{
  "title": {
    "text": "RFC 4379 - Detecting Multi-Protocol Label Switched (MPLS) Data Plane Failures",
    "ja": "RFC 4379 - マルチプロトコルラベルの切り替え（MPLS）データプレーンの障害の検出"
  },
  "number": 4379,
  "created_at": "2023-07-12 13:17:21.737479+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        K. Kompella\nRequest for Comments: 4379                        Juniper Networks, Inc.\nUpdates: 1122                                                 G. Swallow\nCategory: Standards Track                            Cisco Systems, Inc.\n                                                           February 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Detecting Multi-Protocol Label Switched (MPLS) Data Plane Failures",
      "ja": "マルチプロトコルラベルの切り替え（MPLS）データプレーンの障害の検出"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism that can be used to detect data plane failures in Multi-Protocol Label Switching (MPLS) Label Switched Paths (LSPs). There are two parts to this document: information carried in an MPLS \"echo request\" and \"echo reply\" for the purposes of fault detection and isolation, and mechanisms for reliably sending the echo reply.",
      "ja": "このドキュメントでは、マルチプロトコルラベルスイッチング（MPLS）ラベルスイッチ付きパス（LSP）のデータプレーン障害を検出するために使用できるシンプルで効率的なメカニズムについて説明します。このドキュメントには、障害検出と分離の目的のためにMPLS「エコーリクエスト」と「エコー応答」にある情報と、エコー応答を確実に送信するメカニズムの2つの部分があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. Conventions ................................................3\n   1.2. Structure of This Document .................................3\n   1.3. Contributors ...............................................3\n2. Motivation ......................................................4\n   2.1. Use of Address Range 127/8 .................................4\n3. Packet Format ...................................................6\n   3.1. Return Codes ..............................................10\n   3.2. Target FEC Stack ..........................................11\n        3.2.1. LDP IPv4 Prefix ....................................12\n        3.2.2. LDP IPv6 Prefix ....................................13\n        3.2.3. RSVP IPv4 LSP ......................................13\n        3.2.4. RSVP IPv6 LSP ......................................14\n        3.2.5. VPN IPv4 Prefix ....................................14\n        3.2.6. VPN IPv6 Prefix ....................................15\n        3.2.7. L2 VPN Endpoint ....................................16\n           3.2.8. FEC 128 Pseudowire (Deprecated) ....................16\n        3.2.9. FEC 128 Pseudowire (Current) .......................17\n        3.2.10. FEC 129 Pseudowire ................................18\n        3.2.11. BGP Labeled IPv4 Prefix ...........................19\n        3.2.12. BGP Labeled IPv6 Prefix ...........................20\n        3.2.13. Generic IPv4 Prefix ...............................20\n        3.2.14. Generic IPv6 Prefix ...............................21\n        3.2.15. Nil FEC ...........................................21\n   3.3. Downstream Mapping ........................................22\n        3.3.1. Multipath Information Encoding .....................26\n        3.3.2. Downstream Router and Interface ....................28\n   3.4. Pad TLV ...................................................29\n   3.5. Vendor Enterprise Number ..................................29\n   3.6. Interface and Label Stack .................................29\n   3.7. Errored TLVs ..............................................31\n   3.8. Reply TOS Byte TLV ........................................31\n4. Theory of Operation ............................................32\n   4.1. Dealing with Equal-Cost Multi-Path (ECMP) .................32\n   4.2. Testing LSPs That Are Used to Carry MPLS Payloads .........33\n   4.3. Sending an MPLS Echo Request ..............................33\n   4.4. Receiving an MPLS Echo Request ............................34\n        4.4.1. FEC Validation .....................................40\n   4.5. Sending an MPLS Echo Reply ................................41\n   4.6. Receiving an MPLS Echo Reply ..............................42\n   4.7. Issue with VPN IPv4 and IPv6 Prefixes .....................42\n   4.8. Non-compliant Routers .....................................43\n5. References .....................................................43\n   5.1. Normative References ......................................43\n   5.2. Informative References ....................................44\n6. Security Considerations ........................................44\n7. IANA Considerations ............................................46\n   7.1. Message Types, Reply Modes, Return Codes ..................46\n   7.2. TLVs ......................................................47\n8. Acknowledgements ...............................................48",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes a simple and efficient mechanism that can be used to detect data plane failures in MPLS Label Switched Paths (LSPs). There are two parts to this document: information carried in an MPLS \"echo request\" and \"echo reply\", and mechanisms for transporting the echo reply. The first part aims at providing enough information to check correct operation of the data plane, as well as a mechanism to verify the data plane against the control plane, and thereby localize faults. The second part suggests two methods of reliable reply channels for the echo request message for more robust fault isolation.",
      "ja": "このドキュメントでは、MPLSラベルスイッチ付きパス（LSP）のデータプレーン障害を検出するために使用できるシンプルで効率的なメカニズムについて説明します。このドキュメントには、MPLSの「エコーリクエスト」と「エコー応答」にある情報と、エコー応答を輸送するためのメカニズムの2つの部分があります。最初の部分は、データプレーンの正しい動作をチェックするのに十分な情報を提供することと、コントロールプレーンに対するデータプレーンを検証するメカニズムを提供し、それにより障害を局在させることを目的としています。2番目の部分は、より堅牢な障害分離のために、エコー要求メッセージの信頼できる返信チャネルの2つの方法を示唆しています。"
    },
    {
      "indent": 3,
      "text": "An important consideration in this design is that MPLS echo requests follow the same data path that normal MPLS packets would traverse. MPLS echo requests are meant primarily to validate the data plane, and secondarily to verify the data plane against the control plane. Mechanisms to check the control plane are valuable, but are not covered in this document.",
      "ja": "この設計における重要な考慮事項は、MPLSエコー要求が、通常のMPLSパケットが横断するのと同じデータパスに従うことです。MPLSエコーリクエストは、主にデータプレーンを検証することを意味し、次に制御プレーンに対するデータプレーンを検証することを目的としています。コントロールプレーンをチェックするメカニズムは価値がありますが、このドキュメントではカバーされていません。"
    },
    {
      "indent": 3,
      "text": "This document makes special use of the address range 127/8. This is an exception to the behavior defined in RFC 1122 [RFC1122] and updates that RFC. The motivation for this change and the details of this exceptional use are discussed in section 2.1 below.",
      "ja": "このドキュメントは、アドレス範囲127/8を特別に使用しています。これは、RFC 1122 [RFC1122]で定義されている動作の例外であり、RFCを更新します。この変更の動機とこの例外的な使用の詳細については、以下のセクション2.1で説明します。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions",
      "section_title": true,
      "ja": "1.1. 規約"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [KEYWORDS].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119 [キーワード]に記載されているとおりに解釈されます。"
    },
    {
      "indent": 3,
      "text": "The term \"Must Be Zero\" (MBZ) is used in object descriptions for reserved fields. These fields MUST be set to zero when sent and ignored on receipt.",
      "ja": "「ゼロでなければならない」（MBZ）という用語は、予約済みフィールドのオブジェクト説明で使用されます。これらのフィールドは、受信時に送信されて無視されたときにゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Terminology pertaining to L2 and L3 Virtual Private Networks (VPNs) is defined in [RFC4026].",
      "ja": "L2およびL3仮想プライベートネットワーク（VPN）に関連する用語は、[RFC4026]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Since this document refers to the MPLS Time to Live (TTL) far more frequently than the IP TTL, the authors have chosen the convention of using the unqualified \"TTL\" to mean \"MPLS TTL\" and using \"IP TTL\" for the TTL value in the IP header.",
      "ja": "このドキュメントは、IP TTLよりもはるかに頻繁にライブ（TTL）のMPLS時間（TTL）を指しているため、著者は、「MPLS TTL」を平均化してTTL値に「IP TTL」を使用するために、資格のない「TTL」を使用する慣習を選択しています。IPヘッダー。"
    },
    {
      "indent": 0,
      "text": "1.2. Structure of This Document",
      "section_title": true,
      "ja": "1.2. このドキュメントの構造"
    },
    {
      "indent": 3,
      "text": "The body of this memo contains four main parts: motivation, MPLS echo request/reply packet format, LSP ping operation, and a reliable return path. It is suggested that first-time readers skip the actual packet formats and read the Theory of Operation first; the document is structured the way it is to avoid forward references.",
      "ja": "このメモの本体には、MPLSエコーリクエスト/返信パケット形式、LSP ping操作、信頼できるリターンパスの4つの主要な部分が含まれています。初めての読者が実際のパケット形式をスキップし、最初に操作理論を読むことが提案されています。このドキュメントは、フォワード参照を避ける方法で構成されています。"
    },
    {
      "indent": 0,
      "text": "1.3. Contributors",
      "section_title": true,
      "ja": "1.3. 貢献者"
    },
    {
      "indent": 3,
      "text": "The following made vital contributions to all aspects of this document, and much of the material came out of debate and discussion among this group.",
      "ja": "以下は、このドキュメントのすべての側面に重要な貢献をし、資料の多くはこのグループの間で議論と議論から生まれました。"
    },
    {
      "indent": 6,
      "text": "Ronald P. Bonica, Juniper Networks, Inc. Dave Cooper, Global Crossing Ping Pan, Hammerhead Systems Nischal Sheth, Juniper Networks, Inc. Sanjay Wadhwa, Juniper Networks, Inc.",
      "ja": "Ronald P. Bonica、Juniper Networks、Inc。Dave Cooper、Global Crossing Ping Pan、Hammerhead Systems Nischal Sheth、Juniper Networks、Inc。Sanjay Wadhwa、Juniper Networks、Inc。"
    },
    {
      "indent": 0,
      "text": "2. Motivation",
      "section_title": true,
      "ja": "2. モチベーション"
    },
    {
      "indent": 3,
      "text": "When an LSP fails to deliver user traffic, the failure cannot always be detected by the MPLS control plane. There is a need to provide a tool that would enable users to detect such traffic \"black holes\" or misrouting within a reasonable period of time, and a mechanism to isolate faults.",
      "ja": "LSPがユーザートラフィックの配信に失敗した場合、MPLSコントロールプレーンによって障害を常に検出することはできません。ユーザーがそのようなトラフィック「ブラックホール」を検出したり、合理的な期間内に誤ったりすることができるツールを提供する必要があり、障害を分離するメカニズムを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "In this document, we describe a mechanism that accomplishes these goals. This mechanism is modeled after the ping/traceroute paradigm: ping (ICMP echo request [ICMP]) is used for connectivity checks, and traceroute is used for hop-by-hop fault localization as well as path tracing. This document specifies a \"ping\" mode and a \"traceroute\" mode for testing MPLS LSPs.",
      "ja": "このドキュメントでは、これらの目標を達成するメカニズムについて説明します。このメカニズムは、ping/tracerouteパラダイムの後にモデル化されます：ping（icmp echo request [icmp]）は接続チェックに使用され、tracerouteはホップバイホップ障害のローカリゼーションとパストレースに使用されます。このドキュメントは、MPLS LSPをテストするための「Ping」モードと「Traceroute」モードを指定します。"
    },
    {
      "indent": 3,
      "text": "The basic idea is to verify that packets that belong to a particular Forwarding Equivalence Class (FEC) actually end their MPLS path on a Label Switching Router (LSR) that is an egress for that FEC. This document proposes that this test be carried out by sending a packet (called an \"MPLS echo request\") along the same data path as other packets belonging to this FEC. An MPLS echo request also carries information about the FEC whose MPLS path is being verified. This echo request is forwarded just like any other packet belonging to that FEC. In \"ping\" mode (basic connectivity check), the packet should reach the end of the path, at which point it is sent to the control plane of the egress LSR, which then verifies whether it is indeed an egress for the FEC. In \"traceroute\" mode (fault isolation), the packet is sent to the control plane of each transit LSR, which performs various checks that it is indeed a transit LSR for this path; this LSR also returns further information that helps check the control plane against the data plane, i.e., that forwarding matches what the routing protocols determined as the path.",
      "ja": "基本的なアイデアは、特定の転送等価クラス（FEC）に属するパケットが、そのFECの出口であるラベルスイッチングルーター（LSR）のMPLSパスを実際に終了することを確認することです。このドキュメントは、このテストは、このFECに属する他のパケットと同じデータパスに沿ってパケット（「MPLSエコーリクエスト」と呼ばれる）を送信することにより実行されることを提案しています。MPLSエコー要求には、MPLSパスが検証されているFECに関する情報も伝えられます。このエコー要求は、そのFECに属する他のパケットと同じように転送されます。「Ping」モード（基本的な接続チェック）では、パケットはパスの終わりに到達する必要があります。その時点で、Egress LSRの制御プレーンに送信されます。これは、FECの出力であるかどうかを確認します。「Traceroute」モード（障害分離）では、パケットは各トランジットLSRの制御プレーンに送信されます。これは、このパスのトランジットLSRであるというさまざまなチェックを実行します。このLSRは、データプレーンに対してコントロールプレーンを確認するのに役立つさらなる情報、つまり、転送がルーティングプロトコルがパスとして決定したものと一致することも返します。"
    },
    {
      "indent": 3,
      "text": "One way these tools can be used is to periodically ping an FEC to ensure connectivity. If the ping fails, one can then initiate a traceroute to determine where the fault lies. One can also periodically traceroute FECs to verify that forwarding matches the control plane; however, this places a greater burden on transit LSRs and thus should be used with caution.",
      "ja": "これらのツールを使用できる1つの方法は、接続性を確保するためにFECを定期的にpingすることです。pingが故障した場合、障害がどこにあるかを判断するためにトレーサーを開始することができます。また、FECSを定期的にトレーサーして、転送がコントロールプレーンと一致することを確認することもできます。ただし、これにより輸送LSRに大きな負担がかかるため、注意して使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Use of Address Range 127/8",
      "section_title": true,
      "ja": "2.1. アドレス範囲127/8の使用"
    },
    {
      "indent": 3,
      "text": "As described above, LSP ping is intended as a diagnostic tool. It is intended to enable providers of an MPLS-based service to isolate network faults. In particular, LSP ping needs to diagnose situations where the control and data planes are out of sync. It performs this by routing an MPLS echo request packet based solely on its label stack. That is, the IP destination address is never used in a forwarding decision. In fact, the sender of an MPLS echo request packet may not know, a priori, the address of the router at the end of the LSP.",
      "ja": "上記のように、LSP Pingは診断ツールとして意図されています。これは、MPLSベースのサービスのプロバイダーがネットワーク障害を分離できるようにすることを目的としています。特に、LSP Pingは、制御面とデータプレーンが同期していない状況を診断する必要があります。これは、ラベルスタックのみに基づいてMPLSエコーリクエストパケットをルーティングすることで実行します。つまり、IP宛先アドレスは、転送決定に使用されることはありません。実際、MPLSエコーリクエストパケットの送信者は、LSPの最後にあるルーターのアドレスである先験的に知らない場合があります。"
    },
    {
      "indent": 3,
      "text": "Providers of MPLS-based services also need the ability to trace all of the possible paths that an LSP may take. Since most MPLS services are based on IP unicast forwarding, these paths are subject to equal-cost multi-path (ECMP) load sharing.",
      "ja": "MPLSベースのサービスのプロバイダーは、LSPが取る可能性のあるすべてのパスを追跡する機能も必要です。ほとんどのMPLSサービスはIPユニキャスト転送に基づいているため、これらのパスは等しいマルチパス（ECMP）負荷共有の対象となります。"
    },
    {
      "indent": 3,
      "text": "This leads to the following requirements:",
      "ja": "これは、次の要件につながります。"
    },
    {
      "indent": 3,
      "text": "1. Although the LSP in question may be broken in unknown ways, the likelihood of a diagnostic packet being delivered to a user of an MPLS service MUST be held to an absolute minimum.",
      "ja": "1. 問題のLSPは未知の方法で破られる可能性がありますが、MPLSサービスのユーザーに配信される診断パケットの可能性は、絶対的な最小値に保持されなければなりません。"
    },
    {
      "indent": 3,
      "text": "2. If an LSP is broken in such a way that it prematurely terminates, the diagnostic packet MUST NOT be IP forwarded.",
      "ja": "2. LSPが早期に終了するような方法で壊れている場合、診断パケットをIP転送してはなりません。"
    },
    {
      "indent": 3,
      "text": "3. A means of varying the diagnostic packets such that they exercise all ECMP paths is thus REQUIRED.",
      "ja": "3. したがって、すべてのECMPパスを行使するように診断パケットを変化させる手段が必要です。"
    },
    {
      "indent": 3,
      "text": "Clearly, using general unicast addresses satisfies neither of the first two requirements. A number of other options for addresses were considered, including a portion of the private address space (as determined by the network operator) and the newly designated IPv4 link local addresses. Use of the private address space was deemed ineffective since the leading MPLS-based service is an IPv4 Virtual Private Network (VPN). VPNs often use private addresses.",
      "ja": "明らかに、一般的なユニキャストアドレスを使用すると、最初の2つの要件のどちらも満たされません。アドレスの他の多くのオプションが考慮されました。これには、プライベートアドレススペースの一部（ネットワークオペレーターによって決定されています）や、新しく指定されたIPv4リンクローカルアドレスが含まれます。主要なMPLSベースのサービスはIPv4仮想プライベートネットワーク（VPN）であるため、プライベートアドレススペースの使用は効果がないと見なされました。VPNは多くの場合、プライベートアドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "The IPv4 link local addresses are more attractive in that the scope over which they can be forwarded is limited. However, if one were to use an address from this range, it would still be possible for the first recipient of a diagnostic packet that \"escaped\" from a broken LSP to have that address assigned to the interface on which it arrived and thus could mistakenly receive such a packet. Furthermore, the IPv4 link local address range has only recently been allocated. Many deployed routers would forward a packet with an address from that range toward the default route.",
      "ja": "IPv4リンクローカルアドレスは、転送できる範囲が制限されるという点でより魅力的です。ただし、この範囲のアドレスを使用した場合、壊れたLSPから「逃げた」診断パケットの最初の受信者が、そのアドレスを到着したインターフェイスに割り当てて、誤ってそのアドレスを割り当てることができます。そのようなパケットを受け取ります。さらに、IPv4リンクローカルアドレス範囲は最近割り当てられました。多くの展開されたルーターは、その範囲からデフォルトのルートに向かってアドレスを含むパケットを転送します。"
    },
    {
      "indent": 3,
      "text": "The 127/8 range for IPv4 and that same range embedded in as IPv4- mapped IPv6 addresses for IPv6 was chosen for a number of reasons.",
      "ja": "IPv4の127/8範囲と、IPv6のIPv4マッピングIPv6アドレスと同じ範囲が埋め込まれているのは、いくつかの理由で選択されました。"
    },
    {
      "indent": 3,
      "text": "RFC 1122 allocates the 127/8 as \"Internal host loopback address\" and states: \"Addresses of this form MUST NOT appear outside a host.\" Thus, the default behavior of hosts is to discard such packets. This helps to ensure that if a diagnostic packet is misdirected to a host, it will be silently discarded.",
      "ja": "RFC 1122は、127/8を「内部ホストループバックアドレス」として割り当て、次のように述べています。「このフォームのアドレスはホストの外に表示されてはなりません」。したがって、ホストのデフォルトの動作は、そのようなパケットを破棄することです。これにより、診断パケットがホストに誤った方向に向けられている場合、静かに廃棄されるようになります。"
    },
    {
      "indent": 3,
      "text": "RFC 1812 [RFC1812] states:",
      "ja": "RFC 1812 [RFC1812]状態："
    },
    {
      "indent": 6,
      "text": "A router SHOULD NOT forward, except over a loopback interface, any packet that has a destination address on network 127. A router MAY have a switch that allows the network manager to disable these checks. If such a switch is provided, it MUST default to performing the checks.",
      "ja": "ルーターは、ネットワーク127に宛先アドレスを持つパケットを除いて、ループバックインターフェイスを除いて転送してはなりません。ルーターには、ネットワークマネージャーがこれらのチェックを無効にできるスイッチがある場合があります。そのようなスイッチが提供されている場合、デフォルトでチェックを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "This helps to ensure that diagnostic packets are never IP forwarded.",
      "ja": "これにより、診断パケットがIP転送されないようにするのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The 127/8 address range provides 16M addresses allowing wide flexibility in varying addresses to exercise ECMP paths. Finally, as an implementation optimization, the 127/8 provides an easy means of identifying possible LSP packets.",
      "ja": "127/8のアドレス範囲は16mのアドレスを提供し、さまざまなアドレスで幅広い柔軟性を可能にし、ECMPパスを行使します。最後に、実装の最適化として、127/8は、可能なLSPパケットを識別する簡単な手段を提供します。"
    },
    {
      "indent": 0,
      "text": "3. Packet Format",
      "section_title": true,
      "ja": "3. パケット形式"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is a (possibly labeled) IPv4 or IPv6 UDP packet; the contents of the UDP packet have the following format:",
      "ja": "MPLSエコー要求は、（おそらくラベル付き）IPv4またはIPv6 UDPパケットです。UDPパケットの内容には、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Version Number        |         Global Flags          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Message Type |   Reply mode  |  Return Code  | Return Subcode|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sender's Handle                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                        Sequence Number                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                    TimeStamp Sent (seconds)                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  TimeStamp Sent (microseconds)                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                  TimeStamp Received (seconds)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                TimeStamp Received (microseconds)              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                            TLVs ...                           |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Version Number is currently 1. (Note: the version number is to be incremented whenever a change is made that affects the ability of an implementation to correctly parse or process an MPLS echo request/reply. These changes include any syntactic or semantic changes made to any of the fixed fields, or to any Type-Length-Value (TLV) or sub-TLV assignment or format that is defined at a certain version number. The version number may not need to be changed if an optional TLV or sub-TLV is added.)",
      "ja": "バージョン番号は現在1です（注：バージョン番号は、MPLSエコーリクエスト/返信を正しく解析または処理する実装の能力に影響する変更が行われるたびに増加することになります。これらの変更には、構文またはセマンティック変更が含まれます固定フィールドのいずれか、または特定のバージョン番号で定義されているタイプレングス値（TLV）またはサブTLVの割り当てまたは形式に。オプションのTLVまたはサブ - を変更する必要はない場合があります。TLVが追加されます。）"
    },
    {
      "indent": 3,
      "text": "The Global Flags field is a bit vector with the following format:",
      "ja": "グローバルフラグフィールドは、次の形式を備えた少しベクトルです。"
    },
    {
      "indent": 6,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             MBZ             |V|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "One flag is defined for now, the V bit; the rest MUST be set to zero when sending and ignored on receipt.",
      "ja": "今のところ1つのフラグが定義されています。Vビット。残りは、受領時に送信して無視するときにゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The V (Validate FEC Stack) flag is set to 1 if the sender wants the receiver to perform FEC Stack validation; if V is 0, the choice is left to the receiver.",
      "ja": "V（VALIDATE FECスタック）フラグは、送信者が受信機にFECスタック検証を実行することを望んでいる場合に1に設定されます。vが0の場合、選択は受信機に残されます。"
    },
    {
      "indent": 3,
      "text": "The Message Type is one of the following:",
      "ja": "メッセージタイプは次のいずれかです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS echo request\n    2    MPLS echo reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Reply Mode can take one of the following values:",
      "ja": "返信モードは、次の値のいずれかを取得できます。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application level control channel",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An MPLS echo request with 1 (Do not reply) in the Reply Mode field may be used for one-way connectivity tests; the receiving router may log gaps in the Sequence Numbers and/or maintain delay/jitter statistics. An MPLS echo request would normally have 2 (Reply via an IPv4/IPv6 UDP packet) in the Reply Mode field. If the normal IP return path is deemed unreliable, one may use 3 (Reply via an IPv4/IPv6 UDP packet with Router Alert). Note that this requires that all intermediate routers understand and know how to forward MPLS echo replies. The echo reply uses the same IP version number as the received echo request, i.e., an IPv4 encapsulated echo reply is sent in response to an IPv4 encapsulated echo request.",
      "ja": "応答モードフィールドの1（返信しない）を使用したMPLSエコー要求は、一元配置接続テストに使用できます。受信ルーターは、シーケンス番号にギャップを記録したり、遅延/ジッター統計を維持する場合があります。MPLSエコー要求には、通常、応答モードフィールドに2（IPv4/IPv6 UDPパケットを介して返信）があります。通常のIPリターンパスが信頼できないとみなされる場合、3を使用できます（ルーターアラートを備えたIPv4/IPv6 UDPパケットを介して返信）。これには、すべての中間ルーターがMPLSエコー応答を転送する方法を理解し、知ることが必要であることに注意してください。Echo Replyは、受信したEchoリクエストと同じIPバージョン番号を使用します。つまり、IPv4カプセル化されたエコーリクエストに応じてIPv4カプセル化されたエコー応答が送信されます。"
    },
    {
      "indent": 3,
      "text": "Some applications support an IP control channel. One such example is the associated control channel defined in Virtual Circuit Connectivity Verification (VCCV) [VCCV]. Any application that supports an IP control channel between its control entities may set the Reply Mode to 4 (Reply via application level control channel) to ensure that replies use that same channel. Further definition of this codepoint is application specific and thus beyond the scope of this document.",
      "ja": "一部のアプリケーションは、IPコントロールチャネルをサポートしています。そのような例の1つは、仮想回路接続検証（VCCV）[VCCV]で定義された関連する制御チャネルです。制御エンティティ間のIP制御チャネルをサポートするアプリケーションは、返信モードを4（アプリケーションレベル制御チャネル経由で返信）に設定して、返信が同じチャネルを使用するようにすることができます。このコードポイントのさらなる定義はアプリケーション固有であり、したがってこのドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "Return Codes and Subcodes are described in the next section.",
      "ja": "戻りコードとサブコードについては、次のセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "The Sender's Handle is filled in by the sender, and returned unchanged by the receiver in the echo reply (if any). There are no semantics associated with this handle, although a sender may find this useful for matching up requests with replies.",
      "ja": "送信者のハンドルは送信者によって満たされ、エコー応答のレシーバーによって変更されずに返されます（もしあれば）。このハンドルに関連するセマンティクスはありませんが、送信者はこれを返信と一致させるのに役立つ場合があります。"
    },
    {
      "indent": 3,
      "text": "The Sequence Number is assigned by the sender of the MPLS echo request and can be (for example) used to detect missed replies.",
      "ja": "シーケンス番号は、MPLSエコーリクエストの送信者によって割り当てられ、（たとえば）見逃した応答の検出に使用できます。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is the time-of-day (in seconds and microseconds, according to the sender's clock) in NTP format [NTP] when the MPLS echo request is sent. The TimeStamp Received in an echo reply is the time-of-day (according to the receiver's clock) in NTP format that the corresponding echo request was received.",
      "ja": "送信されるタイムスタンプは、MPLSエコーリクエストが送信されたときのNTP形式[NTP]の時間（送信者の時計に応じて、秒とマイクロ秒）です。エコー返信で受け取ったタイムスタンプは、対応するエコー要求を受信したNTP形式の時間（レシーバーの時計に応じて）です。"
    },
    {
      "indent": 3,
      "text": "TLVs (Type-Length-Value tuples) have the following format:",
      "ja": "TLV（型-Length-Value Tulples）には、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type              |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Types are defined below; Length is the length of the Value field in octets. The Value field depends on the Type; it is zero padded to align to a 4-octet boundary. TLVs may be nested within other TLVs, in which case the nested TLVs are called sub-TLVs. Sub-TLVs have independent types and MUST also be 4-octet aligned.",
      "ja": "タイプを以下に定義します。長さは、オクテットの値フィールドの長さです。値フィールドはタイプに依存します。4-OCTET境界に合わせてゼロパッドがあります。TLVは他のTLV内にネストされる場合があります。この場合、ネストされたTLVはサブTLVと呼ばれます。Sub-TLVには独立したタイプがあり、4-OCTETアライメントも必要です。"
    },
    {
      "indent": 3,
      "text": "Two examples follow. The Label Distribution Protocol (LDP) IPv4 FEC sub-TLV has the following format:",
      "ja": "2つの例が続きます。ラベル分布プロトコル（LDP）IPv4 FEC Sub-TLVには、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Type = 1 (LDP IPv4 FEC)    |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Length for this TLV is 5. A Target FEC Stack TLV that contains an LDP IPv4 FEC sub-TLV and a VPN IPv4 prefix sub-TLV has the following format:",
      "ja": "このTLVの長さは5です。LDPIPv4FEC SUB-TLVを含むターゲットFECスタックTLVとVPN IPv4プレフィックスSub-TLVには、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Type = 1 (FEC TLV)       |          Length = 12          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  sub-Type = 1 (LDP IPv4 FEC)  |          Length = 5           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| sub-Type = 6 (VPN IPv4 prefix)|          Length = 13          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A description of the Types and Values of the top-level TLVs for LSP ping are given below:",
      "ja": "LSP pingのトップレベルTLVのタイプと値の説明を以下に示します。"
    },
    {
      "indent": 10,
      "text": "Type #                  Value Field\n------                  -----------\n     1                  Target FEC Stack\n     2                  Downstream Mapping\n     3                  Pad\n     4                  Not Assigned\n     5                  Vendor Enterprise Number\n     6                  Not Assigned\n     7                  Interface and Label Stack\n     8                  Not Assigned\n     9                  Errored TLVs\n    10                  Reply TOS Byte",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Types less than 32768 (i.e., with the high-order bit equal to 0) are mandatory TLVs that MUST either be supported by an implementation or result in the return code of 2 (\"One or more of the TLVs was not understood\") being sent in the echo response.",
      "ja": "32768未満（つまり、高次ビットが0に等しい）未満のタイプは、実装によってサポートされるか、2の戻りコードを得る必要がある必須のTLVです（「1つ以上のTLVは理解されていませんでした」）エコー応答で送信されます。"
    },
    {
      "indent": 3,
      "text": "Types greater than or equal to 32768 (i.e., with the high-order bit equal to 1) are optional TLVs that SHOULD be ignored if the implementation does not understand or support them.",
      "ja": "32768以上（つまり、1つの高次ビットが1に等しい）以上のタイプは、実装がそれらを理解またはサポートしていない場合に無視する必要があるオプションのTLVです。"
    },
    {
      "indent": 0,
      "text": "3.1. Return Codes",
      "section_title": true,
      "ja": "3.1. 返品コード"
    },
    {
      "indent": 3,
      "text": "The Return Code is set to zero by the sender. The receiver can set it to one of the values listed below. The notation <RSC> refers to the Return Subcode. This field is filled in with the stack-depth for those codes that specify that. For all other codes, the Return Subcode MUST be set to zero.",
      "ja": "返品コードは、送信者によってゼロに設定されています。受信者は、以下にリストされている値の1つに設定できます。Notation <RSC>は、返品サブコードを指します。このフィールドには、それを指定するコードのスタックが濃縮されています。他のすべてのコードでは、返品サブコードをゼロに設定する必要があります。"
    },
    {
      "indent": 10,
      "text": "Value    Meaning\n-----    -------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "0 No return code",
      "ja": "0返品コードなし"
    },
    {
      "indent": 14,
      "text": "1 Malformed echo request received",
      "ja": "1つの奇形のエコーリクエストが受信されました"
    },
    {
      "indent": 14,
      "text": "2 One or more of the TLVs was not understood",
      "ja": "2 TLVの1つ以上は理解されていませんでした"
    },
    {
      "indent": 14,
      "text": "3 Replying router is an egress for the FEC at stack-depth <RSC>",
      "ja": "3応答ルーターは、Stack-Depth <RSC>のFECの出口です"
    },
    {
      "indent": 14,
      "text": "4 Replying router has no mapping for the FEC at stack-depth <RSC>",
      "ja": "4応答ルーターには、Stack-Depth <RSC>でFECのマッピングがありません"
    },
    {
      "indent": 14,
      "text": "5 Downstream Mapping Mismatch (See Note 1)",
      "ja": "5ダウンストリームマッピングミスマッチ（注1を参照）"
    },
    {
      "indent": 14,
      "text": "6 Upstream Interface Index Unknown (See Note 1)",
      "ja": "6アップストリームインターフェイスインデックス不明（注1を参照）"
    },
    {
      "indent": 14,
      "text": "7 Reserved",
      "ja": "7予約"
    },
    {
      "indent": 14,
      "text": "8 Label switched at stack-depth <RSC>",
      "ja": "Stack-Depth <RSC>で8ラベルが切り替えられました"
    },
    {
      "indent": 14,
      "text": "9 Label switched but no MPLS forwarding at stack-depth <RSC>",
      "ja": "9ラベルが切り替えられましたが、スタックデプス<RSC>でのMPLS転送はありません"
    },
    {
      "indent": 13,
      "text": "10 Mapping for this FEC is not the given label at stack-depth <RSC>",
      "ja": "このFECの10マッピングは、Stack-Depth <RSC>の指定されたラベルではありません"
    },
    {
      "indent": 13,
      "text": "11 No label entry at stack-depth <RSC>",
      "ja": "11 Stack-Depth <RSC>でのラベルエントリはありません"
    },
    {
      "indent": 13,
      "text": "12 Protocol not associated with interface at FEC stack-depth <RSC>",
      "ja": "FEC Stack-Depth <RSC>のインターフェイスに関連付けられていない12プロトコル"
    },
    {
      "indent": 13,
      "text": "13 Premature termination of ping due to label stack shrinking to a single label",
      "ja": "13ラベルスタックが単一のラベルに縮小するためのPingの早期終了"
    },
    {
      "indent": 3,
      "text": "Note 1",
      "ja": "注1"
    },
    {
      "indent": 6,
      "text": "The Return Subcode contains the point in the label stack where processing was terminated. If the RSC is 0, no labels were processed. Otherwise the packet would have been label switched at depth RSC.",
      "ja": "Return Subcodeには、処理が終了したラベルスタックのポイントが含まれています。RSCが0の場合、ラベルは処理されませんでした。それ以外の場合、パケットは深度RSCでラベルを切り替えられていました。"
    },
    {
      "indent": 0,
      "text": "3.2. Target FEC Stack",
      "section_title": true,
      "ja": "3.2. ターゲットFECスタック"
    },
    {
      "indent": 3,
      "text": "A Target FEC Stack is a list of sub-TLVs. The number of elements is determined by looking at the sub-TLV length fields.",
      "ja": "ターゲットFECスタックは、サブTLVのリストです。要素の数は、サブTLVの長さフィールドを調べることで決定されます。"
    },
    {
      "indent": 6,
      "text": "Sub-Type       Length            Value Field\n--------       ------            -----------\n       1            5            LDP IPv4 prefix\n       2           17            LDP IPv6 prefix\n       3           20            RSVP IPv4 LSP\n       4           56            RSVP IPv6 LSP\n       5                         Not Assigned\n       6           13            VPN IPv4 prefix\n       7           25            VPN IPv6 prefix\n       8           14            L2 VPN endpoint\n       9           10            \"FEC 128\" Pseudowire (deprecated)\n      10           14            \"FEC 128\" Pseudowire\n      11          16+            \"FEC 129\" Pseudowire\n      12            5            BGP labeled IPv4 prefix\n            13           17            BGP labeled IPv6 prefix\n      14            5            Generic IPv4 prefix\n      15           17            Generic IPv6 prefix\n      16            4            Nil FEC",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Other FEC Types will be defined as needed.",
      "ja": "他のFECタイプは、必要に応じて定義されます。"
    },
    {
      "indent": 3,
      "text": "Note that this TLV defines a stack of FECs, the first FEC element corresponding to the top of the label stack, etc.",
      "ja": "このTLVは、ラベルスタックの上部などに対応する最初のFEC要素であるFECのスタックを定義することに注意してください。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have a Target FEC Stack that describes the FEC Stack being tested. For example, if an LSR X has an LDP mapping [LDP] for 192.168.1.1 (say, label 1001), then to verify that label 1001 does indeed reach an egress LSR that announced this prefix via LDP, X can send an MPLS echo request with an FEC Stack TLV with one FEC in it, namely, of type LDP IPv4 prefix, with prefix 192.168.1.1/32, and send the echo request with a label of 1001.",
      "ja": "MPLSエコー要求には、テスト対象のFECスタックを記述するターゲットFECスタックが必要です。たとえば、LSR Xに192.168.1.1（たとえば、ラベル1001）のLDPマッピング[LDP]がある場合、ラベル1001が実際にLDPを介してこのプレフィックスを発表した出力LSRに実際に到達することを確認するために、XはMPLSエコーを送信できます1つのFECを含むFECスタックTLV、つまりタイプLDP IPv4プレフィックスのリクエスト、プレフィックス192.168.1.1/32を使用して、1001のラベルでエコーリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "Say LSR X wanted to verify that a label stack of <1001, 23456> is the right label stack to use to reach a VPN IPv4 prefix [see section 3.2.5] of 10/8 in VPN foo. Say further that LSR Y with loopback address 192.168.1.1 announced prefix 10/8 with Route Distinguisher RD-foo-Y (which may in general be different from the Route Distinguisher that LSR X uses in its own advertisements for VPN foo), label 23456 and BGP next hop 192.168.1.1 [BGP]. Finally, suppose that LSR X receives a label binding of 1001 for 192.168.1.1 via LDP. X has two choices in sending an MPLS echo request: X can send an MPLS echo request with an FEC Stack TLV with a single FEC of type VPN IPv4 prefix with a prefix of 10/8 and a Route Distinguisher of RD-foo-Y. Alternatively, X can send an FEC Stack TLV with two FECs, the first of type LDP IPv4 with a prefix of 192.168.1.1/32 and the second of type of IP VPN with a prefix 10/8 with Route Distinguisher of RD-foo-Y. In either case, the MPLS echo request would have a label stack of <1001, 23456>. (Note: in this example, 1001 is the \"outer\" label and 23456 is the \"inner\" label.)",
      "ja": "LSR Xは、<1001、23456>のラベルスタックが、VPN FOOの10/8のVPN IPv4プレフィックス[セクション3.2.5を参照]に到達するために使用する適切なラベルスタックであることを確認したいと考えていました。さらに、ループバックアドレス192.168.1.1を備えたLSR Yは、ルートdistiutiuser rd-foo-yを使用してプレフィックス10/8を発表しました（これは一般に、LSR XがVPN FOOの独自の広告で使用するルート違い者とは異なる場合があります）、ラベル23456およびBGP次のホップ192.168.1.1 [BGP]。最後に、LSR XがLDPを介して192.168.1.1に対して1001のラベル結合を受け取っていると仮定します。Xには、MPLSエコーリクエストの送信に2つの選択肢があります。Xは、10/8のプレフィックスを備えたタイプVPN IPv4プレフィックスとRD-Foo-Yのルート違いを持つFECスタックTLVを使用してMPLSエコー要求を送信できます。あるいは、Xは2つのFECを持つFECスタックTLVを送信できます。最初のLDP IPv4は192.168.1.1/32のプレフィックスを備えたタイプLDP IPv4、RD-Foo-のルート違いを備えたプレフィックス10/8を持つIP VPNのタイプの2番目は送信できます。Y.どちらの場合でも、MPLSエコーリクエストのラベルスタックは<1001、23456>のラベルスタックがあります。（注：この例では、1001は「外側」ラベルであり、23456は「内側」ラベルです。）"
    },
    {
      "indent": 0,
      "text": "3.2.1. LDP IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.1. LDP IPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv4 Prefix FEC is defined in [LDP]. When an LDP IPv4 prefix is encoded in a label stack, the following format is used. The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, trailing bits SHOULD be set to zero. See [LDP] for an example of a Mapping for an IPv4 FEC.",
      "ja": "IPv4プレフィックスFECは[LDP]で定義されています。LDP IPv4プレフィックスがラベルスタックでエンコードされている場合、次の形式が使用されます。値は、IPv4プレフィックスの4オクテットに続いて、ビットの1オクテットのプレフィックス長さで構成されています。フォーマットを以下に示します。IPv4プレフィックスはネットワークバイトの順序です。接頭辞が32ビットより短い場合、トレーリングビットをゼロに設定する必要があります。IPv4 FECのマッピングの例については、[LDP]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.2. LDP IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.2. LDP IPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The IPv6 Prefix FEC is defined in [LDP]. When an LDP IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero. See [LDP] for an example of a Mapping for an IPv6 FEC.",
      "ja": "IPv6プレフィックスFECは[LDP]で定義されています。LDP IPv6プレフィックスがラベルスタックでエンコードされている場合、次の形式が使用されます。値は、IPv6プレフィックスの16オクテットと、ビットの1オクテットのプレフィックス長さで構成されています。フォーマットを以下に示します。IPv6プレフィックスはネットワークバイトの順序です。接頭辞が128ビットより短い場合、トレーリングビットをゼロに設定する必要があります。IPv6 FECのマッピングの例については、[LDP]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.3. RSVP IPv4 LSP",
      "section_title": true,
      "ja": "3.2.3. RSVP IPv4 LSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The value fields are taken from RFC 3209, sections 4.6.1.1 and 4.6.2.1. See [RSVP-TE].",
      "ja": "値には以下の形式があります。値フィールドは、RFC 3209、セクション4.6.1.1および4.6.2.1から取得されます。[RSVP-TE]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv4 tunnel end point address                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |     Tunnel ID                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv4 tunnel sender address                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.4. RSVP IPv6 LSP",
      "section_title": true,
      "ja": "3.2.4. RSVP IPv6 LSP"
    },
    {
      "indent": 3,
      "text": "The value has the format below. The value fields are taken from RFC 3209, sections 4.6.1.2 and 4.6.2.2. See [RSVP-TE].",
      "ja": "値には以下の形式があります。値フィールドは、RFC 3209、セクション4.6.1.2および4.6.2.2から取得されます。[RSVP-TE]を参照してください。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 IPv6 tunnel end point address                 |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |          Tunnel ID            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                       Extended Tunnel ID                      |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IPv6 tunnel sender address                  |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          Must Be Zero         |            LSP ID             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.5. VPN IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.5. VPN IPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv4 Network Layer Routing Information (NLRI) is defined in [RFC4365]. This document uses the term VPN IPv4 prefix for a VPN-IPv4 NLRI that has been advertised with an MPLS label in BGP. See [BGP-LABEL].",
      "ja": "VPN-IPV4ネットワークレイヤールーティング情報（NLRI）は[RFC4365]で定義されています。このドキュメントでは、BGPのMPLSラベルで宣伝されているVPN-IPV4 NLRIのVPN IPv4プレフィックスという用語を使用しています。[BGP-Label]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv4 prefix is encoded in a label stack, the following format is used. The value field consists of the Route Distinguisher advertised with the VPN IPv4 prefix, the IPv4 prefix (with trailing 0 bits to make 32 bits in all), and a prefix length, as follows:",
      "ja": "VPN IPv4プレフィックスがラベルスタックでエンコードされている場合、次の形式が使用されます。値フィールドは、VPN IPv4プレフィックス、IPv4プレフィックス（すべての32ビットを作成するために0ビットを走る）、およびプレフィックスの長さで宣伝されているルート違いの違いで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv4 prefix                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Route Distinguisher (RD) is an 8-octet identifier; it does not contain any inherent information. The purpose of the RD is solely to allow one to create distinct routes to a common IPv4 address prefix. The encoding of the RD is not important here. When matching this field to the local FEC information, it is treated as an opaque value.",
      "ja": "Route Distinguisher（RD）は8オクテットの識別子です。固有の情報は含まれていません。RDの目的は、一般的なIPv4アドレスプレフィックスへの異なるルートを作成できるようにすることだけです。ここでは、RDのエンコードは重要ではありません。このフィールドをローカルFEC情報に一致させると、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.6. VPN IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.6. VPN IPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "VPN-IPv6 Network Layer Routing Information (NLRI) is defined in [RFC4365]. This document uses the term VPN IPv6 prefix for a VPN-IPv6 NLRI that has been advertised with an MPLS label in BGP. See [BGP-LABEL].",
      "ja": "VPN-IPV6ネットワークレイヤールーティング情報（NLRI）は[RFC4365]で定義されています。このドキュメントでは、BGPのMPLSラベルで宣伝されているVPN-IPV6 NLRIのVPN IPv6プレフィックスという用語を使用しています。[BGP-Label]を参照してください。"
    },
    {
      "indent": 3,
      "text": "When a VPN IPv6 prefix is encoded in a label stack, the following format is used. The value field consists of the Route Distinguisher advertised with the VPN IPv6 prefix, the IPv6 prefix (with trailing 0 bits to make 128 bits in all), and a prefix length, as follows:",
      "ja": "VPN IPv6プレフィックスがラベルスタックでエンコードされている場合、次の形式が使用されます。値フィールドは、VPN IPv6プレフィックス、IPv6プレフィックス（すべての128ビットを作成する0ビットを備えた）、およびプレフィックスの長さで宣伝されているルートの区別者で構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                         IPv6 prefix                           |\n|                                                               |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Route Distinguisher is identical to the VPN IPv4 Prefix RD, except that it functions here to allow the creation of distinct routes to IPv6 prefixes. See section 3.2.5. When matching this field to local FEC information, it is treated as an opaque value.",
      "ja": "ルートの区別器は、VPN IPv4プレフィックスRDと同一ですが、ここではIPv6プレフィックスへの異なるルートの作成を可能にすることを除きます。セクション3.2.5を参照してください。このフィールドをローカルFEC情報に一致させると、不透明な値として扱われます。"
    },
    {
      "indent": 0,
      "text": "3.2.7. L2 VPN Endpoint",
      "section_title": true,
      "ja": "3.2.7. L2 VPNエンドポイント"
    },
    {
      "indent": 3,
      "text": "VPLS stands for Virtual Private LAN Service. The terms VPLS BGP NLRI and VE ID (VPLS Edge Identifier) are defined in [VPLS-BGP]. This document uses the simpler term L2 VPN endpoint when referring to a VPLS BGP NLRI. The Route Distinguisher is an 8-octet identifier used to distinguish information about various L2 VPNs advertised by a node. The VE ID is a 2-octet identifier used to identify a particular node that serves as the service attachment point within a VPLS. The structure of these two identifiers is unimportant here; when matching these fields to local FEC information, they are treated as opaque values. The encapsulation type is identical to the PW Type in section 3.2.8 below.",
      "ja": "VPLSは、仮想プライベートLANサービスの略です。VPLS BGP NLRIおよびVE ID（VPLSエッジ識別子）という用語は、[VPLS-BGP]で定義されています。このドキュメントでは、VPLS BGP NLRIを参照するときに、よりシンプルな用語L2 VPNエンドポイントを使用します。Route Distinguiseerは、ノードで宣伝されているさまざまなL2 VPNに関する情報を区別するために使用される8オクテットの識別子です。VE IDは、VPLS内のサービスアタッチメントポイントとして機能する特定のノードを識別するために使用される2オクセット識別子です。ここでは、これら2つの識別子の構造が重要ではありません。これらのフィールドをローカルFEC情報に一致させると、それらは不透明な値として扱われます。カプセル化タイプは、以下のセクション3.2.8のPWタイプと同じです。"
    },
    {
      "indent": 3,
      "text": "When an L2 VPN endpoint is encoded in a label stack, the following format is used. The value field consists of a Route Distinguisher (8 octets), the sender (of the ping)'s VE ID (2 octets), the receiver's VE ID (2 octets), and an encapsulation type (2 octets), formatted as follows:",
      "ja": "L2 VPNエンドポイントがラベルスタックでエンコードされている場合、次の形式が使用されます。値フィールドは、ルートの区別器（8オクテット）、送信者（Ping）のVE ID（2オクテット）、レシーバーのVE ID（2オクテット）、および次のようにフォーマットされたカプセル化タイプ（2オクテット）で構成されています。："
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Route Distinguisher                      |\n|                          (8 octets)                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Sender's VE ID        |       Receiver's VE ID        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Encapsulation Type       |         Must Be Zero          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.8. FEC 128 Pseudowire (Deprecated)",
      "section_title": true,
      "ja": "3.2.8. FEC 128 PSEUDOWIRE（非推奨）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [PW-CONTROL], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed encapsulation type with the high-order bit set to zero. Both of these fields are treated in this protocol as opaque values.",
      "ja": "FEC 128（0x80）は[PW-Control]で定義され、PW ID（Pseudowire ID）およびPWタイプ（Pseudowire Type）という用語と同様です。PW IDは、非ゼロ32ビット接続IDです。PWタイプは、カプセル化タイプを示す15ビット番号です。ゼロに設定された高次ビットと呼ばれるカプセル化タイプと呼ばれる下のフィールドで正当化されます。これらのフィールドは両方とも、このプロトコルで不透明な値として扱われます。"
    },
    {
      "indent": 3,
      "text": "When an FEC 128 is encoded in a label stack, the following format is used. The value field consists of the remote PE address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128がラベルスタックでエンコードされると、次の形式が使用されます。値フィールドは、リモートPEアドレス（ターゲットを絞ったLDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This FEC is deprecated and is retained only for backward compatibility. Implementations of LSP ping SHOULD accept and process this TLV, but SHOULD send LSP ping echo requests with the new TLV (see next section), unless explicitly configured to use the old TLV.",
      "ja": "このFECは非推奨であり、後方互換性のためにのみ保持されます。LSP Pingの実装は、このTLVを受け入れて処理する必要がありますが、古いTLVを使用するように明示的に構成されていない限り、新しいTLV（次のセクションを参照）でLSP Pingエコー要求を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "An LSR receiving this TLV SHOULD use the source IP address of the LSP echo request to infer the sender's PE address.",
      "ja": "このTLVを受信するLSRは、LSPエコーリクエストのソースIPアドレスを使用して、送信者のPEアドレスを推測する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.9. FEC 128 Pseudowire (Current)",
      "section_title": true,
      "ja": "3.2.9. FEC 128 Pseudowire（現在）"
    },
    {
      "indent": 3,
      "text": "FEC 128 (0x80) is defined in [PW-CONTROL], as are the terms PW ID (Pseudowire ID) and PW Type (Pseudowire Type). A PW ID is a non-zero 32-bit connection ID. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below termed encapsulation type with the high-order bit set to zero.",
      "ja": "FEC 128（0x80）は[PW-Control]で定義され、PW ID（Pseudowire ID）およびPWタイプ（Pseudowire Type）という用語と同様です。PW IDは、非ゼロ32ビット接続IDです。PWタイプは、カプセル化タイプを示す15ビット番号です。ゼロに設定された高次ビットと呼ばれるカプセル化タイプと呼ばれる下のフィールドで正当化されます。"
    },
    {
      "indent": 3,
      "text": "Both of these fields are treated in this protocol as opaque values. When matching these field to the local FEC information, the match MUST be exact.",
      "ja": "これらのフィールドは両方とも、このプロトコルで不透明な値として扱われます。これらのフィールドをローカルFEC情報に一致させる場合、一致は正確でなければなりません。"
    },
    {
      "indent": 3,
      "text": "When an FEC 128 is encoded in a label stack, the following format is used. The value field consists of the sender's PE address (the source address of the targeted LDP session), the remote PE address (the destination address of the targeted LDP session), the PW ID, and the encapsulation type as follows:",
      "ja": "FEC 128がラベルスタックでエンコードされると、次の形式が使用されます。値フィールドは、送信者のPEアドレス（ターゲットを絞ったLDPセッションのソースアドレス）、リモートPEアドレス（ターゲットLDPセッションの宛先アドレス）、PW ID、およびカプセル化タイプで構成されています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE Address                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             PW ID                             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |          Must Be Zero         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.10. FEC 129 Pseudowire",
      "section_title": true,
      "ja": "3.2.10. FEC 129 Pseudowire"
    },
    {
      "indent": 3,
      "text": "FEC 129 (0x81) and the terms PW Type, Attachment Group Identifier (AGI), Attachment Group Identifier Type (AGI Type), Attachment Individual Identifier Type (AII Type), Source Attachment Individual Identifier (SAII), and Target Attachment Individual Identifier (TAII) are defined in [PW-CONTROL]. The PW Type is a 15-bit number indicating the encapsulation type. It is carried right justified in the field below PW Type with the high-order bit set to zero. All the other fields are treated as opaque values and copied directly from the FEC 129 format. All of these values together uniquely define the FEC within the scope of the LDP session identified by the source and remote PE addresses.",
      "ja": "FEC 129（0x81）およびPWタイプ、アタッチメントグループ識別子（AGI）、アタッチメントグループ識別子タイプ（AGIタイプ）、アタッチメント個別識別子タイプ（AIIタイプ）、ソースアタッチメント個体識別子（SAII）、およびターゲットアタッチメント個体識別子（Taii）は[PW-Control]で定義されています。PWタイプは、カプセル化タイプを示す15ビット番号です。PWタイプ以下のフィールドで正当化されているのは、高次ビットがゼロに設定されています。他のすべてのフィールドは不透明な値として扱われ、FEC 129形式から直接コピーされます。これらの値はすべて、ソースとリモートPEアドレスによって識別されたLDPセッションの範囲内でFECを一意に定義します。"
    },
    {
      "indent": 3,
      "text": "When an FEC 129 is encoded in a label stack, the following format is used. The Length of this TLV is 16 + AGI length + SAII length + TAII length. Padding is used to make the total length a multiple of 4; the length of the padding is not included in the Length field.",
      "ja": "FEC 129がラベルスタックでエンコードされると、次の形式が使用されます。このTLVの長さは、16 AGIの長さSAII長Taii長です。パディングは、全長を4の倍数にするために使用されます。パディングの長さは長さフィールドに含まれていません。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                     Sender's PE Address                       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                      Remote PE Address                        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|            PW Type            |   AGI Type    |  AGI Length   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                           AGI Value                           ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  SAII Length  |      SAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    SAII Value (continued)                     ~\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   AII Type    |  TAII Length  |      TAII Value               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n~                    TAII Value (continued)                     ~\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  TAII (cont.) |  0-3 octets of zero padding                   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.11. BGP Labeled IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.11. BGPラベルのIPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv4 prefixes are defined in [BGP-LABEL]. When a BGP labeled IPv4 prefix is encoded in a label stack, the following format is used. The value field consists the IPv4 prefix (with trailing 0 bits to make 32 bits in all), and the prefix length, as follows:",
      "ja": "BGPラベルのIPv4プレフィックスは[BGP-Label]で定義されています。IPv4プレフィックスとラベル付けされたBGPがラベルスタックでエンコードされると、次の形式が使用されます。値フィールドは、IPv4プレフィックス（すべての32ビットを作成するために0ビットを操縦する）とプレフィックスの長さを次のように構成します。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 Prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.12. BGP Labeled IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.12. IPv6プレフィックスとラベル付けされたBGP"
    },
    {
      "indent": 3,
      "text": "BGP labeled IPv6 prefixes are defined in [BGP-LABEL]. When a BGP labeled IPv6 prefix is encoded in a label stack, the following format is used. The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "BGPラベルのIPv6プレフィックスは[BGP-Label]で定義されています。IPv6プレフィックスとラベル付けされたBGPがラベルスタックでエンコードされると、次の形式が使用されます。値は、IPv6プレフィックスの16オクテットと、ビットの1オクテットのプレフィックス長さで構成されています。フォーマットを以下に示します。IPv6プレフィックスはネットワークバイトの順序です。接頭辞が128ビットより短い場合、トレーリングビットをゼロに設定する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.13. Generic IPv4 Prefix",
      "section_title": true,
      "ja": "3.2.13. 汎用IPv4プレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 4 octets of an IPv4 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv4 prefix is in network byte order; if the prefix is shorter than 32 bits, trailing bits SHOULD be set to zero. This FEC is used if the protocol advertising the label is unknown or may change during the course of the LSP. An example is an inter-AS LSP that may be signaled by LDP in one Autonomous System (AS), by RSVP-TE [RSVP-TE] in another AS, and by BGP between the ASes, such as is common for inter-AS VPNs.",
      "ja": "値は、IPv4プレフィックスの4オクテットに続いて、ビットの1オクテットのプレフィックス長さで構成されています。フォーマットを以下に示します。IPv4プレフィックスはネットワークバイトの順序です。接頭辞が32ビットより短い場合、トレーリングビットをゼロに設定する必要があります。このFECは、ラベルを広告するプロトコルが不明であるか、LSPの過程で変更される場合がある場合に使用されます。例は、あるAS（AS）、別のASのRSVP-TE [RSVP-TE]、およびASの間のBGPによって、ある自律システム（AS）、RSVP-TE [RSVP-TE]によってLDPがSIGNALによってシグナルにされる可能性があるLSP間です。vpns。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv4 prefix                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.14. Generic IPv6 Prefix",
      "section_title": true,
      "ja": "3.2.14. 汎用IPv6プレフィックス"
    },
    {
      "indent": 3,
      "text": "The value consists of 16 octets of an IPv6 prefix followed by 1 octet of prefix length in bits; the format is given below. The IPv6 prefix is in network byte order; if the prefix is shorter than 128 bits, the trailing bits SHOULD be set to zero.",
      "ja": "値は、IPv6プレフィックスの16オクテットと、ビットの1オクテットのプレフィックス長さで構成されています。フォーマットを以下に示します。IPv6プレフィックスはネットワークバイトの順序です。接頭辞が128ビットより短い場合、トレーリングビットをゼロに設定する必要があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                          IPv6 prefix                          |\n|                          (16 octets)                          |\n|                                                               |\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Prefix Length |         Must Be Zero                          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.15. Nil FEC",
      "section_title": true,
      "ja": "3.2.15. nilfec"
    },
    {
      "indent": 3,
      "text": "At times, labels from the reserved range, e.g., Router Alert and Explicit-null, may be added to the label stack for various diagnostic purposes such as influencing load-balancing. These labels may have no explicit FEC associated with them. The Nil FEC Stack is defined to allow a Target FEC Stack sub-TLV to be added to the Target FEC Stack to account for such labels so that proper validation can still be performed.",
      "ja": "時には、予約範囲のラベル、例えばルーターアラートや明示的なヌルが、負荷分散に影響を与えるなどのさまざまな診断目的でラベルスタックに追加することができます。これらのラベルには、それらに関連する明示的なFECがない場合があります。NIL FECスタックは、適切な検証を実行できるように、ターゲットFECスタックSub-TLVをターゲットFECスタックに追加できるように定義されています。"
    },
    {
      "indent": 3,
      "text": "The Length is 4. Labels are 20-bit values treated as numbers.",
      "ja": "長さは4です。ラベルは、数値として扱われる20ビット値です。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                 Label                 |          MBZ          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Label is the actual label value inserted in the label stack; the MBZ fields MUST be zero when sent and ignored on receipt.",
      "ja": "ラベルは、ラベルスタックに挿入された実際のラベル値です。MBZフィールドは、受信時に送信されて無視されるとゼロでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.3. Downstream Mapping",
      "section_title": true,
      "ja": "3.3. ダウンストリームマッピング"
    },
    {
      "indent": 3,
      "text": "The Downstream Mapping object is a TLV that MAY be included in an echo request message. Only one Downstream Mapping object may appear in an echo request. The presence of a Downstream Mapping object is a request that Downstream Mapping objects be included in the echo reply. If the replying router is the destination of the FEC, then a Downstream Mapping TLV SHOULD NOT be included in the echo reply. Otherwise the replying router SHOULD include a Downstream Mapping object for each interface over which this FEC could be forwarded. For a more precise definition of the notion of \"downstream\", see section 3.3.2, \"Downstream Router and Interface\".",
      "ja": "ダウンストリームマッピングオブジェクトは、エコーリクエストメッセージに含まれる可能性のあるTLVです。Echoリクエストには、1つのダウンストリームマッピングオブジェクトのみが表示されます。ダウンストリームマッピングオブジェクトの存在は、下流のマッピングオブジェクトをECHO応答に含めるリクエストです。応答ルーターがFECの宛先である場合、下流のマッピングTLVをEcho応答に含めないでください。それ以外の場合、応答ルーターには、このFECを転送できる各インターフェイスのダウンストリームマッピングオブジェクトを含める必要があります。「下流」の概念のより正確な定義については、セクション3.3.2、「ダウンストリームルーターとインターフェイス」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The Length is K + M + 4*N octets, where M is the Multipath Length, and N is the number of Downstream Labels. Values for K are found in the description of Address Type below. The Value field of a Downstream Mapping has the following format:",
      "ja": "長さはk m 4*nオクテットで、mはマルチパス長、nは下流ラベルの数です。Kの値は、以下のアドレスタイプの説明にあります。ダウンストリームマッピングの値フィールドには、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               MTU             | Address Type  |    DS Flags   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Downstream IP Address (4 or 16 octets)            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Downstream Interface Address (4 or 16 octets)         |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Multipath Type| Depth Limit   |        Multipath Length       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                     (Multipath Information)                   .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|               Downstream Label                |    Protocol   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Maximum Transmission Unit (MTU)",
      "ja": "最大トランスミッションユニット（MTU）"
    },
    {
      "indent": 6,
      "text": "The MTU is the size in octets of the largest MPLS frame (including label stack) that fits on the interface to the Downstream LSR.",
      "ja": "MTUは、下流のLSRへのインターフェイスに適合する最大のMPLSフレーム（ラベルスタックを含む）のオクテットのサイズです。"
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the Downstream IP Address and Downstream Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "アドレスタイプは、インターフェイスに番号が付けられているか、番号が付けられていないかを示します。また、下流のIPアドレスとダウンストリームインターフェイスフィールドの長さも決定します。TLVの最初の部分の結果の合計は、以下の表に「kオクテット」としてリストされています。アドレスタイプは、次の値のいずれかに設定されています。"
    },
    {
      "indent": 9,
      "text": "Type #        Address Type           K Octets\n------        ------------           --------\n     1        IPv4 Numbered                16\n     2        IPv4 Unnumbered              16\n     3        IPv6 Numbered                40\n     4        IPv6 Unnumbered              28",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DS Flags",
      "ja": "DSフラグ"
    },
    {
      "indent": 6,
      "text": "The DS Flags field is a bit vector with the following format:",
      "ja": "DSフラグフィールドは、次の形式でビットベクトルです。"
    },
    {
      "indent": 9,
      "text": " 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n| Rsvd(MBZ) |I|N|\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Two flags are defined currently, I and N. The remaining flags MUST be set to zero when sending and ignored on receipt.",
      "ja": "現在、2つのフラグが定義されています。IとN。"
    },
    {
      "indent": 6,
      "text": "Flag  Name and Meaning\n----  ----------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "I Interface and Label Stack Object Request",
      "ja": "スタックオブジェクトリクエストをインターフェイスしてラベル付けします"
    },
    {
      "indent": 12,
      "text": "When this flag is set, it indicates that the replying router SHOULD include an Interface and Label Stack Object in the echo reply message.",
      "ja": "このフラグが設定されている場合、応答ルーターにはエコー応答メッセージにインターフェイスとラベルスタックオブジェクトを含める必要があることが示されます。"
    },
    {
      "indent": 9,
      "text": "N Treat as a Non-IP Packet",
      "ja": "n非IPパケットとして扱います"
    },
    {
      "indent": 12,
      "text": "Echo request messages will be used to diagnose non-IP flows. However, these messages are carried in IP packets. For a router that alters its ECMP algorithm based on the FEC or deep packet examination, this flag requests that the router treat this as it would if the determination of an IP payload had failed.",
      "ja": "エコーリクエストメッセージは、非IPフローの診断に使用されます。ただし、これらのメッセージはIPパケットで伝えられています。FECまたはディープパケット試験に基づいてECMPアルゴリズムを変更するルーターの場合、このフラグは、IPペイロードの決定が失敗した場合にルーターがこれを扱うことを要求します。"
    },
    {
      "indent": 3,
      "text": "Downstream IP Address and Downstream Interface Address",
      "ja": "ダウンストリームIPアドレスとダウンストリームインターフェイスアドレス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスは、4オクテットでエンコードされています。IPv6アドレスは16オクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is numbered, then the Address Type MUST be set to IPv4 or IPv6, the Downstream IP Address MUST be set to either the downstream LSR's Router ID or the interface address of the downstream LSR, and the Downstream Interface Address MUST be set to the downstream LSR's interface address.",
      "ja": "ダウンストリームLSRへのインターフェイスに番号が付けられている場合、アドレスタイプはIPv4またはIPv6に設定する必要があります。下流のIPアドレスは、下流のLSRのルーターIDまたはダウンストリームLSRのインターフェイスアドレス、およびダウンストリームインターフェイスアドレスアドレスのいずれかに設定する必要があります。下流のLSRのインターフェイスアドレスに設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "If the interface to the downstream LSR is unnumbered, the Address Type MUST be IPv4 Unnumbered or IPv6 Unnumbered, the Downstream IP Address MUST be the downstream LSR's Router ID, and the Downstream Interface Address MUST be set to the index assigned by the upstream LSR to the interface.",
      "ja": "ダウンストリームLSRへのインターフェイスが番号が付けられていない場合、アドレスタイプはIPv4またはIPv6の番号なしでなければならず、ダウンストリームIPアドレスはダウンストリームLSRのルーターIDでなければならず、ダウンストリームインターフェイスアドレスは上流のLSRによって割り当てられたインデックスに設定する必要があります。インターフェイス。"
    },
    {
      "indent": 6,
      "text": "If an LSR does not know the IP address of its neighbor, then it MUST set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it must set the Downstream IP Address to 127.0.0.1; for IPv6 the address is set to 0::1. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with either of these addresses in the Downstream IP Address field, this indicates that it MUST bypass interface verification but continue with label validation.",
      "ja": "LSRが近隣のIPアドレスがわからない場合、アドレスタイプをIPv4またはIPv6の数のいずれかに設定する必要があります。IPv4の場合、下流のIPアドレスを127.0.0.1に設定する必要があります。IPv6の場合、アドレスは0 :: 1に設定されています。どちらの場合も、インターフェイスインデックスは0に設定する必要があります。LSRが下流のIPアドレスフィールドにこれらのアドレスのいずれかを含むエコー要求パケットを受信した場合、これはインターフェイスの検証をバイパスする必要があるが、ラベル検証を続ける必要があることを示します。"
    },
    {
      "indent": 6,
      "text": "If the originator of an Echo Request packet wishes to obtain Downstream Mapping information but does not know the expected label stack, then it SHOULD set the Address Type to either IPv4 Unnumbered or IPv6 Unnumbered. For IPv4, it MUST set the Downstream IP Address to 224.0.0.2; for IPv6 the address MUST be set to FF02::2. In both cases, the interface index MUST be set to 0. If an LSR receives an Echo Request packet with the all-routers multicast address, then this indicates that it MUST bypass both interface and label stack validation, but return Downstream Mapping TLVs using the information provided.",
      "ja": "Echo Request Packetのオリジネーターが、下流のマッピング情報を取得したいが、予想されるラベルスタックがわからない場合は、アドレスタイプをIPv4またはIPv6の番号なしのいずれかに設定する必要があります。IPv4の場合、下流のIPアドレスを224.0.0.2に設定する必要があります。IPv6の場合、アドレスはFF02 :: 2に設定する必要があります。どちらの場合も、インターフェイスインデックスは0に設定する必要があります。LSRがオールルーターのマルチキャストアドレスでエコーリクエストパケットを受信した場合、これはインターフェイスとラベルスタック検証の両方をバイパスする必要があることを示しますが、TLVを使用してダウンストリームマッピングTLVを返します。提供された情報。"
    },
    {
      "indent": 3,
      "text": "Multipath Type",
      "ja": "マルチパスタイプ"
    },
    {
      "indent": 6,
      "text": "The following Multipath Types are defined:",
      "ja": "次のマルチパスタイプが定義されています。"
    },
    {
      "indent": 6,
      "text": "Key   Type                  Multipath Information\n---   ----------------      ---------------------\n 0    no multipath          Empty (Multipath Length = 0)\n 2    IP address            IP addresses\n 4    IP address range      low/high address pairs\n 8    Bit-masked IP         IP address prefix and bit mask\n        address set\n 9    Bit-masked label set  Label prefix and bit mask",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Type 0 indicates that all packets will be forwarded out this one interface.",
      "ja": "タイプ0は、すべてのパケットがこの1つのインターフェイスを転送されることを示しています。"
    },
    {
      "indent": 6,
      "text": "Types 2, 4, 8, and 9 specify that the supplied Multipath Information will serve to exercise this path.",
      "ja": "タイプ2、4、8、および9は、提供されたマルチパス情報がこのパスを行使するのに役立つことを指定します。"
    },
    {
      "indent": 3,
      "text": "Depth Limit",
      "ja": "深さ制限"
    },
    {
      "indent": 6,
      "text": "The Depth Limit is applicable only to a label stack and is the maximum number of labels considered in the hash; this SHOULD be set to zero if unspecified or unlimited.",
      "ja": "深さ制限は、ラベルスタックにのみ適用され、ハッシュで考慮されるラベルの最大数です。これは、不特定または無制限の場合はゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Multipath Length",
      "ja": "マルチパス長"
    },
    {
      "indent": 6,
      "text": "The length in octets of the Multipath Information.",
      "ja": "マルチパス情報のオクテットの長さ。"
    },
    {
      "indent": 3,
      "text": "Multipath Information",
      "ja": "マルチパス情報"
    },
    {
      "indent": 6,
      "text": "Address or label values encoded according to the Multipath Type. See the next section below for encoding details.",
      "ja": "マルチパスタイプに従ってエンコードされたアドレスまたはラベルの値。エンコードの詳細については、以下の次のセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Downstream Label(s)",
      "ja": "ダウンストリームラベル"
    },
    {
      "indent": 6,
      "text": "The set of labels in the label stack as it would have appeared if this router were forwarding the packet through this interface. Any Implicit Null labels are explicitly included. Labels are treated as numbers, i.e., they are right justified in the field.",
      "ja": "このルーターがこのインターフェイスを介してパケットを転送している場合に表示されるラベルスタック内のラベルのセット。暗黙のヌルラベルは明示的に含まれています。ラベルは数字として扱われます。つまり、フィールドで正当化されています。"
    },
    {
      "indent": 6,
      "text": "A Downstream Label is 24 bits, in the same format as an MPLS label minus the TTL field, i.e., the MSBit of the label is bit 0, the LSBit is bit 19, the EXP bits are bits 20-22, and bit 23 is the S bit. The replying router SHOULD fill in the EXP and S bits; the LSR receiving the echo reply MAY choose to ignore these bits.",
      "ja": "下流ラベルは24ビットで、MPLSラベルからTTLフィールドを差し引いたものと同じ形式です。つまり、ラベルのMSBITはビット0、LSBITはビット19、EXPビットはビット20-22、ビット23はビットです。sビット。応答ルーターは、EXPとSビットを埋める必要があります。エコー応答を受け取るLSRは、これらのビットを無視することを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "Protocol",
      "ja": "プロトコル"
    },
    {
      "indent": 6,
      "text": "The Protocol is taken from the following table:",
      "ja": "プロトコルは次の表から取得されます。"
    },
    {
      "indent": 6,
      "text": "Protocol #        Signaling Protocol\n----------        ------------------\n         0        Unknown\n         1        Static\n         2        BGP\n         3        LDP\n         4        RSVP-TE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.3.1. Multipath Information Encoding",
      "section_title": true,
      "ja": "3.3.1. マルチパス情報エンコーディング"
    },
    {
      "indent": 3,
      "text": "The Multipath Information encodes labels or addresses that will exercise this path. The Multipath Information depends on the Multipath Type. The contents of the field are shown in the table above. IPv4 addresses are drawn from the range 127/8; IPv6 addresses are drawn from the range 0:0:0:0:0:FFFF:127/104. Labels are treated as numbers, i.e., they are right justified in the field. For Type 4, ranges indicated by Address pairs MUST NOT overlap and MUST be in ascending sequence.",
      "ja": "マルチパス情報は、このパスを行使するラベルまたはアドレスをエンコードします。マルチパス情報は、マルチパスタイプに依存します。フィールドの内容を上の表に示します。IPv4アドレスは、範囲127/8から描画されます。IPv6アドレスは、範囲0：0：0：0：0：FFFF：127/104から描画されます。ラベルは数字として扱われます。つまり、フィールドで正当化されています。タイプ4の場合、アドレスペアで示される範囲は重複してはならず、昇順のシーケンスでなければなりません。"
    },
    {
      "indent": 3,
      "text": "Type 8 allows a more dense encoding of IP addresses. The IP prefix is formatted as a base IP address with the non-prefix low-order bits set to zero. The maximum prefix length is 27. Following the prefix is a mask of length 2^(32-prefix length) bits for IPv4 and 2^(128- prefix length) bits for IPv6. Each bit set to 1 represents a valid address. The address is the base IPv4 address plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. For example, the IPv4 addresses 127.2.1.0, 127.2.1.5-127.2.1.15, and 127.2.1.20-127.2.1.29 would be encoded as follows:",
      "ja": "タイプ8を使用すると、IPアドレスをより密なエンコードできます。IPプレフィックスは、非Prefix低次ビットがゼロに設定されたベースIPアドレスとしてフォーマットされています。最大プレフィックスの長さは27です。プレフィックスに続くのは、長さ2^（32-prefix長）ビットのマスクと、IPv6の2^（128-プレフィックス長）ビットです。1に設定された各ビットは、有効なアドレスを表します。アドレスは、ベースIPv4アドレスと、ゼロでビットに左から右に番号が付けられているマスク内のビットの位置です。たとえば、IPv4は127.2.1.0、127.2.1.5-127.2.1.15、および127.2.1.20-127.2.2.1.29に留まります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Those same addresses embedded in IPv6 would be encoded as follows:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 1 1 1 1 1 1 1 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 1 1 1 1 1 1 1 1 1 1 0 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Type 9 allows a more dense encoding of labels. The label prefix is formatted as a base label value with the non-prefix low-order bits set to zero. The maximum prefix (including leading zeros due to encoding) length is 27. Following the prefix is a mask of length 2^(32-prefix length) bits. Each bit set to one represents a valid label. The label is the base label plus the position of the bit in the mask where the bits are numbered left to right beginning with zero. Label values of all the odd numbers between 1152 and 1279 would be encoded as follows:",
      "ja": "タイプ9を使用すると、ラベルのより密度の高いエンコードが可能になります。ラベルプレフィックスは、非プレフィックスの低次ビットがゼロに設定されたベースラベル値としてフォーマットされています。最大接頭辞（エンコードによる先頭ゼロを含む）長さは27です。プレフィックスに続くのは、長さ2^（32ペルフィックスの長さ）ビットのマスクです。1つに設定する各ビットは、有効なラベルを表します。ラベルは、ベースラベルに加えて、マスク内のビットの位置であり、ビットにはゼロで左から右に番号が付けられています。1152から1279の間のすべての奇数数のラベル値は、次のようにエンコードされます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 0\n0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0| +-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0 1 0 1 0 1 0 1 0 1\n0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1| +-+-+-+-+-+-+-+-+-\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the received Multipath Information is non-null, the labels and IP addresses MUST be picked from the set provided. If none of these labels or addresses map to a particular downstream interface, then for that interface, the type MUST be set to 0. If the received Multipath Information is null (i.e., Multipath Length = 0, or for Types 8 and 9, a mask of all zeros), the type MUST be set to 0.",
      "ja": "受信したマルチパス情報が非ヌルの場合、提供されたセットからラベルとIPアドレスを選択する必要があります。これらのラベルまたはアドレスが特定のダウンストリームインターフェイスにマッピングされていない場合、そのインターフェイスについては、タイプを0に設定する必要があります。すべてのゼロのマスク）、タイプは0に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "For example, suppose LSR X at hop 10 has two downstream LSRs, Y and Z, for the FEC in question. The received X could return Multipath Type 4, with low/high IP addresses of 127.1.1.1->127.1.1.255 for downstream LSR Y and 127.2.1.1->127.2.1.255 for downstream LSR Z. The head end reflects this information to LSR Y. Y, which has three downstream LSRs, U, V, and W, computes that 127.1.1.1->127.1.1.127 would go to U and 127.1.1.128-> 127.1.1.255 would go to V. Y would then respond with 3 Downstream Mappings: to U, with Multipath Type 4 (127.1.1.1->127.1.1.127); to V, with Multipath Type 4 (127.1.1.127->127.1.1.255); and to W, with Multipath Type 0.",
      "ja": "たとえば、ホップ10のLSR Xには、問題のFECの2つの下流LSRS、YとZがあるとします。受信したXは、下流のLSR Yおよび127.2.1.1-> 127.2.1.1-> 127.1.1.1-> 127.2.1.255の低/高IPアドレスが127.1.1.1-> 127.1.1.1.255で、マルチパスタイプ4を返すことができます。Y. Yは、3つの下流のLSR、U、V、およびWを備えたY. Yは、127.1.1.1.1-> 127.1.1.127がUに移動し、127.1.1.128-> 127.1.1.1.255がVに行きます。3ダウンストリームマッピング：uに、マルチパスタイプ4（127.1.1.1-> 127.1.1.127）;v、マルチパスタイプ4（127.1.1.127-> 127.1.1.255）;そして、wに、マルチパスタイプ0で。"
    },
    {
      "indent": 3,
      "text": "Note that computing Multipath Information may impose a significant processing burden on the receiver. A receiver MAY thus choose to process a subset of the received prefixes. The sender, on receiving a reply to a Downstream Mapping with partial information, SHOULD assume that the prefixes missing in the reply were skipped by the receiver, and MAY re-request information about them in a new echo request.",
      "ja": "コンピューティングマルチパス情報は、受信者に重大な処理負担を課す可能性があることに注意してください。したがって、受信者は、受信したプレフィックスのサブセットを処理することを選択できます。送信者は、部分的な情報を使用した下流マッピングへの返信を受信する際に、返信に欠落しているプレフィックスが受信機によってスキップされたと仮定し、新しいエコーリクエストでそれらに関する情報を再リケートする場合があります。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Downstream Router and Interface",
      "section_title": true,
      "ja": "3.3.2. ダウンストリームルーターとインターフェイス"
    },
    {
      "indent": 3,
      "text": "The notion of \"downstream router\" and \"downstream interface\" should be explained. Consider an LSR X. If a packet that was originated with TTL n>1 arrived with outermost label L and TTL=1 at LSR X, X must be able to compute which LSRs could receive the packet if it was originated with TTL=n+1, over which interface the request would arrive and what label stack those LSRs would see. (It is outside the scope of this document to specify how this computation is done.) The set of these LSRs/interfaces consists of the downstream routers/interfaces (and their corresponding labels) for X with respect to L. Each pair of downstream router and interface requires a separate Downstream Mapping to be added to the reply.",
      "ja": "「ダウンストリームルーター」と「ダウンストリームインターフェイス」の概念を説明する必要があります。LSR Xを検討してください。TTLn> 1で発生したパケットがLSR xで最も外側のラベルLとTTL = 1で到着した場合、xはTTL = n 1で発生した場合、どのLSRがパケットを受信できるかを計算できる必要があります。、リクエストが到着するインターフェイスと、それらのLSRが表示されるラベルスタック。（このドキュメントの範囲の外側にあるこの計算の実行方法を指定します。）これらのLSRS/インターフェイスのセットは、L。下流ルーターの各ペアのペアに関するXの下流のルーター/インターフェイス（およびそれらの対応するラベル）で構成されています。インターフェイスでは、応答に別のダウンストリームマッピングを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "The case where X is the LSR originating the echo request is a special case. X needs to figure out what LSRs would receive the MPLS echo request for a given FEC Stack that X originates with TTL=1.",
      "ja": "xがエコー要求を発信するLSRである場合は特別なケースです。Xは、XがTTL = 1で発生する特定のFECスタックのMPLSエコー要求を受信するLSRを把握する必要があります。"
    },
    {
      "indent": 3,
      "text": "The set of downstream routers at X may be alternative paths (see the discussion below on ECMP) or simultaneous paths (e.g., for MPLS multicast). In the former case, the Multipath Information is used as a hint to the sender as to how it may influence the choice of these alternatives.",
      "ja": "Xの下流ルーターのセットは、代替パス（ECMPに関する以下の説明を参照）または同時パス（MPLSマルチキャストなど）です。前者の場合、マルチパス情報は、これらの代替案の選択にどのように影響するかについての送信者へのヒントとして使用されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Pad TLV",
      "section_title": true,
      "ja": "3.4. パッドTLV"
    },
    {
      "indent": 3,
      "text": "The value part of the Pad TLV contains a variable number (>= 1) of octets. The first octet takes values from the following table; all the other octets (if any) are ignored. The receiver SHOULD verify that the TLV is received in its entirety, but otherwise ignores the contents of this TLV, apart from the first octet.",
      "ja": "パッドTLVの値部分には、オクテットの変数数（> = 1）が含まれています。最初のオクテットは、次の表から値を取得します。他のすべてのオクテット（もしあれば）は無視されます。受信者は、TLVが完全に受信されていることを確認する必要がありますが、それ以外の場合は、最初のオクテットとは別に、このTLVの内容を無視します。"
    },
    {
      "indent": 6,
      "text": "Value        Meaning\n-----        -------\n    1        Drop Pad TLV from reply\n    2        Copy Pad TLV to reply\n3-255        Reserved for future use",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5. Vendor Enterprise Number",
      "section_title": true,
      "ja": "3.5. ベンダーエンタープライズ番号"
    },
    {
      "indent": 3,
      "text": "SMI Private Enterprise Numbers are maintained by IANA. The Length is always 4; the value is the SMI Private Enterprise code, in network octet order, of the vendor with a Vendor Private extension to any of the fields in the fixed part of the message, in which case this TLV MUST be present. If none of the fields in the fixed part of the message have Vendor Private extensions, inclusion of this TLV is OPTIONAL. Vendor Private ranges for Message Types, Reply Modes, and Return Codes have been defined. When any of these are used, the Vendor Enterprise Number TLV MUST be included in the message.",
      "ja": "SMIプライベートエンタープライズ番号はIANAによって維持されています。長さは常に4です。値は、ベンダーのSMIプライベートエンタープライズコード、ネットワークオクテットの順序で、メッセージの固定部分のフィールドのいずれかに対するベンダープライベートエクステンションを備えたベンダーの順序です。この場合、このTLVを存在する必要があります。メッセージの固定部分のフィールドのいずれもベンダープライベートエクステンションを持っていない場合、このTLVを含めることはオプションです。メッセージタイプ、返信モード、および返信コードのベンダープライベート範囲が定義されています。これらのいずれかを使用する場合、ベンダーエンタープライズ番号TLVをメッセージに含める必要があります。"
    },
    {
      "indent": 0,
      "text": "3.6. Interface and Label Stack",
      "section_title": true,
      "ja": "3.6. インターフェイスとラベルスタック"
    },
    {
      "indent": 3,
      "text": "The Interface and Label Stack TLV MAY be included in a reply message to report the interface on which the request message was received and the label stack that was on the packet when it was received. Only one such object may appear. The purpose of the object is to allow the upstream router to obtain the exact interface and label stack information as it appears at the replying LSR.",
      "ja": "インターフェイスとラベルスタックTLVを返信メッセージに含めて、リクエストメッセージが受信されたインターフェイスと、受信時にパケットにあるラベルスタックを報告できます。そのようなオブジェクトは1つだけ表示されます。オブジェクトの目的は、上流のルーターが正確なインターフェイスを取得し、応答LSRに表示されるようにスタック情報をラベル付けできるようにすることです。"
    },
    {
      "indent": 3,
      "text": "The Length is K + 4*N octets; N is the number of labels in the label stack. Values for K are found in the description of Address Type below. The Value field of a Downstream Mapping has the following format:",
      "ja": "長さはk 4*nオクテットです。nは、ラベルスタック内のラベルの数です。Kの値は、以下のアドレスタイプの説明にあります。ダウンストリームマッピングの値フィールドには、次の形式があります。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Address Type  |             Must Be Zero                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   IP Address (4 or 16 octets)                 |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                   Interface (4 or 16 octets)                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n.                                                               .\n.                                                               .\n.                          Label Stack                          .\n.                                                               .\n.                                                               .\n.                                                               .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Address Type",
      "ja": "アドレスタイプ"
    },
    {
      "indent": 6,
      "text": "The Address Type indicates if the interface is numbered or unnumbered. It also determines the length of the IP Address and Interface fields. The resulting total for the initial part of the TLV is listed in the table below as \"K Octets\". The Address Type is set to one of the following values:",
      "ja": "アドレスタイプは、インターフェイスに番号が付けられているか、番号が付けられていないかを示します。また、IPアドレスとインターフェイスフィールドの長さも決定します。TLVの最初の部分の結果の合計は、以下の表に「kオクテット」としてリストされています。アドレスタイプは、次の値のいずれかに設定されています。"
    },
    {
      "indent": 9,
      "text": "Type #        Address Type           K Octets\n------        ------------           --------\n     1        IPv4 Numbered                12\n     2        IPv4 Unnumbered              12\n     3        IPv6 Numbered                36\n     4        IPv6 Unnumbered              24",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IP Address and Interface",
      "ja": "IPアドレスとインターフェイス"
    },
    {
      "indent": 6,
      "text": "IPv4 addresses and interface indices are encoded in 4 octets; IPv6 addresses are encoded in 16 octets.",
      "ja": "IPv4アドレスとインターフェイスインデックスは、4オクテットでエンコードされています。IPv6アドレスは16オクテットでエンコードされています。"
    },
    {
      "indent": 6,
      "text": "If the interface upon which the echo request message was received is numbered, then the Address Type MUST be set to IPv4 or IPv6, the IP Address MUST be set to either the LSR's Router ID or the interface address, and the Interface MUST be set to the interface address.",
      "ja": "Echo要求メッセージが受信されたインターフェイスに番号が付けられている場合、アドレスタイプをIPv4またはIPv6に設定する必要があります。IPアドレスはLSRのルーターIDまたはインターフェイスアドレスのいずれかに設定する必要があり、インターフェイスをに設定する必要があります。インターフェイスアドレス。"
    },
    {
      "indent": 6,
      "text": "If the interface is unnumbered, the Address Type MUST be either IPv4 Unnumbered or IPv6 Unnumbered, the IP Address MUST be the LSR's Router ID, and the Interface MUST be set to the index assigned to the interface.",
      "ja": "インターフェイスが番号が付けられていない場合、アドレスタイプはIPv4またはIPv6の番号なしでなければなりません。IPアドレスはLSRのルーターIDでなければならず、インターフェイスはインターフェイスに割り当てられたインデックスに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Label Stack",
      "ja": "ラベルスタック"
    },
    {
      "indent": 6,
      "text": "The label stack of the received echo request message. If any TTL values have been changed by this router, they SHOULD be restored.",
      "ja": "受信したエコーリクエストメッセージのラベルスタック。このルーターによってTTL値が変更されている場合、それらを復元する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. Errored TLVs",
      "section_title": true,
      "ja": "3.7. エラーされたTLV"
    },
    {
      "indent": 3,
      "text": "The following TLV is a TLV that MAY be included in an echo reply to inform the sender of an echo request of mandatory TLVs either not supported by an implementation or parsed and found to be in error.",
      "ja": "次のTLVは、ECHOの返信に含まれるTLVです。これは、実装によってサポートされていないか、解析され、誤っていることが判明した強制TLVのエコー要求を送信者に通知することができます。"
    },
    {
      "indent": 3,
      "text": "The Value field contains the TLVs that were not understood, encoded as sub-TLVs.",
      "ja": "値フィールドには、サブTLVとしてエンコードされた理解されていないTLVが含まれています。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             Type = 9          |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Value                             |\n.                                                               .\n.                                                               .\n.                                                               .\n|                                                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.8. Reply TOS Byte TLV",
      "section_title": true,
      "ja": "3.8. tos byte tlvに返信します"
    },
    {
      "indent": 3,
      "text": "This TLV MAY be used by the originator of the echo request to request that an echo reply be sent with the IP header TOS byte set to the value specified in the TLV. This TLV has a length of 4 with the following value field.",
      "ja": "このTLVは、ECHOリクエストのオリジネーターが使用して、TLVで指定された値に設定されたIPヘッダーTOSバイトでエコー応答を送信するよう要求する場合があります。このTLVの長さは、次の値フィールドで4の長さです。"
    },
    {
      "indent": 6,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Reply-TOS Byte|                 Must Be Zero                  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Theory of Operation",
      "section_title": true,
      "ja": "4. 操作理論"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is used to test a particular LSP. The LSP to be tested is identified by the \"FEC Stack\"; for example, if the LSP was set up via LDP, and is to an egress IP address of 10.1.1.1, the FEC Stack contains a single element, namely, an LDP IPv4 prefix sub-TLV with value 10.1.1.1/32. If the LSP being tested is an RSVP LSP, the FEC Stack consists of a single element that captures the RSVP Session and Sender Template that uniquely identifies the LSP.",
      "ja": "MPLSエコー要求は、特定のLSPをテストするために使用されます。テストするLSPは、「FECスタック」によって識別されます。たとえば、LSPがLDPを介してセットアップされ、10.1.1.1の出力IPアドレスである場合、FECスタックには単一の要素、つまり値10.1.1.1/32のLDP IPv4プレフィックスSub-TLVが含まれています。テストされているLSPがRSVP LSPである場合、FECスタックは、LSPを一意に識別するRSVPセッションと送信者テンプレートをキャプチャする単一の要素で構成されています。"
    },
    {
      "indent": 3,
      "text": "FEC Stacks can be more complex. For example, one may wish to test a VPN IPv4 prefix of 10.1/8 that is tunneled over an LDP LSP with egress 10.10.1.1. The FEC Stack would then contain two sub-TLVs, the bottom being a VPN IPv4 prefix, and the top being an LDP IPv4 prefix. If the underlying (LDP) tunnel were not known, or was considered irrelevant, the FEC Stack could be a single element with just the VPN IPv4 sub-TLV.",
      "ja": "FECスタックはより複雑になる可能性があります。たとえば、出力10.10.1.1を備えたLDP LSPにトンネル化された10.1/8のVPN IPv4プレフィックスをテストすることをお勧めします。FECスタックには2つのサブTLVが含まれ、下部はVPN IPv4プレフィックスであり、上部はLDP IPv4プレフィックスです。基礎となる（LDP）トンネルが知られていない、または無関係であると見なされた場合、FECスタックはVPN IPv4 Sub-TLVのみの単一要素になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "When an MPLS echo request is received, the receiver is expected to verify that the control plane and data plane are both healthy (for the FEC Stack being pinged) and that the two planes are in sync. The procedures for this are in section 4.4 below.",
      "ja": "MPLSエコーリクエストを受信すると、受信者は、コントロールプレーンとデータプレーンの両方が健康であること（FECスタックがpingされている場合）と2つの平面が同期していることを確認することが期待されます。これの手順は、以下のセクション4.4にあります。"
    },
    {
      "indent": 0,
      "text": "4.1. Dealing with Equal-Cost Multi-Path (ECMP)",
      "section_title": true,
      "ja": "4.1. 等しいコストのマルチパス（ECMP）を扱う"
    },
    {
      "indent": 3,
      "text": "LSPs need not be simple point-to-point tunnels. Frequently, a single LSP may originate at several ingresses, and terminate at several egresses; this is very common with LDP LSPs. LSPs for a given FEC may also have multiple \"next hops\" at transit LSRs. At an ingress, there may also be several different LSPs to choose from to get to the desired endpoint. Finally, LSPs may have backup paths, detour paths, and other alternative paths to take should the primary LSP go down.",
      "ja": "LSPは単純なポイントツーポイントトンネルである必要はありません。多くの場合、単一のLSPはいくつかの侵入で発生し、いくつかの出力で終了する場合があります。これは、LDP LSPで非常に一般的です。特定のFECのLSPには、Transit LSRSで複数の「次のホップ」がある場合があります。侵入では、目的のエンドポイントに到達するために選択できるいくつかの異なるLSPもあります。最後に、LSPにはバックアップパス、迂回路、および主要なLSPがダウンした場合に取るためのその他の代替パスがある場合があります。"
    },
    {
      "indent": 3,
      "text": "To deal with the last two first: it is assumed that the LSR sourcing MPLS echo requests can force the echo request into any desired LSP, so choosing among multiple LSPs at the ingress is not an issue. The problem of probing the various flavors of backup paths that will typically not be used for forwarding data unless the primary LSP is down will not be addressed here.",
      "ja": "最後の2つに対処するために、LSRソーシングMPLSエコーリクエストは、エコーリクエストを任意のLSPに強制できるため、イングレスで複数のLSPを選択することは問題ではないと想定されています。プライマリLSPがダウンしない限り、通常、データの転送に使用されないバックアップパスのさまざまなフレーバーを調査する問題は、ここでは対処されません。"
    },
    {
      "indent": 3,
      "text": "Since the actual LSP and path that a given packet may take may not be known a priori, it is useful if MPLS echo requests can exercise all possible paths. This, although desirable, may not be practical, because the algorithms that a given LSR uses to distribute packets over alternative paths may be proprietary.",
      "ja": "特定のパケットが取る可能性のある実際のLSPとパスは先験的に知られていない可能性があるため、MPLSエコーリクエストがすべての可能なパスを行使できる場合に役立ちます。これは、望ましいものの、実用的ではないかもしれません。なぜなら、特定のLSRが代替パス上にパケットを配布するために使用するアルゴリズムは独自のものである可能性があるからです。"
    },
    {
      "indent": 3,
      "text": "To achieve some degree of coverage of alternate paths, there is a certain latitude in choosing the destination IP address and source UDP port for an MPLS echo request. This is clearly not sufficient; in the case of traceroute, more latitude is offered by means of the Multipath Information of the Downstream Mapping TLV. This is used as follows. An ingress LSR periodically sends an MPLS traceroute message to determine whether there are multipaths for a given LSP. If so, each hop will provide some information how each of its downstream paths can be exercised. The ingress can then send MPLS echo requests that exercise these paths. If several transit LSRs have ECMP, the ingress may attempt to compose these to exercise all possible paths. However, full coverage may not be possible.",
      "ja": "代替パスのある程度のカバレッジを達成するために、MPLSエコーリクエストのために宛先IPアドレスとソースUDPポートを選択する際に特定の緯度があります。これは明らかに十分ではありません。Tracerouteの場合、下流マッピングTLVのマルチパス情報によって、より多くの緯度が提供されます。これは次のように使用されます。Ingress LSRは、MPLS Tracerouteメッセージを定期的に送信して、特定のLSPにマルチパスがあるかどうかを判断します。もしそうなら、各ホップは、その下流のパスのそれぞれをどのように行使できるかをいくつかの情報を提供します。イングレスは、これらのパスを行使するMPLSエコー要求を送信できます。いくつかのトランジットLSRにECMPがある場合、侵入はこれらをすべての可能なパスを行使するために構成しようとする場合があります。ただし、完全なカバレッジは不可能です。"
    },
    {
      "indent": 0,
      "text": "4.2. Testing LSPs That Are Used to Carry MPLS Payloads",
      "section_title": true,
      "ja": "4.2. MPLSペイロードを運ぶために使用されるLSPのテスト"
    },
    {
      "indent": 3,
      "text": "To detect certain LSP breakages, it may be necessary to encapsulate an MPLS echo request packet with at least one additional label when testing LSPs that are used to carry MPLS payloads (such as LSPs used to carry L2VPN and L3VPN traffic. For example, when testing LDP or RSVP-TE LSPs, just sending an MPLS echo request packet may not detect instances where the router immediately upstream of the destination of the LSP ping may forward the MPLS echo request successfully over an interface not configured to carry MPLS payloads because of the use of penultimate hop popping. Since the receiving router has no means to differentiate whether the IP packet was sent unlabeled or implicitly labeled, the addition of labels shimmed above the MPLS echo request (using the Nil FEC) will prevent a router from forwarding such a packet out unlabeled interfaces.",
      "ja": "特定のLSPブレークを検出するには、MPLSペイロードを運ぶために使用されるLSP（L2VPNやL3VPNトラフィックを運ぶために使用されるLSPなど。LDPまたはRSVP-TE LSPSを送信するだけで、MPLSエコーリクエストパケットを送信するだけでは、LSP Pingの宛先のすぐ上流のルーターがMPLSエコーリクエストを使用してMPLSエコーリクエストを正常に転送できない場合があります。2番目のホップポップの。受信ルーターには、IPパケットがラベル付けされていないか暗黙的にラベルが付けられたかを区別する手段がないため、MPLSエコー要求（NIL FECを使用）の上にシミングされたラベルの追加は、そのようなパケットを転送することを妨げます。ラベルのないインターフェイスを出します。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending an MPLS Echo Request",
      "section_title": true,
      "ja": "4.3. MPLSエコーリクエストの送信"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is a UDP packet. The IP header is set as follows: the source IP address is a routable address of the sender; the destination IP address is a (randomly chosen) IPv4 address from the range 127/8 or IPv6 address from the range 0:0:0:0:0:FFFF:127/104. The IP TTL is set to 1. The source UDP port is chosen by the sender; the destination UDP port is set to 3503 (assigned by IANA for MPLS echo requests). The Router Alert option MUST be set in the IP header.",
      "ja": "MPLSエコー要求はUDPパケットです。IPヘッダーは次のように設定されています。ソースIPアドレスは、送信者のルーティング可能なアドレスです。宛先IPアドレスは、範囲127/8またはIPv6アドレスの（0：0：0：0：0：FFFF：127/104の（ランダムに選択された）IPv4アドレスです。IP TTLは1に設定されています。ソースUDPポートは送信者によって選択されます。宛先UDPポートは3503に設定されています（MPLSエコーリクエストのためにIANAによって割り当てられます）。ルーターアラートオプションは、IPヘッダーに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request is sent with a label stack corresponding to the FEC Stack being tested. Note that further labels could be applied if, for example, the normal route to the topmost FEC in the stack is via a Traffic Engineered Tunnel [RSVP-TE]. If all of the FECs in the stack correspond to Implicit Null labels, the MPLS echo request is considered unlabeled even if further labels will be applied in sending the packet.",
      "ja": "MPLSエコー要求は、テストされているFECスタックに対応するラベルスタックで送信されます。たとえば、スタック内の最上部FECへの通常のルートがトラフィックエンジニアリングトンネル[RSVP-TE]を介して行われる場合、さらなるラベルを適用できることに注意してください。スタック内のすべてのFECが暗黙のヌルラベルに対応している場合、MPLSエコー要求は、パケットの送信にさらにラベルが適用された場合でも、ラベル付けされていないと見なされます。"
    },
    {
      "indent": 3,
      "text": "If the echo request is labeled, one MAY (depending on what is being pinged) set the TTL of the innermost label to 1, to prevent the ping request going farther than it should. Examples of where this SHOULD be done include pinging a VPN IPv4 or IPv6 prefix, an L2 VPN endpoint or a pseudowire. Preventing the ping request from going too far can also be accomplished by inserting a Router Alert label above this label; however, this may lead to the undesired side effect that MPLS echo requests take a different data path than actual data. For more information on how these mechanisms can be used for pseudowire connectivity verification, see [VCCV].",
      "ja": "エコー要求にラベルが付けられている場合、（pingされているものに応じて）最も内側のラベルのTTLを1に設定することができます。これを行うべき場所の例には、VPN IPv4またはIPv6プレフィックス、L2 VPNエンドポイント、または擬似ワイヤのpingが含まれます。このラベルの上にルーターアラートラベルを挿入することで、Pingリクエストが行き過ぎないようにすることも、達成できます。ただし、これは、MPLSエコーが実際のデータとは異なるデータパスを取るという望ましくない副作用につながる可能性があります。これらのメカニズムを擬似ワイヤーの接続検証に使用する方法の詳細については、[VCCV]を参照してください。"
    },
    {
      "indent": 3,
      "text": "In \"ping\" mode (end-to-end connectivity check), the TTL in the outermost label is set to 255. In \"traceroute\" mode (fault isolation mode), the TTL is set successively to 1, 2, and so on.",
      "ja": "「Ping」モード（エンドツーエンド接続チェック）では、最外ラベルのTTLは255に設定されています。「Traceroute」モード（障害分離モード）では、TTLは1、2などに連続して設定されます。。"
    },
    {
      "indent": 3,
      "text": "The sender chooses a Sender's Handle and a Sequence Number. When sending subsequent MPLS echo requests, the sender SHOULD increment the Sequence Number by 1. However, a sender MAY choose to send a group of echo requests with the same Sequence Number to improve the chance of arrival of at least one packet with that Sequence Number.",
      "ja": "送信者は、送信者のハンドルとシーケンス番号を選択します。後続のMPLSエコーリクエストを送信する場合、送信者はシーケンス番号を1で増やす必要があります。ただし、送信者は、同じシーケンス番号でエコーリクエストのグループを送信して、そのシーケンス番号で少なくとも1つのパケットの到着の可能性を改善することを選択できます。。"
    },
    {
      "indent": 3,
      "text": "The TimeStamp Sent is set to the time-of-day (in seconds and microseconds) that the echo request is sent. The TimeStamp Received is set to zero.",
      "ja": "送信されたタイムスタンプは、エコーリクエストが送信される時間（秒およびマイクロ秒）に設定されます。受け取ったタイムスタンプはゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "An MPLS echo request MUST have an FEC Stack TLV. Also, the Reply Mode must be set to the desired reply mode; the Return Code and Subcode are set to zero. In the \"traceroute\" mode, the echo request SHOULD include a Downstream Mapping TLV.",
      "ja": "MPLSエコー要求には、FECスタックTLVが必要です。また、返信モードは目的の返信モードに設定する必要があります。戻りコードとサブコードはゼロに設定されています。「Traceroute」モードでは、エコーリクエストにはダウンストリームマッピングTLVを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.4. Receiving an MPLS Echo Request",
      "section_title": true,
      "ja": "4.4. MPLSエコーリクエストを受信します"
    },
    {
      "indent": 3,
      "text": "Sending an MPLS echo request to the control plane is triggered by one of the following packet processing exceptions: Router Alert option, IP TTL expiration, MPLS TTL expiration, MPLS Router Alert label, or the destination address in the 127/8 address range. The control plane further identifies it by UDP destination port 3503.",
      "ja": "MPLSエコーリクエストをコントロールプレーンに送信すると、次のパケット処理の例外のいずれかによってトリガーされます：ルーターアラートオプション、IP TTLの有効期限、MPLS TTL有効化、MPLSルーターアラートラベル、または127/8アドレス範囲の宛先アドレス。コントロールプレーンは、UDP宛先ポート3503によってさらに識別されます。"
    },
    {
      "indent": 3,
      "text": "For reporting purposes the bottom of stack is considered to be stack-depth of 1. This is to establish an absolute reference for the case where the actual stack may have more labels than there are FECs in the Target FEC Stack.",
      "ja": "報告のために、スタックの底部は1のスタック濃度であると見なされます。これは、実際のスタックにターゲットFECスタックにFECがあるよりも多くのラベルがある場合の絶対参照を確立するためです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, in all the error codes listed in this document, a stack-depth of 0 means \"no value specified\". This allows compatibility with existing implementations that do not use the Return Subcode field.",
      "ja": "さらに、このドキュメントにリストされているすべてのエラーコードでは、0のスタックの詳細は「値が指定されていない」を意味します。これにより、リターンサブコードフィールドを使用しない既存の実装との互換性が可能になります。"
    },
    {
      "indent": 3,
      "text": "An LSR X that receives an MPLS echo request then processes it as follows.",
      "ja": "MPLSエコー要求を受信するLSR Xが次のように処理します。"
    },
    {
      "indent": 3,
      "text": "1. General packet sanity is verified. If the packet is not well-formed, LSR X SHOULD send an MPLS Echo Reply with the Return Code set to \"Malformed echo request received\" and the Subcode to zero. If there are any TLVs not marked as \"Ignore\" that LSR X does not understand, LSR X SHOULD send an MPLS \"TLV not understood\" (as appropriate), and the Subcode set to zero. In the latter case, the misunderstood TLVs (only) are included as sub-TLVs in an Errored TLVs TLV in the reply. The header fields Sender's Handle, Sequence Number, and Timestamp Sent are not examined, but are included in the MPLS echo reply message.",
      "ja": "1. 一般的なパケットの正気が検証されています。パケットが適切に形成されていない場合、LSR Xは、「recominged-echo request」に設定されたリターンコードでMPLSエコー応答を送信し、サブコードをゼロに送信する必要があります。LSR Xが理解していない「無視」とマークされていないTLVがある場合、LSR XはMPLS「TLVが理解されていない」（必要に応じて）を送信する必要があり、サブコードがゼロに設定されます。後者の場合、誤解されたTLV（のみ）は、返信に誤ったTLVS TLVのサブTLVとして含まれています。ヘッダーフィールド送信者のハンドル、シーケンス番号、および送信されるタイムスタンプは検査されませんが、MPLSエコー応答メッセージに含まれています。"
    },
    {
      "indent": 3,
      "text": "The algorithm uses the following variables and identifiers:",
      "ja": "アルゴリズムは、次の変数と識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "Interface-I: the interface on which the MPLS echo request was received.",
      "ja": "Interface-I：MPLSエコー要求が受信されたインターフェイス。"
    },
    {
      "indent": 3,
      "text": "Stack-R: the label stack on the packet as it was received.",
      "ja": "Stack-R：受信したパケットのラベルスタック。"
    },
    {
      "indent": 3,
      "text": "Stack-D: the label stack carried in the Downstream Mapping TLV (not always present)",
      "ja": "Stack-D：ダウンストリームマッピングTLV（常に存在するとは限らない）に運ばれるラベルスタック"
    },
    {
      "indent": 3,
      "text": "Label-L: the label from the actual stack currently being examined. Requires no initialization.",
      "ja": "ラベルL：現在検査中の実際のスタックのラベル。初期化は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Label-stack-depth: the depth of label being verified. Initialized to the number of labels in the received label stack S.",
      "ja": "ラベルスタックデプス：検証されているラベルの深さ。受信したラベルスタックS.のラベルの数に初期化"
    },
    {
      "indent": 3,
      "text": "FEC-stack-depth: depth of the FEC in the Target FEC Stack that should be used to verify the current actual label. Requires no initialization.",
      "ja": "FECスタックデプス：現在の実際のラベルを検証するために使用するターゲットFECスタックのFECの深さ。初期化は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Best-return-code: contains the return code for the echo reply packet as currently best known. As algorithm progresses, this code may change depending on the results of further checks that it performs.",
      "ja": "Best-Return-Code：現在最もよく知られているように、Echo Reply Packetの返品コードが含まれています。アルゴリズムが進行するにつれて、このコードは、実行するさらなるチェックの結果に応じて変更される場合があります。"
    },
    {
      "indent": 3,
      "text": "Best-rtn-subcode: similar to Best-return-code, but for the Echo Reply Subcode.",
      "ja": "Best-RTN-SubCode：Best-Return-Codeと同様ですが、Echo Reply Subcodeの場合。"
    },
    {
      "indent": 3,
      "text": "FEC-status: result value returned by the FEC Checking algorithm described in section 4.4.1.",
      "ja": "FEC-status：セクション4.4.1で説明されているFECチェックアルゴリズムによって返される結果値。"
    },
    {
      "indent": 3,
      "text": "/* Save receive context information */\n   2. If the echo request is good, LSR X stores the interface over\n   which the echo was received in Interface-I, and the label stack\n   with which it came in Stack-R.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* The rest of the algorithm iterates over the labels in Stack-R,\n   verifies validity of label values, reports associated label\n   switching operations (for traceroute), verifies correspondence\n   between the Stack-R and the Target FEC Stack description in the\n   body of the echo request, and reports any errors. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* The algorithm iterates as follows. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. Label Validation:",
      "ja": "3. ラベル検証："
    },
    {
      "indent": 6,
      "text": "If Label-stack-depth is 0 {",
      "ja": "ラベルスタックデプスが0の場合{"
    },
    {
      "indent": 6,
      "text": "/* The LSR needs to report its being a tail-end for the LSP */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " Set FEC-stack-depth to 1, set Label-L to 3 (Implicit Null). Set Best-return-code to 3 (\"Replying router is an egress for the FEC at stack depth\"), set Best-rtn-subcode to the value of FEC-stack-depth (1) and go to step 5 (Egress Processing). }",
      "ja": "FECスタックの深さを1に設定し、ラベルLを3に設定します（暗黙のヌル）。Best-Return-Codeを3に設定します（「Replying RouterはStack DepthのFECの出口です」）、Best-RTN-SubCodeをFECスタックデプス（1）の値に設定し、ステップ5に移動します（出力処理）。}"
    },
    {
      "indent": 6,
      "text": "/* This step assumes there is always an entry for well-known\n   label values */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Set Label-L to the value extracted from Stack-R at depth Label-stack-depth. Look up Label-L in the Incoming Label Map (ILM) to determine if the label has been allocated and an operation is associated with it.",
      "ja": "深さラベルスタックの深さでstack-rから抽出された値にラベルLを設定します。着信ラベルマップ（ILM）でラベルLを調べて、ラベルが割り当てられていて操作が関連付けられているかどうかを判断します。"
    },
    {
      "indent": 6,
      "text": "If there is no entry for L {",
      "ja": "lのエントリがない場合{"
    },
    {
      "indent": 6,
      "text": "/* Indicates a temporary or permanent label synchronization\n   problem the LSR needs to report an error */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " Set Best-return-code to 11 (\"No label entry at stack-depth\") and Best-rtn-subcode to Label-stack-depth. Go to step 7 (Send Reply Packet). }",
      "ja": "Best-Return-Codeを11（「Stack-Depthでのラベルエントリなし」）とBest-RTN-SubCodeにラベルスタックの濃縮に設定します。ステップ7に移動します（返信パケットを送信）。}"
    },
    {
      "indent": 6,
      "text": "Else {",
      "ja": "それ以外 {"
    },
    {
      "indent": 9,
      "text": "Retrieve the associated label operation from the corresponding NLFE and proceed to step 4 (Label Operation check).",
      "ja": "対応するNLFEから関連するラベル操作を取得し、ステップ4（ラベル操作チェック）に進みます。"
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "4. Label Operation Check",
      "ja": "4. ラベル操作チェック"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Pop and Continue Processing\" {",
      "ja": "ラベル操作が「ポップアンドを続行する」の場合{"
    },
    {
      "indent": 6,
      "text": "/* Includes Explicit Null and Router Alert label cases */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": " Iterate to the next label by decrementing Label-stack-depth and loop back to step 3 (Label Validation). }",
      "ja": "ラベルスタックの深さを減らし、ループをステップ3に戻し、次のラベルに反復します（ラベル検証）。}"
    },
    {
      "indent": 6,
      "text": "If the label operation is \"Swap or Pop and Switch based on Popped Label\" {",
      "ja": "ラベル操作が「スワップまたはポップポップラベルに基づいてスイッチ」の場合{"
    },
    {
      "indent": 9,
      "text": "Set Best-return-code to 8 (\"Label switched at stack-depth\") and Best-rtn-subcode to Label-stack-depth to report transit switching.",
      "ja": "Best-Return-Codeを8（ \"Stack-Depthでのラベルスイッチ）とBest-RTN-SubCodeをラベルスタックデプスに設定して、トランジットスイッチングを報告します。"
    },
    {
      "indent": 9,
      "text": "If a Downstream Mapping TLV is present in the received echo request {",
      "ja": "受信したエコーリクエストにダウンストリームマッピングTLVが存在する場合{"
    },
    {
      "indent": 12,
      "text": "If the IP address in the TLV is 127.0.0.1 or 0::1 {\n   Set Best-return-code to 6 (\"Upstream Interface Index\n   Unknown\").  An Interface and Label Stack TLV SHOULD be\n   included in the reply and filled with Interface-I and\n   Stack-R.\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Else {",
      "ja": "それ以外 {"
    },
    {
      "indent": 9,
      "text": "      Verify that the IP address, interface address, and label\n      stack in the Downstream Mapping TLV match Interface-I\n      and Stack-R.  If there is a mismatch, set\n      Best-return-code to 5, \"Downstream Mapping Mismatch\".\n      An Interface and Label Stack TLV SHOULD be included in\n      the reply and filled in based on Interface-I and\n      Stack-R.  Go to step 7 (Send Reply Packet).\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "For each available downstream ECMP path {",
      "ja": "利用可能な各下流ECMPパスについて{"
    },
    {
      "indent": 12,
      "text": "Retrieve output interface from the NHLFE entry.",
      "ja": "NHLFEエントリから出力インターフェイスを取得します。"
    },
    {
      "indent": 12,
      "text": "/* Note: this return code is set even if Label-stack-depth\n   is one */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "If the output interface is not MPLS enabled {",
      "ja": "出力インターフェイスがMPLSを有効にしていない場合{"
    },
    {
      "indent": 12,
      "text": " Set Best-return-code to Return Code 9, \"Label switched but no MPLS forwarding at stack-depth\" and set Best-rtn-subcode to Label-stack-depth and goto Send_Reply_Packet. }",
      "ja": "コード9を返すようにベストリターンコードを設定し、「ラベルが切り替えられますが、Stack-DepthでMPLS転送はありません」を設定し、Best-RTN-SubCodeをラベルスタックデプスおよびGOTO SEND_REPLY_PACKETに設定します。}"
    },
    {
      "indent": 12,
      "text": "If a Downstream Mapping TLV is present {",
      "ja": "ダウンストリームマッピングTLVが存在する場合{"
    },
    {
      "indent": 9,
      "text": "     A Downstream Mapping TLV SHOULD be included in the echo\n     reply (see section 3.3) filled in with information about\n     the current ECMP path.\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "If no Downstream Mapping TLV is present, or the Downstream IP Address is set to the ALLROUTERS multicast address, go to step 7 (Send Reply Packet).",
      "ja": "ダウンストリームマッピングTLVが存在しない場合、またはダウンストリームIPアドレスがAllRoutersマルチキャストアドレスに設定されている場合は、ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 9,
      "text": "If the \"Validate FEC Stack\" flag is not set and the LSR is not configured to perform FEC checking by default, go to step 7 (Send Reply Packet).",
      "ja": "「FECスタックの検証」フラグが設定されておらず、LSRがデフォルトでFECチェックを実行するように構成されていない場合は、ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 6,
      "text": "/* Validate the Target FEC Stack in the received echo request.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "First determine FEC-stack-depth from the Downstream Mapping TLV. This is done by walking through Stack-D (the Downstream labels) from the bottom, decrementing the number of labels for each non-Implicit Null label, while incrementing FEC-stack-depth for each label. If the Downstream Mapping TLV contains one or more Implicit Null labels, FEC-stack-depth may be greater than Label-stack-depth. To be consistent with the above stack-depths, the bottom is considered to entry 1. */",
      "ja": "最初に、ダウンストリームマッピングTLVからFECスタックの深さを決定します。これは、下部からStack-D（下流のラベル）を歩いて、各非インプリティヌルラベルのラベルの数を減らしながら、各ラベルのFECスタックの深さを増やすことによって行われます。ダウンストリームマッピングTLVに1つ以上の暗黙的なヌルラベルが含まれている場合、FECスタックデプスはラベルスタックの深さよりも大きい場合があります。上記のスタックの深さと一致するために、下部はエントリ1と見なされます。 */"
    },
    {
      "indent": 9,
      "text": "Set FEC-stack-depth to 0. Set i to Label-stack-depth.",
      "ja": "FECスタックデプスを0に設定します。Iを設定します。"
    },
    {
      "indent": 9,
      "text": "While (i > 0 ) do {\n   ++FEC-stack-depth.\n   if Stack-D[FEC-stack-depth] != 3 (Implicit Null)\n      --i.\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "If the number of labels in the FEC stack is greater than or equal to FEC-stack-depth { Perform the FEC Checking procedure (see subsection 4.4.1 below).",
      "ja": "FECスタック内のラベルの数がFECスタックの深さ以上の場合（FECチェック手順を実行します（以下のサブセクション4.4.1を参照）。"
    },
    {
      "indent": 12,
      "text": "If FEC-status is 2, set Best-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\").",
      "ja": "FEC-Statusが2の場合、Best-Return-Codeを10に設定します（「このFECのマッピングは、Stack-Depthの指定されたラベルではありません」）。"
    },
    {
      "indent": 9,
      "text": " If the return code is 1, set Best-return-code to FEC-return-code and Best-rtn-subcode to FEC-stack-depth. }",
      "ja": "戻りコードが1の場合、FEC-Return-CodeにBest-Return-CodeとFECスタックの濃縮にBest-RTN-SubCodeを設定します。}"
    },
    {
      "indent": 6,
      "text": " Go to step 7 (Send Reply Packet). }",
      "ja": "ステップ7に移動します（返信パケットを送信）。}"
    },
    {
      "indent": 3,
      "text": "5. Egress Processing:",
      "ja": "5. 出力処理："
    },
    {
      "indent": 6,
      "text": "/* These steps are performed by the LSR that identified itself\n   as the tail-end LSR for an LSP. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "If received echo request contains no Downstream Mapping TLV, or the Downstream IP Address is set to 127.0.0.1 or 0::1 go to step 6 (Egress FEC Validation).",
      "ja": "受信した場合、エコーリクエストにはダウンストリームマッピングTLVが含まれていない場合、または下流のIPアドレスが127.0.0.1または0 :: 1に設定されています。"
    },
    {
      "indent": 6,
      "text": "Verify that the IP address, interface address, and label stack in the Downstream Mapping TLV match Interface-I and Stack-R. If not, set Best-return-code to 5, \"Downstream Mapping Mis-match\". A Received Interface and Label Stack TLV SHOULD be created for the echo response packet. Go to step 7 (Send Reply Packet).",
      "ja": "ダウンストリームマッピングTLVマッチインターフェイスIおよびスタック-RのIPアドレス、インターフェイスアドレス、およびラベルスタックを確認します。そうでない場合は、Best-Return-Codeを5に設定し、「下流マッピングミスマッチ」を設定します。Echo Response Packet用に、受信したインターフェイスとラベルスタックTLVを作成する必要があります。ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 3,
      "text": "6. Egress FEC Validation:",
      "ja": "6. 出力FEC検証："
    },
    {
      "indent": 6,
      "text": "/* This is a loop for all entries in the Target FEC Stack\n   starting with FEC-stack-depth. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Perform FEC checking by following the algorithm described in subsection 4.4.1 for Label-L and the FEC at FEC-stack-depth.",
      "ja": "Label-Lのサブセクション4.4.1、FECスタックの深さでFECのサブセクション4.4.1で説明したアルゴリズムに従ってFECチェックを実行します。"
    },
    {
      "indent": 6,
      "text": "Set Best-return-code to FEC-code and Best-rtn-subcode to the value in FEC-stack-depth.",
      "ja": "FECコードにBest-Return-CodeとBest-RTN-SubCodeをFECスタックデプスの値に設定します。"
    },
    {
      "indent": 6,
      "text": "If FEC-status (the result of the check) is 1, go to step 7 (Send Reply Packet).",
      "ja": "FEC-status（チェックの結果）が1の場合、ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 6,
      "text": "/* Iterate to the next FEC entry */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "++FEC-stack-depth.",
      "ja": "FECスタックデプス。"
    },
    {
      "indent": 6,
      "text": "If FEC-stack-depth > the number of FECs in the FEC-stack, go to step 7 (Send Reply Packet).",
      "ja": "FECスタックデプス> FECスタック内のFECの数の場合、ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 6,
      "text": "If FEC-status is 0 { ++Label-stack-depth. If Label-stack-depth > the number of labels in Stack-R, Go to step 7 (Send Reply Packet).",
      "ja": "FEC-statusが0の場合{ラベルスタックデプス。ラベルスタックデプス> stack-rのラベルの数の場合、ステップ7に移動します（返信パケットを送信）。"
    },
    {
      "indent": 6,
      "text": " Label-L = extracted label from Stack-R at depth Label-stack-depth. Loop back to step 6 (Egress FEC Validation). }",
      "ja": "ラベルl =深度ラベルスタックの深さでstack-rから抽出されたラベル。ステップ6に戻ります（FEC検証を出力します）。}"
    },
    {
      "indent": 3,
      "text": "7. Send Reply Packet:",
      "ja": "7. 返信パケットを送信："
    },
    {
      "indent": 6,
      "text": "Send an MPLS echo reply with a Return Code of Best-return-code, and a Return Subcode of Best-rtn-subcode. Include any TLVs created during the above process. The procedures for sending the echo reply are found in subsection 4.4.1.",
      "ja": "Best-Return-Codeのリターンコードと、Best-RTN-Subcodeのリターンサブコードを使用して、MPLSエコー応答を送信します。上記のプロセス中に作成されたTLVを含めます。エコー返信を送信する手順は、サブセクション4.4.1にあります。"
    },
    {
      "indent": 0,
      "text": "4.4.1. FEC Validation",
      "section_title": true,
      "ja": "4.4.1. FEC検証"
    },
    {
      "indent": 3,
      "text": "/* This subsection describes validation of an FEC entry within the\n   Target FEC Stack and accepts an FEC, Label-L, and Interface-I.\n   The algorithm performs the following steps. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "1. Two return values, FEC-status and FEC-return-code, are initialized to 0.",
      "ja": "1. FEC-StatusとFEC-Return-Codeの2つの戻り値が0に初期化されます。"
    },
    {
      "indent": 3,
      "text": "2. If the FEC is the Nil FEC { If Label-L is either Explicit_Null or Router_Alert, return.",
      "ja": "2. FECがNIL FECである場合{Label-Lがexplicit_nullまたはrouter_alertのいずれかの場合、返されます。"
    },
    {
      "indent": 6,
      "text": "   Else {\n      Set FEC-return-code to 10 (\"Mapping for this FEC is not\n      the given label at stack-depth\").\n      Set FEC-status to 1\n      Return.\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. Check the FEC label mapping that describes how traffic received on the LSP is further switched or which application it is associated with. If no mapping exists, set FEC-return-code to Return 4, \"Replying router has no mapping for the FEC at stack-depth\". Set FEC-status to 1. Return.",
      "ja": "3. LSPで受信したトラフィックがさらに切り替えられる方法、または関連するアプリケーションを説明するFECラベルマッピングを確認してください。マッピングが存在しない場合は、FEC-Return-Codeを設定して4を返します。FEC-statusを1に設定します。"
    },
    {
      "indent": 3,
      "text": "4. If the label mapping for FEC is Implicit Null, set FEC-status to 2 and proceed to step 5. Otherwise, if the label mapping for FEC is Label-L, proceed to step 5. Otherwise, set FEC-return-code to 10 (\"Mapping for this FEC is not the given label at stack-depth\"), set FEC-status to 1, and return.",
      "ja": "4. FECのラベルマッピングが暗黙のnullである場合、FEC-statusを2に設定してステップ5に進みます。（「このFECのマッピングは、Stack-Depthの指定されたラベルではありません」）、FEC-Statusを1に設定して戻ります。"
    },
    {
      "indent": 3,
      "text": "5. This is a protocol check. Check what protocol would be used to advertise FEC. If it can be determined that no protocol associated with Interface-I would have advertised an FEC of that FEC-Type, set FEC-return-code to 12 (\"Protocol not associated with interface at FEC stack-depth\"). Set FEC-status to 1.",
      "ja": "5. これはプロトコルチェックです。FECの宣伝に使用されるプロトコルを確認してください。Interface-Iに関連するプロトコルがそのFECタイプのFECを宣伝していないことを判断できる場合、FEC-Return-Codeを12に設定しました（「FECスタックの濃度でのインターフェイスに関連付けられていないプロトコル」）。FEC-statusを1に設定します。"
    },
    {
      "indent": 3,
      "text": "6. Return.",
      "ja": "6. 戻る。"
    },
    {
      "indent": 0,
      "text": "4.5. Sending an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.5. MPLSエコーの返信を送信します"
    },
    {
      "indent": 3,
      "text": "An MPLS echo reply is a UDP packet. It MUST ONLY be sent in response to an MPLS echo request. The source IP address is a routable address of the replier; the source port is the well-known UDP port for LSP ping. The destination IP address and UDP port are copied from the source IP address and UDP port of the echo request. The IP TTL is set to 255. If the Reply Mode in the echo request is \"Reply via an IPv4 UDP packet with Router Alert\", then the IP header MUST contain the Router Alert IP option. If the reply is sent over an LSP, the topmost label MUST in this case be the Router Alert label (1) (see [LABEL-STACK]).",
      "ja": "MPLSエコー応答はUDPパケットです。MPLSエコーリクエストに応じてのみ送信する必要があります。ソースIPアドレスは、Replierのルーティング可能なアドレスです。ソースポートは、LSP Pingのよく知られているUDPポートです。宛先IPアドレスとUDPポートは、EchoリクエストのソースIPアドレスとUDPポートからコピーされます。IP TTLは255に設定されています。エコーリクエストの返信モードが「ルーターアラートを備えたIPv4 UDPパケットを介して返信」である場合、IPヘッダーにはルーターアラートIPオプションを含める必要があります。返信がLSPを介して送信された場合、この場合、最上部のラベルはルーターアラートラベル（1）でなければなりません（[ラベルスタック]を参照）。"
    },
    {
      "indent": 3,
      "text": "The format of the echo reply is the same as the echo request. The Sender's Handle, the Sequence Number, and TimeStamp Sent are copied from the echo request; the TimeStamp Received is set to the time-of-day that the echo request is received (note that this information is most useful if the time-of-day clocks on the requester and the replier are synchronized). The FEC Stack TLV from the echo request MAY be copied to the reply.",
      "ja": "エコー応答の形式は、エコーリクエストと同じです。送信者のハンドル、シーケンス番号、および送信されたタイムスタンプは、エコーリクエストからコピーされます。受け取ったタイムスタンプは、エコーリクエストが受信される時期に設定されています（リクエスターの時刻時計とレプリャーが同期されている場合、この情報は最も有用であることに注意してください）。エコーリクエストからのFECスタックTLVを返信にコピーすることができます。"
    },
    {
      "indent": 3,
      "text": "The replier MUST fill in the Return Code and Subcode, as determined in the previous subsection.",
      "ja": "Replierは、以前のサブセクションで決定されているように、返品コードとサブコードに記入する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Pad TLV, the replier MUST interpret the first octet for instructions regarding how to reply.",
      "ja": "エコーリクエストにパッドTLVが含まれている場合、返信方法に関する指示については、最初のオクテットを解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the replying router is the destination of the FEC, then Downstream Mapping TLVs SHOULD NOT be included in the echo reply.",
      "ja": "応答ルーターがFECの宛先である場合、下流マッピングTLVをEcho応答に含めないでください。"
    },
    {
      "indent": 3,
      "text": "If the echo request contains a Downstream Mapping TLV, and the replying router is not the destination of the FEC, the replier SHOULD compute its downstream routers and corresponding labels for the incoming label, and add Downstream Mapping TLVs for each one to the echo reply it sends back.",
      "ja": "エコー要求にダウンストリームマッピングTLVが含まれており、応答するルーターがFECの宛先ではない場合、Replierはその下流のルーターと対応するラベルを計算し、それぞれの下流マッピングTLVをエコーに追加する必要があります。送り返します。"
    },
    {
      "indent": 3,
      "text": "If the Downstream Mapping TLV contains Multipath Information requiring more processing than the receiving router is willing to perform, the responding router MAY choose to respond with only a subset of multipaths contained in the echo request Downstream Mapping. (Note: The originator of the echo request MAY send another echo request with the Multipath Information that was not included in the reply.)",
      "ja": "ダウンストリームマッピングTLVに、受信ルーターが実行するよりも多くの処理を必要とするマルチパス情報が含まれている場合、応答するルーターは、エコーリクエストの下流マッピングに含まれるマルチパスのサブセットのみで応答することを選択できます。（注：エコーリクエストのオリジネーターは、返信に含まれていないマルチパス情報を使用して別のエコーリクエストを送信する場合があります。）"
    },
    {
      "indent": 3,
      "text": "Except in the case of Reply Mode 4, \"Reply via application level control channel\", echo replies are always sent in the context of the IP/MPLS network.",
      "ja": "Reply Mode 4の場合を除き、「アプリケーションレベル制御チャネルを介して返信」、Echo Repliesは常にIP/MPLSネットワークのコンテキストで送信されます。"
    },
    {
      "indent": 0,
      "text": "4.6. Receiving an MPLS Echo Reply",
      "section_title": true,
      "ja": "4.6. MPLSエコーの返信を受信します"
    },
    {
      "indent": 3,
      "text": "An LSR X should only receive an MPLS echo reply in response to an MPLS echo request that it sent. Thus, on receipt of an MPLS echo reply, X should parse the packet to ensure that it is well-formed, then attempt to match up the echo reply with an echo request that it had previously sent, using the destination UDP port and the Sender's Handle. If no match is found, then X jettisons the echo reply; otherwise, it checks the Sequence Number to see if it matches.",
      "ja": "LSR Xは、送信したMPLSエコーリクエストに応じてMPLSエコー応答のみを受信する必要があります。したがって、MPLSエコーの応答を受け取ったとき、xはパケットを解析して整形していることを確認する必要があります。次に、宛先UDPポートと送信者を使用して、以前に送信したエコーリクエストとエコー応答を一致させようとする必要があります。取り持つ。一致が見つからない場合は、xジェッティソンがエコー応答を返信します。それ以外の場合は、シーケンス番号をチェックして、一致するかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "If the echo reply contains Downstream Mappings, and X wishes to traceroute further, it SHOULD copy the Downstream Mapping(s) into its next echo request(s) (with TTL incremented by one).",
      "ja": "エコーの返信にダウンストリームマッピングが含まれており、Xがさらにトレーサーを希望する場合は、下流のマッピングを次のエコー要求にコピーする必要があります（TTLが1つずつ増加します）。"
    },
    {
      "indent": 0,
      "text": "4.7. Issue with VPN IPv4 and IPv6 Prefixes",
      "section_title": true,
      "ja": "4.7. VPN IPv4およびIPv6プレフィックスの問題"
    },
    {
      "indent": 3,
      "text": "Typically, an LSP ping for a VPN IPv4 prefix or VPN IPv6 prefix is sent with a label stack of depth greater than 1, with the innermost label having a TTL of 1. This is to terminate the ping at the egress PE, before it gets sent to the customer device. However, under certain circumstances, the label stack can shrink to a single label before the ping hits the egress PE; this will result in the ping terminating prematurely. One such scenario is a multi-AS Carrier's Carrier VPN.",
      "ja": "通常、VPN IPv4プレフィックスまたはVPN IPv6プレフィックスのLSP pingは、1を超える深さのラベルスタックで送信され、最も内側のラベルは1のTTLを持ちます。カスタマーデバイスに送信されます。ただし、特定の状況では、ラベルスタックは、Pingが出口PEに当たる前に単一のラベルに収縮する可能性があります。これにより、pingが早期に終了します。そのようなシナリオの1つは、マルチASキャリアのキャリアVPNです。"
    },
    {
      "indent": 3,
      "text": "To get around this problem, one approach is for the LSR that receives such a ping to realize that the ping terminated prematurely, and send back error code 13. In that case, the initiating LSR can retry the ping after incrementing the TTL on the VPN label. In this fashion, the ingress LSR will sequentially try TTL values until it finds one that allows the VPN ping to reach the egress PE.",
      "ja": "この問題を回避するために、1つのアプローチは、Pingが早期に終了したことを認識し、エラーコード13を送信するためにそのようなPingを受信するLSRのためのものです。その場合、LSRはVPNでTTLを増加させた後にPingを再試行できます。ラベル。この方法で、Ingress LSRは、VPN pingが出口PEに到達できるようになるまで、TTL値を順次試行します。"
    },
    {
      "indent": 0,
      "text": "4.8. Non-compliant Routers",
      "section_title": true,
      "ja": "4.8. 非準拠ルーター"
    },
    {
      "indent": 3,
      "text": "If the egress for the FEC Stack being pinged does not support MPLS ping, then no reply will be sent, resulting in possible \"false negatives\". If in \"traceroute\" mode, a transit LSR does not support LSP ping, then no reply will be forthcoming from that LSR for some TTL, say, n. The LSR originating the echo request SHOULD try sending the echo request with TTL=n+1, n+2, ..., n+k to probe LSRs further down the path. In such a case, the echo request for TTL > n SHOULD be sent with Downstream Mapping TLV \"Downstream IP Address\" field set to the ALLROUTERs multicast address until a reply is received with a Downstream Mapping TLV. The label stack MAY be omitted from the Downstream Mapping TLV. Furthermore, the \"Validate FEC Stack\" flag SHOULD NOT be set until an echo reply packet with a Downstream Mapping TLV is received.",
      "ja": "PingがPingされているFECスタックの出口がMPLS pingをサポートしていない場合、返信は送信されず、「偽のネガ」の可能性があります。「Traceroute」モードで、Transit LSRがLSP Pingをサポートしていない場合、そのLSRからの返信は、たとえばnの返信を繰り返しません。ECHO要求を発信するLSRは、TTL = n 1、n 2、...、n kを使用してECHO要求を送信して、パスをさらに下回るLSRをプローブしてみてください。このような場合、TTL> nのエコー要求は、ダウンストリームマッピングTLVでAllRoutersマルチキャストアドレスに設定されたダウンストリームマッピングTLV「ダウンストリームIPアドレス」フィールドで送信する必要があります。ラベルスタックは、下流マッピングTLVから省略できます。さらに、「FECスタックの検証」フラグは、下流マッピングTLVを備えたエコー応答パケットが受信されるまで設定しないでください。"
    },
    {
      "indent": 0,
      "text": "5. References",
      "section_title": true,
      "ja": "5. 参考文献"
    },
    {
      "indent": 0,
      "text": "5.1. Normative References",
      "section_title": true,
      "ja": "5.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BGP] Rekhter, Y., Li, T., and S. Hares, \"A Border Gateway Protocol 4 (BGP-4)\", RFC 4271, January 2006.",
      "ja": "[BGP] Rekhter、Y.、Li、T。、およびS. Hares、「A Border Gateway Protocol 4（BGP-4）」、RFC 4271、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[IANA] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[IANA] Narten、T。およびH. Alvestrand、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[KEYWORDS] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[キーワード] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[LABEL-STACK] Rosen, E., Tappan, D., Fedorkow, G., Rekhter, Y., Farinacci, D., Li, T., and A. Conta, \"MPLS Label Stack Encoding\", RFC 3032, January 2001.",
      "ja": "[ラベルスタック] Rosen、E.、Tappan、D.、Fedorkow、G.、Rekhter、Y.、Farinacci、D.、Li、T。、およびA. conta、「MPLSラベルスタックエンコーディング」、RFC 3032、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[NTP] Mills, D., \"Simple Network Time Protocol (SNTP) Version 4 for IPv4, IPv6 and OSI\", RFC 2030, October 1996.",
      "ja": "[NTP] Mills、D。、「IPv4、IPv6およびOSIのSimple Network Time Protocol（SNTP）バージョン4」、RFC 2030、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1812] Baker, F., \"Requirements for IP Version 4 Routers\", RFC 1812, June 1995.",
      "ja": "[RFC1812] Baker、F。、「IPバージョン4ルーターの要件」、RFC 1812、1995年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4026] Andersson, L. and T. Madsen, \"Provider Provisioned Virtual Private Network (VPN) Terminology\", RFC 4026, March 2005.",
      "ja": "[RFC4026] Andersson、L。およびT. Madsen、「プロバイダープロビジョニング仮想プライベートネットワーク（VPN）用語」、RFC 4026、2005年3月。"
    },
    {
      "indent": 0,
      "text": "5.2. Informative References",
      "section_title": true,
      "ja": "5.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BGP-LABEL] Rekhter, Y. and E. Rosen, \"Carrying Label Information in BGP-4\", RFC 3107, May 2001.",
      "ja": "[BGP-Label] Rekhter、Y。およびE. Rosen、「BGP-4でのラベル情報の運搬」、RFC 3107、2001年5月。"
    },
    {
      "indent": 3,
      "text": "[ICMP] Postel, J., \"Internet Control Message Protocol\", STD 5, RFC 792, September 1981.",
      "ja": "[ICMP] Postel、J。、「インターネットコントロールメッセージプロトコル」、STD 5、RFC 792、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[LDP] Andersson, L., Doolan, P., Feldman, N., Fredette, A., and B. Thomas, \"LDP Specification\", RFC 3036, January 2001.",
      "ja": "[LDP] Andersson、L.、Doolan、P.、Feldman、N.、Fredette、A。、およびB. Thomas、「LDP仕様」、RFC 3036、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[PW-CONTROL] Martini, L., El-Aawar, N., Heron, G., Rosen, E., Tappan, D., and T. Smith, \"Pseudowire Setup and Maintenance using the Label Distribution Protocol\", Work in Progress.",
      "ja": "[PW-Control] Martini、L.、El-Aawar、N.、Heron、G.、Rosen、E.、Tappan、D。、およびT. Smith、「ラベル分布プロトコルを使用したPseudowireのセットアップとメンテナンス」、Work進行中。"
    },
    {
      "indent": 3,
      "text": "[RFC4365] Rosen, E., \"Applicability Statement for BGP/MPLS IP Virtual Private Networks (VPNs)\", RFC 4365, February 2006.",
      "ja": "[RFC4365] Rosen、E。、「BGP/MPLS IP仮想ネットワーク（VPNS）のアプリケーションステートメント」、RFC 4365、2006年2月。"
    },
    {
      "indent": 3,
      "text": "[RSVP-TE] Awduche, D., Berger, L., Gan, D., Li, T., Srinivasan, V., and G. Swallow, \"RSVP-TE: Extensions to RSVP for LSP Tunnels\", RFC 3209, December 2001.",
      "ja": "[RSVP-TE] Awduche、D.、Berger、L.、Gan、D.、Li、T.、Srinivasan、V。、およびG. Swallow、 \"RSVP-TE：LSPトンネルのRSVPへの拡張\"、RFC 3209、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[VCCV] Nadeau, T. and R. Aggarwal, \"Pseudo Wire Virtual Circuit Connectivity Verification (VCCV), Work in Progress, August 2005.",
      "ja": "[VCCV] Nadeau、T。およびR. Aggarwal、「Pseudo Wire Virtual Circuit Connectivity Verification（VCCV）、2005年8月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[VPLS-BGP] Kompella, K. and Y. Rekhter, \"Virtual Private LAN Service\", Work in Progress.",
      "ja": "[VPLS-BGP] Kompella、K。およびY. Rekhter、「仮想プライベートLANサービス」、進行中の作業。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Overall, the security needs for LSP ping are similar to those of ICMP ping.",
      "ja": "全体として、LSP pingのセキュリティニーズは、ICMP Pingのセキュリティのニーズに似ています。"
    },
    {
      "indent": 3,
      "text": "There are at least three approaches to attacking LSRs using the mechanisms defined here. One is a Denial-of-Service attack, by sending MPLS echo requests/replies to LSRs and thereby increasing their workload. The second is obfuscating the state of the MPLS data plane liveness by spoofing, hijacking, replaying, or otherwise tampering with MPLS echo requests and replies. The third is an unauthorized source using an LSP ping to obtain information about the network.",
      "ja": "ここで定義されているメカニズムを使用して、LSRを攻撃するには少なくとも3つのアプローチがあります。1つは、MPLSエコー要求/返信をLSRに送信し、それによってワークロードを増やすことにより、サービス拒否攻撃です。2つ目は、MPLSのエコーリクエストと返信をスプーフィング、ハイジャック、リプレイ、または改ざんすることにより、MPLSデータプレーンの描写の状態を難読化することです。3番目は、ネットワークに関する情報を取得するためにLSP pingを使用した不正なソースです。"
    },
    {
      "indent": 3,
      "text": "To avoid potential Denial-of-Service attacks, it is RECOMMENDED that implementations regulate the LSP ping traffic going to the control plane. A rate limiter SHOULD be applied to the well-known UDP port defined below.",
      "ja": "潜在的なサービス拒否攻撃を回避するために、実装により、LSP pingトラフィックをコントロールプレーンに調整することをお勧めします。レートリミッターは、以下に定義されているよく知られているUDPポートに適用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unsophisticated replay and spoofing attacks involving faking or replaying MPLS echo reply messages are unlikely to be effective. These replies would have to match the Sender's Handle and Sequence Number of an outstanding MPLS echo request message. A non-matching replay would be discarded as the sequence has moved on, thus a spoof has only a small window of opportunity. However, to provide a stronger defense, an implementation MAY also validate the TimeStamp Sent by requiring and exact match on this field.",
      "ja": "MPLSエコー応答メッセージの偽造またはリプレイを含む洗練されていないリプレイおよびスプーフィング攻撃は、効果的ではありません。これらの返信は、発行済みのMPLSエコーリクエストメッセージの送信者のハンドルとシーケンス番号を一致させる必要があります。シーケンスが進むにつれて、一致しないリプレイは破棄されます。したがって、スプーフィングにはわずかな機会しかありません。ただし、より強力な防御を提供するために、実装は、このフィールドに必要な一致を要求することによって送信されるタイムスタンプを検証することもできます。"
    },
    {
      "indent": 3,
      "text": "To protect against unauthorized sources using MPLS echo request messages to obtain network information, it is RECOMMENDED that implementations provide a means of checking the source addresses of MPLS echo request messages against an access list before accepting the message.",
      "ja": "MPLSエコーリクエストメッセージを使用してネットワーク情報を取得するために不正なソースから保護するには、メッセージを受け入れる前に、アクセスリストに対してMPLSエコーリクエストメッセージのソースアドレスをチェックする手段を実装することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "It is not clear how to prevent hijacking (non-delivery) of echo requests or replies; however, if these messages are indeed hijacked, LSP ping will report that the data plane is not working as it should.",
      "ja": "エコーリクエストまたは返信のハイジャック（非配信）を防ぐ方法は明確ではありません。ただし、これらのメッセージが実際にハイジャックされている場合、LSP Pingはデータプレーンが正常に機能していないことを報告します。"
    },
    {
      "indent": 3,
      "text": "It does not seem vital (at this point) to secure the data carried in MPLS echo requests and replies, although knowledge of the state of the MPLS data plane may be considered confidential by some. Implementations SHOULD, however, provide a means of filtering the addresses to which echo reply messages may be sent.",
      "ja": "MPLSのリクエストと返信に掲載されたデータを保護することは（この時点で）重要ではないと思われますが、MPLSデータプレーンの状態の知識は一部の人によって機密と見なされる場合があります。ただし、実装は、エコー応答メッセージを送信するアドレスをフィルタリングする手段を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Although this document makes special use of 127/8 address, these are used only in conjunction with the UDP port 3503. Furthermore, these packets are only processed by routers. All other hosts MUST treat all packets with a destination address in the range 127/8 in accordance to RFC 1122. Any packet received by a router with a destination address in the range 127/8 without a destination UDP port of 3503 MUST be treated in accordance to RFC 1812. In particular, the default behavior is to treat packets destined to a 127/8 address as \"martians\".",
      "ja": "このドキュメントは127/8アドレスを特別に使用していますが、これらはUDPポート3503と組み合わせてのみ使用されます。さらに、これらのパケットはルーターによってのみ処理されます。他のすべてのホストは、RFC 1122に従って127/8の範囲127/8の範囲の宛先アドレスですべてのパケットを処理する必要があります。3503の宛先ポートがない範囲127/8の範囲の宛先アドレスを持つルーターで受信したパケットは、で処理する必要があります。特に、RFC1812に従って、デフォルトの動作は、127/8アドレスに運命づけられたパケットを「火星人」として扱うことです。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The TCP and UDP port number 3503 has been allocated by IANA for LSP echo requests and replies.",
      "ja": "TCPおよびUDPポート番号3503は、LSPエコーリクエストと返信のためにIANAによって割り当てられています。"
    },
    {
      "indent": 3,
      "text": "The following sections detail the new name spaces to be managed by IANA. For each of these name spaces, the space is divided into assignment ranges; the following terms are used in describing the procedures by which IANA allocates values: \"Standards Action\" (as defined in [IANA]), \"Specification Required\", and \"Vendor Private Use\".",
      "ja": "次のセクションでは、IANAが管理する新しい名前スペースの詳細を示しています。これらのネームスペースごとに、スペースは割り当て範囲に分かれています。次の用語は、IANAが値を割り当てる手順の説明に使用されます：「標準アクション」（[IANA]で定義されている）、「必要な仕様」、および「ベンダープライベート使用」。"
    },
    {
      "indent": 3,
      "text": "Values from \"Specification Required\" ranges MUST be registered with IANA. The request MUST be made via an Experimental RFC that describes the format and procedures for using the code point; the actual assignment is made during the IANA actions for the RFC.",
      "ja": "「仕様が必要」の範囲からの値は、IANAに登録する必要があります。リクエストは、コードポイントを使用するための形式と手順を説明する実験的なRFCを介して行う必要があります。実際の割り当ては、RFCのIANAアクション中に行われます。"
    },
    {
      "indent": 3,
      "text": "Values from \"Vendor Private\" ranges MUST NOT be registered with IANA; however, the message MUST contain an enterprise code as registered with the IANA SMI Private Network Management Private Enterprise Numbers. For each name space that has a Vendor Private range, it must be specified where exactly the SMI Private Enterprise Number resides; see below for examples. In this way, several enterprises (vendors) can use the same code point without fear of collision.",
      "ja": "「ベンダープライベート」範囲の値は、IANAに登録してはなりません。ただし、メッセージには、IANA SMIプライベートネットワーク管理のプライベートエンタープライズ番号に登録されているエンタープライズコードを含める必要があります。ベンダーのプライベート範囲を持つ各名前スペースについて、SMIプライベートエンタープライズ番号が正確に存在する場合に指定する必要があります。例については、以下を参照してください。このようにして、いくつかの企業（ベンダー）は衝突を恐れることなく同じコードポイントを使用できます。"
    },
    {
      "indent": 0,
      "text": "7.1. Message Types, Reply Modes, Return Codes",
      "section_title": true,
      "ja": "7.1. メッセージタイプ、返信モード、返信コード"
    },
    {
      "indent": 3,
      "text": "The IANA has created and will maintain registries for Message Types, Reply Modes, and Return Codes. Each of these can take values in the range 0-255. Assignments in the range 0-191 are via Standards Action; assignments in the range 192-251 are made via \"Specification Required\"; values in the range 252-255 are for Vendor Private Use, and MUST NOT be allocated.",
      "ja": "IANAは、メッセージタイプ、返信モード、および返信コードのレジストリを作成し、維持します。これらのそれぞれは、0-255の範囲で値を取ることができます。0-191の範囲の割り当ては、標準訴訟を介して行われます。範囲192-251の割り当ては、「必要な仕様」を介して行われます。範囲252-255の値は、ベンダーの個人使用用であり、割り当てられないでください。"
    },
    {
      "indent": 3,
      "text": "If any of these fields fall in the Vendor Private range, a top-level Vendor Enterprise Number TLV MUST be present in the message.",
      "ja": "これらのフィールドのいずれかがベンダーのプライベート範囲に分類されている場合、メッセージにはトップレベルのベンダーエンタープライズ番号TLVが存在する必要があります。"
    },
    {
      "indent": 3,
      "text": "Message Types defined in this document are the following:",
      "ja": "このドキュメントで定義されているメッセージタイプは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    MPLS echo request\n    2    MPLS echo reply",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Reply Modes defined in this document are the following:",
      "ja": "このドキュメントで定義されている返信モードは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Value    Meaning\n-----    -------\n    1    Do not reply\n    2    Reply via an IPv4/IPv6 UDP packet\n    3    Reply via an IPv4/IPv6 UDP packet with Router Alert\n    4    Reply via application level control channel",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Return Codes defined in this document are listed in section 3.1.",
      "ja": "このドキュメントで定義されている戻りコードは、セクション3.1にリストされています。"
    },
    {
      "indent": 0,
      "text": "7.2. TLVs",
      "section_title": true,
      "ja": "7.2. TLVS"
    },
    {
      "indent": 3,
      "text": "The IANA has created and will maintain a registry for the Type field of top-level TLVs as well as for any associated sub-TLVs. Note the meaning of a sub-TLV is scoped by the TLV. The number spaces for the sub-TLVs of various TLVs are independent.",
      "ja": "IANAは、トップレベルTLVのタイプフィールドおよび関連するサブTLVのレジストリを作成し、維持します。SUB-TLVの意味は、TLVによってスコープされています。さまざまなTLVのサブTLVの数値スペースは独立しています。"
    },
    {
      "indent": 3,
      "text": "The valid range for TLVs and sub-TLVs is 0-65535. Assignments in the range 0-16383 and 32768-49161 are made via Standards Action as defined in [IANA]; assignments in the range 16384-31743 and 49162-64511 are made via \"Specification Required\" as defined above; values in the range 31744-32767 and 64512-65535 are for Vendor Private Use, and MUST NOT be allocated.",
      "ja": "TLVとサブTLVの有効な範囲は0-65535です。範囲0-16383および32768-49161の割り当ては、[IANA]で定義されている標準訴訟を介して行われます。16384-31743および49162-64511の範囲の割り当ては、上記の「仕様が必要」を介して行われます。範囲31744-32767および64512-65535の値は、ベンダーの私的使用のためであり、割り当てられないでください。"
    },
    {
      "indent": 3,
      "text": "If a TLV or sub-TLV has a Type that falls in the range for Vendor Private Use, the Length MUST be at least 4, and the first four octets MUST be that vendor's SMI Private Enterprise Number, in network octet order. The rest of the Value field is private to the vendor.",
      "ja": "TLVまたはSub-TLVにベンダーの個人使用のために範囲に収まるタイプがある場合、長さは少なくとも4でなければならず、最初の4つのオクテットは、ベンダーのSMIプライベートエンタープライズ番号、ネットワークOCTET順序でなければなりません。残りのバリューフィールドは、ベンダーのプライベートです。"
    },
    {
      "indent": 3,
      "text": "TLVs and sub-TLVs defined in this document are the following:",
      "ja": "このドキュメントで定義されているTLVとサブTLVは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "Type       Sub-Type        Value Field\n----       --------        -----------\n   1                       Target FEC Stack\n                1          LDP IPv4 prefix\n                2          LDP IPv6 prefix\n                3          RSVP IPv4 LSP\n                4          RSVP IPv6 LSP\n                5          Not Assigned\n                6          VPN IPv4 prefix\n                7          VPN IPv6 prefix\n                8          L2 VPN endpoint\n                9          \"FEC 128\" Pseudowire (Deprecated)\n               10          \"FEC 128\" Pseudowire\n               11          \"FEC 129\" Pseudowire\n               12          BGP labeled IPv4 prefix\n               13          BGP labeled IPv6 prefix\n               14          Generic IPv4 prefix\n               15          Generic IPv6 prefix\n               16          Nil FEC\n   2                       Downstream Mapping\n   3                       Pad\n   4                       Not Assigned\n   5                       Vendor Enterprise Number\n   6                       Not Assigned\n   7                       Interface and Label Stack\n   8                       Not Assigned\n   9                       Errored TLVs\n           Any value       The TLV not understood\n  10                       Reply TOS Byte",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the outcome of many discussions among many people, including Manoj Leelanivas, Paul Traina, Yakov Rekhter, Der-Hwa Gan, Brook Bailey, Eric Rosen, Ina Minei, Shivani Aggarwal, and Vanson Lim.",
      "ja": "この文書は、Manoj Leelanivas、Paul Traina、Yakov Rekhter、Der-Hwa Gan、Brook Bailey、Eric Rosen、Ina Minei、Shivani Aggarwal、Vanson Limなど、多くの人々の間で多くの議論の結果です。"
    },
    {
      "indent": 3,
      "text": "The description of the Multipath Information sub-field of the Downstream Mapping TLV was adapted from text suggested by Curtis Villamizar.",
      "ja": "下流マッピングTLVのマルチパス情報サブフィールドの説明は、Curtis Villamizarが提案したテキストから採用されました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Kireeti Kompella Juniper Networks 1194 N.Mathilda Ave Sunnyvale, CA 94089",
      "ja": "Kireeti Kompella Juniper Networks 1194 N.Mathilda Ave Sunnyvale、CA 94089"
    },
    {
      "indent": 3,
      "text": "EMail:  kireeti@juniper.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "George Swallow Cisco Systems 1414 Massachusetts Ave, Boxborough, MA 01719",
      "ja": "ジョージスワローシスコシステム1414マサチューセッツアベニュー、ボックスボロー、マサチューセッツ州01719"
    },
    {
      "indent": 3,
      "text": "Phone:  +1 978 936 1398\nEMail:  swallow@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}