{
  "title": {
    "text": "RFC 4757 - The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows",
    "ja": "RFC 4757 - Microsoft Windowsが使用するRC4-HMAC Kerberos暗号化タイプ"
  },
  "number": 4757,
  "created_at": "2023-05-31 15:17:47.913573+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                      K. Jaganathan\nRequest for Comments: 4757                                        L. Zhu\nCategory: Informational                                        J. Brezak\n                                                   Microsoft Corporation\n                                                           December 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "The RC4-HMAC Kerberos Encryption Types Used by Microsoft Windows",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2006).",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "IESG Note",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This document documents the RC4 Kerberos encryption types first introduced in Microsoft Windows 2000. Since then, these encryption types have been implemented in a number of Kerberos implementations. The IETF Kerberos community supports publishing this specification as an informational document in order to describe this widely implemented technology. However, while these encryption types provide the operations necessary to implement the base Kerberos specification [RFC4120], they do not provide all the required operations in the Kerberos cryptography framework [RFC3961]. As a result, it is not generally possible to implement potential extensions to Kerberos using these encryption types. The Kerberos encryption type negotiation mechanism [RFC4537] provides one approach for using such extensions even when a Kerberos infrastructure uses long-term RC4 keys. Because this specification does not implement operations required by RFC 3961 and because of security concerns with the use of RC4 and MD4 discussed in Section 8, this specification is not appropriate for publication on the standards track.",
      "ja": "このドキュメントは、Microsoft Windows 2000で最初に導入されたRC4 Kerberos暗号化タイプをドキュメントしています。それ以来、これらの暗号化タイプは多くのKerberosの実装で実装されています。IETF Kerberos Communityは、この広く実装されているテクノロジーを説明するために、この仕様を情報文書として公開することをサポートしています。ただし、これらの暗号化タイプは、Base Kerberos仕様[RFC4120]を実装するために必要な操作を提供しますが、Kerberos暗号化フレームワーク[RFC3961]で必要なすべての操作を提供するわけではありません。その結果、これらの暗号化タイプを使用してKerberosに潜在的な拡張を実装することは一般に不可能です。Kerberos暗号化タイプの交渉メカニズム[RFC4537]は、Kerberosインフラが長期のRC4キーを使用している場合でも、このような拡張機能を使用するための1つのアプローチを提供します。この仕様はRFC 3961で必要な操作を実装しておらず、セクション8で説明したRC4とMD4の使用に関するセキュリティ上の懸念のために、この仕様は標準トラックでの公開には適していません。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Microsoft Windows 2000 implementation of Kerberos introduces a new encryption type based on the RC4 encryption algorithm and using an MD5 HMAC for checksum. This is offered as an alternative to using the existing DES-based encryption types.",
      "ja": "KerberosのMicrosoft Windows 2000の実装では、RC4暗号化アルゴリズムに基づいて新しい暗号化タイプを導入し、チェックサムにMD5 HMACを使用します。これは、既存のDESベースの暗号化タイプを使用する代わりに提供されます。"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC encryption types are used to ease upgrade of existing Windows NT environments, provide strong cryptography (128-bit key lengths), and provide exportable (meet United States government export restriction requirements) encryption. This document describes the implementation of those encryption types.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n   1.1. Conventions Used in This Document ..........................3\n2. Key Generation ..................................................3\n3. Basic Operations ................................................4\n4. Checksum Types ..................................................5\n5. Encryption Types ................................................6\n6. Key Strength Negotiation ........................................8\n7. GSS-API Kerberos V5 Mechanism Type ..............................8\n   7.1. Mechanism Specific Changes .................................8\n   7.2. GSS-API MIC Semantics ......................................9\n   7.3. GSS-API WRAP Semantics ....................................11\n8. Security Considerations ........................................15\n9. IANA Considerations ............................................15\n10. Acknowledgements ..............................................15\n11. References ....................................................16\n   11.1. Normative References .....................................16\n   11.2. Informative References ...................................16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Microsoft Windows 2000 implementation of Kerberos contains new encryption and checksum types for two reasons. First, for export reasons early in the development process, 56-bit DES encryption could not be exported, and, second, upon upgrade from Windows NT 4.0 to Windows 2000, accounts will not have the appropriate DES keying material to do the standard DES encryption. Furthermore, 3DES was not available for export when Windows 2000 was released, and there was a desire to use a single flavor of encryption in the product for both US and international products.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As a result, there are two new encryption types and one new checksum type introduced in Microsoft Windows 2000.",
      "ja": "その結果、Microsoft Windows 2000に導入された2つの新しい暗号化タイプと1つの新しいチェックサムタイプがあります。"
    },
    {
      "indent": 3,
      "text": "Note that these cryptosystems aren't intended to be complete, general-purpose Kerberos encryption or checksum systems as defined in [RFC3961]: there is no one-one mapping between the operations in this documents and the primitives described in [RFC3961].",
      "ja": "これらの暗号システムは、[RFC3961]で定義されているように、完全な一般的なKerberos暗号化またはチェックサムシステムを意図していないことに注意してください。このドキュメントの操作と[RFC3961]で説明されているプリミティブの間に1つのマッピングはありません。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用されている規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" are to be interpreted as described in [RFC2119].",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2. Key Generation",
      "section_title": true,
      "ja": "2. キー生成"
    },
    {
      "indent": 3,
      "text": "On upgrade from existing Windows NT domains, the user accounts would not have a DES-based key available to enable the use of DES base encryption types specified in [RFC4120] and [RFC3961]. The key used for RC4-HMAC is the same as the existing Windows NT key (NT Password Hash) for compatibility reasons. Once the account password is changed, the DES-based keys are created and maintained. Once the DES keys are available, DES-based encryption types can be used with Kerberos.",
      "ja": "既存のWindows NTドメインからアップグレードすると、[RFC4120]および[RFC3961]で指定されたDESベース暗号化タイプの使用を可能にするために、ユーザーアカウントにはDESベースのキーが利用できません。RC4-HMACに使用されるキーは、互換性の理由で既存のWindows NTキー（NTパスワードハッシュ）と同じです。アカウントのパスワードが変更されると、DESベースのキーが作成および維持されます。DESキーが利用可能になると、DESベースの暗号化タイプをKerberosで使用できます。"
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC string to key function is defined as follows:",
      "ja": "キー関数へのRC4-HMAC文字列は、次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "String2Key(password)",
      "ja": ""
    },
    {
      "indent": 11,
      "text": "K = MD4(UNICODE(password))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC keys are generated by using the Windows UNICODE version of the password. Each Windows UNICODE character is encoded in little-endian format of 2 octets each. Then an MD4 [RFC1320] hash operation is performed on just the UNICODE characters of the password (not including the terminating zero octets).",
      "ja": "RC4-HMACキーは、パスワードのWindows Unicodeバージョンを使用して生成されます。各Windows Unicode文字は、それぞれ2オクテットのリトルエンディアン形式でエンコードされています。次に、MD4 [RFC1320]ハッシュ操作が、パスワードのUnicode文字のみで実行されます（終端ゼロオクテットは含まれません）。"
    },
    {
      "indent": 3,
      "text": "For an account with a password of \"foo\", this String2Key(\"foo\") will return:",
      "ja": "「foo」のパスワードがあるアカウントの場合、このstring2key（ \"foo\"）が返されます。"
    },
    {
      "indent": 11,
      "text": "0xac, 0x8e, 0x65, 0x7f, 0x83, 0xdf, 0x82, 0xbe, 0xea, 0x5d, 0x43, 0xbd, 0xaf, 0x78, 0x00, 0xcc",
      "ja": "0xac、0x8e、0x65、0x7f、0x83、0xdf、0x82、0xbe、0xea、0x5d、0xbd、0xaf、0x78、0x00、0xcc"
    },
    {
      "indent": 0,
      "text": "3. Basic Operations",
      "section_title": true,
      "ja": "3. 基本操作"
    },
    {
      "indent": 3,
      "text": "The MD5 HMAC function is defined in [RFC2104]. It is used in this encryption type for checksum operations. Refer to [RFC2104] for details on its operation. In this document, this function is referred to as HMAC(Key, Data) returning the checksum using the specified key on the data.",
      "ja": "MD5 HMAC関数は[RFC2104]で定義されています。この暗号化タイプでは、チェックサム操作に使用されます。その操作の詳細については、[RFC2104]を参照してください。このドキュメントでは、この関数は、データの指定されたキーを使用してチェックサムを返すHMAC（キー、データ）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "The basic MD5 hash operation is used in this encryption type and defined in [RFC1321]. In this document, this function is referred to as MD5(Data) returning the checksum of the data.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RC4 is a stream cipher licensed by RSA Data Security. In this document, the function is referred to as RC4(Key, Data) returning the encrypted data using the specified key on the data.",
      "ja": "RC4は、RSAデータセキュリティによってライセンスされているストリーム暗号です。このドキュメントでは、関数は、データの指定されたキーを使用して暗号化されたデータを返すRC4（キー、データ）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "These encryption types use key derivation. With each message, the message type (T) is used as a component of the keying material. The following table summarizes the different key derivation values used in the various operations. Note that these differ from the key derivations used in other Kerberos encryption types. T = the message type, encoded as a little-endian four-byte integer.",
      "ja": "これらの暗号化タイプは、キー派生を使用します。各メッセージで、メッセージタイプ（t）はキーイング素材のコンポーネントとして使用されます。次の表は、さまざまな操作で使用されるさまざまなキー派生値をまとめたものです。これらは、他のKerberos暗号化タイプで使用される重要な派生物とは異なることに注意してください。t =小さなエンディアンの4バイト整数としてエンコードされたメッセージタイプ。"
    },
    {
      "indent": 6,
      "text": "1. AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the client key (T=1) 2. AS-REP Ticket and TGS-REP Ticket (includes TGS session key or application session key), encrypted with the service key (T=2) 3. AS-REP encrypted part (includes TGS session key or application session key), encrypted with the client key (T=8) 4. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS session key (T=4) 5. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS authenticator subkey (T=5) 6. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum, keyed with the TGS session key (T=6) 7. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes TGS authenticator subkey), encrypted with the TGS session key T=7) 8. TGS-REP encrypted part (includes application session key), encrypted with the TGS session key (T=8) 9. TGS-REP encrypted part (includes application session key), encrypted with the TGS authenticator subkey (T=8)",
      "ja": "1. AS-REQ PA-ECN-TIMESTAMP PADATAタイムスタンプ、クライアントキー（T = 1）で暗号化された2. AS-REPチケットとTGS-REPチケット（TGSセッションキーまたはアプリケーションセッションキーを含む）、サービスキー（t）= 2）3。AS-REP暗号化された部品（TGSセッションキーまたはアプリケーションセッションキーを含む）、クライアントキー（T = 8）で暗号化された4. TGS-REQ KDC-REQ-BODY AuthorizationData、TGSセッションキーで暗号化された（T = 4）5。TGS-REQ KDC-REQ-Body AuthorizationData、TGS Authenticator Subkey（T = 5）で暗号化された6. TGS-REQ PA-TGS-REQ PADATA AP-REQ Authencator CKSUM。（T = 6）7。TGS-REQ PA-TGS-REQ PADATA AP-REQ Authenticator（TGS Authenticator Subkeyを含む）、TGSセッションキーT = 7）8.TGS-REP暗号化パーツ（アプリケーションセッションキーを含む）、TGSセッションキー（T = 8）で暗号化された9. TGS Authenticator Subkey（T = 8）で暗号化されたTGS-REP暗号化パーツ（アプリケーションセッションキーを含む）"
    },
    {
      "indent": 6,
      "text": "10. AP-REQ Authenticator cksum, keyed with the application session key (T=10) 11. AP-REQ Authenticator (includes application authenticator subkey), encrypted with the application session key (T=11) 12. AP-REP encrypted part (includes application session subkey), encrypted with the application session key (T=12) 13. KRB-PRIV encrypted part, encrypted with a key chosen by the application. Also for data encrypted with GSS Wrap (T=13) 14. KRB-CRED encrypted part, encrypted with a key chosen by the application (T=14) 15. KRB-SAFE cksum, keyed with a key chosen by the application. Also for data signed in GSS MIC (T=15)",
      "ja": "10. アプリケーションセッションキー（t = 10）でキー付きAP-REQ Authenticator CKSUM 11. AP-REQ Authenticator（アプリケーション認証者サブキーを含む）、アプリケーションセッションキー（T = 11）12.AP-REP暗号化された部品（アプリケーションセッションキー（t = 12）13で暗号化されたアプリケーションセッションサブキー）13。また、GSSラップ（t = 13）14で暗号化されたデータ用。14。アプリケーション（t = 14）15。KRB-Safe CKSUMで選択されたキーで暗号化されたKRB-CREDの暗号化された部分。また、GSSマイクに署名されたデータ（t = 15）"
    },
    {
      "indent": 6,
      "text": "Relative to RFC-1964 key uses:",
      "ja": ""
    },
    {
      "indent": 6,
      "text": "T = 0 in the generation of sequence number for the MIC token T = 0 in the generation of sequence number for the WRAP token T = 0 in the generation of encrypted data for the WRAPPED token",
      "ja": "マイクトークンT = 0のシーケンス番号の生成のt = 0ラップトークンT = 0のシーケンス番号の生成ラップされたトークンの暗号化データの生成におけるT = 0"
    },
    {
      "indent": 3,
      "text": "All strings in this document are ASCII unless otherwise specified. The lengths of ASCII-encoded character strings include the trailing terminator character (0). The concat(a,b,c,...) function will return the logical concatenation (left to right) of the values of the arguments. The nonce(n) function returns a pseudo-random number of \"n\" octets.",
      "ja": "このドキュメントのすべての文字列は、特に指定されていない限りASCIIです。Ascii-Enecoded文字列の長さには、後期ターミネーター文字（0）が含まれます。concat（a、b、c、...）関数は、引数の値の論理的連結（左から右）を返します。NonCe（n）関数は、「n」オクテットの擬似ランダム数を返します。"
    },
    {
      "indent": 0,
      "text": "4. Checksum Types",
      "section_title": true,
      "ja": "4. チェックサムタイプ"
    },
    {
      "indent": 3,
      "text": "There is one checksum type used in this encryption type. The Kerberos constant for this type is:",
      "ja": "この暗号化タイプで使用されるチェックサムタイプが1つあります。このタイプのkerberos定数は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "#define KERB_CHECKSUM_HMAC_MD5 (-138)",
      "ja": "#define kerb_checksum_hmac_md5（-138）"
    },
    {
      "indent": 6,
      "text": "The function is defined as follows:",
      "ja": "関数は次のように定義されています。"
    },
    {
      "indent": 6,
      "text": "K = the Key T = the message type, encoded as a little-endian four-byte integer",
      "ja": "k =キーt =メッセージタイプ、小さなエンディアンの4バイト整数としてエンコードされています"
    },
    {
      "indent": 6,
      "text": "CHKSUM(K, T, data)",
      "ja": "chksum（k、t、data）"
    },
    {
      "indent": 11,
      "text": "Ksign = HMAC(K, \"signaturekey\")  //includes zero octet at end\ntmp = MD5(concat(T, data))\nCHKSUM = HMAC(Ksign, tmp)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Encryption Types",
      "section_title": true,
      "ja": "5. 暗号化タイプ"
    },
    {
      "indent": 3,
      "text": "There are two encryption types used in these encryption types. The Kerberos constants for these types are:",
      "ja": "これらの暗号化タイプで使用される2つの暗号化タイプがあります。これらのタイプのKerberos定数は次のとおりです。"
    },
    {
      "indent": 11,
      "text": "#define KERB_ETYPE_RC4_HMAC 23 #define KERB_ETYPE_RC4_HMAC_EXP 24",
      "ja": "#define kerb_etype_rc4_hmac 23 #define kerb_etype_rc4_hmac_exp 24"
    },
    {
      "indent": 3,
      "text": "The basic encryption function is defined as follows:",
      "ja": "基本的な暗号化関数は、次のように定義されています。"
    },
    {
      "indent": 5,
      "text": "T = the message type, encoded as a little-endian four-byte integer.",
      "ja": "t =小さなエンディアンの4バイト整数としてエンコードされたメッセージタイプ。"
    },
    {
      "indent": 11,
      "text": "OCTET L40[14] = \"fortybits\";",
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The header field on the encrypted data in KDC messages is:",
      "ja": "KDCメッセージの暗号化されたデータのヘッダーフィールドは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "typedef struct _RC4_MDx_HEADER {\n    OCTET Checksum[16];\n    OCTET Confounder[8];\n} RC4_MDx_HEADER, *PRC4_MDx_HEADER;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "ENCRYPT (K, export, T, data)\n{\n    struct EDATA {\n        struct HEADER {\n                OCTET Checksum[16];\n                OCTET Confounder[8];\n        } Header;\n        OCTET Data[0];\n    } edata;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (export){\n    *((DWORD *)(L40+10)) = T;\n    K1 = HMAC(K, L40); // where the length of L40 in\n                       // octets is 14\n}\nelse\n{\n    K1 = HMAC(K, &T); // where the length of T in octets\n                      // is 4\n}\nmemcpy (K2, K1, 16);\nif (export) memset (K1+7, 0xAB, 9);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "nonce (edata.Confounder, 8); memcpy (edata.Data, data);",
      "ja": "nonce（edata.confounder、8）;memcpy（edata.data、data）;"
    },
    {
      "indent": 15,
      "text": "edata.Checksum = HMAC (K2, edata);\nK3 = HMAC (K1, edata.Checksum);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": " RC4 (K3, edata.Confounder); RC4 (K3, data.Data); }",
      "ja": "RC4（K3、edata.Confounder）;RC4（K3、data.data）;}"
    },
    {
      "indent": 11,
      "text": "DECRYPT (K, export, T, edata)\n{\n    // edata looks like\n    struct EDATA {\n        struct HEADER {\n                OCTET Checksum[16];\n                OCTET Confounder[8];\n        } Header;\n        OCTET Data[0];\n    } edata;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (export){\n    *((DWORD *)(L40+10)) = T;\n    HMAC (K, L40, 14, K1);\n}\nelse\n{\n    HMAC (K, &T, 4, K1);\n}\nmemcpy (K2, K1, 16);\nif (export) memset (K1+7, 0xAB, 9);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "K3 = HMAC (K1, edata.Checksum);\nRC4 (K3, edata.Confounder);\nRC4 (K3, edata.Data);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    // verify generated and received checksums\n  checksum = HMAC (K2, concat(edata.Confounder, edata.Data));\n    if (checksum != edata.Checksum)\n        printf(\"CHECKSUM ERROR  !!!!!!\\n\");\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The KDC message is encrypted using the ENCRYPT function not including the Checksum in the RC4_MDx_HEADER.",
      "ja": "KDCメッセージは、RC4_MDX_Headerにチェックサムを含まない暗号化機能を使用して暗号化されます。"
    },
    {
      "indent": 3,
      "text": "The character constant \"fortybits\" evolved from the time when a 40-bit key length was all that was exportable from the United States. It is now used to recognize that the key length is of \"exportable\" length. In this description, the key size is actually 56 bits.",
      "ja": "キャラクターの一定の「40ビット」は、40ビットのキー長が米国から輸出可能だったときから進化しました。現在、キーの長さが「エクスポート可能な」長さであることを認識するために使用されています。この説明では、キーサイズは実際には56ビットです。"
    },
    {
      "indent": 3,
      "text": "The pseudo-random operation [RFC3961] for both enctypes above is defined as follows:",
      "ja": ""
    },
    {
      "indent": 11,
      "text": "pseudo-random(K, S) = HMAC-SHA1(K, S)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where K is the protocol key and S is the input octet string. HMAC-SHA1 is defined in [RFC2104] and the output of HMAC-SHA1 is the 20-octet digest.",
      "ja": "ここで、Kはプロトコルキーであり、Sは入力オクテット文字列です。HMAC-SHA1は[RFC2104]で定義されており、HMAC-SHA1の出力は20オクテットのダイジェストです。"
    },
    {
      "indent": 0,
      "text": "6. Key Strength Negotiation",
      "section_title": true,
      "ja": "6. 主要な強さの交渉"
    },
    {
      "indent": 3,
      "text": "A Kerberos client and server can negotiate over key length if they are using mutual authentication. If the client is unable to perform full-strength encryption, it may propose a key in the \"subkey\" field of the authenticator, using a weaker encryption type. The server must then either return the same key or suggest its own key in the subkey field of the AP reply message. The key used to encrypt data is derived from the key returned by the server. If the client is able to perform strong encryption but the server is not, it may propose a subkey in the AP reply without first being sent a subkey in the authenticator.",
      "ja": "Kerberosのクライアントとサーバーは、相互認証を使用している場合、キーの長さを超えてネゴシエートできます。クライアントがフルストレングの暗号化を実行できない場合、より弱い暗号化タイプを使用して、認証器の「サブキー」フィールドにキーを提案する場合があります。サーバーは、同じキーを返すか、AP Replyメッセージのサブキーフィールドに独自のキーを提案する必要があります。データを暗号化するために使用されるキーは、サーバーによって返されるキーから派生します。クライアントが強力な暗号化を実行できますが、サーバーがそうでない場合、APの返信でサブキーを最初に認証者に送信することなく提案する場合があります。"
    },
    {
      "indent": 0,
      "text": "7. GSS-API Kerberos V5 Mechanism Type",
      "section_title": true,
      "ja": "7. GSS-API Kerberos V5メカニズムタイプ"
    },
    {
      "indent": 0,
      "text": "7.1. Mechanism Specific Changes",
      "section_title": true,
      "ja": "7.1. メカニズム固有の変化"
    },
    {
      "indent": 3,
      "text": "The Generic Security Service Application Program Interface (GSS-API) per-message tokens also require new checksum and encryption types. The GSS-API per-message tokens are adapted to support these new encryption types. See [RFC1964] Section 1.2.2.",
      "ja": "ジェネリックセキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）1回のトークンには、新しいチェックサムと暗号化の種類も必要です。GSS-APIメッセージごとのトークンは、これらの新しい暗号化タイプをサポートするために適合しています。[RFC1964]セクション1.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The only support quality of protection is:",
      "ja": ""
    },
    {
      "indent": 9,
      "text": "#define GSS_KRB5_INTEG_C_QOP_DEFAULT 0x0",
      "ja": "#define gss_krb5_integ_c_qop_default 0x0"
    },
    {
      "indent": 3,
      "text": "When using this RC4-based encryption type, the sequence number is always sent in big-endian rather than little-endian order.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Windows 2000 implementation also defines new GSS-API flags in the initial token passed when initializing a security context. These flags are passed in the checksum field of the authenticator. See [RFC1964] Section 1.1.1.",
      "ja": "Windows 2000の実装は、セキュリティコンテキストを初期化するときに渡された最初のトークンの新しいGSS-APIフラグも定義します。これらのフラグは、認証機のチェックサムフィールドに渡されます。[RFC1964]セクション1.1.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "GSS_C_DCE_STYLE - This flag was added for use with Microsoft's implementation of Distributed Computing Environment Remote Procedure Call (DCE RPC), which initially expected three legs of authentication. Setting this flag causes an extra AP reply to be sent from the client back to the server after receiving the server's AP reply. In addition, the context negotiation tokens do not have GSS-API per-message tokens -- they are raw AP messages that do not include object identifiers.",
      "ja": ""
    },
    {
      "indent": 11,
      "text": "#define GSS_C_DCE_STYLE 0x1000",
      "ja": "#define gss_c_dce_style 0x1000"
    },
    {
      "indent": 3,
      "text": "GSS_C_IDENTIFY_FLAG - This flag allows the client to indicate to the server that it should only allow the server application to identify the client by name and ID, but not to impersonate the client.",
      "ja": "gss_c_identify_flag-このフラグにより、クライアントはサーバーに、サーバーアプリケーションが名前とIDでクライアントを識別できるようにする必要があることをサーバーに示すことができますが、クライアントになりすましません。"
    },
    {
      "indent": 11,
      "text": "#define GSS_C_IDENTIFY_FLAG 0x2000",
      "ja": "#define gss_c_identify_flag 0x2000"
    },
    {
      "indent": 3,
      "text": "GSS_C_EXTENDED_ERROR_FLAG - Setting this flag indicates that the client wants to be informed of extended error information. In particular, Windows 2000 status codes may be returned in the data field of a Kerberos error message. This allows the client to understand a server failure more precisely. In addition, the server may return errors to the client that are normally handled at the application layer in the server, in order to let the client try to recover. After receiving an error message, the client may attempt to resubmit an AP request.",
      "ja": ""
    },
    {
      "indent": 11,
      "text": "#define GSS_C_EXTENDED_ERROR_FLAG 0x4000",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These flags are only used if a client is aware of these conventions when using the Security Support Provider Interface (SSPI) on the Windows platform; they are not generally used by default.",
      "ja": "これらのフラグは、Windowsプラットフォームでセキュリティサポートプロバイダーインターフェイス（SSPI）を使用する際に、クライアントがこれらの規則を認識している場合にのみ使用されます。通常、デフォルトでは使用されません。"
    },
    {
      "indent": 3,
      "text": "When NetBIOS addresses are used in the GSS-API, they are identified by the GSS_C_AF_NETBIOS value. This value is defined as:",
      "ja": ""
    },
    {
      "indent": 11,
      "text": "#define GSS_C_AF_NETBIOS 0x14",
      "ja": "#define gss_c_af_netbios 0x14"
    },
    {
      "indent": 3,
      "text": "NetBios addresses are 16-octet addresses typically composed of 1 to 15 characters, trailing blank (ASCII char 20) filled, with a 16th octet of 0x0.",
      "ja": "NetBiosアドレスは、通常1〜15文字で構成される16オクテットアドレスで、トレーニングブランク（ASCII Char 20）が16番目のオクテットで0x0です。"
    },
    {
      "indent": 0,
      "text": "7.2. GSS-API MIC Semantics",
      "section_title": true,
      "ja": "7.2. GSS-API MICセマンティクス"
    },
    {
      "indent": 3,
      "text": "The GSS-API checksum type and algorithm are defined in Section 5. Only the first 8 octets of the checksum are used. The resulting checksum is stored in the SGN_CKSUM field. See [RFC1964] Section 1.2 for GSS_GetMIC() and GSS_Wrap(conf_flag=FALSE).",
      "ja": "GSS-APIチェックサムのタイプとアルゴリズムは、セクション5で定義されています。チェックサムの最初の8オクテットのみが使用されます。結果のチェックサムは、sgn_cksumフィールドに保存されます。[rfc1964] gss_getmic（）およびgss_wrap（conf_flag = false）については、[rfc1964]セクション1.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "The GSS_GetMIC token has the following format:",
      "ja": "GSS_GETMICトークンには次の形式があります。"
    },
    {
      "indent": 8,
      "text": "Byte no         Name        Description\n0..1           TOK_ID     Identification field.\n                          Tokens emitted by GSS_GetMIC() contain\n                          the hex value 01 01 in this field.\n2..3           SGN_ALG    Integrity algorithm indicator.\n                          11 00 - HMAC\n4..7           Filler     Contains ff ff ff ff\n8..15          SND_SEQ    Sequence number field.\n16..23         SGN_CKSUM  Checksum of \"to-be-signed data\",\n                          calculated according to algorithm\n                          specified in SGN_ALG field.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MIC mechanism used for GSS-MIC-based messages is as follows:",
      "ja": "GSS-MICベースのメッセージに使用されるMICメカニズムは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "GetMIC(Kss, direction, export, seq_num, data)\n{\n        struct Token {\n               struct Header {\n                      OCTET TOK_ID[2];\n                      OCTET SGN_ALG[2];\n                      OCTET Filler[4];\n                 };\n               OCTET SND_SEQ[8];\n               OCTET SGN_CKSUM[8];\n        } Token;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Token.TOK_ID = 01 01;\nToken.SGN_SLG = 11 00;\nToken.Filler = ff ff ff ff;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Create the sequence number",
      "ja": "//シーケンス番号を作成します"
    },
    {
      "indent": 19,
      "text": "if (direction == sender_is_initiator)\n{\n        memset(Token.SEND_SEQ+4, 0xff, 4)\n}\nelse if (direction == sender_is_acceptor)\n{\n        memset(Token.SEND_SEQ+4, 0, 4)\n}\nToken.SEND_SEQ[0] = (seq_num & 0xff000000) >> 24;\nToken.SEND_SEQ[1] = (seq_num & 0x00ff0000) >> 16;\nToken.SEND_SEQ[2] = (seq_num & 0x0000ff00) >> 8;\nToken.SEND_SEQ[3] = (seq_num & 0x000000ff);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Derive signing key from session key",
      "ja": "//セッションキーから署名キーを導き出します"
    },
    {
      "indent": 19,
      "text": "Ksign = HMAC(Kss, \"signaturekey\");\n                  // length includes terminating null",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Generate checksum of message - SGN_CKSUM // Key derivation salt = 15",
      "ja": "//メッセージのチェックサムを生成-SGN_CKSUM //キー派生塩= 15"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = MD5((int32)15, Token.Header, data);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Save first 8 octets of HMAC Sgn_Cksum",
      "ja": "// hmac sgn_cksumの最初の8オクテットを保存します"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);\nmemcpy(Token.SGN_CKSUM, Sgn_Cksum, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化します"
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for the sequence number // Key derivation salt = 0",
      "ja": "//シーケンス番号の暗号化キーを導き出す//キー派生塩= 0"
    },
    {
      "indent": 19,
      "text": "if (exportable)\n{\n        Kseq = HMAC(Kss, \"fortybits\", (int32)0);\n                     // len includes terminating null\n        memset(Kseq+7, 0xab, 7)\n}\nelse\n{\n         Kseq = HMAC(Kss, (int32)0);\n}\nKseq = HMAC(Kseq, Token.SGN_CKSUM);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化します"
    },
    {
      "indent": 11,
      "text": " RC4(Kseq, Token.SND_SEQ); }",
      "ja": "rc4（kseq、token.snd_seq）;}"
    },
    {
      "indent": 0,
      "text": "7.3. GSS-API WRAP Semantics",
      "section_title": true,
      "ja": "7.3. GSS-APIラップセマンティクス"
    },
    {
      "indent": 3,
      "text": "There are two encryption keys for GSS-API message tokens, one that is 128 bits in strength and one that is 56 bits in strength as defined in Section 6.",
      "ja": "GSS-APIメッセージトークンには2つの暗号化キーがあり、1つは強度が128ビット、もう1つはセクション6で定義されているように強度が56ビットです。"
    },
    {
      "indent": 3,
      "text": "All padding is rounded up to 1 byte. One byte is needed to say that there is 1 byte of padding. The DES-based mechanism type uses 8-byte padding. See [RFC1964] Section 1.2.2.3.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The RC4-HMAC GSS_Wrap() token has the following format:",
      "ja": "RC4-HMAC GSS_WRAP（）トークンには次の形式があります。"
    },
    {
      "indent": 6,
      "text": "Byte no          Name         Description\n  0..1           TOK_ID       Identification field.\n                              Tokens emitted by GSS_Wrap() contain\n                              the hex value 02 01 in this field.\n  2..3           SGN_ALG      Checksum algorithm indicator.\n                              11 00 - HMAC\n  4..5           SEAL_ALG     ff ff - none\n                              00 00 - DES-CBC\n                              10 00 - RC4\n  6..7           Filler       Contains ff ff\n  8..15          SND_SEQ      Encrypted sequence number field.\n  16..23         SGN_CKSUM    Checksum of plaintext padded data,\n                              calculated according to algorithm\n                              specified in SGN_ALG field.\n  24..31         Confounder   Random confounder.\n  32..last       Data         Encrypted or plaintext padded data.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The encryption mechanism used for GSS-wrap-based messages is as follows:",
      "ja": "GSS-Wrapベースのメッセージに使用される暗号化メカニズムは次のとおりです。"
    },
    {
      "indent": 11,
      "text": "WRAP(Kss, encrypt, direction, export, seq_num, data)\n{\n        struct Token {          // 32 octets\n               struct Header {\n                      OCTET TOK_ID[2];\n                      OCTET SGN_ALG[2];\n                      OCTET SEAL_ALG[2];\n                      OCTET Filler[2];\n               };\n               OCTET SND_SEQ[8];\n               OCTET SGN_CKSUM[8];\n                 OCTET Confounder[8];\n        } Token;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Token.TOK_ID = 02 01;\nToken.SGN_SLG = 11 00;\nToken.SEAL_ALG = (no_encrypt)? ff ff : 10 00;\nToken.Filler = ff ff;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Create the sequence number",
      "ja": "//シーケンス番号を作成します"
    },
    {
      "indent": 19,
      "text": "if (direction == sender_is_initiator) {",
      "ja": "if（direction == sender_is_initiator）{"
    },
    {
      "indent": 19,
      "text": "        memset(&Token.SEND_SEQ[4], 0xff, 4)\n}\nelse if (direction == sender_is_acceptor)\n{\n        memset(&Token.SEND_SEQ[4], 0, 4)\n}\nToken.SEND_SEQ[0] = (seq_num & 0xff000000) >> 24;\nToken.SEND_SEQ[1] = (seq_num & 0x00ff0000) >> 16;\nToken.SEND_SEQ[2] = (seq_num & 0x0000ff00) >> 8;\nToken.SEND_SEQ[3] = (seq_num & 0x000000ff);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Generate random confounder",
      "ja": "//ランダム交絡因子を生成します"
    },
    {
      "indent": 19,
      "text": "nonce(&Token.Confounder, 8);",
      "ja": "nonce（＆token.confounder、8）;"
    },
    {
      "indent": 19,
      "text": "// Derive signing key from session key",
      "ja": "//セッションキーから署名キーを導き出します"
    },
    {
      "indent": 19,
      "text": "Ksign = HMAC(Kss, \"signaturekey\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Generate checksum of message -\n//  SGN_CKSUM + Token.Confounder\n//   Key derivation salt = 15",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = MD5((int32)15, Token.Header, Token.Confounder);",
      "ja": "sgn_cksum = md5（（int32）15、token.header、token.confounder）;"
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for data // Key derivation salt = 0",
      "ja": "//データの暗号化キーを導き出す//キー派生塩= 0"
    },
    {
      "indent": 19,
      "text": "for (i = 0; i < 16; i++) Klocal[i] = Kss[i] ^ 0xF0;\n                                         // XOR\nif (exportable)\n{\n        Kcrypt = HMAC(Klocal, \"fortybits\", (int32)0);\n                    // len includes terminating null\n        memset(Kcrypt+7, 0xab, 7);\n}\nelse\n{\n        Kcrypt = HMAC(Klocal, (int32)0);\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// new encryption key salted with seq",
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Kcrypt = HMAC(Kcrypt, (int32)seq);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encrypt confounder (if encrypting)",
      "ja": "//暗号化交絡因子（暗号化の場合）"
    },
    {
      "indent": 19,
      "text": "if (encrypt) RC4(Kcrypt, Token.Confounder);",
      "ja": "if（encrypt）rc4（kcrypt、token.confounder）;"
    },
    {
      "indent": 19,
      "text": "// Sum the data buffer",
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum += MD5(data);         // Append to checksum",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encrypt the data (if encrypting)",
      "ja": "//データを暗号化する（暗号化の場合）"
    },
    {
      "indent": 19,
      "text": "if (encrypt) RC4(Kcrypt, data);",
      "ja": "if（encrypt）rc4（kcrypt、data）;"
    },
    {
      "indent": 19,
      "text": "// Save first 8 octets of HMAC Sgn_Cksum",
      "ja": "// hmac sgn_cksumの最初の8オクテットを保存します"
    },
    {
      "indent": 19,
      "text": "Sgn_Cksum = HMAC(Ksign, Sgn_Cksum);\nmemcpy(Token.SGN_CKSUM, Sgn_Cksum, 8);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Derive encryption key for the sequence number // Key derivation salt = 0",
      "ja": "//シーケンス番号の暗号化キーを導き出す//キー派生塩= 0"
    },
    {
      "indent": 19,
      "text": "if (exportable)\n{\n        Kseq = HMAC(Kss, \"fortybits\", (int32)0);\n                    // len includes terminating null\n        memset(Kseq+7, 0xab, 7)\n}\nelse\n{\n        Kseq = HMAC(Kss, (int32)0);\n}\nKseq = HMAC(Kseq, Token.SGN_CKSUM);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "// Encrypt the sequence number",
      "ja": "//シーケンス番号を暗号化します"
    },
    {
      "indent": 19,
      "text": "RC4(Kseq, Token.SND_SEQ);",
      "ja": "rc4（kseq、token.snd_seq）;"
    },
    {
      "indent": 11,
      "text": "        // Encrypted message = Token + Data\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The character constant \"fortybits\" evolved from the time when a 40-bit key length was all that was exportable from the United States. It is now used to recognize that the key length is of \"exportable\" length. In this description, the key size is actually 56 bits.",
      "ja": "キャラクターの一定の「40ビット」は、40ビットのキー長が米国から輸出可能だったときから進化しました。現在、キーの長さが「エクスポート可能な」長さであることを認識するために使用されています。この説明では、キーサイズは実際には56ビットです。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Care must be taken in implementing these encryption types because they use a stream cipher. If a different IV is not used in each direction when using a session key, the encryption is weak. By using the sequence number as an IV, this is avoided.",
      "ja": "これらの暗号化タイプは、ストリーム暗号を使用するため、これらの暗号化タイプを実装することに注意する必要があります。セッションキーを使用するときに、それぞれの方向に別のIVが使用されない場合、暗号化は弱いです。シーケンス番号をIVとして使用することにより、これは回避されます。"
    },
    {
      "indent": 3,
      "text": "There are two classes of attack on RC4 described in [MIRONOV]. Strong distinguishers distinguish an RC4 keystream from randomness at the start of the stream. Weak distinguishers can operate on any part of the keystream, and the best ones, described in [FMcG] and [MANTIN05], can exploit data from multiple, different keystreams. A consequence of these is that encrypting the same data (for instance, a password) sufficiently many times in separate RC4 keystreams can be sufficient to leak information to an adversary. The encryption types defined in this document defend against these by constructing a new keystream for every message. However, it is RECOMMENDED not to use the RC4 encryption types defined in this document for high-volume connections.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Weaknesses in MD4 [BOER91] were demonstrated by den Boer and Bosselaers in 1991. In August 2004, Xiaoyun Wang, et al., reported MD4 collisions generated using hand calculation [WANG04]. Implementations based on Wang's algorithm can find collisions in real time. However, the intended usage of MD4 described in this document does not rely on the collision-resistant property of MD4. Furthermore, MD4 is always used in the context of a keyed hash in this document. Although no evidence has suggested keyed MD4 hashes are vulnerable to collision-based attacks, no study has directly proved that the HMAC-MD4 is secure: the existing study simply assumed that the hash function used in HMAC is collision proof. It is thus RECOMMENDED not to use the RC4 encryption types defined in this document if alternative stronger encryption types, such as aes256-cts-hmac-sha1-96 [RFC3962], are available.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 5 of this document defines two Kerberos encryption types rc4-hmac (23) and rc4-hmac-exp (24). The Kerberos parameters registration page at <http://www.iana.org/assignments/kerberos-parameters> has been updated to reference this document for these two encryption types.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. Acknowledgements",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank Sam Hartman, Ken Raeburn, and Qunli Li for their insightful comments.",
      "ja": "著者は、サム・ハートマン、ケン・レーバーン、Qunli Liの洞察に満ちたコメントに感謝したいと考えています。"
    },
    {
      "indent": 0,
      "text": "11. References",
      "section_title": true,
      "ja": "11. 参考文献"
    },
    {
      "indent": 0,
      "text": "11.1. Normative References",
      "section_title": true,
      "ja": "11.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC1320] Rivest, R., \"The MD4 Message-Digest Algorithm\", RFC 1320, April 1992.",
      "ja": "[RFC1320] Rivest、R。、「The MD4 Message-Digest Algorithm」、RFC 1320、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC1321] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. CaNetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[RFC3962] Raeburn, K., \"Advanced Encryption Standard (AES) Encryption for Kerberos 5\", RFC 3962, February 2005.",
      "ja": "[RFC3962] Raeburn、K。、「高度な暗号化標準（AES）Kerberos 5の暗号化」、RFC 3962、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120] Neuman、C.、Yu、T.、Hartman、S。、およびK. Raeburn、「The Kerberos Network認証サービス（V5）」、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4537] Zhu, L., Leach, P., and K. Jaganathan, \"Kerberos Cryptosystem Negotiation Extension\", RFC 4537, June 2006.",
      "ja": "[RFC4537] Zhu、L.、Leach、P。、およびK. Jaganathan、「Kerberos Cryptosystem Negotiation Extension」、RFC 4537、2006年6月。"
    },
    {
      "indent": 0,
      "text": "11.2. Informative References",
      "section_title": true,
      "ja": "11.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BOER91] den Boer, B. and A. Bosselaers, \"An Attack on the Last Two Rounds of MD4\", Proceedings of the 11th Annual International Cryptology Conference on Advances in Cryptology, pages: 194 - 203, 1991.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[FMcG] Fluhrer, S. and D. McGrew, \"Statistical Analysis of the Alleged RC4 Keystream Generator\", Fast Software Encryption: 7th International Workshop, FSE 2000, April 2000, <http://www.mindspring.com/~dmcgrew/rc4-03.pdf>.",
      "ja": "[FMCG] Fluhrer、S。およびD. McGrew、「疑わしいRC4キーストリームジェネレーターの統計分析」、高速ソフトウェア暗号化：第7回国際ワークショップ、FSE 2000、2000年4月、<http://www.mindspring.com/~dmcregrea/rc4-03.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MANTIN05] Mantin, I., \"Predicting and Distinguishing Attacks on RC4 Keystream Generator\", Advances in Cryptology -- EUROCRYPT 2005: 24th Annual International Conference on the Theory and Applications of Cryptographic Techniques, May 2005.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[MIRONOV] Mironov, I., \"(Not So) Random Shuffles of RC4\", Advances in Cryptology -- CRYPTO 2002: 22nd Annual International Cryptology Conference, August 2002, <http://eprint.iacr.org/2002/067.pdf>.",
      "ja": "[Mironov] Mironov、I。、「（そうではない）RC4のランダムシャッフル」、暗号学の進歩 -  Crypto 2002：22nd Annulational Cryptology Conference、2002年8月、<http://eprint.iacr.org/2002/067.pdf>。"
    },
    {
      "indent": 3,
      "text": "[WANG04] Wang, X., Lai, X., Feng, D., Chen, H., and X. Yu, \"Cryptanalysis of Hash functions MD4 and RIPEMD\", August 2004, <http://www.infosec.sdu.edu.cn/paper/md4-ripemd-attck.pdf>.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Karthik Jaganathan Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EMail: karthikj@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Larry Zhu Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "Larry Zhu Microsoft Corporation One Microsoft Way Redmond、WA 98052 US"
    },
    {
      "indent": 3,
      "text": "EMail: lzhu@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "John Brezak Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "John Brezak Microsoft Corporation One Microsoft Way Redmond、WA 98052 US"
    },
    {
      "indent": 3,
      "text": "EMail: jbrezak@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2006).",
      "ja": "Copyright（c）The IETF Trust（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST, AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}