{
  "title": {
    "text": "RFC 4995 - The RObust Header Compression (ROHC) Framework",
    "ja": "RFC 4995 - 堅牢なヘッダー圧縮（ROHC）フレームワーク"
  },
  "number": 4995,
  "created_at": "2023-05-07 13:17:49.897938+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       L-E. Jonsson\nRequest for Comments: 4995                                  G. Pelletier\nCategory: Standards Track                                    K. Sandlund\n                                                                Ericsson\n                                                               July 2007",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "The RObust Header Compression (ROHC) Framework",
      "ja": "堅牢なヘッダー圧縮（ROHC）フレームワーク"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Robust Header Compression (ROHC) protocol provides an efficient, flexible, and future-proof header compression concept. It is designed to operate efficiently and robustly over various link technologies with different characteristics.",
      "ja": "堅牢なヘッダー圧縮（ROHC）プロトコルは、効率的で柔軟な、将来のヘッダー圧縮概念を提供します。さまざまな特性を持つさまざまなリンクテクノロジーで効率的かつ堅牢に動作するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The ROHC framework, along with a set of compression profiles, was initially defined in RFC 3095. To improve and simplify the ROHC specifications, this document explicitly defines the ROHC framework and the profile for uncompressed separately. More specifically, the definition of the framework does not modify or update the definition of the framework specified by RFC 3095.",
      "ja": "ROHCフレームワークは、圧縮プロファイルのセットとともに、RFC 3095で最初に定義されていました。ROHC仕様を改善および簡素化するために、このドキュメントはROHCフレームワークと非圧縮のプロファイルを個別に定義します。より具体的には、フレームワークの定義は、RFC 3095で指定されたフレームワークの定義を変更または更新しません。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Terminology .....................................................4\n   2.1. Acronyms ...................................................4\n   2.2. ROHC Terminology ...........................................4\n3. Background (Informative) ........................................7\n   3.1. Header Compression Fundamentals ............................7\n   3.2. A Short History of Header Compression ......................7\n4. Overview of Robust Header Compression (ROHC) (Informative) ......8\n   4.1. General Principles .........................................8\n   4.2. Compression Efficiency, Robustness, and Transparency ......10\n   4.3. Developing the ROHC Protocol ..............................10\n      4.4. Operational Characteristics of the ROHC Channel ...........11\n   4.5. Compression and Master Sequence Number (MSN) ..............13\n   4.6. Static and Dynamic Parts of a Context .....................13\n5. The ROHC Framework (Normative) .................................14\n   5.1. The ROHC Channel ..........................................14\n        5.1.1. Contexts and Context Identifiers ...................14\n        5.1.2. Per-Channel Parameters .............................15\n        5.1.3. Persistence of Decompressor Contexts ...............16\n   5.2. ROHC Packets and Packet Types .............................16\n        5.2.1. General Format of ROHC Packets .....................17\n               5.2.1.1. Format of the Padding Octet ...............17\n               5.2.1.2. Format of the Add-CID Octet ...............18\n               5.2.1.3. General Format of Header ..................18\n        5.2.2. Initialization and Refresh (IR) Packet Types .......19\n               5.2.2.1. ROHC IR Packet Type .......................20\n               5.2.2.2. ROHC IR-DYN Packet Type ...................20\n        5.2.3. ROHC Initial Decompressor Processing ...............21\n        5.2.4. ROHC Feedback ......................................22\n               5.2.4.1. ROHC Feedback Format ......................23\n        5.2.5. ROHC Segmentation ..................................25\n               5.2.5.1. Segmentation Usage Considerations .........25\n               5.2.5.2. Segmentation Protocol .....................26\n   5.3. General Encoding Methods ..................................27\n        5.3.1. Header Compression CRCs, Coverage and Polynomials ..27\n               5.3.1.1. 8-bit CRCs in IR and IR-DYN Headers .......27\n               5.3.1.2. 3-bit CRC in Compressed Headers ...........27\n               5.3.1.3. 7-bit CRC in Compressed Headers ...........28\n               5.3.1.4. 32-bit Segmentation CRC ...................28\n        5.3.2. Self-Describing Variable-Length Values .............29\n   5.4. ROHC UNCOMPRESSED -- No Compression  (Profile 0x0000) .....29\n        5.4.1. IR Packet ..........................................30\n        5.4.2. Normal Packet ......................................31\n        5.4.3. Decompressor Operation .............................31\n        5.4.4. Feedback ...........................................32\n6. Overview of a ROHC Profile (Informative) .......................32\n7. Security Considerations ........................................33\n8. IANA Considerations ............................................34\n9. Acknowledgments ................................................35\n10. References ....................................................35\n   10.1. Normative References .....................................35\n   10.2. Informative References ...................................35\nAppendix A.  CRC Algorithm ........................................37",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "For many types of networks, reducing the deployment and operational costs by improving the usage of the bandwidth resources is of vital importance. Header compression over a link is possible because some of the information carried within the header of a packet becomes compressible between packets belonging to the same flow.",
      "ja": "多くの種類のネットワークでは、帯域幅リソースの使用を改善することで展開と運用コストを削減することが非常に重要です。リンク上のヘッダー圧縮は、パケットのヘッダー内にある情報の一部が、同じフローに属するパケット間で圧縮可能になるため、可能です。"
    },
    {
      "indent": 3,
      "text": "For links where the overhead of the IP header(s) is problematic, the total size of the header may be significant. Applications carrying data carried within RTP [13] will then, in addition to link-layer framing, have an IPv4 [10] header (20 octets), a UDP [12] header (8 octets), and an RTP header (12 octets), for a total of 40 octets. With IPv6 [11], the IPv6 header is 40 octets for a total of 60 octets. Applications transferring data using TCP [14] will have 20 octets for the transport header, for a total size of 40 octets for IPv4 and 60 octets for IPv6.",
      "ja": "IPヘッダーのオーバーヘッドに問題があるリンクの場合、ヘッダーの合計サイズが重要である可能性があります。RTP [13]内で運ばれるデータを伝達するアプリケーションは、リンク層フレーミングに加えて、IPv4 [10]ヘッダー（20オクテット）、UDP [12]ヘッダー（8オクテット）、およびRTPヘッダー（12オクテット）を持ちます。）、合計40オクテット。IPv6 [11]では、IPv6ヘッダーは40オクテットで、合計60オクテットがあります。TCP [14]を使用してデータを転送するアプリケーションには、トランスポートヘッダーに20オクテットがあり、IPv4の合計40オクテット、IPv6で60オクテットがあります。"
    },
    {
      "indent": 3,
      "text": "The relative gain for specific flows (or applications) depends on the size of the payload used in each packet. For applications such as Voice-over-IP, where the size of the payload containing coded speech can be as small as 15-20 octets, this gain will be quite significant. Similarly, relative gains for TCP flows carrying large payloads (such as file transfers) will be less than for flows carrying smaller payloads (such as application signaling, e.g., session initiation).",
      "ja": "特定のフロー（またはアプリケーション）の相対的なゲインは、各パケットで使用されるペイロードのサイズに依存します。コード化された音声を含むペイロードのサイズが15〜20オクテットになる可能性があるVoice-over-IPなどのアプリケーションの場合、このゲインは非常に重要です。同様に、大きなペイロード（ファイル転送など）を運ぶTCPフローの相対的な利益は、小さいペイロード（アプリケーションシグナリングなど）を運ぶフローの場合よりも少なくなります。"
    },
    {
      "indent": 3,
      "text": "As more and more wireless link technologies are being deployed to carry IP traffic, care must be taken to address the specific characteristics of these technologies within the header compression algorithms. Legacy header compression schemes, such as those defined in [16] and [17], have been shown to perform inadequately over links where both the lossy behavior and the round-trip times are non-negligible, such as those observed for example in wireless links and IP tunnels.",
      "ja": "ますます多くのワイヤレスリンクテクノロジーが展開されているため、IPトラフィックを運ぶには、ヘッダー圧縮アルゴリズム内のこれらのテクノロジーの特定の特性に対処するために注意する必要があります。[16]および[17]で定義されているものなどのレガシーヘッダー圧縮スキームは、無数の動作と往復時間の両方が無視できないリンクに対して不十分に実行されることが示されています。リンクとIPトンネル。"
    },
    {
      "indent": 3,
      "text": "In addition, a header compression scheme should handle the often non-trivial residual errors, i.e., where the lower layer may pass a packet that contains undetected bit errors to the decompressor. It should also handle loss and reordering before the compression point, as well as on the link between the compression and decompression points [7].",
      "ja": "さらに、ヘッダー圧縮スキームは、しばしば自明ではない残留エラーを処理する必要があります。つまり、下層が減圧器に検出されないビットエラーを含むパケットを渡す場合があります。また、圧縮ポイントの前に、および圧縮ポイントと減圧点の間のリンク上で損失と並べ替えを処理する必要があります[7]。"
    },
    {
      "indent": 3,
      "text": "The Robust Header Compression (ROHC) protocol provides an efficient, flexible, and future-proof header compression concept. It is designed to operate efficiently and robustly over various link technologies with different characteristics.",
      "ja": "堅牢なヘッダー圧縮（ROHC）プロトコルは、効率的で柔軟な、将来のヘッダー圧縮概念を提供します。さまざまな特性を持つさまざまなリンクテクノロジーで効率的かつ堅牢に動作するように設計されています。"
    },
    {
      "indent": 3,
      "text": "RFC 3095 [3] defines the ROHC framework along with an initial set of compression profiles. To improve and simplify the specification, the framework and the profiles' parts have been split into separate documents. This document explicitly defines the ROHC framework, but it does not modify or update the definition of the framework specified by RFC 3095; both documents can be used independently of each other. This also implies that implementations based on either definition will be compatible and interoperable with each other. However, it is the intent to let this specification replace RFC 3095 as the base specification for all profiles defined in the future.",
      "ja": "RFC 3095 [3]は、圧縮プロファイルの初期セットとともにROHCフレームワークを定義します。仕様を改善および簡素化するために、フレームワークとプロファイルの部分は個別のドキュメントに分割されています。このドキュメントは、ROHCフレームワークを明示的に定義していますが、RFC 3095で指定されたフレームワークの定義を変更または更新しません。両方のドキュメントは、互いに独立して使用できます。これは、いずれかの定義に基づく実装が互いに互換性があり、相互運用可能であることを意味します。ただし、将来定義されているすべてのプロファイルの基本仕様として、この仕様をRFC 3095に置き換えることを目的としています。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [1].",
      "ja": "「必須」、「そうしない」、「必須」、「shall」、「shall \"、\" ingle \"、\" should \"、\" not \"、\" becommended \"、\" bay \"、および「optional」は、[1]に記載されているとおりに解釈される。"
    },
    {
      "indent": 0,
      "text": "2.1. Acronyms",
      "section_title": true,
      "ja": "2.1. 頭字語"
    },
    {
      "indent": 3,
      "text": "This section lists most acronyms used for reference.",
      "ja": "このセクションには、参照に使用されるほとんどの頭字語をリストします。"
    },
    {
      "indent": 6,
      "text": "ACK Acknowledgment. CID Context Identifier. CO Compressed Packet Format. CRC Cyclic Redundancy Check. IR Initialization and Refresh. IR-DYN Initialization and Refresh, Dynamic part. LSB Least Significant Bit(s). MRRU Maximum Reconstructed Reception Unit. MSB Most Significant Bit(s). MSN Master Sequence Number. NACK Negative Acknowledgment. ROHC RObust Header Compression.",
      "ja": "ACK謝辞。CIDコンテキスト識別子。CO圧縮パケット形式。CRC周期的冗長性チェック。IR初期化と更新。IR-Dynの初期化と更新、動的部分。LSB最小有意ビット。MRRU最大再構築レセプションユニット。MSBの最も重要なビット。MSNマスターシーケンス番号。否定的な承認。ROHCロバストヘッダー圧縮。"
    },
    {
      "indent": 0,
      "text": "2.2. ROHC Terminology",
      "section_title": true,
      "ja": "2.2. ROHC用語"
    },
    {
      "indent": 3,
      "text": "Context",
      "ja": "コンテクスト"
    },
    {
      "indent": 6,
      "text": "The context of the compressor is the state it uses to compress a header. The context of the decompressor is the state it uses to decompress a header. Either of these or the two in combination are usually referred to as \"context\", when it is clear which is intended. The context contains relevant information from previous headers in the packet flow, such as static fields and possible reference values for compression and decompression. Moreover, additional information describing the packet flow is also part of the context, for example, information about the change behavior of fields (e.g., the IP Identifier behavior, or the typical inter-packet increase in sequence numbers and timestamps).",
      "ja": "コンプレッサーのコンテキストは、ヘッダーを圧縮するために使用する状態です。減圧器のコンテキストは、ヘッダーを減圧するために使用する状態です。これらまたは2つの組み合わせのいずれかは、通常「コンテキスト」と呼ばれます。コンテキストには、静的フィールドや圧縮と減圧の可能な参照値など、パケットフローの以前のヘッダーからの関連情報が含まれています。さらに、パケットフローを説明する追加情報は、コンテキストの一部でもあります。たとえば、フィールドの変更挙動に関する情報（たとえば、IP識別子の動作、またはシーケンス数とタイムスタンプの典型的なパケット間の増加）。"
    },
    {
      "indent": 3,
      "text": "Context damage",
      "ja": "コンテキストダメージ"
    },
    {
      "indent": 6,
      "text": "When the context of the decompressor is not consistent with the context of the compressor, decompression may fail to reproduce the original header. This situation can occur when the context of the decompressor has not been initialized properly or when packets have been lost or damaged between the compressor and decompressor.",
      "ja": "減圧器のコンテキストがコンプレッサーのコンテキストと一致しない場合、減圧は元のヘッダーを再現できない場合があります。この状況は、減圧器のコンテキストが適切に初期化されていない場合、またはコンプレッサーと減圧器の間でパケットが失われたり破損したりした場合に発生する可能性があります。"
    },
    {
      "indent": 6,
      "text": "Packets which cannot be decompressed due to inconsistent contexts are said to be lost due to context damage. Packets that are decompressed but contain errors due to inconsistent contexts are said to be damaged due to context damage.",
      "ja": "一貫性のないコンテキストのために解凍できないパケットは、コンテキストの損傷のために失われたと言われています。解凍されたが、一貫性のないコンテキストによるエラーが含まれているパケットは、コンテキストの損傷のために損傷していると言われています。"
    },
    {
      "indent": 3,
      "text": "Context repair mechanism",
      "ja": "コンテキスト修復メカニズム"
    },
    {
      "indent": 6,
      "text": "Context repair mechanisms are used to resynchronize the contexts, an important task since context damage causes loss propagation. Examples of such mechanisms are NACK-based mechanisms, and the periodic refreshes of important context information, usually done in unidirectional operation. There are also mechanisms that can reduce the context inconsistency probability, for example, repetition of the same type of information in multiple packets and CRCs that protect context-updating information.",
      "ja": "コンテキストの修復メカニズムは、コンテキストの再同時に使用されます。これは、コンテキストダメージが損失の伝播を引き起こすため、重要なタスクです。このようなメカニズムの例は、NACKベースのメカニズムと、通常は単方向操作で行われる重要なコンテキスト情報の周期的な更新です。また、コンテキストの不一致の可能性を減らすことができるメカニズムもあります。たとえば、コンテキストアップデート情報を保護する複数のパケットとCRCで同じタイプの情報を繰り返します。"
    },
    {
      "indent": 3,
      "text": "CRC-8 validation",
      "ja": "CRC-8検証"
    },
    {
      "indent": 6,
      "text": "The CRC-8 validation refers to the validation of the integrity against bit error(s) in a received IR and IR-DYN header using the 8-bit CRC included in the IR/IR-DYN header.",
      "ja": "CRC-8検証とは、IR/IR-Dynヘッダーに含まれる8ビットCRCを使用して、受信したIRおよびIR-Dynヘッダーのビットエラーに対する整合性の検証を指します。"
    },
    {
      "indent": 3,
      "text": "CRC verification",
      "ja": "CRC検証"
    },
    {
      "indent": 6,
      "text": "The CRC verification refers to the verification of the result of a decompression attempt using the 3-bit CRC or 7-bit CRC included in the header of a compressed packet format.",
      "ja": "CRC検証とは、圧縮パケット形式のヘッダーに含まれる3ビットCRCまたは7ビットCRCを使用した減圧試行の結果の検証を指します。"
    },
    {
      "indent": 3,
      "text": "Damage propagation",
      "ja": "損傷伝播"
    },
    {
      "indent": 6,
      "text": "Delivery of incorrect decompressed headers due to context damage, that is, due to errors in (i.e., loss of or damage to) previous header(s) or feedback.",
      "ja": "コンテキストの損傷による誤った減圧ヘッダーの配信、つまり、以前のヘッダーまたはフィードバックのエラー（つまりの損失または損傷）またはフィードバックによる配信。"
    },
    {
      "indent": 3,
      "text": "Error detection",
      "ja": "エラー検出"
    },
    {
      "indent": 6,
      "text": "Detection of errors by lower layers. If error detection is not perfect, there will be residual errors.",
      "ja": "下層によるエラーの検出。エラー検出が完全でない場合、残留エラーがあります。"
    },
    {
      "indent": 3,
      "text": "Error propagation",
      "ja": "エラー伝播"
    },
    {
      "indent": 6,
      "text": "Damage propagation or loss propagation.",
      "ja": "損傷の伝播または損失の伝播。"
    },
    {
      "indent": 3,
      "text": "ROHC profile",
      "ja": "ROHCプロファイル"
    },
    {
      "indent": 6,
      "text": "A ROHC profile is a compression protocol, which specifies how to compress specific header combinations. A ROHC profile may be tailored to handle a specific set of link characteristics, e.g., loss characteristics, reordering between compression points, etc. ROHC profiles provide the details of the header compression framework defined in this document, and each compression profile is associated with a unique ROHC profile identifier [21]. When setting up a ROHC channel, the set of profiles supported by both endpoints of the channel is negotiated, and when initializing new contexts, a profile identifier from this negotiated set is used to associate each compression context with one specific profile.",
      "ja": "ROHCプロファイルは圧縮プロトコルであり、特定のヘッダーの組み合わせを圧縮する方法を指定します。ROHCプロファイルは、特定のリンク特性、例えば損失特性、圧縮ポイント間の並べ替えなどを処理するように調整される場合があります。ROHCプロファイルは、このドキュメントで定義されたヘッダー圧縮フレームワークの詳細を提供し、各圧縮プロファイルは一意のROHCプロファイル識別子[21]。ROHCチャネルをセットアップするとき、チャネルの両方のエンドポイントでサポートされるプロファイルのセットがネゴシエートされ、新しいコンテキストを初期化する場合、このネゴシエートセットのプロファイル識別子を使用して、各圧縮コンテキストを特定のプロファイルに関連付けます。"
    },
    {
      "indent": 3,
      "text": "Link",
      "ja": "リンク"
    },
    {
      "indent": 6,
      "text": "A physical transmission path that constitutes a single IP hop.",
      "ja": "単一のIPホップを構成する物理的な送信パス。"
    },
    {
      "indent": 3,
      "text": "Loss propagation",
      "ja": "損失伝播"
    },
    {
      "indent": 6,
      "text": "Loss of headers, due to errors in (i.e., loss of or damage to) previous header(s) or feedback.",
      "ja": "以前のヘッダーまたはフィードバックのエラー（すなわち、損失の損失または損傷）によるヘッダーの喪失。"
    },
    {
      "indent": 3,
      "text": "Packet flow",
      "ja": "パケットフロー"
    },
    {
      "indent": 6,
      "text": "A sequence of packets where the field values and change patterns of field values are such that the headers can be compressed using the same context.",
      "ja": "フィールド値とフィールド値のパターンを変更するパケットのシーケンスは、同じコンテキストを使用してヘッダーを圧縮できるようにするためです。"
    },
    {
      "indent": 3,
      "text": "Residual error",
      "ja": "残留エラー"
    },
    {
      "indent": 6,
      "text": "Errors introduced during transmission and not detected by lower-layer error detection schemes.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ROHC channel",
      "ja": "ROHCチャネル"
    },
    {
      "indent": 6,
      "text": "A logical unidirectional point-to-point channel carrying ROHC packets from one compressor to one decompressor, optionally carrying ROHC feedback information on the behalf of another compressor-decompressor pair operating on a separate ROHC channel in the opposite direction. See also [5].",
      "ja": "1つのコンプレッサーから1つの減圧器までROHCパケットを運ぶ論理的な一方向からポイントチャネル。[5]も参照してください。"
    },
    {
      "indent": 3,
      "text": "This document also makes use of the conceptual terminology defined by \"ROHC Terminology and Channel Mapping Examples\", RFC 3759 [5].",
      "ja": "このドキュメントでは、「ROHC用語とチャネルマッピングの例」、RFC 3759 [5]で定義された概念用語を使用しています。"
    },
    {
      "indent": 0,
      "text": "3. Background (Informative)",
      "section_title": true,
      "ja": "3. 背景（有益）"
    },
    {
      "indent": 3,
      "text": "This section provides a background to the subject of header compression. The fundamental ideas are described together with a discussion about the history of header compression schemes. The motivations driving the development of the various schemes are discussed and their drawbacks identified, thereby providing the foundations for the design of the ROHC framework and profiles [3].",
      "ja": "このセクションでは、ヘッダー圧縮の主題の背景を提供します。基本的なアイデアは、ヘッダー圧縮スキームの歴史に関する議論とともに説明されています。さまざまなスキームの開発を促進する動機が議論され、それらの欠点が特定され、それによってROHCフレームワークとプロファイルの設計の基礎を提供します[3]。"
    },
    {
      "indent": 0,
      "text": "3.1. Header Compression Fundamentals",
      "section_title": true,
      "ja": "3.1. ヘッダー圧縮の基礎"
    },
    {
      "indent": 3,
      "text": "Header compression is possible because there is significant redundancy between header fields; within the headers of a single packet, but in particular between consecutive packets belonging to the same flow. On the path end-to-end, the entire header information is necessary for all packets in the flow, but over a single link, some of this information becomes redundant and can be reduced, as long as it is transparently recovered at the receiving end of the link. The header size can be reduced by first sending field information that is expected to remain static for (at least most of) the lifetime of the packet flow. Further compression is achieved for the fields carrying information that changes more dynamically by using compression methods tailored to their respective assumed change behavior.",
      "ja": "ヘッダーフィールド間に大きな冗長性があるため、ヘッダー圧縮が可能です。単一のパケットのヘッダー内で、特に同じフローに属する連続したパケット間。パスエンドツーエンドでは、フロー内のすべてのパケットにヘッダー情報全体が必要ですが、単一のリンクで、この情報の一部が冗長になり、受信側で透過的に回復する限り、減少させることができます。リンクの。ヘッダーサイズは、最初にパケットフローの寿命の（少なくともほとんど）に静的であると予想されるフィールド情報を最初に送信することで縮小できます。それぞれの想定された変化挙動に合わせた圧縮方法を使用することにより、より動的に変化する情報を運ぶフィールドでは、さらなる圧縮が達成されます。"
    },
    {
      "indent": 3,
      "text": "To achieve compression and decompression, some necessary information from past packets is maintained in a context. The compressor and the decompressor update their respective contexts upon certain, not necessarily synchronized, events. Impairment events may lead to inconsistencies in the decompressor context (i.e., context damage), which in turn may cause incorrect decompression. A Robust Header Compression scheme needs mechanisms to minimize the possibility of context damage, in combination with mechanisms for context repair.",
      "ja": "圧縮と減圧を実現するために、過去のパケットから必要な情報がコンテキストで維持されます。コンプレッサーと減圧装置は、必ずしも同期したイベントではなく、特定のコンテキストを特定します。障害のイベントは、減圧装置のコンテキスト（つまり、コンテキスト損傷）で不整合につながる可能性があり、それが誤った減圧を引き起こす可能性があります。堅牢なヘッダー圧縮スキームは、コンテキスト修復のメカニズムと組み合わせて、コンテキスト損傷の可能性を最小限に抑えるためのメカニズムを必要とします。"
    },
    {
      "indent": 0,
      "text": "3.2. A Short History of Header Compression",
      "section_title": true,
      "ja": "3.2. ヘッダー圧縮の短い履歴"
    },
    {
      "indent": 3,
      "text": "The first header compression scheme, compressed TCP (CTCP) [15], was introduced by Van Jacobson. CTCP, also often referred to as VJ compression, compresses the 40 octets of the TCP/IP header down to 4 octets. CTCP uses delta encoding for sequentially changing fields. The CTCP compressor detects transport-level retransmissions and sends a header that updates the entire context when they occur. This repair mechanism does not require any explicit signaling between the compressor and decompressor.",
      "ja": "最初のヘッダー圧縮スキームである圧縮TCP（CTCP）[15]は、Van Jacobsonによって導入されました。VJ圧縮とも呼ばれるCTCPは、TCP/IPヘッダーの40オクテットを4オクテットに圧縮します。CTCPは、シーケンシャルに変化するフィールドにデルタエンコードを使用します。CTCPコンプレッサーは、輸送レベルの再送信を検出し、コンテキスト全体を更新するヘッダーを送信します。この修復メカニズムでは、コンプレッサーと減圧器間の明示的なシグナル伝達は必要ありません。"
    },
    {
      "indent": 3,
      "text": "A general IP header compression scheme, IP header compression [16], improves somewhat on CTCP. IP Header Compression (IPHC) can compress arbitrary IP, TCP, and UDP headers. When compressing non-TCP headers, IPHC does not use delta encoding and is robust. The repair mechanism of CTCP is augmented with negative acknowledgments, called CONTEXT_STATE messages, which speeds up the repair. This context repair mechanism is thus limited by the round-trip time of the link. IPHC does not compress RTP headers.",
      "ja": "一般的なIPヘッダー圧縮スキーム、IPヘッダー圧縮[16]は、CTCPで多少改善されます。IPヘッダー圧縮（IPHC）は、任意のIP、TCP、およびUDPヘッダーを圧縮できます。非TCPヘッダーを圧縮する場合、IPHCはデルタエンコードを使用せず、堅牢です。CTCPの修復メカニズムは、修理を高速化するContext_Stateメッセージと呼ばれる否定的な確認で増強されます。したがって、このコンテキスト修復メカニズムは、リンクの往復時間によって制限されます。IPHCはRTPヘッダーを圧縮しません。"
    },
    {
      "indent": 3,
      "text": "CRTP [17] is an RTP extension to IPHC. CRTP compresses the 40 octets of IPv4/UDP/RTP headers to a minimum of 2 octets when the UDP Checksum is not enabled. If the UDP Checksum is enabled, the minimum CRTP header is 4 octets.",
      "ja": "CRTP [17]は、IPHCのRTP拡張です。CRTPは、UDPチェックサムが有効になっていない場合、IPv4/UDP/RTPヘッダーの40オクテットを最低2オクテットに圧縮します。UDPチェックサムが有効になっている場合、最小CRTPヘッダーは4オクテットです。"
    },
    {
      "indent": 3,
      "text": "On lossy links with long round-trip times, CRTP does not perform well [20]. Each packet lost over the link causes decompression of several subsequent packets to fail, because the context becomes invalidated during at least one link round-trip time from the lost packet. Unfortunately, the large headers that CRTP sends when updating the context waste additional bandwidth.",
      "ja": "長い往復時間との損失のあるリンクでは、CRTPはうまく機能しません[20]。リンクを介して失われた各パケットにより、コンテキストが失われたパケットから少なくとも1回のリンクの往復時間中にコンテキストが無効になるため、いくつかの後続のパケットの減圧が失敗します。残念ながら、コンテキストを更新するときにCRTPが送信する大きなヘッダーは、追加の帯域幅を無駄にします。"
    },
    {
      "indent": 3,
      "text": "CRTP uses a local repair mechanism known as TWICE, which was introduced by IPHC. TWICE derives its name from the observation that when the flow of compressed packets is regular, the correct guess when one packet is lost between the compression points is to apply the update in the current packet twice. While TWICE improves CRTP performance significantly, [20] also found that even with TWICE, CRTP doubled the number of lost packets.",
      "ja": "CRTPは、IPHCによって導入された2回と呼ばれるローカル修復メカニズムを使用します。圧縮パケットのフローが規則的である場合、圧縮ポイント間に1つのパケットが失われたときの正しい推測は、現在のパケットのアップデートを2回適用することであるという観察結果から2回派生します。CRTPのパフォーマンスは2回大幅に向上しますが、[20]は、2回でもCRTPが失われたパケットの数を2倍にすることも発見しました。"
    },
    {
      "indent": 3,
      "text": "An enhanced variant of CRTP, called eCRTP [19], means to improve the robustness of CRTP in the presence of reordering and packet losses, while keeping the protocol almost unchanged from CRTP. As a result, eCRTP does provide better means to implement some degree of robustness, albeit at the expense of additional overhead, leading to a reduction in compression efficiency in comparison to CRTP.",
      "ja": "ECRTP [19]と呼ばれるCRTPの強化されたバリアントは、プロトコルをCRTPからほとんど変化させずに、並べ替えとパケット損失の存在下でCRTPの堅牢性を改善することを意味します。その結果、ECRTPは、追加のオーバーヘッドを犠牲にして、ある程度の堅牢性を実装するためのより良い手段を提供し、CRTPと比較して圧縮効率を低下させます。"
    },
    {
      "indent": 0,
      "text": "4. Overview of Robust Header Compression (ROHC) (Informative)",
      "section_title": true,
      "ja": "4. 堅牢なヘッダー圧縮（ROHC）の概要（有益）"
    },
    {
      "indent": 0,
      "text": "4.1. General Principles",
      "section_title": true,
      "ja": "4.1. 一般原理"
    },
    {
      "indent": 3,
      "text": "As mentioned earlier, header compression is possible per-link due to the fact that there is much redundancy between header field values within packets, and especially between consecutive packets belonging to the same flow. To utilize these properties for header compression, there are a few essential steps to consider.",
      "ja": "前述のように、パケット内のヘッダーフィールド値、特に同じフローに属する連続したパケット間に大きな冗長性があるという事実により、ヘッダー圧縮がリンクごとに可能です。ヘッダー圧縮のためにこれらのプロパティを利用するには、考慮すべきいくつかの重要な手順があります。"
    },
    {
      "indent": 3,
      "text": "The first step consists of identifying and grouping packets together into different \"flows\", so that packet-to-packet redundancy is maximized in order to improve the compression ratio. Grouping packets into flows is usually based on source and destination host (IP) addresses, transport protocol type (e.g., UDP or TCP), process (port) numbers, and potentially additional unique application identifiers, such as the synchronization source (SSRC) in RTP [13]. The compressor and decompressor each establish a context for the packet flow and identify the context with a Context Identifier (CID) included in each compressed header.",
      "ja": "最初のステップは、パケットを異なる「フロー」に識別してグループ化することで構成されているため、圧縮比を改善するためにパケット間冗長性が最大化されます。パケットをフローにグループ化することは、通常、ソースおよび宛先ホスト（IP）アドレス、トランスポートプロトコルタイプ（UDPまたはTCP）、プロセス（ポート）番号、および同期ソース（SSRC）の潜在的に追加の一意のアプリケーション識別子に基づいています。RTP [13]。コンプレッサーと分解器はそれぞれ、パケットフローのコンテキストを確立し、各圧縮ヘッダーに含まれるコンテキスト識別子（CID）を使用してコンテキストを識別します。"
    },
    {
      "indent": 3,
      "text": "The second step is to understand the change patterns of the various header fields. On a high level, header fields fall into one of the following classes:",
      "ja": "2番目のステップは、さまざまなヘッダーフィールドの変更パターンを理解することです。高いレベルでは、ヘッダーフィールドは次のクラスの1つに分類されます。"
    },
    {
      "indent": 3,
      "text": "INFERRED These fields contain values that can be inferred from other fields or external sources, for example, the size of the frame carrying the packet can often be derived from the link layer protocol, and thus does not have to be transmitted by the compression scheme.",
      "ja": "これらのフィールドには、他のフィールドまたは外部ソースから推測できる値が含まれています。たとえば、パケットを運ぶフレームのサイズは、多くの場合、リンクレイヤープロトコルから導出できるため、圧縮スキームによって送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "STATIC Fields classified as STATIC are assumed to be constant throughout the lifetime of the packet flow. The value of each field is thus only communicated initially.",
      "ja": "静的フィールドは、静的に分類され、パケットフローの寿命を通じて一定であると想定されます。したがって、各フィールドの値は最初にのみ通信されます。"
    },
    {
      "indent": 3,
      "text": "STATIC-DEF Fields classified as STATIC-DEF are used to define a packet flow as discussed above. Packets for which respective values of these fields differ are treated as belonging to different flows. These fields are in general compressed as STATIC fields.",
      "ja": "Static-DEFに分類された静的DEFフィールドは、上記のようにパケットフローを定義するために使用されます。これらのフィールドのそれぞれの値が異なるパケットは、異なるフローに属するものとして扱われます。これらのフィールドは、一般的に静的フィールドとして圧縮されています。"
    },
    {
      "indent": 3,
      "text": "STATIC-KNOWN Fields classified as STATIC-KNOWN are expected to have well-known values, and therefore their values do not need to be communicated.",
      "ja": "静的な既知として分類された静的なフィールドは、よく知られている値を持つと予想されるため、その値を伝える必要はありません。"
    },
    {
      "indent": 3,
      "text": "CHANGING These fields are expected to vary randomly, either within a limited value set or range, or in some other manner. CHANGING fields are usually handled in more sophisticated ways based on a more detailed classification of their expected change patterns.",
      "ja": "これらのフィールドの変更は、限られた値セットまたは範囲内、または他の方法でランダムに異なることが予想されます。通常、変化するフィールドは、予想される変更パターンのより詳細な分類に基づいて、より洗練された方法で処理されます。"
    },
    {
      "indent": 3,
      "text": "Finally, the last step is to choose the encoding method(s) that will be applied onto different fields based on classification. The encoding methods, in combination with the identified field behavior, provide the input to the design of the compressed header formats. The analysis of the probability distribution of the identified change patterns then provides the means to optimize the packet formats, where the most frequently occurring change patterns for a field should be encoded within the most efficient format(s).",
      "ja": "最後に、最後のステップは、分類に基づいて異なるフィールドに適用されるエンコード方法を選択することです。識別されたフィールドの動作と組み合わせたエンコード方法は、圧縮ヘッダー形式の設計に入力を提供します。特定された変更パターンの確率分布の分析は、パケット形式を最適化する手段を提供します。ここでは、フィールドの最も頻繁に発生する変更パターンを最も効率的な形式でエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "However, compression efficiency has to be traded against two other properties: the robustness of the encoding to losses and errors between the compressor and the decompressor, and the ability to detect and cope with errors in the decompression process.",
      "ja": "ただし、圧縮効率は、コンプレッサーと減圧装置間の損失とエラーへのエンコードの堅牢性と、減圧プロセスのエラーを検出および対処する能力という2つの他のプロパティに対して取引する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Compression Efficiency, Robustness, and Transparency",
      "section_title": true,
      "ja": "4.2. 圧縮効率、堅牢性、および透明性"
    },
    {
      "indent": 3,
      "text": "The performance of a header compression protocol can be described with three parameters: its compression efficiency, its robustness, and its compression transparency.",
      "ja": "ヘッダー圧縮プロトコルのパフォーマンスは、その圧縮効率、その堅牢性、および圧縮透明度の3つのパラメーターで説明できます。"
    },
    {
      "indent": 3,
      "text": "Compression efficiency",
      "ja": "圧縮効率"
    },
    {
      "indent": 6,
      "text": "The compression efficiency is determined by how much the average header size is reduced by applying the compression protocol.",
      "ja": "圧縮効率は、圧縮プロトコルを適用することにより、平均ヘッダーサイズがどれだけ削減されるかによって決まります。"
    },
    {
      "indent": 3,
      "text": "Robustness",
      "ja": "堅牢性"
    },
    {
      "indent": 6,
      "text": "A robust protocol tolerates packet losses, residual bit errors, and out-of-order delivery on the link over which header compression takes place, without losing additional packets or introducing additional errors in decompressed headers.",
      "ja": "堅牢なプロトコルは、追加のパケットを失ったり、減圧ヘッダーに追加のエラーを導入せずに、ヘッダー圧縮が行われるリンク上のパケット損失、残留ビットエラー、および順序外配信を許容します。"
    },
    {
      "indent": 3,
      "text": "Compression transparency",
      "ja": "圧縮透明度"
    },
    {
      "indent": 6,
      "text": "The compression transparency is a measure of the extent to which the scheme maintains the semantics of the original headers. If all decompressed headers are bitwise identical to the corresponding original headers, the scheme is transparent.",
      "ja": "圧縮透明性は、スキームが元のヘッダーのセマンティクスを維持する程度の尺度です。すべての減圧ヘッダーが対応する元のヘッダーと少し同一である場合、スキームは透明です。"
    },
    {
      "indent": 0,
      "text": "4.3. Developing the ROHC Protocol",
      "section_title": true,
      "ja": "4.3. ROHCプロトコルの開発"
    },
    {
      "indent": 3,
      "text": "The challenge in developing a header compression protocol is to conciliate compression efficiency and robustness while maintaining transparency, as increasing robustness will always come at the expense of a lower compression efficiency, and vice-versa. The scheme should also be flexible enough in its design to minimize the impacts from the varying round-trip times and loss patterns of links where header compression will be used.",
      "ja": "ヘッダー圧縮プロトコルの開発における課題は、透明性を維持しながら、圧縮効率と堅牢性を和解させることです。堅牢性の増加は常に低い圧縮効率を犠牲にして、逆になるためです。また、このスキームは、ヘッダー圧縮が使用されるリンクのさまざまな往復時間と損失パターンからの影響を最小限に抑えるために、設計に十分な柔軟性が必要です。"
    },
    {
      "indent": 3,
      "text": "To achieve this, the header compression scheme must provide facilities for the decompressor to verify decompression and detect potential context damage, as well as context recovery mechanisms such as feedback. Header compression schemes prior to the ones developed by the Robust Header Compression (ROHC) WG were not designed with the above high-level objectives in mind.",
      "ja": "これを達成するために、ヘッダー圧縮スキームは、減圧を検証し、潜在的なコンテキストの損傷、およびフィードバックなどのコンテキスト回復メカニズムを検出するための減圧器に施設を提供する必要があります。堅牢なヘッダー圧縮（ROHC）WGによって開発されたヘッダー圧縮スキームは、上記の高レベルの目標を念頭に置いて設計されていませんでした。"
    },
    {
      "indent": 3,
      "text": "The ROHC WG has developed header compression solutions to meet the needs of present and future link technologies. While special attention has been put towards meeting the more stringent requirements stemming from the characteristics of wireless links, the results are equally applicable to many other link technologies.",
      "ja": "ROHC WGは、現在および将来のリンクテクノロジーのニーズを満たすために、ヘッダー圧縮ソリューションを開発しました。ワイヤレスリンクの特性に起因するより厳しい要件を満たすことに特別な注意が払われていますが、結果は他の多くのリンクテクノロジーに等しく適用できます。"
    },
    {
      "indent": 3,
      "text": "RFC 3095 [3], \"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed\", was published in 2001, as the first output of the ROHC WG. ROHC is a general and extendable framework for header compression, on top of which profiles can be defined for compression of different protocols headers. RFC 3095 introduced a number of new compression techniques, and was successful at living up to the requirements placed on it, as described in [18].",
      "ja": "RFC 3095 [3]、「ロバストヘッダー圧縮（ROHC）：フレームワークと4つのプロファイル：RTP、UDP、ESP、および非圧縮」は、ROHC WGの最初の出力として2001年に公開されました。ROHCは、ヘッダー圧縮の一般的で拡張可能なフレームワークであり、その上に、さまざまなプロトコルヘッダーの圧縮のプロファイルを定義できます。RFC 3095は、多くの新しい圧縮技術を導入し、[18]で説明されているように、それに掲載された要件に応えることに成功しました。"
    },
    {
      "indent": 3,
      "text": "Interoperability testing of RFC 3095 confirms the capabilities of ROHC to meet its purposes, but feedback from implementers has also indicated that the protocol specification is complex and sometimes obscure. Most importantly, a clear distinction between framework and profiles is not obvious in [3], which also makes development of additional profiles troublesome. This document therefore aims at explicitly specifying the ROHC framework, while a companion document [8] specifies revised versions of the compression profiles of RFC 3095.",
      "ja": "RFC 3095の相互運用性テストは、ROHCの目的を満たす機能を確認しますが、実装者からのフィードバックは、プロトコルの仕様が複雑であり、時にはあいまいであることを示しています。最も重要なことは、[3]では、フレームワークとプロファイルの明確な区別が明らかではなく、追加のプロファイルの開発も面倒です。したがって、このドキュメントは、ROHCフレームワークを明示的に指定することを目的としていますが、コンパニオンドキュメント[8]は、RFC 3095の圧縮プロファイルの修正バージョンを指定します。"
    },
    {
      "indent": 0,
      "text": "4.4. Operational Characteristics of the ROHC Channel",
      "section_title": true,
      "ja": "4.4. ROHCチャネルの運用特性"
    },
    {
      "indent": 3,
      "text": "Robust header compression can be used over many type of link technologies. The ROHC framework provides flexibility for profiles to address a wide range of applications, and this section lists some of the operational characteristics of the ROHC channel (see also [5]).",
      "ja": "堅牢なヘッダー圧縮は、さまざまな種類のリンクテクノロジーで使用できます。ROHCフレームワークは、プロファイルが幅広いアプリケーションに対処するための柔軟性を提供し、このセクションにはROHCチャネルの運用特性の一部をリストします（[5]も参照）。"
    },
    {
      "indent": 3,
      "text": "Multiplexing over a single logical channel",
      "ja": "単一の論理チャネル上の多重化"
    },
    {
      "indent": 6,
      "text": "The ROHC channel provides a mechanism to identify a context within the general ROHC packet format. The CID makes it possible for a logical channel that supports ROHC to transport multiple header-compressed flows, while still making it possible for a channel to be dedicated to one single packet flow without any CID overhead. More specifically, ROHC uses a distinct context identifier space per logical channel, and the context identifier can be omitted for one of the flows over the ROHC channel when configured to use a small CID space.",
      "ja": "ROHCチャネルは、一般的なROHCパケット形式内のコンテキストを識別するメカニズムを提供します。CIDにより、ROHCをサポートする論理チャネルが複数のヘッダー圧縮フローを輸送することを可能にし、同時にCIDオーバーヘッドなしで1つのパケットフローに専用するチャネルを可能にします。より具体的には、ROHCは論理チャネルごとに異なるコンテキスト識別子空間を使用し、小さなCIDスペースを使用するように構成された場合、ROHCチャネル上のフローの1つについて、コンテキスト識別子を省略できます。"
    },
    {
      "indent": 3,
      "text": "Establishment of channel parameters",
      "ja": "チャネルパラメーターの確立"
    },
    {
      "indent": 6,
      "text": "A link layer defining support for the ROHC channel must provide the means to establish header compression channel parameters (see Section 5.1). This can be achieved through a negotiation mechanism, static provisioning, or some out-of-band signaling.",
      "ja": "ROHCチャネルのサポートを定義するリンクレイヤーは、ヘッダー圧縮チャネルパラメーターを確立する手段を提供する必要があります（セクション5.1を参照）。これは、交渉メカニズム、静的プロビジョニング、または帯域外シグナリングを通じて達成できます。"
    },
    {
      "indent": 3,
      "text": "Packet type identification",
      "ja": "パケットタイプの識別"
    },
    {
      "indent": 6,
      "text": "The ROHC channel defines a packet type identifier space, and puts restrictions with respect to the use of a number of identifiers that are common for all ROHC profiles. Identifiers that have no restrictions, i.e., identifiers that are not defined by this document, are available to each profile. The identifier is part of each compressed header, and this makes it possible for the link that supports the ROHC channel to allocate one single link layer payload type for ROHC.",
      "ja": "ROHCチャネルは、パケットタイプの識別子スペースを定義し、すべてのROHCプロファイルに共通する多くの識別子の使用に関して制限を設けます。制限がない識別子、つまり、このドキュメントで定義されていない識別子は、各プロファイルで利用可能です。識別子は各圧縮ヘッダーの一部であるため、ROHCチャネルをサポートするリンクがROHCに1つのリンクレイヤーペイロードタイプを割り当てることができます。"
    },
    {
      "indent": 3,
      "text": "Out-of-order delivery between compression endpoints",
      "ja": "圧縮エンドポイント間のオーダー配信"
    },
    {
      "indent": 6,
      "text": "Each profile defines its own level of robustness, including tolerance to reordering of packets before but especially between compression endpoints, if any.",
      "ja": "各プロファイルは、以前のパケットの並べ替えに対する耐性を含む、特に圧縮エンドポイントの間で、ある場合は堅牢性の独自のレベルを定義します。"
    },
    {
      "indent": 6,
      "text": "For profiles specified in [3], the channel between the compressor and decompressor is required to maintain in-order delivery of the packets, i.e., the definition of these profiles assumes that the decompressor always receives packets in the same order as the compressor sent them. The impacts of reordering on the performance of these profiles is described in [7]. However, reordering before the compression point is handled, i.e., these profiles make no assumption that the compressor will receive packets in-order.",
      "ja": "[3]で指定されたプロファイルの場合、コンプレッサーと減圧器の間のチャネルは、パケットの順序配信を維持するために必要です。つまり、これらのプロファイルの定義は、コンプレッサーがコンプレッサーが送信したのと同じ順序で常にパケットを受信することを前提としています。。これらのプロファイルのパフォーマンスに対する並べ替えの影響は、[7]で説明されています。ただし、圧縮ポイントが処理される前に並べ替えること、つまり、これらのプロファイルは、コンプレッサーがパケットを注文すると仮定しません。"
    },
    {
      "indent": 6,
      "text": "For the ROHCv2 profiles specified in [8], their definitions assume that the decompressor can receive packets out-of-order, i.e., not in the same order that the compressor sent them. Reordering before the compression point is also dealt with.",
      "ja": "[8]で指定されているROHCV2プロファイルの場合、それらの定義は、減圧器がパケットをオーダーオーダー、つまりコンプレッサーが送信したのと同じ順序ではないと仮定しています。圧縮ポイントの前に並べ替えることも扱われます。"
    },
    {
      "indent": 3,
      "text": "Duplication of packets",
      "ja": "パケットの複製"
    },
    {
      "indent": 6,
      "text": "The link supporting the ROHC channel is required to not duplicate packets (however, duplication of packets can occur before they reach the compressor, i.e., there is no assumption that the compressor will receive only one copy of each packet).",
      "ja": "ROHCチャネルをサポートするリンクは、パケットを複製しないために必要です（ただし、コンプレッサーに到達する前にパケットの複製が発生する可能性があります。つまり、コンプレッサーが各パケットのコピーを1つしか受信しないという仮定はありません）。"
    },
    {
      "indent": 3,
      "text": "Framing",
      "ja": "フレーミング"
    },
    {
      "indent": 6,
      "text": "The link layer must provide framing that makes it possible to distinguish frame boundaries and individual frames.",
      "ja": "リンクレイヤーは、フレームの境界と個々のフレームを区別することを可能にするフレーミングを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "Error detection/protection",
      "ja": "エラー検出/保護"
    },
    {
      "indent": 6,
      "text": "ROHC profiles should be designed to cope with residual errors in the headers delivered to the decompressor. CRCs are used to detect decompression failures and to prevent or reduce damage propagation. However, it is recommended that lower layers deploy error detection for ROHC headers and that ROHC headers with high residual error rates not be delivered.",
      "ja": "ROHCプロファイルは、減圧器に配信されたヘッダーの残留エラーに対処するように設計する必要があります。CRCは、減圧の障害を検出し、損傷の伝播を防止または減少させるために使用されます。ただし、下層層はROHCヘッダーのエラー検出を展開し、残留エラー率が高いROHCヘッダーが配信されないことをお勧めします。"
    },
    {
      "indent": 0,
      "text": "4.5. Compression and Master Sequence Number (MSN)",
      "section_title": true,
      "ja": "4.5. 圧縮およびマスターシーケンス番号（MSN）"
    },
    {
      "indent": 3,
      "text": "Compression of header fields is based on the establishment of a function to a sequence number, called the master sequence number (MSN). This function describes the change pattern of the field with respect to a change in the MSN.",
      "ja": "ヘッダーフィールドの圧縮は、マスターシーケンス番号（MSN）と呼ばれるシーケンス番号への関数の確立に基づいています。この関数は、MSNの変化に関するフィールドの変化パターンを説明しています。"
    },
    {
      "indent": 3,
      "text": "Change patterns include, for example, fields that increase monotonically or by a small value, fields that seldom change,and fields that remain unchanging for the entire lifetime of the packet flow, in which case the function to the MSN is equivalent to a constant value.",
      "ja": "変更パターンには、たとえば、単調にまたは小さな値によって増加するフィールド、めったに変化しないフィールド、およびパケットフローの寿命全体を変えないフィールドが含まれます。その場合、MSNへの関数は一定の値に相当します。"
    },
    {
      "indent": 3,
      "text": "The compressor first establishes functions for each of the header fields, and then reliably communicates the MSN. When the change pattern of the field does not match the established function, i.e., the existing function gives a result that is different from the field in the header being compressed, additional information can be sent to update the parameters of that function.",
      "ja": "コンプレッサーは最初に各ヘッダーフィールドの関数を確立し、次にMSNを確実に通信します。フィールドの変化パターンが確立された関数と一致しない場合、つまり、既存の関数が圧縮されるヘッダーのフィールドとは異なる結果を与えます。追加情報を送信して、その関数のパラメーターを更新できます。"
    },
    {
      "indent": 3,
      "text": "The MSN is defined per profile. It can be either derived directly from one of the fields of the protocol being compressed (e.g., the RTP SN [8]), or it can be created and maintained by the compressor (e.g., the MSN for compression of UDP in profile 0x0102 [8] or the MSN in ROHC-TCP [9]).",
      "ja": "MSNはプロファイルごとに定義されています。圧縮されているプロトコルのフィールドの1つ（RTP SN [8]など）から直接導出するか、コンプレッサーによって作成および維持される可能性があります（たとえば、プロファイル0x0102 [UDPの圧縮のMSN] [8]またはROHC-TCP [9]のMSN。"
    },
    {
      "indent": 0,
      "text": "4.6. Static and Dynamic Parts of a Context",
      "section_title": true,
      "ja": "4.6. コンテキストの静的および動的な部分"
    },
    {
      "indent": 3,
      "text": "A compression context can be conceptually divided into two different parts, the static context and the dynamic context, each based on the properties of the fields that are being compressed.",
      "ja": "圧縮コンテキストは、静的コンテキストと動的コンテキストの2つの異なる部分に概念的に分割できます。それぞれが圧縮されているフィールドのプロパティに基づいています。"
    },
    {
      "indent": 3,
      "text": "The static part includes the information necessary to compress and decompress the fields whose change behavior is classified as STATIC, STATIC-KNOWN, or STATIC-DEF (as described in Section 4.1 above).",
      "ja": "静的部分には、変化挙動が静的、静的、または静的DEFとして分類されるフィールドを圧縮および解凍するために必要な情報が含まれます（上記のセクション4.1で説明されているように）。"
    },
    {
      "indent": 3,
      "text": "The dynamic part includes the state maintained for all the other fields, i.e., those that are classified as CHANGING.",
      "ja": "動的な部分には、他のすべてのフィールド、つまり変更として分類されるフィールドに維持されている状態が含まれます。"
    },
    {
      "indent": 0,
      "text": "5. The ROHC Framework (Normative)",
      "section_title": true,
      "ja": "5. ROHCフレームワーク（規範）"
    },
    {
      "indent": 3,
      "text": "This section normatively defines the parts common to all ROHC profiles, i.e., the framework. The framework specifies the requirements and functionality of the ROHC channel, including how to handle multiple compressed packet flows over the same channel.",
      "ja": "このセクションは、すべてのROHCプロファイル、つまりフレームワークに共通するパーツを規範的に定義します。フレームワークは、同じチャネルで複数の圧縮パケットフローを処理する方法など、ROHCチャネルの要件と機能を指定します。"
    },
    {
      "indent": 3,
      "text": "Finally, this section specifies encoding methods used in the packet formats that are common to all profiles. These encoding methods may be reused within profile specifications for encoding fields in profile-specific parts of a packet format, without requiring their redefinition.",
      "ja": "最後に、このセクションでは、すべてのプロファイルに共通するパケット形式で使用されるエンコードメソッドを指定します。これらのエンコード方法は、再定義を必要とせずに、パケット形式のプロファイル固有の部分でフィールドをエンコードするためのプロファイル仕様内で再利用できます。"
    },
    {
      "indent": 0,
      "text": "5.1. The ROHC Channel",
      "section_title": true,
      "ja": "5.1. ROHCチャネル"
    },
    {
      "indent": 0,
      "text": "5.1.1. Contexts and Context Identifiers",
      "section_title": true,
      "ja": "5.1.1. コンテキストとコンテキスト識別子"
    },
    {
      "indent": 3,
      "text": "Associated with each compressed flow is a context. The context is the state that the compressor and the decompressor maintain in order to correctly compress or decompress the headers of the packet in the flow. Each context is identified using a CID.",
      "ja": "各圧縮フローに関連付けられていることは、コンテキストです。コンテキストは、フロー内のパケットのヘッダーを正しく圧縮または解凍するために、コンプレッサーと減圧器が維持する状態です。各コンテキストは、CIDを使用して識別されます。"
    },
    {
      "indent": 3,
      "text": "A context is considered to be a new context when the CID is associated with a profile for the first time since the creation of the ROHC channel, or when the CID gets associated from the reception of an IR (this does not apply to the IR-DYN) with a different profile than the profile in the context.",
      "ja": "CIDがROHCチャネルの作成以来初めてプロファイルに関連付けられている場合、またはCIDがIRの受信から関連付けられた場合（これはIRに適用されない場合、CIDがプロファイルに初めて関連付けられている場合、コンテキストは新しいコンテキストと見なされます。dyn）コンテキスト内のプロファイルとは異なるプロファイルを使用します。"
    },
    {
      "indent": 3,
      "text": "Context information is conceptually kept in a table. The context table is indexed using the CID, which is sent along with compressed headers and feedback information.",
      "ja": "コンテキスト情報は概念的にテーブルに保持されます。コンテキストテーブルは、CIDを使用してインデックス化されており、圧縮ヘッダーとフィードバック情報とともに送信されます。"
    },
    {
      "indent": 3,
      "text": "The CID space can be either small, which means that CIDs can take the values 0 through 15, or large, which means that CIDs take values between 0 and 2^14 - 1 = 16383. Whether the CID space is large or small MUST be established, possibly by negotiation, before any compressed packet may be sent over the ROHC channel.",
      "ja": "CIDスペースは小さい場合があります。つまり、CIDは0〜15から15、または大規模な値を取得できます。つまり、CIDは0〜2^14-1 = 16383の値を取得できます。おそらく交渉により、圧縮されたパケットがROHCチャネル上で送信される前に確立されます。"
    },
    {
      "indent": 3,
      "text": "The CID space is distinct for each channel, i.e., CID 3 over channel A and CID 3 over channel B do not refer to the same context, even if the endpoints of A and B are the same nodes. In particular, CIDs for any pair of ROHC channels are not related (two associated ROHC channels serving as feedback channels for one another do not even need to have CID spaces of the same size).",
      "ja": "CIDスペースは各チャネルで異なります。つまり、チャンネルA上のCID 3およびチャネルB上のCID 3は、AとBのエンドポイントが同じノードであっても、同じコンテキストを参照しません。特に、ROHCチャネルのペアのCIDは関連していません（互いにフィードバックチャネルとして機能する2つの関連ROHCチャネルは、同じサイズのCIDスペースを持つ必要さえありません）。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Per-Channel Parameters",
      "section_title": true,
      "ja": "5.1.2. チャネルごとのパラメーター"
    },
    {
      "indent": 3,
      "text": "The ROHC channel is based on a number of parameters that form part of the established channel state and the per-context state. The state of the ROHC channel MUST be established before the first ROHC packet may be sent, which may be achieved using negotiation protocols provided by the link layer (see also [4], which describes an option for negotiation of ROHC parameters for PPP). This section describes some of this channel state information in an abstract way:",
      "ja": "ROHCチャネルは、確立されたチャネル状態とコンテキストごとの状態の一部を形成する多くのパラメーターに基づいています。ROHCチャネルの状態は、最初のROHCパケットを送信する前に確立する必要があります。これは、リンクレイヤーによって提供されるネゴシエーションプロトコルを使用して達成できます（PPPのROHCパラメーターの交渉オプションを説明する[4]も参照）。このセクションでは、このチャネル状態情報の一部について抽象的な方法で説明します。"
    },
    {
      "indent": 3,
      "text": "LARGE_CIDS: Boolean; if false, the small CID representation (0 octets or 1 prefix octet, covering CID 0 to 15) is used; if true, the large CID representation (1 or 2 embedded CID octets covering CID 0 to 16383) is used. See also 5.1.1 and 5.2.1.3.",
      "ja": "large_cids：boolean;FALSEの場合、小さなCID表現（0オクテットまたは1のプレフィックスオクテット、CID 0〜15をカバーする）が使用されます。真実の場合、CID 0〜16383を覆う1つまたは2つの埋め込みCIDオクテット）が使用されます。5.1.1および5.2.1.3も参照してください。"
    },
    {
      "indent": 3,
      "text": "MAX_CID: Non-negative integer; highest CID number to be used by the compressor (note that this parameter is not coupled to, but in effect further constrained by, LARGE_CIDS). This value represents an agreement by the decompressor that it can provide sufficient memory resources to host at least MAX_CID+1 contexts; the decompressor MUST maintain established contexts within this space until either the CID gets re-used by the establishment of a new context, or until the channel is taken down.",
      "ja": "MAX_CID：非陰性整数;コンプレッサーが使用する最高のCID数（このパラメーターは、large_cidsに結合されているのではなく、実際にはさらに制約されていることに注意してください）。この値は、少なくともMAX_CID 1コンテキストをホストするのに十分なメモリリソースを提供できるという減圧装置による契約を表します。減圧器は、CIDが新しいコンテキストの確立によって再利用されるか、チャネルが削除されるまで、このスペース内の確立されたコンテキストを維持する必要があります。"
    },
    {
      "indent": 3,
      "text": "PROFILES: Set of non-negative integers, where each integer indicates a profile supported by both the compressor and the decompressor. A profile is identified by a 16-bit value, where the 8 LSB bits indicate the actual profile, and the 8 MSB bits indicate the variant of that profile. The ROHC compressed header format identifies the profile used with only the 8 LSB bits; this means that if multiple variants of the same profile are available for a ROHC channel, the PROFILES set after negotiation MUST NOT include more than one variant of the same profile. The compressor MUST NOT compress using a profile that is not in PROFILES.",
      "ja": "プロファイル：非陰性整数のセット。各整数は、コンプレッサーと減圧器の両方でサポートされているプロファイルを示します。プロファイルは16ビット値によって識別され、8つのLSBビットが実際のプロファイルを示し、8 MSBビットはそのプロファイルのバリアントを示します。ROHC圧縮ヘッダー形式は、8 LSBビットのみで使用されるプロファイルを識別します。これは、同じプロファイルの複数のバリアントがROHCチャネルで利用可能である場合、交渉後に設定されたプロファイルに同じプロファイルの複数のバリアントを含めてはならないことを意味します。コンプレッサーは、プロファイルではないプロファイルを使用して圧縮してはなりません。"
    },
    {
      "indent": 3,
      "text": "FEEDBACK_FOR: Optional reference to a ROHC channel in the opposite direction between the same compression endpoints. If provided, this parameter indicates to which other ROHC channel any feedback sent on this ROHC channel refers (see [5]).",
      "ja": "Feedback_for：同じ圧縮エンドポイント間の反対方向にあるROHCチャネルへのオプションの参照。提供されている場合、このパラメーターは、このROHCチャネルに送信されたフィードバックが参照する他のROHCチャネルを示します（[5]を参照）。"
    },
    {
      "indent": 3,
      "text": "MRRU: Non-negative integer. Maximum Reconstructed Reception Unit. This is the size of the largest reconstructed unit in octets that the decompressor is expected to reassemble from segments (see Section 5.2.5). This size includes the segmentation CRC. If MRRU is negotiated to be 0, segmentation MUST NOT be used on the channel, and received segments MUST be discarded by the decompressor.",
      "ja": "MRRU：非陰性整数。最大再構築レセプションユニット。これは、オクテットの最大の再構築されたユニットのサイズであり、減圧器がセグメントから再組み立てされると予想されます（セクション5.2.5を参照）。このサイズにはセグメンテーションCRCが含まれます。MRRUが0と交渉されている場合、セグメンテーションをチャネルで使用してはならず、受信したセグメントは減圧器によって破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Persistence of Decompressor Contexts",
      "section_title": true,
      "ja": "5.1.3. 減圧器のコンテキストの持続性"
    },
    {
      "indent": 3,
      "text": "As part of the negotiated channel parameters, the compressor and decompressor have through the MAX_CID parameter agreed on the highest context identification (CID) number to be used. By agreeing on the MAX_CID, the decompressor also agrees to provide memory resources to host at least MAX_CID+1 contexts, and an established context with a CID within this negotiated space SHOULD be kept by the decompressor until either the CID gets re-used, or the channel is taken down or re-negotiated.",
      "ja": "ネゴシエートされたチャネルパラメーターの一部として、コンプレッサーと分解器は、MAX_CIDパラメーターを介して、使用する最高のコンテキスト識別（CID）数に合意しました。MAX_CIDに同意することにより、減圧装置は、少なくともMAX_CID 1コンテキストをホストするメモリリソースを提供することに同意し、このネゴシエートスペース内のCIDを使用した確立されたコンテキストは、CIDが再利用されるか、またはCIDが再利用されるまで保持する必要があります。チャネルは削除または再交渉されます。"
    },
    {
      "indent": 0,
      "text": "5.2. ROHC Packets and Packet Types",
      "section_title": true,
      "ja": "5.2. ROHCパケットとパケットタイプ"
    },
    {
      "indent": 3,
      "text": "This section uses the following convention in the diagrams when representing various ROHC packet types, formats, and fields:",
      "ja": "このセクションでは、さまざまなROHCパケットタイプ、フォーマット、およびフィールドを表す際に、次の規則を図で使用します。"
    },
    {
      "indent": 6,
      "text": "- colons \":\" indicate that the part is optional - slashes \"/\" indicate variable length",
      "ja": "- コロン \"：\"部品がオプションであることを示します - スラッシュ \"/\""
    },
    {
      "indent": 3,
      "text": "The ROHC packet type indication scheme has been designed to provide optional padding, a feedback packet type, an optional Add-CID octet (which includes 4 bits of CID), and a simple segmentation and reassembly mechanism.",
      "ja": "ROHCパケットタイプの表示スキームは、オプションのパディング、フィードバックパケットタイプ、オプションの追加CIDオクター（4ビットのCIDを含む）、および簡単なセグメンテーションと再組み立てメカニズムを提供するように設計されています。"
    },
    {
      "indent": 3,
      "text": "The following packet types are reserved at the ROHC framework level:",
      "ja": "次のパケットタイプは、ROHCフレームワークレベルで予約されています。"
    },
    {
      "indent": 6,
      "text": "11100000 : Padding 1110nnnn : Add-CID octet (nnnn=CID with values 0x1 through 0xF) 11110 : Feedback 11111000 : IR-DYN packet 1111110 : IR packet 1111111 : Segment",
      "ja": "11100000：パディング1110NNNN：ADD-CID OCTET（NNNN = CID 0x1〜0XF）11110：フィードバック11111000：IR-Dynパケット1111110：IRパケット1111111：セグメント"
    },
    {
      "indent": 3,
      "text": "Other packet types can be defined and used by individual profiles:",
      "ja": "他のパケットタイプは、個々のプロファイルで定義および使用できます。"
    },
    {
      "indent": 6,
      "text": "0 : available (not reserved by ROHC framework) 10 : available (not reserved by ROHC framework) 110 : available (not reserved by ROHC framework) 1111101 : available (not reserved by ROHC framework) 11111001 : available (not reserved by ROHC framework)",
      "ja": "0：利用可能（ROHCフレームワークによって予約されていない）10：利用可能（ROHCフレームワークによって予約されていない）110：利用可能（ROHCフレームワークによって予約されていない）1111101：利用可能（ROHCフレームワークによって予約されていない）11111001：利用可能（ROHCフレームワークによって予約されていない）"
    },
    {
      "indent": 0,
      "text": "5.2.1. General Format of ROHC Packets",
      "section_title": true,
      "ja": "5.2.1. ROHCパケットの一般的な形式"
    },
    {
      "indent": 3,
      "text": "A ROHC packet has the following general format:",
      "ja": "ROHCパケットには、次の一般的な形式があります。"
    },
    {
      "indent": 3,
      "text": " --- --- --- --- --- --- --- ---\n:           Padding             :\n --- --- --- --- --- --- --- ---\n:           Feedback            :\n --- --- --- --- --- --- --- ---\n:            Header             :\n --- --- --- --- --- --- --- ---\n:           Payload             :\n --- --- --- --- --- --- --- ---",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Padding: Any number (zero or more) of padding octets, where the format of a padding octet is as defined in Section 5.2.1.1.",
      "ja": "パディング：パディングオクテットの任意の数（ゼロ以上）。パディングオクテットの形式は、セクション5.2.1.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Feedback: Any number (zero or more) of feedback elements, where the format of a feedback element is as defined in Section 5.2.4.1.",
      "ja": "フィードバック：フィードバック要素の任意の数（ゼロ以上）。フィードバック要素の形式は、セクション5.2.4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Header: Either a profile-specific CO header (see Section 5.2.1.3), an IR or IR-DYN header (see Section 5.2.2), or a ROHC Segment (see Section 5.2.5). There can be at most one Header in a ROHC packet, but it may also be omitted (if the packet contains Feedback only).",
      "ja": "ヘッダー：プロファイル固有のCOヘッダー（セクション5.2.1.3を参照）、IRまたはIR-Dynヘッダー（セクション5.2.2を参照）、またはROHCセグメント（セクション5.2.5を参照）。ROHCパケットにはせいぜい1つのヘッダーがありますが、省略することもできます（パケットにフィードバックのみが含まれている場合）。"
    },
    {
      "indent": 3,
      "text": "Payload: Corresponds to zero or more octets of payload from the uncompressed packet, starting with the first octet in the uncompressed packet after the last header compressible by the current profile.",
      "ja": "ペイロード：非圧縮パケットからのゼロ以上のペイロードに対応します。これは、現在のプロファイルによって最後のヘッダーが圧縮可能な後、非圧縮パケットの最初のオクテットから始まります。"
    },
    {
      "indent": 3,
      "text": "At least one of Feedback or Header MUST be present.",
      "ja": "少なくとも1つのフィードバックまたはヘッダーが存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Format of the Padding Octet",
      "section_title": true,
      "ja": "5.2.1.1. パディングオクテットの形式"
    },
    {
      "indent": 3,
      "text": "Padding octet:",
      "ja": "パディングオクテット："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1   1   1   0   0   0   0   0 |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note: The Padding octet MUST NOT be interpreted as an Add-CID octet for CID 0.",
      "ja": "注：パディングオクテットは、CID 0の追加CIDオクテットとして解釈してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Format of the Add-CID Octet",
      "section_title": true,
      "ja": "5.2.1.2. Add-CIDオクテットの形式"
    },
    {
      "indent": 3,
      "text": "Add-CID octet:",
      "ja": "ADD-CIDオクテット："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1   1   1   0 |      CID      |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CID: 0x1 through 0xF indicates CIDs 1 through 15.",
      "ja": "CID：0x1〜0xfは、CID 1〜15を示します。"
    },
    {
      "indent": 3,
      "text": "Note: The Padding octet looks like an Add-CID octet for CID 0.",
      "ja": "注：パディングオクテットは、CID 0の追加CIDオクテットのように見えます。"
    },
    {
      "indent": 0,
      "text": "5.2.1.3. General Format of Header",
      "section_title": true,
      "ja": "5.2.1.3. ヘッダーの一般的な形式"
    },
    {
      "indent": 3,
      "text": "All ROHC packet types have the following general Header format:",
      "ja": "すべてのROHCパケットタイプには、次の一般的なヘッダー形式があります。"
    },
    {
      "indent": 3,
      "text": "  0              x-1  x       7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         :  if CID 1-15 and small CIDs\n+--- --- --- --- ---+--- --- ---+\n| type indication   |   body    |  1 octet (8-x bits of body)\n+--- --- --- --- ---+--- --- ---+\n:                               :\n/    0, 1, or 2 octets of CID   /  1 or 2 octets if large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n/             body              /  variable length\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "type indication: ROHC packet type.",
      "ja": "タイプ表示：ROHCパケットタイプ。"
    },
    {
      "indent": 3,
      "text": "body: Interpreted according to the packet type indication and CID information, as defined by individual profiles.",
      "ja": "ボディ：個々のプロファイルで定義されているように、パケットタイプの表示とCID情報に従って解釈されます。"
    },
    {
      "indent": 3,
      "text": "Thus, the header either starts with a packet type indication or has a packet type indication immediately following an Add-CID octet.",
      "ja": "したがって、ヘッダーはパケットタイプの表示で始まるか、追加cidオクテットの直後にパケットタイプの表示があります。"
    },
    {
      "indent": 3,
      "text": "When the ROHC channel is configured with a small CID space:",
      "ja": "ROHCチャネルが小さなCIDスペースで構成されている場合："
    },
    {
      "indent": 6,
      "text": "o If an Add-CID immediately precedes the packet type indication, the packet has the CID of the Add-CID; otherwise, it has CID 0.",
      "ja": "o 追加CIDがパケットタイプの表示の直前にある場合、パケットにはADD-CIDのCIDがあります。それ以外の場合、CID 0があります。"
    },
    {
      "indent": 6,
      "text": "o A small CID with the value 0 is represented using zero bits; therefore, a flow associated with CID 0 has no CID overhead in the compressed header. In such case, Header starts with a packet type indication.",
      "ja": "o 値0の小さなCIDは、ゼロビットを使用して表されます。したがって、CID 0に関連付けられたフローには、圧縮ヘッダーにCIDオーバーヘッドがありません。そのような場合、ヘッダーはパケットタイプの表示から始まります。"
    },
    {
      "indent": 6,
      "text": "o A small CID with a value from 1 to 15 is represented using the Add-CID octet as described above. The Header starts with the Add-CID octet, followed by a packet type indication.",
      "ja": "o 1〜15の値を持つ小さなCIDは、上記のようにAdd-CIDオクテットを使用して表されます。ヘッダーは、Add-CID Octetから始まり、パケットタイプの表示が続きます。"
    },
    {
      "indent": 6,
      "text": "o There is no large CID in the Header.",
      "ja": "o ヘッダーには大きなCIDはありません。"
    },
    {
      "indent": 3,
      "text": "When the ROHC channel is configured with a large CID space:",
      "ja": "ROHCチャネルが大きなCIDスペースで構成されている場合："
    },
    {
      "indent": 6,
      "text": "o The large CID is always present and is represented using the encoding scheme of Section 5.3.2, limited to two octets. In this case, the Header starts with a packet type indication.",
      "ja": "o 大きなCIDは常に存在し、セクション5.3.2のエンコードスキームを使用して2つのオクテットに制限されています。この場合、ヘッダーはパケットタイプの表示から始まります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Initialization and Refresh (IR) Packet Types",
      "section_title": true,
      "ja": "5.2.2. 初期化と更新（IR）パケットタイプ"
    },
    {
      "indent": 3,
      "text": "IR packet types contain a profile identifier, which determines how the rest of the header is to be interpreted. They also associate a profile with a context. The stored profile parameter further determines the syntax and semantics of the packet type identifiers and packet types used with a specific context.",
      "ja": "IRパケットタイプには、プロファイル識別子が含まれており、ヘッダーの残りの部分をどのように解釈するかを決定します。また、プロファイルをコンテキストに関連付けます。保存されたプロファイルパラメーターは、特定のコンテキストで使用されるパケットタイプの識別子とパケットタイプの構文とセマンティクスをさらに決定します。"
    },
    {
      "indent": 3,
      "text": "The IR and IR-DYN packets always update the context for all context-updating fields carried in the header. They never clear the context, except when initializing a new context (see Section 5.1.1), or unless the profile indicated in the Profile field specifies otherwise.",
      "ja": "IRおよびIR-Dynパケットは、ヘッダーに掲載されたすべてのコンテキストアップデートフィールドのコンテキストを常に更新します。新しいコンテキストを初期化する場合（セクション5.1.1を参照）、またはプロファイルフィールドに示されているプロファイルが特に指定しない限り、コンテキストをクリアすることはありません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. ROHC IR Packet Type",
      "section_title": true,
      "ja": "5.2.2.1. ROHC IRパケットタイプ"
    },
    {
      "indent": 3,
      "text": "The IR header associates a CID with a profile, and typically also initializes the context. It can typically also refresh all (or parts of) the context. For IR, Header has the following general format:",
      "ja": "IRヘッダーはCIDをプロファイルに関連付け、通常、コンテキストも初期化します。通常、コンテキストのすべて（または一部）を更新することもできます。IRの場合、ヘッダーには次の一般的な形式があります。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         :  if CID 1-15 and small CID\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1   0 | x |  IR type octet\n+---+---+---+---+---+---+---+---+\n:                               :\n/      0-2 octets of CID        /  1 or 2 octets if large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|            Profile            |  1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              |  1 octet\n+---+---+---+---+---+---+---+---+\n|                               |\n/ profile specific information  /  variable length\n|                               |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "x: Profile specific information. Interpreted according to the profile indicated in the Profile field of the IR header.",
      "ja": "X：特定の情報をプロファイルします。IRヘッダーのプロファイルフィールドに示されているプロファイルに従って解釈されます。"
    },
    {
      "indent": 3,
      "text": "Profile: The profile associated with the CID. In the IR header, the profile identifier is abbreviated to the 8 least significant bits (see Section 5.1.2).",
      "ja": "プロファイル：CIDに関連付けられたプロファイル。IRヘッダーでは、プロファイル識別子は8つの最も有意なビットと略されます（セクション5.1.2を参照）。"
    },
    {
      "indent": 3,
      "text": "CRC: 8-bit CRC (see Section 5.3.1.1).",
      "ja": "CRC：8ビットCRC（セクション5.3.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Profile specific information: The content of this part of the IR header is defined by the individual profiles. It is interpreted according to the profile indicated in the Profile field.",
      "ja": "プロファイル特定の情報：IRヘッダーのこの部分の内容は、個々のプロファイルによって定義されます。これは、プロファイルフィールドに示されているプロファイルに従って解釈されます。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. ROHC IR-DYN Packet Type",
      "section_title": true,
      "ja": "5.2.2.2. ROHC IR-DYNパケットタイプ"
    },
    {
      "indent": 3,
      "text": "In contrast to the IR header, the IR-DYN header can never initialize a non-initialized context. However, it can redefine what profile is associated with a context, if the profile indicated in the IR-DYN header allows this. Thus, this packet type is also reserved at the framework level. The IR-DYN header typically also initializes or refreshes parts of a context. For IR-DYN, Header has the following general format:",
      "ja": "IRヘッダーとは対照的に、IR-Dynヘッダーは、非初期化されたコンテキストを初期化することはできません。ただし、IR-Dynヘッダーに示されているプロファイルがこれを許可する場合、コンテキストに関連付けられているプロファイルを再定義できます。したがって、このパケットタイプは、フレームワークレベルでも予約されています。IR-Dynヘッダーは通常、コンテキストの一部を初期化または再表示します。IR-Dynの場合、ヘッダーには次の一般的な形式があります。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         :  if CID 1-15 and small CID\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   0   0   0 |  IR-DYN type octet\n+---+---+---+---+---+---+---+---+\n:                               :\n/      0-2 octets of CID        /  1 or 2 octets if large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|            Profile            |  1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              |  1 octet\n+---+---+---+---+---+---+---+---+\n|                               |\n/ profile specific information  /  variable length\n|                               |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Profile: The profile associated with the CID. This is abbreviated in the same way as in IR packets.",
      "ja": "プロファイル：CIDに関連付けられたプロファイル。これは、IRパケットと同じ方法で略されます。"
    },
    {
      "indent": 3,
      "text": "CRC: 8-bit CRC (see Section 5.3.1.1).",
      "ja": "CRC：8ビットCRC（セクション5.3.1.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Profile specific information: The content of this part of the IR-DYN header is defined by the individual profiles. It is interpreted according to the profile indicated in the Profile field.",
      "ja": "プロファイル特定の情報：IR-Dynヘッダーのこの部分の内容は、個々のプロファイルによって定義されます。これは、プロファイルフィールドに示されているプロファイルに従って解釈されます。"
    },
    {
      "indent": 0,
      "text": "5.2.3. ROHC Initial Decompressor Processing",
      "section_title": true,
      "ja": "5.2.3. ROHC初期減圧器処理"
    },
    {
      "indent": 3,
      "text": "Initially, all contexts are in no context state. Thus, all packets referencing a non-initialized context, except packets that have enough information on the static fields, cannot be decompressed by the decompressor.",
      "ja": "当初、すべてのコンテキストはコンテキスト状態なしです。したがって、静的フィールドに十分な情報を持っているパケットを除く、非初期化コンテキストを参照するすべてのパケットは、減圧器によって減圧されません。"
    },
    {
      "indent": 3,
      "text": "When the decompressor receives a packet of type IR, the profile indicated in the IR packet determines how it is to be processed.",
      "ja": "減圧器がタイプIRのパケットを受信すると、IRパケットに示されているプロファイルが処理方法を決定します。"
    },
    {
      "indent": 6,
      "text": "o If the 8-bit CRC fails to verify the integrity of the Header, the packet MUST NOT be decompressed and delivered to upper layers. If a profile is indicated in the context, the logic of that profile determines what, if any, feedback is to be sent. If no profile is noted in the context, the logic used to determine what, if any, feedback to send is up to the implementation. However, it may be suitable to take no further actions, as any part of the IR header covered by the CRC may have caused the failure.",
      "ja": "o 8ビットCRCがヘッダーの整合性を確認できない場合、パケットを解凍して上層に配信する必要はありません。コンテキストでプロファイルが示されている場合、そのプロファイルのロジックは、フィードバックが送信されるものを決定します。コンテキストでプロファイルが記載されていない場合、ロジックは、送信するフィードバックが実装にまで及ぶものを決定するために使用されます。ただし、CRCの対象となるIRヘッダーの一部が障害を引き起こした可能性があるため、それ以上のアクションをとることは適していない場合があります。"
    },
    {
      "indent": 3,
      "text": "When the decompressor receives a packet of type IR-DYN, the profile indicated in the IR-DYN packet determines how it is to be processed.",
      "ja": "減圧器がタイプIR-Dynのパケットを受信すると、IR-Dynパケットに示されているプロファイルが処理方法を決定します。"
    },
    {
      "indent": 6,
      "text": "o If the 8-bit CRC fails to verify the integrity of the header, the packet MUST NOT be decompressed and delivered to upper layers. If a profile is indicated in the context, the logic of that profile determines what, if any, feedback is to be sent. If no profile is noted in the context, the logic used to determine what, if any, feedback to send is up to the implementation. However, it may be suitable to take no further actions, as any part of the IR-DYN header covered by the CRC may have caused the failure.",
      "ja": "o 8ビットCRCがヘッダーの整合性を確認できない場合、パケットを解凍して上層に配信する必要はありません。コンテキストでプロファイルが示されている場合、そのプロファイルのロジックは、フィードバックが送信されるものを決定します。コンテキストでプロファイルが記載されていない場合、ロジックは、送信するフィードバックが実装にまで及ぶものを決定するために使用されます。ただし、CRCの対象となるIR-Dynヘッダーの一部が障害を引き起こした可能性があるため、それ以上のアクションをとることは適切な場合があります。"
    },
    {
      "indent": 6,
      "text": "o If the context has not already been initialized, the packet MUST NOT be decompressed and delivered to upper layers. The logic of the profile indicated in the IR-DYN header (if verified by the 8-bit CRC), determines what, if any, feedback is to be sent.",
      "ja": "o コンテキストがまだ初期化されていない場合、パケットを解凍して上層に配信する必要はありません。IR-Dynヘッダー（8ビットCRCによって検証された場合）に示されているプロファイルのロジックは、フィードバックが送信されるものを決定します。"
    },
    {
      "indent": 3,
      "text": "If a parsing error occurs for any packet type, the decompressor MUST discard the packet without further processing. For example, a CID field is present in the compressed header when the large CID space is used for the ROHC channel, and the field is coded using the self-describing variable-length encoding of Section 5.3.2; if the field starts with 110 or 111, this would generate a parsing error for the decompressor because this field must not be encoded with a size larger than 2 octets.",
      "ja": "任意のパケットタイプで解析エラーが発生した場合、減圧器はさらに処理せずにパケットを破棄する必要があります。たとえば、ROHCチャネルに大きなCIDスペースが使用されると、CIDフィールドが圧縮ヘッダーに存在し、セクション5.3.2の自己記述可変長エンコードを使用してフィールドがコード化されています。フィールドが110または111で始まる場合、このフィールドを2オクテットを大きいサイズでエンコードしてはならないため、これにより、減圧器の解析誤差が生成されます。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that profiles disallow the decompressor to make a decompression attempt for packets carrying only a 3-bit CRC after it has invalidated some or all of the entire dynamic context, until a packet that contains sufficient information on the dynamic fields is received, decompressed, and successfully verified by a 7- or 8-bit CRC.",
      "ja": "ダイナミックフィールドに十分な情報を含むパケットが受信され、減圧され、減圧された後、プロファイルが3ビットCRCの一部またはすべてを無効にした後、3ビットCRCのみを運ぶパケットの減圧試行を行うように禁止することをお勧めします。、および7ビットまたは8ビットCRCによって正常に検証されました。"
    },
    {
      "indent": 0,
      "text": "5.2.4. ROHC Feedback",
      "section_title": true,
      "ja": "5.2.4. ROHCフィードバック"
    },
    {
      "indent": 3,
      "text": "Feedback carries information from the decompressor to compressor. Feedback can be sent over a ROHC channel that operates in the same direction as the feedback.",
      "ja": "フィードバックは、減圧器からコンプレッサーへの情報を伝えます。フィードバックは、フィードバックと同じ方向に動作するROHCチャネルを介して送信できます。"
    },
    {
      "indent": 3,
      "text": "The general ROHC packet format allows transport of feedback using interspersion or piggybacking (see [5]), or a combination of both, over a ROHC channel. This is facilitated by the following properties: Reserved packet type:",
      "ja": "一般的なROHCパケット形式では、ROHCチャネルを介して、散布またはピギーバック（[5]を参照）、または両方の組み合わせを使用したフィードバックの輸送が可能になります。これは、次のプロパティによって促進されます。予約済みパケットタイプ："
    },
    {
      "indent": 6,
      "text": "A feedback packet type is reserved at the framework level. The packet type can carry variable-length feedback information.",
      "ja": "フィードバックパケットタイプは、フレームワークレベルで予約されています。パケットタイプは、可変長のフィードバック情報を伝えることができます。"
    },
    {
      "indent": 3,
      "text": "CID information:",
      "ja": "CID情報："
    },
    {
      "indent": 6,
      "text": "The feedback information sent on a particular channel is passed to, and interpreted by, the compressor associated with feedback on that channel. Thus, each feedback element contains CID information from the channel for which the feedback is sent. The ROHC feedback scheme thus requires that a channel carries feedback to at most one compressor. How a compressor is associated with the feedback for a particular channel is outside the scope of this specification. See also [5].",
      "ja": "特定のチャネルで送信されたフィードバック情報は、そのチャネルのフィードバックに関連付けられたコンプレッサーに渡され、解釈されます。したがって、各フィードバック要素には、フィードバックが送信されるチャネルからのCID情報が含まれています。したがって、ROHCフィードバックスキームでは、チャネルが最大1つのコンプレッサーにフィードバックを搭載する必要があります。コンプレッサーが特定のチャネルのフィードバックにどのように関連付けられているかは、この仕様の範囲外です。[5]も参照してください。"
    },
    {
      "indent": 3,
      "text": "Length information:",
      "ja": "長さの情報："
    },
    {
      "indent": 6,
      "text": "The length of a feedback element can be determined by examining the first few octets of the feedback. This enables piggybacking of feedback, and also the concatenation of more than one feedback element in a packet. The length information thus decouples the decompressor from the associated same-side compressor, as the decompressor can extract the feedback information from the compressed header without parsing its content and hand over the extracted information.",
      "ja": "フィードバック要素の長さは、フィードバックの最初の数オクテットを調べることで決定できます。これにより、フィードバックのピギーバック、およびパケット内の複数のフィードバック要素の連結が可能になります。したがって、長さの情報は、関連する同じサイドコンプレッサーの減圧装置を切り離します。これは、分解器がコンテンツを解析せずに圧縮ヘッダーからフィードバック情報を抽出し、抽出された情報を引き渡すことができるためです。"
    },
    {
      "indent": 3,
      "text": "The association between compressor-decompressor pairs operating in opposite directions, for the purpose of exchanging piggyback and/or interspersed feedback, SHOULD be maintained for the lifetime of the ROHC channel. Otherwise, it is RECOMMENDED that the compressor be notified if the feedback channel is no longer available: the compressor SHOULD then restart compression by creating a new context for each packet flow, and SHOULD use a CID value that was not previously associated with the profile used to compress the flow.",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.4.1. ROHC Feedback Format",
      "section_title": true,
      "ja": "5.2.4.1. ROHCフィードバック形式"
    },
    {
      "indent": 3,
      "text": "ROHC defines three different categories of feedback messages: acknowledgment (ACK), negative ACK (NACK), and NACK for the entire context (STATIC-NACK). Other types of information may be defined in profile-specific feedback information.",
      "ja": "ROHCは、フィードバックメッセージの3つの異なるカテゴリを定義します。承認（ACK）、ネガティブACK（NACK）、およびNACK（static-nack）。他のタイプの情報は、プロファイル固有のフィードバック情報で定義される場合があります。"
    },
    {
      "indent": 3,
      "text": "ACK : Acknowledges successful decompression of a packet. Indicates that the decompressor considers its context to be valid.",
      "ja": "ACK：パケットの減圧が成功したことを認めています。減圧器がそのコンテキストが有効であると見なしていることを示します。"
    },
    {
      "indent": 3,
      "text": "NACK : Indicates that the decompressor considers some or all of the dynamic part of its context invalid.",
      "ja": "NACK：減圧器が、そのコンテキストの動的部分の一部またはすべてが無効であることを考慮していることを示します。"
    },
    {
      "indent": 3,
      "text": "STATIC-NACK : Indicates that the decompressor considers its entire static context invalid, or that it has not been established.",
      "ja": "Static-Nack：減圧器が静的コンテキスト全体が無効であると見なすこと、または確立されていないことを示します。"
    },
    {
      "indent": 3,
      "text": "Feedback sent on a ROHC channel consists of one or more concatenated feedback elements, where each feedback element has the following format:",
      "ja": "ROHCチャネルで送信されたフィードバックは、1つ以上の連結されたフィードバック要素で構成されています。各フィードバック要素には次の形式があります。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   0 |   Code    |  feedback type\n+---+---+---+---+---+---+---+---+\n:             Size              :  if Code = 0\n+---+---+---+---+---+---+---+---+\n:         Add-CID octet         :  if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n:                               :\n/  large CID (5.3.2 encoding)   /  1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n/         FEEDBACK data         /  variable length\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Code: 0 indicates that a Size octet is present. 1-7 indicates the size of the feedback data field, in octets.",
      "ja": "コード：0は、サイズのオクテットが存在することを示します。1-7は、オクテットのフィードバックデータフィールドのサイズを示します。"
    },
    {
      "indent": 3,
      "text": "Size: Indicates the size of the feedback data field, in octets.",
      "ja": "サイズ：オクテットのフィードバックデータフィールドのサイズを示します。"
    },
    {
      "indent": 3,
      "text": "FEEDBACK data: FEEDBACK-1 or FEEDBACK-2 (see below).",
      "ja": "フィードバックデータ：フィードバック1またはフィードバック-2（以下を参照）。"
    },
    {
      "indent": 3,
      "text": "CID information in a feedback element indicates the context for which feedback is sent. The LARGE_CIDS parameter that controls whether a large CID is present is taken from the channel state of the receiving compressor's channel, not from the state of the channel carrying the feedback.",
      "ja": "フィードバック要素のCID情報は、フィードバックが送信されるコンテキストを示します。大きなCIDが存在するかどうかを制御するlarge_cidsパラメーターは、フィードバックを運ぶチャネルの状態からではなく、受信コンプレッサーのチャネルのチャネル状態から取得されます。"
    },
    {
      "indent": 3,
      "text": "The large CID field, if present, is encoded according to Section 5.3.2, and it MUST NOT be encoded using more than 2 octets.",
      "ja": "大きなCIDフィールドは、存在する場合、セクション5.3.2に従ってエンコードされており、2オクテット以上を使用してエンコードしてはなりません。"
    },
    {
      "indent": 3,
      "text": "The FEEDBACK data field can have either of the following two formats:",
      "ja": "フィードバックデータフィールドには、次の2つの形式のいずれかを持つことができます。"
    },
    {
      "indent": 3,
      "text": "FEEDBACK-1:",
      "ja": "フィードバック1："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| profile specific information  |  1 octet\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "FEEDBACK-2:",
      "ja": "フィードバック-2："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|Acktype|                       |\n+---+---+   profile specific    /  at least 2 octets\n/             information       |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Acktype: 0 = ACK 1 = NACK 2 = STATIC-NACK 3 is reserved (MUST NOT be used. Otherwise unparseable.)",
      "ja": "Acktype：0 = ack 1 = nack 2 = static-nack 3は予約されています（使用してはいけません。それ以外の場合は比類のないものです。）"
    },
    {
      "indent": 0,
      "text": "5.2.5. ROHC Segmentation",
      "section_title": true,
      "ja": "5.2.5. ROHCセグメンテーション"
    },
    {
      "indent": 3,
      "text": "ROHC defines a simple segmentation protocol. The compressor may perform segmentation, e.g., to accommodate packets that are larger than a specific size configured for the channel.",
      "ja": "ROHCは、単純なセグメンテーションプロトコルを定義します。コンプレッサーは、たとえば、チャネル用に構成された特定のサイズよりも大きいパケットに対応するために、セグメンテーションを実行できます。"
    },
    {
      "indent": 0,
      "text": "5.2.5.1. Segmentation Usage Considerations",
      "section_title": true,
      "ja": "5.2.5.1. セグメンテーションの使用に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The ROHC segmentation protocol is not particularly efficient. It is not intended to replace link layer segmentation functions; these SHOULD be used whenever available and efficient for the task at hand.",
      "ja": "ROHCセグメンテーションプロトコルは特に効率的ではありません。リンクレイヤーセグメンテーション機能を置き換えることを意図していません。これらは、手元のタスクに利用可能で効率的なときにいつでも使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ROHC segmentation protocol has been designed with an assumption of in-order delivery of packets between the compressor and the decompressor, using only a CRC for error detection, and no sequence numbers. If in-order delivery cannot be guaranteed, ROHC segmentation MUST NOT be used.",
      "ja": "ROHCセグメンテーションプロトコルは、エラー検出にCRCのみを使用して、コンプレッサーと減圧装置間のパケットの順序配信を仮定して設計されており、シーケンス番号はありません。注文内配達を保証できない場合、ROHCセグメンテーションを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "The segmentation protocol also assumes that all segments of a ROHC packet corresponding to one context are received without interference from other ROHC packets over the channel, including any ROHC packet corresponding to a different context. Based on this assumption, segments do not carry CID information, and therefore cannot be associated with a specific context until all segments have been received and the whole unit has been reconstructed.",
      "ja": "また、セグメンテーションプロトコルは、1つのコンテキストに対応するROHCパケットのすべてのセグメントが、異なるコンテキストに対応するROHCパケットを含むチャネル上の他のROHCパケットから干渉することなく受信されることを前提としています。この仮定に基づいて、セグメントはCID情報を携帯していないため、すべてのセグメントが受信され、ユニット全体が再構築されるまで特定のコンテキストに関連付けることはできません。"
    },
    {
      "indent": 0,
      "text": "5.2.5.2. Segmentation Protocol",
      "section_title": true,
      "ja": "5.2.5.2. セグメンテーションプロトコル"
    },
    {
      "indent": 3,
      "text": "ROHC segmentation is applied to the combination of the Header and the Payload fields of the ROHC packet, as defined in Section 5.2.1.",
      "ja": "ROHCセグメンテーションは、セクション5.2.1で定義されているように、ROHCパケットのヘッダーとペイロードフィールドの組み合わせに適用されます。"
    },
    {
      "indent": 3,
      "text": "Segment format:",
      "ja": "セグメント形式："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1   1 | F |  segment type\n+---+---+---+---+---+---+---+---+\n/           Segment             /  variable length\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "F: Final bit. If set, it indicates that this is the last segment of a reconstructed unit.",
      "ja": "F：最終ビット。設定されている場合、これが再構築されたユニットの最後のセグメントであることを示します。"
    },
    {
      "indent": 3,
      "text": "Padding and/or Feedback may precede the segment type octet. There is no per-segment CID, but CID information is of course part of the reconstructed unit. The reconstructed unit MUST NOT contain padding, segments, or feedback.",
      "ja": "パディングおよび/またはフィードバックは、セグメントタイプのオクテットに先行する場合があります。セグメントごとのCIDはありませんが、CID情報はもちろん再構築されたユニットの一部です。再構築されたユニットには、パディング、セグメント、またはフィードバックを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "When a final segment is received, the decompressor reassembles the segment carried in this packet and any non-final segments that immediately preceded it into a single reconstructed unit, in the order they were received. All segments for one reconstructed unit have to be received consecutively and in the correct order by the decompressor. If a non-segment ROHC packet directly follows a non-final segment, the reassembly of the current reconstructed unit is aborted and the decompressor MUST discard the non-final segments so far received on this channel.",
      "ja": "最終セグメントが受信されると、減圧器は、このパケットとそれを直前に1つの再構築されたユニットに到達した順序で、それらを受信した順に任意のセグメントに掲載されたセグメントを再組み立てします。1つの再構築されたユニットのすべてのセグメントは、分解器が連続して正しい順序で受信する必要があります。非セグメントROHCパケットが非ファイナルセグメントに直接従う場合、現在の再構築されたユニットの再組み立てが中止され、減圧器はこのチャネルでこれまでに受け取った非ファイナスセグメントを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Reconstructed unit:",
      "ja": "再構築されたユニット："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n/            Header             /  (see Section 5.2.1)\n+---+---+---+---+---+---+---+---+\n:            Payload            :  (see Section 5.2.1)\n+---+---+---+---+---+---+---+---+\n/              CRC              /  4 octets\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CRC: 32-bit CRC computed using the polynomial of Section 5.3.1.4.",
      "ja": "CRC：セクション5.3.1.4の多項式を使用して計算された32ビットCRC。"
    },
    {
      "indent": 3,
      "text": "If the reconstructed unit is 4 octets or less, or if the CRC fails, or if it is larger than the channel parameter MRRU (see Section 5.1.2), the reconstructed unit MUST be discarded by the decompressor. If the CRC succeeds, the reconstructed unit can be further processed.",
      "ja": "再構築されたユニットが4オクテット以下の場合、またはCRCが故障した場合、またはチャネルパラメーターMRRUよりも大きい場合（セクション5.1.2を参照）、再構成されたユニットは圧縮機によって破棄する必要があります。CRCが成功した場合、再構築されたユニットをさらに処理できます。"
    },
    {
      "indent": 0,
      "text": "5.3. General Encoding Methods",
      "section_title": true,
      "ja": "5.3. 一般的なエンコーディング方法"
    },
    {
      "indent": 0,
      "text": "5.3.1. Header Compression CRCs, Coverage and Polynomials",
      "section_title": true,
      "ja": "5.3.1. ヘッダー圧縮CRC、カバレッジ、多項式"
    },
    {
      "indent": 3,
      "text": "This section describes how to calculate the CRCs used by ROHC. For all CRCs, the algorithm used to calculate the CRC is the same as the one used in [2], defined in Appendix A of this document, with the polynomials specified in subsequent sections.",
      "ja": "このセクションでは、ROHCが使用するCRCを計算する方法について説明します。すべてのCRCについて、CRCの計算に使用されるアルゴリズムは、このドキュメントの付録Aで定義されている[2]で使用されているアルゴリズムと同じであり、後続のセクションで多項式が指定されています。"
    },
    {
      "indent": 0,
      "text": "5.3.1.1. 8-bit CRCs in IR and IR-DYN Headers",
      "section_title": true,
      "ja": "5.3.1.1. IRおよびIR-Dynヘッダーの8ビットCRC"
    },
    {
      "indent": 3,
      "text": "The coverage for the 8-bit CRC in the IR and IR-DYN headers is profile-dependent, but it MUST cover at least the initial part of the header ending with the Profile field, including the CID or an Add-CID octet. Feedback and padding are not part of Header (Section 5.2.1) and are thus not included in the CRC calculation. As a rule of thumb for profile specifications, any other information that initializes the decompressor context SHOULD also be covered by a CRC.",
      "ja": "IRおよびIR-Dynヘッダーの8ビットCRCのカバレッジはプロファイルに依存しますが、CIDやAdd-CIDオクターを含むプロファイルフィールドで終了するヘッダーの少なくとも最初の部分をカバーする必要があります。フィードバックとパディングはヘッダーの一部ではなく（セクション5.2.1）、したがってCRC計算には含まれていません。プロファイル仕様の経験則として、減圧装置のコンテキストを初期化する他の情報もCRCでカバーする必要があります。"
    },
    {
      "indent": 3,
      "text": "More specifically, the 8-bit CRC does not cover only and entirely the original uncompressed header; therefore, it does not provide the means for the decompressor to verify a decompression attempt, or the means to verify the correctness of the entire decompressor context. However, when successful, it does provide enough robustness for the decompressor to update its context with the information carried within the IR or the IR-DYN header.",
      "ja": "より具体的には、8ビットCRCは、元の非圧縮ヘッダーだけでなく、完全にカバーするだけではありません。したがって、減圧試行の試みを検証する手段、または減圧器全体のコンテキスト全体の正確性を検証する手段を提供するものではありません。ただし、成功した場合、ded decompressorがIRまたはIR-Dynヘッダー内で運ばれる情報でコンテキストを更新するのに十分な堅牢性を提供します。"
    },
    {
      "indent": 3,
      "text": "The CRC polynomial for the 8-bit CRC is:",
      "ja": "8ビットCRCのCRC多項式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "C(x) = 1 + x + x^2 + x^8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When computing the CRC, the CRC field in the header is set to zero, and the initial content of the CRC register is set to all 1's.",
      "ja": "CRCを計算すると、ヘッダー内のCRCフィールドがゼロに設定され、CRCレジスタの初期コンテンツはすべて1に設定されます。"
    },
    {
      "indent": 0,
      "text": "5.3.1.2. 3-bit CRC in Compressed Headers",
      "section_title": true,
      "ja": "5.3.1.2. 圧縮ヘッダーの3ビットCRC"
    },
    {
      "indent": 3,
      "text": "The 3-bit CRC in compressed headers is calculated over all octets of the entire original header, before compression, in the following manner.",
      "ja": "圧縮ヘッダーの3ビットCRCは、圧縮前の元のヘッダー全体のすべてのオクテットで、次の方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "The initial content of the CRC register is set to all 1's.",
      "ja": "CRCレジスタの初期コンテンツは、すべて1に設定されています。"
    },
    {
      "indent": 3,
      "text": "The polynomial for the 3-bit CRC is:",
      "ja": "3ビットCRCの多項式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "C(x) = 1 + x + x^3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The purpose of the 3-bit CRC is to provide the means for the decompressor to verify the outcome of a decompression attempt for small compressed headers, and to detect context damage based on aggregated probability over a number of decompression attempts. It is however too weak to provide enough success guarantees from the decompression of one single header. Therefore, compressed headers carrying a 3-bit CRC are normally not suitable to perform context repairs at the decompressor; hence, profiles should refrain from allowing decompression of such a header when some or the entire decompressor context is assumed invalid.",
      "ja": "3ビットCRCの目的は、減圧装置が小さな圧縮ヘッダーの減圧試行の結果を検証する手段を提供し、多くの減圧試行における集約確率に基づいてコンテキストの損傷を検出することです。ただし、1つのヘッダーの減圧から十分な成功保証を提供するには、弱すぎます。したがって、3ビットCRCを運ぶ圧縮ヘッダーは、通常、減圧器でコンテキスト修理を実行するのに適していません。したがって、プロファイルは、一部または全体の減圧コンテキストが無効であると想定されている場合、そのようなヘッダーの減圧を許可することを控える必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1.3. 7-bit CRC in Compressed Headers",
      "section_title": true,
      "ja": "5.3.1.3. 圧縮ヘッダーの7ビットCRC"
    },
    {
      "indent": 3,
      "text": "The 7-bit CRC in compressed headers is calculated over all octets of the entire original header, before compression, in the following manner.",
      "ja": "圧縮ヘッダーの7ビットCRCは、圧縮前の元のヘッダー全体のすべてのオクテットで、次の方法で計算されます。"
    },
    {
      "indent": 3,
      "text": "The initial content of the CRC register is set to all 1's.",
      "ja": "CRCレジスタの初期コンテンツは、すべて1に設定されています。"
    },
    {
      "indent": 3,
      "text": "The polynomial for the 7-bit CRC is:",
      "ja": "7ビットCRCの多項式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "C(x) = 1 + x + x^2 + x^3 + x^6 + x^7",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The purpose of the 7-bit CRC is to provide the means for the decompressor to verify the outcome of a decompression attempt for a larger compressed header, and to provide enough protection to validate a context repair at the decompressor. The 7-bit CRC is strong enough to assume a repair to be successful from the decompression of one single header; hence, profiles may allow decompression of a header carrying a 7-bit CRC when some of the decompressor context is assumed invalid.",
      "ja": "7ビットCRCの目的は、減圧装置がより大きな圧縮ヘッダーの減圧試行の結果を検証する手段を提供し、減圧器でのコンテキスト修復を検証するのに十分な保護を提供することです。7ビットCRCは、単一のヘッダーの減圧から成功するために修復が成功すると仮定するのに十分な強さです。したがって、プロファイルは、減圧器のコンテキストの一部が無効であると想定される場合、7ビットCRCを運ぶヘッダーの減圧を可能にする場合があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1.4. 32-bit Segmentation CRC",
      "section_title": true,
      "ja": "5.3.1.4. 32ビットセグメンテーションCRC"
    },
    {
      "indent": 3,
      "text": "The 32-bit CRC is used by the segmentation scheme to verify the reconstructed unit, and it is thus calculated over the segmented unit, i.e., over the Header and the Payload fields of the ROHC packet.",
      "ja": "32ビットCRCは、セグメンテーションスキームで使用されて再構築されたユニットを検証するため、セグメント化されたユニット、つまりROHCパケットのヘッダーとペイロードフィールドに計算されます。"
    },
    {
      "indent": 3,
      "text": "The initial content of the CRC register is set to all 1's.",
      "ja": "CRCレジスタの初期コンテンツは、すべて1に設定されています。"
    },
    {
      "indent": 3,
      "text": "The polynomial for the 32-bit CRC is:",
      "ja": "32ビットCRCの多項式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 + x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32.",
      "ja": "c（x）= x^0 x^1 x^2 x^4 x^5 x^7 x^8 x^10 x^11 x^12 x^16 x^22 x^23 x^26 x^32。"
    },
    {
      "indent": 3,
      "text": "The purpose of the 32-bit CRC is to verify the reconstructed unit.",
      "ja": "32ビットCRCの目的は、再構築されたユニットを検証することです。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Self-Describing Variable-Length Values",
      "section_title": true,
      "ja": "5.3.2. 自己記述変数長値"
    },
    {
      "indent": 3,
      "text": "The values of many fields and compression parameters can vary widely. To optimize the transfer of such values, a variable number of octets are used to encode them. The first few bits of the first octet determine the number of octets used:",
      "ja": "多くのフィールドと圧縮パラメーターの値は大きく異なります。このような値の転送を最適化するために、それらをエンコードするために可変数のオクテットが使用されます。最初のオクテットの最初の数ビットは、使用されるオクテットの数を決定します。"
    },
    {
      "indent": 3,
      "text": "First bit is 0: 1 octet. 7 bits transferred. Up to 127 decimal. Encoded octets in hexadecimal: 00 to 7F",
      "ja": "最初のビットは0：1オクテットです。7ビット転送。最大127小数。16進数でエンコードされたオクテット：00〜7f"
    },
    {
      "indent": 3,
      "text": "First bits are 10: 2 octets. 14 bits transferred. Up to 16 383 decimal. Encoded octets in hexadecimal: 80 00 to BF FF",
      "ja": "最初のビットは10：2オクテットです。14ビットが転送されました。最大16 383 10進数。ヘキサデシマルのエンコードオクテット：80 00〜BF ff"
    },
    {
      "indent": 3,
      "text": "First bits are 110: 3 octets. 21 bits transferred. Up to 2 097 151 decimal. Encoded octets in hexadecimal: C0 00 00 to DF FF FF",
      "ja": "最初のビットは110：3オクテットです。21ビット転送。最大2 097 151 10進数。16進数でエンコードされたオクテット：c0 00 00〜df ff ff"
    },
    {
      "indent": 3,
      "text": "First bits are 111: 4 octets. 29 bits transferred. Up to 536 870 911 decimal. Encoded octets in hexadecimal: E0 00 00 00 to FF FF FF FF",
      "ja": "最初のビットは111：4オクテットです。29ビット転送。最大536 870 911 10進数。16進数でエンコードされたオクテット：e0 00 00 00からff ff ff ff"
    },
    {
      "indent": 0,
      "text": "5.4. ROHC UNCOMPRESSED -- No Compression (Profile 0x0000)",
      "section_title": true,
      "ja": "5.4. ROHC非圧縮 - 圧縮なし（プロファイル0x0000）"
    },
    {
      "indent": 3,
      "text": "This section describes the uncompressed ROHC profile. The profile identifier for this profile is 0x0000.",
      "ja": "このセクションでは、非圧縮ROHCプロファイルについて説明します。このプロファイルのプロファイル識別子は0x0000です。"
    },
    {
      "indent": 3,
      "text": "Profile 0x0000 provides a way to send IP packets without compressing them. This can be used for any packet for which a compression profile is not available in the set of profiles supported by the ROHC channel, or for which compression is not desirable for some reason.",
      "ja": "プロファイル0x0000は、IPパケットを圧縮せずに送信する方法を提供します。これは、ROHCチャネルでサポートされているプロファイルのセットで圧縮プロファイルが使用できない、または何らかの理由で圧縮が望ましくない任意のパケットに使用できます。"
    },
    {
      "indent": 3,
      "text": "After initialization, the only overhead for sending packets using Profile 0x0000 is the size of the CID. When uncompressed packets are frequent, Profile 0x0000 should be associated with a CID the size of zero or one octet. Profile 0x0000 SHOULD be associated with at most one CID.",
      "ja": "初期化後、プロファイル0x0000を使用してパケットを送信するための唯一のオーバーヘッドは、CIDのサイズです。非圧縮パケットが頻繁に発生する場合、プロファイル0x0000は、ゼロまたは1オクテットのサイズのCIDに関連付けられている必要があります。プロファイル0x0000は、せいぜい1つのCIDに関連付ける必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4.1. IR Packet",
      "section_title": true,
      "ja": "5.4.1. IRパケット"
    },
    {
      "indent": 3,
      "text": "The initialization and refresh packet (IR packet) for Profile 0x0000 has the following Header format:",
      "ja": "プロファイル0x0000の初期化と更新パケット（IRパケット）には、次のヘッダー形式があります。"
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         : if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1   0 |res|\n+---+---+---+---+---+---+---+---+\n:                               :\n/    0-2 octets of CID info     / 1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|         Profile = 0x00        | 1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              | 1 octet\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "res: MUST be set to zero; otherwise, the decompressor MUST discard the packet.",
      "ja": "RES：ゼロに設定する必要があります。それ以外の場合、減圧器はパケットを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Profile: 0x00",
      "ja": "プロファイル：0x00"
    },
    {
      "indent": 3,
      "text": "CRC: 8-bit CRC, computed using the polynomial of Section 5.3.1.1. The CRC covers the first octet of the IR Header through the Profile octet of the IR Header, i.e., it does not cover the CRC itself. Neither does it cover any preceding Padding or Feedback, nor the Payload.",
      "ja": "CRC：セクション5.3.1.1の多項式を使用して計算された8ビットCRC。CRCは、IRヘッダーの最初のオクテットをIRヘッダーのプロファイルオクテットからカバーします。つまり、CRC自体をカバーしません。前のパディングやフィードバックもペイロードもカバーしていません。"
    },
    {
      "indent": 3,
      "text": "For the IR packet, Payload has the following format:",
      "ja": "IRパケットの場合、ペイロードには次の形式があります。"
    },
    {
      "indent": 3,
      "text": " --- --- --- --- --- --- --- ---\n:                               : (optional)\n/           IP packet           / variable length\n:                               :\n --- --- --- --- --- --- --- ---",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "IP packet: An uncompressed IP packet may be included in the IR packet. The decompressor determines if the IP packet is present by considering the length of the IR packet.",
      "ja": "IPパケット：非圧縮IPパケットがIRパケットに含まれる場合があります。減圧装置は、IRパケットの長さを考慮することにより、IPパケットが存在するかどうかを判断します。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Normal Packet",
      "section_title": true,
      "ja": "5.4.2. 通常のパケット"
    },
    {
      "indent": 3,
      "text": "A Normal packet is a normal IP packet plus CID information. For the Normal Packet, the following format corresponds to the Header and Payload (as defined in Section 5.2.1):",
      "ja": "通常のパケットは、通常のIPパケットとCID情報です。通常のパケットの場合、次の形式はヘッダーとペイロードに対応します（セクション5.2.1で定義されています）："
    },
    {
      "indent": 3,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         : if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n|   first octet of IP packet    |\n+---+---+---+---+---+---+---+---+\n:                               :\n/    0-2 octets of CID info     / 1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|                               |\n/       rest of IP packet       / variable length\n|                               |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the first octet of the IP packet starts with the bit pattern 0100 (IPv4) or 0110 (IPv6). This does not conflict with any reserved packet types.",
      "ja": "IPパケットの最初のオクテットは、ビットパターン0100（IPv4）または0110（IPv6）で始まることに注意してください。これは、予約されたパケットタイプと矛盾しません。"
    },
    {
      "indent": 3,
      "text": "When the channel uses small CIDs, and profile 0x0000 is associated with a CID > 0, an Add-CID octet precedes the IP packet. When the channel uses large CIDs, the CID is placed so that it starts at the second octet of the combined Header/Payload format above.",
      "ja": "チャネルが小さなCIDを使用し、プロファイル0x0000がCID> 0に関連付けられている場合、ADD-CIDオクテットはIPパケットの前にあります。チャネルが大きなCIDを使用すると、CIDが配置され、上記のヘッダー/ペイロード形式の2番目のオクテットから始まります。"
    },
    {
      "indent": 3,
      "text": "A Normal Packet may carry Padding and/or Feedback as any other ROHC packet, preceding the combined Header/Payload.",
      "ja": "通常のパケットは、ヘッダー/ペイロードを組み合わせた他のROHCパケットと同様に、パディングやフィードバックを運ぶ場合があります。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Decompressor Operation",
      "section_title": true,
      "ja": "5.4.3. 減圧剤操作"
    },
    {
      "indent": 3,
      "text": "When an IR packet is received, the decompressor first validates its header using the 8-bit CRC.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o If the header fails validation, the decompressor MUST NOT deliver the IP packet to upper layers.",
      "ja": "o ヘッダーが検証に失敗した場合、減圧器はIPパケットを上層に配信してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If the header is successfully validated, the decompressor",
      "ja": "o ヘッダーが正常に検証されている場合、減圧装置"
    },
    {
      "indent": 9,
      "text": "1) initializes the context if it has no valid context for the given CID already associated to the specified profile,",
      "ja": "1) 指定されたプロファイルに既に関連付けられている特定のCIDに対して有効なコンテキストがない場合、コンテキストを初期化します。"
    },
    {
      "indent": 9,
      "text": "2) delivers the IP packet to upper layers if present, 3) MAY send an ACK.",
      "ja": "2) 存在する場合は、IPパケットを上層に配信します。3）ACKを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "When any other packet is received while the decompressor has no context, it is discarded without further action.",
      "ja": "減圧器にコンテキストがない間に他のパケットが受信されると、さらなるアクションなしで破棄されます。"
    },
    {
      "indent": 3,
      "text": "When a Normal packet is received and the decompressor has a valid context, the IP packet is extracted and delivered to upper layers.",
      "ja": "通常のパケットが受信され、減圧器に有効なコンテキストがある場合、IPパケットが抽出され、上層に配信されます。"
    },
    {
      "indent": 0,
      "text": "5.4.4. Feedback",
      "section_title": true,
      "ja": "5.4.4. フィードバック"
    },
    {
      "indent": 3,
      "text": "The only kind of feedback defined by Profile 0x0000 is ACK, using the FEEDBACK-1 format of Section 5.2.4.1, where the value of the profile-specific octet in the FEEDBACK-1 is 0 (zero). The FEEDBACK-2 format is thus not defined for Profile 0x0000.",
      "ja": "プロファイル0x0000で定義されるフィードバックの唯一の種類は、ACKです。これは、セクション5.2.4.1のフィードバック1形式を使用しています。フィードバック1のプロファイル固有のオクテットの値は0（ゼロ）です。したがって、フィードバック-2形式は、プロファイル0x0000に対して定義されていません。"
    },
    {
      "indent": 0,
      "text": "6. Overview of a ROHC Profile (Informative)",
      "section_title": true,
      "ja": "6. ROHCプロファイルの概要（情報）"
    },
    {
      "indent": 3,
      "text": "The ROHC protocol consists of a framework part and a profile part. The framework defines the mechanisms common to all profiles, while the profile defines the compression algorithm and profile specific packet formats.",
      "ja": "ROHCプロトコルは、フレームワークパーツとプロファイルパーツで構成されています。フレームワークはすべてのプロファイルに共通するメカニズムを定義し、プロファイルは圧縮アルゴリズムとプロファイル固有のパケット形式を定義します。"
    },
    {
      "indent": 3,
      "text": "Section 5 specifies the details of the ROHC framework. This section provides an informative overview of the elements that make a profile specification. The normative specification of individual profiles is outside the scope of this document.",
      "ja": "セクション5では、ROHCフレームワークの詳細を指定します。このセクションでは、プロファイル仕様を作成する要素の有益な概要を説明します。個々のプロファイルの規範的仕様は、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "A ROHC profile defines the elements that build up the compression protocol. A ROHC profile consists of:",
      "ja": "ROHCプロファイルは、圧縮プロトコルを構築する要素を定義します。ROHCプロファイルは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Packet formats:",
      "ja": "パケット形式："
    },
    {
      "indent": 3,
      "text": "o Bits-on-the-wire",
      "ja": "o ワイヤーのビット"
    },
    {
      "indent": 6,
      "text": "The profile defines the layout of the bits for profile-specific packet types that it defines, and for the profile-specific parts of packet types common to all profiles (e.g., IR and IR-DYN).",
      "ja": "このプロファイルは、定義するプロファイル固有のパケットタイプのビットのレイアウトを定義し、すべてのプロファイルに共通するパケットタイプのプロファイル固有の部分（IRおよびIR-DYNなど）を定義します。"
    },
    {
      "indent": 3,
      "text": "o Field encodings",
      "ja": "o フィールドエンコーディング"
    },
    {
      "indent": 6,
      "text": "Bits and groups of bits from the packet format layout, referred to as Compressed fields, represents the result of an encoding method specific for that compressed field within a specific packet format. The profile defines these encoding methods.",
      "ja": "圧縮フィールドと呼ばれるパケット形式のレイアウトからのビットとビットのグループは、特定のパケット形式内の圧縮フィールドに固有のエンコードメソッドの結果を表します。プロファイルは、これらのエンコード方法を定義します。"
    },
    {
      "indent": 3,
      "text": "o Updating properties",
      "ja": "o プロパティの更新"
    },
    {
      "indent": 6,
      "text": "The profile-specific packet formats may update the state of the decompressor, and may do so in different ways. The profile defines how individual profile-specific fields, or entire profile-specific packet types, update the decompressor context.",
      "ja": "プロファイル固有のパケット形式は、減圧剤の状態を更新する場合があり、さまざまな方法でそれを行う場合があります。このプロファイルは、個々のプロファイル固有のフィールド、またはプロファイル固有のパケットタイプ全体がどのように分解器コンテキストを更新するかを定義します。"
    },
    {
      "indent": 3,
      "text": "o Verification",
      "ja": "o 検証"
    },
    {
      "indent": 6,
      "text": "Packets that update the state of the decompressor are verified to prevent incorrect updates to the decompressor context. The profile defines the mechanisms used to verify the decompression of a packet.",
      "ja": "減圧剤の状態を更新するパケットは、decompressorコンテキストの誤った更新を防ぐために検証されています。プロファイルは、パケットの減圧を検証するために使用されるメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "Context management:",
      "ja": "コンテキスト管理："
    },
    {
      "indent": 3,
      "text": "o Robustness logic",
      "ja": "o 堅牢性ロジック"
    },
    {
      "indent": 6,
      "text": "Packets may be lost or reordered between the compressor and the decompressor. The profile defines mechanism to minimize the impacts of such events and prevent damage propagation.",
      "ja": "パケットは、コンプレッサーと減圧器の間で紛失または並べ替えられる場合があります。このプロファイルは、そのようなイベントの影響を最小限に抑え、損傷の伝播を防ぐメカニズムを定義します。"
    },
    {
      "indent": 3,
      "text": "o Repair mechanism",
      "ja": "o 修復メカニズム"
    },
    {
      "indent": 6,
      "text": "Despite the robustness logic, impairment events may still lead to decompression failure(s), and even to context damage at the decompressor. The profile defines context repair mechanisms, including feedback logic if used.",
      "ja": "堅牢性の論理にもかかわらず、障害のイベントは依然として減圧障害、さらには減圧器での文脈的損傷につながる可能性があります。プロファイルは、使用した場合のフィードバックロジックを含むコンテキスト修復メカニズムを定義します。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Because encryption eliminates the redundancy that header compression schemes try to exploit, there is some inducement to forego encryption of headers in order to enable operation over low-bandwidth links.",
      "ja": "暗号化は、ヘッダー圧縮スキームが悪用しようとする冗長性を排除するため、低帯域幅リンク上の動作を有効にするために、ヘッダーの暗号化を放棄するにはいくらかの誘導があります。"
    },
    {
      "indent": 3,
      "text": "A malfunctioning or malicious header compressor could cause the header decompressor to reconstitute packets that do not match the original packets but still have valid headers and possibly also valid transport checksums. Such corruption may be detected with end-to-end authentication and integrity mechanisms, which will not be affected by the compression. Moreover, the ROHC header compression scheme uses an internal checksum for verification of reconstructed headers, which reduces the probability of producing decompressed headers not matching the original ones without this being noticed.",
      "ja": "誤動作または悪意のあるヘッダーコンプレッサーにより、ヘッダー減圧装置は、元のパケットと一致しないが、有効なヘッダーとおそらく有効な輸送チェックサムを持っているパケットを再構成する可能性があります。このような腐敗は、エンドツーエンドの認証と整合性メカニズムで検出される場合がありますが、これは圧縮の影響を受けません。さらに、ROHCヘッダー圧縮スキームは、再構築されたヘッダーの検証のために内部チェックサムを使用します。これにより、これが気付かずに元のヘッダーと一致しない減圧されたヘッダーを生成する確率が低下します。"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks are possible if an intruder can introduce, for example, bogus IR, IR-DYN, or FEEDBACK packets onto the link and thereby cause compression efficiency to be reduced. However, an intruder having the ability to inject arbitrary packets at the link layer in this manner raises additional security issues that dwarf those related to the use of header compression.",
      "ja": "侵入者がリンクに偽のIR、IR-DYN、またはフィードバックパケットを導入し、それにより圧縮効率を低下させる場合、サービス拒否攻撃が可能です。ただし、この方法でリンクレイヤーに任意のパケットを注入する機能を持つ侵入者は、ヘッダー圧縮の使用に関連する追加のセキュリティ問題を提起します。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "An IANA registry for \"RObust Header Compression (ROHC) Profile Identifiers\" [21] was created by RFC 3095 [3]. The assignment policy, as outlined by RFC 3095, is the following:",
      "ja": "「堅牢なヘッダー圧縮（ROHC）プロファイル識別子」[21]のIANAレジストリは、RFC 3095 [3]によって作成されました。RFC 3095で概説されているように、割り当てポリシーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "The ROHC profile identifier is a non-negative integer. In many negotiation protocols, it will be represented as a 16-bit value. Due to the way the profile identifier is abbreviated in ROHC packets, the 8 least significant bits of the profile identifier have a special significance: Two profile identifiers with identical 8 LSBs should be assigned only if the higher-numbered one is intended to supersede the lower-numbered one. To highlight this relationship, profile identifiers should be given in hexadecimal (as in 0x1234, which would for example supersede 0x0A34).",
      "ja": "ROHCプロファイル識別子は、非陰性整数です。多くの交渉プロトコルでは、16ビット値として表されます。ROHCパケットでプロファイル識別子が略される方法により、プロファイル識別子の8つの最も有意なビットには特に重要なものがあります。 - 数え切れない。この関係を強調するには、プロファイル識別子を16進数（0x1234のように、たとえば0x0A34に取って代わる）を与える必要があります。"
    },
    {
      "indent": 3,
      "text": "Following the policies outlined in [22], the IANA policy for assigning new values for the profile identifier shall be Specification Required: values and their meanings must be documented in an RFC or in some other permanent and readily available reference, in sufficient detail that interoperability between independent implementations is possible. In the 8 LSBs, the range 0 to 127 is reserved for IETF standard-track specifications; the range 128 to 254 is available for other specifications that meet this requirement (such as Informational RFCs). The LSB value 255 is reserved for future extensibility of the present specification.",
      "ja": "[22]で概説されているポリシーに従って、プロファイル識別子に新しい値を割り当てるためのIANAポリシーは、必要な仕様です。値とその意味は、RFCまたは他の永続的で容易に利用可能な参照で文書化する必要があります。独立した実装の間は可能です。8つのLSBでは、範囲0〜127はIETF標準トラック仕様用に予約されています。範囲128〜254は、この要件を満たす他の仕様（情報RFCなど）で使用できます。LSB値255は、現在の仕様の将来の拡張性のために予約されています。"
    },
    {
      "indent": 3,
      "text": "The following profile identifiers have so far been allocated:",
      "ja": "これまでのところ、次のプロファイル識別子が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Profile Identifier    Usage                      Reference\n------------------    ----------------------     ---------\n0x0000                ROHC uncompressed          RFC 4995\n0x0001                ROHC RTP                   RFC 3095\n0x0002                ROHC UDP                   RFC 3095\n0x0003                ROHC ESP                   RFC 3095\n0x0004                ROHC IP                    RFC 3843\n0x0005                ROHC LLA                   RFC 3242\n0x0105                ROHC LLA with R-mode       RFC 3408\n0x0006                ROHC TCP                   RFC 4996\n0x0007                ROHC RTP/UDP-Lite          RFC 4019\n0x0008                ROHC UDP-Lite              RFC 4019",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "New profiles will need new identifiers to be assigned by the IANA, but this document does not require any additional IANA action.",
      "ja": "新しいプロファイルでは、IANAによって新しい識別子を割り当てる必要がありますが、このドキュメントでは追加のIANAアクションは必要ありません。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to acknowledge all who have contributed to previous ROHC work, and especially to the authors of RFC 3095 [3], which is the technical basis for this document. Thanks also to the various individuals who contributed to the RFC 3095 corrections and clarifications document [6], from which technical contents, when applicable, have been incorporated into this document. Committed WG document reviewers were Carl Knutsson and Biplab Sarkar, who reviewed the document during working group last-call.",
      "ja": "著者は、以前のROHC作業に貢献したすべての人、特にこの文書の技術的根拠であるRFC 3095 [3]の著者に貢献したすべての人を認めたいと考えています。また、RFC 3095の修正と説明文書[6]に貢献してくれたさまざまな個人にも感謝します。この文書には、技術的なコンテンツがこの文書に組み込まれています。コミットされたWGドキュメントレビュアーは、ワーキンググループのラストコール中にドキュメントをレビューしたCarl KnutssonとBiplab Sarkarでした。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[2] Simpson, W., \"PPP in HDLC-like Framing\", STD 51, RFC 1662, July 1994.",
      "ja": "[2] シンプソン、W。、「HDLCのようなフレーミングのPPP」、STD 51、RFC 1662、1994年7月。"
    },
    {
      "indent": 3,
      "text": "[3] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed\", RFC 3095, July 2001.",
      "ja": "[3] Bormann、C.、Burmeister、C.、Degermark、M.、Fukushima、H.、Hannu、H.、Jonsson、L-E。、Hakenberg、R.、Koren、T.、Le、K.、Liu、Z。、Martensson、A.、Miyazaki、A.、Svanbro、K.、Wiebke、T.、Yoshimura、T.、およびH. Zheng、 \"Robust Header圧縮（ROHC）：フレームワークと4つのプロファイル：RTP、UDP、ESP、および非圧縮」、RFC 3095、2001年7月。"
    },
    {
      "indent": 3,
      "text": "[4] Bormann, C., \"Robust Header Compression (ROHC) over PPP\", RFC 3241, April 2002.",
      "ja": "[4] Bormann、C。、「PPP上の堅牢なヘッダー圧縮（ROHC）」、RFC 3241、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[5] Jonsson, L-E., \"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples\", RFC 3759, April 2004.",
      "ja": "[5] Jonsson、L-E。、「堅牢なヘッダー圧縮（ROHC）：用語とチャネルマッピングの例」、RFC 3759、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[6] Jonsson, L-E., Sandlund, K., Pelletier, G., and P. Kremer, \"RObust Header Compression (ROHC): Corrections and Clarifications to RFC 3095\", RFC 4815, February 2007.",
      "ja": "[6] Jonsson、L-E。、Sandlund、K.、Pelletier、G。、およびP. Kremer、「堅牢なヘッダー圧縮（ROHC）：RFC 3095への修正と明確化、RFC 4815、2007年2月。"
    },
    {
      "indent": 3,
      "text": "[7] Pelletier, G., Jonsson, L-E., and K. Sandlund, \"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets\", RFC 4224, January 2006.",
      "ja": "[7] Pelletier、G.、Jonsson、L-E。、およびK. Sandlund、「Robust Header Compression（ROHC）：Packetsを並べ替えることができるチャネル上のROHC」、RFC 4224、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[8] Pelletier, G. and K. Sandlund, \"RObust Header Compression Version 2 (ROHCv2): Profiles for RTP, UDP, IP, ESP, and UDP Lite\", Work in Progress, September 2006.",
      "ja": "[8] Pelletier、G。およびK. Sandlund、「堅牢なヘッダー圧縮バージョン2（ROHCV2）：RTP、UDP、IP、ESP、およびUDP Liteのプロファイル」、2006年9月の作業。"
    },
    {
      "indent": 3,
      "text": "[9] Pelletier, G., Sandlund, K., Jonsson, L-E., and M. West, \"RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)\", RFC 4996, July 2007.",
      "ja": "[9] Pelletier、G.、Sandlund、K.、Jonsson、L-E。、およびM. West、「堅牢なヘッダー圧縮（ROHC）：TCP/IP（ROHC-TCP）のプロファイル、RFC 4996、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[10] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[10] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[11] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[11] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[12] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[12] Postel、J。、「ユーザーデータグラムプロトコル」、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[13] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[13] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーション用の輸送プロトコル」、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[14] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[14] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[15] Jacobson, V., \"Compressing TCP/IP headers for low-speed serial links\", RFC 1144, February 1990.",
      "ja": "[15] Jacobson、V。、「低速シリアルリンクのTCP/IPヘッダーの圧縮」、RFC 1144、1990年2月。"
    },
    {
      "indent": 3,
      "text": "[16] Degermark, M., Nordgren, B., and S. Pink, \"IP Header Compression\", RFC 2507, February 1999.",
      "ja": "[16] Degermark、M.、Nordgren、B。、およびS. Pink、「IPヘッダー圧縮」、RFC 2507、1999年2月。"
    },
    {
      "indent": 3,
      "text": "[17] Casner, S. and V. Jacobson, \"Compressing IP/UDP/RTP Headers for Low-Speed Serial Links\", RFC 2508, February 1999.",
      "ja": "[17] Casner、S。およびV. Jacobson、「低速シリアルリンク用のIP/UDP/RTPヘッダーの圧縮」、RFC 2508、1999年2月。"
    },
    {
      "indent": 3,
      "text": "[18] Degermark, M., \"Requirements for robust IP/UDP/RTP header compression\", RFC 3096, July 2001.",
      "ja": "[18] Degermark、M。、「堅牢なIP/UDP/RTPヘッダー圧縮の要件」、RFC 3096、2001年7月。"
    },
    {
      "indent": 3,
      "text": "[19] Koren, T., Casner, S., Geevarghese, J., Thompson, B., and P. Ruddy, \"Enhanced Compressed RTP (CRTP) for Links with High Delay, Packet Loss and Reordering\", RFC 3545, July 2003.",
      "ja": "[19] Koren、T.、Casner、S.、Geevarghese、J.、Thompson、B。、およびP. Ruddy、「高い遅延、パケット損失、再注文を伴うリンクのための圧縮RTP（CRTP）の強化」、RFC 3545、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[20] Degermark, M., Hannu, H., Jonsson, L.E., and K. Svanbro, \"Evaluation of CRTP Performance over Cellular Radio Networks\", IEEE Personal Communication Magazine, Volume 7, number 4, pp. 20-25, August 2000.",
      "ja": "[20] Degermark、M.、Hannu、H.、Jonsson、L.E。、およびK. Svanbro、「セルラー無線ネットワーク上のCRTPパフォーマンスの評価」、IEEE Personal Communication Magazine、Volume 7、Number 4、pp。20-25、2000。"
    },
    {
      "indent": 3,
      "text": "[21] IANA registry, \"RObust Header Compression (ROHC) Profile Identifiers\", http://www.iana.org/assignments/rohc-pro-ids",
      "ja": "[21] IANAレジストリ、「堅牢なヘッダー圧縮（ROHC）プロファイル識別子」、http：//www.iana.org/assignments/rohc-pro-ids"
    },
    {
      "indent": 3,
      "text": "[22] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[22] Narten、T。およびH. Alvestrand、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. CRC Algorithm",
      "section_title": true,
      "ja": "付録A. CRCアルゴリズム"
    },
    {
      "indent": 3,
      "text": "#!/usr/bin/perl -w\nuse strict;\n#=================================\n#\n# ROHC CRC demo - Carsten Bormann cabo@tzi.org 2001-08-02\n#\n# This little demo shows the four types of CRC in use in RFC 3095,\n# the specification for robust header compression.  Type your data in\n# hexadecimal form and then press Control+D.\n#\n#---------------------------------\n#\n# utility\n#\nsub dump_bytes($) {\n    my $x = shift;\n    my $i;\n    for ($i = 0; $i < length($x); ) {\n  printf(\"%02x \", ord(substr($x, $i, 1)));\n  printf(\"\\n\") if (++$i % 16 == 0);\n    }\n    printf(\"\\n\") if ($i % 16 != 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# The CRC calculation algorithm.\n#\nsub do_crc($$$) {\n    my $nbits = shift;\n    my $poly = shift;\n    my $string = shift;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    my $crc = ($nbits == 32 ? 0xffffffff : (1 << $nbits) - 1);\n    for (my $i = 0; $i < length($string); ++$i) {\n      my $byte = ord(substr($string, $i, 1));\n      for( my $b = 0; $b < 8; $b++ ) {\n        if (($crc & 1) ^ ($byte & 1)) {\n          $crc >>= 1;\n          $crc ^= $poly;\n        } else {\n        $crc >>= 1;\n        }\n        $byte >>= 1;\n      }\n    }\n       printf \"%2d bits, \", $nbits;\n    printf \"CRC: %02x\\n\", $crc;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# Test harness\n#\n$/ = undef;\n$_ = <>;         # read until EOF\nmy $string = \"\"; # extract all that looks hex:\ns/([0-9a-fA-F][0-9a-fA-F])/$string .= chr(hex($1)), \"\"/eg;\ndump_bytes($string);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# 32-bit segmentation CRC\n# Note that the text implies this is complemented like for PPP\n# (this differs from 8, 7, and 3-bit CRC)\n#\n#      C(x) = x^0 + x^1 + x^2 + x^4 + x^5 + x^7 + x^8 + x^10 +\n#             x^11 + x^12 + x^16 + x^22 + x^23 + x^26 + x^32\n#\ndo_crc(32, 0xedb88320, $string);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# 8-bit IR/IR-DYN CRC\n#\n#      C(x) = x^0 + x^1 + x^2 + x^8\n#\ndo_crc(8, 0xe0, $string);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# 7-bit FO/SO CRC\n#\n#      C(x) = x^0 + x^1 + x^2 + x^3 + x^6 + x^7\n#\ndo_crc(7, 0x79, $string);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#---------------------------------\n#\n# 3-bit FO/SO CRC\n#\n#      C(x) = x^0 + x^1 + x^3\n#\ndo_crc(3, 0x6, $string);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lars-Erik Jonsson Optand 737 SE-831 92 Ostersund, Sweden",
      "ja": "Lars-Erik Jonsson Optand 737 SE-831 92 Ostersund、Sweden"
    },
    {
      "indent": 3,
      "text": "Phone: +46 70 365 20 58\nEMail: lars-erik@lejonsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Ghyslain Pelletier Ericsson AB Box 920 SE-971 28 Lulea, Sweden",
      "ja": "Ghyslain Pelletier Ericsson AB Box 920 SE-971 28 Lulea、Sweden"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 404 29 43\nFax:   +46 920 996 21\nEMail: ghyslain.pelletier@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kristofer Sandlund Ericsson AB Box 920 SE-971 28 Lulea, Sweden",
      "ja": "Kristofer Sandlund Ericsson AB Box 920 SE-971 28 Lulea、Sweden"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 404 41 58\nFax:   +46 920 996 21\nEMail: kristofer.sandlund@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}