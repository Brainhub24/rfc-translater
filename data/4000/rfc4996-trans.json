{
  "title": {
    "text": "RFC 4996 - RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)",
    "ja": "RFC 4996 - 堅牢なヘッダー圧縮（ROHC）：TCP/IP（ROHC-TCP）のプロファイル"
  },
  "number": 4996,
  "created_at": "2023-05-07 11:17:52.687707+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                       G. Pelletier\nRequest for Comments: 4996                                   K. Sandlund\nCategory: Standards Track                                       Ericsson\n                                                            L-E. Jonsson",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 54,
      "text": " M. West Siemens/Roke Manor July 2007",
      "ja": "M. West Siemens/Roke Manor 2007年7月"
    },
    {
      "indent": 3,
      "text": "RObust Header Compression (ROHC): A Profile for TCP/IP (ROHC-TCP)",
      "ja": "堅牢なヘッダー圧縮（ROHC）：TCP/IP（ROHC-TCP）のプロファイル"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a ROHC (Robust Header Compression) profile for compression of TCP/IP packets. The profile, called ROHC-TCP, provides efficient and robust compression of TCP headers, including frequently used TCP options such as SACK (Selective Acknowledgments) and Timestamps.",
      "ja": "このドキュメントは、TCP/IPパケットの圧縮のためのROHC（堅牢なヘッダー圧縮）プロファイルを指定します。ROHC-TCPと呼ばれるプロファイルは、SACK（選択的承認）やタイムスタンプなどの頻繁に使用されるTCPオプションを含む、TCPヘッダーの効率的で堅牢な圧縮を提供します。"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP works well when used over links with significant error rates and long round-trip times. For many bandwidth-limited links where header compression is essential, such characteristics are common.",
      "ja": "ROHC-TCPは、重要なエラー率と長い往復時間を持つリンクで使用するとうまく機能します。ヘッダー圧縮が不可欠な多くの帯域幅制限リンクの場合、そのような特性は一般的です。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  4\n3.  Background . . . . . . . . . . . . . . . . . . . . . . . . . .  5\n  3.1.  Existing TCP/IP Header Compression Schemes . . . . . . . .  5\n  3.2.  Classification of TCP/IP Header Fields . . . . . . . . . .  6\n4.  Overview of the TCP/IP Profile (Informative) . . . . . . . . .  8\n  4.1.  General Concepts . . . . . . . . . . . . . . . . . . . . .  8\n  4.2.  Compressor and Decompressor Interactions . . . . . . . . .  8\n    4.2.1.  Compressor Operation . . . . . . . . . . . . . . . . .  8\n    4.2.2.  Decompressor Feedback  . . . . . . . . . . . . . . . .  9\n  4.3.  Packet Formats and Encoding Methods  . . . . . . . . . . .  9\n    4.3.1.  Compressing TCP Options  . . . . . . . . . . . . . . . 10\n    4.3.2.  Compressing Extension Headers  . . . . . . . . . . . . 10\n  4.4.  Expected Compression Ratios with ROHC-TCP  . . . . . . . . 10\n5.  Compressor and Decompressor Logic (Normative)  . . . . . . . . 11\n  5.1.  Context Initialization . . . . . . . . . . . . . . . . . . 11\n  5.2.  Compressor Operation . . . . . . . . . . . . . . . . . . . 11\n    5.2.1.  Compression Logic  . . . . . . . . . . . . . . . . . . 11\n    5.2.2.  Feedback Logic . . . . . . . . . . . . . . . . . . . . 13\n    5.2.3.  Context Replication  . . . . . . . . . . . . . . . . . 14\n  5.3.  Decompressor Operation . . . . . . . . . . . . . . . . . . 14\n    5.3.1.  Decompressor States and Logic  . . . . . . . . . . . . 14\n    5.3.2.  Feedback Logic . . . . . . . . . . . . . . . . . . . . 18\n    5.3.3.  Context Replication  . . . . . . . . . . . . . . . . . 18\n6.  Encodings in ROHC-TCP (Normative)  . . . . . . . . . . . . . . 18\n  6.1.  Control Fields in ROHC-TCP . . . . . . . . . . . . . . . . 18\n    6.1.1.  Master Sequence Number (MSN) . . . . . . . . . . . . . 19\n    6.1.2.  IP-ID Behavior . . . . . . . . . . . . . . . . . . . . 19\n    6.1.3.  Explicit Congestion Notification (ECN) . . . . . . . . 20\n  6.2.  Compressed Header Chains . . . . . . . . . . . . . . . . . 21\n  6.3.  Compressing TCP Options with List Compression  . . . . . . 23\n    6.3.1.  List Compression . . . . . . . . . . . . . . . . . . . 23\n    6.3.2.  Table-Based Item Compression . . . . . . . . . . . . . 24\n    6.3.3.  Encoding of Compressed Lists . . . . . . . . . . . . . 25\n    6.3.4.  Item Table Mappings  . . . . . . . . . . . . . . . . . 26\n    6.3.5.  Compressed Lists in Dynamic Chain  . . . . . . . . . . 28\n    6.3.6.  Irregular Chain Items for TCP Options  . . . . . . . . 28\n    6.3.7.  Replication of TCP Options . . . . . . . . . . . . . . 28\n  6.4.  Profile-Specific Encoding Methods  . . . . . . . . . . . . 29\n    6.4.1.  inferred_ip_v4_header_checksum . . . . . . . . . . . . 29\n    6.4.2.  inferred_mine_header_checksum  . . . . . . . . . . . . 30\n    6.4.3.  inferred_ip_v4_length  . . . . . . . . . . . . . . . . 30\n    6.4.4.  inferred_ip_v6_length  . . . . . . . . . . . . . . . . 31\n    6.4.5.  inferred_offset  . . . . . . . . . . . . . . . . . . . 31\n    6.4.6.  baseheader_extension_headers . . . . . . . . . . . . . 31\n    6.4.7.  baseheader_outer_headers . . . . . . . . . . . . . . . 32\n       6.4.8.  Scaled Encoding of Fields  . . . . . . . . . . . . . . 32\n  6.5.  Encoding Methods With External Parameters  . . . . . . . . 34\n7.  Packet Types (Normative) . . . . . . . . . . . . . . . . . . . 36\n  7.1.  Initialization and Refresh (IR) Packets  . . . . . . . . . 36\n  7.2.  Context Replication (IR-CR) Packets  . . . . . . . . . . . 38\n  7.3.  Compressed (CO) Packets  . . . . . . . . . . . . . . . . . 41\n8.  Header Formats (Normative) . . . . . . . . . . . . . . . . . . 42\n  8.1.  Design Rationale for Compressed Base Headers . . . . . . . 42\n  8.2.  Formal Definition of Header Formats  . . . . . . . . . . . 45\n  8.3.  Feedback Formats and Options . . . . . . . . . . . . . . . 86\n    8.3.1.  Feedback Formats . . . . . . . . . . . . . . . . . . . 86\n    8.3.2.  Feedback Options . . . . . . . . . . . . . . . . . . . 87\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 89\n10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 89\n11. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 90\n12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 90\n  12.1. Normative References . . . . . . . . . . . . . . . . . . . 90\n  12.2. Informative References . . . . . . . . . . . . . . . . . . 91",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There are several reasons to perform header compression on low- or medium-speed links for TCP/IP traffic, and these have already been discussed in [RFC2507]. Additional considerations that make robustness an important objective for a TCP [RFC0793] compression scheme are introduced in [RFC4163]. Finally, existing TCP/IP header compression schemes ([RFC1144], [RFC2507]) are limited in their handling of the TCP options field and cannot compress the headers of handshaking packets (SYNs and FINs).",
      "ja": "TCP/IPトラフィックの低速または中速リンクでヘッダー圧縮を実行するいくつかの理由があり、これらは[RFC2507]ですでに議論されています。堅牢性をTCP [RFC0793]圧縮スキームの重要な目的とする追加の考慮事項は、[RFC4163]に導入されています。最後に、既存のTCP/IPヘッダー圧縮スキーム（[RFC1144]、[RFC2507]）は、TCPオプションフィールドの取り扱いが制限されており、ハンドシェーブパケットのヘッダー（SynとFins）のヘッダーを圧縮できません。"
    },
    {
      "indent": 3,
      "text": "It is thus desirable for a header compression scheme to be able to handle loss on the link between the compression and decompression points as well as loss before the compression point. The header compression scheme also needs to consider how to efficiently compress short-lived TCP transfers and TCP options, such as SACK ([RFC2018], [RFC2883]) and Timestamps ([RFC1323]).",
      "ja": "したがって、ヘッダー圧縮スキームが圧縮ポイントと減圧ポイントの間のリンクの損失、および圧縮ポイントの前の損失を処理できることが望ましい。ヘッダー圧縮スキームは、SACK（[RFC2018]、[RFC2883]）およびタイムスタンプ（[RFC1323]）などの短命のTCP転送とTCPオプションを効率的に圧縮する方法を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ROHC WG has developed a header compression framework on top of which various profiles can be defined for different protocol sets, or for different compression strategies. This document defines a TCP/IP compression profile for the ROHC framework [RFC4995], compliant with the requirements listed in [RFC4163].",
      "ja": "ROHC WGは、さまざまなプロトコルセット、またはさまざまな圧縮戦略に対して、さまざまなプロファイルを定義できるヘッダー圧縮フレームワークを開発しました。このドキュメントは、[RFC4163]にリストされている要件に準拠したROHCフレームワーク[RFC4995]のTCP/IP圧縮プロファイルを定義します。"
    },
    {
      "indent": 3,
      "text": "Specifically, it describes a header compression scheme for TCP/IP header compression (ROHC-TCP) that is robust against packet loss and that offers enhanced capabilities, in particular for the compression of header fields including TCP options. The profile identifier for TCP/IP compression is 0x0006.",
      "ja": "具体的には、特にTCPオプションを含むヘッダーフィールドの圧縮に対して、パケット損失に対して堅牢で、パケット損失に対して堅牢であるTCP/IPヘッダー圧縮（ROHC-TCP）のヘッダー圧縮スキームについて説明します。TCP/IP圧縮のプロファイル識別子は0x0006です。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "This document reuses some of the terminology found in [RFC4995]. In addition, this document uses or defines the following terms:",
      "ja": "この文書は、[RFC4995]で見つかった用語の一部を再利用します。さらに、このドキュメントは次の用語を使用または定義します。"
    },
    {
      "indent": 3,
      "text": "Base context",
      "ja": "ベースコンテキスト"
    },
    {
      "indent": 6,
      "text": "The base context is a context that has been validated by both the compressor and the decompressor. A base context can be used as the reference when building a new context using replication.",
      "ja": "ベースコンテキストは、コンプレッサーと減圧器の両方によって検証されたコンテキストです。レプリケーションを使用して新しいコンテキストを構築するときに、基本コンテキストを参照として使用できます。"
    },
    {
      "indent": 3,
      "text": "Base Context Identifier (Base CID)",
      "ja": "ベースコンテキスト識別子（ベースCID）"
    },
    {
      "indent": 6,
      "text": "The Base CID is the CID that identifies the base context, from which information needed for context replication can be extracted.",
      "ja": "ベースCIDは、ベースコンテキストを識別するCIDであり、コンテキストの複製に必要な情報を抽出できます。"
    },
    {
      "indent": 3,
      "text": "Base header",
      "ja": "ベースヘッダー"
    },
    {
      "indent": 6,
      "text": "A compressed representation of the innermost IP and TCP headers of the uncompressed packet.",
      "ja": "非圧縮パケットの最も内側のIPおよびTCPヘッダーの圧縮表現。"
    },
    {
      "indent": 3,
      "text": "Chaining of items",
      "ja": "アイテムのチェーン"
    },
    {
      "indent": 6,
      "text": "A chain groups fields based on similar characteristics. ROHC-TCP defines chain items for static, dynamic, replicable, or irregular fields. Chaining is done by appending an item for each header e.g., to the chain in their order of appearance in the uncompressed packet. Chaining is useful to construct compressed headers from an arbitrary number of any of the protocol headers for which ROHC-TCP defines a compressed format.",
      "ja": "同様の特性に基づいたチェーングループフィールド。ROHC-TCPは、静的、動的、複製可能、または不規則なフィールドのチェーンアイテムを定義します。チェーンは、非圧縮パケットに外観の順にチェーンにアイテムを追加することによって行われます。チェーンは、ROHC-TCPが圧縮形式を定義するプロトコルヘッダーの任意の数から圧縮ヘッダーを構築するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Context Replication (CR)",
      "ja": "コンテキストレプリケーション（CR）"
    },
    {
      "indent": 6,
      "text": "Context replication is the mechanism that establishes and initializes a new context based on another existing valid context (a base context). This mechanism is introduced to reduce the overhead of the context establishment procedure, and is especially useful for compression of multiple short-lived TCP connections that may be occurring simultaneously or near-simultaneously.",
      "ja": "コンテキスト複製は、別の既存の有効なコンテキスト（ベースコンテキスト）に基づいて新しいコンテキストを確立および初期化するメカニズムです。このメカニズムは、コンテキスト確立手順のオーバーヘッドを減らすために導入されており、同時またはほぼ同時に発生する可能性のある複数の短命のTCP接続の圧縮に特に役立ちます。"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP packet types",
      "ja": "ROHC-TCPパケットタイプ"
    },
    {
      "indent": 6,
      "text": "ROHC-TCP uses three different packet types: the Initialization and Refresh (IR) packet type, the Context Replication (IR-CR) packet type, and the Compressed packet (CO) type.",
      "ja": "ROHC-TCPは、初期化と更新（IR）パケットタイプ、コンテキストレプリケーション（IR-CR）パケットタイプ、および圧縮パケット（CO）タイプの3つの異なるパケットタイプを使用します。"
    },
    {
      "indent": 3,
      "text": "Short-lived TCP transfer",
      "ja": "短命のTCP転送"
    },
    {
      "indent": 6,
      "text": "Short-lived TCP transfers refer to TCP connections transmitting only small amounts of packets for each single connection.",
      "ja": "短命のTCP転送は、単一の接続ごとに少量のパケットのみを送信するTCP接続を指します。"
    },
    {
      "indent": 0,
      "text": "3. Background",
      "section_title": true,
      "ja": "3. 背景"
    },
    {
      "indent": 3,
      "text": "This section provides some background information on TCP/IP header compression. The fundamentals of general header compression can be found in [RFC4995]. In the following subsections, two existing TCP/IP header compression schemes are first described along with a discussion of their limitations, followed by the classification of TCP/IP header fields. Finally, some of the characteristics of short-lived TCP transfers are summarized.",
      "ja": "このセクションでは、TCP/IPヘッダー圧縮に関する背景情報を提供します。一般的なヘッダー圧縮の基本は[RFC4995]にあります。以下のサブセクションでは、2つの既存のTCP/IPヘッダー圧縮スキームが、最初にそれらの制限の議論とともに説明され、その後TCP/IPヘッダーフィールドの分類が続きます。最後に、短命のTCP転送の特性のいくつかが要約されています。"
    },
    {
      "indent": 3,
      "text": "A behavior analysis of TCP/IP header fields is found in [RFC4413].",
      "ja": "TCP/IPヘッダーフィールドの動作分析は[RFC4413]にあります。"
    },
    {
      "indent": 0,
      "text": "3.1. Existing TCP/IP Header Compression Schemes",
      "section_title": true,
      "ja": "3.1. 既存のTCP/IPヘッダー圧縮スキーム"
    },
    {
      "indent": 3,
      "text": "Compressed TCP (CTCP) and IP Header Compression (IPHC) are two different schemes that may be used to compress TCP/IP headers. Both schemes transmit only the differences from the previous header in order to reduce the size of the TCP/IP header.",
      "ja": "圧縮TCP（CTCP）およびIPヘッダー圧縮（IPHC）は、TCP/IPヘッダーを圧縮するために使用できる2つの異なるスキームです。両方のスキームは、TCP/IPヘッダーのサイズを縮小するために、前のヘッダーとの違いのみを送信します。"
    },
    {
      "indent": 3,
      "text": "The CTCP [RFC1144] compressor detects transport-level retransmissions and sends a header that updates the context completely when they occur. While CTCP works well over reliable links, it is vulnerable when used over less reliable links as even a single packet loss results in loss of synchronization between the compressor and the decompressor. This in turn leads to the TCP receiver discarding all remaining packets in the current window because of a checksum error. This effectively prevents the TCP fast retransmit algorithm [RFC2581] from being triggered. In such a case, the compressor must wait until TCP times out and retransmits a packet to resynchronize.",
      "ja": "CTCP [RFC1144]コンプレッサーは、輸送レベルの再送信を検出し、コンテキストが発生したときに完全に更新するヘッダーを送信します。CTCPは信頼できるリンクでうまく機能しますが、単一のパケット損失でさえコンプレッサーと減圧器間の同期が失われるため、信頼性の低いリンクで使用すると脆弱です。これにより、TCPレシーバーがチェックサムエラーのために現在のウィンドウ内のすべての残りのパケットを破棄します。これにより、TCP高速再送信アルゴリズム[RFC2581]がトリガーされるのを効果的に防ぎます。そのような場合、コンプレッサーはTCPが外出するまで待機し、再同期するためにパケットを再送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "To reduce the errors due to the inconsistent contexts between compressor and decompressor when compressing TCP, IPHC [RFC2507] improves somewhat on CTCP by augmenting the repair mechanism of CTCP with a local repair mechanism called TWICE and with a link-layer mechanism based on negative acknowledgments to request a header that updates the context.",
      "ja": "TCPを圧縮するときにコンプレッサーと減圧装置間の一貫性のないコンテキストによるエラーを減らすために、IPHC [RFC2507]は、CTCPの修復メカニズムを2回呼び出されたローカル修復メカニズムと否定的な承認に基づいたリンクレイヤーメカニズムとともに増強することにより、CTCPで多少改善します。コンテキストを更新するヘッダーをリクエストします。"
    },
    {
      "indent": 3,
      "text": "The TWICE algorithm assumes that only the Sequence Number field of TCP segments is changing with the deltas between consecutive packets being constant in most cases. This assumption is however not always true, especially when TCP Timestamps and SACK options are used.",
      "ja": "2回のアルゴリズムは、TCPセグメントのシーケンス番号フィールドのみが変化していると想定しています。ただし、この仮定は、特にTCPタイムスタンプとサックオプションが使用されている場合、必ずしも真実ではありません。"
    },
    {
      "indent": 3,
      "text": "The full header request mechanism requires a feedback channel that may be unavailable in some circumstances. This channel is used to explicitly request that the next packet be sent with an uncompressed header to allow resynchronization without waiting for a TCP timeout. In addition, this mechanism does not perform well on links with long round-trip times.",
      "ja": "完全なヘッダー要求メカニズムには、状況によっては利用できないフィードバックチャネルが必要です。このチャネルは、TCPタイムアウトを待たずに再同期を許可するために、次のパケットを非圧縮ヘッダーで送信することを明示的に要求するために使用されます。さらに、このメカニズムは、長い往復時間のリンクではうまく機能しません。"
    },
    {
      "indent": 3,
      "text": "Both CTCP and IPHC are also limited in their handling of the TCP options field. For IPHC, any change in the options field (caused by Timestamps or SACK, for example) renders the entire field uncompressible, while for CTCP, such a change in the options field effectively disables TCP/IP header compression altogether.",
      "ja": "CTCPとIPHCの両方は、TCPオプションフィールドの処理にも制限されています。IPHCの場合、オプションフィールドの変更は（たとえば、タイムスタンプやサックによって引き起こされる）フィールド全体を非圧縮性にしますが、CTCPの場合、オプションフィールドの変更はTCP/IPヘッダー圧縮を完全に無効にします。"
    },
    {
      "indent": 3,
      "text": "Finally, existing TCP/IP compression schemes do not compress the headers of handshaking packets (SYNs and FINs). Compressing these packets may greatly improve the overall header compression ratio for the cases where many short-lived TCP connections share the same channel.",
      "ja": "最後に、既存のTCP/IP圧縮スキームでは、ハンドシェーキングパケット（SynとFins）のヘッダーを圧縮しません。これらのパケットを圧縮すると、多くの短命のTCP接続が同じチャネルを共有している場合の全体的なヘッダー圧縮率が大幅に改善される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Classification of TCP/IP Header Fields",
      "section_title": true,
      "ja": "3.2. TCP/IPヘッダーフィールドの分類"
    },
    {
      "indent": 3,
      "text": "Header compression is possible due to the fact that there is much redundancy between header field values within packets, especially between consecutive packets. To utilize these properties for TCP/IP header compression, it is important to understand the change patterns of the various header fields.",
      "ja": "パケット内のヘッダーフィールド値、特に連続したパケット間で多くの冗長性があるという事実により、ヘッダー圧縮が可能です。TCP/IPヘッダー圧縮にこれらのプロパティを利用するには、さまざまなヘッダーフィールドの変更パターンを理解することが重要です。"
    },
    {
      "indent": 3,
      "text": "All fields of the TCP/IP packet header have been classified in detail in [RFC4413]. The main conclusion is that most of the header fields can easily be compressed away since they seldom or never change. The following fields do however require more sophisticated mechanisms:",
      "ja": "TCP/IPパケットヘッダーのすべてのフィールドは、[RFC4413]で詳細に分類されています。主な結論は、ほとんどのヘッダーフィールドは、めったに変わったり、決して変わらないため、簡単に圧縮できるということです。ただし、次のフィールドには、より洗練されたメカニズムが必要です。"
    },
    {
      "indent": 5,
      "text": "- IPv4 Identification (16 bits) - IP-ID - TCP Sequence Number (32 bits) - SN - TCP Acknowledgment Number (32 bits) - TCP Reserved ( 4 bits) - TCP ECN flags ( 2 bits) - ECN - TCP Window (16 bits)",
      "ja": "- IPv4識別（16ビット） -  IP -ID -TCPシーケンス番号（32ビット） -  SN -TCP確認番号（32ビット） -  TCP予約（4ビット） -  TCP ECNフラグ（2ビット） -  ECN -TCPウィンドウ（16ビット）"
    },
    {
      "indent": 5,
      "text": "- TCP Options o Maximum Segment Size (32 bits) - MSS o Window Scale (24 bits) - WSCALE o SACK Permitted (16 bits) o TCP SACK (80, 144, 208, or 272 bits) - SACK o TCP Timestamp (80 bits) - TS",
      "ja": "- TCPオプションo最大セグメントサイズ（32ビット） -  MSS Oウィンドウスケール（24ビット） -  WSCALE O SACK FORDICTED（16ビット）O TCPサック（80、144、208、または272ビット）-Sack O TCPタイムスタンプ（80ビット） -  TS"
    },
    {
      "indent": 3,
      "text": "The assignment of IP-ID values can be done in various ways, usually one of sequential, sequential jump, or random, as described in Section 4.1.3 of [RFC4413]. Some IPv4 stacks do use a sequential assignment when generating IP-ID values but do not transmit the contents of this field in network byte order; instead, it is sent with the two octets reversed. In this case, the compressor can compress the IP-ID field after swapping the bytes. Consequently, the decompressor also swaps the bytes of the IP-ID after decompression to regenerate the original IP-ID. With respect to TCP compression, the analysis in [RFC4413] reveals that there is no obvious candidate among the TCP fields suitable to infer the IP-ID.",
      "ja": "IP-ID値の割り当ては、[RFC4413]のセクション4.1.3で説明されているように、さまざまな方法で行うことができます。一部のIPv4スタックは、IP-ID値を生成するときに順次割り当てを使用しますが、ネットワークバイトの順序でこのフィールドの内容を送信しません。代わりに、2つのオクテットを逆にして送信されます。この場合、コンプレッサーはバイトを交換した後、IP-IDフィールドを圧縮できます。その結果、減圧剤は、減圧後にIP-IDのバイトを交換して、元のIP-IDを再生します。TCP圧縮に関して、[RFC4413]の分析は、IP-IDを推測するのに適したTCPフィールドの間に明らかな候補がないことを明らかにしています。"
    },
    {
      "indent": 3,
      "text": "The change pattern of several TCP fields (Sequence Number, Acknowledgment Number, Window, etc.) is very hard to predict. Of particular importance to a TCP/IP header compression scheme is the understanding of the sequence and acknowledgment numbers [RFC4413].",
      "ja": "いくつかのTCPフィールド（シーケンス番号、確認番号、ウィンドウなど）の変更パターンを予測するのは非常に困難です。TCP/IPヘッダー圧縮スキームにとって特に重要なのは、シーケンスと承認番号の理解です[RFC4413]。"
    },
    {
      "indent": 3,
      "text": "Specifically, the TCP Sequence Number can be anywhere within a range defined by the TCP Window at any point on the path (i.e., wherever a compressor might be deployed). Missing packets or retransmissions can cause the TCP Sequence Number to fluctuate within the limits of this window. The TCP Window also bounds the jumps in acknowledgment number.",
      "ja": "具体的には、TCPシーケンス番号は、パス上の任意のポイント（つまり、コンプレッサーが展開される場合はどこでも）でTCPウィンドウで定義される範囲内のどこにでもあります。パケットや再送信がないと、このウィンドウの制限内でTCPシーケンス番号が変動する可能性があります。また、TCPウィンドウは、ジャンプを確認番号に縛り付けます。"
    },
    {
      "indent": 3,
      "text": "Another important behavior of the TCP/IP header is the dependency between the sequence number and the acknowledgment number. TCP connections can be either near-symmetrical or show a strong asymmetrical bias with respect to the data traffic. In the latter case, the TCP connections mainly have one-way traffic (Web browsing and file downloading, for example). This means that on the forward path (from server to client), only the sequence number is changing while the acknowledgment number remains constant for most packets; on the backward path (from client to server), only the acknowledgment number is changing and the sequence number remains constant for most packets. A compression scheme for TCP should thus have packet formats suitable for either cases, i.e., packet formats that can carry either only sequence number bits, only acknowledgment number bits, or both.",
      "ja": "TCP/IPヘッダーのもう1つの重要な動作は、シーケンス番号と承認番号の間の依存関係です。TCP接続は、ほぼ対称的であるか、データトラフィックに関して強い非対称バイアスを示すことができます。後者の場合、TCP接続には主に一元配置トラフィックがあります（たとえば、Webブラウジングとファイルのダウンロードなど）。これは、（サーバーからクライアントへ）フォワードパスでは、ほとんどのパケットで確認番号が一定のままである一方で、シーケンス番号のみが変更されていることを意味します。後方パス（クライアントからサーバーへ）では、確認番号のみが変更されており、ほとんどのパケットでシーケンス番号は一定のままです。したがって、TCPの圧縮スキームには、いずれかのケースに適したパケット形式、つまり、シーケンス番号ビットのみ、確認番号ビットのみ、またはその両方を搭載できるパケット形式が必要です。"
    },
    {
      "indent": 3,
      "text": "In addition, TCP flows can be short-lived transfers. Short-lived TCP transfers will degrade the performance of header compression schemes that establish a new context by initially sending full headers. Multiple simultaneous or near simultaneous TCP connections may exhibit much similarity in header field values and context values among each other, which would make it possible to reuse information between flows when initializing a new context. A mechanism to this end, context replication [RFC4164], makes the context establishment step faster and more efficient, by replicating part of an existing context to a new flow. The conclusion from [RFC4413] is that part of the IP sub-context, some TCP fields, and some context values can be replicated since they seldom change or change with only a small jump.",
      "ja": "さらに、TCPフローは短命の転送になる可能性があります。短命のTCP転送は、最初に完全なヘッダーを送信することにより、新しいコンテキストを確立するヘッダー圧縮スキームのパフォーマンスを分解します。複数の同時または同時のTCP接続は、ヘッダーフィールド値とコンテキスト値に相互の類似性を示す可能性があり、これにより、新しいコンテキストを初期化するときにフロー間の情報を再利用できるようになります。この目的のメカニズムであるコンテキストレプリケーション[RFC4164]は、既存のコンテキストの一部を新しいフローに複製することにより、コンテキストの確立ステップをより速く、より効率的にします。[RFC4413]の結論は、IPサブコンテキスト、一部のTCPフィールド、および一部のコンテキスト値の一部を、小さなジャンプだけでめったに変更または変更することはないため、複製できることです。"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP also compresses the following headers: IPv6 Destination Options header [RFC2460], IPv6 Routing header [RFC2460], IPv6 Hop-by-Hop Options header [RFC2460], Authentication Header (AH) [RFC4302], NULL-encrypted Encapsulating Security Payload (ESP) header [RFC4303], Generic Routing Encapsulation (GRE) [RFC2784][RFC2890] and the Minimal Encapsulation header (MINE) [RFC2004].",
      "ja": "ROHC-TCPは、次のヘッダーも圧縮します：IPv6宛先オプションヘッダー[RFC2460]、IPv6ルーティングヘッダー[RFC2460]、IPv6ホップバイホップオプションヘッダー[RFC2460]、認証ヘッダー（AH）[RFC4302]、NULL-CENCRITING COMSOLATING SECURITYペイロード（ESP）ヘッダー[RFC4303]、汎用ルーティングカプセル化（GRE）[RFC2784] [RFC2890]、および最小カプセル化ヘッダー（Mine）[RFC2004]。"
    },
    {
      "indent": 3,
      "text": "Headers specific to Mobile IP (for IPv4 or IPv6) do not receive any special treatment in this document, for reasons similar to those described in [RFC3095].",
      "ja": "モバイルIPに固有のヘッダー（IPv4またはIPv6の場合）は、[RFC3095]に記載されている理由と同様の理由により、このドキュメントで特別な処理を受けません。"
    },
    {
      "indent": 0,
      "text": "4. Overview of the TCP/IP Profile (Informative)",
      "section_title": true,
      "ja": "4. TCP/IPプロファイルの概要（情報）"
    },
    {
      "indent": 0,
      "text": "4.1. General Concepts",
      "section_title": true,
      "ja": "4.1. 一般的な概念"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP uses the ROHC protocol as described in [RFC4995]. ROHC-TCP supports context replication as defined in [RFC4164]. Context replication can be particularly useful for short-lived TCP flows [RFC4413].",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Compressor and Decompressor Interactions",
      "section_title": true,
      "ja": "4.2. コンプレッサーと減圧器の相互作用"
    },
    {
      "indent": 0,
      "text": "4.2.1. Compressor Operation",
      "section_title": true,
      "ja": "4.2.1. コンプレッサー操作"
    },
    {
      "indent": 3,
      "text": "Header compression with ROHC can be conceptually characterized as the interaction of a compressor with a decompressor state machine. The compressor's task is to minimally send the information needed to successfully decompress a packet, based on a certain confidence regarding the state of the decompressor context.",
      "ja": "ROHCを使用したヘッダー圧縮は、コンプレッサーと減圧剤状態マシンとの相互作用として概念的に特徴付けます。コンプレッサーのタスクは、減圧器のコンテキストの状態に関する特定の信頼性に基づいて、パケットを正常に解凍するために必要な情報を最小限に送信することです。"
    },
    {
      "indent": 3,
      "text": "For ROHC-TCP compression, the compressor normally starts compression with the initial assumption that the decompressor has no useful information to process the new flow, and sends Initialization and Refresh (IR) packets. Alternatively, the compressor may also support Context Replication (CR) and use IR-CR packets [RFC4164], which attempts to reuse context information related to another flow.",
      "ja": "ROHC-TCP圧縮の場合、コンプレッサーは通常、減圧器に新しいフローを処理するための有用な情報がなく、初期化と更新（IR）パケットを送信するという最初の仮定で圧縮を開始します。あるいは、コンプレッサーはコンテキスト複製（CR）をサポートし、IR-CRパケット[RFC4164]を使用する場合があります。これは、別のフローに関連するコンテキスト情報を再利用しようとします。"
    },
    {
      "indent": 3,
      "text": "The compressor can then adjust the compression level based on its confidence that the decompressor has the necessary information to successfully process the Compressed (CO) packets that it selects. In other words, the task of the compressor is to ensure that the decompressor operates in the state that allows decompression of the most efficient CO packet(s), and to allow the decompressor to move to that state as soon as possible otherwise.",
      "ja": "コンプレッサーは、分解器が選択する圧縮（CO）パケットを正常に処理するために必要な情報を持っているという自信に基づいて、圧縮レベルを調整できます。言い換えれば、コンプレッサーのタスクは、最も効率的なCOパケットの減圧を許可する状態で減圧器が動作することを保証し、それ以外の場合はできるだけ早く減圧器がその状態に移動できるようにすることです。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Decompressor Feedback",
      "section_title": true,
      "ja": "4.2.2. 減圧器のフィードバック"
    },
    {
      "indent": 3,
      "text": "The ROHC-TCP profile can be used in environments with or without feedback capabilities from decompressor to compressor. ROHC-TCP however assumes that if a ROHC feedback channel is available and if this channel is used at least once by the decompressor for a specific ROHC-TCP context, this channel will be used during the entire compression operation for that context. If the feedback channel disappears, compression should be restarted.",
      "ja": "ROHC-TCPプロファイルは、減圧器からコンプレッサーへのフィードバック機能の有無にかかわらず環境で使用できます。ただし、ROHC-TCPは、ROHCフィードバックチャネルが利用可能であり、このチャネルが特定のROHC-TCPコンテキストで減圧器によって少なくとも1回使用される場合、このコンテキストの圧縮操作全体でこのチャネルが使用されると想定しています。フィードバックチャネルが消えた場合、圧縮を再起動する必要があります。"
    },
    {
      "indent": 3,
      "text": "The reception of either positive acknowledgment (ACKs) or negative acknowledgment (NACKs) establishes the feedback channel from the decompressor for the context for which the feedback was received. Once there is an established feedback channel for a specific context, the compressor should make use of this feedback to estimate the current state of the decompressor. This helps in increasing the compression efficiency by providing the information needed for the compressor to achieve the necessary confidence level.",
      "ja": "肯定的な承認（ACK）または否定的な承認（NACKS）のいずれかの受信は、フィードバックが受信されたコンテキストについて、減圧装置からフィードバックチャネルを確立します。特定のコンテキストのために確立されたフィードバックチャネルがあると、コンプレッサーはこのフィードバックを利用して、減圧器の現在の状態を推定する必要があります。これは、コンプレッサーが必要な信頼レベルを達成するために必要な情報を提供することにより、圧縮効率を向上させるのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The ROHC-TCP feedback mechanism is limited in its applicability by the number of (least significant bit (LSB) encoded) master sequence number (MSN) (see Section 6.1.1) bits used in the FEEDBACK-2 format (see Section 8.3). It is not suitable for a decompressor to use feedback altogether where the MSN bits in the feedback could wrap around within one round-trip time. Instead, unidirectional operation -- where the compressor periodically sends larger context-updating packets -- is more appropriate.",
      "ja": "ROHC-TCPフィードバックメカニズムの適用性は、フィードバック2形式で使用されている（セクション6.1.1を参照）マスターシーケンス番号（MSNを参照）のマスターシーケンス番号（セクション6.1.1を参照）の数によって制限されています（セクション8.3を参照）。減圧装置がフィードバックを完全に使用して、フィードバックのMSNビットが1回の往復時間内に包む可能性がある場合には適していません。代わりに、コンプレッサーが定期的により大きなコンテキストアップデートパケットを送信する単方向操作がより適切です。"
    },
    {
      "indent": 0,
      "text": "4.3. Packet Formats and Encoding Methods",
      "section_title": true,
      "ja": "4.3. パケットフォーマットとエンコーディングメソッド"
    },
    {
      "indent": 3,
      "text": "The packet formats and encoding methods used for ROHC-TCP are defined using the formal notation [RFC4997]. The formal notation is used to provide an unambiguous representation of the packet formats and a clear definition of the encoding methods.",
      "ja": "ROHC-TCPに使用されるパケット形式とエンコードメソッドは、正式な表記[RFC4997]を使用して定義されます。正式な表記は、パケット形式の明確な表現とエンコーディング方法の明確な定義を提供するために使用されます。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Compressing TCP Options",
      "section_title": true,
      "ja": "4.3.1. TCPオプションの圧縮"
    },
    {
      "indent": 3,
      "text": "The TCP options in ROHC-TCP are compressed using a list compression encoding that allows option content to be established so that TCP options can be added to the context without having to send all TCP options uncompressed.",
      "ja": "ROHC-TCPのTCPオプションは、すべてのTCPオプションを非圧縮で送信せずにTCPオプションをコンテキストに追加できるように、オプションコンテンツを確立できるようにするリスト圧縮エンコードを使用して圧縮されます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Compressing Extension Headers",
      "section_title": true,
      "ja": "4.3.2. 拡張ヘッダーの圧縮"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP compresses the extension headers as listed in Section 3.2. These headers are treated exactly as other headers and thus have a static chain, a dynamic chain, an irregular chain, and a chain for context replication (Section 6.2).",
      "ja": "ROHC-TCPは、セクション3.2にリストされている拡張ヘッダーを圧縮します。これらのヘッダーは他のヘッダーとして正確に扱われるため、静的チェーン、動的チェーン、不規則なチェーン、およびコンテキスト複製のチェーンがあります（セクション6.2）。"
    },
    {
      "indent": 3,
      "text": "This means that headers appearing in or disappearing from the flow being compressed will lead to changes to the static chain. However, the change pattern of extension headers is not deemed to impair compression efficiency with respect to this design strategy.",
      "ja": "これは、圧縮されているフローに現れたり消滅したりするヘッダーが、静的チェーンの変化につながることを意味します。ただし、拡張ヘッダーの変更パターンは、この設計戦略に関して圧縮効率を損なうとはみなされません。"
    },
    {
      "indent": 0,
      "text": "4.4. Expected Compression Ratios with ROHC-TCP",
      "section_title": true,
      "ja": "4.4. ROHC-TCPによる予想圧縮率"
    },
    {
      "indent": 3,
      "text": "The following table illustrates typical compression ratios that can be expected when using ROHC-TCP and IPHC [RFC2507].",
      "ja": "次の表は、ROHC-TCPおよびIPHC [RFC2507]を使用するときに予想される典型的な圧縮比を示しています。"
    },
    {
      "indent": 3,
      "text": "The figures in the table assume that the compression context has already been properly initialized. For the TS option, the Timestamp is assumed to change with small values. All TCP options include a suitable number of No Operation (NOP) options [RFC0793] for padding and/or alignment. Finally, in the examples for IPv4, a sequential IP-ID behavior is assumed.",
      "ja": "表の図は、圧縮コンテキストがすでに適切に初期化されていると想定しています。TSオプションの場合、タイムスタンプは小さな値で変化すると想定されています。すべてのTCPオプションには、パディングおよび/またはアライメント用の適切な数の操作なし（NOP）オプション[RFC0793]が含まれます。最後に、IPv4の例では、順次IP-IDの動作が想定されています。"
    },
    {
      "indent": 3,
      "text": "                          Total Header Size (octets)\n                           ROHC-TCP          IPHC\n                  Unc.   DATA    ACK      DATA    ACK\nIPv4+TCP+TS       52       8      8        18     18\nIPv4+TCP+TS       52       7      6        16     16   (1)\nIPv6+TCP+TS       72       8      7        18     18\nIPv6+TCP+no opt   60       6      5         6      6\nIPv6+TCP+SACK     80       -     15         -     80   (2)\nIPv6+TCP+SACK     80       -      9         -     26   (3)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(1) The payload size of the data stream is constant. (2) The SACK option appears in the header, but was not present in the previous packet. Two SACK blocks are assumed. (3) The SACK option appears in the header, and was also present in the previous packet (with different SACK blocks). Two SACK blocks are assumed.",
      "ja": "(1) データストリームのペイロードサイズは一定です。（2）サックオプションはヘッダーに表示されますが、前のパケットには存在しませんでした。2つのサックブロックが想定されています。（3）サックオプションはヘッダーに表示され、以前のパケットにも存在していました（異なるサックブロックを使用）。2つのサックブロックが想定されています。"
    },
    {
      "indent": 3,
      "text": "The table below illustrates the typical initial compression ratios for ROHC-TCP and IPHC. The data stream in the example is assumed to be IPv4+TCP, with a sequential behavior for the IP-ID. The following options are assumed present in the SYN packet: TS, MSS, and WSCALE, with an appropriate number of NOP options.",
      "ja": "以下の表は、ROHC-TCPとIPHCの典型的な初期圧縮比を示しています。この例のデータストリームは、IP-IDの連続的な動作を持つIPv4 TCPであると想定されています。Synパケットには、適切な数のNOPオプションがあるTS、MSS、およびWSCALEのSynパケットに存在すると想定されています。"
    },
    {
      "indent": 3,
      "text": " Total Header Size (octets) Unc. ROHC-TCP IPHC 1st packet (SYN) 60 49 60 2nd packet 52 12 52",
      "ja": "総ヘッダーサイズ（オクテット）unc。ROHC-TCP IPHC 1st Packet（syn）60 49 60 2ndパケット52 12 52"
    },
    {
      "indent": 3,
      "text": "The figures in the table assume that the compressor has received an acknowledgment from the decompressor before compressing the second packet, which can be expected when feedback is used in ROHC-TCP. This is because in the most common case, the TCP ACKs are expected to take the same return path, and because TCP does not send more packets until the TCP SYN packet has been acknowledged.",
      "ja": "テーブルの数字は、コンプレッサーが2番目のパケットを圧縮する前に減圧器から確認を受け取ったことを想定しています。これは、最も一般的なケースでは、TCP ACKが同じリターンパスを取得すると予想されており、TCP Synパケットが認められるまでTCPがパケットを送信しないためです。"
    },
    {
      "indent": 0,
      "text": "5. Compressor and Decompressor Logic (Normative)",
      "section_title": true,
      "ja": "5. コンプレッサーと減圧器のロジック（規範）"
    },
    {
      "indent": 0,
      "text": "5.1. Context Initialization",
      "section_title": true,
      "ja": "5.1. コンテキスト初期化"
    },
    {
      "indent": 3,
      "text": "The static context of ROHC-TCP flows can be initialized in either of two ways:",
      "ja": "ROHC-TCPフローの静的コンテキストは、2つの方法のいずれかで初期化できます。"
    },
    {
      "indent": 3,
      "text": "1. By using an IR packet as in Section 7.1, where the profile number is 0x06 and the static chain ends with the static part of a TCP header.",
      "ja": "1. セクション7.1のようにIRパケットを使用することにより、プロファイル番号は0x06で、静的チェーンはTCPヘッダーの静的部分で終わります。"
    },
    {
      "indent": 3,
      "text": "2. By replicating an existing context using the mechanism defined by [RFC4164]. This is done with the IR-CR packet defined in Section 7.2, where the profile number is 0x06.",
      "ja": "2. [RFC4164]で定義されたメカニズムを使用して既存のコンテキストを複製することにより。これは、プロファイル番号が0x06であるセクション7.2で定義されたIR-CRパケットで行われます。"
    },
    {
      "indent": 0,
      "text": "5.2. Compressor Operation",
      "section_title": true,
      "ja": "5.2. コンプレッサー操作"
    },
    {
      "indent": 0,
      "text": "5.2.1. Compression Logic",
      "section_title": true,
      "ja": "5.2.1. 圧縮ロジック"
    },
    {
      "indent": 3,
      "text": "The task of the compressor is to determine what data must be sent when compressing a TCP/IP packet, so that the decompressor can successfully reconstruct the original packet based on its current state. The selection of the type of compressed header to send thus depends on a number of factors, including:",
      "ja": "コンプレッサーのタスクは、TCP/IPパケットを圧縮するときにどのデータを送信する必要があるかを判断し、抑制機が現在の状態に基づいて元のパケットを正常に再構築できるようにすることです。したがって、送信する圧縮ヘッダーのタイプの選択は、次のような多くの要因に依存します。"
    },
    {
      "indent": 3,
      "text": "o The change behavior of header fields in the flow, e.g., conveying the necessary information within the restrictions of the set of available packet formats.",
      "ja": "o フロー内のヘッダーフィールドの変更挙動、たとえば、利用可能なパケット形式のセットの制限内で必要な情報を伝える。"
    },
    {
      "indent": 3,
      "text": "o The compressor's level of confidence regarding decompressor state, e.g., by selecting header formats updating the same type of information for a number of consecutive packets or from the reception of decompressor feedback (ACKs and/or NACKs).",
      "ja": "o たとえば、複数の連続したパケットの同じタイプの情報を更新するヘッダー形式を選択するか、縮小器フィードバック（ACKおよび/またはNACKS）の受信からヘッダー形式を選択することにより、コンプレッサーの信頼レベル。"
    },
    {
      "indent": 3,
      "text": "o Additional robustness required for the flow, e.g., periodic refreshes of static and dynamic information using IR and IR-DYN packets when decompressor feedback is not expected.",
      "ja": "o フローに必要な追加の堅牢性、たとえば、減圧装置のフィードバックが予想されていない場合、IRおよびIR-Dynパケットを使用した静的および動的情報の定期的な更新は予想されません。"
    },
    {
      "indent": 3,
      "text": "The impact of these factors on the compressor's packet type selection is described in more detail in the following subsections.",
      "ja": "コンプレッサーのパケットタイプの選択に対するこれらの要因の影響については、以下のサブセクションで詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "In this section, a \"higher compression state\" means that less data will be sent in compressed packets, i.e., smaller compressed headers are used, while a lower compression state means that a larger amount of data will be sent using larger compressed headers.",
      "ja": "このセクションでは、「より高い圧縮状態」とは、圧縮パケットで送信されるデータが少なくなることを意味します。つまり、圧縮されたヘッダーが小さくなりますが、圧縮状態の低いとは、より大きな圧縮ヘッダーを使用して大量のデータが送信されることを意味します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Optimistic Approach",
      "section_title": true,
      "ja": "5.2.1.1. 楽観的なアプローチ"
    },
    {
      "indent": 3,
      "text": "The optimistic approach is the principle by which a compressor sends the same type of information for a number of packets (consecutively or not) until it is fairly confident that the decompressor has received the information. The optimistic approach is useful to ensure robustness when ROHC-TCP is used to compress packet over lossy links.",
      "ja": "楽観的なアプローチは、コンプレッサーが減圧器が情報を受け取ったとかなり確信するまで、複数のパケット（連続的には）に同じタイプの情報を送信する原則です。楽観的なアプローチは、ROHC-TCPを使用してロスのリンク上でパケットを圧縮するために堅牢性を確保するのに役立ちます。"
    },
    {
      "indent": 3,
      "text": "Therefore, if field X in the uncompressed packet changes value, the compressor MUST use a packet type that contains an encoding for field X until it has gained confidence that the decompressor has received at least one packet containing the new value for X. The compressor SHOULD choose a compressed format with the smallest header that can convey the changes needed to fulfill the optimistic approach condition used.",
      "ja": "したがって、非圧縮パケットのフィールドxが値を変更する場合、コンプレッサーは、xの新しい値をXの新しい値を含む少なくとも1つのパケットを受信したという自信が得られるまで、フィールドXのエンコードを含むパケットタイプを使用する必要があります。使用される楽観的なアプローチ条件を満たすために必要な変更を伝えることができる最小のヘッダーで圧縮形式を選択します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.2. Periodic Context Refreshes",
      "section_title": true,
      "ja": "5.2.1.2. 定期的なコンテキストリフレッシュ"
    },
    {
      "indent": 3,
      "text": "When the optimistic approach is used, there will always be a possibility of decompression failures since the decompressor may not have received sufficient information for correct decompression.",
      "ja": "楽観的なアプローチが使用される場合、減圧装置が正しい減圧のために十分な情報を受け取っていない可能性があるため、減圧障害の可能性が常にあります。"
    },
    {
      "indent": 3,
      "text": "Therefore, until the decompressor has established a feedback channel, the compressor SHOULD periodically move to a lower compression state and send IR and/or IR-DYN packets. These refreshes can be based on timeouts, on the number of compressed packets sent for the flow, or any other strategy specific to the implementation. Once the feedback channel is established, the decompressor MAY stop performing periodic refreshes.",
      "ja": "したがって、減圧器がフィードバックチャネルを確立するまで、コンプレッサーは定期的に低い圧縮状態に移動し、IRおよび/またはIR-Dynパケットを送信する必要があります。これらのリフレッシュは、フローに送信される圧縮パケットの数、または実装に固有のその他の戦略に基づいています。フィードバックチャネルが確立されると、減圧器は定期的な更新の実行を停止する場合があります。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Feedback Logic",
      "section_title": true,
      "ja": "5.2.2. フィードバックロジック"
    },
    {
      "indent": 3,
      "text": "The semantics of feedback messages, acknowledgments (ACKs) and negative acknowledgments (NACKs or STATIC-NACKs), are defined in Section 5.2.4.1 of [RFC4995].",
      "ja": "フィードバックメッセージ、謝辞（ACK）、および否定的な確認（NACKSまたは静的ナック）のセマンティクスは、[RFC4995]のセクション5.2.4.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.2.2.1. Optional Acknowledgments (ACKs)",
      "section_title": true,
      "ja": "5.2.2.1. オプションの謝辞（ACK）"
    },
    {
      "indent": 3,
      "text": "The compressor MAY use acknowledgment feedback (ACKs) to move to a higher compression state.",
      "ja": "コンプレッサーは、確認フィードバック（ACK）を使用して、より高い圧縮状態に移動できます。"
    },
    {
      "indent": 3,
      "text": "Upon reception of an ACK for a context-updating packet, the compressor obtains confidence that the decompressor has received the acknowledged packet and that it has observed changes in the packet flow up to the acknowledged packet.",
      "ja": "コンテキストアップデートパケット用のACKを受信すると、コンプレッサーは、decompressorが認められたパケットを受け取ったという自信を得ており、パケットフローの変化が認められているパケットまでの変化が観察されていることを確認します。"
    },
    {
      "indent": 3,
      "text": "This functionality is optional, so a compressor MUST NOT expect to get such ACKs, even if a feedback channel is available and has been established for that flow.",
      "ja": "この機能はオプションであるため、フィードバックチャネルが利用可能であり、そのフローのために確立されていても、コンプレッサーはそのようなACKを取得することを期待してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.2.2. Negative Acknowledgments (NACKs)",
      "section_title": true,
      "ja": "5.2.2.2. 否定的な謝辞（nacks）"
    },
    {
      "indent": 3,
      "text": "The compressor uses feedback from the decompressor to move to a lower compression state (NACKs).",
      "ja": "コンプレッサーは、減圧器からのフィードバックを使用して、より低い圧縮状態（NACKS）に移動します。"
    },
    {
      "indent": 3,
      "text": "On reception of a NACK feedback, the compressor SHOULD:",
      "ja": "NACKフィードバックを受信すると、コンプレッサーは次のようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o assume that only the static part of the decompressor is valid, and",
      "ja": "o 減圧器の静的部分のみが有効であると仮定し、"
    },
    {
      "indent": 3,
      "text": "o re-send all dynamic information (via an IR or IR-DYN packet) the next time it compresses a packet for the indicated flow",
      "ja": "o 次回指示されたフローのパケットを圧縮するときに、すべての動的情報を（IRまたはIR-Dynパケットを介して）再送信します"
    },
    {
      "indent": 3,
      "text": "unless it has confidence that information sent after the packet being acknowledged already provides a suitable response to the NACK feedback. In addition, the compressor MAY use a CO packet carrying a 7-bit Cyclic Redundancy Check (CRC) if it can determine with enough confidence what information provides a suitable response to the NACK feedback.",
      "ja": "パケットが確認された後に送信された情報が既にNACKフィードバックに対する適切な応答を提供しているという自信がない限り。さらに、コンプレッサーは、NACKフィードバックに対する適切な応答を提供する情報を十分に信頼できる場合に、7ビット環状冗長チェック（CRC）を運ぶCOパケットを使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "On reception of a STATIC-NACK feedback, the compressor SHOULD:",
      "ja": "静的なナックのフィードバックを受信すると、コンプレッサーは次のようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "o assume that the decompressor has no valid context, and",
      "ja": "o 減圧器に有効なコンテキストがないと仮定し、"
    },
    {
      "indent": 3,
      "text": "o re-send all static and all dynamic information (via an IR packet) the next time it compresses a packet for the indicated flow",
      "ja": "o 次に指定されたフローのパケットを圧縮するときに、すべての静的情報とすべての動的情報（IRパケットを介して）を再送信します"
    },
    {
      "indent": 3,
      "text": "unless it has confidence that information sent after the packet that is being acknowledged already provides a suitable response to the STATIC-NACK feedback.",
      "ja": "承認されているパケットの後に送信された情報が既に静的ナックフィードバックに対する適切な応答を提供しているという自信がない限り。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Context Replication",
      "section_title": true,
      "ja": "5.2.3. コンテキストレプリケーション"
    },
    {
      "indent": 3,
      "text": "A compressor MAY support context replication by implementing the additional compression and feedback logic defined in [RFC4164].",
      "ja": "コンプレッサーは、[RFC4164]で定義された追加の圧縮ロジックとフィードバックロジックを実装することにより、コンテキストレプリケーションをサポートできます。"
    },
    {
      "indent": 0,
      "text": "5.3. Decompressor Operation",
      "section_title": true,
      "ja": "5.3. 減圧剤操作"
    },
    {
      "indent": 0,
      "text": "5.3.1. Decompressor States and Logic",
      "section_title": true,
      "ja": "5.3.1. 分解器の状態とロジック"
    },
    {
      "indent": 3,
      "text": "The three states of the decompressor are No Context (NC), Static Context (SC), and Full Context (FC). The decompressor starts in its lowest compression state, the NC state. Successful decompression will always move the decompressor to the FC state. The decompressor state machine normally never leaves the FC state once it has entered this state; only repeated decompression failures will force the decompressor to transit downwards to a lower state.",
      "ja": "減圧器の3つの状態は、コンテキスト（NC）、静的コンテキスト（SC）、および完全コンテキスト（FC）ではありません。減圧装置は、最低の圧縮状態であるNC状態から始まります。減圧が成功すると、減圧装置は常にFC状態に移動します。減圧装置の状態マシンは通常、この状態に入るとFC状態を離れることはありません。繰り返される減圧の障害のみが、減圧装置が下方に下方に移動するように強制されます。"
    },
    {
      "indent": 3,
      "text": "Below is the state machine for the decompressor. Details of the transitions between states and decompression logic are given in the subsections following the figure.",
      "ja": "以下は、減圧器用の状態マシンです。州と減圧ロジック間の遷移の詳細は、図に続くサブセクションに記載されています。"
    },
    {
      "indent": 3,
      "text": "                              Success\n             +-->------>------>------>------>------>--+\n             |                                        |\n No Static   |            No Dynamic        Success   |    Success\n  +-->--+    |             +-->--+      +--->----->---+    +-->--+\n  |     |    |             |     |      |             |    |     |\n  |     v    |             |     v      |             v    |     v\n+-----------------+   +---------------------+   +-------------------+\n| No Context (NC) |   | Static Context (SC) |   | Full Context (FC) |\n+-----------------+   +---------------------+   +-------------------+\n   ^                         |        ^                         |\n   |  Static Context         |        | Context Damage Assumed  |\n   |  Damage Assumed         |        |                         |\n   +-----<------<------<-----+        +-----<------<------<-----+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.1.1. Reconstruction and Verification",
      "section_title": true,
      "ja": "5.3.1.1. 再構築と検証"
    },
    {
      "indent": 3,
      "text": "When decompressing an IR or an IR-DYN packet, the decompressor MUST validate the integrity of the received header using CRC-8 validation [RFC4995]. If validation fails, the packet MUST NOT be delivered to upper layers.",
      "ja": "IRまたはIR-Dynパケットを減圧する場合、減圧器はCRC-8検証[RFC4995]を使用して受信ヘッダーの整合性を検証する必要があります。検証が失敗した場合、パケットを上層に配信してはなりません。"
    },
    {
      "indent": 3,
      "text": "Upon receiving an IR-CR packet, the decompressor MUST perform the actions as specified in [RFC4164].",
      "ja": "IR-CRパケットを受信すると、減圧器は[RFC4164]で指定されているようにアクションを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "When decompressing other packet types (e.g., CO packets), the decompressor MUST validate the outcome of the decompression attempt using CRC verification [RFC4995]. If verification fails, a decompressor implementation MAY attempt corrective or repair measures on the packet, and the result of any attempt MUST be validated using the CRC verification; otherwise, the packet MUST NOT be delivered to upper layers.",
      "ja": "他のパケットタイプ（COパケットなど）を減圧する場合、減圧器はCRC検証[RFC4995]を使用して減圧試行の結果を検証する必要があります。検証が失敗した場合、減圧装置の実装はパケットの修正または修復測定を試みる場合があり、CRC検証を使用して試行の結果を検証する必要があります。それ以外の場合、パケットを上層に配信してはなりません。"
    },
    {
      "indent": 3,
      "text": "When the CRC-8 validation or the CRC verification of the received header is successful, the decompressor SHOULD update its context with the information received in the current header; the decompressor then passes the reconstructed packet to the system's network layer. Otherwise, the decompressor context MUST NOT be updated.",
      "ja": "CRC-8検証または受信ヘッダーのCRC検証が成功した場合、減圧装置は現在のヘッダーで受信した情報とのコンテキストを更新する必要があります。減圧器は、再構成されたパケットをシステムのネットワークレイヤーに渡します。それ以外の場合、減圧器のコンテキストを更新してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the received packet is older than the current reference packet, e.g., based on the master sequence number (MSN) in the compressed packet, the decompressor MAY refrain from updating the context using the information received in the current packet, even if the correctness of its header was successfully verified.",
      "ja": "受信したパケットが、圧縮パケットのマスターシーケンス番号（MSN）に基づいて現在の参照パケット（たとえば、現在のパケットで受信した情報を使用してコンテキストを更新することを控える場合があります。そのヘッダーは正常に検証されました。"
    },
    {
      "indent": 0,
      "text": "5.3.1.2. Detecting Context Damage",
      "section_title": true,
      "ja": "5.3.1.2. コンテキストダメージの検出"
    },
    {
      "indent": 3,
      "text": "All header formats carry a CRC and are context updating. A packet for which the CRC succeeds updates the reference values of all header fields, either explicitly (from the information about a field carried within the compressed header) or implicitly (fields that are inferred from other fields).",
      "ja": "すべてのヘッダー形式にはCRCがあり、コンテキストの更新です。CRCが成功するパケットは、すべてのヘッダーフィールドの参照値を更新します。"
    },
    {
      "indent": 3,
      "text": "The decompressor may assume that some or the entire context is invalid, following one or more failures to validate or verify a header using the CRC. Because the decompressor cannot know the exact reason(s) for a CRC failure or what field caused it, the validity of the context hence does not refer to what exact context entry is deemed valid or not.",
      "ja": "減圧器は、CRCを使用してヘッダーを検証または検証する1つまたは複数の障害に続いて、コンテキスト全体または全体が無効であると想定する場合があります。減圧装置は、CRC障害の正確な理由またはそれを引き起こしたフィールドを知ることができないため、コンテキストの有効性は、正確なコンテキストエントリが有効であるとみなされるかどうかを指しません。"
    },
    {
      "indent": 3,
      "text": "Validity of the context rather relates to the detection of a problem with the context. The decompressor first assumes that the type of information that most likely caused the failure(s) is the state that normally changes for each packet, i.e., context damage of the dynamic part of the context. Upon repeated failures and unsuccessful repairs, the decompressor then assumes that the entire context, including the static part, needs to be repaired, i.e., static context damage.",
      "ja": "コンテキストの妥当性は、むしろ、コンテキストの問題の検出に関連しています。減圧装置は、最初に、障害を引き起こした可能性が最も高い情報のタイプが、通常、各パケットの変化、つまりコンテキストの動的部分のコンテキストダメージが変化する状態であることを前提としています。繰り返し失敗し、修理に失敗すると、減圧装置は、静的部分を含むコンテキスト全体を修復する必要があると仮定します。"
    },
    {
      "indent": 3,
      "text": "Context Damage Detection",
      "ja": "コンテキストダメージの検出"
    },
    {
      "indent": 6,
      "text": "The assumption of context damage means that the decompressor will not attempt decompression of a CO header that carries a 3-bit CRC, and only attempt decompression of IR, IR-DYN, or IR-CR headers or CO headers protected by a CRC-7.",
      "ja": "コンテキスト損傷の仮定は、減圧装置が3ビットCRCを運ぶCOヘッダーの減圧を試みず、IR、IR-Dyn、またはIR-CRヘッダーまたはCRC-7によって保護されたIR-CRヘッダーまたはCOヘッダーの減圧のみを試みることを意味します。。"
    },
    {
      "indent": 3,
      "text": "Static Context Damage Detection",
      "ja": "静的コンテキストダメージの検出"
    },
    {
      "indent": 6,
      "text": "The assumption of static context damage means that the decompressor refrains from attempting decompression of any type of header other than the IR header.",
      "ja": "静的コンテキストダメージの仮定は、減圧器がIRヘッダー以外のあらゆるタイプのヘッダーの減圧を試みることを控えることを意味します。"
    },
    {
      "indent": 3,
      "text": "How these assumptions are made, i.e., how context damage is detected, is open to implementations. It can be based on the residual error rate, where a low error rate makes the decompressor assume damage more often than on a high-rate link.",
      "ja": "これらの仮定がどのように行われるか、つまり、コンテキストダメージがどのように検出されるかは、実装に開かれています。これは、残留エラー率に基づいている場合があります。エラー率が低いと、減圧装置が高額のリンクよりも頻繁に損傷を引き受けるようになります。"
    },
    {
      "indent": 3,
      "text": "The decompressor implements these assumptions by selecting the type of compressed header for which it may attempt decompression. In other words, validity of the context refers to the ability of a decompressor to attempt or not attempt decompression of specific packet types.",
      "ja": "減圧器は、減圧を試みる可能性のある圧縮ヘッダーのタイプを選択することにより、これらの仮定を実装します。言い換えれば、コンテキストの妥当性とは、特定のパケットタイプの減圧を試みるか試行しないか、非回転しない能力を指します。"
    },
    {
      "indent": 0,
      "text": "5.3.1.3. No Context (NC) State",
      "section_title": true,
      "ja": "5.3.1.3. コンテキストなし（NC）状態"
    },
    {
      "indent": 3,
      "text": "Initially, while working in the No Context (NC) state, the decompressor has not yet successfully decompressed a packet.",
      "ja": "当初、NOコンテキスト（NC）状態で作業している間、減圧装置はまだパケットをうまく圧縮していません。"
    },
    {
      "indent": 3,
      "text": "Allowing decompression:",
      "ja": "減圧を許可します："
    },
    {
      "indent": 6,
      "text": "In the NC state, only packets carrying sufficient information on the static fields (IR and IR-CR packets) can be decompressed; otherwise, the packet MUST NOT be decompressed and MUST NOT be delivered to upper layers.",
      "ja": "NC状態では、静的フィールド（IRおよびIR-CRパケット）に十分な情報を運ぶパケットのみを解凍できます。それ以外の場合、パケットを減圧してはならず、上層に配信してはなりません。"
    },
    {
      "indent": 3,
      "text": "Feedback logic:",
      "ja": "フィードバックロジック："
    },
    {
      "indent": 6,
      "text": "In the NC state, the decompressor should send a STATIC-NACK if a packet of a type other than IR is received, or if decompression of an IR packet has failed, subject to the feedback rate limitation as described in Section 5.3.2",
      "ja": "NC状態では、IR以外のタイプのパケットが受信された場合、またはIRパケットの減圧が失敗した場合、減圧剤は静的ナックを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a packet has been validated and decompressed correctly, the decompressor MUST transit to the FC state.",
      "ja": "パケットが検証され、正しく減圧されたら、減圧装置はFC状態に移動する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1.4. Static Context (SC) State",
      "section_title": true,
      "ja": "5.3.1.4. 静的コンテキスト（SC）状態"
    },
    {
      "indent": 3,
      "text": "When the decompressor is in the Static Context (SC) state, only the static part of the decompressor context is valid.",
      "ja": "減圧器が静的コンテキスト（SC）状態にある場合、減圧器コンテキストの静的部分のみが有効です。"
    },
    {
      "indent": 3,
      "text": "From the SC state, the decompressor moves back to the NC state if static context damage is detected.",
      "ja": "SC状態から、静的コンテキストダメージが検出された場合、減圧器はNC状態に戻ります。"
    },
    {
      "indent": 3,
      "text": "Allowing decompression:",
      "ja": "減圧を許可します："
    },
    {
      "indent": 6,
      "text": "In the SC state, packets carrying sufficient information on the dynamic fields covered by an 8-bit CRC (e.g., IR and IR-DYN) or CO packets covered by a 7-bit CRC can be decompressed; otherwise, the packet MUST NOT be decompressed and MUST NOT be delivered to upper layers.",
      "ja": "SC状態では、8ビットCRC（IRおよびIR-DYNなど）で覆われた動的フィールドに関する十分な情報を運ぶパケットまたは7ビットCRCで覆われたCOパケットを解凍できます。それ以外の場合、パケットを減圧してはならず、上層に配信してはなりません。"
    },
    {
      "indent": 3,
      "text": "Feedback logic:",
      "ja": "フィードバックロジック："
    },
    {
      "indent": 6,
      "text": "In the SC state, the decompressor should send a STATIC-NACK if CRC validation of an IR/IR-DYN/IR-CR fails and static context damage is assumed. If any other packet type is received, the decompressor should send a NACK. Both of the above cases are subject to the feedback rate limitation as described in Section 5.3.2.",
      "ja": "SC状態では、IR/IR-DYN/IR-CRのCRC検証が失敗し、静的コンテキストの損傷が想定される場合、減圧剤は静的ナックを送信する必要があります。他のパケットタイプを受信した場合、減圧器はNACKを送信する必要があります。上記の両方のケースは、セクション5.3.2で説明されているように、フィードバック率の制限の対象となります。"
    },
    {
      "indent": 3,
      "text": "Once a packet has been validated and decompressed correctly, the decompressor MUST transit to the FC state.",
      "ja": "パケットが検証され、正しく減圧されたら、減圧装置はFC状態に移動する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.1.5. Full Context (FC) State",
      "section_title": true,
      "ja": "5.3.1.5. 完全なコンテキスト（FC）状態"
    },
    {
      "indent": 3,
      "text": "In the Full Context (FC) state, both the static and the dynamic parts of the decompressor context are valid. From the FC state, the decompressor moves back to the SC state if context damage is detected.",
      "ja": "完全なコンテキスト（FC）状態では、分解器のコンテキストの静的部分と動的部分の両方が有効です。FC状態から、コンピューティングの損傷が検出された場合、減圧装置はSC状態に戻ります。"
    },
    {
      "indent": 3,
      "text": "Allowing decompression:",
      "ja": "減圧を許可します："
    },
    {
      "indent": 6,
      "text": "In the FC state, decompression can be attempted regardless of the type of packet received.",
      "ja": "FC状態では、受信したパケットの種類に関係なく減圧を試みることができます。"
    },
    {
      "indent": 3,
      "text": "Feedback logic:",
      "ja": "フィードバックロジック："
    },
    {
      "indent": 6,
      "text": "In the FC state, the decompressor should send a NACK if the decompression of any packet type fails and context damage is assumed, subject to the feedback rate limitation as described in Section 5.3.2.",
      "ja": "FC状態では、セクション5.3.2で説明されているフィードバックレート制限を条件として、パケットタイプの減圧が失敗し、コンテキストの損傷が想定される場合、減圧器はNACKを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Feedback Logic",
      "section_title": true,
      "ja": "5.3.2. フィードバックロジック"
    },
    {
      "indent": 3,
      "text": "The decompressor MAY send positive feedback (ACKs) to initially establish the feedback channel for a particular flow. Either positive feedback (ACKs) or negative feedback (NACKs) establishes this channel.",
      "ja": "減圧装置は、特定のフローのフィードバックチャネルを最初に確立するために、肯定的なフィードバック（ACK）を送信する場合があります。肯定的なフィードバック（ACK）またはネガティブフィードバック（NACKS）のいずれかがこのチャネルを確立します。"
    },
    {
      "indent": 3,
      "text": "Once the feedback channel is established, the decompressor is REQUIRED to continue sending NACKs or STATIC-NACKs for as long as the context is associated with the same profile, in this case with profile 0x0006, as per the logic defined for each state in Section 5.3.1.",
      "ja": "フィードバックチャネルが確立されると、減圧剤は、セクション5.3の各状態で定義されたロジックに従って、コンテキストが同じプロファイルに関連付けられている限り、コンテキストが同じプロファイルに関連付けられている限り、NACKまたは静的ナックを送信し続ける必要があります。.1。"
    },
    {
      "indent": 3,
      "text": "The decompressor MAY send ACKs upon successful decompression of any packet type. In particular, when a packet carrying a significant context update is correctly decompressed, the decompressor MAY send an ACK.",
      "ja": "減圧装置は、パケットタイプの減圧が成功したときにACKを送信する場合があります。特に、重要なコンテキストアップデートを運ぶパケットが正しく減圧されている場合、減圧装置はACKを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The decompressor should limit the rate at which it sends feedback, for both ACKs and STATIC-NACK/NACKs, and should avoid sending unnecessary duplicates of the same type of feedback message that may be associated to the same event.",
      "ja": "減圧装置は、ACKとStatic-Nack/Nackの両方に対してフィードバックを送信するレートを制限し、同じイベントに関連付けられる可能性のある同じタイプのフィードバックメッセージの不必要な複製を送信しないようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Context Replication",
      "section_title": true,
      "ja": "5.3.3. コンテキストレプリケーション"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP supports context replication; therefore, the decompressor MUST implement the additional decompressor and feedback logic defined in [RFC4164].",
      "ja": "ROHC-TCPはコンテキストの複製をサポートします。したがって、減圧装置は[RFC4164]で定義された追加の減圧装置とフィードバックロジックを実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Encodings in ROHC-TCP (Normative)",
      "section_title": true,
      "ja": "6. ROHC-TCPでのエンコーディング（規範）"
    },
    {
      "indent": 0,
      "text": "6.1. Control Fields in ROHC-TCP",
      "section_title": true,
      "ja": "6.1. ROHC-TCPの制御フィールド"
    },
    {
      "indent": 3,
      "text": "In ROHC-TCP, a number of control fields are used by the decompressor in its interpretation of the format of the packets received from the compressor.",
      "ja": "ROHC-TCPでは、コンプレッサーから受信したパケットの形式の解釈において、減圧器によって多くの制御フィールドが使用されています。"
    },
    {
      "indent": 3,
      "text": "A control field is a field that is transmitted from the compressor to the decompressor, but is not part of the uncompressed header. Values for control fields can be set up in the context of both the compressor and the decompressor. Once established at the decompressor, the values of these fields should be kept until updated by another packet.",
      "ja": "制御フィールドは、コンプレッサーから減圧器に送信されるが、非圧縮ヘッダーの一部ではないフィールドです。制御フィールドの値は、コンプレッサーと減圧器の両方のコンテキストで設定できます。減圧器で確立されたら、これらのフィールドの値は、別のパケットによって更新されるまで保持する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Master Sequence Number (MSN)",
      "section_title": true,
      "ja": "6.1.1. マスターシーケンス番号（MSN）"
    },
    {
      "indent": 3,
      "text": "There is no field in the TCP header that can act as the master sequence number for TCP compression, as explained in [RFC4413], Section 5.6.",
      "ja": "[RFC4413]、セクション5.6で説明されているように、TCP圧縮のマスターシーケンス番号として機能できるTCPヘッダーにはフィールドはありません。"
    },
    {
      "indent": 3,
      "text": "To overcome this problem, ROHC-TCP introduces a control field called the Master Sequence Number (MSN) field. The MSN field is created at the compressor, rather than using one of the fields already present in the uncompressed header. The compressor increments the value of the MSN by one for each packet that it sends.",
      "ja": "この問題を克服するために、ROHC-TCPはマスターシーケンス番号（MSN）フィールドと呼ばれる制御フィールドを導入します。MSNフィールドは、非圧縮ヘッダーに既に存在するフィールドのいずれかを使用するのではなく、コンプレッサーで作成されます。コンプレッサーは、送信するパケットごとにMSNの値を1つずつ増加させます。"
    },
    {
      "indent": 3,
      "text": "The MSN field has the following two functions:",
      "ja": "MSNフィールドには、次の2つの機能があります。"
    },
    {
      "indent": 3,
      "text": "1. Differentiating between packets when sending feedback data.",
      "ja": "1. フィードバックデータを送信するときにパケットを区別します。"
    },
    {
      "indent": 3,
      "text": "2. Inferring the value of incrementing fields such as the IP-ID.",
      "ja": "2. IP-IDなどのフィールドを増分する値を推測します。"
    },
    {
      "indent": 3,
      "text": "The MSN field is present in every packet sent by the compressor. The MSN is LSB encoded within the CO packets, and the 16-bit MSN is sent in full in IR/IR-DYN packets. The decompressor always sends the MSN as part of the feedback information. The compressor can later use the MSN to infer which packet the decompressor is acknowledging.",
      "ja": "MSNフィールドは、コンプレッサーから送信されるすべてのパケットに存在します。MSNはCOパケット内でLSBエンコードされ、16ビットMSNはIR/IR-Dynパケットで完全に送信されます。減圧器は、フィードバック情報の一部として常にMSNを送信します。コンプレッサーは後でMSNを使用して、減圧器が確認しているパケットを推測できます。"
    },
    {
      "indent": 3,
      "text": "When the MSN is initialized, it SHOULD be initialized to a random value. The compressor should only initialize a new MSN for the initial IR or IR-CR packet sent for a CID that corresponds to a context that is not already associated with this profile. In other words, if the compressor reuses the same CID to compress many TCP flows one after the other, the MSN is not reinitialized but rather continues to increment monotonically.",
      "ja": "MSNが初期化されたら、ランダムな値に初期化する必要があります。コンプレッサーは、このプロファイルにまだ関連付けられていないコンテキストに対応するCIDに送信された最初のIRまたはIR-CRパケットの新しいMSNのみを初期化する必要があります。言い換えれば、コンプレッサーが同じCIDを再利用して多くのTCPフローを次々と圧縮する場合、MSNは再活性化されず、単調に増加し続けます。"
    },
    {
      "indent": 3,
      "text": "For context replication, the compressor does not use the MSN of the base context when sending the IR-CR packet, unless the replication process overwrites the base context (i.e., Base CID == CID). Instead, the compressor uses the value of the MSN if it already exists in the ROHC-TCP context being associated with the new flow (CID); otherwise, the MSN is initialized to a new value.",
      "ja": "コンテキストレプリケーションの場合、複製プロセスがベースコンテキスト（つまり、ベースCID == CID）を上書きしない限り、コンプレッサーはIR-CRパケットを送信するときにベースコンテキストのMSNを使用しません。代わりに、コンプレッサーは、新しいフロー（CID）に関連付けられているROHC-TCPコンテキストに既に存在する場合、MSNの値を使用します。それ以外の場合、MSNは新しい値に初期化されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. IP-ID Behavior",
      "section_title": true,
      "ja": "6.1.2. IP-ID動作"
    },
    {
      "indent": 3,
      "text": "The IP-ID field of the IPv4 header can have different change patterns. Conceptually, a compressor monitors changes in the value of the IP-ID field and selects encoding methods and packet formats that are the closest match to the observed change pattern.",
      "ja": "IPv4ヘッダーのIP-IDフィールドには、異なる変更パターンを持つことができます。概念的には、コンプレッサーはIP-IDフィールドの値の変更を監視し、観測された変更パターンに最も近いエンコーディングメソッドとパケット形式を選択します。"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP defines different types of compression techniques for the IP-ID, to provide the flexibility to compress any of the behaviors it may observe for this field: sequential in network byte order (NBO), sequential byte-swapped, random (RND), or constant to a value of zero.",
      "ja": "ROHC-TCPは、IP-IDのさまざまなタイプの圧縮技術を定義し、このフィールドで観察される動作を圧縮する柔軟性を提供します。ネットワークバイト順序（NBO）、シーケンシャルバイトスワップ、ランダム（RND）、またはゼロの値に一定。"
    },
    {
      "indent": 3,
      "text": "The compressor monitors changes in the value of the IP-ID field for a number of packets, to identify which one of the above listed compression alternatives is the closest match to the observed change pattern. The compressor can then select packet formats and encoding methods based on the identified field behavior.",
      "ja": "コンプレッサーは、多くのパケットのIP-IDフィールドの値の変化を監視し、上記の圧縮代替のどれが観測された変化パターンに最も近い一致であるかを識別します。コンプレッサーは、特定されたフィールドの動作に基づいて、パケット形式とエンコードメソッドを選択できます。"
    },
    {
      "indent": 3,
      "text": "If more than one level of IP headers is present, ROHC-TCP can assign a sequential behavior (NBO or byte-swapped) only to the IP-ID of the innermost IP header. This is because only this IP-ID can possibly have a sufficiently close correlation with the MSN (see also Section 6.1.1) to compress it as a sequentially changing field. Therefore, a compressor MUST NOT assign either the sequential (NBO) or the sequential byte-swapped behavior to tunneling headers.",
      "ja": "複数のレベルのIPヘッダーが存在する場合、ROHC-TCPは、最も内側のIPヘッダーのIP-IDにのみ、シーケンシャルな動作（NBOまたはバイトスワップ）を割り当てることができます。これは、このIP-IDのみがMSNと十分に密接な相関を持つ可能性があるためです（セクション6.1.1も参照）。したがって、コンプレッサーは、シーケンシャル（NBO）またはシーケンシャルバイトスワップされた動作を、ヘッダーのトンネリングに割り当ててはなりません。"
    },
    {
      "indent": 3,
      "text": "The control field for the IP-ID behavior determines which set of packet formats will be used. These control fields are also used to determine the contents of the irregular chain item (see Section 6.2) for each IP header.",
      "ja": "IP-IDの動作の制御フィールドは、どのパケット形式のセットが使用されるかを決定します。これらの制御フィールドは、各IPヘッダーの不規則なチェーンアイテムの内容（セクション6.2を参照）を決定するためにも使用されます。"
    },
    {
      "indent": 0,
      "text": "6.1.3. Explicit Congestion Notification (ECN)",
      "section_title": true,
      "ja": "6.1.3. 明示的な混雑通知（ECN）"
    },
    {
      "indent": 3,
      "text": "When ECN [RFC3168] is used once on a flow, the ECN bits could change quite often. ROHC-TCP maintains a control field in the context to indicate whether or not ECN is used. This control field is transmitted in the dynamic chain of the TCP header, and its value can be updated using specific compressed headers carrying a 7-bit CRC.",
      "ja": "ECN [RFC3168]がフローで一度使用されると、ECNビットは非常に頻繁に変化する可能性があります。ROHC-TCPは、ECNが使用されているかどうかを示すために、コンテキストで制御フィールドを維持します。この制御フィールドは、TCPヘッダーの動的チェーンに送信され、7ビットCRCを運ぶ特定の圧縮ヘッダーを使用してその値を更新できます。"
    },
    {
      "indent": 3,
      "text": "When this control field indicates that ECN is being used, items of all IP and TCP headers in the irregular chain include bits used for ECN. To preserve octet-alignment, all of the TCP reserved bits are transmitted and, for outer IP headers, the entire Type of Service/ Traffic Class (TOS/TC) field is included in the irregular chain. When there is only one IP header present in the packet (i.e., no IP tunneling is used), this compression behavior allows the compressor to handle changes in the ECN bits by adding a single octet to the compressed header.",
      "ja": "この制御フィールドがECNが使用されていることを示す場合、不規則なチェーン内のすべてのIPおよびTCPヘッダーのアイテムには、ECNに使用されるビットが含まれます。Octet-Alignmentを保持するために、すべてのTCP予約ビットが送信され、外部IPヘッダーの場合、サービス/トラフィッククラス（TOS/ TC）フィールド全体が不規則なチェーンに含まれています。パケットに1つのIPヘッダーのみが存在する場合（つまり、IPトンネリングは使用されません）、この圧縮挙動により、圧縮ヘッダーに単一のオクテットを追加することにより、コンプレッサーがECNビットの変化を処理できます。"
    },
    {
      "indent": 3,
      "text": "The reason for including the ECN bits of all IP headers in the compressed packet when the control field is set is that the profile needs to efficiently compress flows containing IP tunnels using the \"full-functionality option\" of Section 9.1 of [RFC3168]. For these flows, a change in the ECN bits of an inner IP header is propagated to the outer IP headers. When the \"limited-functionality\" option is used, the compressor will therefore sometimes send one octet more than necessary per tunnel header, but this has been considered a reasonable tradeoff when designing this profile.",
      "ja": "制御フィールドが設定されているときに圧縮パケットにすべてのIPヘッダーのECNビットを含める理由は、[RFC3168]のセクション9.1の「フル機能性オプション」を使用して、IPトンネルを含むフローを効率的に圧縮する必要があるためです。これらのフローでは、内側のIPヘッダーのECNビットの変化が外部IPヘッダーに伝播されます。したがって、「限られた機能」オプションが使用される場合、コンプレッサーはトンネルヘッダーごとに必要以上に1オクテットを送信することがありますが、これはこのプロファイルを設計する際に合理的なトレードオフと見なされます。"
    },
    {
      "indent": 0,
      "text": "6.2. Compressed Header Chains",
      "section_title": true,
      "ja": "6.2. 圧縮ヘッダーチェーン"
    },
    {
      "indent": 3,
      "text": "Some packet types use one or more chains containing sub-header information. The function of a chain is to group fields based on similar characteristics, such as static, dynamic, or irregular fields. Chaining is done by appending an item for each header to the chain in their order of appearance in the uncompressed packet, starting from the fields in the outermost header.",
      "ja": "一部のパケットタイプは、サブヘッダー情報を含む1つ以上のチェーンを使用します。チェーンの機能は、静的、動的、または不規則なフィールドなどの同様の特性に基づいてフィールドをグループ化することです。チェーンは、最も外側のヘッダーのフィールドから始まる、非圧縮パケットに外観の順に、各ヘッダーのアイテムをチェーンに追加することによって行われます。"
    },
    {
      "indent": 3,
      "text": "Chains are defined for all headers compressed by ROHC-TCP, as listed below. Also listed are the names of the encoding methods used to encode each of these protocol headers.",
      "ja": "チェーンは、以下にリストするように、ROHC-TCPによって圧縮されたすべてのヘッダーに対して定義されます。また、これらのプロトコルヘッダーのそれぞれをエンコードするために使用されるエンコードメソッドの名前もリストされています。"
    },
    {
      "indent": 3,
      "text": "o TCP [RFC0793], encoding method: \"tcp\"",
      "ja": "o TCP [RFC0793]、エンコード方法：「TCP」"
    },
    {
      "indent": 3,
      "text": "o IPv4 [RFC0791], encoding method: \"ipv4\"",
      "ja": "o IPv4 [RFC0791]、エンコード方法：「IPv4」"
    },
    {
      "indent": 3,
      "text": "o IPv6 [RFC2460], encoding method: \"ipv6\"",
      "ja": "o IPv6 [RFC2460]、エンコード方法： \"IPv6\""
    },
    {
      "indent": 3,
      "text": "o AH [RFC4302], encoding method: \"ah\"",
      "ja": "o AH [RFC4302]、エンコード方法：「AH」"
    },
    {
      "indent": 3,
      "text": "o GRE [RFC2784][RFC2890], encoding method: \"gre\"",
      "ja": "o GRE [RFC2784] [RFC2890]、エンコーディング方法：「GRE」"
    },
    {
      "indent": 3,
      "text": "o MINE [RFC2004], encoding method: \"mine\"",
      "ja": "o 鉱山[RFC2004]、エンコーディング方法：「鉱山」"
    },
    {
      "indent": 3,
      "text": "o NULL-encrypted ESP [RFC4303], encoding method: \"esp_null\"",
      "ja": "o null-crypted esp [rfc4303]、エンコード方法：「esp_null」"
    },
    {
      "indent": 3,
      "text": "o IPv6 Destination Options header [RFC2460], encoding method: \"ip_dest_opt\"",
      "ja": "o IPv6宛先オプションヘッダー[RFC2460]、エンコーディング方法： \"ip_dest_opt\""
    },
    {
      "indent": 3,
      "text": "o IPv6 Hop-by-Hop Options header [RFC2460], encoding method: \"ip_hop_opt\"",
      "ja": "o IPv6ホップバイホップオプションヘッダー[RFC2460]、エンコーディング方法： \"ip_hop_opt\""
    },
    {
      "indent": 3,
      "text": "o IPv6 Routing header [RFC2460], encoding method: \"ip_rout_opt\"",
      "ja": "o IPv6ルーティングヘッダー[RFC2460]、エンコード方法： \"ip_rout_opt\""
    },
    {
      "indent": 3,
      "text": "Static chain:",
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The static chain consists of one item for each header of the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. In the formal description of the packet formats, this static chain item for each header is a format whose name is suffixed by \"_static\". The static chain is only used in IR packets.",
      "ja": "静的チェーンは、プロトコルヘッダーのチェーンの各ヘッダーの1つのアイテムで構成され、最も外側のIPヘッダーから始まり、TCPヘッダーで終了します。パケット形式の正式な説明では、各ヘッダーのこの静的チェーンアイテムは、「_static」で名前が接尾辞が付けられた形式です。静的チェーンは、IRパケットでのみ使用されます。"
    },
    {
      "indent": 3,
      "text": "Dynamic chain:",
      "ja": "ダイナミックチェーン："
    },
    {
      "indent": 6,
      "text": "The dynamic chain consists of one item for each header of the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. The dynamic chain item for the TCP header also contains a compressed list of TCP options (see Section 6.3). In the formal description of the packet formats, the dynamic chain item for each header type is a format whose name is suffixed by \"_dynamic\". The dynamic chain is used in both IR and IR-DYN packets.",
      "ja": "ダイナミックチェーンは、プロトコルヘッダーのチェーンの各ヘッダーの1つのアイテムで構成され、最も外側のIPヘッダーから始まり、TCPヘッダーで終了します。TCPヘッダーの動的チェーンアイテムには、TCPオプションの圧縮リストも含まれています（セクション6.3を参照）。パケット形式の正式な説明では、各ヘッダータイプの動的チェーンアイテムは、「_dynamic」で名前が接尾辞が付けられた形式です。動的チェーンは、IRとIR-Dynパケットの両方で使用されます。"
    },
    {
      "indent": 3,
      "text": "Replicate chain:",
      "ja": "複製チェーン："
    },
    {
      "indent": 6,
      "text": "The replicate chain consists of one item for each header in the chain of protocol headers to be compressed, starting from the outermost IP header and ending with a TCP header. The replicate chain item for the TCP header also contains a compressed list of TCP options (see Section 6.3). In the formal description of the packet formats, the replicate chain item for each header type is a format whose name is suffixed by \"_replicate\". Header fields that are not present in the replicate chain are replicated from the base context. The replicate chain is only used in the IR-CR packet.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Irregular chain:",
      "ja": "不規則なチェーン："
    },
    {
      "indent": 6,
      "text": "The structure of the irregular chain is analogous to the structure of the static chain. For each compressed packet, the irregular chain is appended at the specified location in the general format of the compressed packets as defined in Section 7.3. This chain also includes the irregular chain items for TCP options as defined in Section 6.3.6, which are placed directly after the irregular chain item of the TCP header, and in the same order as the options appear in the uncompressed packet. In the formal description of the packet formats, the irregular chain item for each header type is a format whose name is suffixed by \"_irregular\". The irregular chain is used only in CO packets.",
      "ja": "不規則な鎖の構造は、静的チェーンの構造に類似しています。圧縮されたパケットごとに、不規則なチェーンは、セクション7.3で定義されているように、圧縮パケットの一般的な形式の指定された場所に追加されます。このチェーンには、セクション6.3.6で定義されているTCPオプションの不規則なチェーンアイテムも含まれています。これは、TCPヘッダーの不規則なチェーンアイテムの直後に配置され、非圧縮パケットにオプションが表示されるのと同じ順序で配置されます。パケット形式の正式な説明では、各ヘッダータイプの不規則なチェーンアイテムは、「_ir Regular」によって名前が接尾辞が付けられた形式です。不規則なチェーンは、COパケットでのみ使用されます。"
    },
    {
      "indent": 6,
      "text": "The format of the irregular chain for the innermost IP header differs from the format of outer IP headers, since this header is part of the compressed base header.",
      "ja": "最も内側のIPヘッダーの不規則なチェーンの形式は、このヘッダーが圧縮ベースヘッダーの一部であるため、外部IPヘッダーの形式とは異なります。"
    },
    {
      "indent": 0,
      "text": "6.3. Compressing TCP Options with List Compression",
      "section_title": true,
      "ja": "6.3. リストコンプレッションを使用してTCPオプションを圧縮します"
    },
    {
      "indent": 3,
      "text": "This section describes in detail how list compression is applied to the TCP options. In the definition of the packet formats for ROHC-TCP, the most frequent TCP options have one encoding method each, as listed in the table below.",
      "ja": "このセクションでは、リスト圧縮がTCPオプションに適用される方法について詳しく説明します。ROHC-TCPのパケット形式の定義では、以下の表にリストされているように、最も頻繁なTCPオプションにはそれぞれ1つのエンコード方法があります。"
    },
    {
      "indent": 11,
      "text": "+-----------------+------------------------+\n|   Option name   |  Encoding method name  |\n+-----------------+------------------------+\n|      NOP        | tcp_opt_nop            |\n|      EOL        | tcp_opt_eol            |\n|      MSS        | tcp_opt_mss            |\n|  WINDOW SCALE   | tcp_opt_wscale         |\n|   TIMESTAMP     | tcp_opt_ts             |\n| SACK-PERMITTED  | tcp_opt_sack_permitted |\n|      SACK       | tcp_opt_sack           |\n| Generic options | tcp_opt_generic        |\n+-----------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each of these encoding methods has an uncompressed format, a format suffixed by \"_list_item\" and a format suffixed by \"_irregular\". In some cases, a single encoding method may have multiple \"_list_item\" or \"_irregular\" formats, in which case bindings inside these formats determine what format is used. This is further described in the following sections.",
      "ja": "これらのエンコードメソッドにはそれぞれ、非圧縮形式、「_list_item」で接尾辞が付いた形式、「_ir Regular」で接尾辞が付いています。場合によっては、単一のエンコーディングメソッドに複数の「_list_item」または「_irレギュラー」形式がある場合があります。この場合、これらの形式内のバインディングは、使用される形式を決定します。これについては、次のセクションでさらに説明します。"
    },
    {
      "indent": 0,
      "text": "6.3.1. List Compression",
      "section_title": true,
      "ja": "6.3.1. リスト理解"
    },
    {
      "indent": 3,
      "text": "The TCP options in the uncompressed packet can be represented as an ordered list, whose order and presence are usually constant between packets. The generic structure of such a list is as follows:",
      "ja": "非圧縮パケットのTCPオプションは、順序付けられたリストとして表すことができ、その順序と存在は通常パケット間で一定です。このようなリストの一般的な構造は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "      +--------+--------+--...--+--------+\nlist: | item 1 | item 2 |       | item n |\n      +--------+--------+--...--+--------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To compress this list, ROHC-TCP uses a list compression scheme, which compresses each of these items individually and combines them into a compressed list.",
      "ja": "このリストを圧縮するために、ROHC-TCPはリスト圧縮スキームを使用します。これは、これらの各アイテムを個別に圧縮し、それらを圧縮リストに結合します。"
    },
    {
      "indent": 3,
      "text": "The basic principles of list-based compression are the following:",
      "ja": "リストベースの圧縮の基本原則は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "1) When a context is being initialized, a complete representation of the compressed list of options is transmitted. All options that have any content are present in the compressed list of items sent by the compressor.",
      "ja": "1) コンテキストが初期化されている場合、オプションの圧縮リストの完全な表現が送信されます。コンテンツを持つすべてのオプションは、コンプレッサーから送信されたアイテムの圧縮リストに存在します。"
    },
    {
      "indent": 3,
      "text": "Then, once the context has been initialized:",
      "ja": "次に、コンテキストが初期化されたら："
    },
    {
      "indent": 6,
      "text": "2) When the structure AND the content of the list are unchanged, no information about the list is sent in compressed headers.",
      "ja": "2) リストの構造と内容が変更されていない場合、リストに関する情報は圧縮ヘッダーに送信されません。"
    },
    {
      "indent": 6,
      "text": "3) When the structure of the list is constant, and when only the content defined within the irregular format for one or more options is changed, no information about the list needs to be sent in compressed base headers; the irregular content is sent as part of the irregular chain, as described in Section 6.3.6.",
      "ja": "3) リストの構造が一定であり、1つ以上のオプションの不規則な形式内で定義されたコンテンツのみが変更された場合、リストに関する情報を圧縮ベースヘッダーで送信する必要はありません。セクション6.3.6で説明されているように、不規則なコンテンツは不規則なチェーンの一部として送信されます。"
    },
    {
      "indent": 6,
      "text": "4) When the structure of the list changes, a compressed list is sent in the compressed base header, including a representation of its structure and order. Content defined within the irregular format of an option can still be sent as part of the irregular chain (as described in Section 6.3.6), provided that the item content is not part of the compressed list.",
      "ja": "4) リストの構造が変更されると、圧縮リストが圧縮ベースヘッダーに送信され、その構造と順序の表現が含まれます。オプションの不規則な形式内で定義されたコンテンツは、アイテムコンテンツが圧縮リストの一部ではない場合、不規則なチェーンの一部として（セクション6.3.6で説明されているように）送信できます。"
    },
    {
      "indent": 0,
      "text": "6.3.2. Table-Based Item Compression",
      "section_title": true,
      "ja": "6.3.2. テーブルベースのアイテム圧縮"
    },
    {
      "indent": 3,
      "text": "The Table-based item compression compresses individual items sent in compressed lists. The compressor assigns a unique identifier, \"Index\", to each item, \"Item\", of a list.",
      "ja": "テーブルベースのアイテム圧縮は、圧縮リストで送信された個々のアイテムを圧縮します。コンプレッサーは、リストの各アイテム「アイテム」に一意の識別子「インデックス」を割り当てます。"
    },
    {
      "indent": 3,
      "text": "Compressor Logic",
      "ja": "コンプレッサーロジック"
    },
    {
      "indent": 6,
      "text": "The compressor conceptually maintains an item table containing all items, indexed using \"Index\". The (Index, Item) pair is sent together in compressed lists until the compressor gains enough confidence that the decompressor has observed the mapping between items and their respective index. Confidence is obtained from the reception of an acknowledgment from the decompressor, or by sending (Index, Item) pairs using the optimistic approach. Once confidence is obtained, the index alone is sent in compressed lists to indicate the presence of the item corresponding to this index.",
      "ja": "コンプレッサーは、「インデックス」を使用してインデックス付けされたすべてのアイテムを含むアイテムテーブルを概念的に維持します。（インデックス、アイテム）ペアは、コンプレッサーが分解器がアイテムとそれぞれのインデックスの間のマッピングを観察するほど十分な信頼性を得るまで、圧縮リストで一緒に送信されます。自信は、減圧器からの謝辞の受信から、または楽観的なアプローチを使用して（インデックス、アイテム）ペアを送信することによって得られます。信頼性が得られると、インデックスのみが圧縮リストに送信され、このインデックスに対応するアイテムの存在を示すことができます。"
    },
    {
      "indent": 6,
      "text": "The compressor may reassign an existing index to a new item, by re-establishing the mapping using the procedure described above.",
      "ja": "コンプレッサーは、上記の手順を使用してマッピングを再確立することにより、既存のインデックスを新しいアイテムに再割り当てすることができます。"
    },
    {
      "indent": 3,
      "text": "Decompressor Logic",
      "ja": "減圧器ロジック"
    },
    {
      "indent": 6,
      "text": "The decompressor conceptually maintains an item table that contains all (Index, Item) pairs received. The item table is updated whenever an (Index, Item) pair is received and decompression is successfully verified using the CRC. The decompressor retrieves the item from the table whenever an index without an accompanying item is received.",
      "ja": "Decompressorは、受信したすべての（インデックス、アイテム）ペアを含むアイテムテーブルを概念的に維持します。アイテムテーブルは、（インデックス、アイテム）ペアが受信され、CRCを使用して減圧が正常に検証されるたびに更新されます。減圧器は、付随するアイテムのないインデックスが受信されるたびに、テーブルからアイテムを取得します。"
    },
    {
      "indent": 6,
      "text": "If an index without an accompanying item is received and the decompressor does not have any context for this index, the header MUST be discarded and a NACK SHOULD be sent.",
      "ja": "付随するアイテムのないインデックスが受信され、減圧器にこのインデックスのコンテキストがない場合、ヘッダーを破棄し、NACKを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.3. Encoding of Compressed Lists",
      "section_title": true,
      "ja": "6.3.3. 圧縮リストのエンコード"
    },
    {
      "indent": 3,
      "text": "Each item present in a compressed list is represented by:",
      "ja": "圧縮リストに存在する各アイテムは、次のように表されます。"
    },
    {
      "indent": 3,
      "text": "o an index into the table of items",
      "ja": "o アイテムのテーブルへのインデックス"
    },
    {
      "indent": 3,
      "text": "o a presence bit indicating if a compressed representation of the item is present in the list",
      "ja": "o アイテムの圧縮表現がリストに存在するかどうかを示す存在ビット"
    },
    {
      "indent": 3,
      "text": "o an item (if the presence bit is set)",
      "ja": "o アイテム（存在ビットが設定されている場合）"
    },
    {
      "indent": 3,
      "text": "Decompression of an item will fail if the presence bit is not set and the decompressor has no entry in the context for that item.",
      "ja": "存在ビットが設定されておらず、減圧器がそのアイテムのコンテキストにエントリがない場合、アイテムの減圧は失敗します。"
    },
    {
      "indent": 3,
      "text": "A compressed list of TCP options uses the following encoding:",
      "ja": "TCPオプションの圧縮リストは、次のエンコードを使用します。"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n| Reserved  |PS |       m       |\n+---+---+---+---+---+---+---+---+\n|        XI_1, ..., XI_m        | m octets, or m * 4 bits\n/                --- --- --- ---/\n|               :    Padding    : if PS = 0 and m is odd\n+---+---+---+---+---+---+---+---+\n|                               |\n/      item_1, ..., item_n      / variable\n|                               |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.",
      "ja": "予約済み：ゼロに設定する必要があります。それ以外の場合、減圧器はパケットを破棄する必要があります。"
    },
    {
      "indent": 6,
      "text": "PS: Indicates size of XI fields:",
      "ja": "PS：XIフィールドのサイズを示します："
    },
    {
      "indent": 9,
      "text": "PS = 0 indicates 4-bit XI fields;",
      "ja": "PS = 0は4ビットXIフィールドを示します。"
    },
    {
      "indent": 9,
      "text": "PS = 1 indicates 8-bit XI fields.",
      "ja": "PS = 1は8ビットXIフィールドを示します。"
    },
    {
      "indent": 6,
      "text": "m: Number of XI item(s) in the compressed list.",
      "ja": "M：圧縮リストのXIアイテムの数。"
    },
    {
      "indent": 6,
      "text": "XI_1, ..., XI_m: m XI items. Each XI represents one TCP option in the uncompressed packet, in the same order as they appear in the uncompressed packet.",
      "ja": "xi_1、...、xi_m：m xiアイテム。各Xiは、非圧縮パケットに表示されていないパケットに1つのTCPオプションを表します。"
    },
    {
      "indent": 9,
      "text": "The format of an XI item is as follows:",
      "ja": "XIアイテムの形式は次のとおりです。"
    },
    {
      "indent": 9,
      "text": "        +---+---+---+---+\nPS = 0: | X |   Index   |\n        +---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "          0   1   2   3   4   5   6   7\n        +---+---+---+---+---+---+---+---+\nPS = 1: | X | Reserved  |     Index     |\n        +---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "X: Indicates whether the item is present in the list:",
      "ja": "X：アイテムがリストに存在するかどうかを示します。"
    },
    {
      "indent": 12,
      "text": "X = 1 indicates that the item corresponding to the Index is sent in the item_1, ..., item_n list;",
      "ja": "x = 1は、インデックスに対応するアイテムがitem_1、...、item_n listで送信されることを示します。"
    },
    {
      "indent": 12,
      "text": "X = 0 indicates that the item corresponding to the Index is not sent and is instead included in the irregular chain.",
      "ja": "x = 0は、インデックスに対応するアイテムが送信されず、代わりに不規則なチェーンに含まれていることを示します。"
    },
    {
      "indent": 9,
      "text": "Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.",
      "ja": "予約済み：ゼロに設定する必要があります。それ以外の場合、減圧器はパケットを破棄する必要があります。"
    },
    {
      "indent": 9,
      "text": "Index: An index into the item table. See Section 6.3.4.",
      "ja": "インデックス：アイテムテーブルへのインデックス。セクション6.3.4を参照してください。"
    },
    {
      "indent": 9,
      "text": "When 4-bit XI items are used, the XI items are placed in octets in the following manner:",
      "ja": "4ビットXIアイテムを使用すると、XIアイテムは次の方法でオクテットに配置されます。"
    },
    {
      "indent": 9,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|     XI_k      |    XI_k + 1   |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Padding: A 4-bit padding field is present when PS = 0 and the number of XIs is odd. The Padding field MUST be set to zero; otherwise, the decompressor MUST discard the packet.",
      "ja": "パディング：PS = 0で、XISの数が奇妙な場合、4ビットパディングフィールドが存在します。パディングフィールドはゼロに設定する必要があります。それ以外の場合、減圧器はパケットを破棄する必要があります。"
    },
    {
      "indent": 6,
      "text": "Item 1, ..., item n: Each item corresponds to an XI with X = 1 in XI 1, ..., XI m. The format of the entries in the item list is described in Section 6.2.",
      "ja": "項目1、...、アイテムN：各アイテムは、xi 1、...、xi mのx = 1のxiに対応します。アイテムリストのエントリの形式については、セクション6.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "6.3.4. Item Table Mappings",
      "section_title": true,
      "ja": "6.3.4. アイテムテーブルマッピング"
    },
    {
      "indent": 3,
      "text": "The item table for TCP options list compression is limited to 16 different items, since it is unlikely that any packet flow will contain a larger number of unique options.",
      "ja": "TCPオプションリストの圧縮のアイテムテーブルは、パケットフローにはより多くの一意のオプションが含まれる可能性が低いため、16種類のアイテムに制限されています。"
    },
    {
      "indent": 3,
      "text": "The mapping between the TCP option type and table indexes are listed in the table below:",
      "ja": "TCPオプションタイプとテーブルインデックスの間のマッピングは、以下の表にリストされています。"
    },
    {
      "indent": 9,
      "text": "+-----------------+---------------+\n|   Option name   |  Table index  |\n+-----------------+---------------+\n|      NOP        |       0       |\n|      EOL        |       1       |\n|      MSS        |       2       |\n|  WINDOW SCALE   |       3       |\n|   TIMESTAMP     |       4       |\n| SACK-PERMITTED  |       5       |\n|      SACK       |       6       |\n| Generic options |      7-15     |\n+-----------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Some TCP options are used more frequently than others. To simplify their compression, a part of the item table is reserved for these option types, as shown on the table above. Both the compressor and the decompressor MUST use these mappings between item and indexes to (de)compress TCP options when using list compression.",
      "ja": "一部のTCPオプションは、他のTCPオプションよりも頻繁に使用されます。圧縮を簡素化するために、上の表に示すように、アイテムテーブルの一部はこれらのオプションタイプ用に予約されています。コンプレッサーと減圧器の両方は、リストコンプレッションを使用するときに（de）indexesの間のこれらのマッピングを（de）圧縮するために使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is expected that the option types for which an index is reserved in the item table will only appear once in a list. However, if an option type is detected twice in the same options list and if both options have a different content, the compressor should compress the second occurrence of the option type by mapping it to a generic compressed option. Otherwise, if the options have the exact same content, the compressor can still use the same table index for both.",
      "ja": "アイテムテーブルにインデックスが予約されているオプションタイプは、リストに1回しか表示されないことが予想されます。ただし、オプションタイプが同じオプションリストで2回検出され、両方のオプションに異なるコンテンツがある場合、コンプレッサーは一般的な圧縮オプションにマッピングすることにより、オプションタイプの2番目の発生を圧縮する必要があります。それ以外の場合、オプションがまったく同じコンテンツを持っている場合、コンプレッサーは両方に同じテーブルインデックスを使用できます。"
    },
    {
      "indent": 3,
      "text": "The NOP option",
      "ja": "NOPオプション"
    },
    {
      "indent": 6,
      "text": "The NOP option can appear more than once in the list. However, since its value is always the same, no context information needs to be transmitted. Multiple NOP options can thus be mapped to the same index. Since the NOP option does not have any content when compressed as a \"_list_item\", it will never be present in the item list. For consistency, the compressor should still establish an entry in the list by setting the presence bit, as done for the other type of options.",
      "ja": "NOPオプションは、リストに複数回表示できます。ただし、その値は常に同じであるため、コンテキスト情報を送信する必要はありません。したがって、複数のNOPオプションを同じインデックスにマッピングできます。NOPオプションには、「_list_item」として圧縮されたときにコンテンツがないため、アイテムリストには存在しません。一貫性のために、コンプレッサーは、他のタイプのオプションに対して行われたように、存在ビットを設定することにより、リストのエントリを確立する必要があります。"
    },
    {
      "indent": 6,
      "text": "List compression always preserves the original order of each item in the decompressed list, whether or not the item is present in the compressed \"_list_item\" or if multiple items of the same type can be mapped to the same index, as for the NOP option.",
      "ja": "リスト圧縮は、項目が圧縮された「_list_item」に存在するかどうか、または同じタイプの複数のアイテムを同じインデックスにマッピングできるかどうかにかかわらず、減圧リスト内の各アイテムの元の注文を常に保持します。"
    },
    {
      "indent": 3,
      "text": "The EOL option",
      "ja": "EOLオプション"
    },
    {
      "indent": 6,
      "text": "The size of the compressed format for the EOL option can be larger than one octet, and it is defined so that it includes the option padding. This is because the EOL should terminate the parsing of the options, but it can also be followed by padding octets that all have the value zero.",
      "ja": "EOLオプションの圧縮形式のサイズは1オクテットより大きくなり、オプションパディングが含まれるように定義されています。これは、EOLがオプションの解析を終了する必要があるためですが、すべてがゼロを持つオクテットをパディングすることもできます。"
    },
    {
      "indent": 3,
      "text": "The Generic option",
      "ja": "一般的なオプション"
    },
    {
      "indent": 6,
      "text": "The Generic option can be used to compress any type of TCP option that does not have a reserved index in the item table.",
      "ja": "一般的なオプションは、アイテムテーブルに予約されたインデックスがないあらゆるタイプのTCPオプションを圧縮するために使用できます。"
    },
    {
      "indent": 0,
      "text": "6.3.5. Compressed Lists in Dynamic Chain",
      "section_title": true,
      "ja": "6.3.5. 動的チェーンの圧縮リスト"
    },
    {
      "indent": 3,
      "text": "A compressed list for TCP options that is part of the dynamic chain (e.g., in IR or IR-DYN packets) must have all its list items present, i.e., all X-bits in the XI list MUST be set.",
      "ja": "動的チェーンの一部であるTCPオプションの圧縮リスト（IRまたはIR-Dynパケットなど）には、すべてのリスト項目が存在する必要があります。つまり、XIリスト内のすべてのXビットを設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.6. Irregular Chain Items for TCP Options",
      "section_title": true,
      "ja": "6.3.6. TCPオプションの不規則なチェーンアイテム"
    },
    {
      "indent": 3,
      "text": "The \"_list_item\" represents the option inside the compressed item list, and the \"_irregular\" format is used for the option fields that are expected to change with each packet. When an item of the specified type is present in the current context, these irregular fields are present in each compressed packet, as part of the irregular chain. Since many of the TCP option types are not expected to change for the duration of a flow, many of the \"_irregular\" formats are empty.",
      "ja": "「_list_item」は、圧縮されたアイテムリスト内のオプションを表し、各パケットで変更されると予想されるオプションフィールドに「_ir Regular」形式が使用されます。指定されたタイプのアイテムが現在のコンテキストに存在する場合、これらの不規則なフィールドは、不規則なチェーンの一部として、各圧縮パケットに存在します。TCPオプションタイプの多くはフローの期間中に変更されるとは予想されていないため、「_irレギュラー」形式の多くは空です。"
    },
    {
      "indent": 3,
      "text": "The irregular chain for TCP options is structured analogously to the structure of the TCP options in the uncompressed packet. If a compressed list is present in the compressed packet, then the irregular chain for TCP options must not contain irregular items for the list items that are transmitted inside the compressed list (i.e., items in the list that have the X-bit set in its XI). The items that are not present in the compressed list, but are present in the uncompressed list, must have their respective irregular items present in the irregular chain.",
      "ja": "TCPオプションの不規則なチェーンは、非圧縮パケットのTCPオプションの構造と同様に構成されています。圧縮リストが圧縮パケットに存在する場合、TCPオプションの不規則なチェーンには、圧縮リスト内に送信されるリスト項目の不規則なアイテムが含まれていてはなりません（つまり、Xビットが設定されているリストのアイテムがあります。xi）。圧縮リストには存在しないが、圧縮されていないリストに存在するアイテムには、不規則なチェーンにそれぞれの不規則なアイテムが存在する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3.7. Replication of TCP Options",
      "section_title": true,
      "ja": "6.3.7. TCPオプションの複製"
    },
    {
      "indent": 3,
      "text": "The entire table of TCP options items is always replicated when using the IR-CR packet. In the IR-CR packet, the list of options for the new flow is also transmitted as a compressed list in the IR-CR packet.",
      "ja": "IR-CRパケットを使用すると、TCPオプションアイテムのテーブル全体が常に複製されます。IR-CRパケットでは、新しいフローのオプションのリストもIR-CRパケットの圧縮リストとして送信されます。"
    },
    {
      "indent": 0,
      "text": "6.4. Profile-Specific Encoding Methods",
      "section_title": true,
      "ja": "6.4. プロファイル固有のエンコーディング方法"
    },
    {
      "indent": 3,
      "text": "This section defines encoding methods that are specific to this profile. These methods are used in the formal definition of the packet formats in Section 8.",
      "ja": "このセクションでは、このプロファイルに固有のエンコードメソッドを定義します。これらの方法は、セクション8のパケット形式の正式な定義で使用されます。"
    },
    {
      "indent": 0,
      "text": "6.4.1. inferred_ip_v4_header_checksum",
      "section_title": true,
      "ja": "6.4.1. vidred_ip_v4_header_checksum"
    },
    {
      "indent": 3,
      "text": "This encoding method compresses the Header Checksum field of the IPv4 header. This checksum is defined in [RFC0791] as follows:",
      "ja": "このエンコードメソッドは、IPv4ヘッダーのヘッダーチェックサムフィールドを圧縮します。このチェックサムは、次のように[RFC0791]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Header Checksum: 16 bits",
      "ja": "ヘッダーチェックサム：16ビット"
    },
    {
      "indent": 9,
      "text": "A checksum on the header only. Since some header fields change (e.g., time to live), this is recomputed and verified at each point that the internet header is processed.",
      "ja": "ヘッダーのみのチェックサム。一部のヘッダーフィールドが変更されるため（例：ライブまで）、これはインターネットヘッダーが処理される各ポイントで再計算および検証されます。"
    },
    {
      "indent": 6,
      "text": "The checksum algorithm is:",
      "ja": "チェックサムアルゴリズムは次のとおりです。"
    },
    {
      "indent": 9,
      "text": "The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header. For purposes of computing the checksum, the value of the checksum field is zero.",
      "ja": "チェックサムフィールドは、ヘッダー内の16ビットすべての単語すべての補完合計の16ビットの補完です。チェックサムを計算するために、チェックサムフィールドの値はゼロです。"
    },
    {
      "indent": 3,
      "text": "As described above, the header checksum protects individual hops from processing a corrupted header. When almost all IP header information is compressed away, and when decompression is verified by a CRC computed over the original header for every compressed packet, there is no point in having this additional checksum; instead, it can be recomputed at the decompressor side.",
      "ja": "上記のように、ヘッダーチェックサムは、個々のホップが破損したヘッダーの処理から保護します。ほぼすべてのIPヘッダー情報が圧縮され、圧縮パケットごとに元のヘッダーを介して計算されたCRCによって減圧が検証された場合、この追加チェックサムを持つことには意味がありません。代わりに、減圧器側で再計算することができます。"
    },
    {
      "indent": 3,
      "text": "The \"inferred_ip_v4_header_checksum\" encoding method thus compresses the IPv4 header checksum down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field using the computation above.",
      "ja": "したがって、「vedred_ip_v4_header_checksum」エンコードメソッドは、IPv4ヘッダーチェックサムをゼロビットのサイズに圧縮します。このエンコード方法を使用して、減圧器は上記の計算を使用してこのフィールドの値を推進します。"
    },
    {
      "indent": 3,
      "text": "This encoding method implicitly assumes that the compressor will not process a corrupted header; otherwise, it cannot guarantee that the checksum as recomputed by the decompressor will be bitwise identical to its original value before compression.",
      "ja": "このエンコード方法は、コンプレッサーが破損したヘッダーを処理しないことを暗黙的に想定しています。それ以外の場合、減圧装置によって再計算されたチェックサムが、圧縮前の元の値と少し同一になることを保証することはできません。"
    },
    {
      "indent": 0,
      "text": "6.4.2. inferred_mine_header_checksum",
      "section_title": true,
      "ja": "6.4.2. vedred_mine_header_checksum"
    },
    {
      "indent": 3,
      "text": "This encoding method compresses the minimal encapsulation header checksum. This checksum is defined in [RFC2004] as follows:",
      "ja": "このエンコードメソッドは、最小限のカプセル化ヘッダーチェックサムを圧縮します。このチェックサムは、次のように[RFC2004]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Header Checksum",
      "ja": "ヘッダーチェックサム"
    },
    {
      "indent": 9,
      "text": "The 16-bit one's complement of the one's complement sum of all 16-bit words in the minimal forwarding header. For purposes of computing the checksum, the value of the checksum field is 0. The IP header and IP payload (after the minimal forwarding header) are not included in this checksum computation.",
      "ja": "最小転送ヘッダーのすべての16ビット語の補完合計を16ビットの補完。チェックサムを計算するために、チェックサムフィールドの値は0です。IPヘッダーとIPペイロード（最小転送ヘッダーの後）は、このチェックサム計算に含まれていません。"
    },
    {
      "indent": 3,
      "text": "The \"inferred_mine_header_checksum\" encoding method compresses the minimal encapsulation header checksum down to a size of zero bits, i.e., no bits are transmitted in compressed headers for this field. Using this encoding method, the decompressor infers the value of this field using the above computation.",
      "ja": "「bedred_mine_header_checksum」エンコードメソッドは、最小限のカプセル化ヘッダーチェックサムをゼロビットのサイズに圧縮します。つまり、このフィールドの圧縮ヘッダーにビットは送信されません。このエンコーディング方法を使用して、減圧器は上記の計算を使用してこのフィールドの値を推進します。"
    },
    {
      "indent": 3,
      "text": "The motivations and the assumptions for inferring this checksum are similar to the ones explained above in Section 6.4.1.",
      "ja": "このチェックサムを推測する動機と仮定は、セクション6.4.1で上記のものと似ています。"
    },
    {
      "indent": 0,
      "text": "6.4.3. inferred_ip_v4_length",
      "section_title": true,
      "ja": "6.4.3. vidred_ip_v4_length"
    },
    {
      "indent": 3,
      "text": "This encoding method compresses the Total Length field of the IPv4 header. The Total Length field of the IPv4 header is defined in [RFC0791] as follows:",
      "ja": "このエンコードメソッドは、IPv4ヘッダーの総長さフィールドを圧縮します。IPv4ヘッダーの総長さフィールドは、次のように[RFC0791]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Total Length: 16 bits",
      "ja": "全長：16ビット"
    },
    {
      "indent": 9,
      "text": "Total Length is the length of the datagram, measured in octets, including internet header and data. This field allows the length of a datagram to be up to 65,535 octets.",
      "ja": "全長は、インターネットヘッダーやデータを含むオクテットで測定されたデータグラムの長さです。このフィールドにより、データグラムの長さを最大65,535オクテットにすることができます。"
    },
    {
      "indent": 3,
      "text": "The \"inferred_ip_v4_length\" encoding method compresses the IPv4 header checksum down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.",
      "ja": "「amedred_ip_v4_length」エンコードメソッドは、IPv4ヘッダーチェックサムをゼロビットのサイズに圧縮します。このエンコード方法を使用して、減圧装置は、減圧後のパケット全体の長さをオクテットでカウントすることにより、このフィールドの値を推進します。"
    },
    {
      "indent": 0,
      "text": "6.4.4. inferred_ip_v6_length",
      "section_title": true,
      "ja": "6.4.4. vidred_ip_v6_length"
    },
    {
      "indent": 3,
      "text": "This encoding method compresses the Payload Length field of the IPv6 header. This length field is defined in [RFC2460] as follows:",
      "ja": "このエンコードメソッドは、IPv6ヘッダーのペイロード長フィールドを圧縮します。この長さフィールドは、次のように[RFC2460]で定義されています。"
    },
    {
      "indent": 6,
      "text": "Payload Length: 16-bit unsigned integer",
      "ja": "ペイロード長：16ビットの署名整数"
    },
    {
      "indent": 9,
      "text": "Length of the IPv6 payload, i.e., the rest of the packet following this IPv6 header, in octets. (Note that any extension headers present are considered part of the payload, i.e., included in the length count.)",
      "ja": "IPv6ペイロードの長さ、つまり、オクテットのこのIPv6ヘッダーに続くパケットの残りの部分。（存在するエクステンションヘッダーは、ペイロードの一部、つまり長さ数に含まれることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "The \"inferred_ip_v6_length\" encoding method compresses the Payload Length field of the IPv6 header down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.",
      "ja": "「推測_ip_v6_length」エンコードメソッドは、IPv6ヘッダーのペイロード長フィールドをゼロビットのサイズに圧縮します。このエンコード方法を使用して、減圧装置は、減圧後のパケット全体の長さをオクテットでカウントすることにより、このフィールドの値を推進します。"
    },
    {
      "indent": 0,
      "text": "6.4.5. inferred_offset",
      "section_title": true,
      "ja": "6.4.5. vidred_offset"
    },
    {
      "indent": 3,
      "text": "This encoding method compresses the data offset field of the TCP header.",
      "ja": "このエンコードメソッドは、TCPヘッダーのデータオフセットフィールドを圧縮します。"
    },
    {
      "indent": 3,
      "text": "The \"inferred_offset\" encoding method is used on the Data Offset field of the TCP header. This field is defined in [RFC0793] as:",
      "ja": "「推測_offset」エンコードメソッドは、TCPヘッダーのデータオフセットフィールドで使用されます。このフィールドは[RFC0793]で次のように定義されています。"
    },
    {
      "indent": 6,
      "text": "Data Offset: 4 bits",
      "ja": "データオフセット：4ビット"
    },
    {
      "indent": 9,
      "text": "The number of 32 bit words in the TCP Header. This indicates where the data begins. The TCP header (even one including options) is an integral number of 32 bits long.",
      "ja": "TCPヘッダーの32ビットワードの数。これは、データがどこから始まるかを示します。TCPヘッダー（オプションを含むものも）は、32ビットの積分数です。"
    },
    {
      "indent": 3,
      "text": "The \"inferred_offset\" encoding method compresses the Data Offset field of the TCP header down to a size of zero bits. Using this encoding method, the decompressor infers the value of this field by first decompressing the TCP options list, and by then setting:",
      "ja": "「推測_offset」エンコードメソッドは、TCPヘッダーのデータオフセットフィールドをゼロビットのサイズに圧縮します。このエンコーディング方法を使用して、減圧器は、最初にTCPオプションリストを減圧することにより、このフィールドの値を推測し、次のように設定します。"
    },
    {
      "indent": 14,
      "text": "data offset = (options length / 4) + 5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The equation above uses integer arithmetic.",
      "ja": "上記の方程式は、整数算術を使用します。"
    },
    {
      "indent": 0,
      "text": "6.4.6. baseheader_extension_headers",
      "section_title": true,
      "ja": "6.4.6. baseheader_extension_headers"
    },
    {
      "indent": 3,
      "text": "In CO packets (see Section 7.3), the innermost IP header and the TCP header are combined to create a compressed base header. In some cases, the IP header will have a number of extension headers between itself and the TCP header.",
      "ja": "COパケット（セクション7.3を参照）では、最も内側のIPヘッダーとTCPヘッダーを組み合わせて、圧縮ベースヘッダーを作成します。場合によっては、IPヘッダーには、それ自体とTCPヘッダーの間に多くの拡張ヘッダーがあります。"
    },
    {
      "indent": 3,
      "text": "To remain formally correct, the base header must define some representation of these extension headers, which is what this encoding method is used for. This encoding method skips over all the extension headers and does not encode any of the fields. Changed fields in these headers are encoded in the irregular chain.",
      "ja": "正式に正しいままであるため、ベースヘッダーはこれらの拡張ヘッダーのいくつかの表現を定義する必要があります。これは、このエンコード方法が使用されるものです。このエンコードメソッドは、すべての拡張機能ヘッダーをスキップし、フィールドのいずれもエンコードしません。これらのヘッダーの変更されたフィールドは、不規則なチェーンにエンコードされています。"
    },
    {
      "indent": 0,
      "text": "6.4.7. baseheader_outer_headers",
      "section_title": true,
      "ja": "6.4.7. baseheader_outer_headers"
    },
    {
      "indent": 3,
      "text": "This encoding method, as well as the baseheader_extension_headers encoding method described above, is needed for the specification to remain formally correct. It is used in CO packets (see Section 7.3) to describe tunneling IP headers and their respective extension headers (i.e., all headers located before the innermost IP header).",
      "ja": "このエンコード方法と、上記のBaseHeader_Extension_Headersエンコードメソッドは、仕様が正式に正しいままであるために必要です。COパケット（セクション7.3を参照）で使用され、トンネルIPヘッダーとそれぞれの拡張ヘッダー（つまり、最も内側のIPヘッダーの前にあるすべてのヘッダー）を説明します。"
    },
    {
      "indent": 3,
      "text": "This encoding method skips over all the fields in these headers and does not perform any encoding. Changed fields in outer headers are instead handled by the irregular chain.",
      "ja": "このエンコードメソッドは、これらのヘッダーのすべてのフィールドをスキップし、エンコードを実行しません。代わりに、外側のヘッダーの変更されたフィールドは、不規則なチェーンによって処理されます。"
    },
    {
      "indent": 0,
      "text": "6.4.8. Scaled Encoding of Fields",
      "section_title": true,
      "ja": "6.4.8. フィールドのスケーリングされたエンコード"
    },
    {
      "indent": 3,
      "text": "Some header fields will exhibit a change pattern where the field increases by a constant value or by multiples of the same value.",
      "ja": "一部のヘッダーフィールドは、フィールドが一定の値または同じ値の倍数によって増加する変更パターンを示します。"
    },
    {
      "indent": 3,
      "text": "Examples of fields that may have this behavior are the TCP Sequence Number and the TCP Acknowledgment Number. For such fields, ROHC-TCP provides the means to downscale the field value before applying LSB encoding, which allows the compressor to transmit fewer bits.",
      "ja": "この動作を持つ可能性のあるフィールドの例は、TCPシーケンス番号とTCP確認番号です。このようなフィールドの場合、ROHC-TCPは、LSBエンコードを適用する前にフィールド値をダウンスケールする手段を提供します。これにより、コンプレッサーがより少ないビットを送信できます。"
    },
    {
      "indent": 3,
      "text": "To be able to use scaled encoding, the field is required to fulfill the following equation:",
      "ja": "スケーリングされたエンコードを使用できるようにするには、次の方程式を満たすためにフィールドが必要です。"
    },
    {
      "indent": 8,
      "text": "unscaled_value = scaling_factor * scaled_value + residue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To use the scaled encoding, the compressor must be confident that the decompressor has established values for the \"residue\" and the \"scaling_factor\", so that it can correctly decompress the field when only an LSB-encoded \"scaled_value\" is present in the compressed packet.",
      "ja": "スケーリングされたエンコーディングを使用するには、コンプレッサーは、減圧器が「残基」と「scaling_factor」の値を確立していることを確信している必要があります。そのため、LSBエンコードされた「scaled_value」のみが圧縮されたときにフィールドを正しく減圧できます。パケット。"
    },
    {
      "indent": 3,
      "text": "Once the compressor is confident that the value of the scaling_factor and the value of the residue have been established in the decompressor, the compressor may send compressed packets using the scaled representation of the field. The compressor MUST NOT use scaled encoding with the value of the scaling_factor set to zero.",
      "ja": "コンプレッサーが、scaling_factorの値と減圧器に残基の値が確立されると確信すると、コンプレッサーはフィールドのスケーリングされた表現を使用して圧縮パケットを送信する場合があります。コンプレッサーは、SCALING_FACTORセットの値をゼロにしてスケーリングされたエンコードを使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "If the compressor detects that the value of the residue has changed, or if the compressor uses a different value for the scaling factor, it MUST NOT use scaled encoding until it is confident that the decompressor has received the new value(s) of these fields.",
      "ja": "コンプレッサーが残基の値が変化したことを検出する場合、またはコンプレッサーがスケーリング係数に異なる値を使用している場合、減圧器がこれらのフィールドの新しい値を受信すると確信するまでスケーリングされたエンコードを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "When the unscaled value of the field wraps around, the value of the residue is likely to change, even if the scaling_factor remains constant. In such a case, the compressor must act in the same way as for any other change in the residue.",
      "ja": "scaling_factorが一定のままであっても、フィールドの非衝突値が包まれている場合、残基の値は変化する可能性があります。そのような場合、コンプレッサーは残基の他の変化と同じように作用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following subsections describe how the scaled encoding is applied to specific fields in ROHC-TCP, in particular, how the scaling_factor and residue values are established for the different fields.",
      "ja": "以下のサブセクションでは、スケーリングされたエンコードがROHC-TCPの特定のフィールドに適用される方法、特に異なるフィールドに対してScaling_Factor値と残基値がどのように確立されるかについて説明します。"
    },
    {
      "indent": 0,
      "text": "6.4.8.1. Scaled TCP Sequence Number Encoding",
      "section_title": true,
      "ja": "6.4.8.1. スケーリングされたTCPシーケンス番号エンコーディング"
    },
    {
      "indent": 3,
      "text": "For some TCP flows, such as data transfers, the payload size will be constant over periods of time. For such flows, the TCP Sequence Number is bound to increase by multiples of the payload size between packets, which means that this field can be a suitable target for scaled encoding. When using this encoding, the payload size will be used as the scaling factor (i.e., as the value for scaling_factor) of this encoding. This means that the scaling factor does not need to be explicitly transmitted, but is instead inferred from the length of the payload in the compressed packet.",
      "ja": "データ転送などの一部のTCPフローの場合、ペイロードサイズは期間にわたって一定になります。このようなフローの場合、TCPシーケンス番号は、パケット間のペイロードサイズの倍数によって増加するようになります。つまり、このフィールドはスケーリングされたエンコードに適したターゲットになります。このエンコードを使用する場合、ペイロードサイズは、このエンコードのスケーリング係数（つまり、Scaling_Factorの値として）として使用されます。これは、スケーリング係数を明示的に送信する必要はないが、その代わりに圧縮パケットのペイロードの長さから推測されることを意味します。"
    },
    {
      "indent": 3,
      "text": "Establishing scaling_factor:",
      "ja": "Scaling_Factorの確立："
    },
    {
      "indent": 6,
      "text": "The scaling factor is established by sending unscaled TCP Sequence Number bits, so that the decompressor can infer the scaling_factor from the payload size.",
      "ja": "スケーリング係数は、非衝撃的なTCPシーケンス数ビットを送信することにより確立され、減圧装置がペイロードサイズからScaling_Factorを推測できるようにします。"
    },
    {
      "indent": 3,
      "text": "Establishing residue:",
      "ja": "残留物の確立："
    },
    {
      "indent": 6,
      "text": "The residue is established identically as the scaling_factor, i.e., by sending unscaled TCP Sequence Number bits.",
      "ja": "残基は、Scaling_Factorと同じように確立されています。つまり、非スケールのTCPシーケンス番号ビットを送信します。"
    },
    {
      "indent": 3,
      "text": "A detailed specification of how the TCP Sequence Number uses the scaled encoding can be found in the definitions of the packet formats, in Section 8.2.",
      "ja": "TCPシーケンス番号がスケーリングされたエンコードを使用する方法の詳細な仕様は、セクション8.2のパケット形式の定義に記載されています。"
    },
    {
      "indent": 0,
      "text": "6.4.8.2. Scaled Acknowledgment Number Encoding",
      "section_title": true,
      "ja": "6.4.8.2. スケーリングされた確認番号エンコーディング"
    },
    {
      "indent": 3,
      "text": "Similar to the pattern exhibited by the TCP Sequence Number, the expected increase in the TCP Acknowledgment Number is often constant and is therefore suitable for scaled encoding.",
      "ja": "TCPシーケンス番号によって示されるパターンと同様に、TCPの確認番号の予想される増加はしばしば一定であるため、スケーリングされたエンコードに適しています。"
    },
    {
      "indent": 3,
      "text": "For the TCP Acknowledgment Number, the scaling factor depends on the size of packets flowing in the opposite direction; this information might not be available to the compressor/decompressor pair. For this reason, ROHC-TCP uses an explicitly transmitted scaling factor to compress the TCP Acknowledgment Number.",
      "ja": "TCPの確認番号の場合、スケーリング係数は、反対方向に流れるパケットのサイズに依存します。この情報は、コンプレッサー/減圧器ペアでは利用できない場合があります。このため、ROHC-TCPは明示的に送信されたスケーリング係数を使用して、TCPの確認番号を圧縮します。"
    },
    {
      "indent": 3,
      "text": "Establishing scaling_factor:",
      "ja": "Scaling_Factorの確立："
    },
    {
      "indent": 6,
      "text": "The scaling factor is established by explicitly transmitting the value of the scaling factor (called ack_stride in the formal notation in Section 8.2) to the decompressor, using one of the packet types that can carry this information.",
      "ja": "スケーリング係数は、この情報を伝達できるパケットタイプの1つを使用して、スケーリング係数の値（セクション8.2の正式な表記でACK_STRIDEと呼ばれる）を減圧器に明示的に送信することにより確立されます。"
    },
    {
      "indent": 3,
      "text": "Establishing residue:",
      "ja": "残留物の確立："
    },
    {
      "indent": 6,
      "text": "The scaling factor is established by sending unscaled TCP Acknowledgment Number bits, so that the decompressor can infer its value from the unscaled value and the scaling factor (ack_stride).",
      "ja": "スケーリング係数は、非スケーリングされたTCP確認数ビットを送信することにより確立されます。これにより、減圧装置はその値とスケーリング係数（ACK_STRIDE）からその値を推測できます。"
    },
    {
      "indent": 3,
      "text": "A detailed specification of how the TCP Acknowledgment Number uses the scaled encoding can be found in the definitions of the packet formats, in Section 8.2.",
      "ja": "TCP確認番号がスケーリングされたエンコードを使用する方法の詳細な仕様は、セクション8.2のパケット形式の定義に記載されています。"
    },
    {
      "indent": 3,
      "text": "The compressor MAY use the scaled acknowledgment number encoding; what value it will use as the scaling factor is up to the compressor implementation. In the case where there is a co-located decompressor processing packets of the same TCP flow in the opposite direction, the scaling factor for the sequence number used for that flow can be used by the compressor to determine a suitable scaling factor for the TCP Acknowledgment number for this flow.",
      "ja": "コンプレッサーは、スケーリングされた確認番号エンコードを使用できます。スケーリング係数として使用する価値は、コンプレッサーの実装に伴います。同じTCPフローの共同配電液処理パケットが反対方向にある場合、そのフローに使用されるシーケンス番号のスケーリング係数は、コンプレッサーによって使用されて、TCP認定の適切なスケーリング係数を決定できます。このフローの番号。"
    },
    {
      "indent": 0,
      "text": "6.5. Encoding Methods With External Parameters",
      "section_title": true,
      "ja": "6.5. 外部パラメーターを使用したメソッドをエンコードします"
    },
    {
      "indent": 3,
      "text": "A number of encoding methods in Section 8.2 have one or more arguments for which the derivation of the parameter's value is outside the scope of the ROHC-FN specification of the header formats. This section lists the encoding methods together with a definition of each of their parameters.",
      "ja": "セクション8.2の多くのエンコーディング方法には、パラメーターの値の導出がヘッダー形式のROHC-FN仕様の範囲外である1つ以上の引数があります。このセクションでは、エンコーディングメソッドと各パラメーターの定義をリストします。"
    },
    {
      "indent": 3,
      "text": "o esp_null(next_header_value):",
      "ja": "o esp_null（next_header_value）："
    },
    {
      "indent": 9,
      "text": "next_header_value: Set to the value of the Next Header field located in the ESP trailer, usually 12 octets from the end of the packet. Compression of null-encrypted ESP headers should only be performed when the compressor has prior knowledge of the exact location of the Next Header field.",
      "ja": "next_header_value：ESPトレーラーにある次のヘッダーフィールドの値に設定します。通常、パケットの端から12オクテットです。ヌル暗号化されたESPヘッダーの圧縮は、コンプレッサーが次のヘッダーフィールドの正確な位置の事前知識を持っている場合にのみ実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "o ipv6(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn):",
      "ja": "o ipv6（is_innermost、ttl_ir relult_chain_flag、ip_inner_ecn）："
    },
    {
      "indent": 9,
      "text": "is_innermost: This Boolean flag is set to true when processing the innermost IP header; otherwise, it is set to false.",
      "ja": "is_innermost：このブールフラグは、最も内側のIPヘッダーを処理するときにTRUEに設定されています。それ以外の場合、それはfalseに設定されています。"
    },
    {
      "indent": 9,
      "text": "ttl_irregular_chain_flag: This parameter must be set to the value that was used for the corresponding \"ttl_irregular_chain_flag\" parameter of the \"co_baseheader\" encoding method (as defined below) when extracting the irregular chain for a compressed header; otherwise, it is set to zero and ignored for other types of chains.",
      "ja": "TTL_IR REMULTION_CHAIN_FLAG：このパラメーターは、圧縮ヘッダーの不規則なチェーンを抽出するときに、「CO_BaseHeader」エンコーディングメソッド（以下に定義されている）の対応する「TTL_IR REGULT_CHAIN_FLAG」パラメーターに使用された値に設定する必要があります。それ以外の場合は、他のタイプのチェーンではゼロに設定され、無視されます。"
    },
    {
      "indent": 9,
      "text": "ip_inner_ecn: This parameter is bound by the encoding method, and therefore it should be undefined when calling this encoding method. This value is then used to bind the corresponding parameter in the \"tcp\" encoding method, as its value is needed when processing the irregular chain for TCP. See the definition of the \"ip_inner_ecn\" parameter for the \"tcp\" encoding method below.",
      "ja": "IP_INNER_ECN：このパラメーターはエンコードメソッドにバインドされているため、このエンコードメソッドを呼び出すときに定義されていないはずです。この値は、TCPの不規則なチェーンを処理する際に値が必要であるため、「TCP」エンコード法の対応するパラメーターをバインドするために使用されます。以下の「TCP」エンコードメソッドの「IP_INNER_ECN」パラメーターの定義を参照してください。"
    },
    {
      "indent": 3,
      "text": "o ipv4(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn):",
      "ja": "o ipv4（is_innermost、ttl_ir relult_chain_flag、ip_inner_ecn）："
    },
    {
      "indent": 9,
      "text": "See definition of arguments for \"ipv6\" above.",
      "ja": "上記の「IPv6」の引数の定義を参照してください。"
    },
    {
      "indent": 3,
      "text": "o tcp_opt_eol(nbits):",
      "ja": "o TCP_OPT_EOL（NBITS）："
    },
    {
      "indent": 9,
      "text": "nbits: This parameter is set to the length of the padding data located after the EOL option type octet to the end of the TCP options in the uncompressed header.",
      "ja": "NBITS：このパラメーターは、非圧縮ヘッダーのTCPオプションの最後にEOLオプションをタイプした後に配置されたパディングデータの長さに設定されます。"
    },
    {
      "indent": 3,
      "text": "o tcp_opt_sack(ack_value):",
      "ja": "o tcp_opt_sack（ack_value）："
    },
    {
      "indent": 9,
      "text": "ack_value: Set to the value of the Acknowledgment Number field of the TCP header.",
      "ja": "ACK_VALUE：TCPヘッダーの確認番号フィールドの値に設定します。"
    },
    {
      "indent": 3,
      "text": "o tcp(payload_size, ack_stride_value, ip_inner_ecn):",
      "ja": "o TCP（payload_size、ack_stride_value、ip_inner_ecn）："
    },
    {
      "indent": 9,
      "text": "payload_size: Set to the length (in octets) of the payload following the TCP header.",
      "ja": "Payload_size：TCPヘッダーに続くペイロードの長さ（オクテット）に設定します。"
    },
    {
      "indent": 9,
      "text": "ack_stride_value: This parameter is the scaling factor used when scaling the TCP Acknowledgment Number. Its value is set by the compressor implementation. See Section 6.4.8.2 for recommendations on how to set this value.",
      "ja": "ACK_STRIDE_VALUE：このパラメーターは、TCP確認番号をスケーリングするときに使用されるスケーリング係数です。その値は、コンプレッサーの実装によって設定されます。この値を設定する方法に関する推奨事項については、セクション6.4.8.2を参照してください。"
    },
    {
      "indent": 9,
      "text": "ip_inner_ecn: This parameter binds with the value given to the corresponding \"ip_inner_ecn\" parameter by the \"ipv4\" or the \"ipv6\" encoding method when processing the innermost IP header of this packet. See also the definition of the \"ip_inner_ecn\" parameter to the \"ipv6\" and \"ipv4\" encoding method above.",
      "ja": "IP_INNER_ECN：このパラメーターは、このパケットの最も内側のIPヘッダーを処理するときに、「IPv4」または「IPv6」エンコードメソッドによって対応する「IP_INNER_ECN」パラメーターに与えられた値にバインドされます。上記の「IPv6」および「IPv4」エンコードメソッドの「IP_INNER_ECN」パラメーターの定義も参照してください。"
    },
    {
      "indent": 3,
      "text": "o co_baseheader(payload_size, ack_stride_value, ttl_irregular_chain_flag):",
      "ja": "o co_baseheader（payload_size、ack_stride_value、ttl_ir Regular_chain_flag）："
    },
    {
      "indent": 9,
      "text": "payload_size: Set to the length (in octets) of the payload following the TCP header.",
      "ja": "Payload_size：TCPヘッダーに続くペイロードの長さ（オクテット）に設定します。"
    },
    {
      "indent": 9,
      "text": "ack_stride_value: This parameter is the scaling factor used when scaling the TCP Acknowledgment Number. Its value is set by the compressor implementation. See Section 6.4.8.2 for recommendations on how to set this value.",
      "ja": "ACK_STRIDE_VALUE：このパラメーターは、TCP確認番号をスケーリングするときに使用されるスケーリング係数です。その値は、コンプレッサーの実装によって設定されます。この値を設定する方法に関する推奨事項については、セクション6.4.8.2を参照してください。"
    },
    {
      "indent": 9,
      "text": "ttl_irregular_chain_flag: This parameter is set to one if the TTL/Hop Limit of an outer header has changed compared to its reference in the context; otherwise, it is set to zero. The value used for this parameter is also used for the \"ttl_irregular_chain_flag\" argument for the \"ipv4\" and \"ipv6\" encoding methods when processing the irregular chain, as defined above for the \"ipv6\" and \"ipv4\" encoding methods.",
      "ja": "TTL_ir Regual_Chain_Flag：このパラメーターは、外側ヘッダーのTTL/ホップ制限がコンテキストでの参照と比較して変更された場合に1に設定されています。それ以外の場合は、ゼロに設定されています。このパラメーターに使用される値は、「IPv6」および「IPv4」エンコードメソッドの上記で定義されているように、不規則なチェーンを処理するときに「IPv4」および「IPv6」エンコードメソッドの「TTL_IR REGULT_CHAIN_FLAG」引数にも使用されます。"
    },
    {
      "indent": 0,
      "text": "7. Packet Types (Normative)",
      "section_title": true,
      "ja": "7. パケットタイプ（規範）"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP uses three different packet types: the Initialization and Refresh (IR) packet type, the Context Replication (IR-CR) packet type, and the Compressed (CO) packet type.",
      "ja": "ROHC-TCPは、初期化と更新（IR）パケットタイプ、コンテキストレプリケーション（IR-CR）パケットタイプ、および圧縮（CO）パケットタイプの3つの異なるパケットタイプを使用します。"
    },
    {
      "indent": 3,
      "text": "Each packet type defines a number of packet formats: two packet formats are defined for the IR type, one packet format is defined for the IR-CR type, and two sets of eight base header formats are defined for the CO type with one additional format that is common to both sets.",
      "ja": "各パケットタイプは多くのパケット形式を定義します。IRタイプに対して2つのパケット形式が定義され、1つのパケット形式がIR-CRタイプに定義され、8つのベースヘッダー形式の2つのセットがCOタイプに対して定義されます。それは両方のセットに共通しています。"
    },
    {
      "indent": 3,
      "text": "The profile identifier for ROHC-TCP is 0x0006.",
      "ja": "ROHC-TCPのプロファイル識別子は0x0006です。"
    },
    {
      "indent": 0,
      "text": "7.1. Initialization and Refresh (IR) Packets",
      "section_title": true,
      "ja": "7.1. 初期化と更新（IR）パケット"
    },
    {
      "indent": 3,
      "text": "ROHC-TCP uses the basic structure of the ROHC IR and IR-DYN packets as defined in [RFC4995] (Sections 5.2.2.1 and 5.2.2.2, respectively).",
      "ja": "ROHC-TCPは、[RFC4995]で定義されているROHC IRおよびIR-Dynパケットの基本構造を使用します（それぞれセクション5.2.2.1および5.2.2.2）。"
    },
    {
      "indent": 3,
      "text": "Packet type: IR",
      "ja": "パケットタイプ：IR"
    },
    {
      "indent": 6,
      "text": "This packet type communicates the static part and the dynamic part of the context.",
      "ja": "このパケットタイプは、静的部分とコンテキストの動的部分を伝えます。"
    },
    {
      "indent": 6,
      "text": "For the ROHC-TCP IR packet, the value of the x bit MUST be set to one. It has the following format, which corresponds to the",
      "ja": "ROHC-TCP IRパケットの場合、xビットの値を1に設定する必要があります。次の形式があり、"
    },
    {
      "indent": 6,
      "text": "\"Header\" and \"Payload\" fields described in Section 5.2.1 of [RFC4995]:",
      "ja": "[RFC4995]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールド："
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:        Add-CID octet          : if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1   0   1 | IR type octet\n+---+---+---+---+---+---+---+---+\n:                               :\n/       0-2 octets of CID       / 1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|         Profile = 0x06        | 1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              | 1 octet\n+---+---+---+---+---+---+---+---+\n|                               |\n/         Static chain          / variable length\n|                               |\n - - - - - - - - - - - - - - - -\n|                               |\n/         Dynamic chain         / variable length\n|                               |\n - - - - - - - - - - - - - - - -\n|                               |\n/            Payload            / variable length\n|                               |\n - - - - - - - - - - - - - - - -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "CRC: 8-bit CRC, computed according to Section 5.3.1.1. of [RFC4995]. The CRC covers the entire IR header, thus excluding payload, padding, and feedback, if any.",
      "ja": "CRC：8ビットCRC、セクション5.3.1.1に従って計算されました。[RFC4995]。CRCは、IRヘッダー全体をカバーしているため、ペイロード、パディング、フィードバックを除外します。"
    },
    {
      "indent": 6,
      "text": "Static chain: See Section 6.2.",
      "ja": "静的チェーン：セクション6.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "Dynamic chain: See Section 6.2.",
      "ja": "動的チェーン：セクション6.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "Payload: The payload of the corresponding original packet, if any. The payload consists of all data after the last octet of the TCP header to end of the uncompressed packet. The presence of a payload is inferred from the packet length.",
      "ja": "ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードは、TCPヘッダーの最後のオクテットの後のすべてのデータで構成されています。ペイロードの存在は、パケットの長さから推測されます。"
    },
    {
      "indent": 3,
      "text": "Packet type: IR-DYN",
      "ja": "パケットタイプ：Ir-Dyn"
    },
    {
      "indent": 6,
      "text": "This packet type communicates the dynamic part of the context.",
      "ja": "このパケットタイプは、コンテキストの動的な部分を伝えます。"
    },
    {
      "indent": 6,
      "text": "The ROHC-TCP IR-DYN packet has the following format, which corresponds to the \"Header\" and \"Payload\" fields described in Section 5.2.1 of [RFC4995]:",
      "ja": "ROHC-TCP IR-Dynパケットには、[RFC4995]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールドに対応する次の形式があります。"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         : if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   0   0   0 | IR-DYN type octet\n+---+---+---+---+---+---+---+---+\n:                               :\n/       0-2 octets of CID       / 1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|         Profile = 0x06        | 1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              | 1 octet\n+---+---+---+---+---+---+---+---+\n|                               |\n/         Dynamic chain         / variable length\n|                               |\n - - - - - - - - - - - - - - - -\n|                               |\n/            Payload            / variable length\n|                               |\n - - - - - - - - - - - - - - - -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "CRC: 8-bit CRC, computed according to Section 5.3.1.1 of [RFC4995]. The CRC covers the entire IR-DYN header, thus excluding payload, padding, and feedback, if any.",
      "ja": "CRC：8ビットCRC、[RFC4995]のセクション5.3.1.1に従って計算されました。CRCは、IR-Dynヘッダー全体をカバーしているため、ペイロード、パディング、フィードバックを除外します。"
    },
    {
      "indent": 6,
      "text": "Dynamic chain: See Section 6.2.",
      "ja": "動的チェーン：セクション6.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "Payload: The payload of the corresponding original packet, if any. The payload consists of all data after the last octet of the TCP header to end of the uncompressed packet. The presence of a payload is inferred from the packet length.",
      "ja": "ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードは、TCPヘッダーの最後のオクテットの後のすべてのデータで構成されています。ペイロードの存在は、パケットの長さから推測されます。"
    },
    {
      "indent": 0,
      "text": "7.2. Context Replication (IR-CR) Packets",
      "section_title": true,
      "ja": "7.2. コンテキストレプリケーション（IR-CR）パケット"
    },
    {
      "indent": 3,
      "text": "Context replication requires a dedicated IR packet format that uniquely identifies the IR-CR packet for the ROHC-TCP profile. This section defines the profile-specific part of the IR-CR packet [RFC4164].",
      "ja": "コンテキストレプリケーションには、ROHC-TCPプロファイルのIR-CRパケットを一意に識別する専用のIRパケット形式が必要です。このセクションでは、IR-CRパケットのプロファイル固有の部分[RFC4164]を定義します。"
    },
    {
      "indent": 3,
      "text": "Packet type: IR-CR",
      "ja": "パケットタイプ：IR-CR"
    },
    {
      "indent": 6,
      "text": "This packet type communicates a reference to a base context along with the static and dynamic parts of the replicated context that differs from the base context.",
      "ja": "このパケットタイプは、基本コンテキストの静的および動的な部分とともに、ベースコンテキストの静的および動的な部分とともに、ベースコンテキストの静的および動的部分への参照を伝えます。"
    },
    {
      "indent": 3,
      "text": "The ROHC-TCP IR-CR packet follows the general format of the ROHC CR packet, as defined in [RFC4164], Section 3.5.2. With consideration to the extensibility of the IR packet type defined in [RFC4995], the ROHC-TCP profile supports context replication through the profile-specific part of the IR packet. This is achieved using the bit (x) left in the IR header for \"Profile specific information\". For ROHC-TCP, this bit is defined as a flag indicating whether this packet is an IR packet or an IR-CR packet. For the ROHC-TCP IR-CR packet, the value of the x bit MUST be set to zero.",
      "ja": "ROHC-TCP IR-CRパケットは、[RFC4164]、セクション3.5.2で定義されているROHC CRパケットの一般的な形式に従います。[RFC4995]で定義されたIRパケットタイプの拡張性を考慮して、ROHC-TCPプロファイルは、IRパケットのプロファイル固有の部分を介したコンテキスト複製をサポートします。これは、「プロファイル固有の情報」のために、IRヘッダーに残っているビット（x）を使用して達成されます。ROHC-TCPの場合、このビットは、このパケットがIRパケットかIR-CRパケットであるかを示すフラグとして定義されます。ROHC-TCP IR-CRパケットの場合、Xビットの値をゼロに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ROHC-TCP IR-CR has the following format, which corresponds to the \"Header\" and \"Payload\" fields described in Section 5.2.1 of [RFC4995]:",
      "ja": "ROHC-TCP IR-CRには、[RFC4995]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールドに対応する次の形式があります。"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         : if for small CIDs and (CID != 0)\n+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1   0   0 | IR-CR type octet\n+---+---+---+---+---+---+---+---+\n:                               :\n/       0-2 octets of CID       / 1-2 octets if for large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n|         Profile = 0x06        | 1 octet\n+---+---+---+---+---+---+---+---+\n|              CRC              | 1 octet\n+---+---+---+---+---+---+---+---+\n| B |             CRC7          | 1 octet\n+---+---+---+---+---+---+---+---+\n:   Reserved    |   Base CID    : 1 octet, for small CID, if B=1\n+---+---+---+---+---+---+---+---+\n:                               :\n/           Base CID            / 1-2 octets, for large CIDs,\n:                               : if B=1\n+---+---+---+---+---+---+---+---+\n|                               |\n/        Replicate chain        / variable length\n|                               |\n - - - - - - - - - - - - - - - -\n|                               |\n/            Payload            / variable length\n|                               |\n - - - - - - - - - - - - - - - -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "B: B = 1 indicates that the Base CID field is present.",
      "ja": "B：B = 1は、ベースCIDフィールドが存在することを示します。"
    },
    {
      "indent": 6,
      "text": "CRC: This CRC covers the entire IR-CR header, thus excluding payload, padding, and feedback, if any. This 8-bit CRC is calculated according to Section 5.3.1.1 of [RFC4995].",
      "ja": "CRC：このCRCは、IR-CRヘッダー全体をカバーしているため、ペイロード、パディング、フィードバックを除外します。この8ビットCRCは、[RFC4995]のセクション5.3.1.1に従って計算されます。"
    },
    {
      "indent": 6,
      "text": "CRC7: The CRC over the original, uncompressed, header. Calculated according to Section 3.5.1.1 of [RFC4164].",
      "ja": "CRC7：元の、圧縮されていないヘッダー上のCRC。[RFC4164]のセクション3.5.1.1に従って計算されました。"
    },
    {
      "indent": 6,
      "text": "Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.",
      "ja": "予約済み：ゼロに設定する必要があります。それ以外の場合、減圧器はパケットを破棄する必要があります。"
    },
    {
      "indent": 6,
      "text": "Base CID: CID of base context. Encoded according to [RFC4164], Section 3.5.3.",
      "ja": "ベースCID：ベースコンテキストのCID。[RFC4164]に従ってエンコード、セクション3.5.3。"
    },
    {
      "indent": 6,
      "text": "Replicate chain: See Section 6.2.",
      "ja": "複製チェーン：セクション6.2を参照してください。"
    },
    {
      "indent": 6,
      "text": "Payload: The payload of the corresponding original packet, if any. The presence of a payload is inferred from the packet length.",
      "ja": "ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードの存在は、パケットの長さから推測されます。"
    },
    {
      "indent": 0,
      "text": "7.3. Compressed (CO) Packets",
      "section_title": true,
      "ja": "7.3. 圧縮（CO）パケット"
    },
    {
      "indent": 3,
      "text": "The ROHC-TCP CO packets communicate irregularities in the packet header. All CO packets carry a CRC and can update the context.",
      "ja": "ROHC-TCP COパケットは、パケットヘッダーの不規則性を伝えます。すべてのCOパケットにはCRCがあり、コンテキストを更新できます。"
    },
    {
      "indent": 3,
      "text": "The general format for a compressed TCP header is as follows, which corresponds to the \"Header\" and \"Payload\" fields described in Section 5.2.1 of [RFC4995]:",
      "ja": "圧縮されたTCPヘッダーの一般的な形式は次のとおりです。これは、[RFC4995]のセクション5.2.1で説明されている「ヘッダー」および「ペイロード」フィールドに対応します。"
    },
    {
      "indent": 7,
      "text": "  0   1   2   3   4   5   6   7\n --- --- --- --- --- --- --- ---\n:         Add-CID octet         :  if for small CIDs and CID 1-15\n+---+---+---+---+---+---+---+---+\n|   First octet of base header  |  (with type indication)\n+---+---+---+---+---+---+---+---+\n:                               :\n/   0, 1, or 2 octets of CID    /  1-2 octets if large CIDs\n:                               :\n+---+---+---+---+---+---+---+---+\n/   Remainder of base header    /  variable number of octets\n+---+---+---+---+---+---+---+---+\n:        Irregular chain        :\n/   (including irregular chain  /  variable\n:    items for TCP options)     :\n --- --- --- --- --- --- --- ---\n|                               |\n/            Payload            / variable length\n|                               |\n - - - - - - - - - - - - - - - -",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Base header: The complete set of base headers is defined in Section 8.",
      "ja": "ベースヘッダー：ベースヘッダーの完全なセットは、セクション8で定義されています。"
    },
    {
      "indent": 6,
      "text": "Irregular chain: See Section 6.2 and Section 6.3.6.",
      "ja": "不規則なチェーン：セクション6.2およびセクション6.3.6を参照してください。"
    },
    {
      "indent": 6,
      "text": "Payload: The payload of the corresponding original packet, if any. The presence of a payload is inferred from the packet length.",
      "ja": "ペイロード：対応する元のパケットのペイロード（ある場合）。ペイロードの存在は、パケットの長さから推測されます。"
    },
    {
      "indent": 0,
      "text": "8. Header Formats (Normative)",
      "section_title": true,
      "ja": "8. ヘッダー形式（規範）"
    },
    {
      "indent": 3,
      "text": "This section describes the set of compressed TCP/IP packet formats. The normative description of the packet formats is given using the formal notation for ROHC profiles defined in [RFC4997]. The formal description of the packet formats specifies all of the information needed to compress and decompress a header relative to the context.",
      "ja": "このセクションでは、圧縮されたTCP/IPパケット形式のセットについて説明します。パケット形式の規範的な説明は、[RFC4997]で定義されているROHCプロファイルの正式な表記を使用して与えられます。パケット形式の正式な説明は、コンテキストに対するヘッダーを圧縮および解凍するために必要なすべての情報を指定します。"
    },
    {
      "indent": 3,
      "text": "In particular, the notation provides a list of all the fields present in the uncompressed and compressed TCP/IP headers, and defines how to map from each uncompressed packet to its compressed equivalent and vice versa.",
      "ja": "特に、表記は、非圧縮および圧縮TCP/IPヘッダーに存在するすべてのフィールドのリストを提供し、各圧縮されていないパケットから圧縮等価にマッピングする方法を定義し、その逆を定義します。"
    },
    {
      "indent": 0,
      "text": "8.1. Design Rationale for Compressed Base Headers",
      "section_title": true,
      "ja": "8.1. 圧縮ベースヘッダーのデザイン理論的根拠"
    },
    {
      "indent": 3,
      "text": "The compressed header formats are defined as two separate sets: one set for the packets where the innermost IP header contains a sequential IP-ID (either network byte order or byte swapped), and one set for the packets without sequential IP-ID (either random, zero, or no IP-ID).",
      "ja": "圧縮ヘッダー形式は、最も内側のIPヘッダーにシーケンシャルIP-ID（ネットワークバイト順序またはバイトスワップされた）が含まれるパケット用の2つの個別のセットとして定義されます。ランダム、ゼロ、またはIP-IDなし）。"
    },
    {
      "indent": 3,
      "text": "These two sets of header formats are referred to as the \"sequential\" and the \"random\" set of header formats, respectively.",
      "ja": "これらの2つのヘッダー形式は、それぞれ「シーケンシャル」および「ランダム」セットのヘッダー形式と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "In addition, there is one compressed format that is common to both sets of header formats and that can thus be used regardless of the type of IP-ID behavior. This format can transmit rarely changing fields and also send the frequently changing fields coded in variable lengths. It can also change the value of control fields such as IP-ID behavior and ECN behavior.",
      "ja": "さらに、ヘッダー形式の両方のセットに共通する圧縮形式が1つあり、IP-IDの動作の種類に関係なく使用できます。この形式は、ほとんど変化するフィールドを送信することができ、変化する長さでコーディングされる頻繁に変化するフィールドを送信できます。また、IP-IDの動作やECN動作などの制御フィールドの値を変更することもできます。"
    },
    {
      "indent": 3,
      "text": "All compressed base headers contain a 3-bit CRC, unless they update control fields such as \"ip_id_behavior\" or \"ecn_used\" that affect the interpretation of subsequent headers. Headers that can modify these control fields carry a 7-bit CRC instead.",
      "ja": "すべての圧縮ベースヘッダーには、後続のヘッダーの解釈に影響する「IP_ID_BEHAVIOR」や「ECN_USED」などの制御フィールドを更新しない限り、3ビットCRCが含まれます。これらの制御フィールドを変更できるヘッダーは、代わりに7ビットCRCを運びます。"
    },
    {
      "indent": 3,
      "text": "When discussing LSB-encoded fields below, \"p\" equals the \"offset_param\" and \"k\" equals the \"num_lsbs_param\" in [RFC4997]. The encoding methods used in the compressed base headers are based on the following design criteria:",
      "ja": "以下のLSBエンコードフィールドについて議論するとき、「P」は「offset_param」と「k」に等しく、[rfc4997]の「num_lsbs_param」に等しくなります。圧縮ベースヘッダーで使用されるエンコーディング方法は、次の設計基準に基づいています。"
    },
    {
      "indent": 3,
      "text": "o MSN",
      "ja": "o MSN"
    },
    {
      "indent": 9,
      "text": "Since the MSN is a number generated by the compressor, it only needs to be large enough to ensure robust operation and to accommodate a small amount of reordering [RFC4163]. Therefore, each compressed base header has an MSN field that is LSB-encoded with k=4 and p=4 to handle a reordering depth of up to 4 packets. Additional guidance to improve robustness when reordering is possible can be found in [RFC4224].",
      "ja": "MSNはコンプレッサーによって生成される数であるため、堅牢な動作を確保し、少量の並べ替え[RFC4163]に対応するのに十分な大きさである必要があります。したがって、各圧縮ベースヘッダーには、最大4つのパケットの並べ替え深度を処理するために、K = 4およびP = 4でLSBエンコードされたMSNフィールドがあります。再注文が可能なときに堅牢性を改善するための追加のガイダンスは、[RFC4224]に記載されています。"
    },
    {
      "indent": 3,
      "text": "o TCP Sequence Number",
      "ja": "o TCPシーケンス番号"
    },
    {
      "indent": 9,
      "text": "ROHC-TCP has the capability to handle bulk data transfers efficiently, for which the sequence number is expected to increase by about 1460 octets (which can be represented by 11 bits). For the compressed base headers to handle retransmissions (i.e., negative delta to the sequence number), the LSB interpretation interval has to handle negative offsets about as large as positive offsets, which means that one more bit is needed.",
      "ja": "ROHC-TCPには、バルクデータ転送を効率的に処理する機能があり、シーケンス数は約1460オクテット（11ビットで表すことができます）が増加すると予想されます。再送信（つまり、シーケンス番号に対する負のデルタ）を処理する圧縮ベースヘッダーの場合、LSB解釈間隔は、正のオフセットと同じくらい大きいネガティブオフセットを処理する必要があります。つまり、もう1つビットが必要です。"
    },
    {
      "indent": 9,
      "text": "Also, for ROHC-TCP to be robust to losses, two additional bits are added to the LSB encoding of the sequence number. This means that the base headers should contain at least 14 bits of LSB-encoded sequence number when present. According to the logic above, the LSB offset value is set to be as large as the positive offset, i.e., p = 2^(k-1)-1.",
      "ja": "また、ROHC-TCPが損失に対して堅牢であるためには、シーケンス番号のLSBエンコードに2つの追加ビットが追加されます。これは、ベースヘッダーには、存在するときに少なくとも14ビットのLSBエンコードシーケンス番号を含める必要があることを意味します。上記のロジックによれば、LSBオフセット値は、正のオフセット、つまりp = 2^（k-1）-1と同じ大きさに設定されています。"
    },
    {
      "indent": 3,
      "text": "o TCP Acknowledgment Number",
      "ja": "o TCP確認番号"
    },
    {
      "indent": 9,
      "text": "The design criterion for the acknowledgment number is similar to that of the TCP Sequence Number. However, often only every other data packet is acknowledged, which means that the expected delta value is twice as large as for sequence numbers.",
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Therefore, at least 15 bits of acknowledgment number should be used in compressed base headers. Since the acknowledgment number is expected to constantly increase, and the only exception to this is packet reordering (either on the ROHC channel [RFC3759] or prior to the compression point), the negative offset for LSB encoding is set to be 1/4 of the total interval, i.e., p = 2^(k-2)-1.",
      "ja": "したがって、圧縮ベースヘッダーでは、少なくとも15ビットの確認番号を使用する必要があります。確認番号は絶えず増加すると予想されており、これの唯一の例外はパケットの並べ替え（ROHCチャネル[RFC3759]のいずれか）または圧縮ポイントの前）であるため、LSBエンコードの負のオフセットは1/4に設定されています。合計間隔、つまりp = 2^（k-2）-1。"
    },
    {
      "indent": 3,
      "text": "o TCP Window",
      "ja": "o TCPウィンドウ"
    },
    {
      "indent": 9,
      "text": "The TCP Window field is expected to increase in increments of similar size as the TCP Sequence Number, and therefore the design criterion for the TCP window is to send at least 14 bits when used.",
      "ja": "TCPウィンドウフィールドは、TCPシーケンス数と同様のサイズの増分が増加すると予想されます。したがって、TCPウィンドウの設計基準は、使用すると少なくとも14ビットを送信することです。"
    },
    {
      "indent": 3,
      "text": "o IP-ID",
      "ja": "o IP-ID"
    },
    {
      "indent": 9,
      "text": "For the \"sequential\" set of packet formats, all the compressed base headers contain LSB-encoded IP-ID offset bits, where the offset is the difference between the value of the MSN field and the value of the IP-ID field. The requirement is that at least 3 bits of IP-ID should always be present, but it is preferable to use 4 to 7 bits. When k=3 then p=1, and if k>3 then p=3 since the offset is expected to increase most of the time.",
      "ja": "パケット形式の「シーケンシャル」セットの場合、すべての圧縮ベースヘッダーにはLSBエンコードIP-IDオフセットビットが含まれます。オフセットは、MSNフィールドの値とIP-IDフィールドの値の違いです。要件は、少なくとも3ビットのIP-IDが常に存在する必要があることですが、4〜7ビットを使用することが望ましいです。k = 3の場合はp = 1、k> 3の場合、オフセットがほとんどの時間増加すると予想されるため、p = 3。"
    },
    {
      "indent": 3,
      "text": "Each set of header formats contains eight different compressed base headers. The reason for having this large number of header formats is that the TCP Sequence Number, TCP Acknowledgment Number, and TCP Window are frequently changing in a non-linear pattern.",
      "ja": "ヘッダー形式の各セットには、8つの異なる圧縮ベースヘッダーが含まれています。この多数のヘッダー形式を持っている理由は、TCPシーケンス番号、TCP確認番号、およびTCPウィンドウが非線形パターンで頻繁に変更されているためです。"
    },
    {
      "indent": 3,
      "text": "The design of the header formats is derived from the field behavior analysis found in [RFC4413].",
      "ja": "ヘッダー形式の設計は、[RFC4413]に見られるフィールドの動作分析から導き出されます。"
    },
    {
      "indent": 3,
      "text": "All of the compressed base headers transmit LSB-encoded MSN bits, the TCP Push flag, and a CRC, and in addition to this, all the base headers in the sequential packet format set contain LSB-encoded IP-ID bits.",
      "ja": "すべての圧縮ベースヘッダーは、LSBエンコードMSNビット、TCPプッシュフラグ、およびCRCを送信し、これに加えて、シーケンシャルパケット形式のすべてのベースヘッダーにLSBエンコードIP-IDビットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The following header formats exist in both the sequential and random packet format sets:",
      "ja": "次のヘッダー形式は、シーケンシャルパケット形式とランダムパケット形式の両方のセットに存在します。"
    },
    {
      "indent": 3,
      "text": "o Format 1: This header format carries changes to the TCP Sequence Number and is expected to be used on the downstream of a data transfer.",
      "ja": "o 形式1：このヘッダー形式は、TCPシーケンス番号への変更を伴い、データ転送の下流で使用されると予想されます。"
    },
    {
      "indent": 3,
      "text": "o Format 2: This header format carries the TCP Sequence Number in scaled form and is expected to be useful for the downstream of a data transfer where the payload size is constant for multiple packets.",
      "ja": "o フォーマット2：このヘッダー形式は、スケーリングされた形式でTCPシーケンス番号を搭載しており、複数のパケットのペイロードサイズが一定であるデータ転送の下流に役立つと予想されます。"
    },
    {
      "indent": 3,
      "text": "o Format 3: This header format carries changes in the TCP Acknowledgment Number and is expected to be useful for the acknowledgment direction of a data transfer.",
      "ja": "o フォーマット3：このヘッダー形式は、TCPの確認番号の変更を伝達し、データ転送の確認方向に役立つと予想されます。"
    },
    {
      "indent": 3,
      "text": "o Format 4: This header format is similar to format 3, but carries a scaled TCP Acknowledgment Number.",
      "ja": "o フォーマット4：このヘッダー形式はフォーマット3に似ていますが、スケーリングされたTCP確認番号が含まれています。"
    },
    {
      "indent": 3,
      "text": "o Format 5: This header format carries both the TCP Sequence Number and the TCP Acknowledgment Number and is expected to be useful for flows that send data in both directions.",
      "ja": "o フォーマット5：このヘッダー形式は、TCPシーケンス番号とTCP確認番号の両方を搭載しており、両方向にデータを送信するフローに役立つと予想されます。"
    },
    {
      "indent": 3,
      "text": "o Format 6: This header format is similar to format 5, but carries the TCP Sequence Number in scaled form, when the payload size is static for certain intervals in a data flow.",
      "ja": "o フォーマット6：このヘッダー形式はフォーマット5に似ていますが、データフローの特定の間隔でペイロードサイズが静的である場合、スケーリングされた形式のTCPシーケンス番号を搭載します。"
    },
    {
      "indent": 3,
      "text": "o Format 7: This header format carries changes to both the TCP Acknowledgment Number and the TCP Window and is expected to be useful for the acknowledgment flows of data connections.",
      "ja": "o フォーマット7：このヘッダー形式は、TCP確認番号とTCPウィンドウの両方に変更され、データ接続の確認フローに役立つと予想されます。"
    },
    {
      "indent": 3,
      "text": "o Format 8: This header format is used to convey changes to some of the more seldom changing fields in the TCP flow, such as ECN behavior, RST/SYN/FIN flags, the TTL/Hop Limit, and the TCP options list. This format carries a 7-bit CRC, since it can change the structure of the contents of the irregular chain for subsequent packets. Note that this can be seen as a reduced form of the common packet format.",
      "ja": "o フォーマット8：このヘッダー形式は、ECNの動作、RST/SYN/FINフラグ、TTL/ホップ制限、TCPオプションリストなど、TCPフローのめったにめったに変化するフィールドの一部に変更を伝えるために使用されます。この形式には、7ビットCRCが搭載されています。これは、後続のパケットの不規則なチェーンの内容の構造を変更できるためです。これは、一般的なパケット形式の縮小された形式と見なすことができることに注意してください。"
    },
    {
      "indent": 3,
      "text": "o Common header format: The common header format can be used for all kinds of IP-ID behavior and should be useful when some of the more rarely changing fields in the IP or TCP header change. Since this header format can update control fields that decide how the decompressor interprets packets, it carries a 7-bit CRC to reduce the probability of context corruption. This header can basically convey changes to any of the dynamic fields in the IP and TCP headers, and it uses a large set of flags to provide information about which fields are present in the header format.",
      "ja": "o 一般的なヘッダー形式：共通ヘッダー形式は、あらゆる種類のIP-ID動作に使用でき、IPまたはTCPヘッダーの変更のフィールドがほとんど変化しない場合に役立つはずです。このヘッダー形式は、分解器がパケットを解釈する方法を決定する制御フィールドを更新できるため、コンテキスト腐敗の確率を低下させるために7ビットCRCを運ぶことができます。このヘッダーは基本的に、IPおよびTCPヘッダーの動的フィールドのいずれかへの変更を伝えることができ、大きなフラグセットを使用して、ヘッダー形式に存在するフィールドに関する情報を提供します。"
    },
    {
      "indent": 0,
      "text": "8.2. Formal Definition of Header Formats",
      "section_title": true,
      "ja": "8.2. ヘッダー形式の正式な定義"
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// Constants\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "IP_ID_BEHAVIOR_SEQUENTIAL = 0;\nIP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED = 1;\nIP_ID_BEHAVIOR_RANDOM = 2;\nIP_ID_BEHAVIOR_ZERO = 3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// Global control fields\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "CONTROL {\n  ecn_used            [ 1 ];\n  msn                 [ 16 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "///////////////////////////////////////////////\n// Encoding methods not specified in FN syntax\n///////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "list_tcp_options               \"defined in Section 6.3.3\";\ninferred_ip_v4_header_checksum \"defined in Section 6.4.1\";\ninferred_mine_header_checksum  \"defined in Section 6.4.2\";\ninferred_ip_v4_length          \"defined in Section 6.4.3\";\ninferred_ip_v6_length          \"defined in Section 6.4.4\";\ninferred_offset                \"defined in Section 6.4.5\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "baseheader_extension_headers \"defined in Section 6.4.6\"; baseheader_outer_headers \"defined in Section 6.4.7\";",
      "ja": "baseheader_extension_headers \"セクション6.4.6で定義されています。baseheader_outer_headers \"セクション6.4.7で定義されています。"
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// General encoding methods\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "static_or_irreg(flag, width)\n{\n  UNCOMPRESSED {\n    field [ width ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED irreg_enc {\n  field =:= irregular(width) [ width ];\n  ENFORCE(flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED static_enc {\n    field =:= static [ 0 ];\n    ENFORCE(flag == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "zero_or_irreg(flag, width)\n{\n  UNCOMPRESSED {\n    field [ width ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED non_zero {\n  field =:= irregular(width) [ width ];\n  ENFORCE(flag == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED zero {\n    field =:= uncompressed_value(width, 0) [ 0 ];\n    ENFORCE(flag == 1);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "variable_length_32_enc(flag)\n{\n  UNCOMPRESSED {\n    field [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED not_present {",
      "ja": "圧縮not_present {"
    },
    {
      "indent": 3,
      "text": "  field =:= static [ 0 ];\n  ENFORCE(flag == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_8_bit {\n  field =:= lsb(8, 63) [ 8 ];\n  ENFORCE(flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_16_bit {\n  field =:= lsb(16, 16383) [ 16 ];\n  ENFORCE(flag == 2);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED irreg_32_bit {\n    field =:= irregular(32) [ 32 ];\n    ENFORCE(flag == 3);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "optional32(flag)\n{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED present {\n  item =:= irregular(32) [ 32 ];\n  ENFORCE(flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED not_present {\n    item =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag == 0);\n  }\n}\nlsb_7_or_31\n{\n  UNCOMPRESSED {\n    item [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_7 {\n  discriminator =:= '0'       [ 1 ];\n  item          =:= lsb(7, 8) [ 7 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_31 {",
      "ja": "圧縮されたLSB_31 {"
    },
    {
      "indent": 1,
      "text": "    discriminator =:= '1'          [ 1 ];\n    item          =:= lsb(31, 256) [ 31 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "opt_lsb_7_or_31(flag)\n{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED present {\n  item =:= lsb_7_or_31 [ 8, 32 ];\n  ENFORCE(flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED not_present {\n    item =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "crc3(data_value, data_length)\n{\n  UNCOMPRESSED {\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED {\n    crc_value =:=\n      crc(3, 0x06, 0x07, data_value, data_length) [ 3 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "crc7(data_value, data_length)\n{\n  UNCOMPRESSED {\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED {\n    crc_value =:=\n      crc(7, 0x79, 0x7f, data_value, data_length) [ 7 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "one_bit_choice\n{\n  UNCOMPRESSED {\n    field [ 1 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "COMPRESSED zero {\n  field [ 1 ];\n  ENFORCE(field.UVALUE == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED nonzero {\n    field [ 1 ];\n    ENFORCE(field.UVALUE == 1);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// Encoding method for updating a scaled field and its associated\n// control fields.  Should be used both when the value is scaled\n// or unscaled in a compressed format.\nfield_scaling(stride_value, scaled_value, unscaled_value)\n{\n  UNCOMPRESSED {\n    residue_field [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED no_scaling {\n  ENFORCE(stride_value == 0);\n  ENFORCE(residue_field.UVALUE == unscaled_value);\n  ENFORCE(scaled_value == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED scaling_used {\n    ENFORCE(stride_value != 0);\n    ENFORCE(residue_field.UVALUE == (unscaled_value % stride_value));\n    ENFORCE(unscaled_value ==\n            scaled_value * stride_value + residue_field.UVALUE);\n  }\n}\n////////////////////////////////////////////\n// IPv6 Destination options header\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_dest_opt\n{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value       [ length.UVALUE * 64 + 48 ];\n  }\n   DEFAULT {\n    length      =:= static;\n    next_header =:= static;\n    value       =:= static;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED dest_opt_static {\n  next_header =:= irregular(8) [ 8 ];\n  length      =:= irregular(8) [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED dest_opt_dynamic {\n  value =:=\n    irregular(length.UVALUE * 64 + 48) [ length.UVALUE * 64 + 48 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED dest_opt_0_replicate {\n  discriminator =:= '00000000' [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED dest_opt_1_replicate {\n  discriminator =:= '10000000'                     [ 8 ];\n  length        =:= irregular(8)                   [ 8 ];\n  value         =:=\n    irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED dest_opt_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// IPv6 Hop-by-Hop options header\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_hop_opt\n{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value       [ length.UVALUE * 64 + 48 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  length      =:= static;\n  next_header =:= static;\n  value       =:= static;\n}\n   COMPRESSED hop_opt_static {\n  next_header =:= irregular(8) [ 8 ];\n  length      =:= irregular(8) [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED hop_opt_dynamic {\n  value =:=\n    irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED hop_opt_0_replicate {\n  discriminator =:= '00000000' [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED hop_opt_1_replicate {\n  discriminator =:= '10000000'                     [ 8 ];\n  length        =:= irregular(8)                   [ 8 ];\n  value         =:=\n    irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED hop_opt_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// IPv6 Routing header\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_rout_opt\n{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value       [ length.UVALUE * 64 + 48 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  length      =:= static;\n  next_header =:= static;\n  value       =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED rout_opt_static {\n  next_header =:= irregular(8)                   [ 8 ];\n  length      =:= irregular(8)                   [ 8 ];\n  value       =:=\n    irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "COMPRESSED rout_opt_dynamic {\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED rout_opt_0_replicate {\n  discriminator =:= '00000000' [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED rout_opt_0_replicate {\n  discriminator =:= '10000000'                     [ 8 ];\n  length        =:= irregular(8)                   [ 8 ];\n  value         =:=\n    irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED rout_opt_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "////////////////////////////////////////////\n// GRE Header\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "optional_checksum(flag_value)\n{\n  UNCOMPRESSED {\n    value     [ 0, 16 ];\n    reserved1 [ 0, 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED cs_present {\n  value     =:= irregular(16)             [ 16 ];\n  reserved1 =:= uncompressed_value(16, 0) [ 0 ];\n  ENFORCE(flag_value == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED not_present {\n    value     =:= compressed_value(0, 0) [ 0 ];\n    reserved1 =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag_value == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "gre_proto\n{\n  UNCOMPRESSED {\n    protocol [ 16 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "COMPRESSED ether_v4 {\n  discriminator =:= compressed_value(1, 0)         [ 1 ];\n  protocol      =:= uncompressed_value(16, 0x0800) [ 0 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ether_v6 {\n    discriminator =:= compressed_value(1, 1)         [ 1 ];\n    protocol      =:= uncompressed_value(16, 0x86DD) [ 0 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "gre\n{\n  UNCOMPRESSED {\n    c_flag                                 [ 1 ];\n    r_flag    =:= uncompressed_value(1, 0) [ 1 ];\n    k_flag                                 [ 1 ];\n    s_flag                                 [ 1 ];\n    reserved0 =:= uncompressed_value(9, 0) [ 9 ];\n    version   =:= uncompressed_value(3, 0) [ 3 ];\n    protocol                               [ 16 ];\n    checksum_and_res                       [ 0, 32 ];\n    key                                    [ 0, 32 ];\n    sequence_number                        [ 0, 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  c_flag           =:= static;\n  k_flag           =:= static;\n  s_flag           =:= static;\n  protocol         =:= static;\n  key              =:= static;\n  sequence_number  =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED gre_static {\n  protocol =:= gre_proto                 [ 1 ];\n  c_flag   =:= irregular(1)              [ 1 ];\n  k_flag   =:= irregular(1)              [ 1 ];\n  s_flag   =:= irregular(1)              [ 1 ];\n  padding  =:= compressed_value(4, 0)    [ 4 ];\n  key      =:= optional32(k_flag.UVALUE) [ 0, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED gre_dynamic {\n  checksum_and_res =:=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    optional_checksum(c_flag.UVALUE)             [ 0, 16 ];\n  sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED gre_0_replicate {\n  discriminator    =:= '00000000'    [ 8 ];\n  checksum_and_res =:=\n    optional_checksum(c_flag.UVALUE) [ 0, 16 ];\n  sequence_number  =:=\n    optional32(s_flag.UVALUE)        [ 0, 8, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED gre_1_replicate {\n  discriminator    =:= '10000'                   [ 5 ];\n  c_flag           =:= irregular(1)              [ 1 ];\n  k_flag           =:= irregular(1)              [ 1 ];\n  s_flag           =:= irregular(1)              [ 1 ];\n  checksum_and_res =:=\n    optional_checksum(c_flag.UVALUE)             [ 0, 16 ];\n  key              =:= optional32(k_flag.UVALUE) [ 0, 32 ];\n  sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED gre_irregular {\n    checksum_and_res =:=\n      optional_checksum(c_flag.UVALUE) [ 0, 16 ];\n    sequence_number  =:=\n      opt_lsb_7_or_31(s_flag.UVALUE)   [ 0, 8, 32 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////\n// MINE header\n/////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "mine\n{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    s_bit       [ 1 ];\n    res_bits    [ 7 ];\n    checksum    [ 16 ];\n    orig_dest   [ 32 ];\n    orig_src    [ 0, 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  next_header =:= static;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  s_bit       =:= static;\n  res_bits    =:= static;\n  checksum    =:= inferred_mine_header_checksum;\n  orig_dest   =:= static;\n  orig_src    =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED mine_static {\n  next_header =:= irregular(8)             [ 8 ];\n  s_bit       =:= irregular(1)             [ 1 ];\n  // Reserved bits are included to achieve byte-alignment\n  res_bits    =:= irregular(7)             [ 7 ];\n  orig_dest   =:= irregular(32)            [ 32 ];\n  orig_src    =:= optional32(s_bit.UVALUE) [ 0, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED mine_dynamic {\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED mine_0_replicate {\n  discriminator =:= '00000000' [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED mine_1_replicate {\n  discriminator =:= '10000000'               [ 8 ];\n  s_bit         =:= irregular(1)             [ 1 ];\n  res_bits      =:= irregular(7)             [ 7 ];\n  orig_dest     =:= irregular(32)            [ 32 ];\n  orig_src      =:= optional32(s_bit.UVALUE) [ 0, 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED mine_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////\n// Authentication Header (AH)\n/////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ah\n{\n  UNCOMPRESSED {\n    next_header     [ 8 ];\n    length          [ 8 ];\n    res_bits        [ 16 ];\n    spi             [ 32 ];\n    sequence_number [ 32 ];\n    auth_data       [ length.UVALUE*32-32 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  next_header     =:= static;\n  length          =:= static;\n  res_bits        =:= static;\n  spi             =:= static;\n  sequence_number =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ah_static {\n  next_header =:= irregular(8)  [ 8 ];\n  length      =:= irregular(8)  [ 8 ];\n  spi         =:= irregular(32) [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ah_dynamic {\n  res_bits        =:= irregular(16) [ 16 ];\n  sequence_number =:= irregular(32) [ 32 ];\n  auth_data       =:=\n    irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ah_0_replicate {\n  discriminator   =:= '00000000'    [ 8 ];\n  sequence_number =:= irregular(32) [ 32 ];\n  auth_data       =:=\n    irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ah_1_replicate {\n  discriminator   =:= '10000000'    [ 8 ];\n  length          =:= irregular(8)  [ 8 ];\n  res_bits        =:= irregular(16) [ 16 ];\n  spi             =:= irregular(32) [ 32 ];\n  sequence_number =:= irregular(32) [ 32 ];\n  auth_data       =:=\n    irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ah_irregular {\n    sequence_number =:= lsb_7_or_31  [ 8, 32 ];\n    auth_data       =:=\n      irregular(length.UVALUE*32-32) [ length.UVALUE*32-32 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////",
      "ja": "//////////////////////////////////"
    },
    {
      "indent": 1,
      "text": "// ESP header (NULL encrypted) /////////////////////////////////////////////",
      "ja": "// espヘッダー（null暗号化）////////////////////////////////////"
    },
    {
      "indent": 1,
      "text": "// The value of the Next Header field from the trailer\n// part of the packet is passed as a parameter.\nesp_null(next_header_value)\n{\n  UNCOMPRESSED {\n    spi             [ 32 ];\n    sequence_number [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  nh_field [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  spi             =:= static;\n  sequence_number =:= static;\n  nh_field        =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED esp_static {\n  nh_field =:= compressed_value(8, next_header_value) [ 8 ];\n  spi      =:= irregular(32)                          [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED esp_dynamic {\n  sequence_number =:= irregular(32) [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED esp_0_replicate {\n  discriminator   =:= '00000000'    [ 8 ];\n  sequence_number =:= irregular(32) [ 32 ];\n}\nCOMPRESSED esp_1_replicate {\n  discriminator   =:= '10000000'    [ 8 ];\n  spi             =:= irregular(32) [ 32 ];\n  sequence_number =:= irregular(32) [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED esp_irregular {\n    sequence_number =:= lsb_7_or_31 [ 8, 32 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "///////////////////////////////////////////// // IPv6 Header",
      "ja": "/////////////////////////////////////// ipv6ヘッダー"
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////",
      "ja": "//////////////////////////////////"
    },
    {
      "indent": 1,
      "text": "fl_enc\n{\n  UNCOMPRESSED {\n    flow_label [ 20 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED fl_zero {\n  discriminator =:= '0'                       [ 1 ];\n  flow_label    =:= uncompressed_value(20, 0) [ 0 ];\n  reserved      =:= '0000'                    [ 4 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED fl_non_zero {\n    discriminator =:= '1'           [ 1 ];\n    flow_label    =:= irregular(20) [ 20 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// The is_innermost flag is true if this is the innermost IP header\n// If extracting the irregular chain for a compressed packet:\n//   - ttl_irregular_chain_flag must have the same value as it had when\n//     processing co_baseheader.\n//   - ip_inner_ecn is bound in this encoding method and the value that\n//     it gets bound to should be passed to the tcp encoding method\n//   For other formats than the irregular chain, these two are ignored\nipv6(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn)\n{\n  UNCOMPRESSED {\n    version         =:= uncompressed_value(4, 6) [ 4 ];\n    dscp                                         [ 6 ];\n    ip_ecn_flags                                 [ 2 ];\n    flow_label                                   [ 20 ];\n    payload_length                               [ 16 ];\n    next_header                                  [ 8 ];\n    ttl_hopl                                     [ 8 ];\n    src_addr                                     [ 128 ];\n    dst_addr                                     [ 128 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  dscp           =:= static;\n  ip_ecn_flags   =:= static;\n  flow_label     =:= static;\n  payload_length =:= inferred_ip_v6_length;\n  next_header    =:= static;\n  ttl_hopl       =:= static;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  src_addr       =:= static;\n  dst_addr       =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv6_static {\n  version_flag =:= '1'            [ 1 ];\n  reserved     =:= '00'           [ 2 ];\n  flow_label   =:= fl_enc         [ 5, 21 ];\n  next_header  =:= irregular(8)   [ 8 ];\n  src_addr     =:= irregular(128) [ 128 ];\n  dst_addr     =:= irregular(128) [ 128 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv6_dynamic {\n  dscp         =:= irregular(6) [ 6 ];\n  ip_ecn_flags =:= irregular(2) [ 2 ];\n  ttl_hopl     =:= irregular(8) [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv6_replicate {\n  dscp         =:= irregular(6) [ 6 ];\n  ip_ecn_flags =:= irregular(2) [ 2 ];\n  reserved     =:= '000'        [ 3 ];\n  flow_label   =:= fl_enc       [ 5, 21 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv6_outer_without_ttl_irregular {\n  dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];\n  ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n  ENFORCE(ttl_irregular_chain_flag == 0);\n  ENFORCE(is_innermost == false);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv6_outer_with_ttl_irregular {\n  dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];\n  ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n  ttl_hopl     =:= irregular(8)                        [ 8 ];\n  ENFORCE(ttl_irregular_chain_flag == 1);\n  ENFORCE(is_innermost == false);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ipv6_innermost_irregular {\n    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);\n    ENFORCE(is_innermost == true);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////",
      "ja": "//////////////////////////////////"
    },
    {
      "indent": 1,
      "text": "// IPv4 Header /////////////////////////////////////////////",
      "ja": "// ipv4ヘッダー///////////////////////////////////////////////"
    },
    {
      "indent": 1,
      "text": "ip_id_enc_dyn(behavior)\n{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ip_id_seq {\n  ip_id =:= irregular(16) [ 16 ];\n  ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED) ||\n          (behavior == IP_ID_BEHAVIOR_RANDOM));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ip_id_zero {\n    ip_id =:= uncompressed_value(16, 0) [ 0 ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_id_enc_irreg(behavior)\n{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ip_id_seq {\n  ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ip_id_seq_swapped {\n  ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n}\nCOMPRESSED ip_id_rand {\n  ip_id =:= irregular(16) [ 16 ];\n  ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ip_id_zero {\n    ip_id =:= uncompressed_value(16, 0) [ 0 ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_id_behavior_choice(is_inner) {",
      "ja": "ip_id_behavior_choice（is_inner）{"
    },
    {
      "indent": 3,
      "text": "UNCOMPRESSED {\n  behavior [ 2 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  behavior =:= irregular(2);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sequential {\n  behavior [ 2 ];\n  ENFORCE(is_inner == true);\n  ENFORCE(behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sequential_swapped {\n  behavior [ 2 ];\n  ENFORCE(is_inner == true);\n  ENFORCE(behavior.UVALUE ==\n          IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED random {\n  behavior [ 2 ];\n  ENFORCE(behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED zero {\n    behavior [ 2 ];\n    ENFORCE(behavior.UVALUE == IP_ID_BEHAVIOR_ZERO);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// The is_innermost flag is true if this is the innermost IP header\n// If extracting the irregular chain for a compressed packet:\n//   - ttl_irregular_chain_flag must have the same value as it had when\n//     processing co_baseheader.\n//   - ip_inner_ecn is bound in this encoding method and the value that\n//     it gets bound to should be passed to the tcp encoding method\n//   For other formats than the irregular chain, these two are ignored\nipv4(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn)\n{\n  UNCOMPRESSED {\n    version        =:= uncompressed_value(4, 4)  [ 4 ];\n    hdr_length     =:= uncompressed_value(4, 5)  [ 4 ];\n    dscp                                         [ 6 ];\n    ip_ecn_flags                                 [ 2 ];\n    length                                       [ 16 ];\n    ip_id                                        [ 16 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  rf             =:= uncompressed_value(1, 0)  [ 1 ];\n  df                                           [ 1 ];\n  mf             =:= uncompressed_value(1, 0)  [ 1 ];\n  frag_offset    =:= uncompressed_value(13, 0) [ 13 ];\n  ttl_hopl                                     [ 8 ];\n  protocol                                     [ 8 ];\n  checksum                                     [ 16 ];\n  src_addr                                     [ 32 ];\n  dst_addr                                     [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  ip_id_behavior [ 2 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  dscp           =:= static;\n  ip_ecn_flags   =:= static;\n  length         =:= inferred_ip_v4_length;\n  df             =:= static;\n  ttl_hopl       =:= static;\n  protocol       =:= static;\n  checksum       =:= inferred_ip_v4_header_checksum;\n  src_addr       =:= static;\n  dst_addr       =:= static;\n  ip_id_behavior =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv4_static {\n  version_flag =:= '0'           [ 1 ];\n  reserved     =:= '0000000'     [ 7 ];\n  protocol     =:= irregular(8)  [ 8 ];\n  src_addr     =:= irregular(32) [ 32 ];\n  dst_addr     =:= irregular(32) [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv4_dynamic {\n  reserved       =:= '00000'             [ 5 ];\n  df             =:= irregular(1)        [ 1 ];\n  ip_id_behavior =:= ip_id_behavior_choice(is_innermost) [ 2 ];\n  dscp           =:= irregular(6)        [ 6 ];\n  ip_ecn_flags   =:= irregular(2)        [ 2 ];\n  ttl_hopl       =:= irregular(8)        [ 8 ];\n  ip_id          =:=\n    ip_id_enc_dyn(ip_id_behavior.UVALUE) [ 0, 16 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv4_replicate {",
      "ja": "圧縮IPv4_Replicate {"
    },
    {
      "indent": 3,
      "text": "  reserved       =:= '0000'              [ 4 ];\n  ip_id_behavior =:= ip_id_behavior_choice(is_innermost) [ 2 ];\n  ttl_flag       =:= irregular(1)        [ 1 ];\n  df             =:= irregular(1)        [ 1 ];\n  dscp           =:= irregular(6)        [ 6 ];\n  ip_ecn_flags   =:= irregular(2)        [ 2 ];\n  ip_id          =:=\n    ip_id_enc_dyn(ip_id_behavior.UVALUE) [ 0, 16 ];\n  ttl_hopl     =:=\n      static_or_irreg(ttl_flag.UVALUE, 8) [ 0, 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv4_outer_without_ttl_irregular {\n  ip_id        =:=\n    ip_id_enc_irreg(ip_id_behavior.UVALUE) [ 0, 16 ];\n  dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];\n  ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n  ENFORCE(ttl_irregular_chain_flag == 0);\n  ENFORCE(is_innermost == false);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ipv4_outer_with_ttl_irregular {\n  ip_id        =:=\n    ip_id_enc_irreg(ip_id_behavior.UVALUE)             [ 0, 16 ];\n  dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];\n  ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n  ttl_hopl     =:= irregular(8)                        [ 8 ];\n  ENFORCE(is_innermost == false);\n  ENFORCE(ttl_irregular_chain_flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ipv4_innermost_irregular {\n    ip_id          =:=\n      ip_id_enc_irreg(ip_id_behavior.UVALUE) [ 0, 16 ];\n    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);\n    ENFORCE(is_innermost == true);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////\n// TCP Options\n/////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// nbits is bound to the remaining length (in bits) of TCP\n// options, including the EOL type byte.\ntcp_opt_eol(nbits)\n{\n  UNCOMPRESSED {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  type     =:= uncompressed_value(8, 0) [ 8 ];\n  padding  =:=\n    uncompressed_value(nbits-8, 0)      [ nbits-8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  pad_len [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED eol_list_item {\n  pad_len =:= compressed_value(8, nbits-8) [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED eol_irregular {\n    pad_len =:= static;\n    ENFORCE(nbits-8 == pad_len.UVALUE);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_opt_nop\n{\n  UNCOMPRESSED {\n    type =:= uncompressed_value(8, 1) [ 8 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED nop_list_item {\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED nop_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_opt_mss\n{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 2) [ 8 ];\n    length =:= uncompressed_value(8, 4) [ 8 ];\n    mss                                 [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED mss_list_item {\n  mss =:= irregular(16) [ 16 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED mss_irregular {\n    mss    =:= static;\n  }\n}\n tcp_opt_wscale\n{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 3) [ 8 ];\n    length =:= uncompressed_value(8, 3) [ 8 ];\n    wscale                              [ 8 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED wscale_list_item {\n  wscale =:= irregular(8) [ 8 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED wscale_irregular {\n    wscale =:= static;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ts_lsb\n{\n  UNCOMPRESSED {\n    tsval [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tsval_7 {\n  discriminator =:= '0'        [ 1 ];\n  tsval         =:= lsb(7, -1) [ 7 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tsval_14 {\n  discriminator =:= '10'        [ 2 ];\n  tsval         =:= lsb(14, -1) [ 14 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tsval_21 {\n  discriminator =:= '110'               [ 3 ];\n  tsval         =:= lsb(21, 0x00040000) [ 21 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED tsval_29 {\n    discriminator =:= '111'               [ 3 ];\n    tsval         =:= lsb(29, 0x04000000) [ 29 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_opt_ts\n{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 8)  [ 8 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  length =:= uncompressed_value(8, 10) [ 8 ];\n  tsval                                [ 32 ];\n  tsecho                               [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tsopt_list_item {\n  tsval  =:= irregular(32) [ 32 ];\n  tsecho =:= irregular(32) [ 32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED tsopt_irregular {\n    tsval  =:= ts_lsb [ 8, 16, 24, 32 ];\n    tsecho =:= ts_lsb [ 8, 16, 24, 32 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "sack_var_length_enc(base)\n{\n  UNCOMPRESSED {\n    sack_field [ 32 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  sack_offset [ 32 ];\n  ENFORCE(sack_offset.UVALUE == (sack_field.UVALUE - base));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_15 {\n  discriminator =:= '0'         [ 1 ];\n  sack_offset   =:= lsb(15, -1) [ 15 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED lsb_22 {\n  discriminator =:= '10'        [ 2 ];\n  sack_offset   =:= lsb(22, -1) [ 22 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED lsb_30 {\n    discriminator =:= '11'        [ 2 ];\n    sack_offset   =:= lsb(30, -1) [ 30 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "sack_block(prev_block_end)\n{\n  UNCOMPRESSED {\n    block_start [ 32 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " block_end [ 32 ]; }",
      "ja": "block_end [32];}"
    },
    {
      "indent": 1,
      "text": "  COMPRESSED {\n    block_start =:=\n      sack_var_length_enc(prev_block_end) [ 16, 24, 32 ];\n    block_end   =:=\n      sack_var_length_enc(block_start)    [ 16, 24, 32 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// The value of the parameter is set to the ack_number value // of the TCP header tcp_opt_sack(ack_value) {",
      "ja": "//パラメーターの値は、TCPヘッダーTCP_OPT_SACK（ACK_VALUE）のACK_Number値に設定されています{"
    },
    {
      "indent": 3,
      "text": "UNCOMPRESSED {\n  type    =:= uncompressed_value(8, 5) [ 8 ];\n  length                               [ 8 ];\n  block_1                              [ 64 ];\n  block_2                              [ 0, 64 ];\n  block_3                              [ 0, 64 ];\n  block_4                              [ 0, 64 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  length  =:= static;\n  block_2 =:= uncompressed_value(0, 0);\n  block_3 =:= uncompressed_value(0, 0);\n  block_4 =:= uncompressed_value(0, 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack1_list_item {\n  discriminator =:= '00000001';\n  block_1       =:= sack_block(ack_value);\n  ENFORCE(length.UVALUE == 10);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack2_list_item {\n  discriminator =:= '00000010';\n  block_1       =:= sack_block(ack_value);\n  block_2       =:= sack_block(block_1_end.UVALUE);\n  ENFORCE(length.UVALUE == 18);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack3_list_item {\n  discriminator =:= '00000011';\n  block_1       =:= sack_block(ack_value);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  block_2       =:= sack_block(block_1_end.UVALUE);\n  block_3       =:= sack_block(block_2_end.UVALUE);\n  ENFORCE(length.UVALUE == 26);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack4_list_item {\n  discriminator =:= '00000100';\n  block_1       =:= sack_block(ack_value);\n  block_2       =:= sack_block(block_1_end.UVALUE);\n  block_3       =:= sack_block(block_2_end.UVALUE);\n  block_4       =:= sack_block(block_3_end.UVALUE);\n  ENFORCE(length.UVALUE == 34);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack_unchanged_irregular {\n  discriminator =:= '00000000';\n  block_1       =:= static;\n  block_2       =:= static;\n  block_3       =:= static;\n  block_4       =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack1_irregular {\n  discriminator =:= '00000001';\n  block_1       =:= sack_block(ack_value);\n  ENFORCE(length.UVALUE == 10);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack2_irregular {\n  discriminator =:= '00000010';\n  block_1       =:= sack_block(ack_value);\n  block_2       =:= sack_block(block_1_end.UVALUE);\n  ENFORCE(length.UVALUE == 18);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack3_irregular {\n  discriminator =:= '00000011';\n  block_1       =:= sack_block(ack_value);\n  block_2       =:= sack_block(block_1_end.UVALUE);\n  block_3       =:= sack_block(block_2_end.UVALUE);\n  ENFORCE(length.UVALUE == 26);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack4_irregular {\n  discriminator =:= '00000100';\n  block_1       =:= sack_block(ack_value);\n  block_2       =:= sack_block(block_1_end.UVALUE);\n  block_3       =:= sack_block(block_2_end.UVALUE);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "    block_4       =:= sack_block(block_3_end.UVALUE);\n    ENFORCE(length.UVALUE == 34);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_opt_sack_permitted\n{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 4) [ 8 ];\n    length =:= uncompressed_value(8, 2) [ 8 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED sack_permitted_list_item {\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED sack_permitted_irregular {\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_opt_generic\n{\n  UNCOMPRESSED {\n    type                                    [ 8 ];\n    length_msb =:= uncompressed_value(1, 0) [ 1 ];\n    length_lsb                              [ 7 ];\n    contents                           [ length_len.UVALUE*8-16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  option_static [ 1 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  type       =:= static;\n  length_lsb =:= static;\n  contents   =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED generic_list_item {\n  type          =:= irregular(8)      [ 8 ];\n  option_static =:= one_bit_choice    [ 1 ];\n  length_lsb    =:= irregular(7)      [ 7 ];\n  contents      =:=\n    irregular(length_lsb.UVALUE*8-16) [ length_len.UVALUE*8-16 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Used when context of option has option_static set to one COMPRESSED generic_static_irregular {",
      "ja": "//オプションのコンテキストがOption_staticが1つの圧縮generic_static_ir Regular {に設定されている場合に使用されます{"
    },
    {
      "indent": 3,
      "text": "  ENFORCE(option_static.UVALUE == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// An item that can change, but currently is unchanged\nCOMPRESSED generic_stable_irregular {\n  discriminator =:= '11111111' [ 8 ];\n  ENFORCE(option_static.UVALUE == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  // An item that is assumed to change constantly.\n  // Length is not allowed to change here, since a length change is\n  // most likely to cause new NOPs or an EOL length change.\n  COMPRESSED generic_full_irregular {\n    discriminator =:= '00000000'        [ 8 ];\n    contents      =:=\n      irregular(length_lsb.UVALUE*8-16) [ length_lsb.UVALUE*8-16 ];\n    ENFORCE(option_static.UVALUE == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_list_presence_enc(presence)\n{\n  UNCOMPRESSED {\n    tcp_options;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED list_not_present {\n  tcp_options =:= static [ 0 ];\n  ENFORCE(presence == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED list_present {\n    tcp_options =:= list_tcp_options [ VARIABLE ];\n    ENFORCE(presence == 1);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "/////////////////////////////////////////////\n// TCP Header\n/////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "port_replicate(flags)\n{\n  UNCOMPRESSED {\n    port [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED port_static_enc {",
      "ja": "圧縮port_static_enc {"
    },
    {
      "indent": 3,
      "text": "  port =:= static [ 0 ];\n  ENFORCE(flags == 0b00);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED port_lsb8 {\n  port =:= lsb(8, 64) [ 8 ];\n  ENFORCE(flags == 0b01);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED port_irr_enc {\n    port =:= irregular(16) [ 16 ];\n    ENFORCE(flags == 0b10);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "tcp_irreg_ip_ecn(ip_inner_ecn)\n{\n  UNCOMPRESSED {\n    ip_ecn_flags [ 2 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED ecn_present {\n  // This field does not exist in the uncompressed header\n  // and therefore cannot use uncompressed_value.\n  ip_ecn_flags =:=\n    compressed_value(2, ip_inner_ecn) [ 2 ];\n  ENFORCE(ecn_used.UVALUE == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED ecn_not_present {\n    ip_ecn_flags =:= static [ 0 ];\n    ENFORCE(ecn_used.UVALUE == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "rsf_index_enc\n{\n  UNCOMPRESSED {\n    rsf_flag [ 3 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED none {\n  rsf_idx  =:= '00' [ 2 ];\n  rsf_flag =:= uncompressed_value(3, 0x00);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED rst_only {\n  rsf_idx  =:= '01' [ 2 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  rsf_flag =:= uncompressed_value(3, 0x04);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED syn_only {\n  rsf_idx  =:= '10' [ 2 ];\n  rsf_flag =:= uncompressed_value(3, 0x02);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED fin_only {\n    rsf_idx  =:= '11' [ 2 ];\n    rsf_flag =:= uncompressed_value(3, 0x01);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "optional_2bit_padding(used_flag)\n{\n  UNCOMPRESSED {\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED used {\n  padding =:= compressed_value(2, 0x0) [ 2 ];\n  ENFORCE(used_flag == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED unused {\n    padding =:= compressed_value(0, 0x0);\n    ENFORCE(used_flag == 0);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// ack_stride_value is the user-selected stride for scaling the\n// TCP ack_number\n// ip_inner_ecn is the value bound when processing the innermost\n// IP header (ipv4 or ipv6 encoding method)\ntcp(payload_size, ack_stride_value, ip_inner_ecn)\n{\n  UNCOMPRESSED {\n    src_port      [ 16 ];\n    dst_port      [ 16 ];\n    seq_number    [ 32 ];\n    ack_number    [ 32 ];\n    data_offset   [ 4 ];\n    tcp_res_flags [ 4 ];\n    tcp_ecn_flags [ 2 ];\n    urg_flag      [ 1 ];\n    ack_flag      [ 1 ];\n    psh_flag      [ 1 ];\n    rsf_flags     [ 3 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  window        [ 16 ];\n  checksum      [ 16 ];\n  urg_ptr       [ 16 ];\n  options       [ (data_offset.UVALUE-5)*32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {\n  seq_number_scaled                    [ 32 ];\n  seq_number_residue =:=\n      field_scaling(payload_size, seq_number_scaled.UVALUE,\n                    seq_number.UVALUE) [ 32 ];\n  ack_stride                           [ 16 ];\n  ack_number_scaled                    [ 32 ];\n  ack_number_residue =:=\n      field_scaling(ack_stride.UVALUE, ack_number_scaled.UVALUE,\n                    ack_number.UVALUE) [ 32 ];\n  ENFORCE(ack_stride.UVALUE == ack_stride_value);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INITIAL {\n  ack_stride     =:= uncompressed_value(16, 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  src_port      =:= static;\n  dst_port      =:= static;\n  seq_number    =:= static;\n  ack_number    =:= static;\n  data_offset   =:= inferred_offset;\n  tcp_res_flags =:= static;\n  tcp_ecn_flags =:= static;\n  urg_flag      =:= static;\n  ack_flag      =:= uncompressed_value(1, 1);\n  rsf_flags     =:= uncompressed_value(3, 0);\n  window        =:= static;\n  urg_ptr       =:= static;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tcp_static {\n  src_port =:= irregular(16) [ 16 ];\n  dst_port =:= irregular(16) [ 16 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tcp_dynamic {\n  ecn_used        =:= one_bit_choice          [ 1 ];\n  ack_stride_flag =:= irregular(1)            [ 1 ];\n  ack_zero        =:= irregular(1)            [ 1 ];\n  urp_zero        =:= irregular(1)            [ 1 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  tcp_res_flags   =:= irregular(4)            [ 4 ];\n  tcp_ecn_flags   =:= irregular(2)            [ 2 ];\n  urg_flag        =:= irregular(1)            [ 1 ];\n  ack_flag        =:= irregular(1)            [ 1 ];\n  psh_flag        =:= irregular(1)            [ 1 ];\n  rsf_flags       =:= irregular(3)            [ 3 ];\n  msn             =:= irregular(16)           [ 16 ];\n  seq_number      =:= irregular(32)           [ 32 ];\n  ack_number      =:=\n    zero_or_irreg(ack_zero.CVALUE, 32)        [ 0, 32 ];\n  window          =:= irregular(16)           [ 16 ];\n  checksum        =:= irregular(16)           [ 16 ];\n  urg_ptr         =:=\n    zero_or_irreg(urp_zero.CVALUE, 16)        [ 0, 16 ];\n  ack_stride      =:=\n    static_or_irreg(ack_stride_flag.CVALUE, 16) [ 0, 16 ];\n  options         =:= list_tcp_options        [ VARIABLE ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED tcp_replicate {\n  reserved          =:= '0'                      [ 1 ];\n  window_presence   =:= irregular(1)             [ 1 ];\n  list_present      =:= irregular(1)             [ 1 ];\n  src_port_presence =:= irregular(2)             [ 2 ];\n  dst_port_presence =:= irregular(2)             [ 2 ];\n  ack_stride_flag   =:= irregular(1)             [ 1 ];\n  ack_presence      =:= irregular(1)             [ 1 ];\n  urp_presence      =:= irregular(1)             [ 1 ];\n  urg_flag          =:= irregular(1)             [ 1 ];\n  ack_flag          =:= irregular(1)             [ 1 ];\n  psh_flag          =:= irregular(1)             [ 1 ];\n  rsf_flags         =:= rsf_index_enc            [ 2 ];\n  ecn_used          =:= one_bit_choice           [ 1 ];\n  msn               =:= irregular(16)            [ 16 ];\n  seq_number        =:= irregular(32)            [ 32 ];\n  src_port          =:=\n    port_replicate(src_port_presence)      [ 0, 8, 16 ];\n  dst_port          =:=\n    port_replicate(dst_port_presence)      [ 0, 8, 16 ];\n  window            =:=\n    static_or_irreg(window_presence, 16)   [ 0, 16 ];\n  urg_point         =:=\n    static_or_irreg(urp_presence, 16)    [ 0, 16 ];\n  ack_number        =:=\n    static_or_irreg(ack_presence, 32)    [ 0, 32 ];\n  ecn_padding       =:=\n    optional_2bit_padding(ecn_used.CVALUE)     [ 0, 2 ];\n  tcp_res_flags =:=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    static_or_irreg(ecn_used.CVALUE, 4)        [ 0, 4 ];\n  tcp_ecn_flags     =:=\n    static_or_irreg(ecn_used.CVALUE, 2)        [ 0, 2 ];\n  checksum          =:= irregular(16)            [ 16 ];\n  ack_stride        =:=\n    static_or_irreg(ack_stride_flag.CVALUE, 16)  [ 0, 16 ];\n  options           =:=\n    tcp_list_presence_enc(list_present.CVALUE) [ VARIABLE ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED tcp_irregular {\n    ip_ecn_flags  =:= tcp_irreg_ip_ecn(ip_inner_ecn)  [ 0, 2 ];\n    tcp_res_flags =:=\n      static_or_irreg(ecn_used.CVALUE, 4)            [ 0, 4 ];\n    tcp_ecn_flags =:=\n      static_or_irreg(ecn_used.CVALUE, 2)             [ 0, 2 ];\n    checksum      =:= irregular(16)                   [ 16 ];\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "///////////////////////////////////////////////////\n// Encoding methods used in compressed base headers\n///////////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "dscp_enc(flag)\n{\n  UNCOMPRESSED {\n    dscp [ 6 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED static_enc {\n  dscp =:= static [ 0 ];\n  ENFORCE(flag == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED irreg {\n    dscp    =:= irregular(6)           [ 6 ];\n    padding =:= compressed_value(2, 0) [ 2 ];\n    ENFORCE(flag == 1);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "ip_id_lsb(behavior, k, p)\n{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n   CONTROL {\n    ip_id_offset [ 16 ];\n    ip_id_nbo    [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED nbo {\n  ip_id_offset =:= lsb(k, p) [ k ];\n  ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL);\n  ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED non_nbo {\n    ip_id_offset =:= lsb(k, p) [ k ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n    ENFORCE(ip_id_nbo.UVALUE ==\n            (ip_id.UVALUE / 256) + (ip_id.UVALUE % 256) * 256);\n    ENFORCE(ip_id_nbo.ULENGTH == 16);\n    ENFORCE(ip_id_offset.UVALUE == ip_id_nbo.UVALUE - msn.UVALUE);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "optional_ip_id_lsb(behavior, indicator)\n{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED short {\n  ip_id =:= ip_id_lsb(behavior, 8, 3) [ 8 ];\n  ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  ENFORCE(indicator == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED long {\n  ip_id =:= irregular(16)  [ 16 ];\n  ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  ENFORCE(indicator == 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED not_present {\n    ENFORCE((behavior == IP_ID_BEHAVIOR_RANDOM) ||\n            (behavior == IP_ID_BEHAVIOR_ZERO));\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "dont_fragment(version)",
      "ja": "dont_fragment（バージョン）"
    },
    {
      "indent": 1,
      "text": "{\n  UNCOMPRESSED {\n    df [ 1 ];\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED v4 {\n  df =:= irregular(1) [ 1 ];\n  ENFORCE(version == 4);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  COMPRESSED v6 {\n    df =:= compressed_value(1, 0) [ 1 ];\n    ENFORCE(version == 6);\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "//////////////////////////////////\n// Actual start of compressed packet formats\n// Important note:\n//   The base header is the compressed representation\n//   of the innermost IP header AND the TCP header.\n//////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "// ttl_irregular_chain_flag is set by the user if the TTL/Hop Limit\n// of an outer header has changed.  The same value must be passed as\n// an argument to the ipv4/ipv6 encoding methods when extracting\n// the irregular chain items.\nco_baseheader(payload_size, ack_stride_value,\n              ttl_irregular_chain_flag)\n{\n  UNCOMPRESSED v4 {\n    outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    version        =:= uncompressed_value(4, 4)        [ 4 ];\n    header_length  =:= uncompressed_value(4, 5)        [ 4 ];\n    dscp                                               [ 6 ];\n    ip_ecn_flags                                       [ 2 ];\n    length                                             [ 16 ];\n    ip_id                                              [ 16 ];\n    rf             =:= uncompressed_value(1, 0)        [ 1 ];\n    df                                                 [ 1 ];\n    mf             =:= uncompressed_value(1, 0)        [ 1 ];\n    frag_offset    =:= uncompressed_value(13, 0)       [ 13 ];\n    ttl_hopl                                           [ 8 ];\n    next_header                                        [ 8 ];\n    checksum                                           [ 16 ];\n    src_addr                                           [ 32 ];\n    dest_addr                                          [ 32 ];\n    extension_headers =:= baseheader_extension_headers [ VARIABLE ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  src_port                                           [ 16 ];\n  dest_port                                          [ 16 ];\n  seq_number                                         [ 32 ];\n  ack_number                                         [ 32 ];\n  data_offset                                        [ 4 ];\n  tcp_res_flags                                      [ 4 ];\n  tcp_ecn_flags                                      [ 2 ];\n  urg_flag                                           [ 1 ];\n  ack_flag                                           [ 1 ];\n  psh_flag                                           [ 1 ];\n  rsf_flags                                          [ 3 ];\n  window                                             [ 16 ];\n  tcp_checksum                                       [ 16 ];\n  urg_ptr                                            [ 16 ];\n  options                           [ (data_offset.UVALUE-5)*32 ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "UNCOMPRESSED v6 {\n  outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n  version =:= uncompressed_value(4, 6)               [ 4 ];\n  dscp                                               [ 6 ];\n  ip_ecn_flags                                       [ 2 ];\n  flow_label                                         [ 20 ];\n  payload_length                                     [ 16 ];\n  next_header                                        [ 8 ];\n  ttl_hopl                                           [ 8 ];\n  src_addr                                           [ 128 ];\n  dest_addr                                          [ 128 ];\n  extension_headers =:= baseheader_extension_headers [ VARIABLE ];\n  src_port                                           [ 16 ];\n  dest_port                                          [ 16 ];\n  seq_number                                         [ 32 ];\n  ack_number                                         [ 32 ];\n  data_offset                                        [ 4 ];\n  tcp_res_flags                                      [ 4 ];\n  tcp_ecn_flags                                      [ 2 ];\n  urg_flag                                           [ 1 ];\n  ack_flag                                           [ 1 ];\n  psh_flag                                           [ 1 ];\n  rsf_flags                                          [ 3 ];\n  window                                             [ 16 ];\n  tcp_checksum                                       [ 16 ];\n  urg_ptr                                            [ 16 ];\n  options                           [ (data_offset.UVALUE-5)*32 ];\n  ENFORCE(ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CONTROL {",
      "ja": "コントロール {"
    },
    {
      "indent": 3,
      "text": "  ip_id_behavior                       [ 2 ];\n  seq_number_scaled                    [ 32 ];\n  seq_number_residue =:=\n      field_scaling(payload_size, seq_number_scaled.UVALUE,\n                    seq_number.UVALUE) [ 32 ];\n  ack_stride                           [ 16 ];\n  ack_number_scaled                    [ 32 ];\n  ack_number_residue =:=\n      field_scaling(ack_stride.UVALUE, ack_number_scaled.UVALUE,\n                    ack_number.UVALUE) [ 32 ];\n  ENFORCE(ack_stride_value == ack_stride.UVALUE);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INITIAL {\n  ack_stride     =:= uncompressed_value(16, 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFAULT {\n  tcp_ecn_flags  =:= static;\n  data_offset    =:= inferred_offset;\n  tcp_res_flags  =:= static;\n  rsf_flags      =:= uncompressed_value(3, 0);\n  dest_port      =:= static;\n  dscp           =:= static;\n  src_port       =:= static;\n  urg_flag       =:= uncompressed_value(1, 0);\n  window         =:= static;\n  dest_addr      =:= static;\n  version        =:= static;\n  ttl_hopl       =:= static;\n  src_addr       =:= static;\n  df             =:= static;\n  ack_number     =:= static;\n  urg_ptr        =:= static;\n  seq_number     =:= static;\n  ack_flag       =:= uncompressed_value(1, 1);\n  // The default for \"options\" is case 2) and 3) from\n  // the list in section 6.3.1 (i.e. nothing present in the\n  // baseheader itself).\n  payload_length =:= inferred_ip_v6_length;\n  checksum       =:= inferred_ip_v4_header_checksum;\n  length         =:= inferred_ip_v4_length;\n  flow_label     =:= static;\n  next_header    =:= static;\n  ip_ecn_flags   =:= static;\n  // The tcp_checksum has no default,\n  // it is considered a part of tcp_irregular\n  ip_id_behavior =:= static;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ecn_used       =:= static;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  // Default is to have no TTL in irregular chain\n  // Can only be nonzero if co_common is used\n  ENFORCE(ttl_irregular_chain_flag == 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "////////////////////////////////////////////\n// Common compressed packet format\n////////////////////////////////////////////",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COMPRESSED co_common {\n  discriminator        =:= '1111101'                [ 7 ];\n  ttl_hopl_outer_flag  =:=\n      compressed_value(1, ttl_irregular_chain_flag) [ 1 ];\n  ack_flag             =:= irregular(1)             [ 1 ];\n  psh_flag             =:= irregular(1)             [ 1 ];\n  rsf_flags            =:= rsf_index_enc            [ 2 ];\n  msn                  =:= lsb(4, 4)                [ 4 ];\n  seq_indicator        =:= irregular(2)             [ 2 ];\n  ack_indicator        =:= irregular(2)             [ 2 ];\n  ack_stride_indicator =:= irregular(1)             [ 1 ];\n  window_indicator     =:= irregular(1)             [ 1 ];\n  ip_id_indicator      =:= irregular(1)             [ 1 ];\n  urg_ptr_present      =:= irregular(1)             [ 1 ];\n  reserved             =:= compressed_value(1, 0)   [ 1 ];\n  ecn_used             =:= one_bit_choice           [ 1 ];\n  dscp_present         =:= irregular(1)             [ 1 ];\n  ttl_hopl_present     =:= irregular(1)             [ 1 ];\n  list_present         =:= irregular(1)             [ 1 ];\n  ip_id_behavior       =:= ip_id_behavior_choice(true)     [ 2 ];\n  urg_flag             =:= irregular(1)             [ 1 ];\n  df                   =:= dont_fragment(version.UVALUE)   [ 1 ];\n  header_crc           =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n  seq_number           =:=\n    variable_length_32_enc(seq_indicator.CVALUE) [ 0, 8, 16, 32 ];\n  ack_number           =:=\n    variable_length_32_enc(ack_indicator.CVALUE) [ 0, 8, 16, 32 ];\n  ack_stride           =:=\n    static_or_irreg(ack_stride_indicator.CVALUE, 16)  [ 0, 16 ];\n  window               =:=\n    static_or_irreg(window_indicator.CVALUE, 16)      [ 0, 16 ];\n  ip_id                =:=\n    optional_ip_id_lsb(ip_id_behavior.UVALUE,\n                       ip_id_indicator.CVALUE)      [ 0, 8, 16 ];\n  urg_ptr              =:=\n    static_or_irreg(urg_ptr_present.CVALUE, 16)     [ 0, 16 ];\n  dscp                 =:=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    dscp_enc(dscp_present.CVALUE)                   [ 0, 8 ];\n  ttl_hopl             =:=\n    static_or_irreg(ttl_hopl_present.CVALUE, 8)     [ 0, 8 ];\n  options              =:=\n    tcp_list_presence_enc(list_present.CVALUE)      [ VARIABLE ];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send LSBs of sequence number\nCOMPRESSED rnd_1 {\n  discriminator =:= '101110'                        [ 6 ];\n  seq_number    =:= lsb(18, 65535)                  [ 18 ];\n  msn           =:= lsb(4, 4)                       [ 4 ];\n  psh_flag      =:= irregular(1)                    [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send scaled sequence number LSBs\nCOMPRESSED rnd_2 {\n  discriminator      =:= '1100'                          [ 4 ];\n  seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];\n  msn                =:= lsb(4, 4)                       [ 4 ];\n  psh_flag           =:= irregular(1)                    [ 1 ];\n  header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE(payload_size != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send acknowledgment number LSBs\nCOMPRESSED rnd_3 {\n  discriminator =:= '0'                             [ 1 ];\n  ack_number    =:= lsb(15, 8191)                   [ 15 ];\n  msn           =:= lsb(4, 4)                       [ 4 ];\n  psh_flag      =:= irregular(1)                    [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send acknowledgment number scaled\nCOMPRESSED rnd_4 {\n  discriminator      =:= '1101'                          [ 4 ];\n  ack_number_scaled  =:= lsb(4, 3)                       [ 4 ];\n  msn                =:= lsb(4, 4)                       [ 4 ];\n  psh_flag           =:= irregular(1)                    [ 1 ];\n  header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  ENFORCE(ack_stride.UVALUE != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send ACK and sequence number\nCOMPRESSED rnd_5 {\n  discriminator =:= '100'                           [ 3 ];\n  psh_flag      =:= irregular(1)                    [ 1 ];\n  msn           =:= lsb(4, 4)                       [ 4 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  seq_number    =:= lsb(14, 8191)                   [ 14 ];\n  ack_number    =:= lsb(15, 8191)                   [ 15 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send both ACK and scaled sequence number LSBs\nCOMPRESSED rnd_6 {\n  discriminator      =:= '1010'                          [ 4 ];\n  header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  psh_flag           =:= irregular(1)                    [ 1 ];\n  ack_number         =:= lsb(16, 16383)                  [ 16 ];\n  msn                =:= lsb(4, 4)                       [ 4 ];\n  seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];\n  ENFORCE(payload_size != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send ACK and window\nCOMPRESSED rnd_7 {\n  discriminator =:= '101111'                        [ 6 ];\n  ack_number    =:= lsb(18, 65535)                  [ 18 ];\n  window        =:= irregular(16)                   [ 16 ];\n  msn           =:= lsb(4, 4)                       [ 4 ];\n  psh_flag      =:= irregular(1)                    [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// An extended packet type for seldom-changing fields\n// Can send LSBs of TTL, RSF flags, change ECN behavior, and\n// options list\nCOMPRESSED rnd_8 {\n  discriminator =:= '10110'                         [ 5 ];\n  rsf_flags     =:= rsf_index_enc                   [ 2 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  list_present  =:= irregular(1)                    [ 1 ];\n  header_crc    =:= crc7(THIS.UVALUE, THIS.ULENGTH) [ 7 ];\n  msn           =:= lsb(4, 4)                       [ 4 ];\n  psh_flag      =:= irregular(1)                    [ 1 ];\n  ttl_hopl      =:= lsb(3, 3)                       [ 3 ];\n  ecn_used      =:= one_bit_choice                  [ 1 ];\n  seq_number    =:= lsb(16, 65535)                  [ 16 ];\n  ack_number    =:= lsb(16, 16383)                  [ 16 ];\n  options       =:=\n    tcp_list_presence_enc(list_present.CVALUE)      [ VARIABLE ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_RANDOM) ||\n          (ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_ZERO));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send LSBs of sequence number\nCOMPRESSED seq_1 {\n  discriminator =:= '1010'                                 [ 4 ];\n  ip_id         =:= ip_id_lsb(ip_id_behavior.UVALUE, 4, 3) [ 4 ];\n  seq_number    =:= lsb(16, 32767)                         [ 16 ];\n  msn           =:= lsb(4, 4)                              [ 4 ];\n  psh_flag      =:= irregular(1)                           [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send scaled sequence number LSBs\nCOMPRESSED seq_2 {\n  discriminator      =:= '11010'                         [ 5 ];\n  ip_id              =:=\n    ip_id_lsb(ip_id_behavior.UVALUE, 7, 3)               [ 7 ];\n  seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];\n  msn                =:= lsb(4, 4)                       [ 4 ];\n  psh_flag           =:= irregular(1)                    [ 1 ];\n  header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE(payload_size != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send acknowledgment number LSBs\nCOMPRESSED seq_3 {\n  discriminator =:= '1001'                                 [ 4 ];\n  ip_id         =:= ip_id_lsb(ip_id_behavior.UVALUE, 4, 3) [ 4 ];\n  ack_number    =:= lsb(16, 16383)                         [ 16 ];\n  msn           =:= lsb(4, 4)                              [ 4 ];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  psh_flag      =:= irregular(1)                           [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send scaled acknowledgment number scaled\nCOMPRESSED seq_4 {\n  discriminator     =:= '0'                             [ 1 ];\n  ack_number_scaled =:= lsb(4, 3)                       [ 4 ];\n  // Due to having very few ip_id bits, no negative offset\n  ip_id      =:= ip_id_lsb(ip_id_behavior.UVALUE, 3, 1) [ 3 ];\n  msn               =:= lsb(4, 4)                       [ 4 ];\n  psh_flag          =:= irregular(1)                    [ 1 ];\n  header_crc        =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n  ENFORCE(ack_stride.UVALUE != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send ACK and sequence number\nCOMPRESSED seq_5 {\n  discriminator =:= '1000'                                 [ 4 ];\n  ip_id         =:= ip_id_lsb(ip_id_behavior.UVALUE, 4, 3) [ 4 ];\n  ack_number    =:= lsb(16, 16383)                         [ 16 ];\n  seq_number    =:= lsb(16, 32767)                         [ 16 ];\n  msn           =:= lsb(4, 4)                              [ 4 ];\n  psh_flag      =:= irregular(1)                           [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Send both ACK and scaled sequence number LSBs\nCOMPRESSED seq_6 {\n  discriminator      =:= '11011'                          [ 5 ];\n  seq_number_scaled  =:= lsb(4, 7)                        [ 4 ];\n  ip_id        =:= ip_id_lsb(ip_id_behavior.UVALUE, 7, 3) [ 7 ];\n  ack_number         =:= lsb(16, 16383)                   [ 16 ];\n  msn                =:= lsb(4, 4)                        [ 4 ];\n  psh_flag           =:= irregular(1)                     [ 1 ];\n  header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH)  [ 3 ];\n  ENFORCE(payload_size != 0);\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED)); }",
      "ja": "ip_id_behavior_sequential_swapped））;}"
    },
    {
      "indent": 3,
      "text": "// Send ACK and window\nCOMPRESSED seq_7 {\n  discriminator =:= '1100'                                 [ 4 ];\n  window        =:= lsb(15, 16383)                         [ 15 ];\n  ip_id         =:= ip_id_lsb(ip_id_behavior.UVALUE, 5, 3) [ 5 ];\n  ack_number    =:= lsb(16, 32767)                         [ 16 ];\n  msn           =:= lsb(4, 4)                              [ 4 ];\n  psh_flag      =:= irregular(1)                           [ 1 ];\n  header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n  ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n          (ip_id_behavior.UVALUE ==\n           IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "  // An extended packet type for seldom-changing fields\n  // Can send LSBs of TTL, RSF flags, change ECN behavior, and\n  // options list\n  COMPRESSED seq_8 {\n    discriminator =:= '1011'                                 [ 4 ];\n    ip_id         =:= ip_id_lsb(ip_id_behavior.UVALUE, 4, 3) [ 4 ];\n    list_present  =:= irregular(1)                           [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE, THIS.ULENGTH)        [ 7 ];\n    msn           =:= lsb(4, 4)                              [ 4 ];\n    psh_flag      =:= irregular(1)                           [ 1 ];\n    ttl_hopl      =:= lsb(3, 3)                              [ 3 ];\n    ecn_used      =:= one_bit_choice                         [ 1 ];\n    ack_number    =:= lsb(15, 8191)                          [ 15 ];\n    rsf_flags     =:= rsf_index_enc                          [ 2 ];\n    seq_number    =:= lsb(14, 8191)                          [ 14 ];\n    options       =:=\n      tcp_list_presence_enc(list_present.CVALUE)       [ VARIABLE ];\n    ENFORCE((ip_id_behavior.UVALUE == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.3. Feedback Formats and Options",
      "section_title": true,
      "ja": "8.3. フィードバックフォーマットとオプション"
    },
    {
      "indent": 0,
      "text": "8.3.1. Feedback Formats",
      "section_title": true,
      "ja": "8.3.1. フィードバック形式"
    },
    {
      "indent": 3,
      "text": "This section describes the feedback formats for the ROHC-TCP profile, following the general ROHC feedback format described in Section 5.2.3 of [RFC4995].",
      "ja": "このセクションでは、[RFC4995]のセクション5.2.3で説明されている一般的なROHCフィードバック形式に従って、ROHC-TCPプロファイルのフィードバック形式について説明します。"
    },
    {
      "indent": 3,
      "text": "All feedback formats carry a field labeled MSN. The MSN field contains LSBs of the MSN control field described in Section 6.1.1. The sequence number to use is the MSN corresponding to the last header that was successfully CRC-8 validated or CRC verified.",
      "ja": "すべてのフィードバック形式には、MSNというラベルの付いたフィールドがあります。MSNフィールドには、セクション6.1.1で説明されているMSN制御フィールドのLSBが含まれています。使用するシーケンス番号は、CRC-8検証またはCRC検証に正常に行われた最後のヘッダーに対応するMSNです。"
    },
    {
      "indent": 3,
      "text": "FEEDBACK-1",
      "ja": "フィードバック-1"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|              MSN              |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "MSN: The LSB-encoded master sequence number.",
      "ja": "MSN：LSBエンコードマスターシーケンス番号。"
    },
    {
      "indent": 3,
      "text": "A FEEDBACK-1 is an ACK. In order to send a NACK or a STATIC-NACK, FEEDBACK-2 must be used.",
      "ja": "フィードバック1はACKです。NACKまたは静的ナックを送信するには、フィードバック2を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "FEEDBACK-2",
      "ja": "フィードバック-2"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|Acktype|          MSN          |\n+---+---+---+---+---+---+---+---+\n|              MSN              |\n+---+---+---+---+---+---+---+---+\n|              CRC              |\n+---+---+---+---+---+---+---+---+\n/       Feedback options        /\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Acktype:",
      "ja": "acktype："
    },
    {
      "indent": 9,
      "text": "0 = ACK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "1 = NACK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "2 = STATIC-NACK",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "3 is reserved (MUST NOT be used for parsability)",
      "ja": "3は予約されています（格差のために使用してはいけません）"
    },
    {
      "indent": 6,
      "text": "MSN: The LSB-encoded master sequence number.",
      "ja": "MSN：LSBエンコードマスターシーケンス番号。"
    },
    {
      "indent": 6,
      "text": "CRC: 8-bit CRC computed over the entire feedback element (as defined in Section 5.3.1.1 of [RFC4995]). For the purpose of computing the CRC, the CRC field is zero. The CRC is calculated using the polynomial defined in [RFC4995].",
      "ja": "CRC：8ビットCRCは、フィードバック要素全体にわたって計算されました（[RFC4995]のセクション5.3.1.1で定義されています）。CRCを計算する目的で、CRCフィールドはゼロです。CRCは、[RFC4995]で定義された多項式を使用して計算されます。"
    },
    {
      "indent": 6,
      "text": "Feedback options: A variable number of feedback options, see Section 8.3.2. Options may appear in any order.",
      "ja": "フィードバックオプション：さまざまな数のフィードバックオプション、セクション8.3.2を参照してください。オプションは任意の順序で表示される場合があります。"
    },
    {
      "indent": 3,
      "text": "A FEEDBACK-2 of type NACK or STATIC-NACK is always implicitly an acknowledgment for a successfully decompressed packet, which packet corresponds to the MSN of the feedback element, unless the MSN-NOT-VALID option (Section 8.3.2.2) appears in the feedback element.",
      "ja": "タイプNACKまたは静的ナックのフィードバック-2は、MSN-not-validオプション（セクション8.3.2.2）が表示されない限り、フィードバック要素のMSNに対応するパケットが正常に減圧されたパケットの認識と暗黙的に確認されます。フィードバック要素。"
    },
    {
      "indent": 3,
      "text": "The FEEDBACK-2 format always carries a CRC and is thus more robust than the FEEDBACK-1 format. When receiving FEEDBACK-2, the compressor MUST verify the information by computing the CRC and by comparing the result with the CRC carried in the feedback format. If the two are not identical, the feedback element MUST be discarded.",
      "ja": "フィードバック-2形式は常にCRCを搭載するため、フィードバック1形式よりも堅牢です。フィードバック-2を受信するとき、コンプレッサーはCRCを計算し、結果をフィードバック形式でCRCを比較することにより、情報を検証する必要があります。2つが同一でない場合、フィードバック要素を破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Feedback Options",
      "section_title": true,
      "ja": "8.3.2. フィードバックオプション"
    },
    {
      "indent": 3,
      "text": "A ROHC-TCP feedback option has variable length and the following general format:",
      "ja": "ROHC-TCPフィードバックオプションは、長さが変動し、次の一般的な形式があります。"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|   Opt Type    |    Opt Len    |\n+---+---+---+---+---+---+---+---+\n/          option data          /  Opt Length (octets)\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each ROHC-TCP feedback option can appear at most once within a FEEDBACK-2.",
      "ja": "各ROHC-TCPフィードバックオプションは、フィードバック-2内でせいぜい1回表示できます。"
    },
    {
      "indent": 0,
      "text": "8.3.2.1. The REJECT Option",
      "section_title": true,
      "ja": "8.3.2.1. 拒否オプション"
    },
    {
      "indent": 3,
      "text": "The REJECT option informs the compressor that the decompressor does not have sufficient resources to handle the flow.",
      "ja": "拒否オプションは、圧縮機にフローを処理するのに十分なリソースがないことをコンプレッサーに通知します。"
    },
    {
      "indent": 6,
      "text": "+---+---+---+---+---+---+---+---+\n|  Opt Type = 2 |  Opt Len = 0  |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When receiving a REJECT option, the compressor MUST stop compressing the packet flow, and SHOULD refrain from attempting to increase the number of compressed packet flows for some time. The REJECT option MUST NOT appear more than once in the FEEDBACK-2 format; otherwise, the compressor MUST discard the entire feedback element.",
      "ja": "拒否オプションを受信する場合、コンプレッサーはパケットフローの圧縮を停止する必要があり、しばらくの間圧縮されたパケットフローの数を増やそうとすることを控える必要があります。拒否オプションは、フィードバック-2形式で複数回表示してはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.2.2. The MSN-NOT-VALID Option",
      "section_title": true,
      "ja": "8.3.2.2. msn-not-validオプション"
    },
    {
      "indent": 3,
      "text": "The MSN-NOT-VALID option indicates that the MSN of the feedback is not valid.",
      "ja": "Man-Not-validオプションは、フィードバックの男性が無効であることを示します。"
    },
    {
      "indent": 6,
      "text": "+---+---+---+---+---+---+---+---+\n|  Opt Type = 3 |  Opt Len = 0  |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A compressor MUST ignore the MSN of the feedback element when this option is present. Consequently, a NACK or a STATIC-NACK feedback type sent with the MSN-NOT-VALID option is equivalent to a STATIC-NACK with respect to the semantics of the feedback message.",
      "ja": "コンプレッサーは、このオプションが存在する場合、フィードバック要素のMSNを無視する必要があります。その結果、MSN-Not-Validオプションで送信されたNACKまたは静的ナックフィードバックタイプは、フィードバックメッセージのセマンティクスに関して静的ナックと同等です。"
    },
    {
      "indent": 3,
      "text": "The MSN-NOT-VALID option MUST NOT appear more than once in the FEEDBACK-2 format and MUST NOT appear in the same feedback element as the MSN option; otherwise, the compressor MUST discard the entire feedback element.",
      "ja": "MSN-Not-validオプションは、フィードバック2形式に複数回表示されてはならず、MSNオプションと同じフィードバック要素に表示されてはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.2.3. The MSN Option",
      "section_title": true,
      "ja": "8.3.2.3. MSNオプション"
    },
    {
      "indent": 3,
      "text": "The MSN option provides 2 additional bits of MSN.",
      "ja": "MSNオプションは、2つの追加ビットのMSNを提供します。"
    },
    {
      "indent": 6,
      "text": "+---+---+---+---+---+---+---+---+\n|  Opt Type = 4 |  Opt Len = 1  |\n+---+---+---+---+---+---+---+---+\n|  MSN  |        Reserved       |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These 2 bits are the least significant bits of the MSN and are thus concatenated with the 14 bits already present in the FEEDBACK-2 format.",
      "ja": "これらの2ビットはMSNの最も重要なビットであるため、フィードバック-2形式にすでに存在する14ビットと連結されています。"
    },
    {
      "indent": 3,
      "text": "The MSN option MUST NOT appear more than once in the FEEDBACK-2 format and MUST NOT appear in the same feedback element as the MSN-NOT-VALID option; otherwise, the compressor MUST discard the entire feedback element.",
      "ja": "MSNオプションは、フィードバック-2形式で1回以上表示されてはならず、MSN-Not-Validオプションと同じフィードバック要素に表示されてはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.2.4. The CONTEXT_MEMORY Feedback Option",
      "section_title": true,
      "ja": "8.3.2.4. Context_memoryフィードバックオプション"
    },
    {
      "indent": 3,
      "text": "The CONTEXT_MEMORY option means that the decompressor does not have sufficient memory resources to handle the context of the packet flow, as the flow is currently compressed.",
      "ja": "Context_memoryオプションは、流れが現在圧縮されているため、パケットフローのコンテキストを処理するのに十分なメモリリソースがないことを意味します。"
    },
    {
      "indent": 6,
      "text": "  0   1   2   3   4   5   6   7\n+---+---+---+---+---+---+---+---+\n|  Opt Type = 9 |  Opt Len = 0  |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When receiving a CONTEXT_MEMORY option, the compressor SHOULD take actions to compress the packet flow in a way that requires less decompressor memory resources, or stop compressing the packet flow.",
      "ja": "Context_memoryオプションを受信する場合、コンプレッサーは、減圧器メモリリソースを必要とする方法でパケットフローを圧縮するためのアクションを実行するか、パケットフローの圧縮を停止する必要があります。"
    },
    {
      "indent": 3,
      "text": "The CONTEXT_MEMORY option MUST NOT appear more than once in the FEEDBACK-2 format; otherwise, the compressor MUST discard the entire feedback element.",
      "ja": "Context_memoryオプションは、フィードバック2形式で複数回表示してはなりません。それ以外の場合、コンプレッサーはフィードバック要素全体を破棄する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.3.2.5. Unknown Option Types",
      "section_title": true,
      "ja": "8.3.2.5. 不明なオプションタイプ"
    },
    {
      "indent": 3,
      "text": "If an option type unknown to the compressor is encountered, the compressor MUST continue parsing the rest of the FEEDBACK element, which is possible since the length of the option is explicit, but MUST otherwise ignore the unknown option.",
      "ja": "コンプレッサーに不明なオプションタイプが発生した場合、コンプレッサーはフィードバック要素の残りの部分を解析し続ける必要があります。これは、オプションの長さが明示的であるため可能ですが、それ以外の場合は未知のオプションを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "A malfunctioning or malicious header compressor could cause the header decompressor to reconstitute packets that do not match the original packets but still have valid IP and TCP headers, and possibly also valid TCP checksums. Such corruption may be detected with end-to-end authentication and integrity mechanisms that will not be affected by the compression. Moreover, this header compression scheme uses an internal checksum for verification of reconstructed headers. This reduces the probability of producing decompressed headers not matching the original ones without this being noticed.",
      "ja": "誤動作または悪意のあるヘッダーコンプレッサーにより、ヘッダー減圧装置は、元のパケットと一致しないが、有効なIPおよびTCPヘッダー、場合によっては有効なTCPチェックサムを持っているパケットを再構成する可能性があります。このような腐敗は、圧縮の影響を受けないエンドツーエンドの認証と整合性メカニズムで検出される場合があります。さらに、このヘッダー圧縮スキームは、再構築されたヘッダーの検証のために内部チェックサムを使用します。これにより、これが気付かれることなく、元のヘッダーと一致しない減圧ヘッダーを生成する確率が低下します。"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks are possible if an intruder can introduce (for example) bogus IR, CO, or FEEDBACK packets onto the link and thereby cause compression efficiency to be reduced. However, an intruder having the ability to inject arbitrary packets at the link layer in this manner raises additional security issues that dwarf those related to the use of header compression.",
      "ja": "侵入者が（たとえば）偽のIR、CO、またはフィードバックパケットをリンクに導入し、それにより圧縮効率を低下させる場合、サービス拒否攻撃が可能です。ただし、この方法でリンクレイヤーに任意のパケットを注入する機能を持つ侵入者は、ヘッダー圧縮の使用に関連する追加のセキュリティ問題を提起します。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The ROHC profile identifier 0x0006 has been reserved by the IANA for the profile defined in this document.",
      "ja": "ROHCプロファイル識別子0x0006は、このドキュメントで定義されているプロファイルのIANAによって予約されています。"
    },
    {
      "indent": 3,
      "text": "A ROHC profile identifier has been reserved by the IANA for the profile defined in this document. Profiles 0x0000-0x0005 have previously been reserved; this profile is 0x0006. As for previous ROHC profiles, profile numbers 0xnn06 have been reserved for future updates of this profile.",
      "ja": "このドキュメントで定義されているプロファイルのために、IANAによってROHCプロファイル識別子が予約されています。プロファイル0x0000-0x0005は以前に予約されています。このプロファイルは0x0006です。以前のROHCプロファイルに関しては、プロファイル番号0xNN06がこのプロファイルの将来の更新のために予約されています。"
    },
    {
      "indent": 8,
      "text": "Profile             Usage            Document\nidentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "0x0006              ROHC TCP         [RFC4996]\n0xnn06              Reserved",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11. Acknowledgments",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank Qian Zhang, Hong Bin Liao, Richard Price, and Fredrik Lindstroem for their work with early versions of this specification. Thanks also to Robert Finking and Carsten Bormann for valuable input.",
      "ja": "著者は、この仕様の初期バージョンでの仕事について、Qian Zhang、Hong Bin Liao、Richard Price、Fredrik Lindstroemに感謝したいと思います。貴重な入力をしてくれたRobert FinkingとCarsten Bormannにも感謝します。"
    },
    {
      "indent": 3,
      "text": "Additional thanks: this document was reviewed during working group last-call by committed reviewers Joe Touch and Ted Faber, as well as by Sally Floyd, who provided a review at the request of the Transport Area Directors.",
      "ja": "追加の感謝：このドキュメントは、コミットされたレビュアージョータッチとテッドフェイバーによって、ワーキンググループの最終コール中にレビューされました。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC0791] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2004] Perkins, C., \"Minimal Encapsulation within IP\", RFC 2004, October 1996.",
      "ja": "[RFC2004] Perkins、C。、「IP内の最小カプセル化」、RFC 2004、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2784] Farinacci, D., Li, T., Hanks, S., Meyer, D., and P. Traina, \"Generic Routing Encapsulation (GRE)\", RFC 2784, March 2000.",
      "ja": "[RFC2784] Farinacci、D.、Li、T.、Hanks、S.、Meyer、D。、およびP. Traina、「Generic Routing Cancapstulation（GRE）」、RFC 2784、2000年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2890] Dommety, G., \"Key and Sequence Number Extensions to GRE\", RFC 2890, September 2000.",
      "ja": "[RFC2890] Dommety、G。、「GREへのキーおよびシーケンス番号拡張」、RFC 2890、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4164] Pelletier, G., \"RObust Header Compression (ROHC): Context Replication for ROHC Profiles\", RFC 4164, August 2005.",
      "ja": "[RFC4164] Pelletier、G。、「堅牢なヘッダー圧縮（ROHC）：ROHCプロファイルのコンテキスト複製」、RFC 4164、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302] Kent、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303] Kent、S。、「セキュリティペイロード（ESP）」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4995] Jonsson, L-E., Pelletier, G., and K. Sandlund, \"The RObust Header Compression (ROHC) Framework\", RFC 4995, July 2007.",
      "ja": "[RFC4995] Jonsson、L-E。、Pelletier、G。、およびK. Sandlund、「The Robust Header Compression（ROHC）フレームワーク」、RFC 4995、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4997] Finking, R. and G. Pelletier, \"Formal Notation for Robust Header Compression (ROHC-FN)\", RFC 4997, July 2007.",
      "ja": "[RFC4997] Finking、R。およびG. Pelletier、「堅牢なヘッダー圧縮の正式な表記（ROHC-FN）」、RFC 4997、2007年7月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC1144] Jacobson, V., \"Compressing TCP/IP headers for low-speed serial links\", RFC 1144, February 1990.",
      "ja": "[RFC1144] Jacobson、V。、「低速シリアルリンクのTCP/IPヘッダーの圧縮」、RFC 1144、1990年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[RFC1323] Jacobson、V.、Braden、B。、およびD. Borman、「TCP拡張のためのTCP拡張」、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018] Mathis、M.、Mahdavi、J.、Floyd、S。、およびA. Romanow、「TCP Selective Ascondage Options」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2507] Degermark, M., Nordgren, B., and S. Pink, \"IP Header Compression\", RFC 2507, February 1999.",
      "ja": "[RFC2507] Degermark、M.、Nordgren、B。、およびS. Pink、「IPヘッダー圧縮」、RFC 2507、1999年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Allman、M.、Paxson、V。、およびW. Stevens、「TCP渋滞制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883] Floyd、S.、Mahdavi、J.、Mathis、M。、およびM. Podolsky、「TCPの選択的承認（SACK）オプションの拡張」、RFC 2883、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3095] Bormann, C., Burmeister, C., Degermark, M., Fukushima, H., Hannu, H., Jonsson, L-E., Hakenberg, R., Koren, T., Le, K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K., Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header Compression (ROHC): Framework and four profiles: RTP, UDP, ESP, and uncompressed\", RFC 3095, July 2001.",
      "ja": "[RFC3095] Bormann、C.、Burmeister、C.、Degermark、M.、Fukushima、H.、Hannu、H.、Jonsson、L-e。、Hakenberg、R.、Koren、T.、Le、K.、Liu、Liu、Z.、Martensson、A.、Miyazaki、A.、Svanbro、K.、Wiebke、T.、Yoshimura、T.、およびH. Zheng、 \"堅牢なヘッダー圧縮（ROHC）：フレームワークと4つのプロファイル：RTP、UDP、ESP、および非圧縮」、RFC 3095、2001年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "[RFC3168] Ramakrishnan、K.、Floyd、S。、およびD. Black、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3759] Jonsson, L-E., \"RObust Header Compression (ROHC): Terminology and Channel Mapping Examples\", RFC 3759, April 2004.",
      "ja": "[RFC3759] Jonsson、L-E。、「ロバストヘッダー圧縮（ROHC）：用語とチャネルマッピングの例」、RFC 3759、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4163] Jonsson, L-E., \"RObust Header Compression (ROHC): Requirements on TCP/IP Header Compression\", RFC 4163, August 2005.",
      "ja": "[RFC4163] Jonsson、L-E。、「ロバストヘッダー圧縮（ROHC）：TCP/IPヘッダー圧縮の要件」、RFC 4163、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4224] Pelletier, G., Jonsson, L-E., and K. Sandlund, \"RObust Header Compression (ROHC): ROHC over Channels That Can Reorder Packets\", RFC 4224, January 2006.",
      "ja": "[RFC4224] Pelletier、G.、Jonsson、L-E。、およびK. Sandlund、「Robust Header Compression（ROHC）：Packetsを並べ替えることができるチャネル上のROHC」、RFC 4224、2006年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4413] West, M. and S. McCann, \"TCP/IP Field Behavior\", RFC 4413, March 2006.",
      "ja": "[RFC4413] West、M。およびS. McCann、「TCP/IPフィールド行動」、RFC 4413、2006年3月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Ghyslain Pelletier Ericsson Box 920 Lulea SE-971 28 Sweden",
      "ja": "Ghyslain Pelletier Ericsson Box 920 Lulea SE-971 28スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 (0) 8 404 29 43\nEMail: ghyslain.pelletier@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kristofer Sandlund Ericsson Box 920 Lulea SE-971 28 Sweden",
      "ja": "Kristofer Sandlund Ericsson Box 920 Lulea SE-971 28スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 (0) 8 404 41 58\nEMail: kristofer.sandlund@ericsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Lars-Erik Jonsson Optand 737 Ostersund SE-831 92 Sweden",
      "ja": "Lars-Erik Jonsson Optand 737 Ostersund SE-831 92スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 70 365 20 58\nEMail: lars-erik@lejonsson.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mark A West Siemens/Roke Manor Roke Manor Research Ltd. Romsey, Hampshire SO51 0ZN UK",
      "ja": "マーク・ア・ウェスト・シーメンス/ローク・マナー・ローク・マナー・リサーチ・リミテッド。ハンプシャーSO51 0ZN UKをマーク"
    },
    {
      "indent": 3,
      "text": "Phone: +44 1794 833311\nEMail: mark.a.west@roke.co.uk\nURI:   http://www.roke.co.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}