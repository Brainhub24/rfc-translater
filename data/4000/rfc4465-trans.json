{
  "title": {
    "text": "RFC 4465 - Signaling Compression (SigComp) Torture Tests",
    "ja": "RFC 4465 - シグナリング圧縮（SIGCOMP）拷問テスト"
  },
  "number": 4465,
  "created_at": "2023-07-03 13:17:49.423482+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                         A. Surtees\nRequest for Comments: 4465                                       M. West\nCategory: Informational                      Siemens/Roke Manor Research\n                                                               June 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Signaling Compression (SigComp) Torture Tests",
      "ja": "シグナリング圧縮（SIGCOMP）拷問テスト"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document provides a set of \"torture tests\" for implementers of the Signaling Compression (SigComp) protocol. The torture tests check each of the SigComp Universal Decompressor Virtual Machine instructions in turn, focusing in particular on the boundary and error cases that are not generally encountered when running well-behaved compression algorithms. Tests are also provided for other SigComp entities such as the dispatcher and the state handler.",
      "ja": "このドキュメントは、シグナリング圧縮（SIGCOMP）プロトコルの実装者向けの一連の「拷問テスト」を提供します。拷問テストは、特に、行儀の良い圧縮アルゴリズムを実行するときに一般的に遭遇しない境界とエラーのケースに焦点を当て、順番にSigcomp Universal Decompressor仮想マシンの命令をチェックします。ディスパッチャーやステートハンドラーなどの他のSigCompエンティティについては、テストも提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Torture Tests for UDVM ..........................................4\n   2.1. Bit Manipulation ...........................................4\n   2.2. Arithmetic .................................................5\n   2.3. Sorting ....................................................7\n   2.4. SHA-1 ......................................................8\n   2.5. LOAD and MULTILOAD .........................................9\n   2.6. COPY ......................................................11\n   2.7. COPY-LITERAL and COPY-OFFSET ..............................12\n   2.8. MEMSET ....................................................14\n   2.9. CRC .......................................................15\n   2.10. INPUT-BITS ...............................................16\n   2.11. INPUT-HUFFMAN ............................................17\n   2.12. INPUT-BYTES ..............................................19\n   2.13. Stack Manipulation .......................................20\n   2.14. Program Flow .............................................22\n   2.15. State Creation ...........................................23\n   2.16. STATE-ACCESS .............................................26\n3. Torture Tests for Dispatcher ...................................28\n   3.1. Useful Values .............................................28\n   3.2. Cycles Checking ...........................................31\n   3.3. Message-based Transport ...................................32\n   3.4. Stream-based Transport ....................................34\n   3.5. Input Past the End of a Message ...........................36\n4. Torture Tests for State Handler ................................38\n   4.1. SigComp Feedback Mechanism ................................38\n   4.2. State Memory Management ...................................41\n   4.3. Multiple Compartments .....................................44\n   4.4. Accessing RFC 3485 State ..................................49\n   4.5. Bytecode State Creation ...................................50\n5. Security Considerations ........................................53\n6. Acknowledgements ...............................................53\n7. Normative References ...........................................53\nAppendix A.  UDVM Bytecode for the Torture Tests ..................54\n   A.1. Instructions ..............................................54\n        A.1.1. Bit Manipulation ...................................54\n        A.1.2. Arithmetic .........................................55\n        A.1.3. Sorting ............................................55\n        A.1.4. SHA-1 ..............................................56\n        A.1.5. LOAD and MULTILOAD .................................56\n        A.1.6. COPY ...............................................56\n        A.1.7. COPY-LITERAL and COPY-OFFSET .......................57\n        A.1.8. MEMSET .............................................57\n        A.1.9. CRC ................................................57\n        A.1.10. INPUT-BITS ........................................57\n        A.1.11. INPUT-HUFFMAN .....................................58\n           A.1.12. INPUT-BYTES .......................................58\n        A.1.13. Stack Manipulation ................................58\n        A.1.14. Program Flow ......................................59\n        A.1.15. State Creation ....................................59\n        A.1.16. STATE-ACCESS ......................................60\n   A.2. Dispatcher Tests ..........................................61\n        A.2.1. Useful Values ......................................61\n        A.2.2. Cycles Checking  ...................................62\n        A.2.3. Message-based Transport ............................62\n        A.2.4. Stream-based Transport .............................62\n        A.2.5. Input Past the End of a Message ....................63\n   A.3. State Handler Tests .......................................64\n        A.3.1. SigComp Feedback Mechanism .........................64\n        A.3.2. State Memory Management ............................64\n        A.3.3. Multiple Compartments ..............................65\n        A.3.4. Accessing RFC 3485 State ...........................66\n        A.3.5. Bytecode State Creation ............................66",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document provides a set of \"torture tests\" for implementers of the SigComp protocol, RFC 3320 [2]. The idea behind SigComp is to standardize a Universal Decompressor Virtual Machine (UDVM) that can be programmed to understand the output of many well-known compressors including DEFLATE and LZW. The bytecode for the chosen decompressor is uploaded to the UDVM as part of the SigComp message flow.",
      "ja": "このドキュメントは、SIGCOMPプロトコルのRFC 3320 [2]の実装者に「拷問テスト」のセットを提供します。Sigcompの背後にあるアイデアは、DERLATEやLZWを含む多くのよく知られているコンプレッサーの出力を理解するようにプログラムできるユニバーサルDecompressor仮想マシン（UDVM）を標準化することです。選択した減圧器のバイトコードは、SigCompメッセージフローの一部としてUDVMにアップロードされます。"
    },
    {
      "indent": 3,
      "text": "The SigComp User's Guide [1] gives examples of a number of different algorithms that can be used by the SigComp protocol. However, the bytecode for the corresponding decompressors is relatively well behaved and does not test the boundary and error cases that may potentially be exploited by malicious SigComp messages.",
      "ja": "SigCompユーザーガイド[1]は、SigCompプロトコルで使用できるさまざまなアルゴリズムの例を示しています。ただし、対応する減圧剤のバイトコードは比較的うまく動作しており、悪意のあるSigCompメッセージによって悪用される可能性のある境界とエラーのケースをテストしません。"
    },
    {
      "indent": 3,
      "text": "This document is divided into a number of sections, each containing a piece of code designed to test a particular function of one of the SigComp entities (UDVM, dispatcher, and state handler). The specific boundary and error cases tested by the bytecode are also listed, as are the output the code should produce and the number of UDVM cycles that should be used.",
      "ja": "このドキュメントは、SigCompエンティティの1つ（UDVM、ディスパッチャー、およびステートハンドラー）の特定の機能をテストするように設計されたコードを含む多くのセクションに分割されています。バイトコードによってテストされた特定の境界とエラーのケースもリストされており、コードが生成すべき出力と使用するUDVMサイクルの数もリストされています。"
    },
    {
      "indent": 3,
      "text": "Each test runs in the SigComp minimum decompression memory size (that is, 2K), within the minimum number of cycles per bit (that is, 16) and in tests where state is stored 2K state memory size is needed.",
      "ja": "各テストは、SIGCOMPの最小減圧メモリサイズ（つまり、2K）で、ビットあたりの最小サイクル数（つまり、16）内で実行され、状態が保存されているテストで2K状態メモリサイズが必要です。"
    },
    {
      "indent": 0,
      "text": "2. Torture Tests for UDVM",
      "section_title": true,
      "ja": "2. UDVMの拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections each provide code to test one or more UDVM instructions. In the interests of readability, the code is given using the SigComp assembly language: a description of how to convert this assembly code into UDVM bytecode can be found in the SigComp User's Guide [1].",
      "ja": "次のセクションでは、それぞれ1つ以上のUDVM命令をテストするコードを提供します。読みやすさのために、コードはSigCompアセンブリ言語を使用して与えられます。このアセンブリコードをUDVMバイトコードに変換する方法の説明は、SigCompユーザーガイド[1]に記載されています。"
    },
    {
      "indent": 3,
      "text": "The raw UDVM bytecode for each torture test is given in Appendix A.",
      "ja": "各拷問テストの生のUDVMバイトコードは、付録Aに記載されています。"
    },
    {
      "indent": 3,
      "text": "Each section also lists the number of UDVM cycles required to execute the code. Note that this figure only takes into account the cost of executing each UDVM instruction (in particular, it ignores the fact that the UDVM can gain extra cycles as a result of inputting more data).",
      "ja": "各セクションには、コードを実行するのに必要なUDVMサイクルの数もリストされています。この図は、各UDVM命令を実行するコストのみを考慮していることに注意してください（特に、より多くのデータを入力した結果、UDVMが追加のサイクルを獲得できるという事実は無視されます）。"
    },
    {
      "indent": 0,
      "text": "2.1. Bit Manipulation",
      "section_title": true,
      "ja": "2.1. ビット操作"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the AND, OR, NOT, LSHIFT, and RSHIFT instructions. When the instructions have a multitype operand, the code tests the case where the multitype contains a fixed integer value, and the case where it contains a memory address at which the 2-byte operand value can be found. In addition, the code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アンドシフトとrshiftの命令をテストするためのアセンブリコードを提供します。命令にマルチタイプオペランドがある場合、コードは、マルチタイプに固定整数値が含まれている場合、および2バイトのオペランド値が見つかるメモリアドレスが含まれる場合をテストします。さらに、コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The instructions overwrite themselves with the result of the bit manipulation operation, in which case execution continues normally.",
      "ja": "1. 命令は、ビット操作操作の結果で自分自身を上書きします。その場合、実行は正常に続きます。"
    },
    {
      "indent": 3,
      "text": "2. The LSHIFT or RSHIFT instructions shift bits beyond the 2-byte boundary, in which case the bits must be discarded.",
      "ja": "2. lshiftまたはrshift命令は、2バイトの境界を超えてビットをシフトします。その場合、ビットを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "3. The UDVM registers byte_copy_left and byte_copy_right are used to store the results of the bit manipulation operations. Since no byte copying is taking place, these registers should behave in exactly the same manner as ordinary UDVM memory addresses.",
      "ja": "3. udvmレジスタbyte_copy_leftおよびbyte_copy_rightは、ビット操作操作の結果を保存するために使用されます。バイトコピーが行われていないため、これらのレジスタは通常のUDVMメモリアドレスとまったく同じ方法で動作する必要があります。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":a                              pad (2)\n:b                              pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "JUMP (start) ; Jump to address 255",
      "ja": "ジャンプスタート） ;255に対処するためにジャンプします"
    },
    {
      "indent": 3,
      "text": "at (255)",
      "ja": "で（255）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "; The multitypes are values\n                        ; $start = 448 (first 2 bytes of AND instr)\nAND ($start, 21845)     ; 448 & 21845 = 320 = 0x0140\nOR ($a, 42)             ; 0 | 42 = 42 = 0x002a\nNOT ($b)                ; ~0 = 65535 = 0xffff\nLSHIFT ($a, 3)          ; 42 << 3 = 336 = 0x0150\nRSHIFT ($b, 65535)      ; 65535 >> 65535 = 0 = 0x0000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; Output 0x0150 0000",
      "ja": "出力（64、4）;出力0x0150 0000"
    },
    {
      "indent": 3,
      "text": "; The multitypes are references",
      "ja": ";マルチティペップは参照です"
    },
    {
      "indent": 3,
      "text": "AND ($a, $start)        ; 336 & 320 = 320 = 0x0140\nOR ($a, $a)             ; 320 | 320 = 320 = 0x0140\nNOT ($a)                ; ~320 = 65215 = 0xfebf\nLSHIFT ($b, $a)         ; 0 << 65215 = 0 = 0x0000\nRSHIFT ($a, $b)         ; 65215 >> 0 = 65215 = 0xfebf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; Output 0xfebf 0000",
      "ja": "出力（64、4）;出力0xfebf 0000"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0150 0000 febf 0000. Executing the code costs a total of 22 UDVM cycles.",
      "ja": "コードの出力は0x0150 0000 FEBF 0000です。コードの実行では、合計22のUDVMサイクルがかかります。"
    },
    {
      "indent": 0,
      "text": "2.2. Arithmetic",
      "section_title": true,
      "ja": "2.2. 算術"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the ADD, SUBTRACT, MULTIPLY, DIVIDE, and REMAINDER instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アセンブリコードを提供して、追加、減算、乗算、分割、および残りの命令をテストします。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The instructions overwrite themselves with the result of the arithmetic operation, resulting in continuation as if the bytes were not bytecode.",
      "ja": "1. 命令は、算術演算の結果で自分自身を上書きし、バイトがバイトコードではないかのように継続をもたらします。"
    },
    {
      "indent": 3,
      "text": "2. The result does not lie between 0 and 2^16 - 1 inclusive, in which case it must be taken modulo 2^16.",
      "ja": "2. 結果は0〜2^16-1の包括的ではありません。その場合、測定値2^16を取る必要があります。"
    },
    {
      "indent": 3,
      "text": "3. The divisor in the DIVIDE or REMAINDER instructions is 0 (in which case decompression failure must occur).",
      "ja": "3. 除算または残りの指示の除数は0です（この場合、減圧の障害が発生する必要があります）。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":a                              pad (2)\n:b                              pad (2)\n:type                           pad (1)\n:type_lsb                       pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decomp_failure) SUBTRACT ($type, 1) JUMP (start) :decomp_failure DECOMPRESSION-FAILURE",
      "ja": "input-bytes（1、type_lsb、decomp_failure）減算（$ type、1）jump（start）：decomp_failure減圧 -  failure"
    },
    {
      "indent": 3,
      "text": "; Now the value in $type should be 0xffff, 0x0000, or 0x0001 ; according to whether the input was 0x00, 0x01, or 0x02.",
      "ja": ";これで、$タイプの値は0xffff、0x0000、または0x0001にする必要があります。入力が0x00、0x01、または0x02であるかどうかに応じて。"
    },
    {
      "indent": 3,
      "text": "at (255)",
      "ja": "で（255）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "; The multitypes are values\n                        ; For all three messages\n                        ; $start = 1728 (first 2 bytes of ADD instr)\nADD ($start, 63809)     ; 1728 + 63809 = 1 = 0x0001\nSUBTRACT ($a, 1)        ; 0 - 1 = 65535 = 0xffff\nMULTIPLY ($a, 1001)     ; 65535 * 1001 = 64535 = 0xfc17\nDIVIDE ($a, 101)        ; 64535 / 101 = 638 = 0x027e\nREMAINDER ($a, 11)      ; 638 % 11 = 0 = 0x0000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 4) ; output 0x0000 0000",
      "ja": "出力（64、4）;出力0x00000000"
    },
    {
      "indent": 3,
      "text": "; The multitypes are references\nADD ($b, $start)        ; 0 + 1 = 1 = 0x0001\n                        ; If the message is 0x00\nSUBTRACT ($b, $type)    ; 1 - 65535 = 2 = 0x0002\nMULTIPLY ($b, $b)       ; 2 * 2 = 4 = 0x0004\nDIVIDE ($a, $b)         ; 0 / 4 = 0 = 0x0000\nREMAINDER ($b, $type)   ; 4 % 65535 = 4 = 0x0004\n   OUTPUT (64, 4)          ; output 0x0000 0004",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "; If the message is 0x01, $type = 0\n; so decompression failure occurs at\n; REMAINDER ($b, $type)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "; If the message is 0x02, $type = 1 so\n; $b becomes 0 and decompression failure\n; occurs at DIVIDE ($a, $b)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x00, then the output of the code is 0x0000 0000 0000 0004 and the execution cost should be 25 UDVM cycles. However, if the compressed message is 0x01 or 0x02, then decompression failure occurs.",
      "ja": "圧縮メッセージが0x00の場合、コードの出力は0x0000 0000 0000 0004であり、実行コストは25 UDVMサイクルでなければなりません。ただし、圧縮メッセージが0x01または0x02の場合、減圧障害が発生します。"
    },
    {
      "indent": 0,
      "text": "2.3. Sorting",
      "section_title": true,
      "ja": "2.3. ソート"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SORT-ASCENDING and SORT-DESCENDING instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アセンブリコードを提供して、並べ替えと並べ替えの説明命令をテストします。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The sorting instructions sort integers with the same value, in which case the original ordering of the integers must be preserved.",
      "ja": "1. ソート命令は、同じ値で整数をソートします。その場合、整数の元の順序を保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "SORT-DESCENDING (256, 2, 23) SORT-ASCENDING (256, 2, 23)",
      "ja": "ソートデス（256、2、23）並べ替え（256、2、23）"
    },
    {
      "indent": 3,
      "text": "OUTPUT (302, 45) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "出力（302、45）終了（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (256)",
      "ja": "で（256）"
    },
    {
      "indent": 3,
      "text": "word (10, 10, 17, 7, 22, 3, 3, 3, 19, 1, 16, 14, 8, 2, 13, 20, 18, 23, 15, 21, 12, 6, 9)",
      "ja": "単語（10、10、17、7、22、3、3、3、19、1、16、14、8、2、13、20、18、23、15、21、12、6、9）"
    },
    {
      "indent": 3,
      "text": "word (28263, 8297, 30057, 8308, 26996, 11296, 31087, 29991, 8275, 18031, 28263, 24864, 30066, 29284, 28448, 29807, 28206, 11776, 28773, 28704, 28276, 29285, 28265)",
      "ja": "Word（28263、8297、30057、8308、26996、11296、31087、29991、8275、18031、28263、24864、30066、29284、28448、29807、28206、11776、2873、28704、28704、28704、28704"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 7020 6974 2e, and the number of cycles required is 371.",
      "ja": "コードの出力は0x466F 7264 2C20 796F 7527 7265 2074 7572 6E69 6E67 2069 6E74 6F20 6120 7065 6E67 7569 6E2E 2053 746F 7020 6974"
    },
    {
      "indent": 0,
      "text": "2.4. SHA-1",
      "section_title": true,
      "ja": "2.4. SHA-1"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SHA-1 instruction. The code performs four tests on the SHA-1 algorithm itself and, in addition, checks the following boundary cases specific to the UDVM:",
      "ja": "このセクションでは、SHA-1命令をテストするためのアセンブリコードを提供します。コードは、SHA-1アルゴリズム自体で4つのテストを実行し、さらに、UDVMに固有の次の境界ケースをチェックします。"
    },
    {
      "indent": 3,
      "text": "1. The input string for the SHA-1 hash is obtained by byte copying over an area of the UDVM memory.",
      "ja": "1. SHA-1ハッシュの入力文字列は、UDVMメモリの領域にバイトコピーすることによって取得されます。"
    },
    {
      "indent": 3,
      "text": "2. The SHA-1 hash overwrites its own input string.",
      "ja": "2. SHA-1ハッシュは、独自の入力文字列を上書きします。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:hash_value                     pad (20)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "SHA-1 (test_one, 3, hash_value) OUTPUT (hash_value, 20)",
      "ja": "Sha-1（test_one、3、hash_value）出力（hash_value、20）"
    },
    {
      "indent": 3,
      "text": "SHA-1 (test_two, 56, hash_value) OUTPUT (hash_value, 20)",
      "ja": "Sha-1（test_two、56、hash_value）output（hash_value、20）"
    },
    {
      "indent": 3,
      "text": "; Set up a 1-byte buffer LOAD (byte_copy_left, test_three) LOAD (byte_copy_right, test_four)",
      "ja": ";1バイトバッファロード（byte_copy_left、test_three）load（byte_copy_right、test_four）をセットアップします"
    },
    {
      "indent": 3,
      "text": "; Perform SHA-1 over 16384 bytes in a 1-byte buffer SHA-1 (test_three, 16384, hash_value) OUTPUT (hash_value, 20)",
      "ja": ";1バイトバッファーSHA-1（test_three、16384、hash_value）出力（hash_value、20）で16384を超えるSHA-1を実行する"
    },
    {
      "indent": 3,
      "text": "; Set up an 8-byte buffer LOAD (byte_copy_left, test_four) LOAD (byte_copy_right, test_end)",
      "ja": ";8バイトバッファロード（byte_copy_left、test_four）load（byte_copy_right、test_end）を設定します"
    },
    {
      "indent": 3,
      "text": "; Perform SHA-1 over 640 bytes in an 8-byte buffer SHA-1 (test_four, 640, test_four) OUTPUT (test_four, 20)",
      "ja": ";8バイトバッファーSHA-1（test_four、640、test_four）出力（test_four、20）で640バイト以上を実行する"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":test_one",
      "ja": "：test_one"
    },
    {
      "indent": 3,
      "text": "byte (97, 98, 99)",
      "ja": "バイト（97、98、99）"
    },
    {
      "indent": 3,
      "text": ":test_two byte (97, 98, 99, 100, 98, 99, 100, 101, 99, 100, 101, 102, 100, 101, 102, 103, 101, 102, 103, 104, 102, 103, 104, 105, 103, 104, 105, 106, 104, 105, 106, 107, 105, 106, 107, 108, 106, 107, 108, 109, 107, 108, 109, 110, 108, 109, 110, 111, 109, 110, 111, 112, 110, 111, 112, 113)",
      "ja": "：test_two byte（97、98、99、100、98、99、100、101、99、100、101、102、100、101、102、103、101、102、103、104、102、103、104、104、105、103、104、105、106、104、105、106、107、105、106、107、108、106、107、108、109、107、108、109、110、108、109、110、111、109、110、111、112、110、111、112、113）"
    },
    {
      "indent": 3,
      "text": ":test_three",
      "ja": "：test_three"
    },
    {
      "indent": 3,
      "text": "byte (97)",
      "ja": "バイト（97）"
    },
    {
      "indent": 3,
      "text": ":test_four",
      "ja": "：test_four"
    },
    {
      "indent": 3,
      "text": "byte (48, 49, 50, 51, 52, 53, 54, 55)",
      "ja": "バイト（48、49、50、51、52、53、54、55）"
    },
    {
      "indent": 3,
      "text": ":test_end",
      "ja": "：test_end"
    },
    {
      "indent": 3,
      "text": "The output of the code is as follows:",
      "ja": "コードの出力は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347b 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122f 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452",
      "ja": "0xa999 3E36 4706 816A BA3E 2571 7850 C26C 9CD0 D89D 0x8498 3E44 1C3B D26E BAAE 4AA1 F951 4F46 0452 EBB5 6393 4F46 0452 EBB5 6393 4F46 0452"
    },
    {
      "indent": 3,
      "text": "Executing the code costs a total of 17176 UDVM cycles.",
      "ja": "コードを実行すると、合計17176 UDVMサイクルがかかります。"
    },
    {
      "indent": 0,
      "text": "2.5. LOAD and MULTILOAD",
      "section_title": true,
      "ja": "2.5. 負荷とマルチロード"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the LOAD and MULTILOAD instructions. The code is designed to test the following boundary cases:",
      "ja": "このセクションでは、荷重とマルチロードの命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The MULTILOAD instruction overwrites itself or any of its operands, in which case decompression failure occurs.",
      "ja": "1. マルチロード命令は、それ自体またはそのオペランドのいずれかを上書きします。その場合、減圧の故障が発生します。"
    },
    {
      "indent": 3,
      "text": "2. The memory references of MULTILOAD instruction operands are evaluated step-by-step rather than all at once before starting to copy data.",
      "ja": "2. マルチロード命令オペランドのメモリ参照は、データのコピーを開始する前に、一度にすべてではなく段階的に評価されます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":start                          pad (1)\n:start_lsb                      pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "set (location_a, 128)\nset (location_b, 132)\n   LOAD (128, 132)                 ; address 128 contains 132 = 0x0084\nLOAD (130, $location_a)         ; address 130 contains 132 = 0x0084\nLOAD ($location_a, 134)         ; address 132 contains 134 = 0x0086\nLOAD ($location_b, $location_b) ; address 134 contains 134 = 0x0086\nOUTPUT (128, 8)                 ; output 0x0084 0084 0086 0086",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, start_lsb, decompression_failure) MULTIPLY ($start, 2) ADD ($start, 60) MULTILOAD ($start, 3, overlap_start, overlap_end, 128)",
      "ja": "input-bytes（1、start_lsb、decompression_failure）乗算（$ start、2）add（$ start、60）multiLoad（$ start、3、anuverlap_start、anuverlap_end、128）"
    },
    {
      "indent": 3,
      "text": ":position",
      "ja": "：位置"
    },
    {
      "indent": 3,
      "text": "set (overlap_start, (position - 7))",
      "ja": "set（overlap_start、（position -7））"
    },
    {
      "indent": 3,
      "text": "MULTILOAD ($start, 4, 42, 128, $location_a, $location_b)",
      "ja": "MultiLoad（$ start、4、42、128、$ location_a、$ location_b）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "set (overlap_end, (end - 1))",
      "ja": "set（overlap_end、（end -1））"
    },
    {
      "indent": 3,
      "text": "OUTPUT (128, 8) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "出力（128、8）終了（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":decompression_failure DECOMPRESSION-FAILURE",
      "ja": "：decompression_failure減圧 -  failure"
    },
    {
      "indent": 3,
      "text": "The INPUT-BYTES, MULTIPLY, and ADD instructions give the following values for $start = $64 just before the MULTILOADs begin:",
      "ja": "入力バイト、乗算、および追加手順は、マルチロードが始まる直前に$ start = $ 64の次の値を示します。"
    },
    {
      "indent": 3,
      "text": "Input     $start before 1st MULTILOAD\n0x00            60\n0x01            62\n0x02            64",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Consequently, after the first MULTILOAD the values of $start are the following:",
      "ja": "その結果、最初のマルチロードの後、$ startの値は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input $start before 2nd MULTILOAD 0x00 128 0x01 overlap_end = 177 = last byte of 2nd MULTILOAD instruction 0x02 overlap_start = 162 = 7 bytes before 2nd MULTILOAD instruction",
      "ja": "入力$は2番目のマルチロード0x00 128 0x01 overlap_end = 177 = 2番目のマルチロード命令0x02 overlap_start = 162 = 2番目のマルチロード命令の最終バイト= 177 = 177 = 177 = 177 =開始"
    },
    {
      "indent": 3,
      "text": "Consequently, execution of the 2nd MULTILOAD (and any remaining code) gives the following:",
      "ja": "したがって、2番目のマルチロード（および残りのコード）の実行により、次のようになります。"
    },
    {
      "indent": 3,
      "text": "Input Outcome 0x00 MULTILOAD reads and writes operand by operand. The output is 0x0084 0084 0086 0086 002a 0080 002a 002a, and the cost of executing the code is 36 UDVM cycles.",
      "ja": "入力結果0x00マルチロードは、オペランドによるオペランドを読み取り、書き込みます。出力は0x0084 0084 0086 0086 002A 0080 002A 002Aで、コードを実行するコストは36 UDVMサイクルです。"
    },
    {
      "indent": 3,
      "text": "0x01 The first write of the MULTILOAD instruction would overwrite the last byte of the final MULTILOAD operand, so decompression failure occurs.",
      "ja": "0x01マルチロード命令の最初の書き込みは、最終的なマルチロードオペランドの最後のバイトを上書きするため、減圧障害が発生します。"
    },
    {
      "indent": 3,
      "text": "0x02 The last write of the MULTILOAD would overwrite the MULTILOAD opcode, so decompression failure occurs.",
      "ja": "0x02マルチロードの最後の書き込みは、マルチロードオペコードを上書きするため、減圧の故障が発生します。"
    },
    {
      "indent": 0,
      "text": "2.6. COPY",
      "section_title": true,
      "ja": "2.6. コピー"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the COPY instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、コピー命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The COPY instruction copies data from both outside the circular buffer and inside the circular buffer within the same operation.",
      "ja": "1. コピー命令は、同じ操作内の円形バッファーの外側と円形バッファー内の両方からデータをコピーします。"
    },
    {
      "indent": 3,
      "text": "2. The COPY instruction performs byte-by-byte copying (i.e., some of the later bytes to be copied are themselves written into the UDVM memory by the COPY instruction currently being executed).",
      "ja": "2. コピー命令は、バイバイバイバイトのコピーを実行します（つまり、コピーされる後のバイトの一部は、現在実行されているコピー命令によりUDVMメモリに書き込まれます）。"
    },
    {
      "indent": 3,
      "text": "3. The COPY instruction overwrites itself and continues executing.",
      "ja": "3. コピー命令はそれ自体を上書きし、実行を続けます。"
    },
    {
      "indent": 3,
      "text": "4. The COPY instruction overwrites the UDVM registers byte_copy_left and byte_copy_right.",
      "ja": "4. コピー命令は、udvmレジスタbyte_copy_leftとbyte_copy_rightを上書きします。"
    },
    {
      "indent": 3,
      "text": "5. The COPY instruction writes to and reads from the right of the buffer beginning at byte_copy_right.",
      "ja": "5. コピー命令は、byte_copy_rightで始まるバッファの右から書き込み、読み取ります。"
    },
    {
      "indent": 3,
      "text": "6. The COPY instruction implements byte copying rules when the destination wraps around the buffer.",
      "ja": "6. コピー命令は、宛先がバッファーの周りをラップするときにバイトのコピールールを実装します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n   at (128)\n                        ; Set up buffer between addresses 64 & 128\nLOAD (32, 16384)\nLOAD (byte_copy_left, 64)\nLOAD (byte_copy_right, 128)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COPY (32, 128, 33)      ; Copy byte by byte starting to the left of\n                        ; the buffer, into the buffer and wrapping\n                        ; the buffer (inc overwriting the\n                        ; boundaries)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LOAD (64, 16640) ; Change the start of the buffer to be ; beyond bytecode",
      "ja": "負荷（64、16640）;バッファの開始を変更します。Bytecodeを超えて"
    },
    {
      "indent": 3,
      "text": "COPY (64, 85, 65) ; Copy to the left of the buffer, ; overwriting this instruction",
      "ja": "コピー（64、85、65）;バッファの左にコピーします。この指示を上書きします"
    },
    {
      "indent": 3,
      "text": "OUTPUT (32, 119)        ; Output 32 * 0x40 + 86 * 0x41 + 0x55,\n                        ; which is 32 * '@' + 86 'A' + 'U'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " ; Set a new small buffer LOAD (byte_copy_left, 32) LOAD (byte_copy_right, 48)",
      "ja": ";新しい小さなバッファロードを設定します（byte_copy_left、32）ロード（byte_copy_right、48）"
    },
    {
      "indent": 3,
      "text": "MEMSET (32, 4, 65, 1) ; Set first 4 bytes of the buffer to be ; 'ABCD' COPY (32, 4, 48) ; Copy from byte_copy_right (i.e., not ; in buffer)",
      "ja": "memset（32、4、65、1）;バッファーの最初の4バイトを設定します。「ABCD」コピー（32、4、48）;byte_copy_rightからコピー（つまり、バッファーではそうではありません）"
    },
    {
      "indent": 3,
      "text": "OUTPUT (48, 4) ; Output 0x4142 4344, which is 'ABCD'",
      "ja": "出力（48、4）;出力0x4142 4344、「ABCD」"
    },
    {
      "indent": 3,
      "text": "COPY (48, 4, 46) ; Copy from two before byte_copy_right to ; wrap around the buffer OUTPUT (32, 2) ; Output 0x4344, which is 'CD'",
      "ja": "コピー（48、4、46）;byte_copy_rightの前に2つからコピーします。バッファ出力の周りをラップ（32、2）;出力0x4344、「CD」"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output is above, and executing the code costs a total of 365 UDVM cycles.",
      "ja": "出力は上にあり、コードを実行すると合計365のUDVMサイクルがかかります。"
    },
    {
      "indent": 0,
      "text": "2.7. COPY-LITERAL and COPY-OFFSET",
      "section_title": true,
      "ja": "2.7. コピーリテラルとコピーオフセット"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the COPY-LITERAL and COPY-OFFSET instructions. The code is designed to test similar boundary cases to the code for the COPY instruction, as well as the following condition specific to COPY-LITERAL and COPY-OFFSET: 1. The COPY-LITERAL or COPY-OFFSET instruction overwrites the value of its destination.",
      "ja": "このセクションでは、コピーリテラルおよびコピーオフセットの手順をテストするためのアセンブリコードを提供します。このコードは、コピー命令のコードに同様の境界ケースをテストするように設計されています。また、コピーリテラルおよびコピーオフセットに固有の次の条件：1。コピーリテラルまたはコピーオフセット命令は、宛先の値を上書きします。"
    },
    {
      "indent": 3,
      "text": "2. The COPY-OFFSET instruction reads from an offset that wraps around the buffer (i.e., the offset is larger than the distance between byte_copy_left and the destination).",
      "ja": "2. コピーオフセット命令は、バッファーをラップするオフセットから読み取りされます（つまり、オフセットはBYTE_COPY_LEFTと宛先間の距離よりも大きくなります）。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:destination                    pad (2)\n:offset                         pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128) ; Set up circular buffer, source, and ; destination LOAD (32, 16640) LOAD (byte_copy_left, 64) LOAD (byte_copy_right, 128) LOAD (destination, 33)",
      "ja": "at（128）;円形バッファー、ソース、および;宛先の負荷（32、16640）ロード（byte_copy_left、64）load（byte_copy_right、128）load（destination、33）"
    },
    {
      "indent": 3,
      "text": "COPY-LITERAL (32, 128, $destination)    ; Copy from the left of the\n                        ; buffer overwriting bcl, bcr, and\n                        ; destination wrapping around the buffer\nOUTPUT (64, 8)          ; Check destination has been updated\n                        ; Output 0x4141 4141 0061 4141",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LOAD (destination, copy)",
      "ja": "ロード（宛先、コピー）"
    },
    {
      "indent": 3,
      "text": ":copy ; Overwrite the copy instruction COPY-LITERAL (32, 2, $destination) OUTPUT (copy, 2) ; Output 0x4141",
      "ja": "：コピー ;コピー命令を上書きするコピーリテラル（32、2、 $ destination）出力（コピー、2）;出力0x4141"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, 72) ; Set up new circular buffer LOAD (byte_copy_right, 82) LOAD (destination, 82) ; Set destination to byte_copy_right",
      "ja": "load（byte_copy_left、72）;新しい円形バッファーロード（byte_copy_right、82）ロード（宛先、82）をセットアップします。宛先をbyte_copy_rightに設定します"
    },
    {
      "indent": 3,
      "text": "MEMSET (72, 10, 65, 1) ; Fill the buffer with 0x41 - 4A",
      "ja": "Memset（72、10、65、1）;バッファーを0x41-4aで埋めます"
    },
    {
      "indent": 3,
      "text": "COPY-OFFSET (2, 6, $destination) ; Copy from within circular ; buffer to outside buffer",
      "ja": "コピーオフセット（2、6、$宛先）;内部からコピーします。バッファー外部バッファー"
    },
    {
      "indent": 3,
      "text": "LOAD (offset, 6) COPY-OFFSET ($offset, 4, $destination) ; Copy from byte_copy_right ; so reading outside buffer",
      "ja": "Load（Offset、6）コピーオフセット（$ offset、4、$ Destination）;byte_copy_rightからコピー;したがって、外部バッファーを読んでください"
    },
    {
      "indent": 3,
      "text": "OUTPUT ($byte_copy_right, 10) ; Output 0x494A 4142 4344 494A 4142, ; which is 'IJABCDIJAB' LOAD (destination, 80) ; Put destination within the ; buffer COPY-OFFSET (4, 4, $destination) ; Copy where destination wraps OUTPUT (destination, 2) ; Output 0x004A",
      "ja": "出力（$ byte_copy_right、10）;出力0x494a 4142 4344 494a 4142、;これは「ijabcdijab」荷重（宛先、80）です。宛先を内に置きます。バッファコピーオフセット（4、4、$宛先）;宛先ラップ出力（宛先、2）をコピーします。出力0x004a"
    },
    {
      "indent": 3,
      "text": "COPY-OFFSET (5, 4, $destination)    ; Copy where offset wraps from\n                                    ; left back around to the right\nOUTPUT (destination, 2)             ; Output 0x004E\nOUTPUT ($byte_copy_left, 10)        ; Output the circular buffer\n                                    ; 0x4748 4845 4647 4748 4546,\n                                    ; which is 'GHHEFGGHEF'",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is above, and the cost of execution is 216 UDVM cycles.",
      "ja": "コードの出力は上にあり、実行コストは216 UDVMサイクルです。"
    },
    {
      "indent": 0,
      "text": "2.8. MEMSET",
      "section_title": true,
      "ja": "2.8. メンバーセット"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the MEMSET instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、MEMSET命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The MEMSET instruction overwrites the registers byte_copy_left and byte_copy_right.",
      "ja": "1. MEMSET命令は、Registers BYTE_COPY_LEFTとBYTE_COPY_RIGHTを上書きします。"
    },
    {
      "indent": 3,
      "text": "2. The output values of the MEMSET instruction do not lie between 0 and 255 inclusive (in which case they must be taken modulo 2^8).",
      "ja": "2. MEMSET命令の出力値は、0〜255の包括的なものではありません（この場合、測定値2^8を取得する必要があります）。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, 128) ; sets up a circular buffer LOAD (byte_copy_right, 129) ; of 1 byte between 0x0080 and 0x0081",
      "ja": "load（byte_copy_left、128）;円形バッファーロードをセットアップします（byte_copy_right、129）。0x0080から0x0081の間の1バイト"
    },
    {
      "indent": 3,
      "text": "MEMSET (64, 129, 0, 1)  ; fills up the memory in the range\n                     ; 0x0040-0x007f with 0x00, ... 0x3f;\n                     ; then it writes successively at\n                     ; 0x0080 the following values 0x40, ... 0x80\n                     ; as a side effect, the values of\n                     ; bcl and bcr are modified.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "; before and during the MEMSET:\n; byte_copy_left: 0x0080 byte_copy_right: 0x0081\n; after the MEMSET:\n; byte_copy_left: 0x0001 byte_copy_right: 0x0203",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MEMSET (129, 15, 64, 15)     ; fills the memory range 0x0080-0x008f\n                      ; with values 0x40, 0x4f, ... 0xf4, 0x03, 0x12.\n                      ; as a side effect, it overwrites a\n                      ; part of the code including itself",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OUTPUT (128, 16) ; outputs 0x8040 4f5e 6d7c 8b9a ; a9b8 c7d6 e5f4 0312",
      "ja": "出力（128、16）;出力0x8040 4F5E 6D7C 8B9A;A9B8 C7D6 E5F4 0312"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312. Executing the code costs 166 UDVM cycles.",
      "ja": "コードの出力は0x8040 4F5E 6D7C 8B9A A9B8 C7D6 E5F4 0312です。コードの実行コストは166 UDVMサイクルです。"
    },
    {
      "indent": 0,
      "text": "2.9. CRC",
      "section_title": true,
      "ja": "2.9. CRC"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the CRC instruction. The code does not test any specific boundary cases (as there do not appear to be any) but focuses instead on verifying the CRC algorithm.",
      "ja": "このセクションでは、CRC命令をテストするためのアセンブリコードを提供します。コードは、特定の境界ケースをテストするのではなく（存在しないように見えます）、代わりにCRCアルゴリズムの検証に焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:crc_value                      pad (2)\n:crc_string_a                   pad (24)\n:crc_string_b                   pad (20)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "MEMSET (crc_string_a, 24, 1, 1) ; sets up between 0x0046 and 0x005d ; a byte string containing 0x01, ; 0x02, ... 0x18",
      "ja": "memset（crc_string_a、24、1、1）;0x0046から0x005Dの間にセットアップします。0x01を含むバイト文字列、;0x02、... 0x18"
    },
    {
      "indent": 3,
      "text": "MEMSET (crc_string_b, 20, 128, 1) ; sets up between 0x005e and 0x0071 ; a byte string containing 0x80, ; 0x81, ... 0x93",
      "ja": "memset（crc_string_b、20、128、1）;0x005eから0x0071の間にセットアップします。0x80を含むバイト文字列、;0x81、... 0x93"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (2, crc_value, decompression_failure)\n                                 ; reads in 2 bytes representing\n                                 ; the CRC value of the byte string\n                                 ; of 44 bytes starting at 0x0046",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CRC ($crc_value, crc_string_a, 44, decompression_failure)\n                                   ; computes the CRC value of the\n                                   ; byte string crc_string_a\n                                   ; concatenated with byte string\n                                   ; crc_string_b (with a total\n                                   ; length of 44 bytes).\n                                   ; if the computed value does\n                                   ; not match the 2-byte value read\n                                   ; previously, the program ends\n                                   ; with DECOMPRESSION-FAILURE.\nEND-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":decompression_failure DECOMPRESSION-FAILURE",
      "ja": "：decompression_failure減圧 -  failure"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x62cb, then the code should successfully terminate with no output, and with a total execution cost of 95 UDVM cycles. For different 2-byte compressed messages, the code should terminate with a decompression failure.",
      "ja": "圧縮メッセージが0x62CBの場合、コードは出力なしで正常に終了し、合計実行コストは95 UDVMサイクルで終了する必要があります。さまざまな2バイト圧縮メッセージの場合、コードは減圧障害で終了する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10. INPUT-BITS",
      "section_title": true,
      "ja": "2.10. 入力ビット"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-BITS instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力ビット命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-BITS instruction changes between any of the four possible bit orderings defined by the input_bit_order register.",
      "ja": "1. 入力ビット命令は、input_bit_orderレジスタによって定義された4つの可能なビット順序のいずれかの間で変更されます。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BITS instruction inputs 0 bits.",
      "ja": "2. 入力ビット命令は0ビットを入力します。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-BITS instruction requests data that lies beyond the end of the compressed message.",
      "ja": "3. 入力ビット命令は、圧縮メッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:input_bit_order                pad (2)\n:result                         pad (2)\n   at (128)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS ($input_bit_order, result, end_of_message) ; reads in\n                              ; exactly as many bits as the 2-byte\n                              ; value written in the input_bit_order\n                              ; register, get out of the loop when\n                              ; no more bits are available at input.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "OUTPUT (result, 2) ; outputs as a 2-byte integer ; the previously read bits",
      "ja": "出力（結果、2）;2バイト整数としての出力。以前に読み取られたビット"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1)      ; if at the beginning of this loop the\n                               ; register input_bit_order is 0,\nREMAINDER ($input_bit_order, 7) ; then its value varies periodically\n                               ; like this: 2, 4, 6, 1, 3, 5, 7.\nADD ($input_bit_order, 1)      ; that gives for the FHP bits: 010,\n                               ; 100, 110, 001, 011, 101, 111",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "JUMP (start) ; run the loop once more",
      "ja": "ジャンプスタート） ;ループをもう一度実行します"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "An example of a compressed message is 0x932e ac71, which decompresses to give the output 0x0000 0002 0002 0013 0000 0003 001a 0038. Executing the code costs 66 UDVM cycles.",
      "ja": "圧縮メッセージの例は0x932E AC71で、出力0x0000 0002 0002 0013 0000 0003 001A 0038を与えると減圧されます。コードの実行は66 UDVMサイクルです。"
    },
    {
      "indent": 0,
      "text": "2.11. INPUT-HUFFMAN",
      "section_title": true,
      "ja": "2.11. 入力ハフマン"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-HUFFMAN instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力ハフマン命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-HUFFMAN instruction changes between any of the four possible bit orderings defined by the input_bit_order register.",
      "ja": "1. input_bit_orderレジスタによって定義された4つの可能なビット順序のいずれかの間で、入力ハフマン命令が変更されます。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-HUFFMAN instruction inputs 0 bits.",
      "ja": "2. 入力ハフマン命令は0ビットを入力します。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-HUFFMAN instruction requests data that lies beyond the end of the compressed message.",
      "ja": "3. 入力-Huffman命令は、圧縮メッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:input_bit_order                pad (2)\n:result                         pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "INPUT-HUFFMAN (result, end_of_message, 2, $input_bit_order, 0, $input_bit_order, $input_bit_order, $input_bit_order, 0, 65535, 0) OUTPUT (result, 2)",
      "ja": "input-huffman（result、end_of_message、2、$ input_bit_order、0、$ input_bit_order、$ input_bit_order、$ input_bit_order、0、65535、0）出力（結果、2）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1) REMAINDER ($input_bit_order, 7) ADD ($input_bit_order, 1)",
      "ja": "add（$ input_bit_order、1）remainder（$ input_bit_order、7）add（$ input_bit_order、1）"
    },
    {
      "indent": 3,
      "text": "JUMP (start)",
      "ja": "ジャンプスタート）"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "An example of a compressed message is 0x932e ac71 66d8 6f, which decompresses to give the output 0x0000 0003 0008 04d7 0002 0003 0399 30fe. Executing the code costs 84 UDVM cycles.",
      "ja": "圧縮メッセージの例は0x932E AC71 66D8 6Fです。これは、出力0x0000 0003 0008 04D7 0003 0003 0399 30FEを提供するために減圧します。コードの実行には84のUDVMサイクルがかかります。"
    },
    {
      "indent": 3,
      "text": "As the code is run, the input_bit_order changes through all possible values to check usage of the H and P bits. The number of bits to input each time is taken from the value of input_bit_order. The sequence is the following:",
      "ja": "コードが実行されると、input_bit_orderはすべての可能な値を介して変更され、HおよびPビットの使用法を確認します。毎回入力するビット数は、input_bit_orderの値から取得されます。シーケンスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input_bit_order (bin)   Total bits input by Huffman             Value\n000                     0                                       0\n010                     2                                       3\n100                     4                                       8\n110                     12                                      1239\n001\nP-bit changed, throw away 6 bits\n001                     1                                       2\n011                     3                                       3\n101                     10                                      921\n111                     14                                      12542\n010\nP-bit changed, throw away 4 bits\n010                     0 - not enough bits so terminate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.12. INPUT-BYTES",
      "section_title": true,
      "ja": "2.12. 入力バイト"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the INPUT-BYTES instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、入力バイト命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The INPUT-BYTES instruction inputs 0 bytes.",
      "ja": "1. 入力バイト命令入力0バイト。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BYTES instruction requests data that lies beyond the end of the compressed message.",
      "ja": "2. Input-Bytes命令は、圧縮メッセージの終わりを超えてあるデータを要求します。"
    },
    {
      "indent": 3,
      "text": "3. The INPUT-BYTES instruction is used after part of a byte has been input (e.g., by the INPUT-BITS instruction).",
      "ja": "3. 入力バイト命令は、バイトの一部が入力された後に使用されます（たとえば、入力ビット命令による）。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:input_bit_order                pad (2)\n:result                         pad (2)\n:output_start                   pad (4)\n:output_end",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, output_start) LOAD (byte_copy_right, output_end)",
      "ja": "load（byte_copy_left、output_start）load（byte_copy_right、output_end）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS ($input_bit_order, result, end_of_message) OUTPUT (result, 2)",
      "ja": "input-bits（$ input_bit_order、result、end_of_message）output（result、2）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 2) REMAINDER ($input_bit_order, 7)",
      "ja": "add（$ input_bit_order、2）remainder（$ input_bit_order、7）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES ($input_bit_order, output_start, end_of_message) OUTPUT (output_start, $input_bit_order)",
      "ja": "input-bytes（$ input_bit_order、output_start、end_of_message）output（output_start、$ input_bit_order）"
    },
    {
      "indent": 3,
      "text": "ADD ($input_bit_order, 1) JUMP (start)",
      "ja": "追加（$ input_bit_order、1）ジャンプ（開始）"
    },
    {
      "indent": 3,
      "text": ":end_of_message",
      "ja": "：end_of_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0) An example of a compressed message is 0x932e ac71 66d8 6fb1 592b dc9a 9734 d847 a733 874e 1bcb cd51 b5dc 9659 9d6a, which decompresses to give the output 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8 0007 0001 3387 4e00 08dc 9651 b5dc 9600 599d 6a. Executing the code costs 130 UDVM cycles.",
      "ja": "終了メッセージ（0、0、0、0、0、0、0、0）圧縮メッセージの例は0x932E AC71 66D8 6FB1 592B DC9A 9734 D847 A733 874E 1BCB CD51 B5DC 9659 9659 9D6Aです。B166 D86F B100 1A2B 0003 9A97 34D8 0007 0001 3387 4E00 08DC 9651 B5DC 9600 599D 6A。コードの実行には130のUDVMサイクルがかかります。"
    },
    {
      "indent": 3,
      "text": "As the code is run, the input_bit_order changes through all possible values to check usage of the F and P bits. The number of bits or bytes to input each time is taken from the value of input_bit_order. For each INPUT-BYTES instruction, the remaining bits of the byte are thrown away. The P-bit always changes on the byte boundary so no bits are thrown away. The sequence is the following:",
      "ja": "コードが実行されると、input_bit_ordorはすべての可能な値を介して変更され、fおよびpビットの使用状況を確認します。毎回入力するビットまたはバイトの数は、input_bit_orderの値から取得されます。入力バイト命令ごとに、バイトの残りの部分が捨てられます。Pビットは常にバイトの境界で変更されるため、ビットは捨てられません。シーケンスは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Input_bit_order (bin)   Input bits  Input bytes   Output\n000                     0                         0x0000\n010                                 2             0x932e\n011                     3                         0x0001\n101                                 5             0xb166 d866 b1\n110                     6                         0x001a\n001                                 1             0x2b\n010                     2                         0x0003\n100                                 4             0x9a97 34d8\n101                     5                         0x0007\n000                                 0\n001                     1                         0x0001\n011                                 3             0x3384 4e\n100                     4                         0x0008\n110                                 6             0xdc96 51b5 dc96\n111                     7                         0x0059\n010                                 2             0x9d6a\n011                     3 - no bits left so terminate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.13. Stack Manipulation",
      "section_title": true,
      "ja": "2.13. スタック操作"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the PUSH, POP, CALL, and RETURN instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アセンブリコードを提供して、プッシュ、ポップ、コール、および返信命令をテストします。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The stack manipulation instructions overwrite the UDVM register stack_location.",
      "ja": "1. スタック操作手順は、UDVMレジスタstack_locationを上書きします。"
    },
    {
      "indent": 3,
      "text": "2. The CALL instruction specifies a reference operand rather than an absolute value.",
      "ja": "2. コール命令は、絶対値ではなく参照オペランドを指定します。"
    },
    {
      "indent": 3,
      "text": "3. The PUSH instruction pushes the value contained in stack_fill onto the stack.",
      "ja": "3. プッシュ命令は、stack_fillに含まれる値をスタックに押し込みます。"
    },
    {
      "indent": 3,
      "text": "4. The stack_location register contains an odd integer.",
      "ja": "4. stack_locationレジスタには奇妙な整数が含まれています。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:input_bit_order                pad (2)\n:stack_location                 pad (2)\n:next_address                   pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 64) PUSH (2) PUSH ($64) PUSH (66) ; Stack now contains 2, 1, 66 ; so $stack_location = 66",
      "ja": "Load（Stack_Location、64）プッシュ（2）プッシュ（64ドル）プッシュ（66）;スタックには2、1、66が含まれるようになりました。したがって、$ stack_location = 66"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 8) ; Output 0x0003 0002 0001 0042",
      "ja": "出力（64、8）;出力0x0003 0002 0001 0042"
    },
    {
      "indent": 3,
      "text": "POP (64) ; Pop value 66 from address 70 to address 64 POP ($stack_location) ; Pop value 1 from address 68 to address 66 ; so stack_fill is overwritten to be 1 POP (stack_location) ; Pop value 1 from address 68 to address 70",
      "ja": "ポップ（64）;アドレス70から64ポップ（$ stack_location）からポップ値66;アドレス68からアドレス66からポップ値1。したがって、stack_fillは上書き1ポップ（stack_location）になります。アドレス68からアドレス70からポップ値1"
    },
    {
      "indent": 3,
      "text": "OUTPUT (64, 8) ; Output 0x0042 0000 0001 0001 JUMP (address_a)",
      "ja": "出力（64、8）;出力0x0042 0000 0001 0001ジャンプ（address_a）"
    },
    {
      "indent": 3,
      "text": "at (192)",
      "ja": "で（192）"
    },
    {
      "indent": 3,
      "text": ":address_a",
      "ja": "：address_a"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 32) LOAD (next_address, address_c) SUBTRACT ($next_address, address_b) ; next_address = 64 CALL (address_b) ; push 204 on stack",
      "ja": "load（stack_location、32）load（next_address、address_c）削除（$ next_address、address_b）;next_address = 64 call（address_b）;スタックで204を押します"
    },
    {
      "indent": 3,
      "text": "at (256)",
      "ja": "で（256）"
    },
    {
      "indent": 3,
      "text": ":address_b",
      "ja": "：address_b"
    },
    {
      "indent": 3,
      "text": "CALL ($next_address) ; push 256 on stack",
      "ja": "call（$ next_address）;スタックで256を押します"
    },
    {
      "indent": 3,
      "text": "at (320)",
      "ja": "で（320）"
    },
    {
      "indent": 3,
      "text": ":address_c",
      "ja": "：address_c"
    },
    {
      "indent": 3,
      "text": "LOAD (stack_location, 383) LOAD (383, 26) ; overwrite $stack_location with 26 MULTILOAD (432, 3, 1, 49153, 32768)",
      "ja": "load（stack_location、383）load（383、26）;26マルチロード（432、3、1、49153、32768）で$ stack_locationを上書きする"
    },
    {
      "indent": 36,
      "text": "; write bytes so that 433 and 434\n; contain 0x01c0 = 448 and\n; 435 and 436 contain 0x0180 = 384",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "RETURN                           ; pop 383 from the stack and jump\n                                 ; there = 384, which is lsb of\n                                 ; stack_fill, which now contains 25,\n                                 ; which is UDVM instruction RETURN\n                                 ; pop 448 from the stack and jump\n                                 ; there\nat (448)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0003 0002 0001 0042 0042 0000 0001 0001, and a total of 40 UDVM cycles are used.",
      "ja": "コードの出力は0x0003 0002 0001 0042 0042 0000 0001 0001であり、合計40のUDVMサイクルが使用されます。"
    },
    {
      "indent": 0,
      "text": "2.14. Program Flow",
      "section_title": true,
      "ja": "2.14. プログラムフロー"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the JUMP, COMPARE, and SWITCH instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、ジャンプ、比較、および切り替えの命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The address operands are specified as references to memory addresses rather than as absolute values.",
      "ja": "1. アドレスオペランドは、絶対値としてではなく、メモリアドレスへの参照として指定されています。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":next_address                   pad (2)\n:counter                        pad (1)\n:counter_lsb                    pad (1)\n:switch_counter                 pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (switch_counter, 4)",
      "ja": "Load（switch_counter、4）"
    },
    {
      "indent": 3,
      "text": ":address_a",
      "ja": "：address_a"
    },
    {
      "indent": 3,
      "text": "LOAD (next_address, address_c) SUBTRACT ($next_address, address_b) ; address_c - address_b OUTPUT (counter_lsb, 1)",
      "ja": "load（next_address、address_c）subtract（$ next_address、address_b）;address_c -address_b output（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_b",
      "ja": "：address_b"
    },
    {
      "indent": 3,
      "text": "JUMP ($next_address) ; Jump to address_c",
      "ja": "Jump（$ next_address）;address_cにジャンプします"
    },
    {
      "indent": 3,
      "text": ":address_c ADD ($counter, 1) LOAD (next_address, address_a) SUBTRACT ($next_address, address_d) ; address_a - address_d OUTPUT (counter_lsb, 1)",
      "ja": "：address_c add（$ counter、1）load（next_address、address_a）subtract（$ next_address、address_d）;address_a -address_d output（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_d",
      "ja": "：address_d"
    },
    {
      "indent": 3,
      "text": "COMPARE ($counter, 6, $next_address, address_c, address_e) ; counter < 6, $next_address gives ; jump to address_a",
      "ja": "比較（$ counter、6、$ next_address、address_c、address_e）;カウンター<6、$ next_address gives;address_aにジャンプします"
    },
    {
      "indent": 3,
      "text": ":address_e",
      "ja": "：address_e"
    },
    {
      "indent": 3,
      "text": "SUBTRACT ($switch_counter, 1) ; switch_counter = 3 LOAD (next_address, address_a) SUBTRACT ($next_address, address_f) ; address_a - address_f OUTPUT (counter_lsb, 1)",
      "ja": "削除（$ switch_counter、1）;switch_counter = 3 load（next_address、address_a）subtract（$ next_address、address_f）;address_a -address_f output（counter_lsb、1）"
    },
    {
      "indent": 3,
      "text": ":address_f",
      "ja": "：address_f"
    },
    {
      "indent": 3,
      "text": "SWITCH (4, $switch_counter, address_g, $next_address, address_c,\naddress_e)\n                                ; when $switch_counter = 1,\n                                ; $next_address gives jump to\n                                ; address_a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":address_g",
      "ja": "：address_g"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909, and a total of 131 UDVM cycles are used.",
      "ja": "コードの出力は0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909で、合計131のUDVMサイクルが使用されます。"
    },
    {
      "indent": 0,
      "text": "2.15. State Creation",
      "section_title": true,
      "ja": "2.15. 国家の創造"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the STATE-CREATE and STATE-FREE instructions. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アセンブリコードを提供して、状態作成および州のない指示をテストします。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. An item of state is created that duplicates an existing state item.",
      "ja": "1. 既存の状態アイテムを複製する状態のアイテムが作成されます。"
    },
    {
      "indent": 3,
      "text": "2. An item of state is freed when the state has not been created.",
      "ja": "2. 国家が作成されていない場合、国家の項目が解放されます。"
    },
    {
      "indent": 3,
      "text": "3. An item of state is created and then freed by the same message.",
      "ja": "3. 状態のアイテムが作成され、同じメッセージによって解放されます。"
    },
    {
      "indent": 3,
      "text": "4. The STATE-FREE instruction frees a state item by sending fewer bytes of the state_identifier than the minimum_access_length.",
      "ja": "4. 状態のない命令は、最小限_Access_lengthよりもState_Identifierのバイトを少なく送信することにより、状態項目を解放します。"
    },
    {
      "indent": 3,
      "text": "5. The STATE-FREE instruction has partial_identifier_length operand shorter than 6 or longer than 20.",
      "ja": "5. 州のない命令には、partial_identifier_length Operandが20より6以下より短いです。"
    },
    {
      "indent": 3,
      "text": "6. The STATE-FREE instruction specifies a partial_identifier that matches with two state items in the compartment.",
      "ja": "6. 州のない命令は、コンパートメント内の2つの状態アイテムと一致するPartial_identifierを指定します。"
    },
    {
      "indent": 3,
      "text": "7. The bytes of the identifier are written to the position specified in the STATE-FREE instruction after the STATE-FREE instruction has been run (and before END-MESSAGE).",
      "ja": "7. 識別子のバイトは、州のない命令が実行された後（および終了前に）、州のない命令で指定された位置に書き込まれます。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:states                         pad (1)\n:states_lsb                     pad (1)\n:min_len                        pad (1)\n:min_len_lsb                    pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":state_identifier pad (20)",
      "ja": "：state_identifierパッド（20）"
    },
    {
      "indent": 3,
      "text": "set (state_length, 10)",
      "ja": "set（state_length、10）"
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "at（127）：decompression_failure at（128）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, states_lsb, decompression_failure)",
      "ja": "input-bytes（1、states_lsb、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":test_one LSHIFT ($states, 11) COMPARE ($states, 32768, test_two, create_state_a2, create_state_a2)",
      "ja": "：test_one lshift（$ states、11）比較（$ states、32768、test_two、create_state_a2、create_state_a2）"
    },
    {
      "indent": 3,
      "text": ":create_state_a2 STATE-CREATE (state_length, state_address2, 0, 20, 0)",
      "ja": "：create_state_a2 state-create（state_length、state_address2、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":test_two LSHIFT ($states, 1) COMPARE ($states, 32768, test_three, create_state_a, create_state_a)",
      "ja": "：test_two lshift（$ states、1）比較（$ states、32768、test_three、create_state_a、create_state_a）"
    },
    {
      "indent": 3,
      "text": ":create_state_a STATE-CREATE (state_length, state_address, 0, 20, 0)",
      "ja": "：create_state_a state-create（state_length、state_address、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":test_three LSHIFT ($states, 1) COMPARE ($states, 32768, test_four, free_state, free_state)",
      "ja": "：test_three lshift（$ states、1）比較（$ states、32768、test_four、free_state、free_state）"
    },
    {
      "indent": 3,
      "text": ":free_state INPUT-BYTES (1, min_len_lsb, decompression_failure) STATE-FREE (state_identifier, $min_len) COPY (identifier1, $min_len, state_identifier)",
      "ja": "：free_state input-bytes（1、min_len_lsb、decompression_failure）state-free（state_identifier、$ min_len）コピー（識別子、$ min_len、state_identifier）"
    },
    {
      "indent": 3,
      "text": ":test_four",
      "ja": "：test_four"
    },
    {
      "indent": 3,
      "text": "LSHIFT ($states, 1) COMPARE ($states, 32768, test_five, free_state2, free_state2)",
      "ja": "lshift（$ states、1）比較（$ states、32768、test_five、free_state2、free_state2）"
    },
    {
      "indent": 3,
      "text": ":free_state2 STATE-FREE (identifier1, 6)",
      "ja": "：free_state2 state-free（識別子1、6）"
    },
    {
      "indent": 3,
      "text": ":test_five LSHIFT ($states, 1) COMPARE ($states, 32768, end, create_state_b, create_state_b)",
      "ja": "：test_five lshift（$ states、1）比較（$ states、32768、end、create_state_b、create_state_b）"
    },
    {
      "indent": 3,
      "text": ":create_state_b END-MESSAGE (0, 0, state_length, state_address, 0, 20, 0)",
      "ja": "：create_state_b end-message（0、0、state_length、state_address、0、20、0）"
    },
    {
      "indent": 3,
      "text": ":end END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "：end end-message（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":identifier1 byte (67, 122, 232, 10, 15, 220, 30, 106, 135, 193, 182, 42, 118, 118, 185, 115, 49, 140, 14, 245)",
      "ja": "：識別子バイト（67、122、232、10、15、220、30、106、135、193、182、42、118、118、185、115、49、140、14、245）"
    },
    {
      "indent": 3,
      "text": "at (256) :state_address byte (192, 204, 63, 238, 121, 188, 252, 143, 209, 8)",
      "ja": "at（256）：state_address byte（192、204、63、238、121、188、252、143、209、8）"
    },
    {
      "indent": 3,
      "text": ":state_address2 byte (101, 232, 3, 82, 238, 41, 119, 23, 223, 87)",
      "ja": "：state_address2 byte（101、232、3、82、238、41、119、23、223、87）"
    },
    {
      "indent": 3,
      "text": "Upon reaching the END-MESSAGE instruction, the UDVM does not output any decompressed data, but instead may make one or more state creation or state free requests to the state handler. Assuming that the application does not veto the state creation request (and that sufficient state memory is available) the code results in 0, 1, or 2 state items being present in the compartment.",
      "ja": "最終説明に到達すると、UDVMは減圧データを出力せず、代わりに州のハンドラーに1つ以上の州の作成または州の無料リクエストを行う可能性があります。アプリケーションが州の作成要求を拒否しないと仮定すると（および十分な状態メモリが利用可能である）、コードはコンパートメントに0、1、または2つの状態項目が存在します。"
    },
    {
      "indent": 3,
      "text": "The following table lists ten different compressed messages, the states created and freed by each, the number of states left after each message, and the number of UDVM cycles used. There are 3 state creation instructions:",
      "ja": "次の表には、それぞれによって作成および解放された状態、各メッセージの後に残された状態の数、および使用されているUDVMサイクルの数が10の異なる圧縮メッセージを示します。3つの州の作成指示があります。"
    },
    {
      "indent": 6,
      "text": "create state_a, which has hash identifier1 create state_b (in END-MESSAGE), which is identical to state_a create state_a2, which has a different identifier, but the first 6 bytes are the same as those of identifier1.",
      "ja": "Hash Identifier1 CREATE STATE_B（End-Message）を備えたState_aを作成します。これは、State_a Create State_A2と同じです。"
    },
    {
      "indent": 3,
      "text": "Message:   Effect:                           # state items:  #cycles:\n0x01       create state_b                             1           23\n0x02       free (id1, 6) = state_b                    0           14\n0x03       free (id1, 6) = state_b; create state_b    1           24",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0x0405 free (id1, 5) Decompression failure 0x0415 free (id1, 21) Decompression failure",
      "ja": "0x0405無料（ID1、5）減圧障害0x0415フリー（ID1、21）減圧障害"
    },
    {
      "indent": 3,
      "text": "0x0406 free (id1, 6) = state_b 0 23",
      "ja": "0x0406 free（id1、6）= state_b 0 23"
    },
    {
      "indent": 3,
      "text": "0x09 create state_a; create state_b 1 34",
      "ja": "0x09 create state_a;State_B 1 34を作成します"
    },
    {
      "indent": 3,
      "text": "0x1e06     create state_a2; create state_a;\n           free (id1, 6) = matches both so no free;\n           free (id1, 6) = matches both so no free;   2           46",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0x1e07     create state_a2; create state_a;\n           free (id1, 7) = state_a;\n           free (id1, 6) = state_a2                   0           47",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0x1e14     create state_a2; create state_a;\n           free (id1, 20) = state_a;\n           free (id1, 6) = state_a2                   0           60",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.16. STATE-ACCESS",
      "section_title": true,
      "ja": "2.16. 状態アクセス"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the STATE-ACCESS instruction. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、ステートアクセス命令をテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. A subset of the bytes contained in a state item is copied to the UDVM memory.",
      "ja": "1. 状態項目に含まれるバイトのサブセットは、UDVMメモリにコピーされます。"
    },
    {
      "indent": 3,
      "text": "2. Bytes are copied from beyond the end of the state value.",
      "ja": "2. バイトは、状態値の終わりからコピーされます。"
    },
    {
      "indent": 3,
      "text": "3. The state_instruction operand is set to 0.",
      "ja": "3. State_instruction Operandは0に設定されています。"
    },
    {
      "indent": 3,
      "text": "4. The state cannot be accessed because the partial state identifier is too short.",
      "ja": "4. 部分状態識別子が短すぎるため、状態にアクセスできません。"
    },
    {
      "indent": 3,
      "text": "5. The state identifier is overwritten by the state item being accessed.",
      "ja": "5. 状態識別子は、アクセスされる状態項目によって上書きされます。"
    },
    {
      "indent": 3,
      "text": "The following bytecode needs to be run first to set up the state for the rest of the test.",
      "ja": "次のバイトコードを最初に実行して、残りのテストのために状態をセットアップする必要があります。"
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, state_length, state_start, 0, 20, 0)",
      "ja": "end-message（0、0、state_length、state_start、0、20、0）"
    },
    {
      "indent": 3,
      "text": "; The bytes between state_start and state_end are derived from\n; translation of the following mnemonic code:\n;\n; at (512)\n; OUTPUT (data, 4)\n; END-MESSAGE (0,0,0,0,0,0,0)\n; :data\n; byte (116, 101, 115, 116)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (512) :state_start byte (34, 162, 12,4, 35, 0, 0, 0, 0, 0, 0, 0, 116, 101, 115, 116) :state_end",
      "ja": "at（512）：state_start byte（34、162、12、4、35、0、0、0、0、0、0、116、101、115、116）：state_end"
    },
    {
      "indent": 3,
      "text": "set (state_length, (state_end - state_start))",
      "ja": "set（state_length、（state_end -state_start））"
    },
    {
      "indent": 3,
      "text": "This is the bytecode for the rest of the test.",
      "ja": "これは、残りのテストのバイトコードです。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:type                           pad (1)\n:type_lsb                       pad (1)\n:state_value                    pad (4)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "at（127）：decompression_failure at（128）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 1, execute_state, extract_state, error_conditions)",
      "ja": "input-bytes（1、type_lsb、decompression_failure）比較（$ type、1、execute_state、extract_state、error_conditions）"
    },
    {
      "indent": 3,
      "text": ":execute_state",
      "ja": "：execute_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 0, 0, 0, 512)",
      "ja": "state-access（state_identifier、20、0、0、512）"
    },
    {
      "indent": 3,
      "text": ":extract_state",
      "ja": "：extract_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 12, 4, state_value, 0) OUTPUT (state_value, 4) JUMP (end)",
      "ja": "State-Access（State_Identifier、20、12、4、State_Value、0）出力（State_Value、4）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":error_conditions COMPARE ($type, 3, state_not_found, id_too_short, state_too_short)",
      "ja": "：error_conditions比較（$ type、3、state_not_found、id_too_short、state_too_short）"
    },
    {
      "indent": 3,
      "text": ":state_not_found",
      "ja": "：state_not_found"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (128, 20, 0, 0, 0, 0) JUMP (end)",
      "ja": "状態アクセス（128、20、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":id_too_short",
      "ja": "：id_too_short"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 19, 6, 4, state_value, 0) JUMP (end)",
      "ja": "state-access（state_identifier、19、6、4、state_value、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":state_too_short",
      "ja": "：state_too_short"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier, 20, 12, 5, state_value, 0) JUMP (end)",
      "ja": "state-access（state_identifier、20、12、5、state_value、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": "at (484)",
      "ja": "で（484）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_identifier",
      "ja": "：state_identifier"
    },
    {
      "indent": 3,
      "text": "byte (0x5d, 0xf8, 0xbc, 0x3e, 0x20, 0x93, 0xb5, 0xab, 0xe1, 0xf1, 0x70, 0x13, 0x42, 0x4c, 0xe7, 0xfe, 0x05, 0xe0, 0x69, 0x39)",
      "ja": "バイト（0x5d、0xf8、0xbc、0x3e、0x20、0x93、0xb5、0xab、0xe1、0xf1、0x70、0x13、0x42、0x4c、0xe7、0xfe、0x05、0xe0、0x69、0x39）"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x00, then the output of the code is 0x7465 7374, and a total of 26 UDVM cycles are used. If the compressed message is 0x01, then the output of the code is also 0x7465 7374 but in this case using a total of 15 UDVM cycles. If the compressed message is 0x02, 0x03, or 0x04, then decompression failure occurs.",
      "ja": "圧縮メッセージが0x00の場合、コードの出力は0x7465 7374で、合計26のUDVMサイクルが使用されます。圧縮メッセージが0x01の場合、コードの出力も0x7465 7374ですが、この場合は合計15のUDVMサイクルを使用します。圧縮メッセージが0x02、0x03、または0x04の場合、減圧障害が発生します。"
    },
    {
      "indent": 0,
      "text": "3. Torture Tests for Dispatcher",
      "section_title": true,
      "ja": "3. ディスパッチャーの拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections give code to test the various functions of the SigComp dispatcher.",
      "ja": "次のセクションでは、SigComp Dispatcherのさまざまな機能をテストするためのコードを示します。"
    },
    {
      "indent": 0,
      "text": "3.1. Useful Values",
      "section_title": true,
      "ja": "3.1. 有用な値"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test that the SigComp \"Useful Values\" are correctly initialized in the UDVM memory. It also tests that the UDVM is correctly terminated if the bytecode uses too many UDVM cycles or tries to write beyond the end of the available memory.",
      "ja": "このセクションでは、SigCompの「有用な値」がUDVMメモリで正しく初期化されていることをテストするためのアセンブリコードを提供します。また、ByteCodeがUDVMサイクルが多すぎるか、使用可能なメモリの終わりを超えて書き込もうとする場合、UDVMが正しく終了することもテストします。"
    },
    {
      "indent": 3,
      "text": "The code tests that the following boundary cases have been correctly implemented:",
      "ja": "コードは、次の境界ケースが正しく実装されていることをテストします。"
    },
    {
      "indent": 3,
      "text": "1. The bytecode uses exactly as many UDVM cycles as are available (in which case no problems should arise) or one cycle too many (in which case decompression failure should occur). A liberal implementation could allow more cycles to be used than are strictly available, in which case decompression failure will not occur. This is an implementation choice. If this choice is made, the implementer must be sure that the cycles are checked eventually and that decompression failure does occur when bytecode uses an excessive number of cycles. This is tested in Section 3.2.",
      "ja": "1. Bytecodeは、利用可能な数のUDVMサイクル（この場合は問題は発生しないはずです）または1つのサイクルが多すぎる（この場合は減圧障害が発生するはずです）を使用します。リベラルな実装では、厳密に利用できるよりも多くのサイクルを使用できるようになります。その場合、減圧の故障は発生しません。これは実装の選択です。この選択が行われた場合、実装者は最終的にサイクルがチェックされ、バイトコードが過剰な数のサイクルを使用すると減圧の故障が発生することを確認する必要があります。これはセクション3.2でテストされています。"
    },
    {
      "indent": 3,
      "text": "2. The bytecode writes to the highest memory address available (in which case no problems should arise) or to the memory address immediately following the highest available address (in which case decompression failure must occur).",
      "ja": "2. ByteCodeは、利用可能な最高のメモリアドレス（問題は発生しないでください）に書き込み、または利用可能な最高のアドレスの直後のメモリアドレス（この場合は減圧障害が発生する必要があります）に書き込みます。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size               pad (2)\n:cycles_per_bit                 pad (2)\n:sigcomp_version                pad (2)\n:partial_state_id_length        pad (2)\n:state_length                   pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:remaining_cycles               pad (2)\n:check_memory                   pad (1)\n:check_memory_lsb               pad (1)\n:check_cycles                   pad (1)\n:check_cycles_lsb               pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128) ; Set up a 1-byte buffer LOAD (byte_copy_left, 32) LOAD (byte_copy_right, 33)",
      "ja": "at（127）：decompression_failure at（128）;1バイトバッファロード（byte_copy_left、32）ロード（byte_copy_right、33）をセットアップします"
    },
    {
      "indent": 3,
      "text": ":test_version",
      "ja": "：test_version"
    },
    {
      "indent": 3,
      "text": "; Input a byte containing the version of SigComp being run INPUT-BYTES (1, check_memory_lsb, decompression_failure) COMPARE ($sigcomp_version, $check_memory, decompression_failure, test_state_access, decompression_failure)",
      "ja": ";入力sigcompのバージョンを含むバイトを入力します入力バイト（1、check_memory_lsb、decompression_failure）の比較（$ sigcomp_version、$ check_memory、decompression_failure、test_state_access、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":test_state_access",
      "ja": "：test_state_access"
    },
    {
      "indent": 3,
      "text": "COMPARE ($partial_state_id_length, 0, decompression_failure, test_length_equals_zero, test_state_length)",
      "ja": "比較（$ partial_state_id_length、0、decompression_failure、test_length_equals_zero、test_state_length）"
    },
    {
      "indent": 3,
      "text": ":test_length_equals_zero ; No state was accessed so state_length ; should be zero (first message) COMPARE ($state_length, 0, decompression_failure, end, decompression_failure)",
      "ja": "：test_length_equals_zero;状態がアクセスされなかったため、state_length;ゼロ（最初のメッセージ）比較（$ state_length、0、decompression_failure、end、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":test_state_length ; State was accessed so state_length ; should be 960 COMPARE ($state_length, 960, decompression_failure, test_udvm_memory, decompression_failure)",
      "ja": "：test_state_length;状態はSTATE_LENGTHでアクセスされました。960比較（$ state_length、960、decompression_failure、test_udvm_memory、decompression_failure）である必要があります"
    },
    {
      "indent": 3,
      "text": ":test_udvm_memory\n                            ; Copy one byte to\n                            ; udvm_memory_size + input - 1\n                            ; Succeed when input byte is 0x00\n                            ; Fail when input byte is 0x01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, check_memory_lsb, decompression_failure) ADD ($check_memory, $udvm_memory_size) SUBTRACT ($check_memory, 1) COPY (32, 1, $check_memory)",
      "ja": "input-bytes（1、check_memory_lsb、decompression_failure）add（$ check_memory、$ udvm_memory_size）減算（$ check_memory、1）コピー（32、1、$ check_memory）"
    },
    {
      "indent": 3,
      "text": ":test_udvm_cycles",
      "ja": "：test_udvm_cycles"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, check_cycles_lsb, decompression_failure)",
      "ja": "input-bytes（1、check_cycles_lsb、decompression_failure）"
    },
    {
      "indent": 3,
      "text": "; Work out the total number of cycles available to the UDVM\n; total_UDVM_cycles = cycles_per_bit * (8 * message_size + 1000)\n;\n;       = cycles_per_bit * (8 * (partial_state_id_length + 3) + 1000)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LOAD (remaining_cycles, $partial_state_id_length) ADD ($remaining_cycles, 3) MULTIPLY ($remaining_cycles, 8) ADD ($remaining_cycles, 1000)",
      "ja": "load（resight_cycles、$ partial_state_id_length）add（$ resterial_cycles、3）乗算（$ resteal_cycles、8）add（$ resteal_cycles、1000）"
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($remaining_cycles, $cycles_per_bit)",
      "ja": "乗算（$ reshing_cycles、$ cycles_per_bit）"
    },
    {
      "indent": 3,
      "text": "ADD ($remaining_cycles, $check_cycles)",
      "ja": "add（$ reshing_cycles、$ check_cycles）"
    },
    {
      "indent": 3,
      "text": "set (cycles_used_by_bytecode, 856)\n   SUBTRACT ($remaining_cycles, cycles_used_by_bytecode)\nCOPY (32, $remaining_cycles, 32)\n                ; Copy to use up all cycles available + input byte\n                ; Succeeds when input byte = 0x00\n                ; Fail when input byte = 0x01",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":end ; Create 960 bytes of state for future ; reference END-MESSAGE (0, 0, 960, 64, 128, 6, 0)",
      "ja": "：終わり ;将来のために960バイトの状態を作成します。参照末端（0、0、960、64、128、6、0）"
    },
    {
      "indent": 3,
      "text": "The bytecode must be executed a total of four times in order to fully test the SigComp Useful Values. In the first case, the bytecode is uploaded as part of the SigComp message with a 1-byte compressed message corresponding to the version of SigComp being run. This causes the UDVM to request creation of a new state item and uses a total of 968 UDVM cycles.",
      "ja": "SigCompの有用な値を完全にテストするには、ByteCodeを合計4回実行する必要があります。最初のケースでは、bytecodeは、実行中のSigcompのバージョンに対応する1バイトの圧縮メッセージを使用して、Sigcompメッセージの一部としてアップロードされます。これにより、UDVMは新しい状態アイテムの作成を要求し、合計968のUDVMサイクルを使用します。"
    },
    {
      "indent": 3,
      "text": "Subsequent tests access this state by uploading the state identifier as part of the SigComp message. Note that the SigComp message should not contain a returned feedback item (as this would cause the bytecode to calculate the total number of available UDVM cycles incorrectly).",
      "ja": "その後のテストは、SigCompメッセージの一部として状態識別子をアップロードすることにより、この状態にアクセスします。SigCompメッセージには、返されたフィードバック項目が含まれてはならないことに注意してください（これにより、Bytecodeが利用可能なUDVMサイクルの総数を誤って計算するため）。"
    },
    {
      "indent": 3,
      "text": "A 3-byte compressed message is required for the second and subsequent cases, the first byte of which is the version of SigComp in use, 0xnn. If the message is 0xnn0000, then the UDVM should successfully terminate using exactly the number of available UDVM cycles. However, if the message is 0xnn0001, then the UDVM should use too many cycles and hence terminate with decompression failure. Furthermore, if the message is 0xnn0100, then decompression failure must occur because the UDVM attempts to write beyond its available memory.",
      "ja": "2番目と後続のケースには3バイトの圧縮メッセージが必要です。最初のバイトは、使用中のSigcompのバージョン、0xnnです。メッセージが0xNN0000の場合、UDVMは、使用可能なUDVMサイクルの数を正確に使用して正確に終了する必要があります。ただし、メッセージが0xNN0001の場合、UDVMはあまりにも多くのサイクルを使用するため、減圧障害で終了する必要があります。さらに、メッセージが0xNN0100の場合、UDVMが利用可能なメモリを超えて書き込もうとするため、減圧障害が発生する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. Cycles Checking",
      "section_title": true,
      "ja": "3.2. サイクルチェック"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.1, it is possible to write an implementation that takes a liberal approach to checking the cycles used and allows some extra cycles. The implementer must be sure that decompression failure does not occur too early and that in the case of excessive use of cycles, decompression failure does eventually occur. This test checks that:",
      "ja": "セクション3.1で説明したように、使用されるサイクルをチェックするためにリベラルなアプローチをとる実装を記述することができ、いくつかの追加サイクルを許可します。実装者は、減圧の故障が早すぎないことを確認する必要があり、サイクルが過度に使用される場合、減圧障害が最終的に発生することを確認する必要があります。このテストはそれをチェックします："
    },
    {
      "indent": 3,
      "text": "1. Decompression failure occurs eventually when there is an infinite loop.",
      "ja": "1. 無限のループがある場合、最終的に減圧の故障が発生します。"
    },
    {
      "indent": 3,
      "text": "at (64)\n:byte_copy_left           pad (2)\n:byte_copy_right          pad (2)\n:value                    pad (2)\n:copy_next                pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at(128) MULTILOAD (byte_copy_left, 4, 32, 41, 0, 34) ; Set up a 10-byte buffer",
      "ja": "at（128）Multiload（byte_copy_left、4、32、41、0、34）;10バイトバッファーをセットアップします"
    },
    {
      "indent": 3,
      "text": "                                ; Set the value to copy\n                                ; Copy it 100 times,\n                                ; output the value,\n                                ; increment the counter\n:loop\nCOPY (value, 2, $byte_copy_left)\nCOPY-OFFSET (2, 100, $copy_next)\nOUTPUT (value, 2)\nADD ($value, 1)\nJUMP (loop)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the cycles are counted exactly and cycles per bit (cpb) = 16, then decompression failure will occur at COPY-OFFSET when value = 180 = 0xB4. If cpb = 32, then decompression failure will occur when value = 361 = 0x0169. If they are not counted exactly, then decompression failure MUST occur eventually.",
      "ja": "サイクルが正確にカウントされ、ビットあたりのサイクル（CPB）= 16の場合、値= 180 = 0xB4の場合、コピーオフセットで減圧障害が発生します。CPB = 32の場合、値= 361 = 0x0169の場合、減圧障害が発生します。それらが正確にカウントされない場合、最終的に減圧障害が発生する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Message-based Transport",
      "section_title": true,
      "ja": "3.3. メッセージベースのトランスポート"
    },
    {
      "indent": 3,
      "text": "This section provides a set of messages to test the SigComp header over a message-based transport such as UDP. The messages test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、UDPなどのメッセージベースのトランスポートを介してSigCompヘッダーをテストするための一連のメッセージを提供します。メッセージは、次の境界ケースが正しく実装されていることをテストします。"
    },
    {
      "indent": 3,
      "text": "1. The UDVM bytecode is copied to different areas of the UDVM memory.",
      "ja": "1. UDVMバイトコードは、UDVMメモリのさまざまな領域にコピーされます。"
    },
    {
      "indent": 3,
      "text": "2. The decompression memory size is set to an incorrect value.",
      "ja": "2. 減圧メモリサイズは誤った値に設定されます。"
    },
    {
      "indent": 3,
      "text": "3. The SigComp message is too short.",
      "ja": "3. Sigcompメッセージは短すぎます。"
    },
    {
      "indent": 3,
      "text": "4. The destination address is invalid.",
      "ja": "4. 宛先アドレスが無効です。"
    },
    {
      "indent": 3,
      "text": "The basic version of the code used in the test is given below. Note that the code is designed to calculate the decompression memory size based on the Useful Values provided to the UDVM:",
      "ja": "テストで使用されるコードの基本バージョンを以下に示します。コードは、UDVMに提供される有用な値に基づいて、減圧メモリサイズを計算するように設計されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size               pad (2)\n:cycles_per_bit                 pad (2)\n:sigcomp_version                pad (2)\n:partial_state_id_length        pad (2)\n:state_length                   pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": ":code_start",
      "ja": "：code_start"
    },
    {
      "indent": 3,
      "text": "; udvm_memory_size for message-based transport\n;    = DMS - total_message_size",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ADD ($udvm_memory_size, total_message_size) OUTPUT (udvm_memory_size, 2) END-MESSAGE (0, 0, 0, 0, 0, 0, 1)",
      "ja": "add（$ udvm_memory_size、total_message_size）output（udvm_memory_size、2）end-message（0、0、0、0、0、1）"
    },
    {
      "indent": 3,
      "text": ":code_end",
      "ja": "：code_end"
    },
    {
      "indent": 3,
      "text": "set (header_size, 3) set (code_size, (code_end - code_start)) set (total_message_size, (header_size + code_size))",
      "ja": "set（header_size、3）set（code_size、（code_end -code_start））set（total_message_size、（header_size code_size））"
    },
    {
      "indent": 3,
      "text": "A number of complete SigComp messages are given below, each containing some or all of the above code. In each case, it is indicated whether the message will successfully output the decompression memory size or whether it will cause a decompression failure to occur (together with the reason for the failure):",
      "ja": "以下の多くの完全なSigCompメッセージを以下に示します。それぞれには、上記のコードの一部またはすべてが含まれています。いずれの場合も、メッセージが減圧メモリサイズを正常に出力するのか、それとも減圧の失敗が発生するのか（障害の理由とともに）ことが示されます。"
    },
    {
      "indent": 3,
      "text": "SigComp message: Effect:",
      "ja": "Sigcompメッセージ：効果："
    },
    {
      "indent": 3,
      "text": "0xf8 Fails (message too short)",
      "ja": "0xf8失敗（メッセージが短すぎる）"
    },
    {
      "indent": 3,
      "text": "0xf800 Fails (message too short)",
      "ja": "0xf800失敗（メッセージが短すぎる）"
    },
    {
      "indent": 3,
      "text": "0xf800 e106 0011 2200 0223 Outputs the decompression_memory_size 0x0000 0000 0000 01",
      "ja": "0xf800 e106 0011 2200 0223出力decompression_memory_size 0x0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "0xf800 f106 0011 2200 0223 Fails (message too short) 0x0000 0000 0000 01",
      "ja": "0xf800 F106 0011 2200 0223失敗（メッセージが短すぎる）0x00000000000001"
    },
    {
      "indent": 3,
      "text": "0xf800 e006 0011 2200 0223 Fails (invalid destination address) 0x0000 0000 0000 01",
      "ja": "0xf800 e006 0011 2200 0223失敗（無効な宛先アドレス）0x0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "0xf800 ee06 0011 2200 0223 Outputs the decompression_memory_size 0x0000 0000 0000 01 The messages should be decompressed in the order given to check that an error in one message does not interfere with the successful decompression of subsequent messages.",
      "ja": "0xf800 EE06 0011 2200 0223 decompression_memory_size 0x0000 0000 0000 0000 0000 01出力メッセージは、1つのメッセージのエラーが後続のメッセージの解読の成功を妨げないことを確認するために与えられた順序で順序で解凍する必要があります。"
    },
    {
      "indent": 3,
      "text": "The two messages that successfully decompress each use a total of 5 UDVM cycles.",
      "ja": "それぞれが合計5つのUDVMサイクルを使用する2つのメッセージは、それぞれを使用します。"
    },
    {
      "indent": 0,
      "text": "3.4. Stream-based Transport",
      "section_title": true,
      "ja": "3.4. ストリームベースのトランスポート"
    },
    {
      "indent": 3,
      "text": "This section provides a byte stream to test the SigComp header and delimiters over a stream-based transport such as TCP. The byte stream tests all of the boundary cases covered in Section 3.2, as well as the following cases specific to stream-based transports:",
      "ja": "このセクションでは、TCPなどのストリームベースのトランスポートでSigCompヘッダーとデリミターをテストするバイトストリームを提供します。バイトストリームは、セクション3.2でカバーされているすべての境界ケースと、ストリームベースのトランスポートに固有の次の場合をテストします。"
    },
    {
      "indent": 3,
      "text": "1. Quoted bytes are used by the record marking scheme.",
      "ja": "1. 引用されたバイトは、レコードマーキングスキームで使用されます。"
    },
    {
      "indent": 3,
      "text": "2. Multiple delimiters are used between the same pair of messages.",
      "ja": "2. 同じメッセージのペア間で複数のデリミターが使用されます。"
    },
    {
      "indent": 3,
      "text": "3. Unnecessary delimiters are included at the start of the stream.",
      "ja": "3. ストリームの開始時には、不要なデリミターが含まれています。"
    },
    {
      "indent": 3,
      "text": "The basic version of the code used in the test is given below. Note that the code is designed to calculate the decompression memory size based on the Useful Values provided to the UDVM:",
      "ja": "テストで使用されるコードの基本バージョンを以下に示します。コードは、UDVMに提供される有用な値に基づいて、減圧メモリサイズを計算するように設計されていることに注意してください。"
    },
    {
      "indent": 3,
      "text": ":udvm_memory_size               pad (2)\n:cycles_per_bit                 pad (2)\n:sigcomp_version                pad (2)\n:partial_state_id_length        pad (2)\n:state_length                   pad (2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "; udvm_memory_size for stream based transport = DMS / 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($udvm_memory_size, 2) OUTPUT (udvm_memory_size, 2) OUTPUT (test_record_marking, 5) END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "乗算（$ udvm_memory_size、2）output（udvm_memory_size、2）output（test_record_marking、5）end-message（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":test_record_marking",
      "ja": "：test_record_marking"
    },
    {
      "indent": 3,
      "text": "byte (255, 255, 255, 255, 255) The above assembly code has been compiled and used to generate the following byte stream:",
      "ja": "バイト（255、255、255、255、255）上記のアセンブリコードがコンパイルされ、次のバイトストリームを生成するために使用されています。"
    },
    {
      "indent": 3,
      "text": "0xffff f801 7108 0002 2200 0222 a092 0523 0000 0000 0000 00ff 00ff 0x03ff ffff ffff ffff f801 7e08 0002 2200 0222 a3d2 0523 0000 0000 0x0000 00ff 04ff ffff ffff ffff ffff ff",
      "ja": "0xffff F801 7108 00022200 0222 A092 0523 000000000000000000 00FF 00FF 0X03FF FFFF FFFF F801 7E08 00022200 0222 A3D2 0523 000000000000000X00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF"
    },
    {
      "indent": 3,
      "text": "Note that this byte stream can be divided into five distinct portions (two SigComp messages and three sets of delimiters) as illustrated below:",
      "ja": "このバイトストリームは、以下に示すように、5つの異なる部分（2つのSigCompメッセージと3セットの区切り文字）に分割できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Portion of byte stream: Meaning:",
      "ja": "バイトストリームの一部：意味："
    },
    {
      "indent": 3,
      "text": "0xffff Delimiter",
      "ja": "0xffffデリミッター"
    },
    {
      "indent": 3,
      "text": "0xf801 7108 0002 2200 0222 a092 0523 First message 0x0000 0000 0000 00ff 00ff 03ff ffff",
      "ja": "0xf801 7108 0002 2200 0222 A092 0523ファーストメッセージ"
    },
    {
      "indent": 3,
      "text": "0xffff ffff Delimiter",
      "ja": "0xffff ffffデリミター"
    },
    {
      "indent": 3,
      "text": "0xf801 7e08 0002 2200 0222 a3d2 0523 Second message 0x0000 0000 0000 00ff 04ff ffff ff",
      "ja": "0xf801 7e08 0002 2200 0222 A3D2 0523 2番目のメッセージ"
    },
    {
      "indent": 3,
      "text": "0xffff ffff ffff Delimiter",
      "ja": "0xffff ffff ffff delimiter"
    },
    {
      "indent": 3,
      "text": "When the complete byte stream is supplied to the decompressor dispatcher, the record marking scheme must use the delimiters to partition the stream into two distinct SigComp messages. Both of these messages successfully output the decompression memory size (as a 2-byte value), followed by 5 consecutive 0xff bytes to test that the record marking scheme is working correctly. A total of 11 UDVM cycles are used in each case.",
      "ja": "完全なバイトストリームがDecompressor Dispatcherに供給される場合、レコードマーキングスキームは、デリミターを使用して、ストリームを2つの異なるSigCompメッセージに分割する必要があります。これらのメッセージはどちらも、減圧メモリサイズ（2バイト値として）を正常に出力し、その後5つの連続した0xffバイトが続き、レコードマーキングスキームが正しく機能していることをテストします。それぞれの場合に合計11のUDVMサイクルが使用されます。"
    },
    {
      "indent": 3,
      "text": "It must also be checked that the dispatcher can handle the same error cases as covered in Section 3.2. Each of the following byte streams should cause a decompression failure to occur for the reason stated:",
      "ja": "また、ディスパッチャーがセクション3.2でカバーされているのと同じエラーケースを処理できることを確認する必要があります。次のバイトストリームのそれぞれは、述べられている理由で減圧の失敗を引き起こすはずです。"
    },
    {
      "indent": 3,
      "text": "Byte stream: Reason for failure:",
      "ja": "バイトストリーム：失敗の理由："
    },
    {
      "indent": 3,
      "text": "0xf8ff ff Message too short",
      "ja": "0xf8ff ffメッセージが短すぎます"
    },
    {
      "indent": 3,
      "text": "0xf800 ffff Message too short",
      "ja": "0xf800 ffffメッセージが短すぎます"
    },
    {
      "indent": 3,
      "text": "0xf801 8108 0002 2200 0222 a092 0523 ffff Message too short 0x0000 0000 0000 00ff 00ff 03ff ffff",
      "ja": "0xf801 8108 0002 2200 0222 A092 0523 FFFFメッセージ"
    },
    {
      "indent": 3,
      "text": "0xf801 7008 0002 2200 0222 a092 0523 ffff Invalid destination 0x0000 0000 0000 00ff 04ff ffff ff",
      "ja": "0xf801 7008 0002 2200 0222 A092 0523 ffff無効な宛先0x0000 0000 00 00ff 04ff ffff ff"
    },
    {
      "indent": 0,
      "text": "3.5. Input Past the End of a Message",
      "section_title": true,
      "ja": "3.5. メッセージの終わりを過ぎて入力します"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test that the implementation correctly handles input past the end of a SigComp message. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、アセンブリコードを提供して、実装がSigCompメッセージの終了を過ぎて入力を正しく処理することをテストします。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. An INPUT instruction requests data that lies beyond the end of the message. In this case, the dispatcher should not return any data to the UDVM. Moreover, the message bytes held by the dispatcher should still be available for retrieval by subsequent INPUT instructions.",
      "ja": "1. 入力命令は、メッセージの終わりを超えてあるデータを要求します。この場合、ディスパッチャーはデータをUDVMに返すべきではありません。さらに、ディスパッチャーが保持しているメッセージバイトは、後続の入力命令により検索するために引き続き利用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The INPUT-BYTES instruction is used after part of a byte has been input (e.g., by the INPUT-BITS instruction). In this case, the remaining partial byte must be discarded, even if the INPUT-BYTES instruction requests data that lies beyond the end of the message.",
      "ja": "2. 入力バイト命令は、バイトの一部が入力された後に使用されます（たとえば、入力ビット命令による）。この場合、入力バイト命令がメッセージの終わりを超えてあるデータを要求する場合でも、残りの部分バイトを破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:input_bit_order                pad (2)\n:result                         pad (1)\n:result_lsb                     pad (6)\n:right",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128)",
      "ja": "で（128）"
    },
    {
      "indent": 3,
      "text": "LOAD (byte_copy_left, result) LOAD (byte_copy_right, right)",
      "ja": "load（byte_copy_left、result）load（byte_copy_right、右）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "; Input bits to ensure that the remaining message is not byte aligned",
      "ja": ";残りのメッセージがバイトに並べられていないことを確認するための入力ビット"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (9, result, decompression_failure1) ; Input 0x1FF (9 bits)",
      "ja": "入力ビット（9、result、decompression_failure1）;入力0x1ff（9ビット）"
    },
    {
      "indent": 3,
      "text": "; Attempt to read 7 bytes\n   INPUT-BYTES (7, result, next_bytes) ; This should fail, throw away\n                                    ; 7 bits with value Ox7a and\n                                    ; jump to next_bytes",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":decompression_failure1\nDECOMPRESSION-FAILURE               ; This instruction is never\n                                    ; executed but is used to\n                                    ; separate success and failure\n                                    ; to input bytes.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":next_bytes",
      "ja": "：next_bytes"
    },
    {
      "indent": 3,
      "text": "; Read 7 bits - this removes the byte alignment of the message",
      "ja": ";7ビットを読む - これにより、メッセージのバイトアラインメントが削除されます"
    },
    {
      "indent": 3,
      "text": "; If the bits have not been thrown away where they should be, then\n; the message will be 1 byte longer than necessary and the output\n; will be incorrect.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (7, result, decompression_failure1) ; Input 0x00 (7 bits)",
      "ja": "入力ビット（7、result、decompression_failure1）;入力0x00（7ビット）"
    },
    {
      "indent": 3,
      "text": "; Read 2 bytes",
      "ja": ";2バイトを読んでください"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (2, result, decompression_failure1) ; Throw away 1 bit value 0 ; Input 0x6869 OUTPUT (result, 2) ; Output 0x6869",
      "ja": "input-bytes（2、result、decompression_failure1）;1ビット値0を捨てます。入力0x6869出力（結果、2）;出力0x6869"
    },
    {
      "indent": 3,
      "text": " ; Attempt to read more bits than INPUT-BITS (16, result, bits) ; there are to ensure they ; remain available",
      "ja": ";入力ビット（16、結果、ビット）よりも多くのビットを読み込もうとしています。それらを確保することがあります。利用可能なままです"
    },
    {
      "indent": 3,
      "text": ":decompression_failure2\nDECOMPRESSION-FAILURE               ; This instruction is never\n                                    ; executed but is used to\n                                    ; separate success and failure\n                                    ; to input bits.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":bits",
      "ja": "：ビット"
    },
    {
      "indent": 3,
      "text": "; Read 8 bits",
      "ja": ";8ビットを読んでください"
    },
    {
      "indent": 3,
      "text": "INPUT-BITS (8, result, decompression_failure2) ; Input 0x21 or fail OUTPUT (result_lsb, 1) ; Output 0x21",
      "ja": "入力ビット（8、result、decompression_failure2）;入力0x21またはfail output（result_lsb、1）;出力0x21"
    },
    {
      "indent": 3,
      "text": ":end_message",
      "ja": "：end_message"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0) If the compressed message is 0xfffa 0068 6921, then the code terminates successfully with the output 0x6869 21, and a total of 23 UDVM cycles are used. However, if the compressed message is 0xfffa 0068 69, then decompression failure occurs (at the final INPUT-BITS).",
      "ja": "終了メッセージ（0、0、0、0、0、0、0）圧縮メッセージが0xfffa 0068 6921の場合、コードは出力0x6869 21で正常に終了し、合計23のUDVMサイクルが使用されます。ただし、圧縮メッセージが0xfffa 0068 69の場合、減圧障害が発生します（最終入力ビットで）。"
    },
    {
      "indent": 0,
      "text": "4. Torture Tests for State Handler",
      "section_title": true,
      "ja": "4. 州ハンドラーの拷問テスト"
    },
    {
      "indent": 3,
      "text": "The following sections give code to test the various functions of the SigComp state handler.",
      "ja": "次のセクションでは、Sigcomp Stateハンドラーのさまざまな機能をテストするためのコードを示します。"
    },
    {
      "indent": 0,
      "text": "4.1. SigComp Feedback Mechanism",
      "section_title": true,
      "ja": "4.1. SigCompフィードバックメカニズム"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the SigComp feedback mechanism. The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "このセクションでは、SigCompフィードバックメカニズムをテストするためのアセンブリコードを提供します。コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. Both the short and the long versions of the SigComp feedback item are used.",
      "ja": "1. SigCompフィードバック項目の短いバージョンと長いバージョンの両方が使用されます。"
    },
    {
      "indent": 3,
      "text": "2. The chain of returned SigComp parameters is terminated by a non-zero value.",
      "ja": "2. 返されたSigCompパラメーターのチェーンは、ゼロ以外の値によって終了します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":type                           pad (1)\n:type_lsb                       pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":requested_feedback_location    pad (1)\n:requested_feedback_length      pad (1)\n:requested_feedback_bytes       pad (127)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":returned_parameters_location   pad (2)\n:length_of_partial_state_id_a   pad (1)\n:partial_state_identifier_a     pad (6)\n:length_of_partial_state_id_b   pad (1)\n:partial_state_identifier_b     pad (12)\n:length_of_partial_state_id_c   pad (1)\n:partial_state_identifier_c     pad (20)\n:terminate_returned_parameters  pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "align (128)",
      "ja": "align（128）"
    },
    {
      "indent": 3,
      "text": "set (q_bit, 1) set (s_bit, 0) set (i_bit, 0) set (flags, (((4 * q_bit) + (2 * s_bit)) + i_bit))",
      "ja": "set（q_bit、1）set（s_bit、0）set（i_bit、0）set（flags、（（（4 * q_bit）（2 * s_bit））i_bit））"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 1, short_feedback_item, long_feedback_item, decompression_failure)",
      "ja": "input-bytes（1、type_lsb、decompression_failure）Compare（$ type、1、short_feedback_item、long_feedback_item、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":short_feedback_item",
      "ja": "：short_feedback_item"
    },
    {
      "indent": 3,
      "text": "set (requested_feedback_data, 127) set (short_feedback_value, ((flags * 256) + requested_feedback_data))",
      "ja": "set（request_feedback_data、127）set（short_feedback_value、（（flags * 256）requested_feedback_data））"
    },
    {
      "indent": 3,
      "text": "LOAD (requested_feedback_location, short_feedback_value) JUMP (return_sigcomp_parameters)",
      "ja": "load（requested_feedback_location、short_feedback_value）ジャンプ（return_sigcomp_parameters）"
    },
    {
      "indent": 3,
      "text": ":long_feedback_item",
      "ja": "：long_feedback_item"
    },
    {
      "indent": 3,
      "text": "set (requested_feedback_field, 255) set (long_feedback_value, ((flags * 256) + requested_feedback_field))",
      "ja": "set（request_feedback_field、255）set（long_feedback_value、（（flags * 256）requested_feedback_field））"
    },
    {
      "indent": 3,
      "text": "LOAD (requested_feedback_location, long_feedback_value) MEMSET (requested_feedback_bytes, 127, 1, 1)",
      "ja": "load（requested_feedback_location、long_feedback_value）memset（requested_feedback_bytes、127、1、1）"
    },
    {
      "indent": 3,
      "text": ":return_sigcomp_parameters",
      "ja": "：return_sigcomp_parameters"
    },
    {
      "indent": 3,
      "text": "set (cpb, 0) set (dms, 1) set (sms, 0) set (sigcomp_version, 1)",
      "ja": "set（cpb、0）set（dms、1）set（sms、0）set（sigcomp_version、1）"
    },
    {
      "indent": 3,
      "text": "set (parameters_msb, (((64 * cpb) + (8 * dms)) + sms))\nset (sigcomp_parameters, ((256 * parameters_msb) + sigcomp_version))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LOAD (returned_parameters_location, sigcomp_parameters)",
      "ja": "load（returned_parameters_location、sigcomp_parameters）"
    },
    {
      "indent": 3,
      "text": "LOAD (length_of_partial_state_id_a, 1536) ; length 6 first byte 0 LOAD (length_of_partial_state_id_b, 3072) ; length 12 first byte 0 LOAD (length_of_partial_state_id_c, 5120) ; length 20 first byte 0 LOAD (terminate_returned_parameters, 5376) ; length 21 ; used to terminate the ; returned parameters MEMSET (partial_state_identifier_a, 6, 0, 1) MEMSET (partial_state_identifier_b, 12, 0, 1) MEMSET (partial_state_identifier_c, 20, 0, 1)",
      "ja": "load（length_of_partial_state_id_a、1536）;長さ6 first byte 0 load（length_of_partial_state_id_b、3072）;長さ12 first byte 0 load（length_of_partial_state_id_c、5120）;長さ20 first byte 0 load（terminate_returned_parameters、5376）;長さ21;終了するために使用されます。返されたパラメーターmemset（partial_state_identifier_a、6、0、1）memset（partial_state_identifier_b、12、0、1）memset（partial_state_identifier_c、20、0、1）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (requested_feedback_location, returned_parameters_location, 0, 0, 0, 0, 0) :decompression_failure DECOMPRESSION-FAILURE When the above code is executed, it supplies a requested feedback item to the state handler. If the compressed message is 0x00, then the short (1-byte) version of the feedback is used. Executing the bytecode in this case costs a total of 52 UDVM cycles. Assuming that the feedback request is successful, the feedback item should be returned in the first SigComp message to be sent in the reverse direction. The SigComp message returning the feedback should begin as follows:",
      "ja": "end-message（requested_feedback_location、returned_parameters_location、0、0、0、0）：decompression_failure上記のコードが実行されると、要求されたフィードバックアイテムがステートハンドラーに提供されます。圧縮メッセージが0x00の場合、フィードバックの短い（1バイト）バージョンが使用されます。この場合のバイトコードを実行すると、合計52のUDVMサイクルがかかります。フィードバックリクエストが成功したと仮定すると、フィードバック項目を最初のSigCompメッセージに返す必要があります。フィードバックを返すSigCompメッセージは、次のように開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1 |   X   |   first header byte\n+---+---+---+---+---+---+---+---+\n| 0 |            127            |   returned feedback field\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "So the first 2 bytes of the returning SigComp message should be 0xfn7f where n = c, d, e, or f (the choice of n is determined by the compressor generating the returning SigComp message, which is not under the control of the above code).",
      "ja": "したがって、返されるSigcompメッセージの最初の2バイトは0xfn7fでなければなりません。ここでn = c、d、e、またはf（nの選択はコンプレッサーによって決定されます。）。"
    },
    {
      "indent": 3,
      "text": "If the compressed message is 0x01, then the long version of the feedback item is used. Executing the bytecode in this case costs a total of 179 UDVM cycles and the SigComp message returning the feedback should begin as follows:",
      "ja": "圧縮メッセージが0x01の場合、フィードバックアイテムの長いバージョンが使用されます。この場合のバイトコードの実行には合計179のUDVMサイクルがかかり、フィードバックを返すSigCompメッセージは次のように開始する必要があります。"
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+---+---+---+---+\n| 1   1   1   1   1   1 |   X   |   first header byte\n+---+---+---+---+---+---+---+---+\n| 1 |            127            |   returned feedback length\n+---+---+---+---+---+---+---+---+\n|               1               |              ^\n+---+---+---+---+---+---+---+---+              |\n|               2               |              |\n+---+---+---+---+---+---+---+---+\n|               3               |   returned feedback field\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "So the first 129 bytes of the SigComp message should be 0xfnff 0102 0304 ... 7e7f where n = c, d, e, or f as above.",
      "ja": "したがって、SigCompメッセージの最初の129バイトは0xfnff 0102 0304 ... 7e7fで、上記のようにn = c、d、e、またはfでなければなりません。"
    },
    {
      "indent": 3,
      "text": "As well as testing the requested and returned feedback items, the above code also announces values for each of the SigComp parameters. The supplied version of the code announces only the minimum possible values for the cycles_per_bit, decompression_memory_size, state_memory_size, and SigComp_version (although this can easily be adjusted to test different values for these parameters).",
      "ja": "要求されたフィードバック項目をテストするだけでなく、上記のコードは、各SIGCOMPパラメーターの値も発表します。コードの付属バージョンは、Cycles_Per_bit、Decompression_memory_size、State_memory_size、およびSigcomp_versionの最小値のみを発表します（ただし、これらのパラメーターの異なる値をテストするために簡単に調整できます）。"
    },
    {
      "indent": 3,
      "text": "The code should also announce the availability of state items with the following partial state identifiers:",
      "ja": "コードは、次の部分的な状態識別子を持つ状態項目の可用性も発表する必要があります。"
    },
    {
      "indent": 3,
      "text": "0x0001 0203 0405 0x0001 0203 0405 0607 0809 0a0b 0x0001 0203 0405 0607 0809 0a0b 0c0d 0e0f 1011 1213",
      "ja": "0x0001 0203 0405 0x0001 0203 0405 0607 0809 0A0B 0x0001 0203 0405 0607 0809 0A0B 0C0D 0E0F 1011 1213"
    },
    {
      "indent": 3,
      "text": "Note that different implementations may make use of the announcement information in different ways. It is a valid implementation choice to simply ignore all of the announcement data and use only the minimum resources that are guaranteed to be available to all endpoints. However, the above code is useful for checking that an endpoint interprets the announcement data correctly (in particular ensuring that it does not mistakenly use resources that have not in fact been announced).",
      "ja": "さまざまな実装では、さまざまな方法でアナウンス情報を使用する場合があることに注意してください。すべてのアナウンスデータを無視し、すべてのエンドポイントが利用できることが保証されている最小リソースのみを単純に無視することは有効な実装選択です。ただし、上記のコードは、エンドポイントが発表データを正しく解釈することを確認するのに役立ちます（特に、実際に発表されていないリソースを誤って使用しないようにします）。"
    },
    {
      "indent": 0,
      "text": "4.2. State Memory Management",
      "section_title": true,
      "ja": "4.2. 状態メモリ管理"
    },
    {
      "indent": 3,
      "text": "The following section gives assembly code to test the memory management features of the state handler. The code checks that the correct states are retained by the state handler when insufficient memory is available to store all of the requested states.",
      "ja": "次のセクションでは、ステートハンドラーのメモリ管理機能をテストするためのアセンブリコードを示します。コードは、要求されたすべての状態を保存するのに不十分なメモリが利用可能な場合、正しい状態が状態ハンドラーによって保持されることをチェックします。"
    },
    {
      "indent": 3,
      "text": "The code is designed to test that the following boundary cases have been correctly implemented:",
      "ja": "コードは、次の境界ケースが正しく実装されていることをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. A state item is created that exceeds the total state_memory_size for the compartment.",
      "ja": "1. コンパートメントの合計State_memory_sizeを超える状態アイテムが作成されます。"
    },
    {
      "indent": 3,
      "text": "2. States are created with a non-zero state_retention_priority.",
      "ja": "2. 状態は、ゼロ以外のstate_retention_priorityで作成されます。"
    },
    {
      "indent": 3,
      "text": "3. A new state item is created that has a lower state_retention_priority than existing state items in the compartment.",
      "ja": "3. コンパートメント内の既存の状態アイテムよりもState_retention_priorityが低い新しい状態アイテムが作成されます。"
    },
    {
      "indent": 3,
      "text": "For the duration of this test, it is assumed that all states will be saved in a single compartment with a state_memory_size of 2048 bytes.",
      "ja": "このテストの期間中、すべての状態が2048バイトのState_memory_sizeを持つ単一のコンパートメントに保存されると想定されています。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:order                          pad (2)\n:type                           pad (1)\n:type_lsb                       pad (1)\n:state_length                   pad (2)\n:state_retention_priority       pad (2)\n   at(127)\n:decompression_failure\nat (128)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "MULTILOAD (byte_copy_left, 2, state_start, order_data)",
      "ja": "Multiload（byte_copy_left、2、state_start、order_data）"
    },
    {
      "indent": 3,
      "text": "INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 5, general_test, large_state, verify_state)",
      "ja": "input-bytes（1、type_lsb、decompression_failure）比較（$ type、5、general_test、lage_state、verify_state）"
    },
    {
      "indent": 3,
      "text": ":general_test",
      "ja": "：general_test"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 3, start, state_present, state_not_present)",
      "ja": "比較（$ type、3、start、state_present、state_not_present）"
    },
    {
      "indent": 3,
      "text": ":start",
      "ja": "：始める"
    },
    {
      "indent": 3,
      "text": "MULTIPLY ($type, 6) ADD ($type, order_data) LOAD (order, $type) ADD ($type, 6)",
      "ja": "乗算（$タイプ、6）add（$ type、order_data）load（order、$ type）add（$ type、6）"
    },
    {
      "indent": 3,
      "text": "; Finish with the value (order_data + 6*n) in order where\n; n is the input value 0x00, 0x01, or 0x02\n; type = order + 6\n; These values are used to index into the 'order_data'\n; that is used to work out state retention priorities and lengths",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":loop",
      "ja": "：ループ"
    },
    {
      "indent": 3,
      "text": "COPY ($order, 2, state_retention_priority) COMPARE ($order, $type, continue, end, decompression_failure)",
      "ja": "copy（$ order、2、state_retention_priority）比較（$ order、$ type、conting、end、decompression_failure）"
    },
    {
      "indent": 3,
      "text": ":continue",
      "ja": "：続く"
    },
    {
      "indent": 3,
      "text": "; Set up a state creation each time through the loop",
      "ja": ";ループを通して毎回州の創造をセットアップする"
    },
    {
      "indent": 3,
      "text": "LOAD (state_length, $state_retention_priority) MULTIPLY ($state_length, 256) STATE-CREATE ($state_length, state_start, 0, 6, $state_retention_priority)",
      "ja": "load（state_length、$ state_retention_priority）倍数（$ state_length、256）state-create（$ state_length、state_start、0、6、$ state_retention_priority）"
    },
    {
      "indent": 3,
      "text": "ADD ($order, 2) JUMP (loop)",
      "ja": "追加（$ order、2）ジャンプ（ループ）"
    },
    {
      "indent": 3,
      "text": ":state_present",
      "ja": "：state_present"
    },
    {
      "indent": 3,
      "text": "; Access the states that should be present STATE-ACCESS (state_identifier_a, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_b, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_c, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_e, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": ";State-Access（State_Identifier_a、6、0、0、0、0）state-access（state_identifier_b、6、0、0、0）state-access（state_identifier_c、6、0、0、0、0、0、0、0、0、0、0）state-access（state_identifier_a、6、0、0、0、0）にアクセスする、0、0）state-access（state_identifier_e、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":state_not_present",
      "ja": "：state_not_present"
    },
    {
      "indent": 3,
      "text": "; Check that the state that shouldn't be present is not present. STATE-ACCESS (state_identifier_d, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": ";存在してはならない状態が存在しないことを確認してください。state-access（state_identifier_d、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":large_state",
      "ja": "：large_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (2048, state_start, 0, 6, 0) JUMP (end)",
      "ja": "State-Create（2048、State_start、0、6、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":verify_state",
      "ja": "：verify_state"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (large_state_identifier, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "state-access（lage_state_identifier、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_start",
      "ja": "：state_start"
    },
    {
      "indent": 3,
      "text": "byte (116, 101, 115, 116)",
      "ja": "バイト（116、101、115、116）"
    },
    {
      "indent": 3,
      "text": ":order_data ; This data is used to generate the retention priority ; and state length of each state creation.",
      "ja": "：order_data;このデータは、保持優先度を生成するために使用されます。各州の作成の状態長さ。"
    },
    {
      "indent": 3,
      "text": "word (0, 1, 2, 3, 4, 3, 2, 1, 0)",
      "ja": "単語（0、1、2、3、4、3、2、1、0）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_a",
      "ja": "：state_identifier_a"
    },
    {
      "indent": 3,
      "text": "byte (142, 234, 75, 67, 167, 135)",
      "ja": "バイト（142、234、75、67、167、135）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_b",
      "ja": "：state_identifier_b"
    },
    {
      "indent": 3,
      "text": "byte (249, 1, 14, 239, 86, 123)",
      "ja": "バイト（249、1、14、239、86、123）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_c",
      "ja": "：state_identifier_c"
    },
    {
      "indent": 3,
      "text": "byte (35, 154, 52, 107, 21, 166)",
      "ja": "バイト（35、154、52、107、21、166）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_d",
      "ja": "：state_identifier_d"
    },
    {
      "indent": 3,
      "text": "byte (180, 15, 192, 228, 77, 44)",
      "ja": "バイト（180、15、192、228、77、44）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_e",
      "ja": "：state_identifier_e"
    },
    {
      "indent": 3,
      "text": "byte (212, 162, 33, 71, 230, 10)",
      "ja": "バイト（212、162、33、71、230、10）"
    },
    {
      "indent": 3,
      "text": ":large_state_identifier",
      "ja": "：large_state_identifier"
    },
    {
      "indent": 3,
      "text": "byte (239, 242, 188, 15, 182, 175)",
      "ja": "バイト（239、242、188、15、182、175）"
    },
    {
      "indent": 3,
      "text": "The above code must be executed a total of 7 times in order to complete the test. Each time the code is executed, a 1-byte compressed message should be provided as below. The effects of the messages are given below. States are described in the form (name, x, y) where name corresponds to the name of the identifier in the mnemonic code, x is the length of the state, and y is the retention priority of the state.",
      "ja": "上記のコードは、テストを完了するために合計7回実行する必要があります。コードが実行されるたびに、以下のように1バイトの圧縮メッセージを提供する必要があります。メッセージの効果を以下に示します。状態は、名前がニーモニックコードの識別子の名前に対応し、xは状態の長さ、yは状態の保持優先度です。"
    },
    {
      "indent": 3,
      "text": "Message:   Effect:                                           #cycles:\n0x00       create states:                                       811\n                (a,0,0),\n                (b,256,1),\n                (c,512,2)\n0x01       create states:                                      2603\n                (d,768,3),\n                (e,1024,4) - deleting a, b, c\n0x02       create states:                                       811\n                (c,512,2), - deleting d\n                (b,256,1),\n                (a,0,0)\n0x03       access states a,b,c,e                               1805\n0x04       access state d - not present so decompression failure\n0x05       create states:                                      2057\n                (large, 2048,0) - deleting a, b, c, e\n0x06       access large state                                  1993",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that as new states are created, some of the existing states will be pushed out of the compartment due to lack of memory.",
      "ja": "新しい状態が作成されると、記憶が不足しているため、既存の状態の一部がコンパートメントから押し出されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.3. Multiple Compartments",
      "section_title": true,
      "ja": "4.3. 複数のコンパートメント"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test the interaction between multiple SigComp compartments. The code is designed to test that the following boundary cases have been correctly implemented: 1. The same state item is saved in more than one compartment.",
      "ja": "このセクションでは、複数のSigCompコンパートメント間の相互作用をテストするためのアセンブリコードを提供します。このコードは、次の境界ケースが正しく実装されていることをテストするように設計されています。1。同じ状態項目が複数のコンパートメントに保存されます。"
    },
    {
      "indent": 3,
      "text": "2. A state item stored in multiple compartments has the same state identifier but a different state_retention_priority in each case.",
      "ja": "2. 複数のコンパートメントに保存されている状態アイテムには、同じ状態識別子がありますが、それぞれの場合は異なるstate_retention_priorityがあります。"
    },
    {
      "indent": 3,
      "text": "3. A state item is deleted from one compartment but still belongs to a different compartment.",
      "ja": "3. 状態アイテムは1つのコンパートメントから削除されますが、それでも別のコンパートメントに属します。"
    },
    {
      "indent": 3,
      "text": "4. A state item belonging to multiple compartments is deleted from every compartment to which it belongs.",
      "ja": "4. 複数のコンパートメントに属する状態アイテムは、それが属するすべてのコンパートメントから削除されます。"
    },
    {
      "indent": 3,
      "text": "The test requires a total of three compartments to be available, which will be referred to as Compartment 0, Compartment 1, and Compartment 2. Each of the three compartments should have a state_memory_size of 2048 bytes.",
      "ja": "このテストでは、合計3つのコンパートメントを使用できる必要があります。これは、コンパートメント0、コンパートメント1、コンパートメント2と呼ばれます。3つのコンパートメントのそれぞれには、2048バイトのState_memory_sizeが必要です。"
    },
    {
      "indent": 3,
      "text": "The assembly code for the test is given below:",
      "ja": "テストのアセンブリコードを以下に示します。"
    },
    {
      "indent": 3,
      "text": "at (64)",
      "ja": "で（64）"
    },
    {
      "indent": 3,
      "text": ":byte_copy_left                 pad (2)\n:byte_copy_right                pad (2)\n:type                           pad (1)\n:type_lsb                       pad (1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (127) :decompression_failure at (128)",
      "ja": "at（127）：decompression_failure at（128）"
    },
    {
      "indent": 3,
      "text": "MULTILOAD (byte_copy_left, 2, state_start, state_end) INPUT-BYTES (1, type_lsb, decompression_failure) COMPARE ($type, 3, create_state, overwrite_state, temp)",
      "ja": "MultiLoad（byte_copy_left、2、state_start、state_end）input-bytes（1、type_lsb、decompression_failure）の比較（$、3、create_state、overwrite_state、temp）"
    },
    {
      "indent": 3,
      "text": ":temp",
      "ja": "：温度"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 5, overwrite_state, access_state, error_conditions)",
      "ja": "比較（$ type、5、overwrite_state、access_state、error_conditions）"
    },
    {
      "indent": 3,
      "text": ":create_state\n; starting byte identified by $type according to input:\n; Input     0x00        0x01        0x02\n; $type      512         513         514",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ADD ($type, state_start) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "add（$ type、state_start）state-create（448、$ type、0、6、0）"
    },
    {
      "indent": 3,
      "text": "; create state again, beginning in different place in buffer\n; starting byte identified by $type according to input:\n; Input     0x00        0x01        0x02",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "; $type 515 516 517",
      "ja": ";$ 515 516 517"
    },
    {
      "indent": 3,
      "text": "ADD ($type, 3) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "add（$ type、3）state-create（448、$ type、0、6、0）"
    },
    {
      "indent": 3,
      "text": "; create a third time beginning in different place again\n; starting byte identified by $type according to input:\n; Input     0x00        0x01        0x02\n; $type      516         517         515",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SUBTRACT ($type, temp_one) REMAINDER ($type, 3) ADD ($type, temp_two) STATE-CREATE (448, $type, 0, 6, 0)",
      "ja": "削除（$ type、temp_one）残り（$ type、3）add（$ type、temp_two）state-create（448、$ type、0、6、0）"
    },
    {
      "indent": 3,
      "text": ":common_state",
      "ja": "：common_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (448, temp_three, 0, 6, $type) JUMP (end)",
      "ja": "State-Create（448、temp_three、0、6、$型）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":overwrite_state",
      "ja": "：overwrite_state"
    },
    {
      "indent": 3,
      "text": "STATE-CREATE (1984, 32, 0, 6, 0) JUMP (end)",
      "ja": "State-Create（1984、32、0、6、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":access_state",
      "ja": "：Access_State"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_c, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_d, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_f, 6, 0, 0, 0, 0) STATE-ACCESS (state_identifier_g, 6, 0, 0, 0, 0)",
      "ja": "state-access（state_identifier_c、6、0、0、0、0）state-access（state_identifier_d、6、0、0、0、0）state-access（state_identifier_f、6、0、0、0）state-- 0、0、0）アクセス（State_Identifier_g、6、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":end",
      "ja": "：終わり"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":error_conditions",
      "ja": "：error_conditions"
    },
    {
      "indent": 3,
      "text": "COMPARE ($type, 7, access_a, access_b, access_e)",
      "ja": "比較（$ type、7、access_a、access_b、access_e）"
    },
    {
      "indent": 3,
      "text": ":access_a",
      "ja": "：Access_a"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_a, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "state-access（state_identifier_a、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":access_b STATE-ACCESS (state_identifier_b, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "：access_b state-access（state_identifier_b、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": ":access_e",
      "ja": "：access_e"
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (state_identifier_e, 6, 0, 0, 0, 0) JUMP (end)",
      "ja": "state-access（state_identifier_e、6、0、0、0、0）ジャンプ（終了）"
    },
    {
      "indent": 3,
      "text": "at (512)",
      "ja": "で（512）"
    },
    {
      "indent": 3,
      "text": ":state_start",
      "ja": "：state_start"
    },
    {
      "indent": 3,
      "text": "byte (0, 1, 2, 3, 4, 5, 6)",
      "ja": "バイト（0、1、2、3、4、5、6）"
    },
    {
      "indent": 3,
      "text": ":state_end",
      "ja": "：state_end"
    },
    {
      "indent": 3,
      "text": "set (temp_one, (state_start + 2))   ; = 514\nset (temp_two, (state_start + 3))   ; = 515\nset (temp_three, (state_end - 1))   ; = 518",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":state_identifier_a ; start state at 512",
      "ja": "：state_identifier_a;512で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (172, 166, 11, 142, 178, 131)",
      "ja": "バイト（172、166、11、142、178、131）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_b ; start state at 513",
      "ja": "：state_identifier_b;513で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (157, 191, 175, 198, 61, 210)",
      "ja": "バイト（157、191、175、198、61、210）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_c ; start state at 514",
      "ja": "：state_identifier_c;514で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (52, 197, 217, 29, 83, 97)",
      "ja": "バイト（52、197、217、29、83、97）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_d ; start state at 515",
      "ja": "：state_identifier_d;515で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (189, 214, 186, 42, 198, 90)",
      "ja": "バイト（189、214、186、42、198、90）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_e ; start state at 516",
      "ja": "：state_identifier_e;516で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (71, 194, 24, 20, 238, 7)",
      "ja": "バイト（71、194、24、20、238、7）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_f ; start state at 517",
      "ja": "：state_identifier_f;517で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (194, 117, 148, 29, 215, 161)",
      "ja": "バイト（194、117、148、29、215、161）"
    },
    {
      "indent": 3,
      "text": ":state_identifier_g ; start state at 518",
      "ja": "：state_identifier_g;518で状態を開始します"
    },
    {
      "indent": 3,
      "text": "byte (72, 135, 156, 141, 233, 14) The above code must be executed a total of 9 times in order to complete the test. Each time the code is executed, a 1-byte compressed message N should be provided, taking the values 0x00 to 0x08 in ascending order (so the compressed message should be 0x00 the first time the code is run, 0x01 the second, and so on).",
      "ja": "BYTE（72、135、156、141、233、14）上記のコードは、テストを完了するために合計9回実行する必要があります。コードが実行されるたびに、1バイトの圧縮メッセージnを提供する必要があり、昇順で値0x00から0x08を取得します（したがって、圧縮メッセージは最初にコードが実行されるのは0x00、2番目に0x01など）。"
    },
    {
      "indent": 3,
      "text": "If the code makes a state creation request, then the state must be saved in Compartment (N modulo 3).",
      "ja": "コードが状態作成要求を行う場合、状態はコンパートメントに保存する必要があります（n modulo 3）。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x00, 0x01, or 0x02, the code makes four state creation requests in compartments 0, 1, and 2, respectively. This creates a total of seven distinct state items referred to as State a through State g. The states should be distributed among the three compartments as illustrated in Figure 1 (note that some states belong to more than one compartment).",
      "ja": "圧縮メッセージが0x00、0x01、または0x02の場合、コードはそれぞれコンパートメント0、1、および2で4つの状態作成要求を行います。これにより、状態Aから状態gと呼ばれる合計7つの異なる状態項目が作成されます。図1に示すように、州は3つのコンパートメントに分配されるべきです（一部の州は複数のコンパートメントに属していることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x03 or 0x04, the code overwrites all of the states in Compartments 0 and 1, respectively. This means that States a, b, and e will be unavailable because they are no longer present in any of the three compartments.",
      "ja": "圧縮メッセージが0x03または0x04の場合、コードはそれぞれコンパートメント0と1のすべての状態を上書きします。これは、3つのコンパートメントのいずれにも存在しないため、A、B、およびEが利用できないことを意味します。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x05, the code checks that the States c, d, f, and g are still available. Decompression should terminate successfully in this case.",
      "ja": "圧縮メッセージが0x05の場合、コードは状態c、d、f、およびgがまだ利用可能であることをチェックします。この場合、減圧は正常に終了するはずです。"
    },
    {
      "indent": 3,
      "text": "When the compressed message is 0x06, 0x07, or 0x08, the code attempts to access States a, b, and e, respectively. Decompression failure should occur in this case because the relevant states are no longer available.",
      "ja": "圧縮メッセージが0x06、0x07、または0x08の場合、コードはそれぞれ状態a、b、およびeにアクセスしようとします。関連する状態が利用できなくなったため、この場合に減圧の故障が発生するはずです。"
    },
    {
      "indent": 3,
      "text": "The cost in UDVM cycles for each compressed message is given below (except for messages 0x06, 0x07, and 0x08 where decompression failure should to occur):",
      "ja": "各圧縮メッセージのUDVMサイクルのコストを以下に示します（減圧障害が発生するはずのメッセージ0x06、0x07、および0x08を除く）："
    },
    {
      "indent": 3,
      "text": "Compressed message: 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08",
      "ja": "圧縮メッセージ：0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08"
    },
    {
      "indent": 3,
      "text": "Cost in UDVM cycles: 1809 1809 1809 1993 1994 1804 N/A N/A N/A",
      "ja": "UDVMサイクルのコスト：1809 1809 1809 1993 1994 1804 n/a n/a n/a"
    },
    {
      "indent": 11,
      "text": "          +-----------------------------+\n          |        Compartment 0        |\n          |                             |\n          |                             |\n          |           State a           |\n          |                             |\n          |         +-------------------+---------+\n          |         |                   |         |\n          |         |                   |         |\n          |         |           State d |         |\n          |         |                   |         |\n          |         |                   |         |\n+---------+---------+---------+         |         |\n|         |         |         |         |         |\n|         |         |         |         |         |\n|         | State e | State g |         | State c |\n|         |         |         |         |         |\n|         |         |         |         |         |\n|         +---------+---------+---------+         |\n|                   |         |                   |\n|                   |         |                   |\n|           State b | State f |                   |\n|                   |         |                   |\n|                   |         |   Compartment 2   |\n|                   +---------+-------------------+\n|                             |\n|                             |\n|                             |\n|                             |\n|        Compartment 1        |\n+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 1: States created in the three compartments",
      "ja": "図1：3つのコンパートメントで作成された状態"
    },
    {
      "indent": 0,
      "text": "4.4. Accessing RFC 3485 State",
      "section_title": true,
      "ja": "4.4. RFC 3485状態へのアクセス"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test accessing SIP-SDP static dictionary state [3]. The code first accesses the state and then outputs the result.",
      "ja": "このセクションでは、SIP-SDP静的辞書状態にアクセスするためのアセンブリコードを提供します[3]。コードは最初に状態にアクセスし、結果を出力します。"
    },
    {
      "indent": 3,
      "text": "at (32)",
      "ja": "で（32）"
    },
    {
      "indent": 3,
      "text": ":input      pad (1)\n:input2     pad (1)\n:input3     pad (1)\n   at (128)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "STATE-ACCESS (sip_dictionary, 20, 0xcfe, 1, input, 0) STATE-ACCESS (sip_dictionary, 6, 0xcff, 1, input2, 0) STATE-ACCESS (sip_dictionary, 12, 0xd00, 1, input3, 0)",
      "ja": "state-access（sip_dictionary、20、0xcfe、1、input、0）state-access（sip_dictionary、6、0xcff、1、input2、0）state-access（sip_dictionary、12、0xd00、1、input3、0））"
    },
    {
      "indent": 3,
      "text": "OUTPUT (input, 3)",
      "ja": "出力（入力、3）"
    },
    {
      "indent": 3,
      "text": "END-MESSAGE (0, 0, 0, 0, 0, 0, 0)",
      "ja": "末端（0、0、0、0、0、0、0）"
    },
    {
      "indent": 3,
      "text": ":sip_dictionary byte (0xfb, 0xe5, 0x07, 0xdf, 0xe5, 0xe6) byte (0xaa, 0x5a, 0xf2, 0xab, 0xb9, 0x14) byte (0xce, 0xaa, 0x05, 0xf9, 0x9c, 0xe6) byte (0x1b, 0xa5)",
      "ja": "：sip_dictionary byte（0xfb、0xe5、0x07、0xdf、0xe5、0xe6）byte（0xaa、0x5a、0xf2、0xab、0xb9、0x14）byte（0xce、0xaa、0x05、0xf9、0x9c、0xe6）"
    },
    {
      "indent": 3,
      "text": "The output of the code is 0x5349 50, and the cost is 11 UDVM cycles.",
      "ja": "コードの出力は0x5349 50で、コストは11サイクルです。"
    },
    {
      "indent": 0,
      "text": "4.5. Bytecode State Creation",
      "section_title": true,
      "ja": "4.5. バイトコード状態の作成"
    },
    {
      "indent": 3,
      "text": "This section gives assembly code to test storing bytecode using END-MESSAGE and later loading the bytecode using a partial state identifier within the SigComp header. The assembly code is designed to test the following cases:",
      "ja": "このセクションでは、エンドメッセージを使用してバイトコードを保存し、後でSigCompヘッダー内の部分状態識別子を使用してバイトコードをロードするアセンブリコードを提供します。アセンブリコードは、次のケースをテストするように設計されています。"
    },
    {
      "indent": 3,
      "text": "1. The bytes to be saved are changed after the state create request has been made.",
      "ja": "1. 保存するバイトは、州の作成要求が行われた後に変更されます。"
    },
    {
      "indent": 3,
      "text": "2. The uploaded bytecode is modified before execution.",
      "ja": "2. アップロードされたbytecodeは、実行前に変更されます。"
    },
    {
      "indent": 3,
      "text": "3. The bytecode is loaded using the partial state identifier and is modified before execution.",
      "ja": "3. バイトコードは、部分状態識別子を使用してロードされ、実行前に変更されます。"
    },
    {
      "indent": 3,
      "text": "4. The bytecode is loaded to an address lower than 128, using the partial state identifier.",
      "ja": "4. バイトコードは、部分状態識別子を使用して、128未満のアドレスにロードされます。"
    },
    {
      "indent": 3,
      "text": "5. The bytecode is loaded using the partial state identifier. Part of the loaded memory is reserved area, which is overwritten after loading the bytecode.",
      "ja": "5. バイトコードは、部分状態識別子を使用してロードされます。ロードされたメモリの一部は予約領域で、バイトコードをロードした後に上書きされます。"
    },
    {
      "indent": 3,
      "text": "6. The loading of the bytecode fails because the partial state identifier is too short.",
      "ja": "6. 部分的な状態識別子が短すぎるため、バイトコードの負荷は失敗します。"
    },
    {
      "indent": 3,
      "text": "at (30)\n:save_area1\nset (saved_instr1, (save_area1 + (code_start2 - start_saved))) ; = 33",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (80)\n:save_area2\nset (saved_instr2, (save_area2 + (code_start2 - start_saved))) ; = 83",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "at (128) :code_start",
      "ja": "at（128）：code_start"
    },
    {
      "indent": 3,
      "text": "COPY (start_saved, saved_len, save_area1) ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE ; to position 30 and create as state STATE-CREATE (saved_len, save_area1, saved_instr1, 6, 10)",
      "ja": "copy（start_saved、saved_len、save_area1）;'ok2'、output（save_area2,3）endmessageをコピーします。30を配置し、州の状態を作成する（saved_len、save_area1、saved_instr1、6、10）"
    },
    {
      "indent": 3,
      "text": "set (modify1, (save_area1 + 5)) ; = 35 LOAD (modify1, 0x1e03) ; modify save_area2 to be save_area1 in the ; created state",
      "ja": "set（modify1、（save_area1 5））;= 35 load（modify1、0x1e03）;save_area2を変更して、save_area1になります。作成された状態"
    },
    {
      "indent": 3,
      "text": "COPY (start_saved, saved_len, save_area2)\nSTATE-CREATE (saved_len, save_area2, saved_instr2, 20, 10)\nSTATE-CREATE (saved_len, save_area2, saved_instr2, 12, 10)\n                    ; copy 'ok2', OUTPUT (save_area2,3) END-MESSAGE\n                    ; to position 80 and create as state twice with\n                    ; min access len 20 and 12",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "JUMP (modify)",
      "ja": "ジャンプ（変更）"
    },
    {
      "indent": 3,
      "text": ":ok1 byte (0x4f, 0x4b, 0x31)",
      "ja": "：ok1 byte（0x4f、0x4b、0x31）"
    },
    {
      "indent": 3,
      "text": "set (after_output_minus1, (after_output - 1))",
      "ja": "set（after_output_minus1、（afth_output -1））"
    },
    {
      "indent": 3,
      "text": ":modify INPUT-BYTES (1, after_output_minus1, decompression_failure) ; Input overwrites the next instruction OUTPUT (ok1, 3) ; Now is OUTPUT (ok1, 2) so output is 0x4f4b",
      "ja": "：input-bytes（1、afth_output_minus1、decompression_failure）を変更します。入力次の命令出力（OK1、3）を上書きします。これが出力（OK1、2）であるため、出力は0x4F4Bです"
    },
    {
      "indent": 3,
      "text": ":after_output",
      "ja": "：afth_output"
    },
    {
      "indent": 3,
      "text": "; Save from ok1 to the opcode of END-MESSAGE",
      "ja": ";ok1から末端のオペコードに保存します"
    },
    {
      "indent": 3,
      "text": "set (modify_len, ((after_output + 1) - ok1)) ; = 13\n   END-MESSAGE (0, 0, modify_len, ok1, modify, 6, 10)\n                    ; Save 'ok1', INPUT-BYTES, OUTPUT as state",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "set (saved_len, (end_saved - start_saved)) ; = 8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ":start_saved byte (0x4f, 0x4b, 0x32)",
      "ja": "：start_saved byte（0x4f、0x4b、0x32）"
    },
    {
      "indent": 3,
      "text": ":code_start2",
      "ja": "：code_start2"
    },
    {
      "indent": 3,
      "text": "; Translated bytecode for OUTPUT (save_area2, 3) byte (0x22, 0xa0, 0x50, 0x03)",
      "ja": ";出力用の翻訳bytecode（save_area2、3）byte（0x22、0xa0、0x50、0x03）"
    },
    {
      "indent": 3,
      "text": "; Translated bytecode for END-MESSAGE (0, 0, 0, 0, 0, 0, 0) ; The zeros do not need to be sent because UDVM is initialised to 0 byte (0x23)",
      "ja": ";末端の翻訳されたbytecode（0、0、0、0、0、0、0）;UDVMが0バイト（0x23）に初期化されるため、ゼロを送信する必要はありません"
    },
    {
      "indent": 3,
      "text": ":end_saved :decompression_failure",
      "ja": "：end_saved：decompression_failure"
    },
    {
      "indent": 3,
      "text": "The outputs and cycle usages are:",
      "ja": "出力とサイクルの使用は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Message              Output                  Cycles\n1                    0x4f4b                  66\n2                    0x4f4b 31               7\n3                    0x4f4b 32               5\n4                    0x0000 32               5\n5                    None                    Decompression failure",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "First message: mnemonic code annotated above",
      "ja": "最初のメッセージ：上記で注釈が付けられたニーモニックコード"
    },
    {
      "indent": 3,
      "text": "0xf804 6112 a0be 081e 2008 1e21 060a 0e23 be03 12a0 be08 a050 2008 0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f 4b31 1c01 a0b3 fc22 0xa0a8 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003 2302",
      "ja": "0xf804 6112 A0BE 081E 2008 1E21 060A 0E23 BE03 12A0 BE08 A050 2008 0XA050 A053 140A 2008 A050 A053 0C0A 1606 004F 4B31 1C01 A0B3 FC22 2 22A0 5003 2302"
    },
    {
      "indent": 3,
      "text": "Second message: access and run last state saved by previous message - 'ok1', INPUT-BYTES, OUTPUT, END-MESSAGE.",
      "ja": "2番目のメッセージ：以前のメッセージ - 「ok1」、入力バイト、出力、終了式で保存された最後の状態にアクセスして実行されます。"
    },
    {
      "indent": 3,
      "text": "0xf905 b88c e72c 9103",
      "ja": "0xf905 B88C E72C 9103"
    },
    {
      "indent": 3,
      "text": "Third message: access and run state from save_area2 with 12 bytes of state identifier - 'ok2', INPUT-BYTES, OUTPUT, END-MESSAGE.",
      "ja": "3番目のメッセージ：12バイトの状態識別子を備えたSave_Area2からのアクセスと実行状態 -  'ok2'、input-bytes、output、end message。"
    },
    {
      "indent": 3,
      "text": "0xfb24 63cd ff5c f8c7 6df6 a289 ff",
      "ja": "0xFB24 63CD FF5C F8C7 6DF6 A289 FF"
    },
    {
      "indent": 3,
      "text": "Fourth message: access and run state from save_area1. The state is 'ok2', INPUT-BYTES, OUTPUT, END-MESSAGE but the first two bytes should be overwritten when initialising UDVM memory.",
      "ja": "4番目のメッセージ：Save_area1からのアクセスおよび実行状態。状態は「ok2」、入力バイト、出力、終了末期ですが、UDVMメモリを初期化するときは最初の2バイトを上書きする必要があります。"
    },
    {
      "indent": 3,
      "text": "0xf95b 4b43 d567 83",
      "ja": "0xf95b 4b43 D567 83"
    },
    {
      "indent": 3,
      "text": "Fifth message: attempt to access state from save_area2 with fewer than 20 bytes of state identifier.",
      "ja": "5番目のメッセージ：Save_Area2から20バイトの状態識別子を持つSAVE_AREA2から状態にアクセスしようとします。"
    },
    {
      "indent": 3,
      "text": "0xf9de 8126 1199 1f",
      "ja": "0xf9de 8126 1199 1f"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document describes torture tests for the SigComp protocol RFC 3320 [2]. Consequently, the security considerations for this document match those of SigComp.",
      "ja": "このドキュメントは、SIGCOMPプロトコルRFC 3320の拷問テストについて説明しています[2]。その結果、このドキュメントのセキュリティ上の考慮事項は、Sigcompのセキュリティと一致します。"
    },
    {
      "indent": 3,
      "text": "In addition, the torture tests include tests for a significant number of \"boundary and error cases\" for execution of the UDVM bytecode. Boundary and error problems are common vectors for security attacks, so ensuring that a UDVM implementation executes this set of torture tests correctly should contribute to the security of the implementation.",
      "ja": "さらに、拷問テストには、UDVMバイトコードの実行のためのかなりの数の「境界およびエラーケース」のテストが含まれています。境界とエラーの問題は、セキュリティ攻撃の一般的なベクトルであるため、UDVMの実装がこの一連の拷問テストを正しく実行することを保証することで、実装のセキュリティに貢献するはずです。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Richard Price and Pekka Pessi for test contributions and to Pekka Pessi and Cristian Constantin, who served as committed working group document reviewers.",
      "ja": "テストの貢献をしてくれたリチャード・プライスとペッカ・ペッシと、コミットされたワーキンググループのドキュメントレビュー担当者を務めたペッカ・ペッシとクリスティアン・コンスタンティンに感謝します。"
    },
    {
      "indent": 0,
      "text": "7. Normative References",
      "section_title": true,
      "ja": "7. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Surtees, A. and M. West, \"Signaling Compression (SigComp) Users' Guide\", RFC 4464, May 2006.",
      "ja": "[1] Surtees、A。およびM. West、「シグナリング圧縮（Sigcomp）ユーザーガイド」、RFC 4464、2006年5月。"
    },
    {
      "indent": 3,
      "text": "[2] Price, R., Bormann, C., Christoffersson, J., Hannu, H., Liu, Z., and J. Rosenberg, \"Signaling Compression (SigComp)\", RFC 3320, January 2003.",
      "ja": "[2] Price、R.、Bormann、C.、Christoffersson、J.、Hannu、H.、Liu、Z。、およびJ. Rosenberg、「Signaling Compression（Sigcomp）」、RFC 3320、2003年1月。"
    },
    {
      "indent": 3,
      "text": "[3] Garcia-Martin, M., Bormann, C., Ott, J., Price, R., and A.B. Roach, \"The Session Initiation Protocol (SIP) and Session Description Protocol (SDP) Static Dictionary for Signaling Compression (SigComp)\", RFC 3485, February 2003.",
      "ja": "[3] Garcia-Martin、M.、Bormann、C.、Ott、J.、Price、R。、およびA.B.Roach、「セッション開始プロトコル（SIP）およびセッション説明プロトコル（SDP）シグナリング圧縮のための静的辞書（SIGCOMP）」、RFC 3485、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[4] Roach, A.B., \"A Negative Acknowledgement Mechanism for Signaling Compression\", RFC 4077, May 2005.",
      "ja": "[4] Roach、A.B。、「圧縮シグナリングのための否定的な認識メカニズム」、RFC 4077、2005年5月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. UDVM Bytecode for the Torture Tests",
      "section_title": true,
      "ja": "付録A. 拷問テストのUDVMバイトコード"
    },
    {
      "indent": 3,
      "text": "The following sections list the raw UDVM bytecode generated for each test. The bytecode is presented in the form of a complete SigComp message, including the appropriate header. It is followed by input messages, the output they produce, and where the decompression succeeds the number of cycles used.",
      "ja": "次のセクションには、各テストに対して生成された生のUDVMバイトコードがリストされています。バイトコードは、適切なヘッダーを含む完全なSigCompメッセージの形で表示されます。その後、入力メッセージ、生成する出力、および減圧が使用されるサイクルの数が成功します。"
    },
    {
      "indent": 3,
      "text": "In some cases, the test is designed to be run several times with different compressed messages appended to the code. In the cases where multiple whole messages are used for a test, e.g., Appendix A.2.3, these are supplied. In the case where decompression failure occurs, the high-level reason for it is given as a reason code defined in NACK [4].",
      "ja": "場合によっては、テストは、コードに追加された異なる圧縮メッセージで数回実行されるように設計されています。複数のメッセージがテストに使用される場合、たとえば付録A.2.3、これらが提供されます。減圧の故障が発生した場合、それの高レベルの理由は、NACK [4]で定義された理由コードとして与えられます。"
    },
    {
      "indent": 3,
      "text": "Note that the different assemblers can output different bytecode for the same piece of assembly code, so a valid assembler can produce results different from those presented below. However, the following bytecode should always generate the same results on any UDVM.",
      "ja": "異なるアセンブラーは、同じアセンブリコードの異なるバイトコードを出力できるため、有効なアセンブラーは以下に示すものとは異なる結果を生成できることに注意してください。ただし、次のByteCodeは常に任意のUDVMで同じ結果を生成する必要があります。"
    },
    {
      "indent": 0,
      "text": "A.1. Instructions",
      "section_title": true,
      "ja": "A.1. 手順"
    },
    {
      "indent": 0,
      "text": "A.1.1. Bit Manipulation",
      "section_title": true,
      "ja": "A.1.1. ビット操作"
    },
    {
      "indent": 3,
      "text": "0xf80a 7116 a07f 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x01c0 00ff 8055 5502 202a 0321 0420 0305 21ff 2286 0401 20c0 ff02 0x2060 0320 0421 6005 2061 2286 0423",
      "ja": "0xf80a 7116 A07f 0000 0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 00000000 0000 0x0000 000000000000000000000000000000000000000000000000000000000000000x01C0 00FF 8055 5502 202A 0321 0420 0305 21FF 2286 0401 20C0 FF02"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0150 0000 febf 0000 Cycles: 22",
      "ja": "入力：なし出力：0x0150 0000 febf 0000サイクル：22"
    },
    {
      "indent": 0,
      "text": "A.1.2. Arithmetic",
      "section_title": true,
      "ja": "A.1.2. 算術"
    },
    {
      "indent": 3,
      "text": "0xf80a a11c 01a0 450b 0722 0116 a077 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x06c0 00ff 9941 0720 0108 20a3 e909 20a0 650a 200b 2286 0406 21c0 0xff07 2162 0821 6109 2061 0a21 6222 8604 23",
      "ja": "0xf80a a11c 01a0 450b 0722 0116 A077 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 000000000000000000000000000000000000000000000000000000000000 0x06C0 00FF 9941 0720 0108 20A3 E909 20A0 650A 200B 2286 0406 21C0 0"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: 0x0000 0000 0000 0004 Cycles: 25",
      "ja": "入力：0x00出力：0x0000 0000 0000 0004サイクル：25"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 DECOMPRESSION-FAILURE DIV_BY_ZERO",
      "ja": "入力：0x01減圧 -  failure div_by_zero"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE DIV_BY_ZERO",
      "ja": "入力：0x02減圧 -  failure div_by_zero"
    },
    {
      "indent": 0,
      "text": "A.1.3. Sorting",
      "section_title": true,
      "ja": "A.1.3. ソート"
    },
    {
      "indent": 3,
      "text": "0xf80d c10c 8802 170b 8802 1722 a12e 2d23 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0a00 0a00 1100 0700 1600 0300 0300 0300 1300 0100 1000 0e00 0x0800 0200 0d00 1400 1200 1700 0f00 1500 0c00 0600 096e 6720 6975 0x6920 7469 742c 2079 6f75 2720 5346 6f6e 6761 2075 7272 646f 2074 0x6f6e 2e2e 0070 6570 206e 7472 656e 69",
      "ja": "0xf80d C10C 8802 170b 8802 1722 A12E 2D23 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 0000000000000000000000000000000000000000000000000000000000000x0000 0A00 0A00 1100 0700 1600 0300 0300 0300 1300 0100 1000 0E00 0x0800 0200 6920 7469 742C 2079 6F75 2720 5346 6F6E 67612075 7272 646F 2074 0x6F6E 2E2E 0070 6570 206E 7472 656E 69"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x466f 7264 2c20 796f 7527 7265 2074 7572 6e69 6e67 0x2069 6e74 6f20 6120 7065 6e67 7569 6e2e 2053 746f 0x7020 6974 2e Cycles: 371",
      "ja": "入力：なし出力：0x466F 7264 2C20 796F 7527 7265 2074 7572 6E69 6E67 0x2069 6E74 6F20 6120 7065 6E67"
    },
    {
      "indent": 0,
      "text": "A.1.4. SHA-1",
      "section_title": true,
      "ja": "A.1.4. SHA-1"
    },
    {
      "indent": 3,
      "text": "0xf808 710d a0c3 03a0 4422 a044 140d a0c6 38a0 4422 a044 140e 86a0 0xfe0e a042 a0ff 0da0 fe8e a044 22a0 4414 0e86 a0ff 0ea0 42a1 070d 0xa0ff a280 a0ff 22a0 ff14 2300 0000 0000 0000 6162 6361 6263 6462 0x6364 6563 6465 6664 6566 6765 6667 6866 6768 6967 6869 6a68 696a 0x6b69 6a6b 6c6a 6b6c 6d6b 6c6d 6e6c 6d6e 6f6d 6e6f 706e 6f70 7161 0x3031 3233 3435 3637",
      "ja": "0xf808 710D A0C3 03A0 4422 A044 140D A0C6 38A0 4422 A044 140E 86A0 0XFE0E A042 A0FF 0DA0 FE8E A044 22A0 4414 0E86 A0FF 0EA0 42A1 070D 070D 070D 070D 070D 070D 070D 070D 070D 0000 0000 6162 6361 6263 6462 0x6364 6563 6465 6664 6566 6765 6667 6866 6768 6967 68696A68 696A 0x6B69 6A6B 6C6A 6B6C 6D6B 6C6D 6E6C 6D6E 6F6D 6E6F 706E 6F70 7161 0x3031 3233 3435 36377"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0xa999 3e36 4706 816a ba3e 2571 7850 c26c 9cd0 d89d 0x8498 3e44 1c3b d26e baae 4aa1 f951 29e5 e546 70f1 0x12ff 347b 4f27 d69e 1f32 8e6f 4b55 73e3 666e 122f 0x4f46 0452 ebb5 6393 4f46 0452 ebb5 6393 4f46 0452 Cycles: 17176",
      "ja": "入力：なし出力：0xA999 3E36 4706 816A BA3E 2571 7850 C26C 9CD0 D89D 0x8498 3E44 1C3B D26E BAAE 4AA1 F951 29E5 E546 70F1 E 122F 0x4F46 0452 EBB5 6393 4F46 0452 EBB5 6393 4F46 0452サイクル：17176"
    },
    {
      "indent": 0,
      "text": "A.1.5. LOAD and MULTILOAD",
      "section_title": true,
      "ja": "A.1.5. 負荷とマルチロード"
    },
    {
      "indent": 3,
      "text": "0xf803 610e 87a0 840e a082 c080 0ec0 80a0 860e c084 c084 2287 081c 0x01a0 4127 0820 0206 203c 0f60 03a0 a2a0 b187 0f60 042a 87c0 80c0 0x8422 8708 23",
      "ja": "0xf803 610e 87a0 840e A082 C080 0EC0 80A0 860E C084 C084 2287 081C 0x01A0 4127 0820 0206 203C 0F60 03A0 A2A0 B187 0F60"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: 0x0084 0084 0086 0086 002a 0080 002a 002a Cycles: 36",
      "ja": "入力：0x00出力：0x0084 0084 0086 0086 002A 0080 002A 002Aサイクル：36"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 DECOMPRESSION-FAILURE MULTILOAD_OVERWRITTEN",
      "ja": "入力：0x01減圧 - マルチロード_OverWritten"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE MULTILOAD_OVERWRITTEN",
      "ja": "入力：0x02減圧 - マルチロード_OverWritten"
    },
    {
      "indent": 0,
      "text": "A.1.6. COPY",
      "section_title": true,
      "ja": "A.1.6. コピー"
    },
    {
      "indent": 3,
      "text": "0xf803 910e 208e 0e86 860e a042 8712 2087 210e 8680 4100 1286 a055 0xa041 2220 a077 0e86 200e a042 3015 2004 a041 0112 2004 3022 3004 0x1230 042e 2220 0223",
      "ja": "0xf803 910E 208E 0E86 860E A042 8712 2087 210E 8680 4100 1286 A055 0XA041 2220 A077 0E86 200E A042 3015 2004 A041 0112 2004 3022 3004"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4040 4040 4040 4040 4040 4040 4040 4040 4040 4040 0x4040 4040 4040 4040 4040 4040 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 5541 0x4243 4443 44 Cycles: 365",
      "ja": "入力：なし出力：0x4040404040404040404040404040404040404040 0x4040 4040 4040 4040 4040 4040 4141 4141 4141 4141 0x4141 4141 4141 1 4141 4141 4141 4141 4141 4141 4141 4141 4141 0x4141 4141 4141 4141 41414141 4141 4141 4141 4141 0x4141 4141 4141 4141 4141 4141 4141 4141 4141 5541 0x4243 4443 44サイクル：365"
    },
    {
      "indent": 0,
      "text": "A.1.7. COPY-LITERAL and COPY-OFFSET",
      "section_title": true,
      "ja": "A.1.7. コピーリテラルとコピーオフセット"
    },
    {
      "indent": 3,
      "text": "0xf806 110e 2080 4100 0e86 860e a042 870e a044 2113 2087 2222 8608 0x0ea0 44a0 9c13 2002 2222 a09c 020e 86a0 480e a042 a052 0ea0 44a0 0x5215 a048 0aa0 4101 1402 0622 0ea0 4606 1463 0422 2261 0a0e a044 0xa050 1404 0422 22a0 4402 1405 0422 22a0 4402 2260 0a23",
      "ja": "0xf806 110e 2080 4100 0E86 860E A042 870E A044 2113 2087 2222 8608 0x0EA0 44A0 9C13 2002 2222 A09C 020E 86A0 480E A042 A052 4606 1463 0422 2261 0A0E A044 0XA050 1404 0422 22A0 4402 1405 0422 22A0 4402 2260 0A23"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4141 4141 0061 4141 4141 494A 4142 4344 494A 4142 0x004A 004E 4748 4845 4647 4748 4546 Cycles: 216",
      "ja": "入力：なし出力：0x4141 4141 0061 4141 4141 494a 4142 4344 494a 4142 0x004a 004e 4748 4845 4647 4748 4546サイクル：216"
    },
    {
      "indent": 0,
      "text": "A.1.8. MEMSET",
      "section_title": true,
      "ja": "A.1.8. メンバーセット"
    },
    {
      "indent": 3,
      "text": "0xf801 810e 8687 0ea0 42a0 8115 86a0 8100 0115 a081 0f86 0f22 8710 0x23",
      "ja": "0xf801 810E 8687 0EA0 42A0 8115 86A0 8100 0115 A081 0F86 0F22 8710 0x23"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x8040 4f5e 6d7c 8b9a a9b8 c7d6 e5f4 0312 Cycles: 166",
      "ja": "入力：なし出力：0x8040 4F5E 6D7C 8B9A A9B8 C7D6 E5F4 0312サイクル：166"
    },
    {
      "indent": 0,
      "text": "A.1.9. CRC",
      "section_title": true,
      "ja": "A.1.9. CRC"
    },
    {
      "indent": 3,
      "text": "0xf801 8115 a046 1801 0115 a05e 1487 011c 02a0 4413 1b62 a046 2c0e 0x23",
      "ja": "0xf801 8115 A046 1801 0115 A05E 1487 011C 02A0 4413 1B62 A046 2C0E 0x23"
    },
    {
      "indent": 3,
      "text": "Input: 0x62cb Output: None Cycles: 95",
      "ja": "入力：0x62CB出力：なしサイクル：95"
    },
    {
      "indent": 3,
      "text": "Input: 0xabcd DECOMPRESSION FAILURE USER_REQUESTED (CRC mismatch)",
      "ja": "入力：0xABCD減圧障害user_requested（crcの不一致）"
    },
    {
      "indent": 0,
      "text": "A.1.10. INPUT-BITS",
      "section_title": true,
      "ja": "A.1.10. 入力ビット"
    },
    {
      "indent": 3,
      "text": "0xf801 511d 62a0 4614 22a0 4602 0622 010a 2207 0622 0116 ee23",
      "ja": "0xf801 511d 62A0 4614 22A0 4602 0622 010A 2207 0622 0116 EE23"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 Output: 0x0000 0002 0002 0013 0000 0003 001a 0038 Cycles: 66",
      "ja": "入力：0x932E AC71出力：0x0000 0002 0002 0013 0000 0003 001A 0038サイクル：66"
    },
    {
      "indent": 0,
      "text": "A.1.11. INPUT-HUFFMAN",
      "section_title": true,
      "ja": "A.1.11. 入力ハフマン"
    },
    {
      "indent": 3,
      "text": "0xf801 d11e a046 1c02 6200 6262 6200 ff00 22a0 4602 0622 010a 2207 0x0622 0116 e623",
      "ja": "0xf801 D11E A046 1C02 6200 6262 6200 FF00 22A0 4602 0622 010A 2207 0x0622 0116 E623"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 66d8 6f Output: 0x0000 0003 0008 04d7 0002 0003 0399 30fe Cycles: 84",
      "ja": "入力：0x932E AC71 66D8 6F出力：0x0000 0003 0008 04D7 0002 0003 0399 30FEサイクル：84"
    },
    {
      "indent": 0,
      "text": "A.1.12. INPUT-BYTES",
      "section_title": true,
      "ja": "A.1.12. 入力バイト"
    },
    {
      "indent": 3,
      "text": "0xf802 710e 86a0 480e a042 a04c 1d62 a046 1d22 a046 0206 2202 0a22 0x071c 62a0 480e 22a0 4862 0622 0116 e523",
      "ja": "0xf802 710E 86A0 480E A042 A04C 1D62 A046 1D22 A046 0206 2202 0A22 0x071C 62A0 480E 22A0 4862 0622 0116 E523"
    },
    {
      "indent": 3,
      "text": "Input: 0x932e ac71 66d8 6fb1 592b dc9a 9734 d847 a733 874e 0x1bcb cd51 b5dc 9659 9d6a Output: 0x0000 932e 0001 b166 d86f b100 1a2b 0003 9a97 34d8 0x0007 0001 3387 4e00 08dc 9651 b5dc 9600 599d 6a Cycles: 130",
      "ja": "入力：0x932E AC71 66D8 6FB1 592B DC9A 9734 D847 A733 874E 0x1BCB CD51 B5DC 9659 9D6A出力：0x0000 932E 0001 B166 D86F B100 651 B5DC 9600 599D 6Aサイクル：130"
    },
    {
      "indent": 0,
      "text": "A.1.13. Stack Manipulation",
      "section_title": true,
      "ja": "A.1.13. スタック操作"
    },
    {
      "indent": 3,
      "text": "0xf814 110e a046 8610 0210 6010 a042 2286 0811 8611 6311 a046 2286 0x0816 2800 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 000e a046 200e a048 a140 0724 0x8818 3400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0018 6400 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 000e a046 a17f 0ea1 7f1a 0fa1 b003 0x0180 c001 8f19 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0023",
      "ja": "0xf814 110E A046 8610 0210 6010 A042 2286 0811 8611 6311 A046 2286 0x0816 2800 0000 0000 0000 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0 0724 0x8818 3400 0000 0000 000000000000000000000000000000 0000 0x0000 0000000000000000000000000000000000000000000000000000000000000x0018 6400 0000 0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 0000 0000 0000 0000 0000 000E A046 A17F0EA1 7F1A 0FA1 B003 0x0180 C001 8F19 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0000 0000 0x0000 000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0023"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0003 0002 0001 0042 0042 0000 0001 0001 Cycles: 40",
      "ja": "入力：なし出力：0x0003 0002 0001 0042 0042 0000 0001 0001サイクル：40"
    },
    {
      "indent": 0,
      "text": "A.1.14. Program Flow",
      "section_title": true,
      "ja": "A.1.14. プログラムフロー"
    },
    {
      "indent": 3,
      "text": "0xf803 f10e a044 040e 86a0 9207 20a0 9022 a043 0116 6006 2101 0e86 0xa084 0720 a0a1 22a0 4301 1761 0660 f106 0722 010e 86a0 8407 20a0 0xb622 a043 011a 0462 0860 9fdc f123",
      "ja": "0xf803 F10E A044 040E 86A0 9207 20A0 9022 A043 0116 6006 2101 0E86 0XA084 0720 A0A1 22A0 4301 1761 0660 F106 0722 010E 86A0 3"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909 Cycles: 131",
      "ja": "入力：なし出力：0x0001 0102 0203 0304 0405 0506 0707 0708 0808 0909サイクル：131"
    },
    {
      "indent": 0,
      "text": "A.1.15. State Creation",
      "section_title": true,
      "ja": "A.1.15. 国家の創造"
    },
    {
      "indent": 3,
      "text": "0xf809 411c 01a0 45ff 0422 0b17 628f 0d06 0620 0aa1 0a00 1400 0422 0x0117 628f 0c06 0620 0a88 0014 0004 2201 1762 8f16 0606 1c01 a047 0x9fd2 21a0 4863 12a0 e363 a048 0422 0117 628f 0a06 0621 a0e3 0604 0x2201 1762 8f0e 0606 2300 000a 8800 1400 2300 0000 0000 0000 437a 0xe80a 0fdc 1e6a 87c1 b62a 7676 b973 318c 0ef5 0000 0000 0000 0000 0x00c0 cc3f ee79 bcfc 8fd1 0865 e803 52ee 2977 17df 57",
      "ja": "0xf809 411c 01a0 45ff 0422 0b17 628f 0d06 0620 0AA1 0A00 1400 0422 0x0117 628F 0C06 0620 0A88 0014 0004 2201 1762 8F16 0606 22 0117 628F 0A06 0621 A0E3 0604 0x2201 1762 8F0E 0606 2300 000A 8800 1400 2300 0000 00000000 437A 0XE80A 0FDC 1E6A 87C1 B62A 7676 B973 318C 0EF5 0000 000000000000000000000000000000000000000000000FD1 0865 E803 52EE 2977 17DF 57DF 57"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 23",
      "ja": "入力：0x01出力：なしサイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 Output: None Cycles: 14",
      "ja": "入力：0x02出力：なしサイクル：14"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 24",
      "ja": "入力：0x03出力：なしサイクル：24"
    },
    {
      "indent": 3,
      "text": "Input: 0x0405 DECOMPRESSION-FAILURE INVALID_STATE_ID_LENGTH",
      "ja": "入力：0x0405 Decompression-failure Invalid_state_id_length"
    },
    {
      "indent": 3,
      "text": "Input: 0x0415 DECOMPRESSION-FAILURE INVALID_STATE_ID_LENGTH",
      "ja": "入力：0x0415 Decompression-Failure infalid_state_id_length"
    },
    {
      "indent": 3,
      "text": "Input: 0x0406 Output: None Cycles: 23",
      "ja": "入力：0x0406出力：なしサイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0x09 Output: None Cycles: 34",
      "ja": "入力：0x09出力：なしサイクル：34"
    },
    {
      "indent": 3,
      "text": "Input: 0x1e06 Output: None Cycles: 46 Input: 0x1e07 Output: None Cycles: 47",
      "ja": "入力：0x1E06出力：なしサイクル：46入力：0x1E07出力：なしサイクル：47"
    },
    {
      "indent": 3,
      "text": "Input: 0x1e14 Output: None Cycles: 60",
      "ja": "入力：0x1E14出力：なしサイクル：60"
    },
    {
      "indent": 0,
      "text": "A.1.16. STATE-ACCESS",
      "section_title": true,
      "ja": "A.1.16. 状態アクセス"
    },
    {
      "indent": 3,
      "text": "Set up bytecode: 0xf819 0123 0000 1089 0014 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0022 a20c 0x0423 0000 0000 0000 0074 6573 74",
      "ja": "BYTECODEのセットアップ：0xf819 0123 0000 1089 0014 0000 0000 0000 0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0x0000 0000 0000 0000 000000000000 0000 000000000000000000000000000000 0x0000 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0000 0000 0000 0000 0x0000 000000000000 0000 0000 0000 000000000000000000000000000000000x0000 0000 0000 0000 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0000 0000 0000 0000 0022 A20C 0x04230000 0000 0000 0074 6573 74"
    },
    {
      "indent": 3,
      "text": "Input: None",
      "ja": "入力：なし"
    },
    {
      "indent": 3,
      "text": "0xf819 411c 01a0 45ff 1762 0106 0d1c 1f89 1400 0000 891f 8914 0c04 0xa046 0022 a046 0416 a146 1762 0306 101b 1f87 1400 0000 0016 a136 0x1f89 1306 04a0 4600 16a1 2b1f 8914 0c05 a046 0016 a120 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0023 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 005d f8bc 0x3e20 93b5 abe1 f170 1342 4ce7 fe05 e069 39 Input: 0x00 Output: 0x7465 7374 Cycles: 26",
      "ja": "0xf819 411c 01a0 45ff 1762 0106 0d1c 1f89 1400 0000 891f 8914 0c04 0xa046 0022 A046 0416 A146 1762 0306 101b 1F87 1400 0000000000000016 A136 0X1F89 130404040404040404040404040404040404040404041041040404 C05 A046 0016 A120 0000 0000 0x0000 00000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 0000000000000000000000000000000000000000000000000000000000000x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0x0000 0000 0000 0000 0000 0000 0000 00000000 0000 0000 0000 0x0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0x0000 0000 0000 0000 000000004CE7 FE05 E069 39入力：0x00出力：0x7465 7374サイクル：26"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: 0x7465 7374 Cycles: 15",
      "ja": "入力：0x01出力：0x7465 7374サイクル：15"
    },
    {
      "indent": 3,
      "text": "Input: 0x02 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x02減圧-Pailure state_not_found"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 DECOMPRESSION-FAILURE STATE_NOT_FOUND (len < min_acc_len)",
      "ja": "入力：0x03減圧 -  failure state_not_found（len <min_acc_len）"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 DECOMPRESSION-FAILURE STATE_TOO_SHORT",
      "ja": "入力：0x04減圧-Pailure State_too_short"
    },
    {
      "indent": 0,
      "text": "A.2. Dispatcher Tests",
      "section_title": true,
      "ja": "A.2. ディスパッチャーテスト"
    },
    {
      "indent": 0,
      "text": "A.2.1. Useful Values",
      "section_title": true,
      "ja": "A.2.1. 有用な値"
    },
    {
      "indent": 3,
      "text": "0xf805 f10e 8620 0ea0 4221 1c01 a047 f817 4263 f306 f317 4300 ed06 0x0c17 4400 e73f e717 44a3 c0e1 07e1 1c01 a047 9fda 0623 4007 2301 0x1220 0163 1c01 a049 9fca 0ea0 4443 0622 0308 2208 0622 a3e8 0822 0x4106 2264 0722 a358 1220 6220 2300 00a3 c086 8706",
      "ja": "0xf805 F10E 8620 0EA0 4221 1C01 A047 F817 4263 F306 F317 4300 ED06 0x0C17 4400 E73F E717 44A3 C0E1 07E1 1C01 A047 9FDA 4443 0622 0308 2208 0622 A3E8 0822 0x4106 2264 0722 A358 1220 6220 2300 00A3 C086 8706"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version Output: None Cycles: 968",
      "ja": "入力：1バイトのSigCompバージョン出力：なしサイクル：968"
    },
    {
      "indent": 3,
      "text": "0xf93a db1d 3d20 aa",
      "ja": "0xf93a db1d 3d20 aa"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0000 Output: None Cycles: cycles_per_bit * 1080",
      "ja": "入力：SigCompバージョンの1バイト、0x0000出力：なしサイクル：Cycles_per_bit * 1080"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0001 DECOMPRESSION-FAILURE CYCLES_EXHAUSTED",
      "ja": "入力：1バイトのSigCompバージョン、その後0x0001減圧 -  cycles_exaxted"
    },
    {
      "indent": 3,
      "text": "Input: 1 byte of SigComp version then 0x0100 DECOMPRESSION-FAILURE SEGFAULT",
      "ja": "入力：SigCompバージョンの1バイト、その後0x0100減圧 - セグフォールト"
    },
    {
      "indent": 0,
      "text": "A.2.2. Cycles Checking",
      "section_title": true,
      "ja": "A.2.2. サイクルチェック"
    },
    {
      "indent": 3,
      "text": "0xf801 a10f 8604 2029 0022 12a0 4402 6014 02a0 6423 22a0 4402 0622 0x0116 ef",
      "ja": "0xf801 A10F 8604 2029 0022 12A0 4402 6014 02A0 6423 22A0 4402 0622 0x0116 EF"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE CYCLES_EXHAUSTED",
      "ja": "入力：none Decompression-failure cycles_exasted"
    },
    {
      "indent": 0,
      "text": "A.2.3. Message-based Transport",
      "section_title": true,
      "ja": "A.2.3. メッセージベースのトランスポート"
    },
    {
      "indent": 3,
      "text": "0xf8",
      "ja": "0xf8"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf800",
      "ja": "0xf800"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf800 e106 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 E106 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None Output: decompression_memory_size Cycles: 5",
      "ja": "入力：なし出力：decompression_memory_sizeサイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf800 f106 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 F106 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf800 e006 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 E006 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE INVALID_CODE_LOCATION",
      "ja": "入力：none decompression-failure invalid_code_location"
    },
    {
      "indent": 3,
      "text": "0xf800 ee06 0011 2200 0223 0000 0000 0000 01",
      "ja": "0xf800 EE06 0011 2200 0223 0000 0000 0000 01"
    },
    {
      "indent": 3,
      "text": "Input: None Output: decompression_memory_size Cycles: 5",
      "ja": "入力：なし出力：decompression_memory_sizeサイクル：5"
    },
    {
      "indent": 0,
      "text": "A.2.4. Stream-based Transport",
      "section_title": true,
      "ja": "A.2.4. ストリームベースのトランスポート"
    },
    {
      "indent": 3,
      "text": "0xffff f801 7108 0002 2200 0222 a092 0523 0000 0000 0000 00ff 00ff 0x03ff ffff ffff ffff f801 7e08 0002 2200 0222 a3d2 0523 0000 0000 0x0000 00ff 04ff ffff ffff ffff ffff ff The above stream contains two messages:",
      "ja": "0xffff f801 7108 0002 2200 0222 a092 0523 0000 0000 0000 00ff 00ff 0x03ff ffff ffff ffff f801 7e08 0002 2200 0222 a3d2 0523 0000 0000 0x0000 00ff 04ff ffff ffff ffff ffff ff The above stream contains two messages:"
    },
    {
      "indent": 3,
      "text": "Output: decompression_memory_size Cycles: 11",
      "ja": "出力：decompression_memory_sizeサイクル：11"
    },
    {
      "indent": 3,
      "text": "Output: decompression_memory_size Cycles: 11",
      "ja": "出力：decompression_memory_sizeサイクル：11"
    },
    {
      "indent": 3,
      "text": "0xf8ff ff",
      "ja": "0xf8ff ff"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf800 ffff",
      "ja": "0xf800 ffff"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf801 8108 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 00ff 0x03ff ffff",
      "ja": "0xf801 8108 0002 2200 0222 A092 0523 ffff 0000 0000 0000 00ff 00ff 0x03ff ffff"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE MESSAGE_TOO_SHORT",
      "ja": "入力：none decompression-failure message_too_short"
    },
    {
      "indent": 3,
      "text": "0xf801 7008 0002 2200 0222 a092 0523 ffff 0000 0000 0000 00ff 04ff 0xffff ff",
      "ja": "0xf801 7008 0002 2200 0222 A092 0523 ffff 0000 0000 0000 00ff 04ff 0xffff ff"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE INVALID_CODE_LOCATION",
      "ja": "入力：none decompression-failure invalid_code_location"
    },
    {
      "indent": 0,
      "text": "A.2.5. Input Past the End of a Message",
      "section_title": true,
      "ja": "A.2.5. メッセージの終わりを過ぎて入力します"
    },
    {
      "indent": 3,
      "text": "0xf803 210e 86a0 460e a042 a04d 1d09 a046 0a1c 07a0 4606 001d 07a0 0x46ff 1c02 a046 fa22 a046 021d 10a0 4606 001d 08a0 46ff 22a0 4701 0x23",
      "ja": "0xf803 210E 86A0 460E A042 A04D 1D09 A046 0A1C 07A0 4606 001D 07A0 0x46FF 1C02 A046 FA22 A046 021D 10A0 4606 001D 08A0 46FF 22A0 4701 0X23"
    },
    {
      "indent": 3,
      "text": "Input: 0xfffa 0068 6921 Output: 0x6869 21 Cycles: 23",
      "ja": "入力：0xfffa 0068 6921出力：0x6869 21サイクル：23"
    },
    {
      "indent": 3,
      "text": "Input: 0xfffa 0068 69 DECOMPRESSION-FAILURE USER_REQUESTED (not enough bits)",
      "ja": "入力：0xfffa 0068 69減圧 -  failure user_requested（十分なビットなし）"
    },
    {
      "indent": 0,
      "text": "A.3. State Handler Tests",
      "section_title": true,
      "ja": "A.3. ステートハンドラーテスト"
    },
    {
      "indent": 0,
      "text": "A.3.1. SigComp Feedback Mechanism",
      "section_title": true,
      "ja": "A.3.1. SigCompフィードバックメカニズム"
    },
    {
      "indent": 3,
      "text": "0xf805 031c 01a0 41a0 5517 6001 070e a04f 0ea0 42a4 7f16 0e0e a042 0xa4ff 15a0 44a0 7f01 010e a0c3 a801 0ea0 c5a6 000e a0cc ac00 0ea0 0xd9b4 000e a0ee b500 15a0 c606 0001 15a0 cd0c 0001 15a0 da14 0001 0x23a0 42a0 c3",
      "ja": "0xf805 031c 01A0 41A0 5517 6001 070E A04F 0EA0 42A4 7F16 0E0E A042 0XA4FF 15A0 44A0 7F01 A0 CD0C 0001 15A0 DA14 0001 0x23A0 42A0 C3"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 52",
      "ja": "入力：0x00出力：なしサイクル：52"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 179",
      "ja": "入力：0x01出力：なしサイクル：179"
    },
    {
      "indent": 0,
      "text": "A.3.2. State Memory Management",
      "section_title": true,
      "ja": "A.3.2. 状態メモリ管理"
    },
    {
      "indent": 3,
      "text": "0xf81b a10f 8602 89a2 041c 01a0 47f9 1763 0508 a068 a070 1763 0307 0x34a0 5608 2306 0623 a204 0ea0 4463 0623 0612 6202 a04a 1762 6308 0xa058 9fd2 0ea0 4865 0824 8820 6489 0006 6506 2202 16e3 1fa2 1606 0x0000 0000 1fa2 1c06 0000 0000 1fa2 2206 0000 0000 1fa2 2e06 0000 0x0000 161e 1fa2 2806 0000 0000 1614 208b 8900 0600 160c 1fa2 3406 0x0000 0000 1602 2300 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0074 6573 0x7400 0000 0100 0200 0300 0400 0300 0200 0100 008e ea4b 43a7 87f9 0x010e ef56 7b23 9a34 6b15 a6b4 0fc0 e44d 2cd4 a221 47e6 0aef f2bc 0x0fb6 af",
      "ja": "0xf81b A10F 8602 89A2 041C 01A0 47F9 1763 0508 A068 A070 1763 0307 0x34A0 5608 2306 0623 A204 89 0006 6506 2202 16E3 1FA2 1606 0x0000 0000 1FA2 1C06 0000 0000 1FA2 2206 0000 0000 1FA22E06 0000 0x0000 161E 1FA2 2806 0000 00000000 1614 208B 8900 0600 160C 1FA2 3406 0x0000 0000 1602 2300 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0x0000 0000 0000 0000 0000000000000000000000000000000000000000000000000000 0000 0000 0000 0x0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0x0000 0000 0000 0000 000000000400 0300 0200 0100 008E EA4B 43A7 87F9 0X010E EF56 7B23 9A34 6B15 A6B4 0FC0 E44D 2CD4 A221 47E6 0AEF F2BC 0x0FB6 AF AF AF AF"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 811",
      "ja": "入力：0x00出力：なしサイクル：811"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 2603 Input: 0x02 Output: None Cycles: 811",
      "ja": "入力：0x01出力：なしサイクル：2603入力：0x02出力：なしサイクル：811"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 1805",
      "ja": "入力：0x03出力：なしサイクル：1805"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x04減圧-Pailure state_not_found"
    },
    {
      "indent": 3,
      "text": "Input: 0x05 Output: None Cycles: 2057",
      "ja": "入力：0x05出力：なしサイクル：2057"
    },
    {
      "indent": 3,
      "text": "Input: 0x06 Output: None Cycles: 1993",
      "ja": "入力：0x06出力：なしサイクル：1993"
    },
    {
      "indent": 0,
      "text": "A.3.3. Multiple Compartments",
      "section_title": true,
      "ja": "A.3.3. 複数のコンパートメント"
    },
    {
      "indent": 3,
      "text": "0xf81b 110f 8602 89a2 071c 01a0 45f9 1762 030d 3d06 1762 0537 86a0 0x6806 2289 20a1 c062 0006 0006 2203 20a1 c062 0006 0007 22a2 020a 0x2203 0622 a203 20a1 c062 0006 0020 a1c0 a206 0006 6216 2b20 a7c0 0x2000 0600 1622 1fa2 1306 0000 0000 1fa2 1906 0000 0000 1fa2 2506 0x0000 0000 1fa2 2b06 0000 0000 2300 0000 0000 0000 1762 0706 101a 0x1fa2 0706 0000 0000 16ea 1fa2 0d06 0000 0000 16e0 1fa2 1f06 0000 0x0000 169f d600 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0102 0x0304 0506 aca6 0b8e b283 9dbf afc6 3dd2 34c5 d91d 5361 bdd6 ba2a 0xc65a 47c2 1814 ee07 c275 941d d7a1 4887 9c8d e90e",
      "ja": "0xf81b 110f 8602 89a2 071c 01a0 45f9 1762 030d 3d06 1762 0537 86a0 0x6806 2289 20A1 C062 0006 0006 2203 20A1 C062 0006 0007 0007 22A2 020A 0203 062220A10220 A20220 A20220 A20220 A20220 A20220 A20220 A203 A206 0006 6216 2B20 A7C0 0x2000 0600 1622 1FA2 1306 0000 0000 1FA2 1906 0000 00001FA2 2506 0x000000000000 1FA2 2B06 00000000 2300 0000 0000 0000 1762 0706 101A 0x1FA2 0706 0000 000000001EA 1FA2 0D06 0000 0000 16E0 1FA2 0000 0000 0000 0000 0x0000 0000 0000 0000 0000 0000 0000 00000000 0000 0000 0000 0x0000 0000 0000 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 0000 0000 0000 0x0000 0000 0000 0000 000000009DBF AFC6 3DD2 34C5 D91D 5361 BDD6 BA2A 0XC65A 47C2 1814 EE07 C275 941D D7A1 4887 9C8D E90E"
    },
    {
      "indent": 3,
      "text": "Input: 0x00 Output: None Cycles: 1809",
      "ja": "入力：0x00出力：なしサイクル：1809"
    },
    {
      "indent": 3,
      "text": "Input: 0x01 Output: None Cycles: 1809 Input: 0x02 Output: None Cycles: 1809",
      "ja": "入力：0x01出力：なしサイクル：1809入力：0x02出力：なしサイクル：1809"
    },
    {
      "indent": 3,
      "text": "Input: 0x03 Output: None Cycles: 1993",
      "ja": "入力：0x03出力：なしサイクル：1993"
    },
    {
      "indent": 3,
      "text": "Input: 0x04 Output: None Cycles: 1994",
      "ja": "入力：0x04出力：なしサイクル：1994"
    },
    {
      "indent": 3,
      "text": "Input: 0x05 Output: None Cycles: 1804",
      "ja": "入力：0x05出力：なしサイクル：1804"
    },
    {
      "indent": 3,
      "text": "Input: 0x06 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x06減圧-Pailure state_not_found"
    },
    {
      "indent": 3,
      "text": "Input: 0x07 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x07減圧 -  failure state_not_found"
    },
    {
      "indent": 3,
      "text": "Input: 0x08 DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": "入力：0x08減圧-Pailure state_not_found"
    },
    {
      "indent": 0,
      "text": "A.3.4. Accessing RFC 3485 State",
      "section_title": true,
      "ja": "A.3.4. RFC 3485状態へのアクセス"
    },
    {
      "indent": 3,
      "text": "0xf803 a11f a0a6 14ac fe01 2000 1fa0 a606 acff 0121 001f a0a6 0cad 0x0001 2200 2220 0323 0000 0000 0000 00fb e507 dfe5 e6aa 5af2 abb9 0x14ce aa05 f99c e61b a5",
      "ja": "0xf803 A11F A0A6 14AC FE01 2000 1FA0 A606 ACFF 0121 001F A0A6 0CAD 0x0001 2200 2220 0323 0000 000000000000FB E507 DFE5 E6AA 5AF2 ABB9 0X14CE AA05 F9C E61B A5 A5 A5 A5"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x5349 50 Cycles: 11",
      "ja": "入力：なし出力：0x5349 50サイクル：11"
    },
    {
      "indent": 0,
      "text": "A.3.5. Bytecode State Creation",
      "section_title": true,
      "ja": "A.3.5. バイトコード状態の作成"
    },
    {
      "indent": 3,
      "text": "0xf804 6112 a0be 081e 2008 1e21 060a 0e23 be03 12a0 be08 a050 2008 0xa050 a053 140a 2008 a050 a053 0c0a 1606 004f 4b31 1c01 a0b3 fc22 0xa0a8 0323 0000 0da0 a8a0 ab06 0a4f 4b32 22a0 5003 2302",
      "ja": "0xf804 6112 A0BE 081E 2008 1E21 060A 0E23 BE03 12A0 BE08 A050 2008 0XA050 A053 140A 2008 A050 A053 0C0A 1606 004F 4B31 1C01 A0B3 FC22 2 22A0 5003 2302"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4f4b Cycles: 66",
      "ja": "入力：なし出力：0x4F4Bサイクル：66"
    },
    {
      "indent": 3,
      "text": "0xf905 b88c e72c 9103 Input: None Output: 0x4f4b 31 Cycles: 7",
      "ja": "0xf905 b88c e72c 9103入力：なし出力：0x4f4b 31サイクル：7"
    },
    {
      "indent": 3,
      "text": "0xfb24 63cd ff5c f8c7 6df6 a289 ff",
      "ja": "0xFB24 63CD FF5C F8C7 6DF6 A289 FF"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x4f4b 32 Cycles: 5",
      "ja": "入力：なし出力：0x4F4B 32サイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf95b 4b43 d567 83",
      "ja": "0xf95b 4b43 D567 83"
    },
    {
      "indent": 3,
      "text": "Input: None Output: 0x0000 32 Cycles: 5",
      "ja": "入力：なし出力：0x0000 32サイクル：5"
    },
    {
      "indent": 3,
      "text": "0xf9de 8126 1199 1f",
      "ja": "0xf9de 8126 1199 1f"
    },
    {
      "indent": 3,
      "text": "Input: None DECOMPRESSION-FAILURE STATE_NOT_FOUND",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Abigail Surtees Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey, Hants SO51 0ZN UK",
      "ja": "Abigail Surtees Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey、Hants So51 0Zn UK"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)1794 833131\nEMail: abigail.surtees@roke.co.uk\nURI:   http://www.roke.co.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mark A. West Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey, Hants SO51 0ZN UK",
      "ja": "Mark A. West Siemens/Roke Manor Research Roke Manor Research Ltd. Romsey、Hants SO51 0ZN UK"
    },
    {
      "indent": 3,
      "text": "Phone: +44 (0)1794 833311\nEMail: mark.a.west@roke.co.uk\nURI:   http://www.roke.co.uk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}