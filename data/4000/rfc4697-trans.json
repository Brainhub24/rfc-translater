{
  "title": {
    "text": "RFC 4697 - Observed DNS Resolution Misbehavior",
    "ja": "RFC 4697 - 観察されたDNS解像度の不正行為"
  },
  "number": 4697,
  "created_at": "2023-06-07 13:17:47.801770+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Larson\nRequest for Comments: 4697                                     P. Barber\nBCP: 123                                                  VeriSign, Inc.\nCategory: Best Current Practice                             October 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Observed DNS Resolution Misbehavior",
      "ja": "観察されたDNS解像度の不正行為"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネットの最良のプラクティスを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This memo describes DNS iterative resolver behavior that results in a significant query volume sent to the root and top-level domain (TLD) name servers. We offer implementation advice to iterative resolver developers to alleviate these unnecessary queries. The recommendations made in this document are a direct byproduct of observation and analysis of abnormal query traffic patterns seen at two of the thirteen root name servers and all thirteen com/net TLD name servers.",
      "ja": "このメモは、ルートおよびトップレベルドメイン（TLD）ネームサーバーに送信される重要なクエリボリュームをもたらすDNS反復リゾルバーの動作について説明します。これらの不要なクエリを軽減するために、反復リゾルバー開発者に実装アドバイスを提供します。このドキュメントで行われた推奨事項は、13のルート名サーバーのうち2つとすべての13のCOM/Net TLD名サーバーで見られる異常なクエリトラフィックパターンの観測と分析の直接的な副産物です。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n   1.1. A Note about Terminology in this Memo ......................3\n   1.2. Key Words ..................................................3\n2. Observed Iterative Resolver Misbehavior .........................3\n   2.1. Aggressive Requerying for Delegation Information ...........3\n        2.1.1. Recommendation ......................................5\n   2.2. Repeated Queries to Lame Servers ...........................6\n        2.2.1. Recommendation ......................................6\n   2.3. Inability to Follow Multiple Levels of Indirection .........7\n        2.3.1. Recommendation ......................................7\n   2.4. Aggressive Retransmission when Fetching Glue ...............8\n        2.4.1. Recommendation ......................................9\n   2.5. Aggressive Retransmission behind Firewalls .................9\n        2.5.1. Recommendation .....................................10\n   2.6. Misconfigured NS Records ..................................10\n        2.6.1. Recommendation .....................................11",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   2.7. Name Server Records with Zero TTL .........................11\n        2.7.1. Recommendation .....................................12\n   2.8. Unnecessary Dynamic Update Messages .......................12\n        2.8.1. Recommendation .....................................13\n   2.9. Queries for Domain Names Resembling IPv4 Addresses ........13\n        2.9.1. Recommendation .....................................14\n   2.10. Misdirected Recursive Queries ............................14\n        2.10.1. Recommendation ....................................14\n   2.11. Suboptimal Name Server Selection Algorithm ...............15\n        2.11.1. Recommendation ....................................15\n3. Security Considerations ........................................16\n4. Acknowledgements ...............................................16\n5. Internationalization Considerations ............................16\n6. References .....................................................16\n   6.1. Normative References ......................................16\n   6.2. Informative References ....................................16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Observation of query traffic received by two root name servers and the thirteen com/net Top-Level Domain (TLD) name servers has revealed that a large proportion of the total traffic often consists of \"requeries\". A requery is the same question (<QNAME, QTYPE, QCLASS>) asked repeatedly at an unexpectedly high rate. We have observed requeries from both a single IP address and multiple IP addresses (i.e., the same query received simultaneously from multiple IP addresses).",
      "ja": "2つのルート名サーバーと13のCOM/ネットトップレベルドメイン（TLD）名サーバーが受け取ったクエリトラフィックの観察により、総トラフィックの大部分は「リクエア」で構成されていることが多いことが明らかになりました。requeryは、予期せぬ高速で繰り返し尋ねた同じ質問（<qname、qtype、qclass>）です。単一のIPアドレスと複数のIPアドレスの両方からリクエアを観察しました（つまり、複数のIPアドレスから同時に受信した同じクエリ）。"
    },
    {
      "indent": 3,
      "text": "By analyzing requery events, we have found that the cause of the duplicate traffic is almost always a deficient iterative resolver, stub resolver, or application implementation combined with an operational anomaly. The implementation deficiencies we have identified to date include well-intentioned recovery attempts gone awry, insufficient caching of failures, early abort when multiple levels of indirection must be followed, and aggressive retry by stub resolvers or applications. Anomalies that we have seen trigger requery events include lame delegations, unusual glue records, and anything that makes all authoritative name servers for a zone unreachable (Denial of Service (DoS) attacks, crashes, maintenance, routing failures, congestion, etc.).",
      "ja": "Requeryイベントを分析することにより、重複トラフィックの原因は、ほとんどの場合、不十分な反復リゾルバー、スタブリゾルバー、またはアプリケーションの実装と運用上の異常を組み合わせていることがわかりました。これまで特定された実装の欠陥には、意図的な回復の試みが失われ、障害のキャッシングが不十分であること、複数のレベルの間接がたどらなければならない場合の早期中絶、スタブリゾルバーまたはアプリケーションによる積極的な再試行が含まれます。トリガーリクリーイベントには、ゾーンの不自由な代表団、異常な接着剤レコード、ゾーンのないすべての権威ある名前サーバーが到達不能（サービス拒否（DOS）攻撃、クラッシュ、メンテナンス、ルーティング障害、混雑など）が含まれます。"
    },
    {
      "indent": 3,
      "text": "In the following sections, we provide a detailed explanation of the observed behavior and recommend changes that will reduce the requery rate. None of the changes recommended affects the core DNS protocol specification; instead, this document consists of guidelines to implementors of iterative resolvers.",
      "ja": "次のセクションでは、観察された動作の詳細な説明を提供し、補充レートを下げる変更を推奨します。推奨される変更のいずれも、コアDNSプロトコル仕様に影響しません。代わりに、このドキュメントは、反復型リゾルバーの実装者へのガイドラインで構成されています。"
    },
    {
      "indent": 0,
      "text": "1.1. A Note about Terminology in This Memo",
      "section_title": true,
      "ja": "1.1. このメモの用語に関するメモ"
    },
    {
      "indent": 3,
      "text": "To recast an old saying about standards, the nice thing about DNS terms is that there are so many of them to choose from. Writing or talking about DNS can be difficult and can cause confusion resulting from a lack of agreed-upon terms for its various components. Further complicating matters are implementations that combine multiple roles into one piece of software, which makes naming the result problematic. An example is the entity that accepts recursive queries, issues iterative queries as necessary to resolve the initial recursive query, caches responses it receives, and which is also able to answer questions about certain zones authoritatively. This entity is an iterative resolver combined with an authoritative name server and is often called a \"recursive name server\" or a \"caching name server\".",
      "ja": "基準についての古いことわざを作り直すために、DNS用語についての良いところは、それらの多くが選択できることです。DNSについて書いたり話したりするのは難しく、さまざまなコンポーネントの合意された条件の欠如に起因する混乱を引き起こす可能性があります。さらに複雑な問題は、複数の役割を1つのソフトウェアに組み合わせた実装であり、結果を問題にします。例は、再帰クエリを受け入れ、必要に応じて最初の再帰クエリを解決するために反復クエリを発行するエンティティ、受信するキャッシュ応答、および特定のゾーンに関する質問に信頼できることにも答えることができます。このエンティティは、権威ある名前サーバーと組み合わされた反復リゾルバーであり、「再帰名サーバー」または「キャッシュネームサーバー」と呼ばれることがよくあります。"
    },
    {
      "indent": 3,
      "text": "This memo is concerned principally with the behavior of iterative resolvers, which are typically found as part of a recursive name server. This memo uses the more precise term \"iterative resolver\", because the focus is usually on that component. In instances where the name server role of this entity requires mentioning, this memo uses the term \"recursive name server\". As an example of the difference, the name server component of a recursive name server receives DNS queries and the iterative resolver component sends queries.",
      "ja": "このメモは、主に反復型リゾルバーの動作に関するものであり、通常は再帰名サーバーの一部として見られます。このメモは、より正確な用語「反復リゾルバー」を使用します。これは、焦点が通常そのコンポーネントにあるためです。このエンティティの名前サーバーの役割が言及する必要がある場合、このメモは「再帰名サーバー」という用語を使用します。違いの例として、再帰名サーバーの名前サーバーコンポーネントはDNSクエリを受信し、反復リゾルバーコンポーネントはクエリを送信します。"
    },
    {
      "indent": 3,
      "text": "The advent of IPv6 requires mentioning AAAA records as well as A records when discussing glue. To avoid continuous repetition and qualification, this memo uses the general term \"address record\" to encompass both A and AAAA records when a particular situation is relevant to both types.",
      "ja": "IPv6の出現には、接着剤について議論する際には、AAAAレコードとレコードに言及する必要があります。継続的な繰り返しと資格を回避するために、このメモは一般的な用語「アドレスレコード」を使用して、特定の状況が両方のタイプに関連する場合にAとAAAの両方のレコードを包含します。"
    },
    {
      "indent": 0,
      "text": "1.2. Key Words",
      "section_title": true,
      "ja": "1.2. キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [1].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119 [1]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "2. Observed Iterative Resolver Misbehavior",
      "section_title": true,
      "ja": "2. 観察された反復リゾルバーの不正行為"
    },
    {
      "indent": 0,
      "text": "2.1. Aggressive Requerying for Delegation Information",
      "section_title": true,
      "ja": "2.1. 委任情報の積極的な補償"
    },
    {
      "indent": 3,
      "text": "There can be times when every name server in a zone's NS RRSet is unreachable (e.g., during a network outage), unavailable (e.g., the name server process is not running on the server host), or misconfigured (e.g., the name server is not authoritative for the given zone, also known as \"lame\"). Consider an iterative resolver that attempts to resolve a query for a domain name in such a zone and discovers that none of the zone's name servers can provide an answer. We have observed a recursive name server implementation whose iterative resolver then verifies the zone's NS RRSet in its cache by querying for the zone's delegation information: it sends a query for the zone's NS RRSet to one of the parent zone's name servers. (Note that queries with QTYPE=NS are not required by the standard resolution algorithm described in Section 4.3.2 of RFC 1034 [2]. These NS queries represent this implementation's addition to that algorithm.)",
      "ja": "ゾーンのNS RRSet内のすべての名前サーバーが到達不可（ネットワークの停止中に）、利用できない場合（たとえば、Serverプロセスがサーバーホストで実行されていない）、または誤解されている場合（例えば、名前サーバーは「ラメ」とも呼ばれる与えられたゾーンでは権威がありません）。このようなゾーンのドメイン名のクエリを解決しようとする反復リゾルバーを考えて、ゾーンの名前サーバーがいずれも答えを提供できないことを発見します。反復的なリゾルバーがゾーンの委任情報をクエリすることにより、ゾーンのNS RRSetをキャッシュのゾーンのNS RRSETを検証する再帰名サーバーの実装を観察しました。ゾーンのNS RRSEのクエリを親ゾーンの名前サーバーの1つに送信します。（QTYPE = NSのクエリは、RFC 1034 [2]のセクション4.3.2で説明されている標準解像度アルゴリズムでは必須ではないことに注意してください。これらのNSクエリは、このアルゴリズムへのこの実装の追加を表しています。）"
    },
    {
      "indent": 3,
      "text": "For example, suppose that \"example.com\" has the following NS RRSet:",
      "ja": "たとえば、「Example.com」に次のns rrsetがあると仮定します。"
    },
    {
      "indent": 5,
      "text": "example.com. IN NS ns1.example.com. example.com. IN NS ns2.example.com.",
      "ja": "Example.com。ns1.example.comで。Example.com。ns2.example.comで。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of a query for \"www.example.com\" and assuming that neither \"ns1.example.com\" nor \"ns2.example.com\" can provide an answer, this iterative resolver implementation immediately queries a \"com\" zone name server for the \"example.com\" NS RRSet to verify that it has the proper delegation information. This implementation performs this query to a zone's parent zone for each recursive query it receives that fails because of a completely unresponsive set of name servers for the target zone. Consider the effect when a popular zone experiences a catastrophic failure of all its name servers: now every recursive query for domain names in that zone sent to this recursive name server implementation results in a query to the failed zone's parent name servers. On one occasion when several dozen popular zones became unreachable, the query load on the com/net name servers increased by 50%.",
      "ja": "「www.example.com」のクエリを受け取り、「ns1.example.com」も「ns2.example.com」も回答を提供できないと仮定すると、この反復リゾルバーの実装はすぐに「com」ゾーン名サーバーを照会します「Example.com」NS rrsetについては、適切な委任情報があることを確認します。この実装は、受信する各再帰クエリに対してゾーンの親ゾーンにこのクエリを実行します。これは、ターゲットゾーンの完全に反応しない名前サーバーのために失敗します。人気のあるゾーンがすべての名前サーバーの壊滅的な障害を経験した場合に効果を考えてみましょう。この再帰名のサーバーの実装に送信されたゾーン内のドメイン名のすべての再帰クエリは、失敗したゾーンの親名サーバーへのクエリになります。数十人の一般的なゾーンが到達できなくなったとき、COM/ネット名サーバーのクエリ負荷は50％増加しました。"
    },
    {
      "indent": 3,
      "text": "We believe this verification query is not reasonable. Consider the circumstances: when an iterative resolver is resolving a query for a domain name in a zone it has not previously searched, it uses the list of name servers in the referral from the target zone's parent. If on its first attempt to search the target zone, none of the name servers in the referral is reachable, a verification query to the parent would be pointless: this query to the parent would come so quickly on the heels of the referral that it would be almost certain to contain the same list of name servers. The chance of discovering any new information is slim.",
      "ja": "この検証クエリは合理的ではないと考えています。状況を考慮してください。反復リゾルバーが以前に検索していないゾーン内のドメイン名のクエリを解決している場合、ターゲットゾーンの親からの紹介の名前サーバーのリストを使用します。ターゲットゾーンを検索しようとする最初の試みで、紹介の名前サーバーのいずれも到達できない場合、親への検証クエリは無意味になります。名前サーバーの同じリストが含まれていることをほぼ確実にしてください。新しい情報を発見する可能性はわずかです。"
    },
    {
      "indent": 3,
      "text": "The other possibility is that the iterative resolver successfully contacts one of the target zone's name servers and then caches the NS RRSet from the authority section of a response, the proper behavior according to Section 5.4.1 of RFC 2181 [3], because the NS RRSet from the target zone is more trustworthy than delegation information from the parent zone. If, while processing a subsequent recursive query, the iterative resolver discovers that none of the name servers specified in the cached NS RRSet is available or authoritative, querying the parent would be wrong. An NS RRSet from the parent zone would now be less trustworthy than data already in the cache.",
      "ja": "もう1つの可能性は、反復リゾルバーがターゲットゾーンの名前サーバーの1つに正常に接触し、RFC 2181 [3]のセクション5.4.1 [3]の適切な動作である応答の権限セクションからNS RRSetをキャッシュすることです。ターゲットゾーンからのRRSetは、親ゾーンからの委任情報よりも信頼できます。後続の再帰クエリの処理中に、反復的なリゾルバーが、キャッシュされたNS RRSetで指定された名前サーバーが利用可能または権威あるものがないことを発見した場合、親を照会することは間違っています。親ゾーンからのNS RRSetは、すでにキャッシュにあるデータよりも信頼性が低くなります。"
    },
    {
      "indent": 3,
      "text": "For this query of the parent zone to be useful, the target zone's entire set of name servers would have to change AND the former set of name servers would have to be deconfigured or decommissioned AND the delegation information in the parent zone would have to be updated with the new set of name servers, all within the Time to Live (TTL) of the target zone's NS RRSet. We believe this scenario is uncommon: administrative best practices dictate that changes to a zone's set of name servers happen gradually when at all possible, with servers removed from the NS RRSet left authoritative for the zone as long as possible. The scenarios that we can envision that would benefit from the parent requery behavior do not outweigh its damaging effects.",
      "ja": "親ゾーンのこのクエリを役立つには、ターゲットゾーンの名前サーバー全体を変更する必要があり、以前の名前サーバーのセットをデコンフィギングまたは廃止する必要があり、親ゾーンの委任情報を更新する必要があります新しい名前サーバーのセットを使用して、すべてターゲットゾーンのNS RRSetのライブ（TTL）の時間内にあります。このシナリオは珍しいと考えています。管理上のベストプラクティスは、ゾーンの名前サーバーのセットの変更が可能な限り徐々に発生することを決定します。親のrequeryの行動から利益を得ることを想像できるシナリオは、その損傷の影響を上回りません。"
    },
    {
      "indent": 3,
      "text": "This section should not be understood to claim that all queries to a zone's parent are bad. In some cases, such queries are not only reasonable but required. Consider the situation when required information, such as the address of a name server (i.e., the address record corresponding to the RDATA of an NS record), has timed out of an iterative resolver's cache before the corresponding NS record. If the name of the name server is below the apex of the zone, then the name server's address record is only available as glue in the parent zone. For example, consider this NS record:",
      "ja": "このセクションは、ゾーンの親のすべてのクエリが悪いと主張することを理解すべきではありません。場合によっては、そのようなクエリは合理的であるだけでなく、必要です。名前サーバーのアドレス（つまり、NSレコードのRDATAに対応するアドレスレコード）などの必要な情報を考慮して、対応するNSレコードの前に反復的なリゾルバーのキャッシュからタイミングを出しました。名前サーバーの名前がゾーンの頂点の下にある場合、名前サーバーのアドレスレコードは、親ゾーンの接着剤としてのみ使用できます。たとえば、このNSレコードを考えてみましょう。"
    },
    {
      "indent": 5,
      "text": "example.com. IN NS ns.example.com.",
      "ja": "Example.com。ns ns.example.comで。"
    },
    {
      "indent": 3,
      "text": "If a cache has this NS record but not the address record for \"ns.example.com\", it is unable to contact the \"example.com\" zone directly and must query the \"com\" zone to obtain the address record. Note, however, that such a query would not have QTYPE=NS according to the standard resolution algorithm.",
      "ja": "キャッシュに「ns.example.com」のアドレスレコードがないが、このNSレコードがない場合、「Example.com」ゾーンに直接連絡することができず、アドレスレコードを取得するために「com」ゾーンを照会する必要があります。ただし、このようなクエリには標準解像度アルゴリズムに従ってQType = nsが含まれないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Recommendation",
      "section_title": true,
      "ja": "2.1.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "An iterative resolver MUST NOT send a query for the NS RRSet of a non-responsive zone to any of the name servers for that zone's parent zone. For the purposes of this injunction, a non-responsive zone is defined as a zone for which every name server listed in the zone's NS RRSet:",
      "ja": "反復リゾルバーは、そのゾーンの親ゾーンの名前サーバーのいずれかに、非応答ゾーンのNS RRSetのクエリを送信してはなりません。この差し止め命令の目的のために、非応答ゾーンは、ゾーンのNS RRSetにリストされているすべての名前サーバーがゾーンとして定義されます。"
    },
    {
      "indent": 3,
      "text": "1. is not authoritative for the zone (i.e., lame), or",
      "ja": "1. ゾーン（すなわち、ラメ）の権威がない、または"
    },
    {
      "indent": 3,
      "text": "2. returns a server failure response (RCODE=2), or",
      "ja": "2. サーバー障害応答（rcode = 2）を返し、"
    },
    {
      "indent": 3,
      "text": "3. is dead or unreachable according to Section 7.2 of RFC 2308 [4].",
      "ja": "3. RFC 2308 [4]のセクション7.2によると、死んでいるか、到達できません。"
    },
    {
      "indent": 0,
      "text": "2.2. Repeated Queries to Lame Servers",
      "section_title": true,
      "ja": "2.2. "
    },
    {
      "indent": 3,
      "text": "Section 2.1 describes a catastrophic failure: when every name server for a zone is unable to provide an answer for one reason or another. A more common occurrence is when a subset of a zone's name servers is unavailable or misconfigured. Different failure modes have different expected durations. Some symptoms indicate problems that are potentially transient, for example, various types of ICMP unreachable messages because a name server process is not running or a host or network is unreachable, or a complete lack of a response to a query. Such responses could be the result of a host rebooting or temporary outages; these events do not necessarily require any human intervention and can be reasonably expected to be temporary.",
      "ja": "セクション2.1では、壊滅的な障害について説明します。ゾーンのすべての名前サーバーが何らかの理由で答えを提供できない場合。より一般的な発生は、ゾーンの名前サーバーのサブセットが利用できないか、誤解されている場合です。異なる障害モードには、予想される期間が異なります。一部の症状は、名前サーバープロセスが実行されていないか、ホストまたはネットワークが到達不可能であるため、またはクエリに対する応答が完全にないため、潜在的に一時的な問題、たとえば、さまざまなタイプのICMPの到達不可能なメッセージなど、潜在的に一時的な問題を示しています。このような応答は、ホストの再起動または一時的な停止の結果である可能性があります。これらのイベントは、必ずしも人間の介入を必要とするわけではなく、一時的なものであると合理的に期待される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Other symptoms clearly indicate a condition requiring human intervention, such as lame server: if a name server is misconfigured and not authoritative for a zone delegated to it, it is reasonable to assume that this condition has potential to last longer than unreachability or unresponsiveness. Consequently, repeated queries to known lame servers are not useful. In this case of a condition with potential to persist for a long time, a better practice would be to maintain a list of known lame servers and avoid querying them repeatedly in a short interval.",
      "ja": "他の症状は、ラメサーバーなどの人間の介入を必要とする状態を明確に示しています。名前サーバーが誤解されており、委任されたゾーンの権威がない場合、この条件は到達不能や反応のないよりも長持ちする可能性があると仮定するのが合理的です。その結果、既知のラメサーバーに繰り返されるクエリは役に立ちません。長い間持続する可能性のある条件のこの場合、より良い実践は、既知のラメサーバーのリストを維持し、短い間隔でそれらを繰り返し照会することを避けることです。"
    },
    {
      "indent": 3,
      "text": "It should also be noted, however, that some authoritative name server implementations appear to be lame only for queries of certain types as described in RFC 4074 [5]. In this case, it makes sense to retry the \"lame\" servers for other types of queries, particularly when all known authoritative name servers appear to be \"lame\".",
      "ja": "ただし、RFC 4074 [5]に記載されているように、特定のタイプのクエリに対してのみ、権威ある名前サーバーの実装が不自由であるように見えることにも注意する必要があります。この場合、特にすべての既知の権威ある名前サーバーが「ラメ」と思われる場合、他のタイプのクエリに対して「ラメ」サーバーを再試行することは理にかなっています。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Recommendation",
      "section_title": true,
      "ja": "2.2.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "Iterative resolvers SHOULD cache name servers that they discover are not authoritative for zones delegated to them (i.e., lame servers). If this caching is performed, lame servers MUST be cached against the specific query tuple <zone name, class, server IP address>. Zone name can be derived from the owner name of the NS record that was referenced to query the name server that was discovered to be lame.",
      "ja": "反復型リゾルバーは、発見した名前のセルバーをキャッシュする必要があります。このキャッシングが実行される場合、ラメサーバーは特定のクエリ<ゾーン名、クラス、サーバーIPアドレス>に対してキャッシュする必要があります。ゾーン名は、不自由であることが発見された名前サーバーのクエリが参照されたNSレコードの所有者名から導き出すことができます。"
    },
    {
      "indent": 3,
      "text": "Implementations that perform lame server caching MUST refrain from sending queries to known lame servers for a configurable time interval after the server is discovered to be lame. A minimum interval of thirty minutes is RECOMMENDED.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An exception to this recommendation occurs if all name servers for a zone are marked lame. In that case, the iterative resolver SHOULD temporarily ignore the servers' lameness status and query one or more servers. This behavior is a workaround for the type-specific lameness issue described in the previous section.",
      "ja": "この推奨事項の例外は、ゾーンのすべての名前サーバーがマークされている場合に発生します。その場合、反復リゾルバーは、サーバーのラメネスステータスを一時的に無視し、1つ以上のサーバーをクエリする必要があります。この動作は、前のセクションで説明されているタイプ固有のlam性問題の回避策です。"
    },
    {
      "indent": 3,
      "text": "Implementors should take care not to make lame server avoidance logic overly broad: note that a name server could be lame for a parent zone but not a child zone, e.g., lame for \"example.com\" but properly authoritative for \"sub.example.com\". Therefore, a name server should not be automatically considered lame for subzones. In the case above, even if a name server is known to be lame for \"example.com\", it should be queried for QNAMEs at or below \"sub.example.com\" if an NS record indicates that it should be authoritative for that zone.",
      "ja": "実装者は、ラメサーバーの回避ロジックを非常に広くしないように注意する必要があります。名前サーバーは、子ゾーンではなく、「embler.com」のラメではなく、「サブの例」で適切に権威ある場合は、親ゾーンでは不自由である可能性があることに注意してください。com \"。したがって、名前サーバーは、サブゾーンのラメと自動的に見なされるべきではありません。上記のケースでは、「example.com」の名前が不自由であることが知られている場合でも、NSレコードがそれに対して権威あるものであるべきであることを示している場合、「sub.example.com」というqnamesのqnamesにクエリをする必要があります。ゾーン。"
    },
    {
      "indent": 0,
      "text": "2.3. Inability to Follow Multiple Levels of Indirection",
      "section_title": true,
      "ja": "2.3. 複数のレベルの間接に従うことができない"
    },
    {
      "indent": 3,
      "text": "Some iterative resolver implementations are unable to follow sufficient levels of indirection. For example, consider the following delegations:",
      "ja": "一部の反復リゾルバーの実装は、十分なレベルの間接に従うことができません。たとえば、次の代表団を検討してください。"
    },
    {
      "indent": 5,
      "text": "foo.example. IN NS ns1.example.com. foo.example. IN NS ns2.example.com.",
      "ja": "foo.example。ns1.example.comで。foo.example。ns2.example.comで。"
    },
    {
      "indent": 5,
      "text": "example.com. IN NS ns1.test.example.net. example.com. IN NS ns2.test.example.net.",
      "ja": "Example.com。ns1.test.example.netで。Example.com。ns2.test.example.netで。"
    },
    {
      "indent": 5,
      "text": "test.example.net. IN NS ns1.test.example.net. test.example.net. IN NS ns2.test.example.net.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An iterative resolver resolving the name \"www.foo.example\" must follow two levels of indirection, first obtaining address records for \"ns1.test.example.net\" or \"ns2.test.example.net\" in order to obtain address records for \"ns1.example.com\" or \"ns2.example.com\" in order to query those name servers for the address records of \"www.foo.example\". Although this situation may appear contrived, we have seen multiple similar occurrences and expect more as new generic top-level domains (gTLDs) become active. We anticipate many zones in new gTLDs will use name servers in existing gTLDs, increasing the number of delegations using out-of-zone name servers.",
      "ja": "「www.foo.example」という名前を解決する反復的なリゾルバーは、2つのレベルの間接に従う必要があります。最初に「ns1.test.example.net」または「ns2.test.example.net」のアドレスレコードを取得する必要があります。「ns1.example.com」または「ns2.example.com」の場合、「www.foo.example」のアドレスレコードの名前サーバーを照会します。この状況は不自然に見えるかもしれませんが、複数の同様の出来事を見ており、新しいジェネリックトップレベルドメイン（GTLD）がアクティブになるにつれて、より多くを期待しています。新しいGTLDの多くのゾーンが既存のGTLDで名前サーバーを使用し、ゾーン外の名前サーバーを使用して委任の数を増やすと予想されます。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Recommendation",
      "section_title": true,
      "ja": "2.3.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "Clearly constructing a delegation that relies on multiple levels of indirection is not a good administrative practice. However, the practice is widespread enough to require that iterative resolvers be able to cope with it. Iterative resolvers SHOULD be able to handle arbitrary levels of indirection resulting from out-of-zone name servers. Iterative resolvers SHOULD implement a level-of-effort counter to avoid loops or otherwise performing too much work in resolving pathological cases.",
      "ja": "複数のレベルの間接に依存する代表団を明確に構築することは、良い管理慣行ではありません。ただし、このプラクティスは、反復的なリゾルバーがそれに対処できることを要求するのに十分なほど広がっています。反復リゾルバーは、ゾーン外の名前サーバーに起因する任意のレベルの間接を処理できるはずです。反復的なリゾルバーは、ループを回避したり、病理学的症例を解決する際にあまりにも多くの作業を実行したりするために、エフォルトレベルのカウンターを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "A best practice that avoids this entire issue of indirection is to name one or more of a zone's name servers in the zone itself. For example, if the zone is named \"example.com\", consider naming some of the name servers \"ns{1,2,...}.example.com\" (or similar).",
      "ja": "間接的なこの問題全体を回避するベストプラクティスは、ゾーン自体に1つ以上のゾーンの名前サーバーに名前を付けることです。たとえば、ゾーンに「Example.com」という名前の場合、「NS {1,2、...}。embly.com」（または類似）の名前サーバーの一部に名前を付けることを検討してください。"
    },
    {
      "indent": 0,
      "text": "2.4. Aggressive Retransmission when Fetching Glue",
      "section_title": true,
      "ja": "2.4. 接着剤を取得するときの積極的な再送信"
    },
    {
      "indent": 3,
      "text": "When an authoritative name server responds with a referral, it includes NS records in the authority section of the response. According to the algorithm in Section 4.3.2 of RFC 1034 [2], the name server should also \"put whatever addresses are available into the additional section, using glue RRs if the addresses are not available from authoritative data or the cache.\" Some name server implementations take this address inclusion a step further with a feature called \"glue fetching\". A name server that implements glue fetching attempts to include address records for every NS record in the authority section. If necessary, the name server issues multiple queries of its own to obtain any missing address records.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Problems with glue fetching can arise in the context of \"authoritative-only\" name servers, which only serve authoritative data and ignore requests for recursion. Such an entity will not normally generate any queries of its own. Instead it answers non-recursive queries from iterative resolvers looking for information in zones it serves. With glue fetching enabled, however, an authoritative server invokes an iterative resolver to look up an unknown address record to complete the additional section of a response.",
      "ja": "接着剤フェッチの問題は、「権威のある専用」名前サーバーのコンテキストで発生する可能性があります。このようなエンティティは、通常、独自のクエリを生成しません。代わりに、それが提供するゾーンの情報を探している反復リゾルバーからの非再帰的クエリに答えます。ただし、Glue Fetchingを有効にすると、権威あるサーバーが反復リゾルバーを呼び出して、未知のアドレスレコードを検索して応答の追加セクションを完成させます。"
    },
    {
      "indent": 3,
      "text": "We have observed situations where the iterative resolver of a glue-fetching name server can send queries that reach other name servers, but is apparently prevented from receiving the responses. For example, perhaps the name server is authoritative-only and therefore its administrators expect it to receive only queries and not responses. Perhaps unaware of glue fetching and presuming that the name server's iterative resolver will generate no queries, its administrators place the name server behind a network device that prevents it from receiving responses. If this is the case, all glue-fetching queries will go unanswered.",
      "ja": "接着剤を獲得する名前サーバーの反復リゾルバーが他の名前サーバーに届くクエリを送信できる状況を観察しましたが、明らかに応答を受信できないようです。たとえば、おそらく名前サーバーは権威あるものであるため、その管理者は、応答ではなくクエリのみを受信することを期待しています。おそらく、接着剤の取得を知らず、名前サーバーの反復リゾルバーがクエリを生成しないことを推定します。その管理者は、ネットワークデバイスの後ろにネットワークサーバーを配置し、応答を受信できないようにします。この場合、すべての接着剤を獲得するクエリは未回答になります。"
    },
    {
      "indent": 3,
      "text": "We have observed name server implementations whose iterative resolvers retry excessively when glue-fetching queries are unanswered. A single com/net name server has received hundreds of queries per second from a single such source. Judging from the specific queries received and based on additional analysis, we believe these queries result from overly aggressive glue fetching.",
      "ja": "接着剤フェッチのクエリが未回答の場合、反復的なリゾルバーが過度に再試行する名前サーバーの実装を観察しました。単一のcom/net nameサーバーは、そのようなソースの単一から毎秒数百秒のクエリを受信しています。受信した特定のクエリから判断し、追加の分析に基づいて、これらのクエリは過度に攻撃的な接着剤フェッチングに起因すると考えています。"
    },
    {
      "indent": 0,
      "text": "2.4.1. Recommendation",
      "section_title": true,
      "ja": "2.4.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "Implementers whose name servers support glue fetching SHOULD take care to avoid sending queries at excessive rates. Implementations SHOULD support throttling logic to detect when queries are sent but no responses are received.",
      "ja": "ネームサーバーが接着剤のフェッチングをサポートする実装者は、過度のレートでクエリを送信しないように注意する必要があります。実装では、クエリが送信された時期を検出するためにスロットリングロジックをサポートする必要がありますが、応答は受けられません。"
    },
    {
      "indent": 0,
      "text": "2.5. Aggressive Retransmission behind Firewalls",
      "section_title": true,
      "ja": "2.5. ファイアウォールの背後にある積極的な再送信"
    },
    {
      "indent": 3,
      "text": "A common occurrence and one of the largest sources of repeated queries at the com/net and root name servers appears to result from resolvers behind misconfigured firewalls. In this situation, an iterative resolver is apparently allowed to send queries through a firewall to other name servers, but not receive the responses. The result is more queries than necessary because of retransmission, all of which are useless because the responses are never received. Just as with the glue-fetching scenario described in Section 2.4, the queries are sometimes sent at excessive rates. To make matters worse, sometimes the responses, sent in reply to legitimate queries, trigger an alarm on the originator's intrusion detection system. We are frequently contacted by administrators responding to such alarms who believe our name servers are attacking their systems.",
      "ja": "Com/Netおよびルート名サーバーでの一般的な発生と繰り返されるクエリの最大のソースの1つは、誤った構成ファイアウォールの背後にあるリゾルバーに起因するようです。この状況では、反復的なリゾルバーは、ファイアウォールを介して他の名前サーバーにクエリを送信することが許可されているようですが、応答は受け取りません。結果は、再送信のために必要以上に多くのクエリになります。これらはすべて、回答が受信されないために役に立ちます。セクション2.4で説明されている接着剤フェッチのシナリオと同様に、クエリは過度の速度で送信されることがあります。さらに悪いことに、正当なクエリへの返信で送信される応答が、発信者の侵入検知システムのアラームをトリガーする場合があります。私たちは、私たちの名前サーバーがシステムを攻撃していると信じているそのようなアラームに応答する管理者から頻繁に連絡されます。"
    },
    {
      "indent": 3,
      "text": "Not only do some resolvers in this situation retransmit queries at an excessive rate, but they continue to do so for days or even weeks. This scenario could result from an organization with multiple recursive name servers, only a subset of whose iterative resolvers' traffic is improperly filtered in this manner. Stub resolvers in the organization could be configured to query multiple recursive name servers. Consider the case where a stub resolver queries a filtered recursive name server first. The iterative resolver of this recursive name server sends one or more queries whose replies are filtered, so it cannot respond to the stub resolver, which times out. Then the stub resolver retransmits to a recursive name server that is able to provide an answer. Since resolution ultimately succeeds the underlying problem might not be recognized or corrected. A popular stub resolver implementation has a very aggressive retransmission schedule, including simultaneous queries to multiple recursive name servers, which could explain how such a situation could persist without being detected.",
      "ja": "この状況でいくつかのリゾルバーが過度の速度でクエリを再送信するだけでなく、数日または数週間も続けています。このシナリオは、複数の再帰名サーバーを備えた組織から生じる可能性があり、その方法で反復型のトラフィックが不適切にフィルタリングされているサブセットのみが発生します。組織内のスタブリゾルバーは、複数の再帰名サーバーを照会するように構成できます。Stub Resolverが最初にフィルタリングされた再帰名サーバーをクエリする場合を考えてください。この再帰名サーバーの反復リゾルバーは、返信がフィルタリングされている1つ以上のクエリを送信するため、スタブリゾルバーに応答することはできません。次に、スタブリゾルバーは、回答を提供できる再帰名サーバーに再送信します。解決は最終的に成功するため、根本的な問題は認識または修正されない可能性があります。人気のあるスタブリゾルバーの実装には、複数の再帰名サーバーへの同時クエリを含む非常に積極的な再送信スケジュールがあり、このような状況が検出されずにどのように持続するかを説明できます。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Recommendation",
      "section_title": true,
      "ja": "2.5.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "The most obvious recommendation is that administrators SHOULD take care not to place iterative resolvers behind a firewall that allows queries, but not the resulting replies, to pass through.",
      "ja": "最も明白な推奨事項は、管理者が、結果の返信を許可しないファイアウォールの後ろに反復的なリゾルバーを配置しないように注意する必要があることです。"
    },
    {
      "indent": 3,
      "text": "Iterative resolvers SHOULD take care to avoid sending queries at excessive rates. Implementations SHOULD support throttling logic to detect when queries are sent but no responses are received.",
      "ja": "反復リゾルバーは、過度のレートでクエリを送信しないように注意する必要があります。実装では、クエリが送信された時期を検出するためにスロットリングロジックをサポートする必要がありますが、応答は受けられません。"
    },
    {
      "indent": 0,
      "text": "2.6. Misconfigured NS Records",
      "section_title": true,
      "ja": "2.6. 誤ったNSレコード"
    },
    {
      "indent": 3,
      "text": "Sometimes a zone administrator forgets to add the trailing dot on the domain names in the RDATA of a zone's NS records. Consider this fragment of the zone file for \"example.com\":",
      "ja": "ゾーン管理者が、ゾーンのNSレコードのRDATAのドメイン名にトレーリングドットを追加することを忘れている場合があります。ゾーンファイルのこの断片を「embles.com」と考えてみましょう。"
    },
    {
      "indent": 5,
      "text": "$ORIGIN example.com. example.com. 3600 IN NS ns1.example.com ; Note missing example.com. 3600 IN NS ns2.example.com ; trailing dots",
      "ja": "$ origin Example.com。Example.com。NS1.example.comの3600;Example.comがないことに注意してください。NS2.example.comの3600;トレーリングドット"
    },
    {
      "indent": 3,
      "text": "The zone's authoritative servers will parse the NS RDATA as \"ns1.example.com.example.com\" and \"ns2.example.com.example.com\" and return NS records with this incorrect RDATA in responses, including typically the authority section of every response containing records from the \"example.com\" zone.",
      "ja": "ゾーンの権威あるサーバーは、NS RDATAを「ns1.example.com.example.com」および「ns2.example.com.example.com」として解析し、通常、この誤ったRDATAを使用してNSレコードを返します。「Example.com」ゾーンからのレコードを含むすべての応答。"
    },
    {
      "indent": 3,
      "text": "Now consider a typical sequence of queries. An iterative resolver attempting to resolve address records for \"www.example.com\" with no cached information for this zone will query a \"com\" authoritative server. The \"com\" server responds with a referral to the \"example.com\" zone, consisting of NS records with valid RDATA and associated glue records. (This example assumes that the \"example.com\" zone delegation information is correct in the \"com\" zone.) The iterative resolver caches the NS RRSet from the \"com\" server and follows the referral by querying one of the \"example.com\" authoritative servers. This server responds with the \"www.example.com\" address record in the answer section and, typically, the \"example.com\" NS records in the authority section and, if space in the message remains, glue address records in the additional section. According to Section 5.4.1 of RFC 2181 [3], NS records in the authority section of an authoritative answer are more trustworthy than NS records from the authority section of a non-authoritative answer. Thus, the \"example.com\" NS RRSet just received from the \"example.com\" authoritative server overrides the \"example.com\" NS RRSet received moments ago from the \"com\" authoritative server.",
      "ja": "次に、典型的な一連のクエリを検討します。このゾーンのキャッシュされた情報がない「www.example.com」のアドレスレコードを解決しようとする反復的なリゾルバーは、「com」権威あるサーバーを照会します。「COM」サーバーは、有効なRDATAと関連するGlueレコードを備えたNSレコードで構成される「Example.com」ゾーンへの紹介で応答します。（この例では、「example.com」ゾーンの委任情報が「com」ゾーンで正しいと想定しています。）反復リゾルバーは、「com」サーバーからのns rrsetをキャッシュし、「example.comのいずれかを照会して紹介に従います。「権威あるサーバー。このサーバーは、回答セクションの「www.example.com」アドレスレコード、および通常、権限セクションの「Example.com」NSレコードと、メッセージ内のスペースが残っている場合、追加セクションの接着アドレス記録で応答します。。RFC 2181 [3]のセクション5.4.1によると、権威ある回答の当局セクションのNSレコードは、非認知的回答の当局セクションのNS記録よりも信頼できるものです。したがって、「example.com」ns rrsetは、「example.com」権限サーバーから受け取ったばかりで、「example.com」ns rrsetが「com」権限サーバーから受け取ったns rrsetをオーバーライドします。"
    },
    {
      "indent": 3,
      "text": "But the \"example.com\" zone contains the erroneous NS RRSet as shown in the example above. Subsequent queries for names in \"example.com\" will cause the iterative resolver to attempt to use the incorrect NS records and so it will try to resolve the nonexistent names \"ns1.example.com.example.com\" and \"ns2.example.com.example.com\". In this example, since all of the zone's name servers are named in the zone itself (i.e., \"ns1.example.com.example.com\" and \"ns2.example.com.example.com\" both end in \"example.com\") and all are bogus, the iterative resolver cannot reach any \"example.com\" name servers. Therefore, attempts to resolve these names result in address record queries to the \"com\" authoritative servers. Queries for such obviously bogus glue address records occur frequently at the com/net name servers.",
      "ja": "ただし、「Example.com」ゾーンには、上記の例に示すように、誤ったNS RRSETが含まれています。「example.com」の名前の後続のクエリは、反復的なリゾルバーが誤ったNSレコードを使用しようとするため、存在しない名前「ns1.example.com.example.com」および「ns2.example」を解決しようとします。com.example.com \"。この例では、すべてのゾーンの名前サーバーがゾーン自体に命名されているため（つまり、「ns1.example.com.example.com」および「ns2.example.com.example.com」の両方が \"example.comで終わります。\"）そしてすべてが偽物であり、反復的なリゾルバーは「Example.com」名前サーバーに到達することはできません。したがって、これらの名前を解決しようとすると、「com」権威あるサーバーのアドレス記録クエリが得られます。そのような明らかに偽の接着剤アドレスレコードのクエリは、COM/ネット名サーバーで頻繁に発生します。"
    },
    {
      "indent": 0,
      "text": "2.6.1. Recommendation",
      "section_title": true,
      "ja": "2.6.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "An authoritative server can detect this situation. A trailing dot missing from an NS record's RDATA always results by definition in a name server name that exists somewhere under the apex of the zone that the NS record appears in. Note that further levels of delegation are possible, so a missing trailing dot could inadvertently create a name server name that actually exists in a subzone.",
      "ja": "権威あるサーバーは、この状況を検出できます。NSレコードのRDATAから欠落している後続のドットは、NSレコードが表示されるゾーンの頂点のどこかに存在する名前サーバー名で常に定義上、常に発生します。さらなる委任のレベルが可能であることに注意してください。実際にサブゾーンに存在する名前サーバー名を作成します。"
    },
    {
      "indent": 3,
      "text": "An authoritative name server SHOULD issue a warning when one of a zone's NS records references a name server below the zone's apex when a corresponding address record does not exist in the zone AND there are no delegated subzones where the address record could exist.",
      "ja": "ゾーンのNSレコードのいずれかがゾーンの頂点の下の名前サーバーを参照している場合、ゾーンの頂点の下の名前のサーバーを参照している場合、ゾーンの頂点の下にある名前のサーバーがゾーンに存在しない場合、アドレス記録が存在する可能性のある委任されたサブゾーンがない場合、警告を発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.7. Name Server Records with Zero TTL",
      "section_title": true,
      "ja": "2.7. ゼロTTLの名前サーバーレコード"
    },
    {
      "indent": 3,
      "text": "Sometimes a popular com/net subdomain's zone is configured with a TTL of zero on the zone's NS records, which prohibits these records from being cached and will result in a higher query volume to the zone's authoritative servers. The zone's administrator should understand the consequences of such a configuration and provision resources accordingly. A zero TTL on the zone's NS RRSet, however, carries additional consequences beyond the zone itself: if an iterative resolver cannot cache a zone's NS records because of a zero TTL, it will be forced to query that zone's parent's name servers each time it resolves a name in the zone. The com/net authoritative servers do see an increased query load when a popular com/net subdomain's zone is configured with a TTL of zero on the zone's NS records.",
      "ja": "人気のあるCOM/ネットサブドメインゾーンがゾーンのNSレコードにゼロのTTLで構成されている場合があります。これにより、これらのレコードがキャッシュされないようになり、ゾーンの権威あるサーバーのクエリボリュームが高くなります。ゾーンの管理者は、そのような構成の結果を理解し、それに応じてリソースを提供する必要があります。ただし、ゾーンのNS RRSETのゼロTTLは、ゾーン自体を超えて追加の結果をもたらします。反復的なリゾルバーがTTLがゼロのためにゾーンのNSレコードをキャッシュできない場合、解決するたびにゾーンの親の名前がサーバーを照会することを余儀なくされます。ゾーン内の名前。com/net権威あるサーバーは、ゾーンのNSレコードにゼロのTTLで人気のあるCOM/ネットサブドメインゾーンが構成されている場合、クエリ負荷の増加が表示されます。"
    },
    {
      "indent": 3,
      "text": "A zero TTL on an RRSet expected to change frequently is extreme but permissible. A zone's NS RRSet is a special case, however, because changes to it must be coordinated with the zone's parent. In most zone parent/child relationships that we are aware of, there is typically some delay involved in effecting changes. Furthermore, changes to the set of a zone's authoritative name servers (and therefore to the zone's NS RRSet) are typically relatively rare: providing reliable authoritative service requires a reasonably stable set of servers. Therefore, an extremely low or zero TTL on a zone's NS RRSet rarely makes sense, except in anticipation of an upcoming change. In this case, when the zone's administrator has planned a change and does not want iterative resolvers throughout the Internet to cache the NS RRSet for a long period of time, a low TTL is reasonable.",
      "ja": "頻繁に変化すると予想されるRRSetのゼロTTLは極端ですが、許容されます。ただし、ゾーンのNS RRSetは特別なケースです。これは、ゾーンの親と調整する必要があるためです。私たちが知っているほとんどのゾーンの親と子の関係では、通常、変化の影響に関与する遅延があります。さらに、ゾーンの信頼できる名前サーバーのセット（したがってゾーンのNS RRSet）の変更は通常比較的まれです。信頼できる権威あるサービスを提供するには、合理的に安定したサーバーのセットが必要です。したがって、ゾーンのNS RRSetの非常に低いまたはゼロTTLは、今後の変更を見越している場合を除き、めったに意味がありません。この場合、ゾーンの管理者が変更を計画しており、インターネット全体で反復的なリゾルバーがNS RRSetを長期間キャッシュすることを望まない場合、低いTTLは妥当です。"
    },
    {
      "indent": 0,
      "text": "2.7.1. Recommendation",
      "section_title": true,
      "ja": "2.7.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "Because of the additional load placed on a zone's parent's authoritative servers resulting from a zero TTL on a zone's NS RRSet, under such circumstances authoritative name servers SHOULD issue a warning when loading a zone.",
      "ja": "ゾーンのNS RRSetのゼロTTLに起因するゾーンの親の権威あるサーバーに追加の負荷がかかるため、このような状況下では、権威ある名前サーバーはゾーンをロードするときに警告を発行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.8. Unnecessary Dynamic Update Messages",
      "section_title": true,
      "ja": "2.8. 不要な動的更新メッセージ"
    },
    {
      "indent": 3,
      "text": "The UPDATE message specified in RFC 2136 [6] allows an authorized agent to update a zone's data on an authoritative name server using a DNS message sent over the network. Consider the case of an agent desiring to add a particular resource record. Because of zone cuts, the agent does not necessarily know the proper zone to which the record should be added. The dynamic update process requires that the agent determine the appropriate zone so the UPDATE message can be sent to one of the zone's authoritative servers (typically the primary master as specified in the zone's Start of Authority (SOA) record's MNAME field).",
      "ja": "RFC 2136 [6]で指定された更新メッセージにより、認定エージェントは、ネットワークを介して送信されたDNSメッセージを使用して、権威ある名前サーバー上のゾーンのデータを更新できます。特定のリソースレコードを追加することを望んでいるエージェントの場合を検討してください。ゾーンカットのため、エージェントは必ずしもレコードを追加する必要がある適切なゾーンを知っているわけではありません。動的な更新プロセスでは、エージェントが適切なゾーンを決定して、更新メッセージをゾーンの権威あるサーバーのいずれかに送信できるようにする必要があります（通常、ゾーンの権限の開始（SOA）レコードのMNAMEフィールドで指定されているプライマリマスター）。"
    },
    {
      "indent": 3,
      "text": "The appropriate zone to update is the closest enclosing zone, which cannot be determined only by inspecting the domain name of the record to be updated, since zone cuts can occur anywhere. One way to determine the closest enclosing zone entails walking up the name space tree by sending repeated UPDATE messages until successful. For example, consider an agent attempting to add an address record with the name \"foo.bar.example.com\". The agent could first attempt to update the \"foo.bar.example.com\" zone. If the attempt failed, the update could be directed to the \"bar.example.com\" zone, then the \"example.com\" zone, then the \"com\" zone, and finally the root zone.",
      "ja": "更新する適切なゾーンは、ゾーンカットがどこでも発生する可能性があるため、更新するレコードのドメイン名を検査することでのみ決定することはできません。最も近い囲まれたゾーンを決定する1つの方法は、成功するまで繰り返し更新メッセージを送信することにより、名前のスペースツリーを上に歩くことを伴います。たとえば、「foo.bar.example.com」という名前のアドレスレコードを追加しようとするエージェントを検討してください。エージェントは、最初に「foo.bar.example.com」ゾーンの更新を試みることができます。試みが失敗した場合、更新は「bar.example.com」ゾーン、次に「embles.com」ゾーン、「com」ゾーン、最後にルートゾーンに向けられます。"
    },
    {
      "indent": 3,
      "text": "A popular dynamic agent follows this algorithm. The result is many UPDATE messages received by the root name servers, the com/net authoritative servers, and presumably other TLD authoritative servers. A valid question is why the algorithm proceeds to send updates all the way to TLD and root name servers. This behavior is not entirely unreasonable: in enterprise DNS architectures with an",
      "ja": "人気のある動的エージェントがこのアルゴリズムに従います。その結果、ルート名サーバー、COM/ネットの権威あるサーバー、およびおそらく他のTLD権威あるサーバーによって受信された多くの更新メッセージが得られます。有効な質問は、アルゴリズムがTLDおよびルートネームサーバーに更新を送信するために進む理由です。この動作は完全に不合理ではありません。"
    },
    {
      "indent": 3,
      "text": "\"internal root\" design, there could conceivably be private, non-public TLD or root zones that would be the appropriate targets for a dynamic update.",
      "ja": "「内部ルート」デザインでは、ダイナミックアップデートの適切なターゲットとなるプライベート、非公開のTLDまたはルートゾーンがある可能性があります。"
    },
    {
      "indent": 3,
      "text": "A significant deficiency with this algorithm is that knowledge of a given UPDATE message's failure is not helpful in directing future UPDATE messages to the appropriate servers. A better algorithm would be to find the closest enclosing zone by walking up the name space with queries for SOA or NS rather than \"probing\" with UPDATE messages. Once the appropriate zone is found, an UPDATE message can be sent. In addition, the results of these queries can be cached to aid in determining the closest enclosing zones for future updates. Once the closest enclosing zone is determined with this method, the update will either succeed or fail and there is no need to send further updates to higher-level zones. The important point is that walking up the tree with queries yields cacheable information, whereas walking up the tree by sending UPDATE messages does not.",
      "ja": "このアルゴリズムの重大な欠陥は、特定の更新メッセージの障害に関する知識が、将来の更新メッセージを適切なサーバーに指示するのに役立ちないことです。より良いアルゴリズムは、更新メッセージで「プロービング」するのではなく、SOAまたはNSのクエリを使用して名前スペースを登ることにより、最も近い囲まれたゾーンを見つけることです。適切なゾーンが見つかったら、更新メッセージを送信できます。さらに、これらのクエリの結果は、将来の更新に最も近い囲まれたゾーンを決定するのに役立つようにキャッシュできます。このメソッドで最も近い囲いゾーンが決定されると、更新は成功または失敗し、高レベルのゾーンにさらに更新を送信する必要はありません。重要な点は、クエリで木を上って行くとキャッシュ可能な情報が得られるのに対し、更新メッセージを送信してツリーを歩くことはできないということです。"
    },
    {
      "indent": 0,
      "text": "2.8.1. Recommendation",
      "section_title": true,
      "ja": "2.8.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "Dynamic update agents SHOULD send SOA or NS queries to progressively higher-level names to find the closest enclosing zone for a given name to update. Only after the appropriate zone is found should the client send an UPDATE message to one of the zone's authoritative servers. Update clients SHOULD NOT \"probe\" using UPDATE messages by walking up the tree to progressively higher-level zones.",
      "ja": "動的更新エージェントは、SOAまたはNSクエリを徐々に高レベルの名前に送信して、特定の名前の最も近い囲まれたゾーンを更新する必要があります。適切なゾーンが見つかった後にのみ、クライアントがゾーンの権威あるサーバーのいずれかに更新メッセージを送信した場合にのみ。クライアントの更新は、ツリーを上に歩いて徐々に高レベルのゾーンを歩いて更新メッセージを使用して「プローブ」してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.9. Queries for Domain Names Resembling IPv4 Addresses",
      "section_title": true,
      "ja": "2.9. IPv4アドレスに似たドメイン名のクエリ"
    },
    {
      "indent": 3,
      "text": "The root name servers receive a significant number of A record queries where the QNAME looks like an IPv4 address. The source of these queries is unknown. It could be attributed to situations where a user believes that an application will accept either a domain name or an IP address in a given configuration option. The user enters an IP address, but the application assumes that any input is a domain name and attempts to resolve it, resulting in an A record lookup. There could also be applications that produce such queries in a misguided attempt to reverse map IP addresses.",
      "ja": "ルート名サーバーは、QNameがIPv4アドレスのように見えるかなりの数のレコードクエリを受け取ります。これらのクエリのソースは不明です。これは、ユーザーがアプリケーションが特定の構成オプションのドメイン名またはIPアドレスのいずれかを受け入れると信じている状況に起因する可能性があります。ユーザーはIPアドレスを入力しますが、アプリケーションは、入力がドメイン名であると想定し、それを解決しようとするため、Aレコード検索が行われます。また、IPアドレスのマップを逆転させようとする誤った試みでこのようなクエリを生成するアプリケーションも存在する可能性があります。"
    },
    {
      "indent": 3,
      "text": "These queries result in Name Error (RCODE=3) responses. An iterative resolver can negatively cache such responses, but each response requires a separate cache entry; i.e., a negative cache entry for the domain name \"192.0.2.1\" does not prevent a subsequent query for the domain name \"192.0.2.2\".",
      "ja": "これらのクエリの結果、名前エラー（rcode = 3）応答が発生します。反復リゾルバーはそのような応答を負にキャッシュできますが、各応答には個別のキャッシュエントリが必要です。つまり、ドメイン名「192.0.2.1」のネガティブキャッシュエントリは、ドメイン名「192.0.2.2」の後続のクエリを妨げません。"
    },
    {
      "indent": 0,
      "text": "2.9.1. Recommendation",
      "section_title": true,
      "ja": "2.9.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "It would be desirable for the root name servers not to have to answer these queries: they unnecessarily consume CPU resources and network bandwidth. A possible solution is to delegate these numeric TLDs from the root zone to a separate set of servers to absorb the traffic. The \"black hole servers\" used by the AS 112 Project (http://www.as112.net), which are currently delegated the in-addr.arpa zones corresponding to RFC 1918 [7] private use address space, would be a possible choice to receive these delegations. Of course, the proper and usual root zone change procedures would have to be followed to make such a change to the root zone.",
      "ja": "ルート名サーバーがこれらのクエリに答える必要がないことが望ましいでしょう。彼らは不必要にCPUリソースとネットワーク帯域幅を消費します。可能な解決策は、これらの数値TLDをルートゾーンから個別のサーバーのセットに委任して、トラフィックを吸収することです。AS 112プロジェクト（http://www.as112.net）が現在使用している「ブラックホールサーバー」は、現在RFC 1918 [7]に対応するIn-ddr.arpaゾーンを委任されています。これらの代表団を受け取るための選択肢。もちろん、ルートゾーンにこのような変更を加えるために、適切かつ通常のルートゾーンの変更手順に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "2.10. Misdirected Recursive Queries",
      "section_title": true,
      "ja": "2.10. 誤った方向の再帰クエリ"
    },
    {
      "indent": 3,
      "text": "The root name servers receive a significant number of recursive queries (i.e., queries with the Recursion Desired (RD) bit set in the header). Since none of the root servers offers recursion, the servers' response in such a situation ignores the request for recursion and the response probably does not contain the data the querier anticipated. Some of these queries result from users configuring stub resolvers to query a root server. (This situation is not hypothetical: we have received complaints from users when this configuration does not work as hoped.) Of course, users should not direct stub resolvers to use name servers that do not offer recursion, but we are not aware of any stub resolver implementation that offers any feedback to the user when so configured, aside from simply \"not working\".",
      "ja": "ルート名サーバーは、かなりの数の再帰クエリを受け取ります（つまり、ヘッダーに設定された再帰（RD）ビットを使用してクエリ）。ルートサーバーはいずれも再帰を提供していないため、このような状況でのサーバーの応答は再帰の要求を無視し、応答にはおそらくクエリエが予想したデータは含まれていません。これらのクエリの一部は、ルートサーバーを照会するためにスタブリゾルバーを構成するユーザーから生じます。（この状況は仮説的ではありません。この構成が期待どおりに機能しない場合、ユーザーから苦情を受け取りました。）もちろん、ユーザーは再帰を提供しない名前サーバーを使用するようにスタブリゾルバーを指示するべきではありませんが、スタブを認識していません単に「動作しない」ことを除いて、そのように構成されたときにユーザーにフィードバックを提供するリゾルバーの実装。"
    },
    {
      "indent": 0,
      "text": "2.10.1. Recommendation",
      "section_title": true,
      "ja": "2.10.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "When the IP address of a name server that supposedly offers recursion is configured in a stub resolver using an interactive user interface, the resolver could send a test query to verify that the server indeed supports recursion (i.e., verify that the response has the RA bit set in the header). The user could be notified immediately if the server is non-recursive.",
      "ja": "再帰を提供する名前サーバーのIPアドレスがインタラクティブユーザーインターフェイスを使用してスタブリゾルバーで構成されていると思われる場合、リゾルバーはテストクエリを送信して、サーバーが実際に再帰をサポートしていることを確認できます（つまり、応答がRAビットがあることを確認しますヘッダーに設定）。サーバーが再回されている場合、ユーザーはすぐに通知される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The stub resolver could also report an error, either through a user interface or in a log file, if the queried server does not support recursion. Error reporting SHOULD be throttled to avoid a notification or log message for every response from a non-recursive server.",
      "ja": "Stub Resolverは、クエリサーバーが再帰をサポートしていない場合、ユーザーインターフェイスまたはログファイルのいずれかを介してエラーを報告することもできます。非回復的なサーバーからのすべての応答の通知またはログメッセージを回避するために、エラーレポートを調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.11. Suboptimal Name Server Selection Algorithm",
      "section_title": true,
      "ja": "2.11. サブオプティマルネームサーバー選択アルゴリズム"
    },
    {
      "indent": 3,
      "text": "An entire document could be devoted to the topic of problems with different implementations of the recursive resolution algorithm. The entire process of recursion is woefully under-specified, requiring each implementor to design an algorithm. Sometimes implementors make poor design choices that could be avoided if a suggested algorithm and best practices were documented, but that is a topic for another document.",
      "ja": "ドキュメント全体は、再帰解像度アルゴリズムのさまざまな実装を伴う問題のトピックに専念できます。再帰のプロセス全体がひどく不足しているため、各実装者にアルゴリズムを設計する必要があります。実装者は、提案されたアルゴリズムとベストプラクティスが文書化された場合に回避できるデザインの選択が不十分な場合がありますが、それは別のドキュメントのトピックです。"
    },
    {
      "indent": 3,
      "text": "Some deficiencies cause significant operational impact and are therefore worth mentioning here. One of these is name server selection by an iterative resolver. When an iterative resolver wants to contact one of a zone's authoritative name servers, how does it choose from the NS records listed in the zone's NS RRSet? If the selection mechanism is suboptimal, queries are not spread evenly among a zone's authoritative servers. The details of the selection mechanism are up to the implementor, but we offer some suggestions.",
      "ja": "いくつかの欠陥は重要な運用上の影響を引き起こすため、ここで言及する価値があります。これらの1つは、反復リゾルバーによる名前サーバーの選択です。反復リゾルバーがゾーンの権威ある名前サーバーの1つに連絡したい場合、ゾーンのNS RRSetにリストされているNSレコードからどのように選択しますか？選択メカニズムが最適ではない場合、クエリはゾーンの権威あるサーバーの間に均等に拡張されません。選択メカニズムの詳細は実装者次第ですが、いくつかの提案を提供します。"
    },
    {
      "indent": 0,
      "text": "2.11.1. Recommendation",
      "section_title": true,
      "ja": "2.11.1. おすすめ"
    },
    {
      "indent": 3,
      "text": "This list is not conclusive, but reflects the changes that would produce the most impact in terms of reducing disproportionate query load among a zone's authoritative servers. That is, these changes would help spread the query load evenly.",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o Do not make assumptions based on NS RRSet order: all NS RRs SHOULD be treated equally. (In the case of the \"com\" zone, for example, most of the root servers return the NS record for \"a.gtld-servers.net\" first in the authority section of referrals. Apparently as a result, this server receives disproportionately more traffic than the other twelve authoritative servers for \"com\".)",
      "ja": "o NS RRSET順序に基づいて仮定をしないでください：すべてのNS RRは均等に扱う必要があります。（たとえば、「com」ゾーンの場合、ほとんどのルートサーバーは、紹介の権限セクションで最初に「a.gtld-servers.net」のNSレコードを返します。明らかに、このサーバーは不釣り合いに受け取るようです「com」の他の12の権威あるサーバーよりも多くのトラフィック。）"
    },
    {
      "indent": 3,
      "text": "o Use all NS records in an RRSet. (For example, we are aware of implementations that hard-coded information for a subset of the root servers.)",
      "ja": "o RRSetですべてのNSレコードを使用します。（たとえば、ルートサーバーのサブセットのハードコーディング情報の実装を認識しています。）"
    },
    {
      "indent": 3,
      "text": "o Maintain state and favor the best-performing of a zone's authoritative servers. A good definition of performance is response time. Non-responsive servers can be penalized with an extremely high response time.",
      "ja": "o 状態を維持し、ゾーンの権威あるサーバーの最良のパフォーマンスを支持します。パフォーマンスの適切な定義は、応答時間です。反応しないサーバーは、非常に高い応答時間でペナルティを受けることができます。"
    },
    {
      "indent": 3,
      "text": "o Do not lock onto the best-performing of a zone's name servers. An iterative resolver SHOULD periodically check the performance of all of a zone's name servers to adjust its determination of the best-performing one.",
      "ja": "o ゾーンの名前サーバーの最高のパフォーマンスをロックしないでください。反復的なリゾルバーは、すべてのゾーンの名前サーバーのパフォーマンスを定期的にチェックして、最高のパフォーマンスのあるものの決定を調整する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The iterative resolver misbehavior discussed in this document exposes the root and TLD name servers to increased risk of both intentional and unintentional Denial of Service attacks.",
      "ja": "このドキュメントで議論されている反復的なリゾルバーの不正行為は、ルートとTLDのネームサーバーを、意図的および意図的でないサービス拒否攻撃の両方のリスクを高めるために公開します。"
    },
    {
      "indent": 3,
      "text": "We believe that implementation of the recommendations offered in this document will reduce the amount of unnecessary traffic seen at root and TLD name servers, thus reducing the opportunity for an attacker to use such queries to his or her advantage.",
      "ja": "このドキュメントで提供される推奨事項の実装により、RootおよびTLDネームサーバーで見られる不必要なトラフィックの量が減り、攻撃者がそのようなクエリを有利に使用する機会を減らすと考えています。"
    },
    {
      "indent": 0,
      "text": "4. Acknowledgements",
      "section_title": true,
      "ja": "4. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the following people for their comments that improved this document: Andras Salamon, Dave Meyer, Doug Barton, Jaap Akkerhuis, Jinmei Tatuya, John Brady, Kevin Darcy, Olafur Gudmundsson, Pekka Savola, Peter Koch, and Rob Austein. We apologize if we have omitted anyone; any oversight was unintentional.",
      "ja": "。誰かを省略した場合はお詫び申し上げます。監視は意図的ではありませんでした。"
    },
    {
      "indent": 0,
      "text": "5. Internationalization Considerations",
      "section_title": true,
      "ja": "5. 国際化の考慮事項"
    },
    {
      "indent": 3,
      "text": "There are no new internationalization considerations introduced by this memo.",
      "ja": "このメモによって導入された新しい国際化に関する考慮事項はありません。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[1] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[2] Mockapetris, P., \"Domain names - concepts and facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[2] Mockapetris、P。、「ドメイン名 - 概念と施設」、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[3] Elz, R. and R. Bush, \"Clarifications to the DNS Specification\", RFC 2181, July 1997.",
      "ja": "[3] Elz、R。、およびR. Bush、「DNS仕様の説明」、RFC 2181、1997年7月。"
    },
    {
      "indent": 3,
      "text": "[4] Andrews, M., \"Negative Caching of DNS Queries (DNS NCACHE)\", RFC 2308, March 1998.",
      "ja": "[4] Andrews、M。、「DNSクエリのネガティブキャッシュ（DNS ncache）」、RFC 2308、1998年3月。"
    },
    {
      "indent": 3,
      "text": "[5] Morishita, Y. and T. Jinmei, \"Common Misbehavior Against DNS Queries for IPv6 Addresses\", RFC 4074, May 2005.",
      "ja": "[5] Morishita、Y。およびT. Jinmei、「IPv6アドレスのDNSクエリに対する一般的な不正行為」、RFC 4074、2005年5月。"
    },
    {
      "indent": 3,
      "text": "[6] Vixie, P., Thomson, S., Rekhter, Y., and J. Bound, \"Dynamic Updates in the Domain Name System (DNS UPDATE)\", RFC 2136, April 1997.",
      "ja": "[6] Vixie、P.、Thomson、S.、Rekhter、Y。、およびJ. Bound、「ドメイン名システムの動的更新（DNSアップデート）」、RFC 2136、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[7] Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[7] Rekhter、Y.、Moskowitz、B.、Karrenberg、D.、De Groot、G。、およびE. Lear、「Private Internetsのアドレス割り当て」、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Matt Larson VeriSign, Inc. 21345 Ridgetop Circle Dulles, VA 20166-6503 USA",
      "ja": "Matt Larson Verisign、Inc。21345 Ridgetop Circle Dulles、VA 20166-6503 USA"
    },
    {
      "indent": 3,
      "text": "EMail: mlarson@verisign.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Piet Barber VeriSign, Inc. 21345 Ridgetop Circle Dulles, VA 20166-6503 USA",
      "ja": "Piet Barber Verisign、Inc。21345 Ridgetop Circle Dulles、VA 20166-6503 USA"
    },
    {
      "indent": 3,
      "text": "EMail: pbarber@verisign.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}