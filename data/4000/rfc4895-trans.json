{
  "title": {
    "text": "RFC 4895 - Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)",
    "ja": "RFC 4895 - ストリーム制御伝送プロトコル（SCTP）の認証チャンク"
  },
  "number": 4895,
  "created_at": "2023-05-17 15:17:53.182793+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Tuexen\nRequest for Comments: 4895            Muenster Univ. of Applied Sciences\nCategory: Standards Track                                     R. Stewart\n                                                                  P. Lei\n                                                     Cisco Systems, Inc.\n                                                             E. Rescorla\n                                                              RTFM, Inc.\n                                                             August 2007",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": " Authenticated Chunks for the Stream Control Transmission Protocol (SCTP)",
      "ja": "ストリーム制御伝送プロトコル（SCTP）の認証チャンク"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a new chunk type, several parameters, and procedures for the Stream Control Transmission Protocol (SCTP). This new chunk type can be used to authenticate SCTP chunks by using shared keys between the sender and receiver. The new parameters are used to establish the shared keys.",
      "ja": "このドキュメントでは、新しいチャンクタイプ、いくつかのパラメーター、およびストリーム制御伝送プロトコル（SCTP）の手順について説明します。この新しいチャンクタイプは、送信者と受信機の間で共有キーを使用してSCTPチャンクを認証するために使用できます。新しいパラメーターは、共有キーを確立するために使用されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Conventions  . . . . . . . . . . . . . . . . . . . . . . . . .  3\n3.  New Parameter Types  . . . . . . . . . . . . . . . . . . . . .  4\n  3.1.  Random Parameter (RANDOM)  . . . . . . . . . . . . . . . .  4\n  3.2.  Chunk List Parameter (CHUNKS)  . . . . . . . . . . . . . .  5\n  3.3.  Requested HMAC Algorithm Parameter (HMAC-ALGO) . . . . . .  6\n4.  New Error Cause  . . . . . . . . . . . . . . . . . . . . . . .  7\n  4.1.  Unsupported HMAC Identifier Error Cause  . . . . . . . . .  7\n5.  New Chunk Type . . . . . . . . . . . . . . . . . . . . . . . .  8\n  5.1.  Authentication Chunk (AUTH)  . . . . . . . . . . . . . . .  8\n6.  Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . 10\n  6.1.  Establishment of an Association Shared Key . . . . . . . . 10\n  6.2.  Sending Authenticated Chunks . . . . . . . . . . . . . . . 11\n  6.3.  Receiving Authenticated Chunks . . . . . . . . . . . . . . 12\n7.  Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . 14\n8.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 15\n  8.1.  A New Chunk Type . . . . . . . . . . . . . . . . . . . . . 15\n  8.2.  Three New Parameter Types  . . . . . . . . . . . . . . . . 15\n  8.3.  A New Error Cause  . . . . . . . . . . . . . . . . . . . . 15\n  8.4.  A New Table for HMAC Identifiers . . . . . . . . . . . . . 16\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16\n10. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 17\n11. Normative References . . . . . . . . . . . . . . . . . . . . . 17",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "SCTP uses 32-bit verification tags to protect itself against blind attackers. These values are not changed during the lifetime of an SCTP association.",
      "ja": "SCTPは、32ビット検証タグを使用して、ブラインド攻撃者から身を守ります。これらの値は、SCTP協会の存続期間中に変更されません。"
    },
    {
      "indent": 3,
      "text": "Looking at new SCTP extensions, there is the need to have a method of proving that an SCTP chunk(s) was really sent by the original peer that started the association and not by a malicious attacker.",
      "ja": "新しいSCTP拡張機能を見ると、悪意のある攻撃者ではなく、協会を開始した元のピアからSCTPチャンクが実際に送信されたことを証明する方法が必要です。"
    },
    {
      "indent": 3,
      "text": "Using Transport Layer Security (TLS), as defined in RFC 3436 [6], does not help because it only secures SCTP user data.",
      "ja": "RFC 3436 [6]で定義されているように、トランスポートレイヤーセキュリティ（TLS）を使用して、SCTPユーザーデータのみを保護するため、役に立ちません。"
    },
    {
      "indent": 3,
      "text": "Therefore, an SCTP extension that provides a mechanism for deriving shared keys for each association is presented. These association shared keys are derived from endpoint pair shared keys, which are configured and might be empty, and data that is exchanged during the SCTP association setup.",
      "ja": "したがって、各アソシエーションの共有キーを導出するためのメカニズムを提供するSCTP拡張が提示されます。これらのアソシエーション共有キーは、エンドポイントペア共有キーから派生しており、構成されている可能性があり、空になる可能性があり、SCTP Associationのセットアップ中に交換されます。"
    },
    {
      "indent": 3,
      "text": "The extension presented in this document allows an SCTP sender to authenticate chunks using shared keys between the sender and receiver. The receiver can then verify that the chunks are sent from the sender and not from a malicious attacker (as long as the attacker does not know an association shared key).",
      "ja": "このドキュメントに示されている拡張機能により、SCTP送信者は、送信者と受信機の間の共有キーを使用してチャンクを認証できます。その後、受信者は、攻撃者が関連性の共有キーを知らない限り、悪意のある攻撃者からではなく、送信者からチャンクが送信されていることを確認できます。"
    },
    {
      "indent": 3,
      "text": "The extension described in this document places the result of a Hashed Message Authentication Code (HMAC) computation before the data covered by that computation. Placing it at the end of the packet would have required placing a control chunk after DATA chunks in case of authenticating DATA chunks. This would break the rule that control chunks occur before DATA chunks in SCTP packets. It should also be noted that putting the result of the HMAC computation after the data being covered would not allow sending the packet during the computation of the HMAC because the result of the HMAC computation is needed to compute the CRC32C checksum of the SCTP packet, which is placed in the common header of the SCTP packet.",
      "ja": "このドキュメントで説明されている拡張機能は、その計算でカバーされるデータの前に、ハッシュされたメッセージ認証コード（HMAC）計算の結果を配置します。パケットの最後に配置すると、データチャンクを認証する場合にデータチャンクの後にコントロールチャンクを配置する必要がありました。これにより、SCTPパケットのデータチャンクの前に制御チャンクが発生するというルールが破られます。また、HMAC計算の結果をCRC32Cチェックサムを計算するためにHMAC計算の結果を計算するために必要であるため、データがカバーされた後にHMAC計算の結果をHMACの計算中にパケットの送信を許可しないことに注意してください。SCTPパケットの共通ヘッダーに配置されます。"
    },
    {
      "indent": 3,
      "text": "The SCTP extension for Dynamic Address Reconfiguration (ADD-IP) requires the usage of the extension described in this document. The SCTP Partial Reliability Extension (PR-SCTP) can be used in conjunction with the extension described in this document.",
      "ja": "動的アドレス再構成（ADD-IP）のSCTP拡張には、このドキュメントで説明されている拡張機能の使用が必要です。SCTP部分信頼性拡張（PR-SCTP）は、このドキュメントで説明されている拡張機能と組み合わせて使用できます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions",
      "section_title": true,
      "ja": "2. 規約"
    },
    {
      "indent": 3,
      "text": "The keywords \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\", when they appear in this document, are to be interpreted as described in RFC 2119 [3].",
      "ja": "キーワードは「必要」、「必要」、「必要」、「shall」、「shall \"、\" sulld \"、\" not \"、\" becommented \"、\" becommented \"、\" may \"、\" optional \"、これらがこの文書に登場する場合、RFC 2119 [3]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. New Parameter Types",
      "section_title": true,
      "ja": "3. 新しいパラメータータイプ"
    },
    {
      "indent": 3,
      "text": "This section defines the new parameter types that will be used to negotiate the authentication during association setup. Table 1 illustrates the new parameter types.",
      "ja": "このセクションでは、関連付けのセットアップ中に認証をネゴシエートするために使用される新しいパラメータータイプを定義します。表1に、新しいパラメータータイプを示しています。"
    },
    {
      "indent": 4,
      "text": "+----------------+------------------------------------------------+\n| Parameter Type | Parameter Name                                 |\n+----------------+------------------------------------------------+\n| 0x8002         | Random Parameter (RANDOM)                      |\n| 0x8003         | Chunk List Parameter (CHUNKS)                  |\n| 0x8004         | Requested HMAC Algorithm Parameter (HMAC-ALGO) |\n+----------------+------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 3,
      "text": "Note that the parameter format requires the receiver to ignore the parameter and continue processing if the parameter is not understood. This is accomplished (as described in RFC 2960 [5], Section 3.2.1.) by the use of the upper bits of the parameter type.",
      "ja": "パラメーター形式では、パラメーターを無視し、パラメーターが理解されていない場合は処理を継続する必要があることに注意してください。これは、パラメータータイプの上部ビットを使用することにより、RFC 2960 [5]、セクション3.2.1。）に記載されているように（）達成されます。"
    },
    {
      "indent": 0,
      "text": "3.1. Random Parameter (RANDOM)",
      "section_title": true,
      "ja": "3.1. ランダムパラメーター（ランダム）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to carry a random number of an arbitrary length.",
      "ja": "このパラメーターは、任意の長さの乱数を運ぶために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8002   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                          Random Number                        /\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8002.",
      "ja": "パラメータータイプ：2バイト（符号なし整数）この値は0x8002に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the length of the Random Number in bytes plus 4.",
      "ja": "パラメーターの長さ：2バイト（符号なし整数）この値は、バイトと4の乱数の長さです。"
    },
    {
      "indent": 3,
      "text": "Random Number: n bytes (unsigned integer) This value represents an arbitrary Random Number in network byte order.",
      "ja": "乱数：nバイト（符号なし整数）この値は、ネットワークバイト順序の任意の乱数を表します。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the length of the Random Number is not a multiple of 4 bytes, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "パディング：0、1、2、または3バイト（符号なし整数）乱数の長さが4バイトの倍数ではない場合、送信者はパラメーターをすべてゼロバイトでパラメーターにパッドにパッドして、パラメーター32ビットをアライメントする必要があります。パディングは3バイトを超えてはならず、受信機は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The RANDOM parameter MUST be included once in the INIT or INIT-ACK chunk, if the sender wants to send or receive authenticated chunks, to provide a 32-byte Random Number. For 32-byte Random Numbers, the Padding is empty.",
      "ja": "32バイトの乱数を提供するために、送信者が認証されたチャンクを送信または受信したい場合は、ランダムパラメーターをinitまたはinit-ackチャンクに1回含める必要があります。32バイトの乱数の場合、パディングは空です。"
    },
    {
      "indent": 0,
      "text": "3.2. Chunk List Parameter (CHUNKS)",
      "section_title": true,
      "ja": "3.2. チャンクリストパラメーター（チャンク）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to specify which chunk types are required to be authenticated before being sent by the peer.",
      "ja": "このパラメーターは、ピアから送信される前に、どのチャンクタイプを認証する必要があるかを指定するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8003   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type 1  | Chunk Type 2  | Chunk Type 3  | Chunk Type 4  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Chunk Type n  |                   Padding                     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8003.",
      "ja": "パラメータータイプ：2バイト（符号なし整数）この値は0x8003に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the number of listed Chunk Types plus 4.",
      "ja": "パラメーターの長さ：2バイト（符号なし整数）この値は、リストされているチャンクタイプと4の数です。"
    },
    {
      "indent": 3,
      "text": "Chunk Type n: 1 byte (unsigned integer) Each Chunk Type listed is required to be authenticated when sent by the peer.",
      "ja": "チャンクタイプN：1バイト（符号なし整数）リストされている各チャンクタイプは、ピアから送信されたときに認証される必要があります。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the number of Chunk Types is not a multiple of 4, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "パディング：0、1、2、または3バイト（符号なし整数）チャンクタイプの数が4の倍数ではない場合、送信者はパラメーターをすべてゼロバイトでパラメーターにパッドにパッドにパッドにパッドにパッドにパッドにパッドにしなければなりません。パディングは3バイトを超えてはならず、受信機は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The CHUNKS parameter MUST be included once in the INIT or INIT-ACK chunk if the sender wants to receive authenticated chunks. Its maximum length is 260 bytes.",
      "ja": "送信者が認証されたチャンクを受信したい場合は、Chunksパラメーターをinitまたはinit-ackチャンクに一度含める必要があります。その最大長は260バイトです。"
    },
    {
      "indent": 3,
      "text": "The chunk types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH chunks MUST NOT be listed in the CHUNKS parameter. However, if a CHUNKS parameter is received then the types for INIT, INIT-ACK, SHUTDOWN-COMPLETE, and AUTH chunks MUST be ignored.",
      "ja": "init、init-ack、shutdown-complete、およびauthチャンクのチャンクタイプをチャンクパラメーターにリストしてはなりません。ただし、チャンクパラメーターを受信した場合、init、init-ack、shutdown-complete、およびauthチャンクのタイプを無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Requested HMAC Algorithm Parameter (HMAC-ALGO)",
      "section_title": true,
      "ja": "3.3. 要求されたHMACアルゴリズムパラメーター（HMAC-Algo）"
    },
    {
      "indent": 3,
      "text": "This parameter is used to list the HMAC Identifiers the peer MUST use.",
      "ja": "このパラメーターは、ピアが使用する必要があるHMAC識別子をリストするために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Parameter Type = 0x8004   |       Parameter Length        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|          HMAC Identifier 1    |      HMAC Identifier 2        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n/                                                               /\n\\                              ...                              \\\n/                                                               /\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        HMAC Identifier n      |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "Parameter Type: 2 bytes (unsigned integer) This value MUST be set to 0x8004.",
      "ja": "パラメータータイプ：2バイト（符号なし整数）この値は0x8004に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Parameter Length: 2 bytes (unsigned integer) This value is the number of HMAC Identifiers multiplied by 2, plus 4.",
      "ja": "パラメーターの長さ：2バイト（符号なし整数）この値は、2を掛けたHMAC識別子の数と4を掛けたものです。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier n: 2 bytes (unsigned integer) The values expressed are a list of HMAC Identifiers that may be used by the peer. The values are listed by preference, with respect to the sender, where the first HMAC Identifier listed is the one most preferable to the sender.",
      "ja": "HMAC識別子n：2バイト（符号なし整数）表現された値は、ピアが使用できるHMAC識別子のリストです。値は、送信者に対して優先的にリストされ、最初にリストされているHMAC識別子が送信者にとって最も望ましいものです。"
    },
    {
      "indent": 3,
      "text": "Padding: 0 or 2 bytes (unsigned integer) If the number of HMAC Identifiers is not even, the sender MUST pad the parameter with all zero bytes to make the parameter 32-bit aligned. The Padding MUST be 0 or 2 bytes long and it MUST be ignored by the receiver.",
      "ja": "パディング：0または2バイト（符号なし整数）HMAC識別子の数が偶数でない場合、送信者はパラメーターをすべてゼロバイトでパラメータにパッドにパッドにパッドにパッドにパッドにパッドにパッドにパッドを付けなければなりません。パディングは0または2バイトの長さでなければならず、受信機は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The HMAC-ALGO parameter MUST be included once in the INIT or INIT-ACK chunk if the sender wants to send or receive authenticated chunks.",
      "ja": "送信者が認証されたチャンクを送信または受信したい場合は、HMAC-Algoパラメーターをinitまたはinit-ackチャンクに1回含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Table 2 shows the currently defined values for HMAC Identifiers.",
      "ja": "表2は、HMAC識別子の現在定義されている値を示しています。"
    },
    {
      "indent": 14,
      "text": "+-----------------+--------------------------+\n| HMAC Identifier | Message Digest Algorithm |\n+-----------------+--------------------------+\n| 0               | Reserved                 |\n| 1               | SHA-1 defined in [8]     |\n| 2               | Reserved                 |\n| 3               | SHA-256 defined in [8]   |\n+-----------------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 3,
      "text": "Every endpoint supporting SCTP chunk authentication MUST support the HMAC based on the SHA-1 algorithm.",
      "ja": "SCTPチャンク認証をサポートするすべてのエンドポイントは、SHA-1アルゴリズムに基づいてHMACをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "4. New Error Cause",
      "section_title": true,
      "ja": "4. 新しいエラー原因"
    },
    {
      "indent": 3,
      "text": "This section defines a new error cause that will be sent if an AUTH chunk is received with an unsupported HMAC Identifier. Table 3 illustrates the new error cause.",
      "ja": "このセクションでは、サポートされていないHMAC識別子で認証チャンクが受信された場合に送信される新しいエラー原因を定義します。表3は、新しいエラー原因を示しています。"
    },
    {
      "indent": 15,
      "text": "+------------+-----------------------------+\n| Cause Code | Error Cause Name            |\n+------------+-----------------------------+\n| 0x0105     | Unsupported HMAC Identifier |\n+------------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 3",
      "ja": "表3"
    },
    {
      "indent": 0,
      "text": "4.1. Unsupported HMAC Identifier Error Cause",
      "section_title": true,
      "ja": "4.1. サポートされていないHMAC識別子エラー原因"
    },
    {
      "indent": 3,
      "text": "This error cause is used to indicate that an AUTH chunk has been received with an unsupported HMAC Identifier.",
      "ja": "このエラー原因は、サポートされていないHMAC識別子で認証チャンクが受信されたことを示すために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Cause Code = 0x0105      |       Cause Length = 6        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         HMAC Identifier       |            Padding            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Cause Code: 2 bytes (unsigned integer) This value MUST be set to 0x0105.",
      "ja": "原因コード：2バイト（符号なし整数）この値は0x0105に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Cause Length: 2 bytes (unsigned integer) This value MUST be set to 6.",
      "ja": "原因の長さ：2バイト（符号なし整数）この値は6に設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier: 2 bytes (unsigned integer) This value is the HMAC Identifier which is not supported.",
      "ja": "HMAC識別子：2バイト（符号なし整数）この値は、サポートされていないHMAC識別子です。"
    },
    {
      "indent": 3,
      "text": "Padding: 2 bytes (unsigned integer) The sender MUST pad the error cause with all zero bytes to make the cause 32-bit aligned. The Padding MUST be 2 bytes long and it MUST be ignored by the receiver.",
      "ja": "パディング：2バイト（符号なし整数）送信者は、すべてのゼロバイトでエラー原因をパッドにパッドにして、原因を32ビットに合わせる必要があります。パディングは2バイトの長さでなければならず、受信機は無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. New Chunk Type",
      "section_title": true,
      "ja": "5. 新しいチャンクタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines the new chunk type that will be used to authenticate chunks. Table 4 illustrates the new chunk type.",
      "ja": "このセクションでは、チャンクの認証に使用される新しいチャンクタイプを定義します。表4は、新しいチャンクタイプを示しています。"
    },
    {
      "indent": 15,
      "text": "+------------+-----------------------------+\n| Chunk Type | Chunk Name                  |\n+------------+-----------------------------+\n| 0x0F       | Authentication Chunk (AUTH) |\n+------------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 34,
      "text": "Table 4",
      "ja": "表4"
    },
    {
      "indent": 3,
      "text": "It should be noted that the AUTH-chunk format requires the receiver to ignore the chunk if it is not understood and silently discard all chunks that follow. This is accomplished (as described in RFC 2960 [5], Section 3.2.) by the use of the upper bits of the chunk type.",
      "ja": "Auth-Chunk形式では、理解されていない場合はレシーバーがチャンクを無視し、続くすべてのチャンクを静かに破棄する必要があることに注意する必要があります。これは、チャンクタイプの上部ビットを使用することにより、RFC 2960 [5]、セクション3.2。）で説明されています。"
    },
    {
      "indent": 0,
      "text": "5.1. Authentication Chunk (AUTH)",
      "section_title": true,
      "ja": "5.1. 認証チャンク（auth）"
    },
    {
      "indent": 3,
      "text": "This chunk is used to hold the result of the HMAC calculation.",
      "ja": "このチャンクは、HMAC計算の結果を保持するために使用されます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type = 0x0F   |   Flags=0     |             Length            |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Shared Key Identifier      |        HMAC Identifier        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                             HMAC                              /\n/                                                               \\\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 5",
      "ja": "図5"
    },
    {
      "indent": 3,
      "text": "Type: 1 byte (unsigned integer) This value MUST be set to 0x0F for all AUTH-chunks.",
      "ja": "タイプ：1バイト（符号なし整数）この値は、すべての認証チャンクで0x0Fに設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Flags: 1 byte (unsigned integer) SHOULD be set to zero on transmit and MUST be ignored on receipt.",
      "ja": "フラグ：1バイト（符号なし整数）は、送信時にゼロに設定する必要があり、受領時に無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Length: 2 bytes (unsigned integer) This value holds the length of the HMAC in bytes plus 8.",
      "ja": "長さ：2バイト（符号なし整数）この値は、HMACの長さをバイトと8に保持します。"
    },
    {
      "indent": 3,
      "text": "Shared Key Identifier: 2 bytes (unsigned integer) This value describes which endpoint pair shared key is used.",
      "ja": "共有キー識別子：2バイト（符号なし整数）この値は、どのエンドポイントペア共有キーが使用されるかを説明しています。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier: 2 bytes (unsigned integer) This value describes which message digest is being used. Table 2 shows the currently defined values.",
      "ja": "HMAC識別子：2バイト（符号なし整数）この値は、どのメッセージが使用されているかを説明しています。表2は、現在定義されている値を示しています。"
    },
    {
      "indent": 3,
      "text": "HMAC: n bytes (unsigned integer) This holds the result of the HMAC calculation.",
      "ja": "HMAC：nバイト（符号なし整数）これは、HMAC計算の結果を保持します。"
    },
    {
      "indent": 3,
      "text": "Padding: 0, 1, 2, or 3 bytes (unsigned integer) If the length of the HMAC is not a multiple of 4 bytes, the sender MUST pad the chunk with all zero bytes to make the chunk 32-bit aligned. The Padding MUST NOT be longer than 3 bytes and it MUST be ignored by the receiver.",
      "ja": "パディング：0、1、2、または3バイト（符号なし整数）HMACの長さが4バイトの倍数ではない場合、送信者はすべてのゼロバイトでチャンクをパッドに埋めて、チャンク32ビットを整列させる必要があります。パディングは3バイトを超えてはならず、受信機は無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "The control chunk AUTH MUST NOT appear more than once in an SCTP packet. All control and data chunks that are placed after the AUTH chunk in the packet are sent in an authenticated way. Those chunks placed in a packet before the AUTH chunk are not authenticated. Please note that DATA chunks can not appear before control chunks in an SCTP packet.",
      "ja": "Control Chunk Authは、SCTPパケットに1回以上表示されてはなりません。パケットの認証チャンク後に配置されたすべてのコントロールおよびデータチャンクは、認証された方法で送信されます。認証チャンクの前にパケットに配置されたこれらのチャンクは認証されていません。SCTPパケットでチャンクを制御する前に、データチャンクが表示されないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "6. Procedures",
      "section_title": true,
      "ja": "6. 手順"
    },
    {
      "indent": 0,
      "text": "6.1. Establishment of an Association Shared Key",
      "section_title": true,
      "ja": "6.1. 協会の共有キーの確立"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint willing to receive or send authenticated chunks MUST send one RANDOM parameter in its INIT or INIT-ACK chunk. The RANDOM parameter MUST contain a 32-byte Random Number. The Random Number should be generated in accordance with RFC 4086 [7]. If the Random Number is not 32 bytes, the association MUST be aborted. The ABORT chunk SHOULD contain the error cause 'Protocol Violation'. In case of INIT collision, the rules governing the handling of this Random Number follow the same pattern as those for the Verification Tag, as explained in Section 5.2.4 of RFC 2960 [5]. Therefore, each endpoint knows its own Random Number and the peer's Random Number after the association has been established.",
      "ja": "認証されたチャンクを受け取るか送信するSCTPエンドポイントは、そのinitまたはinit-ackチャンクに1つのランダムパラメーターを送信する必要があります。ランダムパラメーターには、32バイトの乱数を含める必要があります。乱数は、RFC 4086 [7]に従って生成する必要があります。乱数が32バイトでない場合、関連付けを中止する必要があります。中止チャンクには、エラー原因「プロトコル違反」が含まれている必要があります。INIT衝突の場合、この乱数の取り扱いを管理する規則は、RFC 2960のセクション5.2.4 [5]で説明されているように、検証タグのパターンと同じパターンに従います。したがって、各エンドポイントは、関連性が確立された後の独自の乱数とピアの乱数を知っています。"
    },
    {
      "indent": 3,
      "text": "An SCTP endpoint has a list of chunks it only accepts if they are received in an authenticated way. This list is included in the INIT and INIT-ACK, and MAY be omitted if it is empty. Since this list does not change during the lifetime of the SCTP endpoint there is no problem in case of INIT collision.",
      "ja": "SCTPエンドポイントには、認証された方法で受信された場合にのみ受け入れるチャンクのリストがあります。このリストはinitとinit-ackに含まれており、空の場合は省略できます。このリストはSCTPエンドポイントの存続期間中に変更されないため、INIT衝突の場合に問題はありません。"
    },
    {
      "indent": 3,
      "text": "Each SCTP endpoint MUST include in the INIT and INIT-ACK a HMAC-ALGO parameter containing a list of HMAC Identifiers it requests the peer to use. The receiver of an HMAC-ALGO parameter SHOULD use the first listed algorithm it supports. The HMAC algorithm based on SHA-1 MUST be supported and included in the HMAC-ALGO parameter. An SCTP endpoint MUST NOT change the parameters listed in the HMAC-ALGO parameter during the lifetime of the endpoint.",
      "ja": "各SCTPエンドポイントは、initに含まれ、ピアに使用するように要求するHMAC識別子のリストを含むhmac-algoパラメーターをinit-ackする必要があります。HMAC-Algoパラメーターの受信機は、サポートする最初のリストされたアルゴリズムを使用する必要があります。SHA-1に基づくHMACアルゴリズムをサポートし、HMAC-Algoパラメーターに含める必要があります。SCTPエンドポイントは、エンドポイントの寿命の間にHMAC-Algoパラメーターにリストされているパラメーターを変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "Both endpoints of an association MAY have endpoint pair shared keys that are byte vectors and pre-configured or established by another mechanism. They are identified by the Shared Key Identifier. For each endpoint pair shared key, an association shared key is computed. If there is no endpoint pair shared key, only one association shared key is computed by using an empty byte vector as the endpoint pair shared key.",
      "ja": "関連付けの両方のエンドポイントには、バイトベクトルであり、別のメカニズムによって事前に構成または確立されたエンドポイントペア共有キーがある場合があります。それらは、共有キー識別子によって識別されます。各エンドポイントペアの共有キーについて、アソシエーション共有キーが計算されます。エンドポイントペア共有キーがない場合、エンドポイントペア共有キーとして空のバイトベクトルを使用して、1つのアソシエーション共有キーのみが計算されます。"
    },
    {
      "indent": 3,
      "text": "The RANDOM parameter, the CHUNKS parameter, and the HMAC-ALGO parameter sent by each endpoint are concatenated as byte vectors. These parameters include the parameter type, parameter length, and the parameter value, but padding is omitted; all padding MUST be removed from this concatenation before proceeding with further computation of keys. Parameters that were not sent are simply omitted from the concatenation process. The resulting two vectors are called the two key vectors.",
      "ja": "ランダムパラメーター、チャンクパラメーター、および各エンドポイントで送信されたHMAC-Algoパラメーターは、バイトベクトルとして連結されています。これらのパラメーターには、パラメータータイプ、パラメーターの長さ、およびパラメーター値が含まれますが、パディングは省略されています。キーのさらなる計算を進める前に、すべてのパディングをこの連結から削除する必要があります。送信されなかったパラメーターは、連結プロセスから単純に省略されます。結果の2つのベクトルは、2つの重要なベクトルと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "From the endpoint pair shared keys and the key vectors, the association shared keys are computed. This is performed by selecting the numerically smaller key vector and concatenating it to the endpoint pair shared key, and then concatenating the numerically larger key vector to that. If the key vectors are equal as numbers but differ in length, then the concatenation order is the endpoint shared key, followed by the shorter key vector, followed by the longer key vector. Otherwise, the key vectors are identical, and may be concatenated to the endpoint pair key in any order. The concatenation is performed on byte vectors, and all numerical comparisons use network byte order to convert the key vectors to a number. The result of the concatenation is the association shared key.",
      "ja": "エンドポイントペアの共有キーとキーベクトルから、アソシエーション共有キーが計算されます。これは、数値的に小さいキーベクトルを選択し、それをエンドポイントペア共有キーに連結し、それに数値的に大きいキーベクトルを連結することによって実行されます。キーベクトルが数値として等しいが長さが異なる場合、連結順序はエンドポイント共有キーであり、より短いキーベクトルが続き、その後に長いキーベクトルが続きます。それ以外の場合、キーベクトルは同一であり、任意の順序でエンドポイントペアキーに連結することができます。連結はバイトベクトルで実行され、すべての数値比較はネットワークバイト順序を使用してキーベクトルを数に変換します。連結の結果は、関連性の共有キーです。"
    },
    {
      "indent": 0,
      "text": "6.2. Sending Authenticated Chunks",
      "section_title": true,
      "ja": "6.2. 認証されたチャンクを送信します"
    },
    {
      "indent": 3,
      "text": "Endpoints MUST send all requested chunks that have been authenticated where this has been requested by the peer. The other chunks MAY be sent whether or not they have been authenticated. If endpoint pair shared keys are used, one of them MUST be selected for authentication.",
      "ja": "エンドポイントは、これがピアから要求された場所で認証されたすべての要求されたチャンクを送信する必要があります。他のチャンクは、それらが認証されているかどうかにかかわらず送信される場合があります。エンドポイントペア共有キーを使用する場合、そのうちの1つを認証のために選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "To send chunks in an authenticated way, the sender MUST include these chunks after an AUTH chunk. This means that a sender MUST bundle chunks in order to authenticate them.",
      "ja": "認証された方法でチャンクを送信するには、送信者は認証チャンクの後にこれらのチャンクを含める必要があります。これは、送信者がチャンクを認証するためにチャンクを束ねなければならないことを意味します。"
    },
    {
      "indent": 3,
      "text": "If the endpoint has no endpoint pair shared key for the peer, it MUST use Shared Key Identifier zero with an empty endpoint pair shared key. If there are multiple endpoint shared keys the sender selects one and uses the corresponding Shared Key Identifier.",
      "ja": "エンドポイントにピアのエンドポイントペア共有キーがない場合、空のエンドポイントペア共有キーで共有キー識別子ゼロを使用する必要があります。複数のエンドポイント共有キーがある場合、送信者は1つを選択し、対応する共有キー識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "The sender MUST calculate the Message Authentication Code (MAC) (as described in RFC 2104 [2]) using the hash function H as described by the HMAC Identifier and the shared association key K based on the endpoint pair shared key described by the Shared Key Identifier. The 'data' used for the computation of the AUTH-chunk is given by the AUTH chunk with its HMAC field set to zero (as shown in Figure 6) followed by all the chunks that are placed after the AUTH chunk in the SCTP packet.",
      "ja": "送信者は、HMAC識別子と共有関連キーKに基づいてHMAC識別子と共有アソシエーションキーKによって説明されているように、ハッシュ関数Hを使用して、メッセージ認証コード（MAC）（RFC 2104 [2]で説明されている）を計算する必要があります。識別子。Auth-Chunkの計算に使用される「データ」は、HMACフィールドがゼロに設定された（図6を参照）、SCTPパケットのAuth Chunkの後に配置されたすべてのチャンクがゼロに設定されたAuth Chunkによって与えられます。"
    },
    {
      "indent": 3,
      "text": "+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Type = 0x0F   |   Flags=0     |         Chunk Length          |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|    Shared Key Identifier      |        HMAC Identifier        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n\\                               0                               /\n/                               +-------------------------------\\\n|                               |           Padding             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 6",
      "ja": "図6"
    },
    {
      "indent": 3,
      "text": "Please note that all fields are in network byte order and that the field that will contain the complete HMAC is filled with zeroes. The length of the field shown as zero is the length of the HMAC described by the HMAC Identifier. The padding of all chunks being authenticated MUST be included in the HMAC computation.",
      "ja": "すべてのフィールドはネットワークバイトの順序であり、完全なHMACを含むフィールドはゼロで満たされていることに注意してください。ゼロとして表示されるフィールドの長さは、HMAC識別子によって記述されたHMACの長さです。認証されているすべてのチャンクのパディングは、HMAC計算に含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The sender fills the HMAC into the HMAC field and sends the packet.",
      "ja": "送信者はHMACをHMACフィールドに埋め、パケットを送信します。"
    },
    {
      "indent": 0,
      "text": "6.3. Receiving Authenticated Chunks",
      "section_title": true,
      "ja": "6.3. 認証されたチャンクを受信します"
    },
    {
      "indent": 3,
      "text": "The receiver has a list of chunk types that it expects to be received only after an AUTH-chunk. This list has been sent to the peer during the association setup. It MUST silently discard these chunks if they are not placed after an AUTH chunk in the packet.",
      "ja": "受信者には、Auth-Chunkの後にのみ受信されると予想されるチャンクタイプのリストがあります。このリストは、協会のセットアップ中にピアに送信されました。これらのチャンクは、パケットの認証チャンクの後に配置されていない場合、静かに捨てなければなりません。"
    },
    {
      "indent": 3,
      "text": "The receiver MUST use the HMAC algorithm indicated in the HMAC Identifier field. If this algorithm was not specified by the receiver in the HMAC-ALGO parameter in the INIT or INIT-ACK chunk during association setup, the AUTH chunk and all the chunks after it MUST be discarded and an ERROR chunk SHOULD be sent with the error cause defined in Section 4.1.",
      "ja": "受信者は、HMAC識別子フィールドに示されているHMACアルゴリズムを使用する必要があります。このアルゴリズムが、Associationのセットアップ中にinitまたはinit-ackチャンクのhmac-algoパラメーターの受信機によって指定されていない場合、廃棄した後のAuth Chunkおよびすべてのチャンクを、エラーチャンクをエラーの原因とともに送信する必要がありますセクション4.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "If an endpoint with no shared key receives a Shared Key Identifier other than 0, it MUST silently discard all authenticated chunks. If the endpoint has at least one endpoint pair shared key for the peer, it MUST use the key specified by the Shared Key Identifier if a key has been configured for that Shared Key Identifier. If no endpoint pair shared key has been configured for that Shared Key Identifier, all authenticated chunks MUST be silently discarded.",
      "ja": "共有キーのないエンドポイントが0以外の共有キー識別子を受信する場合、認証されたすべてのチャンクを静かに破棄する必要があります。エンドポイントにピアの少なくとも1つのエンドポイントペア共有キーがある場合、その共有キー識別子にキーが構成されている場合、共有キー識別子によって指定されたキーを使用する必要があります。その共有キー識別子に対してエンドポイントペア共有キーが構成されていない場合、すべての認証されたチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "The receiver now performs the same calculation as described for the sender based on Figure 6. If the result of the calculation is the same as given in the HMAC field, all the chunks following the AUTH chunk are processed. If the field does not match the result of the calculation, all the chunks following the AUTH chunk MUST be silently discarded.",
      "ja": "レシーバーは、図6に基づいて送信者について説明したのと同じ計算を実行するようになりました。計算の結果がHMACフィールドで与えられたものと同じ場合、AUTHチャンクに続くすべてのチャンクが処理されます。フィールドが計算の結果と一致しない場合、認証チャンクに続くすべてのチャンクは静かに廃棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "It should be noted that if the receiver wants to tear down an association in an authenticated way only, the handling of malformed packets should not result in tearing down the association.",
      "ja": "受信者が認証された方法でのみ協会を取り壊したい場合、不正なパケットの取り扱いは関連性を取り壊すものではないことに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "An SCTP implementation has to maintain state for each SCTP association. In the following, we call this data structure the SCTP transmission control block (STCB).",
      "ja": "SCTPの実装は、各SCTP協会の状態を維持する必要があります。以下では、このデータ構造をSCTP伝送制御ブロック（STCB）と呼びます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint requires COOKIE-ECHO chunks to be authenticated, some special procedures have to be followed because the reception of a COOKIE-ECHO chunk might result in the creation of an SCTP association. If a packet arrives containing an AUTH chunk as a first chunk, a COOKIE-ECHO chunk as the second chunk, and possibly more chunks after them, and the receiver does not have an STCB for that packet, then authentication is based on the contents of the COOKIE-ECHO chunk. In this situation, the receiver MUST authenticate the chunks in the packet by using the RANDOM parameters, CHUNKS parameters and HMAC_ALGO parameters obtained from the COOKIE-ECHO chunk, and possibly a local shared secret as inputs to the authentication procedure specified in Section 6.3. If authentication fails, then the packet is discarded. If the authentication is successful, the COOKIE-ECHO and all the chunks after the COOKIE-ECHO MUST be processed. If the receiver has an STCB, it MUST process the AUTH chunk as described above using the STCB from the existing association to authenticate the COOKIE-ECHO chunk and all the chunks after it.",
      "ja": "エンドポイントでCookie-Echoチャンクを認証する必要がある場合、Cookie-Echoチャンクの受信がSCTP協会の作成につながる可能性があるため、いくつかの特別な手順に従う必要があります。Auth Chunkを最初のチャンク、Cookie-Echo Chunkとして2番目のチャンクとして含むパケットが到着し、おそらくそれらの後にさらにチャンクがあり、受信機にはそのパケットのSTCBがない場合、認証はの内容に基づいています。クッキーエコーチャンク。この状況では、レシーバーは、Cookie-Echoチャンクから得られたランダムパラメーター、チャンクパラメーター、およびhmac_algoパラメーター、およびセクション6.3で指定された認証手順への入力としてのローカル共有秘密を使用して、パケットのチャンクを認証する必要があります。認証が失敗した場合、パケットは破棄されます。認証が成功した場合、Cookie-Echoの後のCookie-Echoとすべてのチャンクを処理する必要があります。受信機にSTCBがある場合、既存の関連付けからSTCBを使用して上記のように認証チャンクを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the receiver does not find an STCB for a packet containing an AUTH chunk as the first chunk and does not find a COOKIE-ECHO chunk as the second chunk, it MUST use the chunks after the AUTH chunk to look up an existing association. If no association is found, the packet MUST be considered as out of the blue. The out of the blue handling MUST be based on the packet without taking the AUTH chunk into account. If an association is found, it MUST process the AUTH chunk using the STCB from the existing association as described earlier.",
      "ja": "受信者が、最初のチャンクとして認証チャンクを含むパケットのSTCBを見つけられず、2番目のチャンクとしてCookie-Echoチャンクを見つけられない場合、Auth Chunkの後にチャンクを使用して既存の関連性を検索する必要があります。関連性が見つからない場合、パケットは青色と見なされる必要があります。青いハンドリングは、認証チャンクを考慮せずにパケットに基づいている必要があります。関連性が見つかった場合、前述のように既存の関連付けからSTCBを使用してAUTHチャンクを処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "Requiring ABORT chunks and COOKIE-ECHO chunks to be authenticated makes it impossible for an attacker to bring down or restart an association as long as the attacker does not know the association shared key. But it should also be noted that if an endpoint accepts ABORT chunks only in an authenticated way, it may take longer to detect that the peer is no longer available. If an endpoint accepts COOKIE-ECHO chunks only in an authenticated way, the restart procedure does not work, because the restarting endpoint most likely does not know the association shared key of the old association to be restarted. However, if the restarting endpoint does know the old association shared key, he can successfully send the COOKIE-ECHO chunk in a way that it is accepted by the peer by using this old association shared key for the packet containing the AUTH chunk. After this operation, both endpoints have to use the new association shared key.",
      "ja": "中止チャンクとクッキーエコーチャンクを認証する必要があるため、攻撃者が協会の共有キーを知らない限り、攻撃者が協会を倒したり再起動したりすることは不可能になります。ただし、エンドポイントが認証された方法でのみ中止チャンクを受け入れる場合、ピアが利用できなくなったことを検出するのに時間がかかる場合があることにも注意する必要があります。エンドポイントが認証された方法でのみCookie-Echoチャンクを受け入れる場合、再起動エンドポイントは、古い協会の関連性の共有キーが再起動することを知らないため、再起動手順は機能しません。ただし、再起動エンドポイントが古い協会の共有キーを知っている場合、彼は、Authチャンクを含むパケットにこの古い協会共有キーを使用することにより、ピアが受け入れるようにCookie-Echoチャンクを正常に送信できます。この操作の後、両方のエンドポイントは新しいアソシエーション共有キーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server has an endpoint pair shared key with some clients, it can request the COOKIE_ECHO chunk to be authenticated and can ensure that only associations from clients with a correct endpoint pair shared key are accepted.",
      "ja": "サーバーが一部のクライアントとエンドポイントペアの共有キーを持っている場合、Cookie_Echo Chunkの認証を要求し、正しいエンドポイントペア共有キーを持つクライアントからのアソシエーションのみが受け入れられるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "Furthermore, it is important that the cookie contained in an INIT-ACK chunk and in a COOKIE-ECHO chunk MUST NOT contain any endpoint pair shared keys.",
      "ja": "さらに、Cookieがinit-ackチャンクに含まれており、Cookie-echo chunkに含まれるクッキーには、エンドポイントペア共有キーが含まれていないことが重要です。"
    },
    {
      "indent": 0,
      "text": "7. Examples",
      "section_title": true,
      "ja": "7. 例"
    },
    {
      "indent": 3,
      "text": "This section gives examples of message exchanges for association setup.",
      "ja": "このセクションでは、アソシエーションセットアップのメッセージ交換の例を示します。"
    },
    {
      "indent": 3,
      "text": "The simplest way of using the extension described in this document is given by the following message exchange.",
      "ja": "このドキュメントで説明されている拡張機能を使用する最も簡単な方法は、次のメッセージ交換によって与えられます。"
    },
    {
      "indent": 7,
      "text": "---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n<------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n-------------------- COOKIE-ECHO -------------------->\n<-------------------- COOKIE-ACK ---------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Please note that the CHUNKS parameter is optional in the INIT and INIT-ACK.",
      "ja": "Chunksパラメーターは、initとinit-ackでオプションであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the server wants to receive DATA chunks in an authenticated way, the following message exchange is possible:",
      "ja": "サーバーが認証された方法でデータチャンクを受信したい場合、次のメッセージ交換が可能です。"
    },
    {
      "indent": 7,
      "text": "---------- INIT[RANDOM; CHUNKS; HMAC-ALGO] ---------->\n<------- INIT-ACK[RANDOM; CHUNKS; HMAC-ALGO] ---------\n--------------- COOKIE-ECHO; AUTH; DATA ------------->\n<----------------- COOKIE-ACK; SACK ------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Please note that if the endpoint pair shared key depends on the client and the server, and is only known by the upper layer, this message exchange requires an upper layer intervention between the processing of the COOKIE-ECHO chunk and the processing of the AUTH and DATA chunk at the server side. This intervention may be realized by a COMMUNICATION-UP notification followed by the presentation of the endpoint pair shared key by the upper layer to the SCTP stack, see for example Section 10 of RFC 2960 [5]. If this intervention is not possible due to limitations of the API (for example, the socket API), the server might discard the AUTH and DATA chunk, making a retransmission of the DATA chunk necessary. If the same endpoint pair shared key is used for multiple endpoints and does not depend on the client, this intervention might not be necessary.",
      "ja": "エンドポイントペアの共有キーがクライアントとサーバーに依存し、上層層によってのみ知られている場合、このメッセージ交換には、Cookie-Echoチャンクの処理と認証の処理との間に上層層の介入が必要であることに注意してください。サーバー側のデータチャンク。この介入は、通信アップ通知に続いて、上層層で共有キーをSCTPスタックに共有するエンドポイントペアの提示によって実現される場合があります。たとえば、RFC 2960 [5]のセクション10を参照してください。この介入がAPI（たとえば、ソケットAPIなど）の制限のために不可能な場合、サーバーはAUTHとデータチャンクを破棄し、データチャンクを再送信する必要があります。同じエンドポイントペア共有キーが複数のエンドポイントに使用され、クライアントに依存しない場合、この介入は必要ない場合があります。"
    },
    {
      "indent": 0,
      "text": "8. IANA Considerations",
      "section_title": true,
      "ja": "8. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document (RFC 4895) is the reference for all registrations described in this section. All registrations need to be listed in the document available at SCTP-parameters [9]. The changes are described below.",
      "ja": "このドキュメント（RFC 4895）は、このセクションで説明されているすべての登録のリファレンスです。すべての登録は、sctp-parameters [9]で利用可能なドキュメントにリストする必要があります。変更については、以下に説明します。"
    },
    {
      "indent": 0,
      "text": "8.1. A New Chunk Type",
      "section_title": true,
      "ja": "8.1. 新しいチャンクタイプ"
    },
    {
      "indent": 3,
      "text": "A chunk type for the AUTH chunk has been assigned by IANA. IANA has assigned the value (15), as given in Table 4. An additional line has been added in the \"CHUNK TYPES\" table of SCTP-parameters [9]:",
      "ja": "Auth Chunkのチャンクタイプは、IANAによって割り当てられています。IANAは、表4に示すように、値（15）を割り当てました。"
    },
    {
      "indent": 3,
      "text": "CHUNK TYPES",
      "ja": "チャンクタイプ"
    },
    {
      "indent": 3,
      "text": "ID Value    Chunk Type                                     Reference\n-----       ----------                                     ---------\n15          Authentication Chunk (AUTH)                    [RFC4895]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.2. Three New Parameter Types",
      "section_title": true,
      "ja": "8.2. 3つの新しいパラメータータイプ"
    },
    {
      "indent": 3,
      "text": "Parameter types have been assigned for the RANDOM, CHUNKS, and HMAC-ALGO parameter by IANA. The values are as given in Table 1. This required two modifications to the \"CHUNK PARAMETER TYPES\" tables in SCTP-parameters [9]: the first is the addition of three new lines to the \"INIT Chunk Parameter Types\" table:",
      "ja": "IANAによってランダム、チャンク、およびHMAC-Algoパラメーターにパラメータータイプが割り当てられています。値は表1に示されています。これには、sctp-parametersの「チャンクパラメータータイプ」テーブルの2つの変更が必要です[9]：1つ目は、「initチャンクパラメータータイプ」テーブルに3つの新しい行を追加することです。"
    },
    {
      "indent": 3,
      "text": "Chunk Parameter Type                       Value\n--------------------                       -----\nRandom                             32770 (0x8002)\nChunk List                         32771 (0x8003)\nRequested HMAC Algorithm Parameter 32772 (0x8004)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second required change is the addition of the same three lines to the to the \"INIT ACK Chunk Parameter Types\" table.",
      "ja": "2番目の必要な変更は、「init ackチャンクパラメータータイプ」テーブルに同じ3行を追加することです。"
    },
    {
      "indent": 0,
      "text": "8.3. A New Error Cause",
      "section_title": true,
      "ja": "8.3. 新しいエラー原因"
    },
    {
      "indent": 3,
      "text": "An error cause for the Unsupported HMAC Identifier error cause has been assigned. The value (261) has been assigned as in Table 3.",
      "ja": "サポートされていないHMAC識別子エラー原因のエラー原因が割り当てられています。値（261）は、表3のように割り当てられています。"
    },
    {
      "indent": 3,
      "text": "This requires an additional line of the \"CAUSE CODES\" table in SCTP-parameters [9]:",
      "ja": "これには、SCTPパラメーター[9]の「原因コード」テーブルの追加行が必要です。"
    },
    {
      "indent": 3,
      "text": "VALUE            CAUSE CODE                               REFERENCE\n-----            ----------------                         ---------\n261 (0x0105)     Unsupported HMAC Identifier              [RFC4895]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.4. A New Table for HMAC Identifiers",
      "section_title": true,
      "ja": "8.4. HMAC識別子の新しいテーブル"
    },
    {
      "indent": 3,
      "text": "HMAC Identifiers have to be maintained by IANA. Four initial values have been assigned by IANA as described in Table 2. This required a new table \"HMAC IDENTIFIERS\" in SCTP-parameters [9]:",
      "ja": "HMAC識別子はIANAによって維持する必要があります。表2に記載されているように、IANAによって4つの初期値が割り当てられています。"
    },
    {
      "indent": 3,
      "text": "HMAC Identifier      Message Digest Algorithm             REFERENCE\n---------------      ------------------------             ---------\n0                    Reserved                             [RFC4895]\n1                    SHA-1                                [RFC4895]\n2                    Reserved                             [RFC4895]\n3                    SHA-256                              [RFC4895]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For registering a new HMAC Identifier with IANA, in this table, a request has to be made to assign such a number. This number must be unique and a message digest algorithm usable with the HMAC defined in RFC 2104 [2] MUST be specified. The \"Specification Required\" policy of RFC 2434 [4] MUST be applied.",
      "ja": "このテーブルでは、IANAに新しいHMAC識別子を登録するには、そのような番号を割り当てるためにリクエストを行う必要があります。この数値は一意でなければならず、RFC 2104 [2]で定義されたHMACを使用して使用可能なメッセージダイジェストアルゴリズムを指定する必要があります。RFC 2434 [4]の「必要な仕様」ポリシーを適用する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Without using endpoint shared keys, this extension only protects against modification or injection of authenticated chunks by attackers who did not capture the initial handshake setting up the SCTP association.",
      "ja": "エンドポイント共有キーを使用せずに、この拡張機能は、SCTPアソシエーションを設定した最初の握手をキャプチャしなかった攻撃者による認証されたチャンクの変更または注入からのみ保護します。"
    },
    {
      "indent": 3,
      "text": "If an endpoint pair shared key is used, even a true man in the middle cannot inject chunks, which are required to be authenticated, even if he intercepts the initial message exchange. The endpoint also knows that it is accepting authenticated chunks from a peer who knows the endpoint pair shared key.",
      "ja": "エンドポイントペアの共有キーが使用されている場合、真ん中の真の男でさえ、最初のメッセージ交換を傍受したとしても、認証が必要なチャンクを注入することはできません。エンドポイントは、エンドポイントペア共有キーを知っているピアから認証されたチャンクを受け入れていることも知っています。"
    },
    {
      "indent": 3,
      "text": "The establishment of endpoint pair shared keys is out of the scope of this document. Other mechanisms can be used, like using TLS or manual configuration.",
      "ja": "エンドポイントペア共有キーの確立は、このドキュメントの範囲外です。TLSや手動構成の使用など、他のメカニズムを使用できます。"
    },
    {
      "indent": 3,
      "text": "When an endpoint accepts COOKIE-ECHO chunks only in an authenticated way the restart procedure does not work. Neither an attacker nor a restarted endpoint not knowing the association shared key can perform an restart. However, if the association shared key is known, it is possible to restart the association.",
      "ja": "エンドポイントが認証された方法でのみクッキーエコーチャンクを受け入れる場合、再起動手順は機能しません。攻撃者も再起動したエンドポイントも、協会の共有キーが再起動を実行できることを知らないことではありません。ただし、協会の共有キーがわかっている場合、協会を再開することが可能です。"
    },
    {
      "indent": 3,
      "text": "Because SCTP already has a built-in mechanism that handles the reception of duplicated chunks, the presented solution makes use of this functionality and does not provide a method to avoid replay attacks by itself. Of course, this only works within each SCTP association. Therefore, a separate shared key is used for each SCTP association to handle replay attacks covering multiple SCTP associations.",
      "ja": "SCTPにはすでに重複したチャンクの受信を処理する組み込みメカニズムがあるため、提示されたソリューションはこの機能を利用し、それ自体で攻撃を再生する方法を提供しません。もちろん、これは各SCTP協会内でのみ機能します。したがって、複数のSCTPアソシエーションをカバーするリプレイ攻撃を処理するために、各SCTPアソシエーションに個別の共有キーが使用されます。"
    },
    {
      "indent": 3,
      "text": "Each endpoint presenting a list of more than one element in the HMAC-ALGO parameter must be prepared for the peer using the weakest algorithm listed.",
      "ja": "HMAC-Algoパラメーターの複数の要素のリストを提示する各エンドポイントは、リストされている最も弱いアルゴリズムを使用してピアに対して準備する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an endpoint pair uses non-NULL endpoint pair shared keys and one of the endpoints still accepts a NULL key, an attacker who captured the initial handshake can still inject or modify authenticated chunks by using the NULL key.",
      "ja": "エンドポイントペアが非ヌルエンドポイントペア共有キーを使用し、エンドポイントの1つがまだnullキーを受け入れる場合、最初の握手をキャプチャした攻撃者は、nullキーを使用して認証されたチャンクを注入または変更できます。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors wish to thank David Black, Sascha Grau, Russ Housley, Ivan Arias Rodriguez, Irene Ruengeler, and Magnus Westerlund for their invaluable comments.",
      "ja": "著者は、David Black、Sascha Grau、Russ Housley、Ivan Arias Rodriguez、Irene Ruengeler、Magnus Westerlundの貴重なコメントに感謝したいと考えています。"
    },
    {
      "indent": 0,
      "text": "11. Normative References",
      "section_title": true,
      "ja": "11. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April 1992.",
      "ja": "[1] Rivest、R。、「The Md5 Message-Digest Algorithm」、RFC 1321、1992年4月。"
    },
    {
      "indent": 3,
      "text": "[2] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[2] Krawczyk、H.、Bellare、M。、およびR. Canetti、「HMAC：メッセージ認証のためのキードハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[3] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[3] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[4] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[4] Narten、T。およびH. Alvestrand、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[5] Stewart, R., Xie, Q., Morneault, K., Sharp, C., Schwarzbauer, H., Taylor, T., Rytina, I., Kalla, M., Zhang, L., and V. Paxson, \"Stream Control Transmission Protocol\", RFC 2960, October 2000.",
      "ja": "[5] Stewart、R.、Xie、Q.、Morneault、K.、Sharp、C.、Schwarzbauer、H.、Taylor、T.、Rytina、I.、Kalla、M.、Zhang、L。、およびV. Paxson、「ストリーム制御伝送プロトコル」、RFC 2960、2000年10月。"
    },
    {
      "indent": 3,
      "text": "[6] Jungmaier, A., Rescorla, E., and M. Tuexen, \"Transport Layer Security over Stream Control Transmission Protocol\", RFC 3436, December 2002.",
      "ja": "[6] Jungmaier、A.、Rescorla、E。、およびM. Tuexen、「ストリーム制御伝送プロトコルを介した輸送層セキュリティ」、RFC 3436、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[7] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[7] Eastlake、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[8] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-2, August 2002, <http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2.pdf>.",
      "ja": "[8] 国立標準技術研究所、「Secure Hash Standard」、Fips Pub 180-2、2002年8月、<http://csrc.nist.gov/publications/fips/fips180-2/ fips180-2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[9]  <http://www.iana.org/assignments/sctp-parameters>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Michael Tuexen Muenster Univ. of Applied Sciences Stegerwaldstr. 39 48565 Steinfurt Germany",
      "ja": "マイケル・テクセン・ミューンスター大学。Applied SciencesStegerwaldstraßeの。39 48565 Steinfurtドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: tuexen@fh-muenster.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Randall R. Stewart Cisco Systems, Inc. 4875 Forest Drive Suite 200 Columbia, SC 29206 USA",
      "ja": "Randall R. Stewart Cisco Systems、Inc。4875 Forest Drive Suite 200 Columbia、Sc 29206 USA"
    },
    {
      "indent": 3,
      "text": "EMail: rrs@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Peter Lei Cisco Systems, Inc. 8735 West Higgins Road Suite 300 Chicago, IL 60631 USA",
      "ja": "Peter Lei Cisco Systems、Inc。8735 West Higgins Road Suite 300 Chicago、IL 60631 USA"
    },
    {
      "indent": 3,
      "text": "Phone: EMail: peterlei@cisco.com",
      "ja": "電話：メール：peterlei@cisco.com"
    },
    {
      "indent": 3,
      "text": "Eric Rescorla RTFM, Inc. 2064 Edgewood Drive Palo Alto, CA 94303 USA",
      "ja": "Eric Rescorla RTFM、Inc。2064 Edgewood Drive Palo Alto、CA 94303 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650-320-8549\nEMail: ekr@rtfm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    }
  ]
}