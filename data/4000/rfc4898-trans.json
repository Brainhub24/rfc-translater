{
  "title": {
    "text": "RFC 4898 - TCP Extended Statistics MIB",
    "ja": "RFC 4898 - TCP拡張統計MIB"
  },
  "number": 4898,
  "created_at": "2023-05-17 09:17:53.819586+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Mathis\nRequest for Comments: 4898                                    J. Heffner\nCategory: Standards Track               Pittsburgh Supercomputing Center\n                                                         R. Raghunarayan\n                                                           Cisco Systems\n                                                                May 2007",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "TCP Extended Statistics MIB",
      "ja": "TCP拡張統計MIB"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes extended performance statistics for TCP. They are designed to use TCP's ideal vantage point to diagnose performance problems in both the network and the application. If a network-based application is performing poorly, TCP can determine if the bottleneck is in the sender, the receiver, or the network itself. If the bottleneck is in the network, TCP can provide specific information about its nature.",
      "ja": "このドキュメントは、TCPの拡張パフォーマンス統計について説明しています。TCPの理想的な見晴らしの良い点を使用して、ネットワークとアプリケーションの両方のパフォーマンスの問題を診断するように設計されています。ネットワークベースのアプリケーションのパフォーマンスが低い場合、TCPはボトルネックが送信者、受信機、またはネットワーク自体にあるかどうかを判断できます。ボトルネットがネットワークにある場合、TCPはその性質に関する特定の情報を提供できます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. The Internet-Standard Management Framework ......................2\n3. Overview ........................................................2\n   3.1. MIB Initialization and Persistence .........................4\n   3.2. Relationship to TCP Standards ..............................4\n   3.3. Diagnosing SYN-Flood Denial-of-Service Attacks .............6\n4. TCP Extended Statistics MIB .....................................7\n5. Security Considerations ........................................69\n6. IANA Considerations ............................................70\n7. Normative References ...........................................70\n8. Informative References .........................................72\n9. Contributors ...................................................73\n10. Acknowledgments ...............................................73",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes extended performance statistics for TCP. They are designed to use TCP's ideal vantage point to diagnose performance problems in both the network and the application. If a network-based application is performing poorly, TCP can determine if the bottleneck is in the sender, the receiver, or the network itself. If the bottleneck is in the network, TCP can provide specific information about its nature.",
      "ja": "このドキュメントは、TCPの拡張パフォーマンス統計について説明しています。TCPの理想的な見晴らしの良い点を使用して、ネットワークとアプリケーションの両方のパフォーマンスの問題を診断するように設計されています。ネットワークベースのアプリケーションのパフォーマンスが低い場合、TCPはボトルネックが送信者、受信機、またはネットワーク自体にあるかどうかを判断できます。ボトルネットがネットワークにある場合、TCPはその性質に関する特定の情報を提供できます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.",
      "ja": "「必須」、「そうしない」、「必須」、「shall」、「shall \"、\" ingle \"、\" should \"、\" not \"、\" becommended \"、\" bay \"、および「optional」は、RFC 2119に記載されているとおりに解釈されます。"
    },
    {
      "indent": 3,
      "text": "The Simple Network Management Protocol (SNMP) objects defined in this document extend TCP MIB, as specified in RFC 4022 [RFC4022]. In addition to several new scalars and other objects, it augments two tables and makes one clarification to RFC 4022. Existing management stations for the TCP MIB are expected to be fully compatible with these clarifications.",
      "ja": "このドキュメントで定義されている単純なネットワーク管理プロトコル（SNMP）オブジェクトは、RFC 4022 [RFC4022]で指定されているように、TCP MIBを拡張します。いくつかの新しいスカラーやその他のオブジェクトに加えて、2つのテーブルを強化し、RFC 4022に1つの説明を作成します。TCPMIBの既存の管理ステーションは、これらの明確化と完全に互換性があると予想されます。"
    },
    {
      "indent": 0,
      "text": "2. The Internet-Standard Management Framework",
      "section_title": true,
      "ja": "2. インターネット標準の管理フレームワーク"
    },
    {
      "indent": 3,
      "text": "For a detailed overview of the documents that describe the current Internet-Standard Management Framework, please refer to section 7 of RFC 3410 [RFC3410].",
      "ja": "現在のインターネット標準管理フレームワークを説明するドキュメントの詳細な概要については、RFC 3410 [RFC3410]のセクション7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Managed objects are accessed via a virtual information store, termed the Management Information Base or MIB. MIB objects are generally accessed through the Simple Network Management Protocol (SNMP). Objects in the MIB are defined using the mechanisms defined in the Structure of Management Information (SMI). This memo specifies a MIB module that is compliant to the SMIv2, which is described in STD 58, RFC 2578 [RFC2578], STD 58, RFC 2579 [RFC2579] and STD 58, RFC 2580 [RFC2580].",
      "ja": "管理されたオブジェクトは、管理情報ベースまたはMIBと呼ばれる仮想情報ストアからアクセスされます。MIBオブジェクトは通常、単純なネットワーク管理プロトコル（SNMP）からアクセスされます。MIBのオブジェクトは、管理情報の構造（SMI）で定義されたメカニズムを使用して定義されます。このメモは、STD 58、RFC 2578 [RFC2578]、STD 58、RFC 2579 [RFC2579]およびSTD 58、RFC 2580 [RFC2580]に記載されているSMIV2に準拠したMIBモジュールを指定します。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概要"
    },
    {
      "indent": 3,
      "text": "The TCP-ESTATS-MIB defined in this memo consists of two groups of scalars, seven tables, and two notifications:",
      "ja": "このメモで定義されているTCP-ESTATS-MIBは、スカラーの2つのグループ、7つのテーブル、および2つの通知で構成されています。"
    },
    {
      "indent": 3,
      "text": "* The first group of scalars contain statistics of the TCP protocol engine not covered in RFC 4022. This group consists of the single scalar tcpEStatsListenerTableLastChange, which provides management stations with an easier mechanism to validate their listener caches.",
      "ja": "* スカラーの最初のグループには、RFC 4022でカバーされていないTCPプロトコルエンジンの統計が含まれています。このグループは、リスナーキャッシュを検証するための簡単なメカニズムを管理ステーションに提供する単一のScalar TCPestatsListenTenerTableLastChangeで構成されています。"
    },
    {
      "indent": 3,
      "text": "* The second group of scalars consist of knobs to enable and disable information collection by the tables containing connection-related statistics/information. For example, the tcpEStatsControlPath object controls the activation of the tcpEStatsPathTable. The tcpEStatsConnTableLatency object determines how long connection table rows are retained after a TCP connection transitions into the closed state.",
      "ja": "* スカラーの2番目のグループは、接続関連の統計/情報を含むテーブルで情報収集を有効にして無効にするノブで構成されています。たとえば、TCPestatsControlPathオブジェクトは、TCPestatsPathtableの活性化を制御します。TCPESTATSCONNTABLETENCYオブジェクトは、TCP接続が閉じた状態に遷移した後、接続テーブルの行が保持される時間を決定します。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsListenerTable augments tcpListenerTable in TCP-MIB [RFC4022] to provide additional information on the active TCP listeners on a device. It supports objects to monitor and diagnose SYN-flood denial-of-service attacks as described below.",
      "ja": "* TCPESTATSLISTENERTABLEは、TCP-MIB [RFC4022]でTCPLISTENERTABLEを拡張して、デバイス上のアクティブなTCPリスナーに関する追加情報を提供します。以下に説明するように、Syn-Floodのサービス拒否攻撃を監視および診断するオブジェクトをサポートします。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsConnectIdTable augments the tcpConnectionTable in TCP-MIB [RFC4022] to provide a mapping between connection 4-tuples (which index tcpConnectionTable) and an integer connection index, tcpEStatsConnectIndex. The connection index is used to index into the five remaining tables in this MIB module, and is designed to facilitate rapid polling of multiple objects associated with one TCP connection.",
      "ja": "* TCPESTATSCONNECTIDTABLEは、TCP-MIB [RFC4022]のTCPConnectionTableを増強して、接続4タプル（TCPConnectionTableインデックス）と整数接続インデックス、TCPestatsConnectIndexの間のマッピングを提供します。接続インデックスは、このMIBモジュールの残りの5つのテーブルにインデックスを作成するために使用され、1つのTCP接続に関連付けられた複数のオブジェクトの迅速なポーリングを促進するように設計されています。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsPerfTable contains objects that are useful for measuring TCP performance and first check problem diagnosis.",
      "ja": "* TCPESTATSPERFTABLEには、TCPのパフォーマンスを測定し、問題の診断を最初に確認するのに役立つオブジェクトが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsPathTable contains objects that can be used to infer detailed behavior of the Internet path, such as the extent that there are segment losses or reordering, etc.",
      "ja": "* tcpestatspathtableには、セグメントの損失や並べ替えなどなど、インターネットパスの詳細な動作を推測するために使用できるオブジェクトが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsStackTable contains objects that are most useful for determining how well the TCP control algorithms are coping with this particular path.",
      "ja": "* TCPESTATSSTACKTABLEには、TCP制御アルゴリズムがこの特定のパスにどれだけうまく対処しているかを判断するのに最も役立つオブジェクトが含まれています。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsAppTable provides objects that are useful for determining if the application using TCP is limiting TCP performance.",
      "ja": "* TCPestatsApptableは、TCPを使用してアプリケーションがTCPパフォーマンスを制限しているかどうかを判断するのに役立つオブジェクトを提供します。"
    },
    {
      "indent": 3,
      "text": "* The tcpEStatsTuneTable provides per-connection controls that can be used to work around a number of common problems that plague TCP over some paths.",
      "ja": "* TCPESTATSTUNETABLEは、いくつかのパスでTCPを悩ませる多くの一般的な問題を回避するために使用できる接続ごとのコントロールを提供します。"
    },
    {
      "indent": 3,
      "text": "* The two notifications defined in this MIB module are tcpEStatsEstablishNotification, indicating that a new connection has been accepted (or established, see below), and tcpEStatsCloseNotification, indicating that an existing connection has recently closed.",
      "ja": "* このMIBモジュールで定義されている2つの通知は、tcpestatsの想像力を発揮していることを示しており、新しい接続が受け入れられていること（または以下を参照）とtcpestatscloseNotificationを示しており、既存の接続が最近閉じられていることを示しています。"
    },
    {
      "indent": 0,
      "text": "3.1. MIB Initialization and Persistence",
      "section_title": true,
      "ja": "3.1. MIBの初期化と持続性"
    },
    {
      "indent": 3,
      "text": "The TCP protocol itself is specifically designed not to preserve any state whatsoever across system reboots, and enforces this by requiring randomized Initial Sequence numbers and ephemeral ports under any conditions where segments from old connections might corrupt new connections following a reboot.",
      "ja": "TCPプロトコル自体は、システムの再起動全体で状態を保存しないように特異的に設計されており、古い接続のセグメントが再起動後に新しい接続を破損する可能性のある任意の条件の下で、ランダム化された初期シーケンス番号とはかないポートを必要とすることにより、これを実施します。"
    },
    {
      "indent": 3,
      "text": "All of the objects in the MIB MUST have the same persistence properties as the underlying TCP implementation. On a reboot, all zero-based counters MUST be cleared, all dynamically created table rows MUST be deleted, and all read-write objects MUST be restored to their default values. It is assumed that all TCP implementation have some initialization code (if nothing else, to set IP addresses) that has the opportunity to adjust tcpEStatsConnTableLatency and other read-write scalars controlling the creation of the various tables, before establishing the first TCP connection. Implementations MAY also choose to make these control scalars persist across reboots.",
      "ja": "MIBのすべてのオブジェクトには、基礎となるTCP実装と同じ永続性特性が必要です。再起動時に、すべてのゼロベースのカウンターをクリアする必要があり、動的に作成されたすべてのテーブル行を削除する必要があり、すべての読み取りワイトオブジェクトをデフォルト値に復元する必要があります。すべてのTCP実装には、最初のTCP接続を確立する前に、さまざまなテーブルの作成を制御するTCPestatsConntablelatencyおよびその他の読み取りワイトスカラーを調整する機会がある初期化コード（他には何もない場合、IPアドレスを設定する）があると想定されています。実装は、再起動全体でこれらのコントロールスカラーを持続させることを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "The ZeroBasedCounter32 and ZeroBasedCounter64 objects in the listener and connection tables are initialized to zero when the table row is created.",
      "ja": "リスナーと接続テーブルのZerobasedCounter32およびZerobasedCounter64オブジェクトは、テーブル行の作成時にゼロに初期化されます。"
    },
    {
      "indent": 3,
      "text": "The tcpEStatsConnTableLatency object determines how long connection table rows are retained after a TCP connection transitions into the closed state, to permit reading final connection completion statistics. In RFC 4022 (TCP-MIB), the discussion of tcpConnectionTable row latency (page 9) the words \"soon after\" are understood to mean after tcpEStatsConnTableLatency, such that all rows of all tables associated with one connection are retained at least tcpEStatsConnTableLatency after connection close. This clarification to RFC 4022 only applies when TCP-ESTATS-MIB is implemented. If TCP-ESTATS-MIB is not implemented, RFC 4022 permits an unspecified delay between connection close and row deletion.",
      "ja": "TCPESTATSCONNTABLELATENCENCEオブジェクトは、TCP接続が閉じた状態に遷移した後に接続テーブルの行が保持される時間を決定し、最終的な接続完了統計を読み取ることができます。RFC 4022（TCP-MIB）では、TCPCONNECTIONTABLE ROW LATENCY（9ページ）の議論「SOON後」という単語は、TCPestatsConntablelatencyの後に意味すると理解されているため、1つの接続に関連付けられたすべてのテーブルのすべての列が少なくともTCPestatsConntablelatency後の接続後の接続後のすべての列が保持されます。近い。RFC 4022へのこの明確化は、TCP-Estats-MIBが実装されている場合にのみ適用されます。TCP-ESTATS-MIBが実装されていない場合、RFC 4022は、接続クローズと行の削除の間に不特定の遅延を許可します。"
    },
    {
      "indent": 0,
      "text": "3.2. Relationship to TCP Standards",
      "section_title": true,
      "ja": "3.2. TCP標準との関係"
    },
    {
      "indent": 3,
      "text": "There are more than 70 RFCs and other documents that specify various aspects of the Transmission Control Protocol (TCP) [RFC4614]. While most protocols are completely specified in one or two documents, this has not proven to be feasible for TCP. TCP implements a reliable end-to-end data transport service over a very weakly constrained IP datagram service. The essential problem that TCP has to solve is balancing the applications need for fast and reliable data transport against the need to make fair, efficient, and equitable use of network resources, with only sparse information about the state of the network or its capabilities.",
      "ja": "透過制御プロトコル（TCP）[RFC4614]のさまざまな側面を指定する70を超えるRFCおよびその他のドキュメントがあります。ほとんどのプロトコルは1つまたは2つのドキュメントで完全に指定されていますが、これはTCPで実行可能であることが証明されていません。TCPは、非常に弱く制約されているIPデータグラムサービスよりも信頼性の高いエンドツーエンドのデータ輸送サービスを実装しています。TCPが解決しなければならない重要な問題は、ネットワークの状態またはその機能に関するまばらな情報のみを使用して、ネットワークリソースの公正で効率的かつ公平な使用を行う必要性と、高速かつ信頼性の高いデータ輸送の必要性のバランスをとることです。"
    },
    {
      "indent": 3,
      "text": "TCP maintains this balance through the use of many estimators and heuristics that regulate various aspects of the protocol. For example, RFC 2988 describes how to calculate the retransmission timer (RTO) from the average and variance of the network round-trip-time (RTT), as estimated from the round-trip time sampled on some data segments. Although these algorithms are standardized, they are a compromise which is optimal for only common Internet environments. Other estimators might yield better results (higher performance or more efficient use of the network) in some environments, particularly under uncommon conditions.",
      "ja": "TCPは、プロトコルのさまざまな側面を調節する多くの推定器とヒューリスティックを使用することにより、このバランスを維持します。たとえば、RFC 2988は、一部のデータセグメントでサンプリングされた往復時間から推定される、ネットワークの往復時間（RTT）の平均と分散から再送信タイマー（RTO）を計算する方法について説明します。これらのアルゴリズムは標準化されていますが、一般的なインターネット環境のみに最適な妥協です。他の推定値は、特に珍しい条件下で、より良い結果（ネットワークのより高いパフォーマンスまたはより効率的な使用）をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "It is the consensus of the community that nearly all of the estimators and heuristics used in TCP might be improved through further research and development. For this reason, nearly all TCP documents leave some latitude for future improvements, for example, by the use of \"SHOULD\" instead of \"MUST\" [RFC2119]. Even standard algorithms that are required because they critically effect fairness or the dynamic stability of Internet congestion control, include some latitude for evolution. As a consequence, there is considerable diversity in the details of the TCP implementations actually in use today.",
      "ja": "TCPで使用される推定器とヒューリスティックのほぼすべてが、さらなる研究開発を通じて改善される可能性があるのは、コミュニティのコンセンサスです。このため、ほぼすべてのTCP文書は、たとえば「必須」[RFC2119]の代わりに「必須」の使用により、将来の改善のためにある程度の緯度を残しています。インターネット輻輳制御の公平性や動的安定性に重大な影響を与えるために必要な標準的なアルゴリズムでさえ、進化の緯度を含んでいます。結果として、今日使用されているTCP実装の詳細にはかなりの多様性があります。"
    },
    {
      "indent": 3,
      "text": "The fact that the underlying algorithms are not uniform makes it difficult to tightly specify a MIB. We could have chosen the point of view that the MIB should publish precisely defined metrics of the network path, even if they are different from the estimators in use by TCP. This would make the MIB more useful as a measurement tool, but less useful for understanding how any specific TCP implementation is interacting with the network path and upper protocol layers. We chose instead to have the MIB expose the estimators and important states variables of the algorithms in use, without constraining the TCP implementation.",
      "ja": "基礎となるアルゴリズムが均一ではないという事実により、MIBをしっかりと指定することが困難です。TCPが使用している推定器とは異なる場合でも、MIBはネットワークパスの正確に定義されたメトリックを公開する必要があるという観点を選択できました。これにより、MIBは測定ツールとしてより有用になりますが、特定のTCP実装がネットワークパスおよび上部プロトコル層とどのように相互作用しているかを理解するのにあまり役立ちません。代わりに、TCP実装を制約することなく、使用中のアルゴリズムの推定器と重要な状態変数をMIBに公開することを選択しました。"
    },
    {
      "indent": 3,
      "text": "As a consequence, the MIB objects are defined in terms of fairly abstract descriptions (e.g., round-trip time), but are intended to expose the actual estimators or other state variables as they are used in TCP implementations, possibly transformed (e.g., scaled or otherwise adjusted) to match the spirit of the object descriptions in this document.",
      "ja": "結果として、MIBオブジェクトはかなり抽象的な説明（ラウンドトリップ時間など）の観点から定義されていますが、TCP実装で使用される実際の推定器またはその他の状態変数を公開することを目的としています。または、このドキュメントのオブジェクトの説明のスピリットに一致するように調整されます。"
    },
    {
      "indent": 3,
      "text": "This may mean that MIB objects may not be exactly comparable between two different TCP implementations. A general management station can only assume the abstract descriptions, which are useful for a general assessment of how TCP is functioning. To a TCP implementer with detailed knowledge about the TCP implementation on a specific host, this MIB might be useful for debugging or evaluating the algorithms in their implementation.",
      "ja": "これは、MIBオブジェクトが2つの異なるTCP実装間で正確に匹敵するものではないことを意味する場合があります。一般的な管理ステーションは、TCPがどのように機能しているかの一般的な評価に役立つ抽象的な説明のみを想定できます。特定のホストのTCP実装に関する詳細な知識を持つTCP実装者にとって、このMIBは、その実装でアルゴリズムのデバッグまたは評価に役立つ可能性があります。"
    },
    {
      "indent": 3,
      "text": "Under no conditions is this MIB intended to constrain TCP to use (or exclude) any particular estimator, heuristic, algorithm, or implementation.",
      "ja": "このMIBは、特定の推定器、ヒューリスティック、アルゴリズム、または実装を使用（または除外）するようにTCPを制約することを意図していません。"
    },
    {
      "indent": 0,
      "text": "3.3. Diagnosing SYN-Flood Denial-of-Service Attacks",
      "section_title": true,
      "ja": "3.3. Syn-Floodのサービス拒否攻撃の診断"
    },
    {
      "indent": 3,
      "text": "The tcpEStatsListenerTable is specifically designed to provide information that is useful for diagnosing SYN-flood Denial-of-Service attacks, where a server is overwhelmed by forged or otherwise malicious connection attempts. There are several different techniques that can be used to defend against SYN-flooding but none are standardized [Edd06]. These different techniques all have the same basic characteristics that are instrumentable with a common set of objects, even though the techniques differ greatly in the details.",
      "ja": "TCPestatsListenertableは、サーバーが偽造または悪意のある接続の試みに圧倒されるSyn-Flood拒否攻撃の診断に役立つ情報を提供するように特別に設計されています。Syn-Floodingから防御するために使用できるいくつかの異なる手法がありますが、標準化されていない[EDD06]。これらのさまざまな手法はすべて、テクニックの詳細が大きく異なる場合でも、一般的なオブジェクトセットで計装可能な同じ基本的な特性を持っています。"
    },
    {
      "indent": 3,
      "text": "All SYN-flood defenses avoid allocating significant resources (memory or CPU) to incoming (passive open) connections until the connections meet some liveness criteria (to defend against forged IP source addresses) and the server has sufficient resources to process the incoming request. Note that allocating resources is an implementation-specific event that may not correspond to an observable protocol event (e.g., segments on the wire). There are two general concepts that can be applied to all known SYN-flood defenses. There is generally a well-defined event when a connection is allocated full resources, and a \"backlog\" -- a queue of embryonic connections that have been allocated only partial resources.",
      "ja": "すべてのSyn-Floodの防御は、接続がいくつかのlivenives基準を満たすまで（Forged IPソースアドレスから防御するため）、重要なリソース（メモリまたはCPU）を着信（パッシブオープン）接続に割り当てることを避け、サーバーには着信要求を処理するのに十分なリソースがあります。リソースの割り当ては、観察可能なプロトコルイベント（ワイヤー上のセグメントなど）に対応しない可能性のある実装固有のイベントであることに注意してください。既知のすべてのsyn-flood防御に適用できる2つの一般的な概念があります。一般に、接続が完全なリソースに割り当てられた場合、明確に定義されたイベントと「バックログ」（部分リソースのみが割り当てられた胚接続のキュー）があります。"
    },
    {
      "indent": 3,
      "text": "In many implementations, incoming TCP connections are allocated resources as a side effect of the POSIX [POSIX] accept() call. For this reason we use the terminology \"accepting a connection\" to refer to this event: committing sufficient network resources to process the incoming request. Accepting a connection typically entails allocating memory for the protocol control block [RFC793], the per-connection table rows described in this MIB and CPU resources, such as process table entries or threads.",
      "ja": "多くの実装では、受信TCP接続は、POSIX [POSIX] Accept（）Callの副作用としてリソースを割り当てられます。このため、このイベントを参照するために「接続を受け入れる」という用語を使用します。つまり、着信要求を処理するのに十分なネットワークリソースをコミットします。接続を受け入れるには、通常、プロセステーブルエントリやスレッドなどのこのMIBおよびCPUリソースで説明されている接続ごとのテーブル行、プロトコル制御ブロック[RFC793]にメモリを割り当てることを伴います。"
    },
    {
      "indent": 3,
      "text": "Note that it is not useful to accept connections before they are ESTABLISHED, because this would create an easy opportunity for Denial-of-Service attacks, using forged source IP addresses.",
      "ja": "接続が確立される前に受け入れることは役に立たないことに注意してください。これにより、Forged Source IPアドレスを使用して、サービス拒否攻撃の簡単な機会が生まれるためです。"
    },
    {
      "indent": 3,
      "text": "The backlog consists of connections that are in SYN-RCVD or ESTABLISHED states, that have not been accepted. For purposes of this MIB, we assume that these connections have been allocated some resources (e.g., an embryonic protocol control block), but not full resources (e.g., do not yet have MIB table rows).",
      "ja": "バックログは、syn-RCVDまたは確立された状態にある接続で構成されており、受け入れられていません。このMIBの目的のために、これらの接続にはいくつかのリソース（胚プロトコル制御ブロックなど）が割り当てられているが、完全なリソースではないと仮定します（たとえば、MIBテーブルの行はまだありません）。"
    },
    {
      "indent": 3,
      "text": "Note that some SYN-Flood defenses dispense with explicit SYN-RCVD state by cryptographically encoding the state in the ISS (initial sequence number sent) of the SYN-ACK (sometimes called a syn-cookie), and then using the sequence number of the first ACK to reconstruct the SYN-RCVD state before transitioning to the ESTABLISHED state. For these implementations there is no explicit representation of the SYN-RCVD state, and the backlog only consists of connections that are ESTABLISHED and are waiting to be ACCEPTED.",
      "ja": "Syn-Floodの一部は、Syn-ack（Syn-Cookieと呼ばれることもあります）のISS（Syn-Cookieと呼ばれることもあります）の状態を暗号化することにより、明示的なSyn-RCVD状態を分配し、次に確立された状態に移行する前に、Syn-RCVD状態を再構築する最初のACK。これらの実装では、Syn-RCVD状態の明示的な表現はなく、バックログは確立され、受け入れられるのを待っている接続でのみ構成されています。"
    },
    {
      "indent": 3,
      "text": "Furthermore, most SYN-flood defenses have some mechanism to throttle connections that might otherwise overwhelm this endpoint. They generally use some combination of discarding incoming SYNs and discarding connections already in the backlog. This does not cause all connections from legitimate clients to fail, as long as the clients retransmit the SYN or first ACK as specified in RFC 793. Most diversity in SYN flood defenses arise from variations in these algorithms to limit load, and therefore cannot be instrumented with a common standard MIB.",
      "ja": "さらに、ほとんどのSyn-Flood防御には、このエンドポイントを圧倒する可能性のある接続をスロットルするメカニズムがあります。彼らは一般に、着信シンを破棄し、すでにバックログに接続を破棄するという組み合わせを使用します。これにより、クライアントがRFC 793で指定されているSYNまたは最初のACKを再送信する限り、合法的なクライアントからのすべての接続が失敗するわけではありません。SYN洪水防御のほとんどの多様性は、これらのアルゴリズムの変動から負荷を制限することで生じるため、計装することはできません。一般的な標準MIBで。"
    },
    {
      "indent": 3,
      "text": "The Listen Table instruments all passively opened TCP connections in terms of observable protocol events (e.g., sent and received segments) and resource allocation events (entering the backlog and being accepted). This approach eases generalization to SYN-flood mechanisms that use alternate TCP state transition diagrams and implicit mechanisms to encode some states.",
      "ja": "Listen Table Instrumentsはすべて、観察可能なプロトコルイベント（送信および受信セグメントなど）およびリソース割り当てイベント（バックログの入りおよび受け入れ）の観点からTCP接続を受動的に開きました。このアプローチは、いくつかの状態をコードするために、代替TCP状態遷移図と暗黙のメカニズムを使用するSyn-Floodメカニズムへの一般化を容易にします。"
    },
    {
      "indent": 0,
      "text": "4. TCP Extended Statistics MIB",
      "section_title": true,
      "ja": "4. TCP拡張統計MIB"
    },
    {
      "indent": 3,
      "text": "This MIB module IMPORTS definitions from [RFC2578], [RFC2579], [RFC2580], [RFC2856], [RFC4022], and [RFC4502]. It uses REFERENCE clauses to refer to [RFC791], [RFC793], [RFC1122], [RFC1191], [RFC1323], [RFC2018], [RFC2581], [RFC2861], [RFC2883], [RFC2988], [RFC3168], [RFC3260], [RFC3517], [RFC3522], and [RFC3742].",
      "ja": "このMIBモジュールは、[RFC2578]、[RFC2579]、[RFC2580]、[RFC2856]、[RFC4022]、および[RFC4502]から定義をインポートします。参照節を使用して、[RFC791]、[RFC793]、[RFC1122]、[RFC1191]、[RFC1323]、[RFC2018]、[RFC2581]、[RFC2861]、[RFC2883]、[RFC2988]、[RFC2988]、[RFC2581]、[RFC2581]、[RFC2581]、[RFC2581]を参照しています。、[RFC3260]、[RFC3517]、[RFC3522]、および[RFC3742]。"
    },
    {
      "indent": 3,
      "text": "TCP-ESTATS-MIB DEFINITIONS ::= BEGIN\nIMPORTS\n       MODULE-IDENTITY, Counter32, Integer32, Unsigned32,\n       Gauge32, OBJECT-TYPE, mib-2,\n       NOTIFICATION-TYPE\n           FROM SNMPv2-SMI                 -- [RFC2578]\n       MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP\n           FROM SNMPv2-CONF                -- [RFC2580]\n       ZeroBasedCounter32\n           FROM RMON2-MIB                  -- [RFC4502]\n       ZeroBasedCounter64\n           FROM HCNUM-TC                   -- [RFC2856]\n       TEXTUAL-CONVENTION,\n       DateAndTime, TruthValue, TimeStamp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": " FROM SNMPv2-TC -- [RFC2579] tcpListenerEntry, tcpConnectionEntry FROM TCP-MIB; -- [RFC4022]",
      "ja": "SNMPV2-TCから -  [RFC2579] tcplistenerentry、tcp-mibのtcpconnectionEntry; -  [RFC4022]"
    },
    {
      "indent": 3,
      "text": "tcpEStatsMIB MODULE-IDENTITY LAST-UPDATED \"200705180000Z\" -- 18 May 2007 ORGANIZATION \"IETF TSV Working Group\" CONTACT-INFO \"Matt Mathis John Heffner Web100 Project Pittsburgh Supercomputing Center 300 S. Craig St. Pittsburgh, PA 15213 Email: mathis@psc.edu, jheffner@psc.edu",
      "ja": "TCPESTATSMIBモジュールのアイデンティティ最終アップデーション「200705180000Z \" -  2007年5月18日組織「IETF TSVワーキンググループ」コンタクトINFO\" Matt Mathis John Heffner Web100 Project Proction Supercomputing Center 300 S. Craig St. Pittsburgh、PA 15213メール：Mathis@PSC.edu、jheffner@psc.edu"
    },
    {
      "indent": 11,
      "text": "Rajiv Raghunarayan Cisco Systems Inc. San Jose, CA 95134 Phone: 408 853 9612 Email: raraghun@cisco.com",
      "ja": "Rajiv Raghunarayan Cisco Systems Inc. San Jose、CA 95134電話：408 853 9612メール：raraghun@cisco.com"
    },
    {
      "indent": 7,
      "text": " Jon Saperia 84 Kettell Plain Road Stow, MA 01775 Phone: 617-201-2655 Email: saperia@jdscons.com \" DESCRIPTION \"Documentation of TCP Extended Performance Instrumentation variables from the Web100 project. [Web100]",
      "ja": "Jon Saperia 84 Kettell Plain Road Stow、MA 01775電話：617-201-2655電子メール：saperia@jdscons.com \"説明\" TCPのドキュメントWeb100プロジェクトからのパフォーマンス計装変数。[Web100]"
    },
    {
      "indent": 12,
      "text": "All of the objects in this MIB MUST have the same persistence properties as the underlying TCP implementation. On a reboot, all zero-based counters MUST be cleared, all dynamically created table rows MUST be deleted, and all read-write objects MUST be restored to their default values.",
      "ja": "このMIBのすべてのオブジェクトには、基礎となるTCP実装と同じ永続性プロパティが必要です。再起動時に、すべてのゼロベースのカウンターをクリアする必要があり、動的に作成されたすべてのテーブル行を削除する必要があり、すべての読み取りワイトオブジェクトをデフォルト値に復元する必要があります。"
    },
    {
      "indent": 12,
      "text": "It is assumed that all TCP implementation have some initialization code (if nothing else to set IP addresses) that has the opportunity to adjust tcpEStatsConnTableLatency and other read-write scalars controlling the creation of the various tables, before establishing the first TCP connection. Implementations MAY also choose to make these control scalars persist across reboots.",
      "ja": "すべてのTCP実装には、最初のTCP接続を確立する前に、さまざまなテーブルの作成を制御するTCPestatsConntablelatencyおよびその他の読み取りワイトスカラーを調整する機会がある初期化コード（IPアドレスを設定するものが他にない場合）があると想定されています。実装は、再起動全体でこれらのコントロールスカラーを持続させることを選択する場合があります。"
    },
    {
      "indent": 12,
      "text": "Copyright (C) The IETF Trust (2007). This version of this MIB module is a part of RFC 4898; see the RFC itself for full legal notices.\"",
      "ja": "著作権（c）The IETF Trust（2007）。このMIBモジュールのこのバージョンは、RFC 4898の一部です。完全な法的通知については、RFC自体を参照してください。」"
    },
    {
      "indent": 7,
      "text": "REVISION \"200705180000Z\"    -- 18 May 2007\nDESCRIPTION\n    \"Initial version, published as RFC 4898.\"\n    ::= { mib-2 156 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsNotifications OBJECT IDENTIFIER ::= { tcpEStatsMIB 0 }\ntcpEStatsMIBObjects    OBJECT IDENTIFIER ::= { tcpEStatsMIB 1 }\ntcpEStatsConformance   OBJECT IDENTIFIER ::= { tcpEStatsMIB 2 }\ntcpEStats             OBJECT IDENTIFIER ::= { tcpEStatsMIBObjects 1 }\ntcpEStatsControl      OBJECT IDENTIFIER ::= { tcpEStatsMIBObjects 2 }\ntcpEStatsScalar       OBJECT IDENTIFIER ::= { tcpEStatsMIBObjects 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- -- Textual Conventions --",
      "ja": "---テキストコンベンション - "
    },
    {
      "indent": 3,
      "text": "TcpEStatsNegotiated  ::= TEXTUAL-CONVENTION\n   STATUS             current\n   DESCRIPTION\n       \"Indicates if some optional TCP feature was negotiated.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Enabled(1) indicates that the feature was successfully negotiated on, which generally requires both hosts to agree to use the feature.",
      "ja": "有効になっている（1）機能が正常にネゴシエートされたことを示します。これは、通常、両方のホストが機能の使用に同意することを要求します。"
    },
    {
      "indent": 11,
      "text": "selfDisabled(2) indicates that the local host refused the feature because it is not implemented, configured off, or refused for some other reason, such as the lack of resources.",
      "ja": "自己障害（2）は、リソースの不足など、他の理由で実装、設定、または拒否されていないため、地元のホストが機能を拒否したことを示しています。"
    },
    {
      "indent": 6,
      "text": "     peerDisabled(3) indicates that the local host was willing\n     to negotiate the feature, but the remote host did not\n     do so.\"\nSYNTAX INTEGER {\n             enabled(1),\n             selfDisabled(2),\n             peerDisabled(3)\n     }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- -- TCP Extended statistics scalars --",
      "ja": "--TCP拡張統計スカラー - "
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerTableLastChange OBJECT-TYPE SYNTAX TimeStamp MAX-ACCESS read-only STATUS current DESCRIPTION",
      "ja": "tcpestatsListenerTableLelastChangeオブジェクトタイプ構文タイムスタンプMax-Access読み取り専用ステータス現在の説明"
    },
    {
      "indent": 7,
      "text": "       \"The value of sysUpTime at the time of the last\n        creation or deletion of an entry in the tcpListenerTable.\n        If the number of entries has been unchanged since the\n        last re-initialization of the local network management\n        subsystem, then this object contains a zero value.\"\n::= { tcpEStatsScalar 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- The tcpEStatsControl Group\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- The scalar objects in this group are used to control the\n-- activation and deactivation of the TCP Extended Statistics\n-- tables and notifications in this module.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsControlPath  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n        \"Controls the activation of the TCP Path Statistics\n        table.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    A value 'true' indicates that the TCP Path Statistics\n    table is active, while 'false' indicates that the\n    table is inactive.\"\nDEFVAL          { false }\n::= { tcpEStatsControl 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsControlStack  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n        \"Controls the activation of the TCP Stack Statistics\n        table.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    A value 'true' indicates that the TCP Stack Statistics\n    table is active, while 'false' indicates that the\n    table is inactive.\"\nDEFVAL          { false }\n::= { tcpEStatsControl 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsControlApp  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-write\n       STATUS          current\n    DESCRIPTION\n        \"Controls the activation of the TCP Application\n        Statistics table.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    A value 'true' indicates that the TCP Application\n    Statistics table is active, while 'false' indicates\n    that the table is inactive.\"\nDEFVAL          { false }\n::= { tcpEStatsControl 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsControlTune  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n        \"Controls the activation of the TCP Tuning table.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    A value 'true' indicates that the TCP Tuning\n    table is active, while 'false' indicates that the\n    table is inactive.\"\nDEFVAL          { false }\n::= { tcpEStatsControl 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsControlNotify  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n        \"Controls the generation of all notifications defined in\n        this MIB.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    A value 'true' indicates that the notifications\n    are active, while 'false' indicates that the\n    notifications are inactive.\"\nDEFVAL          { false }\n::= { tcpEStatsControl 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsConnTableLatency OBJECT-TYPE\n    SYNTAX          Unsigned32\n    UNITS           \"seconds\"\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n        \"Specifies the number of seconds that the entity will\n         retain entries in the TCP connection tables, after the\n         connection first enters the closed state.  The entity\n         SHOULD provide a configuration option to enable\n            customization of this value.  A value of 0\n         results in entries being removed from the tables as soon as\n         the connection enters the closed state.  The value of\n         this object pertains to the following tables:\n           tcpEStatsConnectIdTable\n           tcpEStatsPerfTable\n           tcpEStatsPathTable\n           tcpEStatsStackTable\n           tcpEStatsAppTable\n           tcpEStatsTuneTable\"\n    DEFVAL { 0 }\n    ::= { tcpEStatsControl 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Listener Table\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF TcpEStatsListenerEntry\n    MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This table contains information about TCP Listeners,\n        in addition to the information maintained by the\n        tcpListenerTable RFC 4022.\"\n    ::= { tcpEStats 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerEntry OBJECT-TYPE\n    SYNTAX       TcpEStatsListenerEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in the table contains information about\n        a specific TCP Listener.\"\n    AUGMENTS { tcpListenerEntry }\n    ::= { tcpEStatsListenerTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsListenerEntry ::= SEQUENCE {\n        tcpEStatsListenerStartTime         TimeStamp,\n        tcpEStatsListenerSynRcvd           ZeroBasedCounter32,\n        tcpEStatsListenerInitial           ZeroBasedCounter32,\n        tcpEStatsListenerEstablished       ZeroBasedCounter32,\n        tcpEStatsListenerAccepted          ZeroBasedCounter32,\n        tcpEStatsListenerExceedBacklog     ZeroBasedCounter32,\n        tcpEStatsListenerHCSynRcvd         ZeroBasedCounter64,\n        tcpEStatsListenerHCInitial         ZeroBasedCounter64,\n        tcpEStatsListenerHCEstablished     ZeroBasedCounter64,\n           tcpEStatsListenerHCAccepted        ZeroBasedCounter64,\n        tcpEStatsListenerHCExceedBacklog   ZeroBasedCounter64,\n        tcpEStatsListenerCurConns          Gauge32,\n        tcpEStatsListenerMaxBacklog        Unsigned32,\n        tcpEStatsListenerCurBacklog        Gauge32,\n        tcpEStatsListenerCurEstabBacklog   Gauge32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerStartTime   OBJECT-TYPE\n    SYNTAX     TimeStamp\n    MAX-ACCESS read-only\n    STATUS     current\n    DESCRIPTION\n        \"The value of sysUpTime at the time this listener was\n        established.  If the current state was entered prior to\n        the last re-initialization of the local network management\n        subsystem, then this object contains a zero value.\"\n    ::= { tcpEStatsListenerEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerSynRcvd OBJECT-TYPE\n    SYNTAX     ZeroBasedCounter32\n    MAX-ACCESS read-only\n    STATUS     current\n    DESCRIPTION\n        \"The number of SYNs which have been received for this\n        listener.  The total number of failed connections for\n        all reasons can be estimated to be tcpEStatsListenerSynRcvd\n        minus tcpEStatsListenerAccepted and\n        tcpEStatsListenerCurBacklog.\"\n    ::= { tcpEStatsListenerEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerInitial     OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter32\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections for which the Listener\n       has allocated initial state and placed the\n       connection in the backlog.  This may happen in the\n       SYN-RCVD or ESTABLISHED states, depending on the\n       implementation.\"\n    ::= { tcpEStatsListenerEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerEstablished OBJECT-TYPE SYNTAX ZeroBasedCounter32 MAX-ACCESS read-only STATUS current DESCRIPTION",
      "ja": "tcpestatsListenerErtabled Object-Type Syntax ZerobasedCounter32 Max-Access読み取り専用ステータス現在の説明"
    },
    {
      "indent": 7,
      "text": "    \"The number of connections that have been established to\n    this endpoint (e.g., the number of first ACKs that have\n    been received for this listener).\"\n::= { tcpEStatsListenerEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerAccepted    OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter32\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections for which the Listener\n       has successfully issued an accept, removing the connection\n       from the backlog.\"\n    ::= { tcpEStatsListenerEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerExceedBacklog OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter32\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections dropped from the\n      backlog by this listener due to all reasons.  This\n      includes all connections that are allocated initial\n      resources, but are not accepted for some reason.\"\n    ::= { tcpEStatsListenerEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerHCSynRcvd OBJECT-TYPE\n    SYNTAX     ZeroBasedCounter64\n    MAX-ACCESS read-only\n    STATUS     current\n    DESCRIPTION\n        \"The number of SYNs that have been received for this\n        listener on systems that can process (or reject) more\n        than 1 million connections per second.  See\n        tcpEStatsListenerSynRcvd.\"\n    ::= { tcpEStatsListenerEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerHCInitial     OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter64\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections for which the Listener\n       has allocated initial state and placed the connection\n       in the backlog on systems that can process (or reject)\n       more than 1 million connections per second.  See\n       tcpEStatsListenerInitial.\"\n    ::= { tcpEStatsListenerEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerHCEstablished OBJECT-TYPE\n    SYNTAX     ZeroBasedCounter64\n    MAX-ACCESS read-only\n    STATUS     current\n    DESCRIPTION\n        \"The number of connections that have been established to\n        this endpoint on systems that can process (or reject) more\n        than 1 million connections per second.  See\n        tcpEStatsListenerEstablished.\"\n    ::= { tcpEStatsListenerEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerHCAccepted    OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter64\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections for which the Listener\n       has successfully issued an accept, removing the connection\n       from the backlog on systems that can process (or reject)\n       more than 1 million connections per second.  See\n       tcpEStatsListenerAccepted.\"\n    ::= { tcpEStatsListenerEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerHCExceedBacklog OBJECT-TYPE\n   SYNTAX     ZeroBasedCounter64\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The total number of connections dropped from the\n      backlog by this listener due to all reasons on\n      systems that can process (or reject) more than\n      1 million connections per second.  See\n      tcpEStatsListenerExceedBacklog.\"\n    ::= { tcpEStatsListenerEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerCurConns   OBJECT-TYPE\n   SYNTAX     Gauge32\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The current number of connections in the ESTABLISHED\n       state, which have also been accepted.  It excludes\n       connections that have been established but not accepted\n       because they are still subject to being discarded to\n       shed load without explicit action by either endpoint.\"\n    ::= { tcpEStatsListenerEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerMaxBacklog OBJECT-TYPE",
      "ja": "tcpestatslistenermaxbacklogオブジェクトタイプ"
    },
    {
      "indent": 6,
      "text": "SYNTAX     Unsigned32\nMAX-ACCESS read-only\nSTATUS     current\nDESCRIPTION\n   \"The maximum number of connections allowed in the\n    backlog at one time.\"\n ::= { tcpEStatsListenerEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerCurBacklog OBJECT-TYPE SYNTAX Gauge32 MAX-ACCESS read-only STATUS current DESCRIPTION \"The current number of connections that are in the backlog. This gauge includes connections in ESTABLISHED or SYN-RECEIVED states for which the Listener has not yet issued an accept.",
      "ja": "TCPESTATSLISTENERCURBACKLOGオブジェクトタイプ構文ゲージ32 Max-Access読み取り専用ステータス現在の説明 \"バックログにある接続の現在の数。このゲージには、リスナーがまだ受け入れていない確立または同期状態の接続が含まれます。"
    },
    {
      "indent": 7,
      "text": "   If this listener is using some technique to implicitly\n   represent the SYN-RECEIVED states (e.g., by\n   cryptographically encoding the state information in the\n   initial sequence number, ISS), it MAY elect to exclude\n   connections in the SYN-RECEIVED state from the backlog.\"\n::= { tcpEStatsListenerEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsListenerCurEstabBacklog OBJECT-TYPE\n   SYNTAX     Gauge32\n   MAX-ACCESS read-only\n   STATUS     current\n   DESCRIPTION\n      \"The current number of connections in the backlog that are\n       in the ESTABLISHED state, but for which the Listener has\n       not yet issued an accept.\"\n    ::= { tcpEStatsListenerEntry 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- TCP Connection ID Table\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsConnectIdTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsConnectIdEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table maps information that uniquely identifies each active TCP connection to the connection ID used by other tables in this MIB Module. It is an extension of tcpConnectionTable in RFC 4022.",
      "ja": "TCPESTATSCONNECTIDTABLEオブジェクトタイプの構文型TCPestatsConnectIdentry Max-Access Not-Accessable Current Current説明 \"このテーブルは、このMIBモジュールの他のテーブルで使用される他のテーブルで使用される各テーブルIDへの各アクティブなTCP接続を一意に識別する情報をマップします。4022。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsConnectIdEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsConnectIdEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table maps a TCP connection\n        4-tuple to a connection index.\"\n    AUGMENTS { tcpConnectionEntry }\n    ::= { tcpEStatsConnectIdTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsConnectIdEntry ::= SEQUENCE {\n        tcpEStatsConnectIndex             Unsigned32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsConnectIndex  OBJECT-TYPE\n    SYNTAX          Unsigned32 (1..4294967295)\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n        \"A unique integer value assigned to each TCP Connection\n        entry.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    The RECOMMENDED algorithm is to begin at 1 and increase to\n    some implementation-specific maximum value and then start\n    again at 1 skipping values already in use.\"\n::= { tcpEStatsConnectIdEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Basic TCP Performance Statistics\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsPerfEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION",
      "ja": "tcpestatspertableオブジェクトタイプの構文シーケンスtcpestatsperfentry max-accessアクセス不可能なステータス現在の説明"
    },
    {
      "indent": 11,
      "text": "\"This table contains objects that are useful for measuring TCP performance and first line problem diagnosis. Most objects in this table directly expose some TCP state variable or are easily implemented as simple functions (e.g., the maximum value) of TCP state variables.",
      "ja": "「この表には、TCPのパフォーマンスと最初のラインの問題診断を測定するのに役立つオブジェクトが含まれています。この表のほとんどのオブジェクトは、TCP状態変数を直接公開するか、TCP状態変数の単純な関数（最大値など）として簡単に実装されます。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsPerfEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.\"\n   INDEX { tcpEStatsConnectIndex }\n   ::= { tcpEStatsPerfTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsPerfEntry ::= SEQUENCE {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    tcpEStatsPerfSegsOut                ZeroBasedCounter32,\n    tcpEStatsPerfDataSegsOut            ZeroBasedCounter32,\n    tcpEStatsPerfDataOctetsOut          ZeroBasedCounter32,\n    tcpEStatsPerfHCDataOctetsOut        ZeroBasedCounter64,\n    tcpEStatsPerfSegsRetrans            ZeroBasedCounter32,\n    tcpEStatsPerfOctetsRetrans          ZeroBasedCounter32,\n    tcpEStatsPerfSegsIn                 ZeroBasedCounter32,\n    tcpEStatsPerfDataSegsIn             ZeroBasedCounter32,\n    tcpEStatsPerfDataOctetsIn           ZeroBasedCounter32,\n    tcpEStatsPerfHCDataOctetsIn         ZeroBasedCounter64,\n    tcpEStatsPerfElapsedSecs            ZeroBasedCounter32,\n    tcpEStatsPerfElapsedMicroSecs       ZeroBasedCounter32,\n    tcpEStatsPerfStartTimeStamp         DateAndTime,\n    tcpEStatsPerfCurMSS                 Gauge32,\n    tcpEStatsPerfPipeSize               Gauge32,\n    tcpEStatsPerfMaxPipeSize            Gauge32,\n    tcpEStatsPerfSmoothedRTT            Gauge32,\n    tcpEStatsPerfCurRTO                 Gauge32,\n    tcpEStatsPerfCongSignals            ZeroBasedCounter32,\n    tcpEStatsPerfCurCwnd                Gauge32,\n    tcpEStatsPerfCurSsthresh            Gauge32,\n    tcpEStatsPerfTimeouts               ZeroBasedCounter32,\n    tcpEStatsPerfCurRwinSent            Gauge32,\n           tcpEStatsPerfMaxRwinSent            Gauge32,\n    tcpEStatsPerfZeroRwinSent           ZeroBasedCounter32,\n    tcpEStatsPerfCurRwinRcvd            Gauge32,\n    tcpEStatsPerfMaxRwinRcvd            Gauge32,\n    tcpEStatsPerfZeroRwinRcvd           ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTransRwin        ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTransCwnd        ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTransSnd         ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTimeRwin         ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTimeCwnd         ZeroBasedCounter32,\n    tcpEStatsPerfSndLimTimeSnd          ZeroBasedCounter32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects provide statistics on aggregate\n--  segments and data sent on a connection.  These provide a\n--  direct measure of the Internet capacity consumed by a\n--  connection.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSegsOut  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The total number of segments sent.\"\n    ::= { tcpEStatsPerfEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfDataSegsOut  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of segments sent containing a positive length\n        data segment.\"\n    ::= { tcpEStatsPerfEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfDataOctetsOut  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets of data contained in transmitted\n        segments, including retransmitted data.  Note that this does\n        not include TCP headers.\"\n    ::= { tcpEStatsPerfEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfHCDataOctetsOut  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter64\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets of data contained in transmitted\n        segments, including retransmitted data, on systems that can\n        transmit more than 10 million bits per second.  Note that\n        this does not include TCP headers.\"\n    ::= { tcpEStatsPerfEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSegsRetrans  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of segments transmitted containing at least some\n        retransmitted data.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfOctetsRetrans  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets retransmitted.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSegsIn  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The total number of segments received.\"\n    ::= { tcpEStatsPerfEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfDataSegsIn  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of segments received containing a positive",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    length data segment.\"\n::= { tcpEStatsPerfEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfDataOctetsIn  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets contained in received data segments,\n        including retransmitted data.  Note that this does not\n        include TCP headers.\"\n    ::= { tcpEStatsPerfEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfHCDataOctetsIn  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter64\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets contained in received data segments,\n        including retransmitted data, on systems that can receive\n        more than 10 million bits per second.  Note that this does\n        not include TCP headers.\"\n    ::= { tcpEStatsPerfEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfElapsedSecs  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"seconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The seconds part of the time elapsed between\n        tcpEStatsPerfStartTimeStamp and the most recent protocol\n        event (segment sent or received).\"\n    ::= { tcpEStatsPerfEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfElapsedMicroSecs  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"microseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The micro-second part of time elapsed between\n        tcpEStatsPerfStartTimeStamp to the most recent protocol\n        event (segment sent or received).  This may be updated in\n        whatever time granularity is the system supports.\"\n    ::= { tcpEStatsPerfEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfStartTimeStamp  OBJECT-TYPE\n    SYNTAX          DateAndTime\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Time at which this row was created and all\n        ZeroBasedCounters in the row were initialized to zero.\"\n    ::= { tcpEStatsPerfEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects can be used to fit minimal\n--  performance models to the TCP data rate.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurMSS  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current maximum segment size (MSS), in octets.\"\n    REFERENCE\n       \"RFC 1122, Requirements for Internet Hosts - Communication\n        Layers\"\n    ::= { tcpEStatsPerfEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfPipeSize  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The TCP senders current estimate of the number of\n        unacknowledged data octets in the network.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "While not in recovery (e.g., while the receiver is not reporting missing data to the sender), this is precisely the same as 'Flight size' as defined in RFC 2581, which can be computed as SND.NXT minus SND.UNA. [RFC793]",
      "ja": "回復中ではありませんが（たとえば、受信者は欠損データを送信者に報告していませんが）、これはRFC 2581で定義されている「フライトサイズ」とまったく同じです。[RFC793]"
    },
    {
      "indent": 11,
      "text": "During recovery, the TCP sender has incomplete information about the state of the network (e.g., which segments are lost vs reordered, especially if the return path is also dropping TCP acknowledgments). Current TCP standards do not mandate any specific algorithm for estimating the number of unacknowledged data octets in the network.",
      "ja": "回復中、TCP送信者はネットワークの状態に関する不完全な情報を持っています（例えば、特に戻りパスがTCP謝辞を削除している場合、セグメントが並べ替えられます）。現在のTCP標準では、ネットワーク内の未充填データオクテットの数を推定するための特定のアルゴリズムを義務付けません。"
    },
    {
      "indent": 11,
      "text": "RFC 3517 describes a conservative algorithm to use SACK information to estimate the number of unacknowledged data octets in the network. tcpEStatsPerfPipeSize object SHOULD be the same as 'pipe' as defined in RFC 3517 if it is implemented. (Note that while not in recovery the pipe algorithm yields the same values as flight size).",
      "ja": "RFC 3517は、サック情報を使用してネットワーク内の未充填データのオクテットの数を推定する保守的なアルゴリズムを説明しています。tcpestatsperfpipesizeオブジェクトは、実装されている場合、RFC 3517で定義されている「パイプ」と同じである必要があります。（回復中ではないが、パイプアルゴリズムは飛行サイズと同じ値を生成することに注意してください）。"
    },
    {
      "indent": 7,
      "text": "    If RFC 3517 is not implemented, the data octets in flight\n    SHOULD be estimated as SND.NXT minus SND.UNA adjusted by\n    some measure of the data that has left the network and\n    retransmitted data.  For example, with Reno or NewReno style\n    TCP, the number of duplicate acknowledgment is used to\n    count the number of segments that have left the network.\n    That is,\n    PipeSize=SND.NXT-SND.UNA+(retransmits-dupacks)*CurMSS\"\nREFERENCE\n   \"RFC 793, RFC 2581, RFC 3517\"\n::= { tcpEStatsPerfEntry 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfMaxPipeSize  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum value of tcpEStatsPerfPipeSize, for this\n        connection.\"\n    REFERENCE\n       \"RFC 793, RFC 2581, RFC 3517\"\n    ::= { tcpEStatsPerfEntry 16 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSmoothedRTT  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The smoothed round trip time used in calculation of the\n        RTO. See SRTT in [RFC2988].\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPerfEntry 17 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurRTO  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"The current value of the retransmit timer RTO.\"\nREFERENCE\n   \"RFC 2988, Computing TCP's Retransmission Timer\"\n::= { tcpEStatsPerfEntry 18 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCongSignals  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of multiplicative downward congestion window\n        adjustments due to all forms of congestion signals,\n        including Fast Retransmit, Explicit Congestion Notification\n        (ECN), and timeouts.  This object summarizes all events that\n        invoke the MD portion of Additive Increase Multiplicative\n        Decrease (AIMD) congestion control, and as such is the best\n        indicator of how a cwnd is being affected by congestion.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that retransmission timeouts multiplicatively reduce\n    the window implicitly by setting ssthresh, and SHOULD be\n    included in tcpEStatsPerfCongSignals.  In order to minimize\n    spurious congestion indications due to out-of-order\n    segments, tcpEStatsPerfCongSignals SHOULD be incremented in\n    association with the Fast Retransmit algorithm.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsPerfEntry 19 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurCwnd  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current congestion window, in octets.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsPerfEntry 20 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurSsthresh  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current slow start threshold in octets.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "::= { tcpEStatsPerfEntry 21 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfTimeouts  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of times the retransmit timeout has expired when\n        the RTO backoff multiplier is equal to one.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPerfEntry 22 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects instrument receiver window updates\n--  sent by the local receiver to the remote sender.  These can\n--  be used to determine if the local receiver is exerting flow\n--  control back pressure on the remote sender.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurRwinSent  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The most recent window advertisement sent, in octets.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 23 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfMaxRwinSent  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum window advertisement sent, in octets.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 24 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfZeroRwinSent  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of acknowledgments sent announcing a zero",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    receive window, when the previously announced window was\n    not zero.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsPerfEntry 25 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects instrument receiver window updates\n--  from the far end-system to determine if the remote receiver\n--  has sufficient buffer space or is exerting flow-control\n--  back pressure on the local sender.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfCurRwinRcvd  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The most recent window advertisement received, in octets.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 26 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfMaxRwinRcvd  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum window advertisement received, in octets.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 27 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfZeroRwinRcvd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of acknowledgments received announcing a zero\n        receive window, when the previously announced window was\n        not zero.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 28 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--",
      "ja": " - "
    },
    {
      "indent": 3,
      "text": "--  The following optional objects can be used to quickly\n--  identify which subsystems are limiting TCP performance.\n--  There are three parallel pairs of instruments that measure\n--  the extent to which TCP performance is limited by the\n--  announced receiver window (indicating a receiver\n--  bottleneck), the current congestion window or\n--  retransmission timeout (indicating a path bottleneck) and\n--  all others events (indicating a sender bottleneck).\n--\n--  These instruments SHOULD be updated every time the TCP\n--  output routine stops sending data.  The elapsed time since\n--  the previous stop is accumulated into the appropriate\n--  object as determined by the previous stop reason (e.g.,\n--  stop state).  The current stop reason determines which timer\n--  will be updated the next time TCP output stops.\n--\n--  Since there is no explicit stop at the beginning of a\n--  timeout, it is necessary to retroactively reclassify the\n--  previous stop as 'Congestion Limited'.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTransRwin  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of transitions into the 'Receiver Limited' state\n        from either the 'Congestion Limited' or 'Sender Limited'\n        states.  This state is entered whenever TCP transmission\n        stops because the sender has filled the announced receiver\n        window, i.e., when SND.NXT has advanced to SND.UNA +\n        SND.WND - 1 as described in RFC 793.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsPerfEntry 31 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTransCwnd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of transitions into the 'Congestion Limited'\n        state from either the 'Receiver Limited' or 'Sender\n        Limited' states.  This state is entered whenever TCP\n        transmission stops because the sender has reached some\n        limit defined by congestion control (e.g., cwnd) or other\n        algorithms (retransmission timeouts) designed to control\n        network traffic.  See the definition of 'CONGESTION WINDOW'\n           in RFC 2581.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsPerfEntry 32 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTransSnd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of transitions into the 'Sender Limited' state\n        from either the 'Receiver Limited' or 'Congestion Limited'\n        states.  This state is entered whenever TCP transmission\n        stops due to some sender limit such as running out of\n        application data or other resources and the Karn algorithm.\n        When TCP stops sending data for any reason, which cannot be\n        classified as Receiver Limited or Congestion Limited, it\n        MUST be treated as Sender Limited.\"\n    ::= { tcpEStatsPerfEntry 33 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTimeRwin  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The cumulative time spent in the 'Receiver Limited' state.\n        See tcpEStatsPerfSndLimTransRwin.\"\n    ::= { tcpEStatsPerfEntry 34 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTimeCwnd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The cumulative time spent in the 'Congestion Limited'\n        state.  See tcpEStatsPerfSndLimTransCwnd.  When there is a\n        retransmission timeout, it SHOULD be counted in\n        tcpEStatsPerfSndLimTimeCwnd (and not the cumulative time\n        for some other state.)\"\n    ::= { tcpEStatsPerfEntry 35 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPerfSndLimTimeSnd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n       DESCRIPTION\n       \"The cumulative time spent in the 'Sender Limited' state.\n        See tcpEStatsPerfSndLimTransSnd.\"\n    ::= { tcpEStatsPerfEntry 36 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Statistics for diagnosing path problems\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsPathEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table contains objects that can be used to infer detailed behavior of the Internet path, such as the extent that there is reordering, ECN bits, and if RTT fluctuations are correlated to losses.",
      "ja": "tcpestatspathtableオブジェクトタイプタイプの構文シーケンスtcpestatspathentry max-accessアクセス不可能なステータス現在の説明 \"このテーブルには、並べ替え、ecnビット、およびrttの場合など、インターネットパスの詳細な動作を推測するために使用できるオブジェクトが含まれています。変動は損失と相関しています。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsPathEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.\"\n   INDEX { tcpEStatsConnectIndex }\n   ::= { tcpEStatsPathTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsPathEntry ::= SEQUENCE {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    tcpEStatsPathRetranThresh           Gauge32,\n    tcpEStatsPathNonRecovDAEpisodes     ZeroBasedCounter32,\n    tcpEStatsPathSumOctetsReordered     ZeroBasedCounter32,\n    tcpEStatsPathNonRecovDA             ZeroBasedCounter32,\n    tcpEStatsPathSampleRTT              Gauge32,\n    tcpEStatsPathRTTVar                 Gauge32,\n    tcpEStatsPathMaxRTT                 Gauge32,\n    tcpEStatsPathMinRTT                 Gauge32,\n    tcpEStatsPathSumRTT                 ZeroBasedCounter32,\n           tcpEStatsPathHCSumRTT               ZeroBasedCounter64,\n    tcpEStatsPathCountRTT               ZeroBasedCounter32,\n    tcpEStatsPathMaxRTO                 Gauge32,\n    tcpEStatsPathMinRTO                 Gauge32,\n    tcpEStatsPathIpTtl                  Unsigned32,\n    tcpEStatsPathIpTosIn                OCTET STRING,\n    tcpEStatsPathIpTosOut               OCTET STRING,\n    tcpEStatsPathPreCongSumCwnd         ZeroBasedCounter32,\n    tcpEStatsPathPreCongSumRTT          ZeroBasedCounter32,\n    tcpEStatsPathPostCongSumRTT         ZeroBasedCounter32,\n    tcpEStatsPathPostCongCountRTT       ZeroBasedCounter32,\n    tcpEStatsPathECNsignals             ZeroBasedCounter32,\n    tcpEStatsPathDupAckEpisodes         ZeroBasedCounter32,\n    tcpEStatsPathRcvRTT                 Gauge32,\n    tcpEStatsPathDupAcksOut             ZeroBasedCounter32,\n    tcpEStatsPathCERcvd                 ZeroBasedCounter32,\n    tcpEStatsPathECESent                ZeroBasedCounter32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects can be used to infer segment\n--  reordering on the path from the local sender to the remote\n--  receiver.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathRetranThresh  OBJECT-TYPE\n    SYNTAX          Gauge32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of duplicate acknowledgments required to trigger\n        Fast Retransmit.  Note that although this is constant in\n        traditional Reno TCP implementations, it is adaptive in\n        many newer TCPs.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsPathEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathNonRecovDAEpisodes  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of duplicate acknowledgment episodes that did\n        not trigger a Fast Retransmit because ACK advanced prior to\n        the number of duplicate acknowledgments reaching\n        RetranThresh.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "In many implementations this is the number of times the 'dupacks' counter is set to zero when it is non-zero but less than RetranThresh.",
      "ja": "多くの実装では、これは「Dupacks」カウンターがゼロではないが、retranthreshよりも少ない場合にゼロに設定されている回数です。"
    },
    {
      "indent": 7,
      "text": "    Note that the change in tcpEStatsPathNonRecovDAEpisodes\n    divided by the change in tcpEStatsPerfDataSegsOut is an\n    estimate of the frequency of data reordering on the forward\n    path over some interval.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsPathEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathSumOctetsReordered  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The sum of the amounts SND.UNA advances on the\n        acknowledgment which ends a dup-ack episode without a\n        retransmission.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note the change in tcpEStatsPathSumOctetsReordered divided\n    by the change in tcpEStatsPathNonRecovDAEpisodes is an\n    estimates of the average reordering distance, over some\n    interval.\"\n::= { tcpEStatsPathEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathNonRecovDA  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Duplicate acks (or SACKS) that did not trigger a Fast\n        Retransmit because ACK advanced prior to the number of\n        duplicate acknowledgments reaching RetranThresh.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "In many implementations, this is the sum of the 'dupacks' counter, just before it is set to zero because ACK advanced without a Fast Retransmit.",
      "ja": "多くの実装では、これは「Dupacks」カウンターの合計であり、ACKは速い再送信なしで進行するため、ゼロに設定される直前です。"
    },
    {
      "indent": 7,
      "text": "    Note that the change in tcpEStatsPathNonRecovDA divided by\n    the change in tcpEStatsPathNonRecovDAEpisodes is an\n    estimate of the average reordering distance in segments\n    over some interval.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsPathEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects instrument the round trip\n--  time estimator and the retransmission timeout timer.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathSampleRTT  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The most recent raw round trip time measurement used in\n        calculation of the RTO.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathRTTVar  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The round trip time variation used in calculation of the\n        RTO.  See RTTVAR in [RFC2988].\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathMaxRTT  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum sampled round trip time.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathMinRTT  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The minimum sampled round trip time.\"\n    REFERENCE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"RFC 2988, Computing TCP's Retransmission Timer\"\n::= { tcpEStatsPathEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathSumRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The sum of all sampled round trip times.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that the change in tcpEStatsPathSumRTT divided by the\n    change in tcpEStatsPathCountRTT is the mean RTT, uniformly\n    averaged over an enter interval.\"\nREFERENCE\n   \"RFC 2988, Computing TCP's Retransmission Timer\"\n::= { tcpEStatsPathEntry 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathHCSumRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter64\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The sum of all sampled round trip times, on all systems\n        that implement multiple concurrent RTT measurements.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that the change in tcpEStatsPathHCSumRTT divided by\n    the change in tcpEStatsPathCountRTT is the mean RTT,\n    uniformly averaged over an enter interval.\"\nREFERENCE\n   \"RFC 2988, Computing TCP's Retransmission Timer\"\n::= { tcpEStatsPathEntry 16 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathCountRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of round trip time samples included in\n        tcpEStatsPathSumRTT and tcpEStatsPathHCSumRTT.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 17 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathMaxRTO  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n       MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum value of the retransmit timer RTO.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 18 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathMinRTO  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The minimum value of the retransmit timer RTO.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsPathEntry 19 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects provide information about\n--  how TCP is using the IP layer.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathIpTtl  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of the TTL field carried in the most recently\n        received IP header.  This is sometimes useful to detect\n        changing or unstable routes.\"\n    REFERENCE\n       \"RFC 791, Internet Protocol\"\n    ::= { tcpEStatsPathEntry 20 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathIpTosIn  OBJECT-TYPE\n    SYNTAX          OCTET STRING (SIZE(1))\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of the IPv4 Type of Service octet, or the IPv6\n        traffic class octet, carried in the most recently received\n        IP header.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "This is useful to diagnose interactions between TCP and any IP layer packet scheduling and delivery policy, which might be in effect to implement Diffserv.\"",
      "ja": "これは、TCPとIPレイヤーパケットのスケジューリングと配信ポリシーとの間の相互作用を診断するのに役立ちます。"
    },
    {
      "indent": 7,
      "text": "REFERENCE\n   \"RFC 3260, New Terminology and Clarifications for Diffserv\"\n::= { tcpEStatsPathEntry 21 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathIpTosOut  OBJECT-TYPE\n    SYNTAX          OCTET STRING (SIZE(1))\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of the IPv4 Type Of Service octet, or the IPv6\n        traffic class octet, carried in the most recently\n        transmitted IP header.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    This is useful to diagnose interactions between TCP and any\n    IP layer packet scheduling and delivery policy, which might\n    be in effect to implement Diffserv.\"\nREFERENCE\n   \"RFC 3260, New Terminology and Clarifications for Diffserv\"\n::= { tcpEStatsPathEntry 22 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects characterize the congestion\n--  feedback signals by collecting statistics on how the\n--  congestion events are correlated to losses, changes in RTT\n--  and other protocol events.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathPreCongSumCwnd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The sum of the values of the congestion window, in octets,\n        captured each time a congestion signal is received.  This\n        MUST be updated each time tcpEStatsPerfCongSignals is\n        incremented, such that the change in\n        tcpEStatsPathPreCongSumCwnd divided by the change in\n        tcpEStatsPerfCongSignals is the average window (over some\n        interval) just prior to a congestion signal.\"\n    ::= { tcpEStatsPathEntry 23 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathPreCongSumRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"Sum of the last sample of the RTT (tcpEStatsPathSampleRTT)\n    prior to the received congestion signals.  This MUST be\n    updated each time tcpEStatsPerfCongSignals is incremented,\n    such that the change in tcpEStatsPathPreCongSumRTT divided by\n    the change in tcpEStatsPerfCongSignals is the average RTT\n    (over some interval) just prior to a congestion signal.\"\n::= { tcpEStatsPathEntry 24 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathPostCongSumRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Sum of the first sample of the RTT (tcpEStatsPathSampleRTT)\n        following each congestion signal.  Such that the change in\n        tcpEStatsPathPostCongSumRTT divided by the change in\n        tcpEStatsPathPostCongCountRTT is the average RTT (over some\n        interval) just after a congestion signal.\"\n    ::= { tcpEStatsPathEntry 25 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathPostCongCountRTT  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"milliseconds\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of RTT samples included in\n        tcpEStatsPathPostCongSumRTT such that the change in\n        tcpEStatsPathPostCongSumRTT divided by the change in\n        tcpEStatsPathPostCongCountRTT is the average RTT (over some\n        interval) just after a congestion signal.\"\n    ::= { tcpEStatsPathEntry 26 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects can be used to detect other\n--  types of non-loss congestion signals such as source quench\n--  or ECN.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathECNsignals  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of congestion signals delivered to the TCP\n        sender via explicit congestion notification (ECN).  This is\n        typically the number of segments bearing Echo Congestion\n           Experienced (ECE) bits, but\n        should also include segments failing the ECN nonce check or\n        other explicit congestion signals.\"\n    REFERENCE\n       \"RFC 3168, The Addition of Explicit Congestion Notification\n        (ECN) to IP\"\n    ::= { tcpEStatsPathEntry 27 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects are receiver side\n--  instruments of the path from the sender to the receiver.  In\n--  general, the receiver has less information about the state\n--  of the path because the receiver does not have a robust\n--  mechanism to infer the sender's actions.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathDupAckEpisodes  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of Duplicate Acks Sent when prior Ack was not\n        duplicate.  This is the number of times that a contiguous\n        series of duplicate acknowledgments have been sent.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    This is an indication of the number of data segments lost\n    or reordered on the path from the remote TCP endpoint to\n    the near TCP endpoint.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsPathEntry 28 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathRcvRTT  OBJECT-TYPE\n    SYNTAX          Gauge32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The receiver's estimate of the Path RTT.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Adaptive receiver window algorithms depend on the receiver\n    to having a good estimate of the path RTT.\"\n::= { tcpEStatsPathEntry 29 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathDupAcksOut  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"The number of duplicate ACKs sent.  The ratio of the change\n    in tcpEStatsPathDupAcksOut to the change in\n    tcpEStatsPathDupAckEpisodes is an indication of reorder or\n    recovery distance over some interval.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsPathEntry 30 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathCERcvd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of segments received with IP headers bearing\n        Congestion Experienced (CE) markings.\"\n    REFERENCE\n       \"RFC 3168, The Addition of Explicit Congestion Notification\n        (ECN) to IP\"\n    ::= { tcpEStatsPathEntry 31 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsPathECESent  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Number of times the Echo Congestion Experienced (ECE) bit\n        in the TCP header has been set (transitioned from 0 to 1),\n        due to a Congestion Experienced (CE) marking on an IP\n        header.  Note that ECE can be set and reset only once per\n        RTT, while CE can be set on many segments per RTT.\"\n    REFERENCE\n       \"RFC 3168, The Addition of Explicit Congestion Notification\n        (ECN) to IP\"\n    ::= { tcpEStatsPathEntry 32 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Statistics for diagnosing stack algorithms\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsStackEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table contains objects that are most useful for determining how well some of the TCP control algorithms are coping with this particular path.",
      "ja": "tcpestatsStackTableオブジェクトタイプの構文シーケンスTCPestatsStackEntry Max-Accessはアクセス不可能なステータス現在の説明 \"このテーブルには、TCPコントロールアルゴリズムの一部がこの特定のパスにどれだけ適しているかを判断するのに最も役立つオブジェクトが含まれています。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsStackEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.\"\n   INDEX { tcpEStatsConnectIndex }\n   ::= { tcpEStatsStackTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsStackEntry ::= SEQUENCE {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    tcpEStatsStackActiveOpen            TruthValue,\n    tcpEStatsStackMSSSent               Unsigned32,\n    tcpEStatsStackMSSRcvd               Unsigned32,\n    tcpEStatsStackWinScaleSent          Integer32,\n    tcpEStatsStackWinScaleRcvd          Integer32,\n    tcpEStatsStackTimeStamps            TcpEStatsNegotiated,\n    tcpEStatsStackECN                   TcpEStatsNegotiated,\n    tcpEStatsStackWillSendSACK          TcpEStatsNegotiated,\n    tcpEStatsStackWillUseSACK           TcpEStatsNegotiated,\n    tcpEStatsStackState                 INTEGER,\n    tcpEStatsStackNagle                 TruthValue,\n    tcpEStatsStackMaxSsCwnd             Gauge32,\n    tcpEStatsStackMaxCaCwnd             Gauge32,\n    tcpEStatsStackMaxSsthresh           Gauge32,\n    tcpEStatsStackMinSsthresh           Gauge32,\n    tcpEStatsStackInRecovery            INTEGER,\n    tcpEStatsStackDupAcksIn             ZeroBasedCounter32,\n    tcpEStatsStackSpuriousFrDetected    ZeroBasedCounter32,\n    tcpEStatsStackSpuriousRtoDetected   ZeroBasedCounter32,\n    tcpEStatsStackSoftErrors            ZeroBasedCounter32,\n    tcpEStatsStackSoftErrorReason       INTEGER,\n    tcpEStatsStackSlowStart             ZeroBasedCounter32,\n    tcpEStatsStackCongAvoid             ZeroBasedCounter32,\n    tcpEStatsStackOtherReductions       ZeroBasedCounter32,\n    tcpEStatsStackCongOverCount         ZeroBasedCounter32,\n    tcpEStatsStackFastRetran            ZeroBasedCounter32,\n    tcpEStatsStackSubsequentTimeouts    ZeroBasedCounter32,\n           tcpEStatsStackCurTimeoutCount       Gauge32,\n    tcpEStatsStackAbruptTimeouts        ZeroBasedCounter32,\n    tcpEStatsStackSACKsRcvd             ZeroBasedCounter32,\n    tcpEStatsStackSACKBlocksRcvd        ZeroBasedCounter32,\n    tcpEStatsStackSendStall             ZeroBasedCounter32,\n    tcpEStatsStackDSACKDups             ZeroBasedCounter32,\n    tcpEStatsStackMaxMSS                Gauge32,\n    tcpEStatsStackMinMSS                Gauge32,\n    tcpEStatsStackSndInitial            Unsigned32,\n    tcpEStatsStackRecInitial            Unsigned32,\n    tcpEStatsStackCurRetxQueue          Gauge32,\n    tcpEStatsStackMaxRetxQueue          Gauge32,\n    tcpEStatsStackCurReasmQueue         Gauge32,\n    tcpEStatsStackMaxReasmQueue         Gauge32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects reflect TCP options carried on the\n--  SYN or SYN-ACK.  These options are used to provide\n--  additional protocol parameters or to enable various\n--  optional TCP features or algorithms.\n--\n--  Except as noted, the TCP protocol does not permit these\n--  options to change after the SYN exchange.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackActiveOpen  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"True(1) if the local connection traversed the SYN-SENT\n        state, else false(2).\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsStackEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMSSSent  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value sent in an MSS option, or zero if none.\"\n    REFERENCE\n       \"RFC 1122, Requirements for Internet Hosts - Communication\n        Layers\"\n    ::= { tcpEStatsStackEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMSSRcvd  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value received in an MSS option, or zero if none.\"\n    REFERENCE\n       \"RFC 1122, Requirements for Internet Hosts - Communication\n        Layers\"\n    ::= { tcpEStatsStackEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackWinScaleSent  OBJECT-TYPE\n    SYNTAX          Integer32 (-1..14)\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of the transmitted window scale option if one was\n        sent; otherwise, a value of -1.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that if both tcpEStatsStackWinScaleSent and\n    tcpEStatsStackWinScaleRcvd are not -1, then Rcv.Wind.Scale\n    will be the same as this value and used to scale receiver\n    window announcements from the local host to the remote\n    host.\"\nREFERENCE\n   \"RFC 1323, TCP Extensions for High Performance\"\n::= { tcpEStatsStackEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackWinScaleRcvd  OBJECT-TYPE\n    SYNTAX          Integer32 (-1..14)\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of the received window scale option if one was\n        received; otherwise, a value of -1.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that if both tcpEStatsStackWinScaleSent and\n    tcpEStatsStackWinScaleRcvd are not -1, then Snd.Wind.Scale\n    will be the same as this value and used to scale receiver\n    window announcements from the remote host to the local\n    host.\"\nREFERENCE\n   \"RFC 1323, TCP Extensions for High Performance\"\n::= { tcpEStatsStackEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackTimeStamps  OBJECT-TYPE\n    SYNTAX          TcpEStatsNegotiated\n    MAX-ACCESS      read-only\n       STATUS          current\n    DESCRIPTION\n       \"Enabled(1) if TCP timestamps have been negotiated on,\n        selfDisabled(2) if they are disabled or not implemented on\n        the local host, or peerDisabled(3) if not negotiated by the\n        remote hosts.\"\n    REFERENCE\n       \"RFC 1323, TCP Extensions for High Performance\"\n    ::= { tcpEStatsStackEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackECN  OBJECT-TYPE\n    SYNTAX          TcpEStatsNegotiated\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Enabled(1) if Explicit Congestion Notification (ECN) has\n        been negotiated on, selfDisabled(2) if it is disabled or\n        not implemented on the local host, or peerDisabled(3) if\n        not negotiated by the remote hosts.\"\n    REFERENCE\n       \"RFC 3168, The Addition of Explicit Congestion Notification\n        (ECN) to IP\"\n    ::= { tcpEStatsStackEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackWillSendSACK  OBJECT-TYPE\n    SYNTAX          TcpEStatsNegotiated\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Enabled(1) if the local host will send SACK options,\n        selfDisabled(2) if SACK is disabled or not implemented on\n        the local host, or peerDisabled(3) if the remote host did\n        not send the SACK-permitted option.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that SACK negotiation is not symmetrical.  SACK can\n    enabled on one side of the connection and not the other.\"\nREFERENCE\n   \"RFC 2018, TCP Selective Acknowledgement Options\"\n::= { tcpEStatsStackEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackWillUseSACK  OBJECT-TYPE\n    SYNTAX          TcpEStatsNegotiated\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Enabled(1) if the local host will process SACK options,\n        selfDisabled(2) if SACK is disabled or not implemented on\n        the local host, or peerDisabled(3) if the remote host sends\n           duplicate ACKs without SACK options, or the local host\n        otherwise decides not to process received SACK options.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Unlike other TCP options, the remote data receiver cannot explicitly indicate if it is able to generate SACK options. When sending data, the local host has to deduce if the remote receiver is sending SACK options. This object can transition from Enabled(1) to peerDisabled(3) after the SYN exchange.",
      "ja": "他のTCPオプションとは異なり、リモートデータレシーバーは、サックオプションを生成できるかどうかを明示的に示すことができません。データを送信するとき、ローカルホストは、リモートレシーバーがサックオプションを送信しているかどうかを推定する必要があります。このオブジェクトは、syn交換後に有効な（1）からpeerdisabled（3）に移行できます。"
    },
    {
      "indent": 7,
      "text": "    Note that SACK negotiation is not symmetrical.  SACK can\n    enabled on one side of the connection and not the other.\"\nREFERENCE\n   \"RFC 2018, TCP Selective Acknowledgement Options\"\n::= { tcpEStatsStackEntry 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following two objects reflect the current state of the\n--  connection.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackState  OBJECT-TYPE\n    SYNTAX          INTEGER {\n       tcpESStateClosed(1),\n       tcpESStateListen(2),\n       tcpESStateSynSent(3),\n       tcpESStateSynReceived(4),\n       tcpESStateEstablished(5),\n       tcpESStateFinWait1(6),\n       tcpESStateFinWait2(7),\n       tcpESStateCloseWait(8),\n       tcpESStateLastAck(9),\n       tcpESStateClosing(10),\n       tcpESStateTimeWait(11),\n       tcpESStateDeleteTcb(12)\n    }\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"An integer value representing the connection state from the\n        TCP State Transition Diagram.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "The value listen(2) is included only for parallelism to the old tcpConnTable, and SHOULD NOT be used because the listen state in managed by the tcpListenerTable.",
      "ja": "値を聞く（2）は、古いtcpconntableへの並列性のためにのみ含まれており、Tcplistenertableによって管理されているリスニング状態のために使用すべきではありません。"
    },
    {
      "indent": 7,
      "text": "    The value DeleteTcb(12) is included only for parallelism to\n    the tcpConnTable mechanism for terminating connections,\n           although this table does not permit writing.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsStackEntry 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackNagle  OBJECT-TYPE\n    SYNTAX          TruthValue\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"True(1) if the Nagle algorithm is being used, else\n        false(2).\"\n    REFERENCE\n       \"RFC 1122, Requirements for Internet Hosts - Communication\n        Layers\"\n    ::= { tcpEStatsStackEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects instrument the overall operation of\n--  TCP congestion control and data retransmissions.  These\n--  instruments are sufficient to fit the actual performance to\n--  an updated macroscopic performance model [RFC2581] [Mat97]\n--  [Pad98].\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxSsCwnd  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum congestion window used during Slow Start, in\n        octets.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxCaCwnd  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum congestion window used during Congestion\n        Avoidance, in octets.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxSsthresh  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum slow start threshold, excluding the initial\n        value.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMinSsthresh  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The minimum slow start threshold.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackInRecovery  OBJECT-TYPE\n    SYNTAX          INTEGER {\n       tcpESDataContiguous(1),\n       tcpESDataUnordered(2),\n       tcpESDataRecovery(3)\n    }\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"An integer value representing the state of the loss\n        recovery for this connection.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "tcpESDataContiguous(1) indicates that the remote receiver is reporting contiguous data (no duplicate acknowledgments or SACK options) and that there are no unacknowledged retransmissions.",
      "ja": "TCPESDATACONTIGUOUS（1）は、リモートレシーバーが連続データを報告していること（重複した謝辞またはサックオプション）を報告していること、および未解決の再送信がないことを示します。"
    },
    {
      "indent": 11,
      "text": "tcpESDataUnordered(2) indicates that the remote receiver is reporting missing or out-of-order data (e.g., sending duplicate acknowledgments or SACK options) and that there are no unacknowledged retransmissions (because the missing data has not yet been retransmitted).",
      "ja": "TCPESDATAUNORDED（2）は、リモートレシーバーが欠落または順序外データを報告していること（たとえば、重複した謝辞またはサックオプションを送信するなど）を示しており、不明瞭な再送信がないことを示しています（欠損データがまだ再送信されていないため）。"
    },
    {
      "indent": 7,
      "text": "    tcpESDataRecovery(3) indicates that the sender has\n    outstanding retransmitted data that is still\n           unacknowledged.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsStackEntry 16 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackDupAcksIn  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of duplicate ACKs received.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 17 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSpuriousFrDetected  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of acknowledgments reporting out-of-order\n        segments after the Fast Retransmit algorithm has already\n        retransmitted the segments. (For example as detected by the\n        Eifel algorithm).'\"\n    REFERENCE\n       \"RFC 3522, The Eifel Detection Algorithm for TCP\"\n    ::= { tcpEStatsStackEntry 18 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSpuriousRtoDetected  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of acknowledgments reporting segments that have\n        already been retransmitted due to a Retransmission Timeout.\"\n    ::= { tcpEStatsStackEntry 19 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects instrument unusual protocol\n--  events that probably indicate implementation problems in\n--  the protocol or path.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSoftErrors  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"The number of segments that fail various consistency tests\n    during TCP input processing.  Soft errors might cause the\n    segment to be discarded but some do not.  Some of these soft\n    errors cause the generation of a TCP acknowledgment, while\n    others are silently discarded.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsStackEntry 21 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSoftErrorReason  OBJECT-TYPE\n    SYNTAX          INTEGER {\n       belowDataWindow(1),\n       aboveDataWindow(2),\n       belowAckWindow(3),\n       aboveAckWindow(4),\n       belowTSWindow(5),\n       aboveTSWindow(6),\n       dataCheckSum(7),\n       otherSoftError(8)\n    }\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"This object identifies which consistency test most recently\n        failed during TCP input processing.  This object SHOULD be\n        set every time tcpEStatsStackSoftErrors is incremented.  The\n        codes are as follows:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "belowDataWindow(1) - All data in the segment is below SND.UNA. (Normal for keep-alives and zero window probes).",
      "ja": "DowerDataWindow（1） - セグメント内のすべてのデータはSND.UNA以下です。（Keep-Alivesとゼロウィンドウプローブの場合）。"
    },
    {
      "indent": 11,
      "text": "aboveDataWindow(2) - Some data in the segment is above SND.WND. (Indicates an implementation bug or possible attack).",
      "ja": "Abovedatawindow（2） - セグメントの一部のデータはSND.wndを超えています。（実装バグまたは攻撃の可能性を示します）。"
    },
    {
      "indent": 11,
      "text": "belowAckWindow(3) - ACK below SND.UNA. (Indicates that the return path is reordering ACKs)",
      "ja": "lowerackwindow（3） -  snd.unaの下のack。（リターンパスがACKの並べ替えをしていることを示します）"
    },
    {
      "indent": 11,
      "text": "aboveAckWindow(4) - An ACK for data that we have not sent. (Indicates an implementation bug or possible attack).",
      "ja": "AboveAckWindow（4） - 送信していないデータのACK。（実装バグまたは攻撃の可能性を示します）。"
    },
    {
      "indent": 11,
      "text": "belowTSWindow(5) - TSecr on the segment is older than the current TS.Recent (Normal for the rare case where PAWS detects data reordered by the network).",
      "ja": "deolly ttswindow（5）-TSECR上のTSECRは、現在のts.Recentよりも古い（PAWSがネットワークによって再注文されたデータを検出するまれな場合は正常です）。"
    },
    {
      "indent": 11,
      "text": "aboveTSWindow(6) - TSecr on the segment is newer than the current TS.Recent. (Indicates an implementation bug or possible attack).",
      "ja": "AbovetSwindow（6）-TSECR上のTSECRは、現在のTs.Recentよりも新しいものです。（実装バグまたは攻撃の可能性を示します）。"
    },
    {
      "indent": 11,
      "text": "dataCheckSum(7) - Incorrect checksum. Note that this value is intrinsically fragile, because the header fields used to identify the connection may have been corrupted.",
      "ja": "DataChecksum（7） - 誤ったチェックサム。接続を識別するために使用されるヘッダーフィールドが破損している可能性があるため、この値は本質的に脆弱であることに注意してください。"
    },
    {
      "indent": 7,
      "text": "    otherSoftError(8) - All other soft errors not listed\n    above.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsStackEntry 22 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects expose the detailed\n--  operation of the congestion control algorithms.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSlowStart  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of times the congestion window has been\n        increased by the Slow Start algorithm.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 23 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackCongAvoid  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of times the congestion window has been\n        increased by the Congestion Avoidance algorithm.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 24 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackOtherReductions  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of congestion window reductions made as a result\n        of anything other than AIMD congestion control algorithms.\n        Examples of non-multiplicative window reductions include\n        Congestion Window Validation [RFC2861] and experimental\n        algorithms such as Vegas [Bra94].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    All window reductions MUST be counted as either\n    tcpEStatsPerfCongSignals or tcpEStatsStackOtherReductions.\"\nREFERENCE\n   \"RFC 2861, TCP Congestion Window Validation\"\n::= { tcpEStatsStackEntry 25 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackCongOverCount  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of congestion events that were 'backed out' of\n        the congestion control state machine such that the\n        congestion window was restored to a prior value.  This can\n        happen due to the Eifel algorithm [RFC3522] or other\n        algorithms that can be used to detect and cancel spurious\n        invocations of the Fast Retransmit Algorithm.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Although it may be feasible to undo the effects of spurious\n    invocation of the Fast Retransmit congestion events cannot\n    easily be backed out of tcpEStatsPerfCongSignals and\n    tcpEStatsPathPreCongSumCwnd, etc.\"\nREFERENCE\n   \"RFC 3522, The Eifel Detection Algorithm for TCP\"\n::= { tcpEStatsStackEntry 26 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackFastRetran  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of invocations of the Fast Retransmit algorithm.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsStackEntry 27 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSubsequentTimeouts  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of times the retransmit timeout has expired after\n        the RTO has been doubled.  See Section 5.5 of RFC 2988.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsStackEntry 28 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackCurTimeoutCount  OBJECT-TYPE\n    SYNTAX          Gauge32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current number of times the retransmit timeout has\n        expired without receiving an acknowledgment for new data.\n        tcpEStatsStackCurTimeoutCount is reset to zero when new\n        data is acknowledged and incremented for each invocation of\n        Section 5.5 of RFC 2988.\"\n    REFERENCE\n       \"RFC 2988, Computing TCP's Retransmission Timer\"\n    ::= { tcpEStatsStackEntry 29 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackAbruptTimeouts  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of timeouts that occurred without any\n        immediately preceding duplicate acknowledgments or other\n        indications of congestion.  Abrupt Timeouts indicate that\n        the path lost an entire window of data or acknowledgments.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Timeouts that are preceded by duplicate acknowledgments or\n    other congestion signals (e.g., ECN) are not counted as\n    abrupt, and might have been avoided by a more sophisticated\n    Fast Retransmit algorithm.\"\nREFERENCE\n   \"RFC 2581, TCP Congestion Control\"\n::= { tcpEStatsStackEntry 30 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSACKsRcvd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of SACK options received.\"\n    REFERENCE\n       \"RFC 2018, TCP Selective Acknowledgement Options\"\n    ::= { tcpEStatsStackEntry 31 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSACKBlocksRcvd  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of SACK blocks received (within SACK options).\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "REFERENCE\n   \"RFC 2018, TCP Selective Acknowledgement Options\"\n::= { tcpEStatsStackEntry 32 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSendStall  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of interface stalls or other sender local\n        resource limitations that are treated as congestion\n        signals.\"\n    ::= { tcpEStatsStackEntry 33 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackDSACKDups  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of duplicate segments reported to the local host\n        by D-SACK blocks.\"\n    REFERENCE\n       \"RFC 2883, An Extension to the Selective Acknowledgement\n        (SACK) Option for TCP\"\n    ::= { tcpEStatsStackEntry 34 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects instrument path MTU\n--  discovery.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxMSS  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum MSS, in octets.\"\n    REFERENCE\n       \"RFC 1191, Path MTU discovery\"\n    ::= { tcpEStatsStackEntry 35 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMinMSS  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"The minimum MSS, in octets.\"\nREFERENCE\n   \"RFC 1191, Path MTU discovery\"\n::= { tcpEStatsStackEntry 36 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional initial value objects are useful for\n--  conformance testing instruments on application progress and\n--  consumed network resources.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackSndInitial  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Initial send sequence number.  Note that by definition\n        tcpEStatsStackSndInitial never changes for a given\n        connection.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsStackEntry 37 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackRecInitial  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"Initial receive sequence number.  Note that by definition\n        tcpEStatsStackRecInitial never changes for a given\n        connection.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsStackEntry 38 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following optional objects instrument the senders\n--  buffer usage, including any buffering in the application\n--  interface to TCP and the retransmit queue.  All 'buffer\n--  memory' instruments are assumed to include OS data\n--  structure overhead.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackCurRetxQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n       DESCRIPTION\n       \"The current number of octets of data occupying the\n        retransmit queue.\"\n    ::= { tcpEStatsStackEntry 39 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxRetxQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum number of octets of data occupying the\n        retransmit queue.\"\n    ::= { tcpEStatsStackEntry 40 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackCurReasmQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current number of octets of sequence space spanned by\n        the reassembly queue.  This is generally the difference\n        between rcv.nxt and the sequence number of the right most\n        edge of the reassembly queue.\"\n    ::= { tcpEStatsStackEntry 41 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsStackMaxReasmQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum value of tcpEStatsStackCurReasmQueue\"\n    ::= { tcpEStatsStackEntry 42 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Statistics for diagnosing interactions between\n-- applications and TCP.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsAppEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table contains objects that are useful for determining if the application using TCP is limiting TCP performance.",
      "ja": "tcpestatsapptableオブジェクトタイプの構文シーケンスtcpestatsappentry max-accessはアクセス不可能なステータス現在の説明 \"このテーブルには、TCPを使用してアプリケーションがTCPパフォーマンスを制限しているかどうかを判断するのに役立つオブジェクトが含まれています。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsAppEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table has information about the\n        characteristics of each active and recently closed TCP\n        connection.\"\n   INDEX { tcpEStatsConnectIndex }\n   ::= { tcpEStatsAppTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsAppEntry ::= SEQUENCE {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    tcpEStatsAppSndUna                  Counter32,\n    tcpEStatsAppSndNxt                  Unsigned32,\n    tcpEStatsAppSndMax                  Counter32,\n    tcpEStatsAppThruOctetsAcked         ZeroBasedCounter32,\n    tcpEStatsAppHCThruOctetsAcked       ZeroBasedCounter64,\n    tcpEStatsAppRcvNxt                  Counter32,\n    tcpEStatsAppThruOctetsReceived      ZeroBasedCounter32,\n    tcpEStatsAppHCThruOctetsReceived    ZeroBasedCounter64,\n    tcpEStatsAppCurAppWQueue            Gauge32,\n    tcpEStatsAppMaxAppWQueue            Gauge32,\n    tcpEStatsAppCurAppRQueue            Gauge32,\n    tcpEStatsAppMaxAppRQueue            Gauge32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "--\n--  The following objects provide throughput statistics for the\n--  connection including sequence numbers and elapsed\n--  application data.  These permit direct observation of the\n--  applications progress, in terms of elapsed data delivery\n--  and elapsed time.\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppSndUna  OBJECT-TYPE\n    SYNTAX          Counter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "\"The value of SND.UNA, the oldest unacknowledged sequence number.",
      "ja": "「snd.unaの値、最も古い非採取されていないシーケンス番号。"
    },
    {
      "indent": 7,
      "text": "    Note that SND.UNA is a TCP state variable that is congruent\n    to Counter32 semantics.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsAppEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppSndNxt  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of SND.NXT, the next sequence number to be sent.\n        Note that tcpEStatsAppSndNxt is not monotonic (and thus not\n        a counter) because TCP sometimes retransmits lost data by\n        pulling tcpEStatsAppSndNxt back to the missing data.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsAppEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppSndMax  OBJECT-TYPE\n    SYNTAX          Counter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The farthest forward (right most or largest) SND.NXT value.\n        Note that this will be equal to tcpEStatsAppSndNxt except\n        when tcpEStatsAppSndNxt is pulled back during recovery.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsAppEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppThruOctetsAcked  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets for which cumulative acknowledgments\n        have been received.  Note that this will be the sum of\n        changes to tcpEStatsAppSndUna.\"\n    ::= { tcpEStatsAppEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppHCThruOctetsAcked  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter64\n    UNITS           \"octets\"\n       MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets for which cumulative acknowledgments\n        have been received, on systems that can receive more than\n        10 million bits per second.  Note that this will be the sum\n        of changes in tcpEStatsAppSndUna.\"\n    ::= { tcpEStatsAppEntry 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppRcvNxt  OBJECT-TYPE\n    SYNTAX          Counter32\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The value of RCV.NXT.  The next sequence number expected on\n        an incoming segment, and the left or lower edge of the\n        receive window.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    Note that RCV.NXT is a TCP state variable that is congruent\n    to Counter32 semantics.\"\nREFERENCE\n   \"RFC 793, Transmission Control Protocol\"\n::= { tcpEStatsAppEntry 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppThruOctetsReceived  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets for which cumulative acknowledgments\n        have been sent.  Note that this will be the sum of changes\n        to tcpEStatsAppRcvNxt.\"\n    ::= { tcpEStatsAppEntry 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppHCThruOctetsReceived  OBJECT-TYPE\n    SYNTAX          ZeroBasedCounter64\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The number of octets for which cumulative acknowledgments\n        have been sent, on systems that can transmit more than 10\n        million bits per second.  Note that this will be the sum of\n        changes in tcpEStatsAppRcvNxt.\"\n    ::= { tcpEStatsAppEntry 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppCurAppWQueue OBJECT-TYPE",
      "ja": "tcpestatsappcurappwqueueオブジェクトタイプ"
    },
    {
      "indent": 7,
      "text": "SYNTAX          Gauge32\nUNITS           \"octets\"\nMAX-ACCESS      read-only\nSTATUS          current\nDESCRIPTION\n   \"The current number of octets of application data buffered\n    by TCP, pending first transmission, i.e., to the left of\n    SND.NXT or SndMax.  This data will generally be transmitted\n    (and SND.NXT advanced to the left) as soon as there is an\n    available congestion window (cwnd) or receiver window\n    (rwin).  This is the amount of data readily available for\n    transmission, without scheduling the application.  TCP\n    performance may suffer if there is insufficient queued\n    write data.\"\n::= { tcpEStatsAppEntry 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppMaxAppWQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The maximum number of octets of application data buffered\n        by TCP, pending first transmission.  This is the maximum\n        value of tcpEStatsAppCurAppWQueue.  This pair of objects can\n        be used to determine if insufficient queued data is steady\n        state (suggesting insufficient queue space) or transient\n        (suggesting insufficient application performance or\n        excessive CPU load or scheduler latency).\"\n    ::= { tcpEStatsAppEntry 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppCurAppRQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION\n       \"The current number of octets of application data that has\n        been acknowledged by TCP but not yet delivered to the\n        application.\"\n    ::= { tcpEStatsAppEntry 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsAppMaxAppRQueue  OBJECT-TYPE\n    SYNTAX          Gauge32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-only\n    STATUS          current\n    DESCRIPTION",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "   \"The maximum number of octets of application data that has\n    been acknowledged by TCP but not yet delivered to the\n    application.\"\n::= { tcpEStatsAppEntry 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Controls for Tuning TCP\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneTable OBJECT-TYPE SYNTAX SEQUENCE OF TcpEStatsTuneEntry MAX-ACCESS not-accessible STATUS current DESCRIPTION \"This table contains per-connection controls that can be used to work around a number of common problems that plague TCP over some paths. All can be characterized as limiting the growth of the congestion window so as to prevent TCP from overwhelming some component in the path.",
      "ja": "TCPESTATTATSTUNETABLEオブジェクトタイプタイプの構文シーケンスTCPESTATSTUNEENTRY MAX-ACCESSアクセス不可能なステータス現在の説明 \"このテーブルには、いくつかのパス上でTCPを悩ませる多くの一般的な問題を回避するために使用できる接続ごとのコントロールが含まれています。TCPがパス内の一部のコンポーネントを圧倒するのを防ぐための輻輳ウィンドウの成長。"
    },
    {
      "indent": 7,
      "text": "    Entries are retained in this table for the number of\n    seconds indicated by the tcpEStatsConnTableLatency\n    object, after the TCP connection first enters the closed\n    state.\"\n::= { tcpEStats 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneEntry  OBJECT-TYPE\n    SYNTAX       TcpEStatsTuneEntry\n    MAX-ACCESS   not-accessible\n    STATUS       current\n    DESCRIPTION\n        \"Each entry in this table is a control that can be used to\n        place limits on each active TCP connection.\"\n   INDEX { tcpEStatsConnectIndex }\n   ::= { tcpEStatsTuneTable 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TcpEStatsTuneEntry ::= SEQUENCE {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    tcpEStatsTuneLimCwnd                Unsigned32,\n    tcpEStatsTuneLimSsthresh            Unsigned32,\n    tcpEStatsTuneLimRwin                Unsigned32,\n    tcpEStatsTuneLimMSS                 Unsigned32\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneLimCwnd  OBJECT-TYPE\n    SYNTAX          Unsigned32\n       UNITS           \"octets\"\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n       \"A control to set the maximum congestion window that may be\n        used, in octets.\"\n    REFERENCE\n       \"RFC 2581, TCP Congestion Control\"\n    ::= { tcpEStatsTuneEntry 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneLimSsthresh  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n       \"A control to limit the maximum queue space (in octets) that\n        this TCP connection is likely to occupy during slowstart.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "It can be implemented with the algorithm described in RFC 3742 by setting the max_ssthresh parameter to twice tcpEStatsTuneLimSsthresh.",
      "ja": "MAX_SSTHRESHパラメーターを2回tcpestatStunelimsSthreshに設定することにより、RFC 3742で説明されているアルゴリズムで実装できます。"
    },
    {
      "indent": 7,
      "text": "    This algorithm can be used to overcome some TCP performance\n    problems over network paths that do not have sufficient\n    buffering to withstand the bursts normally present during\n    slowstart.\"\nREFERENCE\n   \"RFC 3742, Limited Slow-Start for TCP with Large Congestion\n    Windows\"\n::= { tcpEStatsTuneEntry 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneLimRwin  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-write\n    STATUS          current\n    DESCRIPTION\n       \"A control to set the maximum window advertisement that may\n        be sent, in octets.\"\n    REFERENCE\n       \"RFC 793, Transmission Control Protocol\"\n    ::= { tcpEStatsTuneEntry 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsTuneLimMSS  OBJECT-TYPE\n    SYNTAX          Unsigned32\n    UNITS           \"octets\"\n    MAX-ACCESS      read-write\n       STATUS          current\n    DESCRIPTION\n       \"A control to limit the maximum segment size in octets, that\n        this TCP connection can use.\"\n    REFERENCE\n       \"RFC 1191, Path MTU discovery\"\n    ::= { tcpEStatsTuneEntry 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- TCP Extended Statistics Notifications Group\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsEstablishNotification NOTIFICATION-TYPE\n    OBJECTS     {\n                  tcpEStatsConnectIndex\n                }\n    STATUS      current\n    DESCRIPTION\n        \"The indicated connection has been accepted\n        (or alternatively entered the established state).\"\n    ::= { tcpEStatsNotifications 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tcpEStatsCloseNotification NOTIFICATION-TYPE\n    OBJECTS     {\n                  tcpEStatsConnectIndex\n                }\n    STATUS      current\n    DESCRIPTION\n        \"The indicated connection has left the\n        established state\"\n    ::= { tcpEStatsNotifications 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Conformance Definitions\n--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "tcpEStatsCompliances   OBJECT IDENTIFIER\n     ::= { tcpEStatsConformance 1 }\ntcpEStatsGroups        OBJECT IDENTIFIER\n     ::= { tcpEStatsConformance 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- -- Compliance Statements --",
      "ja": "---コンプライアンスステートメント - "
    },
    {
      "indent": 5,
      "text": "tcpEStatsCompliance MODULE-COMPLIANCE",
      "ja": "tcpestatsComplianceモジュールコンプライアンス"
    },
    {
      "indent": 8,
      "text": "STATUS current\nDESCRIPTION\n    \"Compliance statement for all systems that implement TCP\n    extended statistics.\"\nMODULE -- this module\n    MANDATORY-GROUPS {\n                       tcpEStatsListenerGroup,\n                       tcpEStatsConnectIdGroup,\n                       tcpEStatsPerfGroup,\n                       tcpEStatsPathGroup,\n                       tcpEStatsStackGroup,\n                       tcpEStatsAppGroup\n                     }\n    GROUP tcpEStatsListenerHCGroup\n    DESCRIPTION\n        \"This group is mandatory for all systems that can\n         wrap the values of the 32-bit counters in\n         tcpEStatsListenerGroup in less than one hour.\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsPerfOptionalGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループtcpestatsperfoptionalgroup説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsPerfHCGroup DESCRIPTION \"This group is mandatory for systems that can wrap the values of the 32-bit counters in tcpEStatsPerfGroup in less than one hour.",
      "ja": "グループTCPESTATSPERFHCGROUP説明「このグループは、TCPestatsPerfGroupの32ビットカウンターの値を1時間以内に包むことができるシステムに必須です。"
    },
    {
      "indent": 16,
      "text": "Note that any system that can attain 10 Mb/s can potentially wrap 32-Bit Octet counters in under one hour.\"",
      "ja": "10 MB/sを達成できるシステムは、1時間以内に32ビットのオクテットカウンターを包む可能性があることに注意してください。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsPathOptionalGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループtcpestatspathoptionalgroup説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsPathHCGroup DESCRIPTION \"This group is mandatory for systems that can wrap the values of the 32-bit counters in tcpEStatsPathGroup in less than one hour.",
      "ja": "グループTCPESTATSPATHHCGROUP説明「このグループは、TCPestatsPathGroupの32ビットカウンターの値を1時間以内に包むことができるシステムに必須です。"
    },
    {
      "indent": 16,
      "text": "Note that any system that can attain 10 Mb/s can potentially wrap 32-Bit Octet counters in under one hour.\"",
      "ja": "10 MB/sを達成できるシステムは、1時間以内に32ビットのオクテットカウンターを包む可能性があることに注意してください。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsStackOptionalGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループtcpestatsStackoptionalGroupの説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsAppHCGroup DESCRIPTION \"This group is mandatory for systems that can wrap the values of the 32-bit counters in tcpEStatsStackGroup in less than one hour.",
      "ja": "グループTCPESTATSAPPHCGROUP説明「このグループは、TCPestatsStackGroupの32ビットカウンターの値を1時間以内に包むことができるシステムに必須です。"
    },
    {
      "indent": 16,
      "text": "Note that any system that can attain 10 Mb/s can potentially wrap 32-Bit Octet counters in under one hour.\"",
      "ja": "10 MB/sを達成できるシステムは、1時間以内に32ビットのオクテットカウンターを包む可能性があることに注意してください。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsAppOptionalGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループTCPESTATSAPPOPTIONALGROUP説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsTuneOptionalGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループTCPESTATSTUNEOPTIONALGROUP説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsNotificationsGroup DESCRIPTION \"This group is optional for all systems.\"",
      "ja": "グループtcpestatsnotificationsgroup説明「このグループはすべてのシステムでオプションです。」"
    },
    {
      "indent": 12,
      "text": "GROUP tcpEStatsNotificationsCtlGroup DESCRIPTION \"This group is mandatory for systems that include the tcpEStatsNotificationGroup.\"",
      "ja": "グループtcpestatsnotificationsctlgroup説明「このグループは、tcpestatsnotificationgroupを含むシステムに必須です。」"
    },
    {
      "indent": 6,
      "text": "::= { tcpEStatsCompliances 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- ================================================================\n--\n-- Units of Conformance\n--\n    tcpEStatsListenerGroup  OBJECT-GROUP\n         OBJECTS {\n              tcpEStatsListenerTableLastChange,\n              tcpEStatsListenerStartTime,\n              tcpEStatsListenerSynRcvd,\n              tcpEStatsListenerInitial,\n              tcpEStatsListenerEstablished,\n              tcpEStatsListenerAccepted,\n              tcpEStatsListenerExceedBacklog,\n              tcpEStatsListenerCurConns,\n              tcpEStatsListenerMaxBacklog,\n              tcpEStatsListenerCurBacklog,\n                 tcpEStatsListenerCurEstabBacklog\n         }\n         STATUS current\n         DESCRIPTION\n              \"The tcpEStatsListener group includes objects that\n              provide valuable statistics and debugging\n              information for TCP Listeners.\"\n      ::= { tcpEStatsGroups 1 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsListenerHCGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsListenerHCSynRcvd,\n          tcpEStatsListenerHCInitial,\n          tcpEStatsListenerHCEstablished,\n          tcpEStatsListenerHCAccepted,\n          tcpEStatsListenerHCExceedBacklog\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsListenerHC group includes 64-bit\n           counters in tcpEStatsListenerTable.\"\n  ::= { tcpEStatsGroups 2 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsConnectIdGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsConnTableLatency,\n          tcpEStatsConnectIndex\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsConnectId group includes objects that\n          identify TCP connections and control how long TCP\n          connection entries are retained in the tables.\"\n  ::= { tcpEStatsGroups 3 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsPerfGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsPerfSegsOut, tcpEStatsPerfDataSegsOut,\n          tcpEStatsPerfDataOctetsOut,\n          tcpEStatsPerfSegsRetrans,\n          tcpEStatsPerfOctetsRetrans, tcpEStatsPerfSegsIn,\n          tcpEStatsPerfDataSegsIn,\n          tcpEStatsPerfDataOctetsIn,\n          tcpEStatsPerfElapsedSecs,\n          tcpEStatsPerfElapsedMicroSecs,\n          tcpEStatsPerfStartTimeStamp, tcpEStatsPerfCurMSS,\n          tcpEStatsPerfPipeSize, tcpEStatsPerfMaxPipeSize,\n          tcpEStatsPerfSmoothedRTT, tcpEStatsPerfCurRTO,\n                 tcpEStatsPerfCongSignals, tcpEStatsPerfCurCwnd,\n          tcpEStatsPerfCurSsthresh, tcpEStatsPerfTimeouts,\n          tcpEStatsPerfCurRwinSent,\n          tcpEStatsPerfMaxRwinSent,\n          tcpEStatsPerfZeroRwinSent,\n          tcpEStatsPerfCurRwinRcvd,\n          tcpEStatsPerfMaxRwinRcvd,\n          tcpEStatsPerfZeroRwinRcvd\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsPerf group includes those objects that\n          provide basic performance data for a TCP connection.\"\n  ::= { tcpEStatsGroups 4 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsPerfOptionalGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsPerfSndLimTransRwin,\n          tcpEStatsPerfSndLimTransCwnd,\n          tcpEStatsPerfSndLimTransSnd,\n          tcpEStatsPerfSndLimTimeRwin,\n          tcpEStatsPerfSndLimTimeCwnd,\n          tcpEStatsPerfSndLimTimeSnd\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsPerf group includes those objects that\n          provide basic performance data for a TCP connection.\"\n  ::= { tcpEStatsGroups 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsPerfHCGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsPerfHCDataOctetsOut,\n          tcpEStatsPerfHCDataOctetsIn\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsPerfHC group includes 64-bit\n          counters in the tcpEStatsPerfTable.\"\n  ::= { tcpEStatsGroups 6 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsPathGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsControlPath,\n          tcpEStatsPathRetranThresh,\n          tcpEStatsPathNonRecovDAEpisodes,\n          tcpEStatsPathSumOctetsReordered,\n                 tcpEStatsPathNonRecovDA\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsPath group includes objects that\n          control the creation of the tcpEStatsPathTable,\n          and provide information about the path\n          for each TCP connection.\"\n  ::= { tcpEStatsGroups 7 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsPathOptionalGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsPathSampleRTT, tcpEStatsPathRTTVar,\n          tcpEStatsPathMaxRTT, tcpEStatsPathMinRTT,\n          tcpEStatsPathSumRTT, tcpEStatsPathCountRTT,\n          tcpEStatsPathMaxRTO, tcpEStatsPathMinRTO,\n          tcpEStatsPathIpTtl, tcpEStatsPathIpTosIn,\n          tcpEStatsPathIpTosOut,\n          tcpEStatsPathPreCongSumCwnd,\n          tcpEStatsPathPreCongSumRTT,\n          tcpEStatsPathPostCongSumRTT,\n          tcpEStatsPathPostCongCountRTT,\n          tcpEStatsPathECNsignals,\n          tcpEStatsPathDupAckEpisodes, tcpEStatsPathRcvRTT,\n          tcpEStatsPathDupAcksOut, tcpEStatsPathCERcvd,\n          tcpEStatsPathECESent\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsPath group includes objects that\n          provide additional information about the path\n          for each TCP connection.\"\n  ::= { tcpEStatsGroups 8 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "tcpEStatsPathHCGroup  OBJECT-GROUP\n       OBJECTS {\n            tcpEStatsPathHCSumRTT\n       }\n       STATUS current\n       DESCRIPTION\n            \"The tcpEStatsPathHC group includes 64-bit\n            counters in the tcpEStatsPathTable.\"\n    ::= { tcpEStatsGroups 9 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsStackGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsControlStack,\n          tcpEStatsStackActiveOpen, tcpEStatsStackMSSSent,\n                 tcpEStatsStackMSSRcvd, tcpEStatsStackWinScaleSent,\n          tcpEStatsStackWinScaleRcvd,\n          tcpEStatsStackTimeStamps, tcpEStatsStackECN,\n          tcpEStatsStackWillSendSACK,\n          tcpEStatsStackWillUseSACK, tcpEStatsStackState,\n          tcpEStatsStackNagle, tcpEStatsStackMaxSsCwnd,\n          tcpEStatsStackMaxCaCwnd,\n          tcpEStatsStackMaxSsthresh,\n          tcpEStatsStackMinSsthresh,\n          tcpEStatsStackInRecovery, tcpEStatsStackDupAcksIn,\n          tcpEStatsStackSpuriousFrDetected,\n          tcpEStatsStackSpuriousRtoDetected\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsConnState group includes objects that\n          control the creation of the tcpEStatsStackTable,\n          and provide information about the operation of\n          algorithms used within TCP.\"\n  ::= { tcpEStatsGroups 10 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsStackOptionalGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsStackSoftErrors,\n          tcpEStatsStackSoftErrorReason,\n          tcpEStatsStackSlowStart, tcpEStatsStackCongAvoid,\n          tcpEStatsStackOtherReductions,\n          tcpEStatsStackCongOverCount,\n          tcpEStatsStackFastRetran,\n          tcpEStatsStackSubsequentTimeouts,\n          tcpEStatsStackCurTimeoutCount,\n          tcpEStatsStackAbruptTimeouts,\n          tcpEStatsStackSACKsRcvd,\n          tcpEStatsStackSACKBlocksRcvd,\n          tcpEStatsStackSendStall, tcpEStatsStackDSACKDups,\n          tcpEStatsStackMaxMSS, tcpEStatsStackMinMSS,\n          tcpEStatsStackSndInitial,\n          tcpEStatsStackRecInitial,\n          tcpEStatsStackCurRetxQueue,\n          tcpEStatsStackMaxRetxQueue,\n          tcpEStatsStackCurReasmQueue,\n          tcpEStatsStackMaxReasmQueue\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsConnState group includes objects that\n          provide additional information about the operation of\n          algorithms used within TCP.\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "::= { tcpEStatsGroups 11 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsAppGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsControlApp,\n          tcpEStatsAppSndUna, tcpEStatsAppSndNxt,\n          tcpEStatsAppSndMax, tcpEStatsAppThruOctetsAcked,\n          tcpEStatsAppRcvNxt,\n          tcpEStatsAppThruOctetsReceived\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsConnState group includes objects that\n          control the creation of the tcpEStatsAppTable,\n          and provide information about the operation of\n          algorithms used within TCP.\"\n  ::= { tcpEStatsGroups 12 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "tcpEStatsAppHCGroup  OBJECT-GROUP\n       OBJECTS {\n            tcpEStatsAppHCThruOctetsAcked,\n            tcpEStatsAppHCThruOctetsReceived\n       }\n       STATUS current\n       DESCRIPTION\n            \"The tcpEStatsStackHC group includes 64-bit\n            counters in the tcpEStatsStackTable.\"\n    ::= { tcpEStatsGroups 13 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsAppOptionalGroup  OBJECT-GROUP\n     OBJECTS {\n          tcpEStatsAppCurAppWQueue,\n          tcpEStatsAppMaxAppWQueue,\n          tcpEStatsAppCurAppRQueue,\n          tcpEStatsAppMaxAppRQueue\n     }\n     STATUS current\n     DESCRIPTION\n          \"The tcpEStatsConnState group includes objects that\n          provide additional information about how applications\n          are interacting with each TCP connection.\"\n  ::= { tcpEStatsGroups 14 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsTuneOptionalGroup OBJECT-GROUP OBJECTS { tcpEStatsControlTune, tcpEStatsTuneLimCwnd, tcpEStatsTuneLimSsthresh, tcpEStatsTuneLimRwin, tcpEStatsTuneLimMSS",
      "ja": "tcpestatttuneoptionalgroupオブジェクトグループオブジェクト{tcpestatscontroltune、tcpestatstunelimcwnd、tcpestatstunelimsSthresh、tcpestatstunelimrwin、tcpestatstunelimmsss"
    },
    {
      "indent": 9,
      "text": "   }\n   STATUS current\n   DESCRIPTION\n        \"The tcpEStatsConnState group includes objects that\n        control the creation of the tcpEStatsConnectionTable,\n        which can be used to set tuning parameters\n        for each TCP connection.\"\n::= { tcpEStatsGroups 15 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsNotificationsGroup      NOTIFICATION-GROUP\n     NOTIFICATIONS {\n                   tcpEStatsEstablishNotification,\n                   tcpEStatsCloseNotification\n     }\n     STATUS   current\n     DESCRIPTION\n         \"Notifications sent by a TCP extended statistics agent.\"\n  ::= { tcpEStatsGroups 16 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tcpEStatsNotificationsCtlGroup  OBJECT-GROUP\n     OBJECTS {\n                   tcpEStatsControlNotify\n     }\n     STATUS   current\n     DESCRIPTION\n         \"The tcpEStatsNotificationsCtl group includes the\n          object that controls the creation of the events\n          in the tcpEStatsNotificationsGroup.\"\n  ::= { tcpEStatsGroups 17 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of management objects defined in this MIB module with a MAX-ACCESS clause of read-write and/or read-create. Such objects may be considered sensitive or vulnerable in some network environments. The support for SET operations in a non-secure environment without proper protection can have a negative effect on network operations. These are the tables and objects and their sensitivity/vulnerability:",
      "ja": "このMIBモジュールには、読み取りワイトおよび/またはread-Createの最大アクセス句を備えた管理オブジェクトが多数あります。このようなオブジェクトは、一部のネットワーク環境で敏感または脆弱と見なされる場合があります。適切な保護なしの非セキュア環境でのセット操作のサポートは、ネットワーク操作に悪影響を与える可能性があります。これらはテーブルとオブジェクトであり、その感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "* Changing tcpEStatsConnTableLatency or any of the control objects in the tcpEStatsControl group (tcpEStatsControlPath, tcpEStatsControlStack, tcpEStatsControlApp, tcpEStatsControlTune) may affect the correctness of other management applications accessing this MIB. Generally, local policy should only permit limited write access to these controls (e.g., only by one management station or only during system configuration).",
      "ja": "* tcpestatsconntablelatencyまたはtcpestatscontrolグループ（tcpestatscontrolpath、tcpestatscontrolstack、tcpestatscontrolapp、tcpestatscontroltune）の制御オブジェクトのいずれかを変更すると、このmibにアクセスする他の管理アプリケーションの正確性に影響を与える可能性があります。一般に、ローカルポリシーは、これらのコントロールへの制限された書き込みアクセスのみを許可する必要があります（たとえば、1つの管理ステーションのみ、またはシステム構成中のみ）。"
    },
    {
      "indent": 3,
      "text": "* The objects in the tcpEStatsControlTune group (tcpEStatsTuneLimCwnd, tcpEStatsTuneLimSsthresh, tcpEStatsTuneLimRwin) can be used to limit resources consumed by TCP connections or to limit TCP throughput. An attacker might manipulate these objects to reduce performance to levels below the minimum acceptable for a particular application.",
      "ja": "* tcpestatscontroltuneグループのオブジェクト（tcpestatstunelimcwnd、tcpestatstunelimsSthresh、tcpestatstunelimrwin）を使用して、TCP接続によって消費されるリソースを制限するか、TCPスループットを制限することができます。攻撃者は、これらのオブジェクトを操作して、パフォーマンスを特定のアプリケーションで許容できる最小値よりも低いレベルに減らすことができます。"
    },
    {
      "indent": 3,
      "text": "Some of the readable objects in this MIB module (i.e., objects with a MAX-ACCESS other than not-accessible) may be considered sensitive or vulnerable in some network environments. It is thus important to control even GET and/or NOTIFY access to these objects and possibly to even encrypt the values of these objects when sending them over the network via SNMP. These are the tables and objects and their sensitivity/vulnerability:",
      "ja": "このMIBモジュールの読み取り可能なオブジェクトのいくつか（つまり、アクセスできないこと以外に最大アクセスを備えたオブジェクト）は、一部のネットワーク環境で敏感または脆弱と見なされる場合があります。したがって、これらのオブジェクトへのアクセスを取得および/または通知することさえ制御し、SNMPを介してネットワーク上に送信するときにこれらのオブジェクトの値を暗号化することも重要です。これらはテーブルとオブジェクトであり、その感度/脆弱性です。"
    },
    {
      "indent": 3,
      "text": "* All objects which expose TCP sequence numbers (tcpEStatsAppSndUna, tcpEStatsAppSndNxt, tcpEStatsAppSndMax, tcpEStatsStackSndInitial, tcpEStatsAppRcvNxt, and tcpEStatsStackRecInitial) might make it easier for an attacker to forge in sequence TCP segments to disrupt TCP connections.",
      "ja": "* TCPシーケンス番号を公開するすべてのオブジェクト（tcpestatsappsnduna、tcpestatsappsndnxt、tcpestatsappsndmax、tcpestatsstacksndinitial、tcpestatsapprcvnxt、およびtcpestatsstacksstack recinitial）は、tcpsepの攻撃に攻撃を行うために攻撃を妨害するために攻撃を避けるために容易になります。"
    },
    {
      "indent": 3,
      "text": "* Nearly all objects in this (or any other) MIB may be used to estimate traffic volumes, which may reveal unanticipated information about an organization to the outside world.",
      "ja": "* この（または他の）MIBのほぼすべてのオブジェクトを使用して、トラフィック量を推定することができます。"
    },
    {
      "indent": 3,
      "text": "SNMP versions prior to SNMPv3 did not include adequate security. Even if the network itself is secure (for example by using IPsec), even then, there is no control as to who on the secure network is allowed to access and GET/SET (read/change/create/delete) the objects in this MIB module.",
      "ja": "SNMPV3以前のSNMPバージョンには、適切なセキュリティは含まれていませんでした。ネットワーク自体が（たとえばIPSECを使用して）安全である場合でも、それでもセキュアネットワークで誰がアクセスして取得/セット（読み取り/変更/作成/削除/削除）を制御することはできません。MIBモジュール。"
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that implementers consider the security features as provided by the SNMPv3 framework (see [RFC3410], section 8), including full support for the SNMPv3 cryptographic mechanisms (for authentication and privacy).",
      "ja": "実装者は、SNMPV3暗号化メカニズム（認証とプライバシー用）の完全なサポートを含む、SNMPV3フレームワーク（[RFC3410]、セクション8を参照）で提供されるセキュリティ機能を考慮することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Further, deployment of SNMP versions prior to SNMPv3 is NOT RECOMMENDED. Instead, it is RECOMMENDED to deploy SNMPv3 and to enable cryptographic security. It is then a customer/operator responsibility to ensure that the SNMP entity giving access to an instance of this MIB module is properly configured to give access to the objects only to those principals (users) that have legitimate rights to indeed GET or SET (change/create/delete) them.",
      "ja": "さらに、SNMPV3より前のSNMPバージョンの展開は推奨されません。代わりに、SNMPV3を展開し、暗号化セキュリティを有効にすることをお勧めします。その場合、このMIBモジュールのインスタンスへのアクセスを提供するSNMPエンティティが、実際に取得または設定する正当な権利を持つプリンシパル（ユーザー）にのみオブジェクトにアクセスできるように適切に構成されていることを保証するのは、顧客/オペレーターの責任です（変更を変更します（変更）/作成/削除）それら。"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The MIB module in this document uses the following IANA-assigned OBJECT IDENTIFIER values recorded in the SMI Numbers registry:",
      "ja": "このドキュメントのMIBモジュールは、SMI番号レジストリに記録された次のIANAによって割り当てられたオブジェクト識別子値を使用します。"
    },
    {
      "indent": 10,
      "text": "Descriptor        OBJECT IDENTIFIER value\n------------      -----------------------\ntcpEStatsMIB      { mib-2 156 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Normative References",
      "section_title": true,
      "ja": "7. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC791] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R.、ed。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1323] Jacobson, V., Braden, R., and D. Borman, \"TCP Extensions for High Performance\", RFC 1323, May 1992.",
      "ja": "[RFC1323] Jacobson、V.、Braden、R。、およびD. Borman、「高性能のためのTCP拡張」、RFC 1323、1992年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018] Mathis、M.、Mahdavi、J.、Floyd、S。、およびA. Romanow、「TCP Selective Ascondage Options」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2578] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M., and S. Waldbusser, \"Structure of Management Information Version 2 (SMIv2)\", STD 58, RFC 2578, April 1999.",
      "ja": "[RFC2578] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「管理情報の構造バージョン2（SMIV2）」、STD 58、RFC 2578、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2579] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M., and S. Waldbusser, \"Textual Conventions for SMIv2\", RFC 2579, STD 58, April 1999.",
      "ja": "[RFC2579] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「SMIV2のテキストコンベンション」、RFC 2579、STD 58、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2580] McCloghrie, K., Perkins, D., Schoenwaelder, J., Case, J., Rose, M., and S. Waldbusser, \"Conformance Statements for SMIv2\", RFC 2580, STD 58, April 1999.",
      "ja": "[RFC2580] McCloghrie、K.、Perkins、D.、Schoenwaelder、J.、Case、J.、Rose、M。、およびS. Waldbusser、「Smiv2の適合ステートメント」、RFC 2580、STD 58、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Allman、M.、Paxson、V。、およびW. Stevens、「TCP渋滞制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2856] Bierman, A., McCloghrie, K., and R. Presuhn, \"Textual Conventions for Additional High Capacity Data Types\", RFC 2856, June 2000.",
      "ja": "[RFC2856] Bierman、A.、McCloghrie、K。、およびR. Presuhn、「追加の大容量データ型のテキスト慣習」、RFC 2856、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883] Floyd、S.、Mahdavi、J.、Mathis、M。、およびM. Podolsky、「TCPの選択的承認（SACK）オプションの拡張」、RFC 2883、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988] Paxson、V。およびM. Allman、「TCPの再送信タイマーのコンピューティング」、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "[RFC3168] Ramakrishnan、K.、Floyd、S。、およびD. Black、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517] Blanton、E.、Allman、M.、Fall、K。、およびL. Wang、「TCPの保守的な選択的承認（SACK）ベースの損失回復アルゴリズム」、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4022] Raghunarayan, R., Ed., \"Management Information Base for the Transmission Control Protocol (TCP)\", RFC 4022, March 2005.",
      "ja": "[RFC4022] Raghunarayan、R.、ed。、「送信制御プロトコルの管理情報ベース（TCP）」、RFC 4022、2005年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4502] Waldbusser, S., \"Remote Network Monitoring Management Information Base Version 2\", RFC 4502, May 2006.",
      "ja": "[RFC4502] Waldbusser、S。、「リモートネットワーク監視管理情報ベース2」、RFC 4502、2006年5月。"
    },
    {
      "indent": 0,
      "text": "8. Informative References",
      "section_title": true,
      "ja": "8. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Mat97] M. Mathis, J. Semke, J. Mahdavi, T. Ott, \"The Macroscopic Behavior of the TCP Congestion Avoidance Algorithm\", Computer Communication Review, volume 27, number 3, July 1997.",
      "ja": "[MAT97] M. Mathis、J。Semke、J。Mahdavi、T。Ott、「TCP混雑回避アルゴリズムの巨視的挙動」、コンピューターコミュニケーションレビュー、第27巻、3、1997年7月。"
    },
    {
      "indent": 3,
      "text": "[Bra94] Brakmo, L., O'Malley, S., \"TCP Vegas, New Techniques for Congestion Detection and Avoidance\", SIGCOMM'94, London, pp 24-35, October 1994.",
      "ja": "[Bra94] Brakmo、L.、O'Malley、S。、「TCP Vegas、Commestion Detection and Esisnivesの新しい技術」、Sigcomm'94、ロンドン、PP 24-35、1994年10月。"
    },
    {
      "indent": 3,
      "text": "[Edd06] Eddy, W., \"TCP SYN Flooding Attacks and Common Mitigations\", Work in Progress, May 2007.",
      "ja": "[EDD06] Eddy、W。、「TCP Syn Flooding Attacks and Common Mitigations」、2007年5月の作業。"
    },
    {
      "indent": 3,
      "text": "[POSIX] Portable Operating System Interface, IEEE Std 1003.1",
      "ja": "[POSIX]ポータブルオペレーティングシステムインターフェイス、IEEE STD 1003.1"
    },
    {
      "indent": 3,
      "text": "[Pad98] Padhye, J., Firoiu, V., Towsley, D., Kurose, J., \"Modeling TCP Throughput: A Simple Model and its Empirical Validation\", SIGCOMM'98.",
      "ja": "[PAD98] Padhye、J.、Firoiu、V.、Towsley、D.、Kurose、J。、「モデリングTCPスループット：単純なモデルとその経験的検証」、Sigcomm'98。"
    },
    {
      "indent": 3,
      "text": "[Web100] Mathis, M., J. Heffner, R. Reddy, \"Web100: Extended TCP Instrumentation for Research, Education and Diagnosis\", ACM Computer Communications Review, Vol 33, Num 3, July 2003.",
      "ja": "[Web100] Mathis、M.、J。Heffner、R。Reddy、「Web100：研究、教育、診断のための拡張TCP計装」、ACM Computer Communications Review、Vol 33、Num 3、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2861] Handley, M., Padhye, J., and S. Floyd, \"TCP Congestion Window Validation\", RFC 2861, June 2000.",
      "ja": "[RFC2861] Handley、M.、Padhye、J。、およびS. Floyd、「TCP混雑ウィンドウ検証」、RFC 2861、2000年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3260] Grossman, D., \"New Terminology and Clarifications for Diffserv\", RFC 3260, April 2002.",
      "ja": "[RFC3260] Grossman、D。、「Diffservの新しい用語と説明」、RFC 3260、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3410] Case, J., Mundy, R., Partain, D. and B. Stewart, \"Introduction and Applicability Statements for Internet-Standard Management Framework\", RFC 3410, December 2002.",
      "ja": "[RFC3410] Case、J.、Mundy、R.、Partain、D。およびB. Stewart、「インターネット標準管理フレームワークの紹介と適用声明」、RFC 3410、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3522] Ludwig, R. and M. Meyer, \"The Eifel Detection Algorithm for TCP\", RFC 3522, April 2003.",
      "ja": "[RFC3522] Ludwig、R。およびM. Meyer、「TCPのEIFEL検出アルゴリズム」、RFC 3522、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3742] Floyd, S., \"Limited Slow-Start for TCP with Large Congestion Windows\", RFC 3742, March 2004.",
      "ja": "[RFC3742] Floyd、S。、「大規模な輻輳窓を備えたTCPの限定スロースタート」、RFC 3742、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4614] Duke M., Braden, R., Eddy, W., Blanton, E. \"A Roadmap for Transmission Control Protocol (TCP) Specification Documents\", RFC 4614, September 2006.",
      "ja": "[RFC4614] Duke M.、Braden、R.、Eddy、W.、Blanton、E。"
    },
    {
      "indent": 0,
      "text": "9. Contributors",
      "section_title": true,
      "ja": "9. 貢献者"
    },
    {
      "indent": 3,
      "text": "The following people contributed text that was incorporated into this document:",
      "ja": "次の人々は、このドキュメントに組み込まれたテキストを提供しました。"
    },
    {
      "indent": 3,
      "text": "Jon Saperia <saperia@jdscons.com> converted Web100 internal documentation into a true MIB.",
      "ja": "Jon Saperia <saperia@jdscons.com> Web100内部ドキュメントを真MIBに変換しました。"
    },
    {
      "indent": 3,
      "text": "Some of the objects in this document were moved from an early version of the TCP-MIB by Bill Fenner, et al.",
      "ja": "このドキュメントのオブジェクトのいくつかは、ビル・フェナー等によってTCP-MIBの初期バージョンから移動されました。"
    },
    {
      "indent": 3,
      "text": "Some of the object descriptions are based on an earlier unpublished document by Jeff Semke.",
      "ja": "オブジェクトの説明のいくつかは、ジェフ・セムケによる以前の未発表のドキュメントに基づいています。"
    },
    {
      "indent": 0,
      "text": "10. Acknowledgments",
      "section_title": true,
      "ja": "10. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Web100 project (www.web100.org), a joint effort of Pittsburgh Supercomputing Center (www.psc.edu), National Center for Atmospheric Research (www.ncar.ucar.edu), and National Center for Supercomputer Applications (www.ncsa.edu).",
      "ja": "このドキュメントは、Web100プロジェクト（www.web100.org）の製品、ピッツバーグスーパーコンピューティングセンター（www.psc.edu）の共同努力、国立大気研究センター（www.ncar.ucar.edu）、および国立センターの製品です。スーパーコンピューターアプリケーション（www.ncsa.edu）の場合。"
    },
    {
      "indent": 3,
      "text": "It would not have been possible without all of the hard work by the entire Web100 team, especially Peter O'Neal, who read and reread the entire document several times; Janet Brown and Marla Meehl, who patiently managed the unmanageable. The Web100 project would not have been successful without all of the early adopters who suffered our bugs to provide many good suggestions and insights into their needs for TCP instrumentation.",
      "ja": "Web100チーム全体、特にドキュメント全体を数回読んで読み直したPeter O'Nealがすべてのハードワークがなければ不可能だったでしょう。ジャネット・ブラウンとマルラ・ミールは、管理不能を辛抱強く管理しました。Web100プロジェクトは、TCP計装のニーズに関する多くの良い提案と洞察を提供するために、バグに苦しんだすべての初期採用者がいなければ成功していませんでした。"
    },
    {
      "indent": 3,
      "text": "Web100 was supported by the National Science Foundation under Grant No. 0083285 and a research grant from Cisco Systems.",
      "ja": "Web100は、Grant No. 0083285とCisco Systemsの研究助成金の下で、National Science Foundationによってサポートされていました。"
    },
    {
      "indent": 3,
      "text": "We would also like to thank all of the people who built experimental implementations of this MIB from early versions and provided us with constructive feedback: Glenn Turner at AARnet, Kristine Adamson at IBM, and Xinyan Zan at Microsoft.",
      "ja": "また、初期バージョンからこのMIBの実験的実装を構築し、建設的なフィードバックを提供してくれたすべての人々に感謝したいと思います。AarnetのGlenn Turner、IBMのKristine Adamson、MicrosoftのXinyan Zan。"
    },
    {
      "indent": 3,
      "text": "And last, but not least, we would like to thank Dan Romascanu, our \"MIB Doctor\" and Bert Wijnen, the Operations Area Director, for patiently steering us through the MIB review process.",
      "ja": "そして最後になりましたが、「MIB Doctor」であるDan Romascanuと、運営エリアディレクターのBert Wijnenに、MIBレビュープロセスを辛抱強く操縦してくれたことに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Matt Mathis Pittsburgh Supercomputing Center 300 S. Craig St. Pittsburgh, PA 15213 Phone: 412-268-4960 EMail: mathis@psc.edu",
      "ja": "マットマティスピッツバーグスーパーコンピューティングセンター300 S.クレイグセントピッツバーグ、ペンシルバニア州15213電話：412-268-4960メール：mathis@psc.edu"
    },
    {
      "indent": 3,
      "text": "John Heffner Pittsburgh Supercomputing Center 300 S. Craig St. Pittsburgh, PA 15213 Phone: 412-268-4960 EMail: jheffner@psc.edu",
      "ja": "ジョンヘフナーピッツバーグスーパーコンピューティングセンター300 S.クレイグセントピッツバーグ、ペンシルベニア州15213電話：412-268-4960メール：jheffner@psc.edu"
    },
    {
      "indent": 3,
      "text": "Rajiv Raghunarayan Cisco Systems Inc. San Jose, CA 95134 Phone: 408 853 9612 EMail: raraghun@cisco.com",
      "ja": "Rajiv Raghunarayan Cisco Systems Inc. San Jose、CA 95134電話：408 853 9612メール：raraghun@cisco.com"
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The IETF Trust (2007).",
      "ja": "著作権（c）The IETF Trust（2007）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会、IETFトラスト、インターネットエンジニアリングタスクフォースがすべてを否認します。明示的または黙示的な保証。ここでの情報の使用は、特定の目的に対する商品性または適合性の権利または暗黙の保証を侵害しないという保証を含むがこれらに限定されない。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}