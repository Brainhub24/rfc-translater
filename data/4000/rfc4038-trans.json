{
  "title": {
    "text": "RFC 4038 - Application Aspects of IPv6 Transition",
    "ja": "RFC 4038 - IPv6遷移のアプリケーションの側面"
  },
  "number": 4038,
  "created_at": "2023-08-17 17:17:16.107008+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                     M-K. Shin, Ed.\nRequest for Comments: 4038                                     ETRI/NIST\nCategory: Informational                                        Y-G. Hong\n                                                                    ETRI\n                                                               J. Hagino\n                                                                     IIJ\n                                                               P. Savola\n                                                               CSC/FUNET\n                                                            E. M. Castro\n                                                               GSYC/URJC\n                                                              March 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Application Aspects of IPv6 Transition",
      "ja": "IPv6遷移のアプリケーションの側面"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "As IPv6 networks are deployed and the network transition is discussed, one should also consider how to enable IPv6 support in applications running on IPv6 hosts, and the best strategy to develop IP protocol support in applications. This document specifies scenarios and aspects of application transition. It also proposes guidelines on how to develop IP version-independent applications during the transition period.",
      "ja": "IPv6ネットワークが展開され、ネットワークトランジションが議論されるため、IPv6ホストで実行されているアプリケーションでIPv6サポートを有効にする方法を検討する必要があります。このドキュメントは、アプリケーションの移行のシナリオと側面を指定します。また、移行期間中にIPバージョンに依存しないアプリケーションを開発する方法に関するガイドラインを提案しています。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction .................................................  3\n2.  Overview of IPv6 Application Transition ......................  3\n3.  Problems with IPv6 Application Transition ....................  5\n    3.1.  IPv6 Support in the OS and Applications Are Unrelated...  5\n    3.2.  DNS Does Not Indicate Which IP Version Will Be Used ....  6\n    3.3.  Supporting Many Versions of an Application Is Difficult.  6\n4.  Description of Transition Scenarios and Guidelines ...........  7\n    4.1.  IPv4 Applications in a Dual-Stack Node .................  7\n    4.2.  IPv6 Applications in a Dual-Stack Node .................  8\n    4.3.  IPv4/IPv6 Applications in a Dual-Stack Node ............ 11\n    4.4.  IPv4/IPv6 Applications in an IPv4-only Node ............ 12\n5.  Application Porting Considerations ........................... 12\n    5.1.  Presentation Format for an IP Address .................. 13\n    5.2.  Transport Layer API .................................... 14\n    5.3.  Name and Address Resolution ............................ 15\n    5.4.  Specific IP Dependencies ............................... 16\n          5.4.1.  IP Address Selection ........................... 16\n          5.4.2.  Application Framing ............................ 16\n          5.4.3.  Storage of IP addresses ........................ 17\n    5.5.  Multicast Applications ................................. 17\n6.  Developing IP Version - Independent Applications ............. 18\n    6.1.  IP Version - Independent Structures..................... 18\n    6.2.  IP Version - Independent APIs........................... 19\n          6.2.1.  Example of Overly Simplistic TCP Server\n                  Application .................................... 20\n          6.2.2.  Example of Overly Simplistic TCP Client\n                  Application .................................... 21\n          6.2.3.  Binary/Presentation Format Conversion .......... 22\n    6.3.  Iterated Jobs for Finding the Working Address .......... 23\n          6.3.1.  Example of TCP Server Application .............. 23\n          6.3.2.  Example of TCP Client Application .............. 25\n7.  Transition Mechanism Considerations .......................... 26\n8.  Security Considerations ...................................... 26\n9.  Acknowledgments .............................................. 27\n10. References ................................................... 27\nAppendix A.  Other Binary/Presentation Format Conversions ........ 30\n    A.1.  Binary to Presentation Using inet_ntop() ............... 30\n    A.2.  Presentation to Binary Using inet_pton() ............... 31\nAuthors' Addresses ............................................... 32\nFull Copyright Statement ......................................... 33",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "As IPv6 is introduced in the IPv4-based Internet, several general issues will arise, such as routing, addressing, DNS, and scenarios.",
      "ja": "IPv6がIPv4ベースのインターネットで導入されると、ルーティング、アドレス指定、DNS、シナリオなど、いくつかの一般的な問題が発生します。"
    },
    {
      "indent": 3,
      "text": "An important key to a successful IPv6 transition is compatibility with the large installed base of IPv4 hosts and routers. This issue has already been extensively studied, and work is still in progress. [2893BIS] describes the basic transition mechanisms: dual-stack deployment and tunneling. Various other kinds of mechanisms have been developed for the transition to an IPv6 network. However, these transition mechanisms take no stance on whether applications support IPv6.",
      "ja": "IPv6遷移を成功させるための重要な鍵は、IPv4ホストとルーターの大きな設置ベースとの互換性です。この問題はすでに広範囲に研究されており、作業はまだ進行中です。[2893bis]は、基本的な遷移メカニズム：デュアルスタックの展開とトンネリングについて説明しています。IPv6ネットワークへの移行のために、他のさまざまな種類のメカニズムが開発されています。ただし、これらの遷移メカニズムは、アプリケーションがIPv6をサポートするかどうかについての姿勢をとっていません。"
    },
    {
      "indent": 3,
      "text": "This document specifies application aspects of IPv6 transition. Two inter-related topics are covered:",
      "ja": "このドキュメントは、IPv6遷移のアプリケーションの側面を指定します。相互に関連する2つのトピックがカバーされています。"
    },
    {
      "indent": 6,
      "text": "1. How different network transition techniques affect applications, and strategies for applications to support IPv6 and IPv4.",
      "ja": "1. 異なるネットワーク遷移手法がアプリケーションにどのように影響するか、およびIPv6とIPv4をサポートするアプリケーションの戦略。"
    },
    {
      "indent": 6,
      "text": "2. How to develop IPv6-capable or protocol-independent applications (\"application porting guidelines\") using standard APIs [RFC3493][RFC3542].",
      "ja": "2. 標準API [RFC3493] [RFC3542]を使用して、IPv6対応またはプロトコル非依存性アプリケーション（「アプリケーションポーティングガイドライン」）を開発する方法。"
    },
    {
      "indent": 3,
      "text": "In the context of this document, the term \"application\" covers all kinds of applications, but the focus is on those network applications which have been developed using relatively low-level APIs (such as the \"C\" language, using standard libraries). Many such applications could be command-line driven, but that is not a requirement.",
      "ja": "このドキュメントのコンテキストでは、「アプリケーション」という用語はあらゆる種類のアプリケーションをカバーしていますが、比較的低レベルのAPI（標準ライブラリを使用して「C」言語など）を使用して開発されたネットワークアプリケーションに焦点が当てられています。そのようなアプリケーションの多くはコマンドライン駆動型かもしれませんが、それは要件ではありません。"
    },
    {
      "indent": 3,
      "text": "Applications will have to be modified to support IPv6 (and IPv4) by using one of a number of techniques described in sections 2 - 4. Guidelines for developing such applications are presented in sections 5 and 6.",
      "ja": "セクション2-4で説明されている多くの手法のいずれかを使用して、IPv6（およびIPv4）をサポートするためにアプリケーションを変更する必要があります。このようなアプリケーションを開発するためのガイドラインは、セクション5および6に示されています。"
    },
    {
      "indent": 0,
      "text": "2. Overview of IPv6 Application Transition",
      "section_title": true,
      "ja": "2. IPv6アプリケーションの遷移の概要"
    },
    {
      "indent": 3,
      "text": "The transition of an application can be classified by using four different cases (excluding the first case when there is no IPv6 support in either the application or the operating system):",
      "ja": "アプリケーションの遷移は、4つの異なるケースを使用して分類できます（アプリケーションまたはオペレーティングシステムのいずれにもIPv6サポートがない場合の最初のケースを除く）："
    },
    {
      "indent": 6,
      "text": "+-------------------+\n|       appv4       | (appv4 - IPv4-only applications)\n+-------------------+\n| TCP / UDP / others| (transport protocols - TCP, UDP,\n+-------------------+  SCTP, DCCP, etc.)\n|    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)\n+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Case 1. IPv4 applications in a dual-stack node.",
      "ja": "ケース1.デュアルスタックノードのIPv4アプリケーション。"
    },
    {
      "indent": 6,
      "text": "+-------------------+ (appv4 - IPv4-only applications)\n|  appv4  |  appv6  | (appv6 - IPv6-only applications)\n+-------------------+\n| TCP / UDP / others| (transport protocols - TCP, UDP,\n+-------------------+             SCTP, DCCP, etc.)\n|    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)\n+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Case 2. IPv4-only applications and IPv6-only applications in a dual-stack node.",
      "ja": "ケース2.デュアルスタックノードのIPv4のみのアプリケーションとIPv6のみのアプリケーション。"
    },
    {
      "indent": 6,
      "text": "+-------------------+\n|     appv4/v6      | (appv4/v6 - applications supporting\n+-------------------+             both IPv4 and IPv6)\n| TCP / UDP / others| (transport protocols - TCP, UDP,\n+-------------------+             SCTP, DCCP, etc.)\n|    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)\n+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Case 3. Applications supporting both IPv4 and IPv6 in a dual-stack node.",
      "ja": "ケース3.デュアルスタックノードでIPv4とIPv6の両方をサポートするアプリケーション。"
    },
    {
      "indent": 6,
      "text": "+-------------------+\n|     appv4/v6      | (appv4/v6 - applications supporting\n+-------------------+             both IPv4 and IPv6)\n| TCP / UDP / others| (transport protocols - TCP, UDP,\n+-------------------+             SCTP, DCCP, etc.)\n|       IPv4        | (IP protocols supported/enabled in the OS)\n+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Case 4. Applications supporting both IPv4 and IPv6 in an IPv4-only node.",
      "ja": "ケース4. IPv4のみのノードでIPv4とIPv6の両方をサポートするアプリケーション。"
    },
    {
      "indent": 9,
      "text": "Figure 1. Overview of Application Transition",
      "ja": "図1.アプリケーションの遷移の概要"
    },
    {
      "indent": 5,
      "text": "Figure 1 shows the cases of application transition.",
      "ja": "図1は、アプリケーション遷移のケースを示しています。"
    },
    {
      "indent": 6,
      "text": "Case 1: IPv4-only applications in a dual-stack node. IPv6 protocol is introduced in a node, but applications are not yet ported to support IPv6.",
      "ja": "ケース1：デュアルスタックノードのIPv4のみのアプリケーション。IPv6プロトコルはノードで導入されていますが、アプリケーションはまだIPv6をサポートするために移植されていません。"
    },
    {
      "indent": 6,
      "text": "Case 2: IPv4-only applications and IPv6-only applications in a dual-stack node. Applications are ported for IPv6-only. Therefore there are two similar applications, one for each protocol version (e.g., ping and ping6).",
      "ja": "ケース2：デュアルスタックノードのIPv4のみのアプリケーションとIPv6のみのアプリケーション。アプリケーションはIPv6のみに移植されます。したがって、2つの同様のアプリケーションがあります。1つは各プロトコルバージョン（PingおよびPing6など）です。"
    },
    {
      "indent": 6,
      "text": "Case 3: Applications supporting both IPv4 and IPv6 in a dual stack node. Applications are ported for both IPv4 and IPv6 support. Therefore, the existing IPv4 applications can be removed.",
      "ja": "ケース3：デュアルスタックノードでIPv4とIPv6の両方をサポートするアプリケーション。アプリケーションは、IPv4サポートとIPv6サポートの両方に移植されます。したがって、既存のIPv4アプリケーションを削除できます。"
    },
    {
      "indent": 6,
      "text": "Case 4: Applications supporting both IPv4 and IPv6 in an IPv4-only node. Applications are ported for both IPv4 and IPv6 support, but the same applications may also have to work when IPv6 is not being used (e.g., disabled from the OS).",
      "ja": "ケース4：IPv4のみのノードでIPv4とIPv6の両方をサポートするアプリケーション。アプリケーションはIPv4サポートとIPv6サポートの両方に移植されますが、IPv6が使用されていない場合に同じアプリケーションも機能する必要があります（OSから無効になっています）。"
    },
    {
      "indent": 3,
      "text": "The first two cases are not interesting in the longer term; only few applications are inherently IPv4- or IPv6-specific, and should work with both protocols without having to care about which one is being used.",
      "ja": "最初の2つのケースは長期的には興味深いものではありません。本質的にIPv4-またはIPv6固有のアプリケーションはわずかであり、どちらが使用されているかを気にせずに両方のプロトコルで動作する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Problems with IPv6 Application Transition",
      "section_title": true,
      "ja": "3. IPv6アプリケーションの遷移の問題"
    },
    {
      "indent": 3,
      "text": "There are several reasons why the transition period between IPv4 and IPv6 applications may not be straightforward. These issues are described in this section.",
      "ja": "IPv4アプリケーションとIPv6アプリケーションの間の遷移期間が簡単ではない理由はいくつかあります。これらの問題については、このセクションで説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. IPv6 Support in the OS and Applications Are Unrelated",
      "section_title": true,
      "ja": "3.1. OSおよびアプリケーションでのIPv6サポートは無関係です"
    },
    {
      "indent": 3,
      "text": "Considering the cases described in the previous section, IPv4 and IPv6 protocol stacks are likely to co-exist in a node for a long time.",
      "ja": "前のセクションで説明したケースを考慮すると、IPv4およびIPv6プロトコルスタックは、長い間ノードに共存する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, most applications are expected to be able to handle both IPv4 and IPv6 during another long period. A dual-stack operating system is not intended to have both IPv4 and IPv6 applications. Therefore, IPv6-capable application transition may be independent of protocol stacks in a node.",
      "ja": "同様に、ほとんどのアプリケーションは、別の長期にわたってIPv4とIPv6の両方を処理できることが期待されています。デュアルスタックオペレーティングシステムは、IPv4アプリケーションとIPv6アプリケーションの両方を搭載することを目的としていません。したがって、IPv6対応アプリケーションの遷移は、ノード内のプロトコルスタックとは無関係になる場合があります。"
    },
    {
      "indent": 3,
      "text": "Applications capable of both IPv4 and IPv6 will probably have to work properly in IPv4-only nodes (whether the IPv6 protocol is completely disabled or there is no IPv6 connectivity at all).",
      "ja": "IPv4とIPv6の両方が可能なアプリケーションは、おそらくIPv4のみのノードで適切に動作する必要があります（IPv6プロトコルが完全に無効になっているか、IPv6接続がまったくないかどうか）。"
    },
    {
      "indent": 0,
      "text": "3.2. DNS Does Not Indicate Which IP Version Will Be Used",
      "section_title": true,
      "ja": "3.2. DNSは、どのIPバージョンが使用されるかを示していません"
    },
    {
      "indent": 3,
      "text": "In a node, the DNS name resolver gathers the list of destination addresses. DNS queries and responses are sent by using either IPv4 or IPv6 to carry the queries, regardless of the protocol version of the data records [DNSTRANS].",
      "ja": "ノードでは、DNS名リゾルバーが宛先アドレスのリストを収集します。DNSクエリと応答は、データレコード[DNSTRANS]のプロトコルバージョンに関係なく、IPv4またはIPv6のいずれかを使用してクエリを運ぶことにより送信されます。"
    },
    {
      "indent": 3,
      "text": "The DNS name resolution issue related to application transition is that by only doing a DNS name lookup a client application can not be certain of the version of the peer application. For example, if a server application does not support IPv6 yet but runs on a dual-stack machine for other IPv6 services, and this host is listed with an AAAA record in the DNS, the client application will fail to connect to the server application. This is caused by a mismatch between the DNS query result (i.e., IPv6 addresses) and a server application version (i.e., IPv4).",
      "ja": "アプリケーションの移行に関連するDNS名解決の問題は、DNS名を検索するだけで、クライアントアプリケーションがピアアプリケーションのバージョンを確信できないということです。たとえば、サーバーアプリケーションがまだIPv6をサポートせず、他のIPv6サービスのデュアルスタックマシンで実行している場合、このホストはDNSのAAAAレコードでリストされている場合、クライアントアプリケーションはサーバーアプリケーションに接続できません。これは、DNSクエリ結果（つまり、IPv6アドレス）とサーバーアプリケーションバージョン（つまり、IPv4）の間の不一致によって引き起こされます。"
    },
    {
      "indent": 3,
      "text": "Using SRV records would avoid these problems. Unfortunately, they are not used widely enough to be applicable in most cases. Hence an operational solution is to use \"service names\" in the DNS. If a node offers multiple services, but only some of them over IPv6, a DNS name may be added for each of these services or group of services (with the associated A/AAAA records), not just a single name for the physical machine, also including the AAAA records. However, the applications cannot depend on this operational practice.",
      "ja": "SRVレコードを使用すると、これらの問題が回避されます。残念ながら、それらはほとんどの場合に適用できるほど広く使用されていません。したがって、運用ソリューションは、DNSで「サービス名」を使用することです。ノードが複数のサービスを提供しているが、その一部のみがIPv6を介して提供している場合、これらのサービスまたはグループ（関連するA/AAAAレコードを使用）の各サービスに対してDNS名を追加できます。物理マシンの単一の名前だけでなく、AAAAレコードも含まれます。ただし、アプリケーションはこの運用慣行に依存することはできません。"
    },
    {
      "indent": 3,
      "text": "The application should request all IP addresses without address family constraints and try all the records returned from the DNS, in some order, until a working address is found. In particular, the application has to be able to handle all IP versions returned from the DNS. This issue is discussed in more detail in [DNSOPV6].",
      "ja": "アプリケーションは、家族の制約なしですべてのIPアドレスを要求し、作業アドレスが見つかるまでDNSから返されたすべてのレコードをある程度試してみてください。特に、アプリケーションは、DNSから返されるすべてのIPバージョンを処理できる必要があります。この問題については、[dnsopv6]で詳細に説明します。"
    },
    {
      "indent": 0,
      "text": "3.3. Supporting Many Versions of an Application is Difficult",
      "section_title": true,
      "ja": "3.3. アプリケーションの多くのバージョンをサポートすることは困難です"
    },
    {
      "indent": 3,
      "text": "During the application transition period, system administrators may have various versions of the same application (an IPv4-only application, an IPv6-only application, or an application supporting both IPv4 and IPv6).",
      "ja": "アプリケーションの移行期間中、システム管理者は同じアプリケーションのさまざまなバージョン（IPv4のみのアプリケーション、IPv6のみのアプリケーション、またはIPv4とIPv6の両方をサポートするアプリケーション）を持っている場合があります。"
    },
    {
      "indent": 3,
      "text": "Typically one cannot know which IP versions must be supported prior to doing a DNS lookup *and* trying (see section 3.2) the addresses returned. Therefore if multiple versions of the same application are available, the local users have difficulty selecting the right version supporting the exact IP version required.",
      "ja": "通常、DNSルックアップ *および *試行（セクション3.2を参照）を実行する前に、どのIPバージョンをサポートする必要があるかを知ることはできません。したがって、同じアプリケーションの複数のバージョンが利用可能な場合、ローカルユーザーは必要な正確なIPバージョンをサポートする適切なバージョンを選択するのが困難です。"
    },
    {
      "indent": 3,
      "text": "To avoid problems with one application not supporting the specified protocol version, it is desirable to have hybrid applications supporting both.",
      "ja": "指定されたプロトコルバージョンをサポートしていない1つのアプリケーションの問題を回避するには、両方をサポートするハイブリッドアプリケーションを持つことが望ましいです。"
    },
    {
      "indent": 3,
      "text": "An alternative approach for local client applications could be to have a \"wrapper application\" that performs certain tasks (such as figuring out which protocol version will be used) and calls the IPv4/IPv6-only applications as necessary. This application would perform connection establishment (or similar tasks) and pass the opened socket to another application. However, as applications such as this would have to do more than just perform a DNS lookup or determine the literal IP address given, they will become complex -- likely much more so than a hybrid application. Furthermore, writing \"wrapping\" applications that perform complex operations with IP addresses (such as FTP clients) might be even more challenging or even impossible. In short, wrapper applications do not look like a robust approach for application transition.",
      "ja": "ローカルクライアントアプリケーションの代替アプローチは、特定のタスク（どのプロトコルバージョンが使用されるかを把握するなど）を実行し、必要に応じてIPv4/IPv6のみのアプリケーションを呼び出す「ラッパーアプリケーション」を持つことです。このアプリケーションは、接続確立（または同様のタスク）を実行し、開いたソケットを別のアプリケーションに渡します。ただし、このようなアプリケーションは、DNSルックアップを実行したり、指定された文字通りのIPアドレスを決定する以上のことを行う必要があるため、複雑になります。ハイブリッドアプリケーションよりもはるかに多いでしょう。さらに、IPアドレス（FTPクライアントなど）で複雑な操作を実行する「ラッピング」アプリケーションを作成することは、さらに挑戦的または不可能でさえあります。要するに、ラッパーアプリケーションは、アプリケーション遷移の堅牢なアプローチのようには見えません。"
    },
    {
      "indent": 0,
      "text": "4. Description of Transition Scenarios and Guidelines",
      "section_title": true,
      "ja": "4. 移行シナリオとガイドラインの説明"
    },
    {
      "indent": 3,
      "text": "Once the IPv6 network is deployed, applications supporting IPv6 can use IPv6 network services to establish IPv6 connections. However, upgrading every node to IPv6 at the same time is not feasible, and transition from IPv4 to IPv6 will be a gradual process.",
      "ja": "IPv6ネットワークが展開されると、IPv6ネットワークをサポートするアプリケーションはIPv6ネットワークサービスを使用してIPv6接続を確立できます。ただし、すべてのノードを同時にIPv6にアップグレードすることは実行不可能であり、IPv4からIPv6への移行は段階的なプロセスになります。"
    },
    {
      "indent": 3,
      "text": "Dual-stack nodes provide one solution to maintaining IPv4 compatibility in unicast communications. In this section we will analyze different application transition scenarios (as introduced in section 2) and guidelines for maintaining interoperability between applications running in different types of nodes.",
      "ja": "デュアルスタックノードは、ユニキャスト通信におけるIPv4互換性を維持するための1つのソリューションを提供します。このセクションでは、さまざまなアプリケーション遷移シナリオ（セクション2で導入されている）と、さまざまなタイプのノードで実行されているアプリケーション間の相互運用性を維持するためのガイドラインを分析します。"
    },
    {
      "indent": 3,
      "text": "Note that the first two cases, IPv4-only and IPv6-only applications, are not interesting in the longer term; only few applications are inherently IPv4- or IPv6-specific, and should work with both protocols without having to care about which one is being used.",
      "ja": "最初の2つのケース、IPv4のみのアプリケーションとIPv6のみのアプリケーションは、長期的には興味深いものではないことに注意してください。本質的にIPv4-またはIPv6固有のアプリケーションはわずかであり、どちらが使用されているかを気にせずに両方のプロトコルで動作する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1. IPv4 Applications in a Dual-Stack Node",
      "section_title": true,
      "ja": "4.1. デュアルスタックノードのIPv4アプリケーション"
    },
    {
      "indent": 3,
      "text": "In this scenario, the IPv6 protocol is added in a node, but IPv6- capable applications aren't yet available or installed. Although the node implements the dual stack, IPv4 applications can only manage IPv4 communications and accept/establish connections from/to nodes that implement an IPv4 stack.",
      "ja": "このシナリオでは、IPv6プロトコルはノードに追加されますが、IPv6-有能なアプリケーションはまだ利用可能またはインストールされていません。ノードはデュアルスタックを実装していますが、IPv4アプリケーションはIPv4通信のみを管理し、IPv4スタックを実装するノードからの接続を受け入れる/確立できます。"
    },
    {
      "indent": 3,
      "text": "To allow an application to communicate with other nodes using IPv6, the first priority is to port applications to IPv6.",
      "ja": "アプリケーションがIPv6を使用して他のノードと通信できるようにするために、最優先事項はアプリケーションをIPv6にポートすることです。"
    },
    {
      "indent": 3,
      "text": "In some cases (e.g., when no source code is available), existing IPv4 applications can work if the Bump-in-the-Stack [BIS] or Bump-in-the-API [BIA] mechanism is installed in the node. We strongly recommend that application developers not use these mechanisms when application source code is available. Also, they should not be used as an excuse not to port software or to delay porting.",
      "ja": "場合によっては（たとえば、ソースコードが利用できない場合）、既存のIPv4アプリケーションは、ノードにバンプイン[BIS]またはBump-in-api [BIA]メカニズムがノードにインストールされている場合に機能します。アプリケーションソースコードが利用可能な場合、アプリケーション開発者はこれらのメカニズムを使用しないことを強くお勧めします。また、それらは、ソフトウェアを移植したり、移植を遅らせたりしない言い訳として使用すべきではありません。"
    },
    {
      "indent": 3,
      "text": "When [BIA] or [BIS] is used, the problem described in section 3.2 arises - (the IPv4 client in a [BIS]/[BIA] node tries to connect to an IPv4 server in a dual stack system). However, one can rely on the [BIA]/[BIS] mechanism, which should cycle through all the addresses instead of applications.",
      "ja": "[BIA]または[BIS]を使用すると、セクション3.2で説明されている問題が発生します（[BIS]/[BIA]ノードのIPv4クライアントは、デュアルスタックシステムのIPv4サーバーに接続しようとします）。ただし、[bia]/[bis]メカニズムに依存することができます。これは、アプリケーションではなくすべてのアドレスを循環する必要があります。"
    },
    {
      "indent": 3,
      "text": "[BIS] and [BIA] do not work with all kinds of applications - in particular, with applications that exchange IP addresses as application data (e.g., FTP). These mechanisms provide IPv4 temporary addresses to the applications and locally make a translation between IPv4 and IPv6 communication. Therefore, these IPv4 temporary addresses are only valid in the node scope.",
      "ja": "[BIS]および[BIA]は、あらゆる種類のアプリケーション、特にアプリケーションデータ（FTPなど）としてIPアドレスを交換するアプリケーションでは機能しません。これらのメカニズムは、アプリケーションにIPv4の一時的なアドレスを提供し、IPv4とIPv6通信の間の翻訳を局所的に作成します。したがって、これらのIPv4の一時アドレスは、ノードスコープでのみ有効です。"
    },
    {
      "indent": 0,
      "text": "4.2. IPv6 Applications in a Dual-Stack Node",
      "section_title": true,
      "ja": "4.2. デュアルスタックノードのIPv6アプリケーション"
    },
    {
      "indent": 3,
      "text": "As we have seen in the previous section, applications should be ported to IPv6. The easiest way to port an IPv4 application is to substitute the old IPv4 API references with the new IPv6 APIs with one-to-one mapping. This way the application will be IPv6-only. This IPv6-only source code cannot work in IPv4-only nodes, so the old IPv4 application should be maintained in these nodes. This necessitates having two similar applications working with different protocol versions, depending on the node they are running (e.g., telnet and telnet6). This case is undesirable, as maintaining two versions of the same source code per application could be difficult. This approach would also cause problems for users having to select which version of the application to use, as described in section 3.3.",
      "ja": "前のセクションで見たように、アプリケーションはIPv6に移植する必要があります。IPv4アプリケーションをポートする最も簡単な方法は、古いIPv4 API参照を新しいIPv6 APIに1対1のマッピングに置き換えることです。このようにして、アプリケーションはIPv6のみになります。このIPv6のみのソースコードは、IPv4のみのノードでは動作できないため、古いIPv4アプリケーションをこれらのノードに維持する必要があります。これには、実行中のノード（たとえば、TelnetやTelnet6）に応じて、異なるプロトコルバージョンで動作する2つの同様のアプリケーションが必要です。このケースは望ましくありません。アプリケーションごとに同じソースコードの2つのバージョンを維持することは困難な場合があります。また、このアプローチは、セクション3.3で説明されているように、使用するアプリケーションのバージョンを選択する必要があるユーザーに問題を引き起こします。"
    },
    {
      "indent": 3,
      "text": "Most implementations of dual stack allow IPv6-only applications to interoperate with both IPv4 and IPv6 nodes. IPv4 packets going to IPv6 applications on a dual-stack node reach their destination because their addresses are mapped by using IPv4-mapped IPv6 addresses: the IPv6 address ::FFFF:x.y.z.w represents the IPv4 address x.y.z.w.",
      "ja": "デュアルスタックのほとんどの実装により、IPv6のみのアプリケーションがIPv4ノードとIPv6ノードの両方と相互操作できます。IPv4-Mapped IPv6アドレスを使用してアドレスがマッピングされるため、デュアルスタックノードのIPv6アプリケーションに到達するIPv4アプリケーションが宛先に到達します。IPv6アドレス:: ffff：x.y.z.wは、IPv4アドレスX.Y.Z.Wを表します。"
    },
    {
      "indent": 6,
      "text": "+----------------------------------------------+\n| +------------------------------------------+ |\n| |                                          | |\n| |        IPv6-only applications            | |\n| |                                          | |\n| +------------------------------------------+ |\n|                      |                       |\n| +------------------------------------------+ |\n| |                                          | |\n| |   TCP / UDP / others (SCTP, DCCP, etc.)  | |\n| |                                          | |\n| +------------------------------------------+ |\n|    IPv4-mapped    |        |    IPv6         |\n|  IPv6 addresses   |        |   addresses     |\n| +--------------------+ +-------------------+ |\n| |        IPv4        | |      IPv6         | |\n| +--------------------+ +-------------------+ |\n|   IPv4       |                 |             |\n|   addresses  |                 |             |\n+--------------|-----------------|-------------+\n               |                 |\n          IPv4 packets      IPv6 packets",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We will analyze the behaviour of IPv6-applications that exchange IPv4 packets with IPv4 applications by using the client/server model. We consider the default case to be when the IPV6_V6ONLY socket option has not been set. In these dual-stack nodes, this default behavior allows a limited amount of IPv4 communication using the IPv4-mapped IPv6 addresses.",
      "ja": "クライアント/サーバーモデルを使用して、IPv4パケットをIPv4アプリケーションと交換するIPv6アプリケーションの動作を分析します。デフォルトのケースは、IPv6_V6onlyソケットオプションが設定されていない場合と考えられます。これらのデュアルスタックノードでは、このデフォルトの動作により、IPv4-Mapped IPv6アドレスを使用して、限られた量のIPv4通信が可能になります。"
    },
    {
      "indent": 6,
      "text": "IPv6-only server: When an IPv4 client application sends data to an IPv6-only server application running on a dual-stack node by using the wildcard address, the IPv4 client address is interpreted as the IPv4-mapped IPv6 address in the dual-stack node. This allows the IPv6 application to manage the communication. The IPv6 server will use this mapped address as if it were a regular IPv6 address, and a usual IPv6 connection. However, IPv4 packets will be exchanged between the nodes. Kernels with dual stack properly interpret IPv4-mapped IPv6 addresses as IPv4 ones, and vice versa.",
      "ja": "IPv6のみのサーバー：IPv4クライアントアプリケーションがWildCardアドレスを使用してデュアルスタックノードで実行されているIPv6のみのサーバーアプリケーションにデータを送信すると、IPv4クライアントアドレスはデュアルスタックのIPv4マップIPv6アドレスとして解釈されますノード。これにより、IPv6アプリケーションが通信を管理できます。IPv6サーバーは、このマッピングされたアドレスを通常のIPv6アドレスであり、通常のIPv6接続であるかのように使用します。ただし、IPv4パケットはノード間で交換されます。デュアルスタックを備えたカーネルは、IPv4-Mapped IPv6アドレスをIPv4のアドレスとして適切に解釈し、その逆も同様です。"
    },
    {
      "indent": 6,
      "text": "IPv6-only client: IPv6-only client applications in a dual-stack node will not receive IPv4-mapped addresses from the hostname resolution API functions unless a special hint, AI_V4MAPPED, is given. If it is, the IPv6 client will use the returned mapped address as if it were a regular IPv6 address, and a usual IPv6 connection. However, IPv4 packets will be exchanged between applications.",
      "ja": "IPv6のみのクライアント：デュアルスタックノードのIPv6のみのクライアントアプリケーションは、特別なヒント、AI_V4Mappedが与えられない限り、ホスト名解像度API関数からIPv4マップのアドレスを受信しません。もしそうなら、IPv6クライアントは、通常のIPv6アドレスと通常のIPv6接続であるかのように、返されたマッピングアドレスを使用します。ただし、IPv4パケットはアプリケーション間で交換されます。"
    },
    {
      "indent": 3,
      "text": "Respectively, with IPV6_V6ONLY set, an IPv6-only server application will only communicate with IPv6 nodes, and an IPv6-only client only with IPv6 servers, as the mapped addresses have been disabled. This option could be useful if applications use new IPv6 features such as Flow Label. If communication with IPv4 is needed, either IPV6_V6ONLY must not be used, or dual-stack applications must be used, as described in section 4.3.",
      "ja": "それぞれIPv6_v6onlyセットを使用すると、IPv6のみのサーバーアプリケーションは、マッピングされたアドレスが無効になっているため、IPv6ノードとIPv6のみのクライアントのみをIPv6サーバーでのみ通信します。このオプションは、アプリケーションがフローラベルなどの新しいIPv6機能を使用する場合に役立ちます。IPv4との通信が必要な場合は、セクション4.3で説明されているように、IPv6_v6onlyを使用する必要はないか、デュアルスタックアプリケーションを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some implementations of dual-stack do not allow IPv4-mapped IPv6 addresses to be used for interoperability between IPv4 and IPv6 applications. In these cases, there are two ways to handle the problem:",
      "ja": "デュアルスタックのいくつかの実装では、IPv4アプリケーションとIPv6アプリケーション間の相互運用性にIPv4-MappのIPv6アドレスを使用することはできません。これらの場合、問題を処理するには2つの方法があります。"
    },
    {
      "indent": 6,
      "text": "1. Deploy two different versions of the application (possibly attached with '6' in the name).",
      "ja": "1. アプリケーションの2つの異なるバージョンを展開します（名前に「6」で添付されます）。"
    },
    {
      "indent": 6,
      "text": "2. Deploy just one application supporting both protocol versions as described in the next section.",
      "ja": "2. 次のセクションで説明されているように、両方のプロトコルバージョンをサポートするアプリケーションを1つだけ展開します。"
    },
    {
      "indent": 3,
      "text": "The first method is not recommended because of a significant number of problems associated with selecting the right applications. These problems are described in sections 3.2 and 3.3.",
      "ja": "適切なアプリケーションの選択に関連するかなりの数の問題があるため、最初の方法は推奨されません。これらの問題は、セクション3.2および3.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "Therefore, there are two distinct cases to consider when writing one application to support both protocols:",
      "ja": "したがって、両方のプロトコルをサポートするために1つのアプリケーションを作成する際に考慮すべき2つの異なるケースがあります。"
    },
    {
      "indent": 6,
      "text": "1. Whether the application can (or should) support both IPv4 and IPv6 through IPv4-mapped IPv6 addresses or the applications should support both explicitly (see section 4.3), and",
      "ja": "1. アプリケーションがIPv4とIPv6の両方をサポートできる（またはIPv4とIPv6の両方がIPv6アドレスをサポートできるかどうか、またはアプリケーションが明示的にサポートする必要があります（セクション4.3を参照）、および"
    },
    {
      "indent": 6,
      "text": "2. Whether the systems in which the applications are used support IPv6 (see section 4.4).",
      "ja": "2. アプリケーションが使用されるシステムがIPv6をサポートするかどうか（セクション4.4を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that some systems will disable (by default) support for internal IPv4-mapped IPv6 addresses. The security concerns regarding these are legitimate, but disabling them internally breaks one transition mechanism for server applications originally written to bind() and listen() to a single socket by using a wildcard address. This forces the software developer to rewrite the daemon to create two separate sockets, one for IPv4 only and the other for IPv6 only, and then to use select(). However, mapping-enabling of IPv4 addresses on any particular system is controlled by the OS owner and not necessarily by a developer. This complicates developers' work, as they now have to rewrite the daemon network code to handle both environments, even for the same OS.",
      "ja": "一部のシステムは、内部IPv4マップIPv6アドレスの（デフォルトで）サポートを無効にすることに注意してください。これらに関するセキュリティの懸念は正当なものですが、それらを無効にすると、ワイルドカードアドレスを使用して、bind（）およびlisten（）に単一のソケットに当初書かれたサーバーアプリケーションの1つの遷移メカニズムが内部的に破損します。これにより、ソフトウェア開発者はデーモンを書き換えて2つの別々のソケットを作成するようになります。1つはIPv4のみ、もう1つはIPv6のみで、次にSelect（）を使用します。ただし、特定のシステムでのIPv4アドレスのマッピングエバレーションは、OSの所有者によって制御され、必ずしも開発者によってではありません。これにより、開発者の作業が複雑になります。これは、同じOSであっても、両方の環境を処理するためにデーモンネットワークコードを書き直す必要があるためです。"
    },
    {
      "indent": 0,
      "text": "4.3. IPv4/IPv6 Applications in a Dual-Stack Node",
      "section_title": true,
      "ja": "4.3. デュアルスタックノードのIPv4/IPv6アプリケーション"
    },
    {
      "indent": 3,
      "text": "Applications should be ported to support both IPv4 and IPv6. Over time, the existing IPv4-only applications could be removed. As we have only one version of each application, the source code will typically be easy to maintain and to modify, and there are no problems managing which application to select for which communication.",
      "ja": "アプリケーションは、IPv4とIPv6の両方をサポートするために移植する必要があります。時間が経つにつれて、既存のIPv4のみのアプリケーションを削除できます。各アプリケーションのバージョンは1つしかないため、ソースコードは通常、メンテナンスと変更が容易であり、どのアプリケーションを選択するかを選択するのに問題はありません。"
    },
    {
      "indent": 3,
      "text": "This transition case is the most advisable. During the IPv6 transition period, applications supporting both IPv4 and IPv6 should be able to communicate with other applications, irrespective of the version of the protocol stack or the application in the node. Dual applications allow more interoperability between heterogeneous applications and nodes.",
      "ja": "この遷移ケースは最も推奨されます。IPv6遷移期間中、IPv4とIPv6の両方をサポートするアプリケーションは、プロトコルスタックのバージョンやノード内のアプリケーションに関係なく、他のアプリケーションと通信できるはずです。デュアルアプリケーションにより、不均一なアプリケーションとノード間の相互運用性が向上します。"
    },
    {
      "indent": 3,
      "text": "If the source code is written in a protocol-independent way, without dependencies on either IPv4 or IPv6, applications will be able to communicate with any combination of applications and types of nodes.",
      "ja": "ソースコードがIPv4またはIPv6のいずれかに依存せずにプロトコルに依存しない方法で記述されている場合、アプリケーションはアプリケーションとノードのタイプの任意の組み合わせと通信できます。"
    },
    {
      "indent": 3,
      "text": "Implementations typically prefer IPv6 by default if the remote node and application support it. However, if IPv6 connections fail, version-independent applications will automatically try IPv4 ones. The resolver returns a list of valid addresses for the remote node, and applications can iterate through all of them until connection succeeds.",
      "ja": "通常、実装は、リモートノードとアプリケーションがサポートする場合、デフォルトではデフォルトでIPv6を好みます。ただし、IPv6接続が失敗した場合、バージョンに依存しないアプリケーションは自動的にIPv4のアプリケーションを試します。Resolverは、リモートノードの有効なアドレスのリストを返し、アプリケーションは接続が成功するまですべてを繰り返すことができます。"
    },
    {
      "indent": 3,
      "text": "Application writers should be aware of this protocol ordering, which is typically the default, but the applications themselves usually need not be [RFC3484].",
      "ja": "アプリケーションライターは、通常はデフォルトであるこのプロトコルの順序に注意する必要がありますが、アプリケーション自体は通常[RFC3484]である必要はありません。"
    },
    {
      "indent": 3,
      "text": "If the source code is written in a protocol-dependent way, the application will support IPv4 and IPv6 explicitly by using two separate sockets. Note that there are some differences in bind() implementation - that is, in whether one can first bind to IPv6 wildcard addresses, and then to those for IPv4. Writing applications that cope with this can be a pain. Implementing IPV6_V6ONLY simplifies this. The IPv4 wildcard bind fails on some systems because the IPv4 address space is embedded into IPv6 address space when IPv4-mapped IPv6 addresses are used.",
      "ja": "ソースコードがプロトコル依存的に記述されている場合、アプリケーションは2つの別々のソケットを使用してIPv4とIPv6を明示的にサポートします。bind（）実装にはいくつかの違いがあることに注意してください。つまり、最初にIPv6ワイルドカードアドレスにバインドできるかどうか、次にIPv4の違いがあるかどうかに注意してください。これに対処するアプリケーションを書くことは痛みになる可能性があります。IPv6_v6onlyを実装すると、これが簡素化されます。IPv4アドレススペースがIPv4マップのIPv6アドレスを使用すると、IPv4アドレススペースがIPv6アドレス空間に埋め込まれているため、一部のシステムでIPv4ワイルドカードバインドが失敗します。"
    },
    {
      "indent": 3,
      "text": "A more detailed porting guideline is described in section 6.",
      "ja": "より詳細な移植ガイドラインについては、セクション6で説明します。"
    },
    {
      "indent": 0,
      "text": "4.4. IPv4/IPv6 Applications in an IPv4-Only Node",
      "section_title": true,
      "ja": "4.4. IPv4のみのノードでのIPv4/IPv6アプリケーション"
    },
    {
      "indent": 3,
      "text": "As the transition is likely to take place over a longer time frame, applications already ported to support both IPv4 and IPv6 may be run on IPv4-only nodes. This would typically be done to avoid supporting two application versions for older and newer operating systems, or to support a case in which the user wants to disable IPv6 for some reason.",
      "ja": "遷移はより長い時間枠で行われる可能性が高いため、IPv4とIPv6の両方をサポートするためにすでに移植されているアプリケーションは、IPv4のみのノードで実行される場合があります。これは通常、古いオペレーティングシステムと新しいオペレーティングシステムの2つのアプリケーションバージョンのサポートを避けたり、ユーザーが何らかの理由でIPv6を無効にしたい場合をサポートするために行われます。"
    },
    {
      "indent": 3,
      "text": "The most important case is the application support on systems where IPv6 support can be dynamically enabled or disabled by the users. Applications on such a system should be able to handle a situation IPv6 would not be enabled. Another scenario is when an application is deployed on older systems that do not support IPv6 at all (even the basic APIs such as getaddrinfo). In this case, the application designer has to make a case-by-case judgment call as to whether it makes sense to have compile-time toggle between an older and a newer API (having to support both in the code), or whether to provide getaddrinfo etc. function support on older platforms as part of the application libraries.",
      "ja": "最も重要なケースは、IPv6サポートをユーザーが動的に有効にしたり無効にしたりできるシステムのアプリケーションサポートです。このようなシステムのアプリケーションは、IPv6を有効にしない状況を処理できるはずです。別のシナリオは、IPv6をまったくサポートしていない古いシステムにアプリケーションを展開する場合です（getaddrinfoなどの基本的なAPIでさえ）。この場合、アプリケーションデザイナーは、古いAPIと新しいAPI（コードの両方でサポートしなければならない）をコンパイルすることが理にかなっているかどうか、またはするかどうかについて、ケースバイケースの判断電話をかける必要があります。アプリケーションライブラリの一部として、古いプラットフォームでgetaddrinfoなどを提供します。"
    },
    {
      "indent": 3,
      "text": "Depending on application/operating system support, some may want to ignore this case, but usually no assumptions can be made, and applications should also work in this scenario.",
      "ja": "アプリケーション/オペレーティングシステムのサポートに応じて、このケースを無視したい人もいますが、通常は仮定を行うことはできません。また、アプリケーションもこのシナリオで機能する必要があります。"
    },
    {
      "indent": 3,
      "text": "An example is an application that issues a socket() command, first trying AF_INET6 and then AF_INET. However, if the kernel does not have IPv6 support, the call will result in an EPROTONOSUPPORT or EAFNOSUPPORT error. Typically, errors like these lead to exiting the socket loop, and AF_INET will not even be tried. The application will need to handle this case or build the loop so that errors are ignored until the last address family.",
      "ja": "例は、Socket（）コマンドを発行するアプリケーションで、最初にAF_INET6を試してからAF_INETを試します。ただし、カーネルにIPv6のサポートがない場合、呼び出しはeprotonosupportまたはeafnosupportエラーになります。通常、このようなエラーはソケットループを終了することにつながり、AF_INETは試行されません。アプリケーションは、このケースを処理するか、ループを構築して、最後のアドレスファミリまでエラーが無視されるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "This case is just an extension of the IPv4/IPv6 support in the previous case, covering one relatively common but often-ignored case.",
      "ja": "このケースは、以前のケースでのIPv4/IPv6サポートの単なる拡張であり、比較的一般的ではあるが頻繁にイノベーションされたケースをカバーしています。"
    },
    {
      "indent": 0,
      "text": "5. Application Porting Considerations",
      "section_title": true,
      "ja": "5. アプリケーションの移植に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The minimum changes for IPv4 applications to work with IPv6 are based on the different size and format of IPv4 and IPv6 addresses.",
      "ja": "IPv4アプリケーションがIPv6を使用するための最小変更は、IPv4およびIPv6アドレスの異なるサイズと形式に基づいています。"
    },
    {
      "indent": 3,
      "text": "Applications have been developed with IPv4 network protocol in mind. This assumption has resulted in many IP dependencies through source code.",
      "ja": "アプリケーションは、IPv4ネットワークプロトコルを念頭に置いて開発されています。この仮定により、ソースコードを介して多くのIP依存関係が生じました。"
    },
    {
      "indent": 3,
      "text": "The following list summarizes the more common IP version dependencies in applications:",
      "ja": "次のリストは、アプリケーションのより一般的なIPバージョンの依存関係をまとめたものです。"
    },
    {
      "indent": 6,
      "text": "a) Presentation format for an IP address: An ASCII string that represents the IP address, a dotted-decimal string for IPv4, and a hexadecimal string for IPv6.",
      "ja": "a) IPアドレスのプレゼンテーション形式：IPアドレスを表すASCII文字列、IPv4用の点線式文字列、およびIPv6の16進文字列。"
    },
    {
      "indent": 6,
      "text": "b) Transport layer API: Functions to establish communications and to exchange information.",
      "ja": "b) トランスポートレイヤーAPI：コミュニケーションを確立し、情報を交換する機能。"
    },
    {
      "indent": 6,
      "text": "c) Name and address resolution: Conversion functions between hostnames and IP addresses.",
      "ja": "c) 名前とアドレス解決：ホスト名とIPアドレス間の変換関数。"
    },
    {
      "indent": 6,
      "text": "d) Specific IP dependencies: More specific IP version dependencies, such as IP address selection, application framing, and storage of IP addresses.",
      "ja": "d) 特定のIP依存関係：IPアドレスの選択、アプリケーションフレーミング、IPアドレスのストレージなど、より特定のIPバージョン依存関係。"
    },
    {
      "indent": 6,
      "text": "e) Multicast applications: One must find the IPv6 equivalents to the IPv4 multicast addresses and use the right socket configuration options.",
      "ja": "e) マルチキャストアプリケーション：IPv6マルチキャストアドレスに相当するIPv6を見つけて、適切なソケット構成オプションを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The following subsections describe the problems with the aforementioned IP version dependencies. Although application source code can be ported to IPv6 with minimum changes related to IP addresses, some recommendations are given to modify the source code in a protocol-independent way, which will allow applications to work with both IPv4 and IPv6.",
      "ja": "次のサブセクションでは、前述のIPバージョン依存関係の問題について説明します。IPアドレスに関連する最小変更でアプリケーションソースコードをIPv6に移植できますが、プロトコルに依存しない方法でソースコードを変更するための推奨事項が与えられます。これにより、アプリケーションはIPv4とIPv6の両方で動作できます。"
    },
    {
      "indent": 0,
      "text": "5.1. Presentation Format for an IP Address",
      "section_title": true,
      "ja": "5.1. IPアドレスのプレゼンテーション形式"
    },
    {
      "indent": 3,
      "text": "Many applications use IP addresses to identify network nodes and to establish connections to destination addresses. For instance, using the client/server model, clients usually need an IP address as an application parameter to connect to a server. This IP address is usually provided in the presentation format, as a string. There are two problems when porting the presentation format for an IP address: the allocated memory and the management of the presentation format.",
      "ja": "多くのアプリケーションは、IPアドレスを使用してネットワークノードを識別し、宛先アドレスへの接続を確立します。たとえば、クライアント/サーバーモデルを使用すると、クライアントは通常、サーバーに接続するためのアプリケーションパラメーターとしてIPアドレスが必要です。このIPアドレスは、通常、文字列としてプレゼンテーション形式で提供されます。IPアドレスのプレゼンテーション形式を移植する際には、割り当てられたメモリとプレゼンテーション形式の管理を2つの問題があります。"
    },
    {
      "indent": 3,
      "text": "Usually, the memory allocated to contain an IPv4 address representation as a string is unable to contain an IPv6 address. Applications should be modified to prevent buffer overflows made possible by the larger IPv6 address.",
      "ja": "通常、文字列がIPv6アドレスを含めることができないため、IPv4アドレス表現を含むように割り当てられたメモリ。より大きなIPv6アドレスによって可能になったバッファオーバーフローを防ぐために、アプリケーションを変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "IPv4 and IPv6 do not use the same presentation format. IPv4 uses a dot (.) to separate the four octets written in decimal notation, and IPv6 uses a colon (:) to separate each pair of octets written in hexadecimal notation [RFC3513]. In cases where one must be able to specify, for example, port numbers with the address (see below), it may be desirable to require placing the address inside the square brackets [TextRep].",
      "ja": "IPv4とIPv6は、同じプレゼンテーション形式を使用しません。IPv4はDOT（。）を使用して小数点以下で記述された4つのオクテットを分離し、IPv6はコロン（:)の各ペアのオクテットの各ペアを16進表[RFC3513]で分離します。たとえば、アドレスのあるポート番号（以下を参照）を指定できる必要がある場合は、正方形の括弧内にアドレスを配置する必要があることが望ましい場合があります[Textrep]。"
    },
    {
      "indent": 3,
      "text": "A particular problem with IP address parsers comes when the input is actually a combination of IP address and port number. With IPv4 these are often coupled with a colon; for example, \"192.0.2.1:80\". However, this approach would be ambiguous with IPv6, as colons are already used to structure the address.",
      "ja": "IPアドレスパーサーの特定の問題は、入力が実際にIPアドレスとポート番号の組み合わせである場合に発生します。IPv4では、これらは多くの場合、結腸と結合されます。たとえば、「192.0.2.1:80」。ただし、コロンはすでに住所を構築するために使用されているため、このアプローチはIPv6ではあいまいです。"
    },
    {
      "indent": 3,
      "text": "Therefore, the IP address parsers that take the port number separated with a colon should distinguish IPv6 addresses somehow. One way is to enclose the address in brackets, as is done with Uniform Resource Locators (URLs) [RFC2732]; for example, http://[2001:db8::1]:80.",
      "ja": "したがって、コロンで区切られたポート番号を取得するIPアドレスパーサーは、IPv6アドレスを何らかの形で区別する必要があります。1つの方法は、均一なリソースロケーター（URL）[RFC2732]で行われるように、括弧内のアドレスを囲むことです。たとえば、http：// [2001：db8 :: 1]：80。"
    },
    {
      "indent": 3,
      "text": "Some applications also need to specify IPv6 prefixes and lengths: The prefix length should be inserted outside of the square brackets, if used; for example, [2001:db8::]/64 or 2001:db8::/64 and not [2001:db8::/64]. Note that prefix/length notation is syntactically indistinguishable from a legal URI; therefore, the prefix/length notation must not be used when it isn't clear from the context that it's used to specify the prefix and length and not, for example, a URI.",
      "ja": "一部のアプリケーションは、IPv6プレフィックスと長さを指定する必要があります。使用する場合は、接頭辞の長さを四角いブラケットの外側に挿入する必要があります。たとえば、[2001：db8 ::]/64または2001：db8 ::/64ではなく[2001：db8 ::/64]。接頭辞/長さの表記は、法的URIと構文的に区別できないことに注意してください。したがって、接頭辞/長さの表記は、たとえばURIではなく、プレフィックスと長さを指定するために使用されていることをコンテキストから明らかにしていない場合は、使用する必要はありません。"
    },
    {
      "indent": 3,
      "text": "In some specific cases, it may be necessary to give a zone identifier as part of the address; for example, fe80::1%eth0. In general, applications should not need to parse these identifiers.",
      "ja": "特定の場合には、アドレスの一部としてゾーン識別子を指定する必要がある場合があります。たとえば、Fe80 :: 1％ETH0。一般に、アプリケーションはこれらの識別子を解析する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The IP address parsers should support enclosing the IPv6 address in brackets, even when the address is not used in conjunction with a port number. Requiring that the user always give a literal IP address enclosed in brackets is not recommended.",
      "ja": "IPアドレスパーサーは、アドレスがポート番号と組み合わせて使用されていない場合でも、ブラケット内のIPv6アドレスを囲むことをサポートする必要があります。ユーザーが常にブラケットに囲まれた文字通りのIPアドレスを与えることを要求することは推奨されません。"
    },
    {
      "indent": 3,
      "text": "Note that some applications may also represent IPv6 address literals differently; for example, SMTP [RFC2821] uses [IPv6:2001:db8::1].",
      "ja": "一部のアプリケーションは、IPv6アドレスリテラルを異なる方法で表す場合があることに注意してください。たとえば、SMTP [RFC2821]は[IPv6：2001：db8 :: 1]を使用します。"
    },
    {
      "indent": 3,
      "text": "Note that the use of address literals is strongly discouraged for general-purpose direct input to the applications. Host names and DNS should be used instead.",
      "ja": "アドレスリテラルの使用は、アプリケーションへの一般的な直接入力のために強く推奨されていることに注意してください。代わりにホスト名とDNSを使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Transport Layer API",
      "section_title": true,
      "ja": "5.2. トランスポートレイヤーAPI"
    },
    {
      "indent": 3,
      "text": "Communication applications often include a transport module that establishes communications. Usually this module manages everything related to communications and uses a transport-layer API, typically as a network library. When an application is ported to IPv6, most changes should be made in this application transport module in order to be adapted to the new IPv6 API.",
      "ja": "通信アプリケーションには、多くの場合、通信を確立するトランスポートモジュールが含まれます。通常、このモジュールは通信に関連するすべてを管理し、通常はネットワークライブラリとして輸送層APIを使用します。アプリケーションがIPv6に移植される場合、新しいIPv6 APIに適合するために、このアプリケーション輸送モジュールにほとんどの変更を加える必要があります。"
    },
    {
      "indent": 3,
      "text": "In the general case, porting an existing application to IPv6 requires an examination of the following issues related to the API:",
      "ja": "一般的なケースでは、既存のアプリケーションをIPv6に移植するには、APIに関連する次の問題を調べる必要があります。"
    },
    {
      "indent": 6,
      "text": "- Network Information Storage: IP address Data Structures The new structures must contain 128-bit IP addresses. The use of generic address structures, which can store any address family, is recommended.",
      "ja": "- ネットワーク情報ストレージ：IPアドレスデータ構造新しい構造には、128ビットIPアドレスを含める必要があります。任意のアドレスファミリを保存できる一般的なアドレス構造の使用をお勧めします。"
    },
    {
      "indent": 9,
      "text": "Sometimes special addresses are hard-coded in the application source code. Developers should pay attention to these in order to use the new address format. Some of these special IP addresses are wildcard local, loopback, and broadcast. IPv6 does not have the broadcast addresses, so applications can use multicast instead.",
      "ja": "アプリケーションソースコードでは、特別なアドレスがハードコーディングされる場合があります。開発者は、新しいアドレス形式を使用するためにこれらに注意を払う必要があります。これらの特別なIPアドレスのいくつかは、ワイルドカードローカル、ループバック、ブロードキャストです。IPv6にはブロードキャストアドレスがないため、アプリケーションは代わりにマルチキャストを使用できます。"
    },
    {
      "indent": 6,
      "text": "- Address Conversion Functions The address conversion functions convert the binary address representation to the presentation format and vice versa. The new conversion functions are specified to the IPv6 address format.",
      "ja": "- アドレス変換関数アドレス変換関数バイナリアドレス表現をプレゼンテーション形式に変換し、その逆も同様です。新しい変換関数は、IPv6アドレス形式に指定されています。"
    },
    {
      "indent": 6,
      "text": "- Communication API Functions These functions manage communications. Their signatures are defined based on a generic socket address structure. The same functions are valid for IPv6; however, the IP address data structures used when calling these functions require the updates.",
      "ja": "- 通信API関数これらの関数は通信を管理します。それらの署名は、一般的なソケットアドレス構造に基づいて定義されます。同じ関数はIPv6に対して有効です。ただし、これらの関数を呼び出すときに使用されるIPアドレスデータ構造には、更新が必要です。"
    },
    {
      "indent": 6,
      "text": "- Network Configuration Options These are used when different communication models are configured for Input/Output (I/O) operations (blocking/nonblocking, I/O multiplexing, etc.) and should be translated for IPv6.",
      "ja": "- ネットワーク構成オプションこれらは、入力/出力（I/O）操作（ブロッキング/ノンブロッキング、I/Oマルチプレックスなど）に異なる通信モデルが構成されている場合に使用され、IPv6用に翻訳する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3. Name and Address Resolution",
      "section_title": true,
      "ja": "5.3. 名前とアドレス解決"
    },
    {
      "indent": 3,
      "text": "From the application point of view, the name and address resolution is a system-independent process. An application calls functions in a system library, the resolver, which is linked into the application when it is built. However, these functions use IP address structures, that are protocol dependent and must be reviewed to support the new IPv6 resolution calls.",
      "ja": "アプリケーションの観点から、名前とアドレスの解決はシステムに依存しないプロセスです。アプリケーションは、システムライブラリで機能を呼び出します。リゾルバーは、ビルド時にアプリケーションにリンクされます。ただし、これらの関数は、プロトコルに依存するIPアドレス構造を使用し、新しいIPv6解像度呼び出しをサポートするためにレビューする必要があります。"
    },
    {
      "indent": 3,
      "text": "With IPv6, there are two new basic resolution functions, getaddrinfo() and getnameinfo(). The first returns a list of all configured IP addresses for a hostname. These queries can be constrained to one protocol family; for instance, only IPv4 or only IPv6 addresses. However, it is recommended that all configured IP addresses be obtained to allow applications to work with every kind of node. The second function returns the hostname associated to an IP address.",
      "ja": "IPv6の場合、2つの新しい基本解像度関数、getaddrinfo（）とgetNameInfo（）があります。最初は、ホスト名のすべての設定されたIPアドレスのリストを返します。これらのクエリは、1つのプロトコルファミリに制約できます。たとえば、IPv4またはIPv6のみがアドレス指定されます。ただし、アプリケーションがあらゆる種類のノードで動作できるように、構成されたすべてのIPアドレスを取得することをお勧めします。2番目の関数は、IPアドレスに関連付けられたホスト名を返します。"
    },
    {
      "indent": 0,
      "text": "5.4. Specific IP Dependencies",
      "section_title": true,
      "ja": "5.4. 特定のIP依存関係"
    },
    {
      "indent": 0,
      "text": "5.4.1. IP Address Selection",
      "section_title": true,
      "ja": "5.4.1. IPアドレスの選択"
    },
    {
      "indent": 3,
      "text": "Unlike the IPv4 model, IPv6 promotes the configuration of multiple IP addresses per node, however, applications only use a destination/source pair for a communication. Choosing the right IP source and destination addresses is a key factor that may determine the route of IP datagrams.",
      "ja": "IPv4モデルとは異なり、IPv6はノードあたりの複数のIPアドレスの構成を宣伝しますが、アプリケーションは通信に宛先/ソースペアのみを使用します。適切なIPソースと宛先アドレスを選択することは、IPデータグラムのルートを決定できる重要な要素です。"
    },
    {
      "indent": 3,
      "text": "Typically, nodes, not applications, automatically solve the source address selection. A node will choose the source address for a communication following some rules of best choice, per [RFC3484], but will also allow applications to make changes in the ordering rules.",
      "ja": "通常、アプリケーションではなくノードがソースアドレスの選択を自動的に解決します。ノードは、[RFC3484]によると、最良の選択のいくつかのルールに従って通信のソースアドレスを選択しますが、アプリケーションが順序付けルールを変更できるようにします。"
    },
    {
      "indent": 3,
      "text": "When selecting the destination address, applications usually ask a resolver for the destination IP address. The resolver returns a set of valid IP addresses from a hostname. Unless applications have a specific reason to select any particular destination address, they should try each element in the list until the communication succeeds.",
      "ja": "宛先アドレスを選択するとき、アプリケーションは通常、宛先IPアドレスのリゾルバーを尋ねます。リゾルバーは、ホスト名から有効なIPアドレスのセットを返します。アプリケーションに特定の宛先アドレスを選択する特定の理由がない限り、通信が成功するまでリスト内の各要素を試す必要があります。"
    },
    {
      "indent": 3,
      "text": "In some cases, the application may need to specify its source address. The destination address selection process picks the best destination for the source address (instead of picking the best source address for the chosen destination address). Note that if it is not yet known which protocol will be used for communication there may be an increase in complexity for IP version - independent applications that have to specify the source address (especially for client applications. Fortunately, specifying the source address is not typically required).",
      "ja": "場合によっては、アプリケーションがソースアドレスを指定する必要がある場合があります。宛先アドレスの選択プロセスは、選択した宛先アドレスに最適なソースアドレスを選択する代わりに、ソースアドレスに最適な宛先を選択します。どのプロトコルが通信に使用されるかがまだわかっていない場合、IPバージョンの複雑さが増加する可能性があることに注意してください - ソースアドレスを指定する必要がある独立したアプリケーション（特にクライアントアプリケーションで。幸いなことに、ソースアドレスを指定することは通常、必須）。"
    },
    {
      "indent": 0,
      "text": "5.4.2. Application Framing",
      "section_title": true,
      "ja": "5.4.2. アプリケーションフレーミング"
    },
    {
      "indent": 3,
      "text": "The Application Level Framing (ALF) architecture controls mechanisms that traditionally fall within the transport layer. Applications implementing ALF are often responsible for packetizing data into Application Data Units (ADUs). The application problem with ALF arrives from the ADU size selection to obtain better performance.",
      "ja": "アプリケーションレベルのフレーミング（ALF）アーキテクチャは、伝統的に輸送層内に該当するメカニズムを制御します。ALFを実装するアプリケーションは、多くの場合、データをアプリケーションデータユニット（ADU）にパケット化する責任があります。ALFのアプリケーションの問題は、ADUサイズの選択から到着し、パフォーマンスを向上させます。"
    },
    {
      "indent": 3,
      "text": "Applications using connectionless protocols (such as UDP) typically need application framing. These applications have three choices: (1) to use packet sizes no larger than the IPv6 minimum Maximum Transmission Unit (MTU) of 1280 bytes [RFC2460], (2) to use any packet sizes, but to force IPv6 fragmentation/reassembly when necessary, or (3) to optimize the packet size and avoid unnecessary fragmentation/reassembly, and to guess or find out the optimal packet sizes that can be sent and received, end-to-end, on the network. This memo takes no stance on that approach is best.",
      "ja": "接続のないプロトコル（UDPなど）を使用したアプリケーションは、通常、アプリケーションフレーミングが必要です。これらのアプリケーションには3つの選択肢があります。（1）1280バイト[RFC2460]のIPv6最小最大透過ユニット（MTU）を使用するパケットサイズを使用するには[RFC2460]、（2）パケットサイズを使用しますが、必要に応じてIPv6の断片化/再組み立てを強制します。、または（3）パケットサイズを最適化し、不必要な断片化/再組み立てを回避し、ネットワーク上でエンドツーエンドで送信および受信できる最適なパケットサイズを推測または調べます。このメモは、そのアプローチが最適ではありません。"
    },
    {
      "indent": 3,
      "text": "Note that the most optimal ALF depends on dynamic factors such as Path MTU or whether IPv4 or IPv6 is being used (due to different header sizes, possible IPv6-in-IPv4 tunneling overhead, etc.). These factors have to be taken into consideration when application framing is implemented.",
      "ja": "最も最適なALFは、Path MTUやIPv4またはIPv6などの動的要因に依存していることに注意してください（異なるヘッダーサイズ、IPv6-in-IPV4トンネルのオーバーヘッドなど）。これらの要因は、アプリケーションフレーミングが実装されている場合に考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4.3. Storage of IP Addresses",
      "section_title": true,
      "ja": "5.4.3. IPアドレスのストレージ"
    },
    {
      "indent": 3,
      "text": "Some applications store IP addresses as remote peer information. For instance, one of the most popular ways to register remote nodes in collaborative applications uses IP addresses as registry keys.",
      "ja": "一部のアプリケーションは、IPアドレスをリモートピア情報として保存します。たとえば、コラボレーティブアプリケーションでリモートノードを登録する最も一般的な方法の1つは、IPアドレスをレジストリキーとして使用します。"
    },
    {
      "indent": 3,
      "text": "Although the source code that stores IP addresses can be modified to IPv6 by following the previous basic porting recommendations, applications should not store IP addresses for the following reasons:",
      "ja": "IPアドレスを保存するソースコードは、以前の基本的なポーティング推奨事項に従うことでIPv6に変更できますが、アプリケーションは次の理由でIPアドレスを保存してはなりません。"
    },
    {
      "indent": 6,
      "text": "- IP addresses can change throughout time; for instance, after a renumbering process.",
      "ja": "- IPアドレスは時間をかけて変更できます。たとえば、変更プロセスの後。"
    },
    {
      "indent": 6,
      "text": "- The same node can reach a destination host using different IP addresses, possibly with a different protocol version.",
      "ja": "- 同じノードは、異なるプロトコルバージョンを使用して、異なるIPアドレスを使用して宛先ホストに到達できます。"
    },
    {
      "indent": 3,
      "text": "When possible, applications should store names such as FQDNs or other protocol-independent identities instead of addresses. In this case applications are only bound to specific addresses at run time, or for the duration of a cache lifetime. Other types of applications, such as massive peer-to-peer systems with their own rendezvous and discovery mechanisms, may need to cache addresses for performance reasons, but cached addresses should not be treated as permanent, reliable information. In highly dynamic networks, any form of name resolution may be impossible, and here again addresses must be cached.",
      "ja": "可能な場合、アプリケーションは、アドレスの代わりにFQDNSまたはその他のプロトコルに依存しないアイデンティティなどの名前を保存する必要があります。この場合、アプリケーションは、実行時に特定のアドレスにのみ拘束されます。独自のランデブーや発見メカニズムを備えた大規模なピアツーピアシステムなど、他のタイプのアプリケーションは、パフォーマンス上の理由でアドレスをキャッシュする必要がある場合がありますが、キャッシュされたアドレスは、永続的で信頼できる情報として扱われるべきではありません。非常に動的なネットワークでは、あらゆる形式の名前解像度が不可能である可能性があり、ここでもアドレスをキャッシュする必要があります。"
    },
    {
      "indent": 0,
      "text": "5.5. Multicast Applications",
      "section_title": true,
      "ja": "5.5. マルチキャストアプリケーション"
    },
    {
      "indent": 3,
      "text": "There is an additional problem in porting multicast applications. When multicast facilities are used some changes must be carried out to support IPv6. First, applications must change the IPv4 multicast addresses to IPv6 ones, and second, the socket configuration options must be changed.",
      "ja": "マルチキャストアプリケーションの移植には追加の問題があります。マルチキャスト施設を使用する場合、IPv6をサポートするためにいくつかの変更を実行する必要があります。まず、アプリケーションはIPv4マルチキャストアドレスをIPv6のアドレスに変更する必要があり、次にはソケット構成オプションを変更する必要があります。"
    },
    {
      "indent": 3,
      "text": "All IPv6 multicast addresses encode scope; the scope was only implicit in IPv4 (with multicast groups in 239/8). Also, although a large number of application-specific multicast addresses have been assigned with IPv4, this has been (luckily enough) avoided with IPv6. So there are no direct equivalents for all the multicast addresses. For link-local multicast, it's possible to pick almost anything within the link-local scope. The global groups could use unicast prefix - based addresses [RFC3306]. All in all, this may force the application developers to write more protocol-dependent code.",
      "ja": "すべてのIPv6マルチキャストアドレスはスコープをエンコードします。スコープはIPv4でのみ暗黙的でした（239/8にマルチキャストグループがあります）。また、IPv4には多数のアプリケーション固有のマルチキャストアドレスが割り当てられていますが、これは（幸運にも十分に）IPv6で避けられています。したがって、すべてのマルチキャストアドレスに直接相当するものはありません。Link-Local Multicastの場合、Link-Localスコープ内でほとんどすべてを選択することができます。グローバルグループは、ユニキャストプレフィックスベースのアドレス[RFC3306]を使用できます。全体として、これにより、アプリケーション開発者はより多くのプロトコル依存コードを記述するように強制される可能性があります。"
    },
    {
      "indent": 3,
      "text": "Another problem is that IPv6 multicast does not yet have a standardized mechanism for traditional Any Source Multicast for Interdomain multicast. The models for Any Source Multicast (ASM) or Source-Specific Multicast (SSM) are generally similar between IPv4 and IPv6, but it is possible that PIM-SSM will become more widely deployed in IPv6 due to its simpler architecture.",
      "ja": "別の問題は、IPv6マルチキャストには、インタードメインマルチキャスト用の従来のソースマルチキャストの標準化されたメカニズムがまだないことです。任意のソースマルチキャスト（ASM）またはソース固有のマルチキャスト（SSM）のモデルは一般にIPv4とIPv6の間で類似していますが、PIM-SSMがその単純なアーキテクチャによりIPv6に広く展開される可能性があります。"
    },
    {
      "indent": 3,
      "text": "It might be beneficial to port the applications to use SSM semantics, requiring off-band source discovery mechanisms and a different API [RFC3678]. Inter-domain ASM service is available only through a method embedding the Rendezvous Point address in the multicast address [Embed-RP].",
      "ja": "SSMセマンティクスを使用するようにアプリケーションを移植することが有益である可能性があり、バンドオフソース発見メカニズムと異なるAPI [RFC3678]が必要です。ドメイン間ASMサービスは、マルチキャストアドレス[Embed-RP]のランデブーポイントアドレスを埋め込むメソッドを介してのみ利用可能です。"
    },
    {
      "indent": 3,
      "text": "Another generic problem with multiparty conferencing applications, similar to the issues with peer-to-peer applications, is that all users of the session must use the same protocol version (IPv4 or IPv6), or some form of proxy or translator (e.g., [MUL-GW]).",
      "ja": "ピアツーピアアプリケーションの問題と同様に、マルチパーティ会議アプリケーションの別の一般的な問題は、セッションのすべてのユーザーが同じプロトコルバージョン（IPv4またはIPv6）、または何らかの形のプロキシまたは翻訳者（例えば[）を使用する必要があることです。mul-gw]）。"
    },
    {
      "indent": 0,
      "text": "6. Developing IP Version - Independent Applications",
      "section_title": true,
      "ja": "6. IPバージョンの開発 - 独立したアプリケーション"
    },
    {
      "indent": 3,
      "text": "As stated, dual applications working with both IPv4 and IPv6 are recommended. These applications should avoid IP dependencies in the source code. However, if IP dependencies are required, one of the better solutions would be to build a communication library that provides an IP version - independent API to applications and that hides all dependencies.",
      "ja": "述べたように、IPv4とIPv6の両方で動作するデュアルアプリケーションが推奨されます。これらのアプリケーションは、ソースコードのIP依存関係を回避する必要があります。ただし、IP依存関係が必要な場合、より良い解決策の1つは、IPバージョンを提供する通信ライブラリを構築することです。アプリケーションに独立したAPIとすべての依存関係を隠すことです。"
    },
    {
      "indent": 3,
      "text": "To develop IP version - independent applications, the following guidelines should be considered.",
      "ja": "IPバージョン - 独立したアプリケーションを開発するには、次のガイドラインを考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. IP Version - Independent Structures",
      "section_title": true,
      "ja": "6.1. IPバージョン - 独立した構造"
    },
    {
      "indent": 3,
      "text": "All memory structures and APIs should be IP version-independent. One should avoid structs in_addr, in6_addr, sockaddr_in, and sockaddr_in6.",
      "ja": "すべてのメモリ構造とAPIは、IPバージョンに依存する必要があります。struct in_addr、in6_addr、sockaddr_in、およびsockaddr_in6を避ける必要があります。"
    },
    {
      "indent": 3,
      "text": "Suppose a network address is passed to some function, foo(). If one uses struct in_addr or struct in6_addr, results an extra parameter to indicate address family, as below:",
      "ja": "ネットワークアドレスが何らかの関数foo（）に渡されるとします。struct in_addrまたはstruct in6_addrを使用している場合、以下のようにアドレスファミリを示すために追加のパラメーターを生成します。"
    },
    {
      "indent": 6,
      "text": "struct in_addr in4addr;\nstruct in6_addr in6addr;\n /* IPv4 case */\nfoo(&in4addr, AF_INET);\n /* IPv6 case */\nfoo(&in6addr, AF_INET6);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This leads to duplicated code and having to consider each scenario from both perspectives independently, which is difficult to maintain. So we should use struct sockaddr_storage, as below:",
      "ja": "これにより、コードが複製され、両方の視点から独立して各シナリオを考慮することができなくなり、維持が困難になります。したがって、以下のように、struct sockaddr_storageを使用する必要があります。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_storage ss;\nint sslen;\n/* AF independent! - use sockaddr when passing a pointer */\n/* note: it's typically necessary to also pass the length\n   explicitly */\nfoo((struct sockaddr *)&ss, sslen);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.2. IP Version - Independent APIs",
      "section_title": true,
      "ja": "6.2. IPバージョン - 独立したAPI"
    },
    {
      "indent": 3,
      "text": "The new address independent variants getaddrinfo() and getnameinfo() hide the gory details of name-to-address and address-to-name translations. They implement functionalities of the following functions:",
      "ja": "新しいアドレスの独立バリエーションgetaddrinfo（）およびgetnameInfo（）は、名前からアドレスへのgoryの詳細とアドレス間翻訳を非表示にします。彼らは次の機能の機能を実装します。"
    },
    {
      "indent": 6,
      "text": "gethostbyname() gethostbyaddr() getservbyname() getservbyport()",
      "ja": "gethostbyname（）gethostbyaddr（）getservbyname（）getservbyport（）"
    },
    {
      "indent": 3,
      "text": "They also obsolete the functionality of gethostbyname2(), defined in [RFC2133].",
      "ja": "また、[RFC2133]で定義されているgethostbyname2（）の機能を廃止します。"
    },
    {
      "indent": 3,
      "text": "The new variants can perform hostname/address and service name/port lookups, though the features can be turned off, if desired. Getaddrinfo() can return multiple addresses, as below:",
      "ja": "新しいバリアントは、ホスト名/アドレスとサービス名/ポートルックアップを実行できますが、必要に応じて機能をオフにできます。getaddrinfo（）は、以下のように複数のアドレスを返すことができます。"
    },
    {
      "indent": 6,
      "text": "localhost. IN A 127.0.0.1 IN A 127.0.0.2 IN AAAA ::1",
      "ja": "localhost。127.0.0.1で127.0.0.2でAAAA :: 1"
    },
    {
      "indent": 3,
      "text": "In this example, if IPv6 is preferred, getaddrinfo first returns ::1; then both 127.0.0.1 and 127.0.0.2 are in a random order.",
      "ja": "この例では、IPv6が優先される場合、getaddrinfoが最初に戻ります:: 1;次に、127.0.0.1と127.0.0.2の両方がランダムな順序になります。"
    },
    {
      "indent": 3,
      "text": "Getaddrinfo() and getnameinfo() can query hostname and service name/port at once.",
      "ja": "getaddrinfo（）およびgetnameInfo（）は、ホスト名とサービス名/ポートを一度にクエリすることができます。"
    },
    {
      "indent": 3,
      "text": "Hardcoding AF-dependent knowledge is not preferred in the program. Constructs such as that below should be avoided:",
      "ja": "ハードコードAF依存の知識は、プログラムでは好まれません。以下のような構成要素は避けるべきです。"
    },
    {
      "indent": 6,
      "text": " /* BAD EXAMPLE */\n switch (sa->sa_family) {\n case AF_INET:\n         salen = sizeof(struct sockaddr_in);\n         break;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Instead, we should use the ai_addrlen member of the addrinfo structure, as returned by getaddrinfo().",
      "ja": "代わりに、getaddrinfo（）によって返されるように、addrinfo構造のAI_ADDRLENメンバーを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The gethostbyname(), gethostbyaddr(), getservbyname(), and getservbyport() are mainly used to get server and client sockets. In the following sections, we will see simple examples creating these sockets by using the new IPv6 resolution functions.",
      "ja": "gethostbyname（）、gethostbyaddr（）、getservbyname（）、およびgetservbyport（）は、主にサーバーとクライアントのソケットを取得するために使用されます。次のセクションでは、新しいIPv6解像度関数を使用して、これらのソケットを作成する簡単な例を確認します。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Example of Overly Simplistic TCP Server Application",
      "section_title": true,
      "ja": "6.2.1. 過度に単純化されたTCPサーバーアプリケーションの例"
    },
    {
      "indent": 3,
      "text": "A simple TCP server socket at service name (or port number string) SERVICE:",
      "ja": "サービス名（またはポート番号文字列）サービスのシンプルなTCPサーバーソケット："
    },
    {
      "indent": 6,
      "text": "/*\n * BAD EXAMPLE: does not implement the getaddrinfo loop as\n * specified in 6.3.  This may result in one of the following:\n *  - an IPv6 server, listening at the wildcard address,\n *    allowing IPv4 addresses through IPv4-mapped IPv6 addresses.\n *  - an IPv4 server, if IPv6 is not enabled,\n *  - an IPv6-only server, if IPv6 is enabled but IPv4-mapped IPv6\n *    addresses are not used by default, or\n *  - no server at all, if getaddrinfo supports IPv6, but the\n *    system doesn't, and socket(AF_INET6, ...) exits with an\n *    error.\n */\nstruct addrinfo hints, *res;\nint error, sockfd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "memset(&hints, 0, sizeof(hints));\nhints.ai_flags = AI_PASSIVE;\nhints.ai_family = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;\nerror = getaddrinfo(NULL, SERVICE, &hints, &res);\nif (error != 0) {\n   /* handle getaddrinfo error */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 6,
      "text": "sockfd = socket(res->family, res->ai_socktype, res->ai_protocol);\nif (sockfd < 0) {\n   /* handle socket error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (bind(sockfd, res->ai_addr, res->ai_addrlen) < 0) {\n   /* handle bind error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* ... */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "freeaddrinfo(res);",
      "ja": "Freeaddrinfo（res）;"
    },
    {
      "indent": 0,
      "text": "6.2.2. Example of Overly Simplistic TCP Client Application",
      "section_title": true,
      "ja": "6.2.2. 過度に単純なTCPクライアントアプリケーションの例"
    },
    {
      "indent": 3,
      "text": "A simple TCP client socket connecting to a server running at node name (or IP address presentation format) SERVER_NODE and service name (or port number string) SERVICE follows:",
      "ja": "ノード名（またはIPアドレスプレゼンテーション形式）で実行されているサーバーに接続するシンプルなTCPクライアントソケットServer_Nodeおよびサービス名（またはポート番号文字列）サービスは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "/*\n * BAD EXAMPLE: does not implement the getaddrinfo loop as\n * specified in 6.3.  This may result in one of the following:\n *  - an IPv4 connection to an IPv4 destination,\n *  - an IPv6 connection to an IPv6 destination,\n *  - an attempt to try to reach an IPv6 destination (if AAAA\n *    record found), but failing -- without fallbacks -- because:\n *     o getaddrinfo supports IPv6 but the system does not\n *     o IPv6 routing doesn't exist, so falling back to e.g., TCP\n *       timeouts\n *     o IPv6 server reached, but service not IPv6-enabled or\n *       firewalled away\n *  - if the first destination is not reached, there is no\n *    fallback to the next records\n */\nstruct addrinfo hints, *res;\nint error, sockfd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "memset(&hints, 0, sizeof(hints));\nhints.ai_family = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "error = getaddrinfo(SERVER_NODE, SERVICE, &hints, &res);\nif (error != 0) {\n     /* handle getaddrinfo error */\n}\n      sockfd = socket(res->family, res->ai_socktype, res->ai_protocol);\nif (sockfd < 0) {\n     /* handle socket error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0 ) {\n     /* handle connect error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* ... */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "freeaddrinfo(res);",
      "ja": "Freeaddrinfo（res）;"
    },
    {
      "indent": 0,
      "text": "6.2.3. Binary/Presentation Format Conversion",
      "section_title": true,
      "ja": "6.2.3. バイナリ/プレゼンテーション形式の変換"
    },
    {
      "indent": 3,
      "text": "We should consider the binary and presentation address format conversion APIs. The following functions convert network address structure in its presentation address format and vice versa:",
      "ja": "バイナリおよびプレゼンテーションアドレス形式のフォーマット変換APIを考慮する必要があります。次の関数は、プレゼンテーションアドレス形式でネットワークアドレス構造を変換し、その逆の場合は次のことです。"
    },
    {
      "indent": 6,
      "text": "inet_ntop() inet_pton()",
      "ja": "inet_ntop（）inet_pton（）"
    },
    {
      "indent": 3,
      "text": "Both are from the basic socket extensions for IPv6. However, these conversion functions are protocol-dependent. It is better to use getnameinfo()/getaddrinfo() (inet_pton and inet_ntop equivalents are described in Appendix A).",
      "ja": "どちらもIPv6の基本ソケット拡張機能からです。ただし、これらの変換関数はプロトコル依存です。getNameInfo（）/getAddrinfo（）（inet_ptonおよびinet_ntopの等価物を付録Aに記載することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Conversion from network address structure to presentation format can be written as follows:",
      "ja": "ネットワークアドレス構造からプレゼンテーション形式への変換は、次のように記述できます。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_storage ss;\nchar addrStr[INET6_ADDRSTRLEN];\nchar servStr[NI_MAXSERV];\nint error;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill ss structure */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "error = getnameinfo((struct sockaddr *)&ss, sizeof(ss),\n                    addrStr, sizeof(addrStr),\n                    servStr, sizeof(servStr),\n                    NI_NUMERICHOST);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Conversions from presentation format to network address structure can be written as follows:",
      "ja": "プレゼンテーション形式からネットワークアドレス構造への変換は、次のように記述できます。"
    },
    {
      "indent": 6,
      "text": "struct addrinfo hints, *res;\nchar addrStr[INET6_ADDRSTRLEN];\nint error;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill addrStr buffer */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "memset(&hints, 0, sizeof(hints));\nhints.ai_family = AF_UNSPEC;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "error = getaddrinfo(addrStr, NULL, &hints, &res);\nif (error != 0) {\n    /* handle getaddrinfo error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* res->ai_addr contains the network address structure */\n/* ... */\nfreeaddrinfo(res);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3. Iterated Jobs for Finding the Working Address",
      "section_title": true,
      "ja": "6.3. 作業アドレスを見つけるためのジョブを繰り返しました"
    },
    {
      "indent": 3,
      "text": "In a client code, when multiple addresses are returned from getaddrinfo(), we should try all of them until connection succeeds. When a failure occurs with socket(), connect(), bind(), or some other function, the code should go on to try the next address.",
      "ja": "クライアントコードでは、getaddrinfo（）から複数のアドレスが返される場合、接続が成功するまですべてを試す必要があります。socket（）、connect（）、bind（）、またはその他の関数で障害が発生した場合、コードは次のアドレスを試すために続行する必要があります。"
    },
    {
      "indent": 3,
      "text": "In addition, if something is wrong with the socket call because the address family is not supported (i.e., in case of section 4.4), applications should try the next address structure.",
      "ja": "さらに、アドレスファミリがサポートされていないためにソケットコールに何か問題がある場合（つまり、セクション4.4の場合）、アプリケーションは次のアドレス構造を試す必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: In the following examples, the socket() return value error handling could be simplified by always continuing on with the socket loop instead of performing special checking of specific error numbers.",
      "ja": "注：次の例では、特定のエラー番号の特別なチェックを実行する代わりに、ソケットループを常に継続することにより、ソケット（）戻り値エラー処理が簡素化される可能性があります。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Example of TCP Server Application",
      "section_title": true,
      "ja": "6.3.1. TCPサーバーアプリケーションの例"
    },
    {
      "indent": 3,
      "text": "The previous TCP server example should be written as follows:",
      "ja": "前のTCPサーバーの例は、次のように記述する必要があります。"
    },
    {
      "indent": 6,
      "text": "#define MAXSOCK 2\nstruct addrinfo hints, *res;\nint error, sockfd[MAXSOCK], nsock=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "memset(&hints, 0, sizeof(hints));\nhints.ai_flags = AI_PASSIVE;\nhints.ai_family = AF_UNSPEC;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "hints.ai_socktype = SOCK_STREAM;",
      "ja": "hints.ai_socktype = sock_stream;"
    },
    {
      "indent": 6,
      "text": "error = getaddrinfo(NULL, SERVICE, &hints, &res);\nif (error != 0) {\n    /* handle getaddrinfo error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "for (aip=res; aip && nsock < MAXSOCK; aip=aip->ai_next) {\n    sockfd[nsock] = socket(aip->ai_family,\n                           aip->ai_socktype,\n                           aip->ai_protocol);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "if (sockfd[nsock] < 0) {\n    switch errno {\n         case EAFNOSUPPORT:\n         case EPROTONOSUPPORT:\n             /*\n              *  e.g., skip the errors until\n              *  the last address family,\n              *  see section 4.4.\n              */\n              if (aip->ai_next)\n                      continue;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "         else {\n                /* handle unknown protocol errors */\n                 break;\n         }\n    default:\n         /* handle other socket errors */\n         ;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "    } else {\n        int on = 1;\n        /* optional: works better if dual-binding to wildcard\n           address */\n        if (aip->ai_family == AF_INET6) {\n            setsockopt(sockfd[nsock], IPPROTO_IPV6, IPV6_V6ONLY,\n                       (char *)&on, sizeof(on));\n            /* errors are ignored */\n        }\n        if (bind(sockfd[nsock], aip->ai_addr,\n                                aip->ai_addrlen) < 0 ) {\n            /* handle bind error */\n            close(sockfd[nsock]);\n            continue;\n        }\n              if (listen(sockfd[nsock], SOMAXCONN) < 0) {\n            /* handle listen errors */\n            close(sockfd[nsock]);\n            continue;\n        }\n    }\n    nsock++;\n}\nfreeaddrinfo(res);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* check that we were able to obtain the sockets */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6.3.2. Example of TCP Client Application",
      "section_title": true,
      "ja": "6.3.2. TCPクライアントアプリケーションの例"
    },
    {
      "indent": 3,
      "text": "The previous TCP client example should be written as follows:",
      "ja": "以前のTCPクライアントの例は、次のように記述する必要があります。"
    },
    {
      "indent": 6,
      "text": "struct addrinfo hints, *res, *aip;\nint sockfd, error;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "memset(&hints, 0, sizeof(hints));\nhints.ai_family   = AF_UNSPEC;\nhints.ai_socktype = SOCK_STREAM;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "error = getaddrinfo(SERVER_NODE, SERVICE, &hints, &res);\nif (error != 0) {\n    /* handle getaddrinfo error */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "for (aip=res; aip; aip=aip->ai_next) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "sockfd = socket(aip->ai_family,\n                aip->ai_socktype,\n                aip->ai_protocol);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "if (sockfd < 0) {\n    switch errno {\n         case EAFNOSUPPORT:\n         case EPROTONOSUPPORT:\n             /*\n              *  e.g., skip the errors until\n              *  the last address family,\n              *  see section 4.4.\n              */\n              if (aip->ai_next)\n                      continue;\n              else {\n                     /* handle unknown protocol errors */\n                      break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 15,
      "text": "    default:\n         /* handle other socket errors */\n         ;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "} else {\n    if (connect(sockfd, aip->ai_addr, aip->ai_addrlen) == 0)\n        break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        /* handle connect errors */\n        close(sockfd);\n        sockfd=-1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (sockfd > 0) {\n    /* socket connected to server address */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "    /* ... */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "freeaddrinfo(res);",
      "ja": "Freeaddrinfo（res）;"
    },
    {
      "indent": 0,
      "text": "7. Transition Mechanism Considerations",
      "section_title": true,
      "ja": "7. 遷移メカニズムの考慮事項"
    },
    {
      "indent": 3,
      "text": "The mechanism [NAT-PT] introduces a special set of addresses, formed of an NAT-PT prefix and an IPv4 address these refer to IPv4 addresses translated by NAT-PT DNS-ALG. In some cases, one might be tempted to handle these differently.",
      "ja": "メカニズム[NAT-PT]は、NAT-PTプレフィックスとIPv4アドレスで形成された特別なアドレスセットを導入します。場合によっては、これらを異なって処理するように誘惑されるかもしれません。"
    },
    {
      "indent": 3,
      "text": "However, IPv6 applications must not be required to distinguish \"normal\" and \"NAT-PT translated\" addresses (or any other kind of special addresses, including the IPv4-mapped IPv6 addresses): This would be completely impractical, and if the distinction must be made, it must be done elsewhere (e.g., kernel, system libraries).",
      "ja": "ただし、「通常」と「NAT-PT翻訳」アドレス（またはIPv4マップされたIPv6アドレスを含む他の種類の特別なアドレス）を区別するためにIPv6アプリケーションを必要としないでください。これは完全に非実用的であり、区別が必要な場合作られてください、それは他の場所で行う必要があります（例：カーネル、システムライブラリ）。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of security considerations for IPv6 transition, but those are outside the scope of this memo.",
      "ja": "IPv6トランジションには多くのセキュリティ上の考慮事項がありますが、これらはこのメモの範囲外です。"
    },
    {
      "indent": 3,
      "text": "To ensure the availability and robustness of the service even when transitioning to IPv6, this memo describes a number of ways to make applications more resistant to failures by cycling through addresses until a working one is found. Doing this properly is critical to maintain availability and to avoid loss of service.",
      "ja": "IPv6に移行する場合でも、サービスの可用性と堅牢性を確保するために、このメモは、作業が見つかるまでアドレスを介してサイクリングすることにより、アプリケーションをより耐性に耐性にする方法を説明します。これを適切に行うことは、可用性を維持し、サービスの損失を避けるために重要です。"
    },
    {
      "indent": 3,
      "text": "A special consideration about application transition is how IPv4- mapped IPv6 addresses are handled. The use in the API can be seen both as a merit (easier application transition) and as a burden (difficulty in ensuring whether the use was legitimate). Note that some systems will disable (by default) support for internal IPv4- mapped IPv6 addresses. The security concerns regarding these on the wire are legitimate, but disabling it internally breaks one transition mechanism for server applications originally written to bind() and listen() to a single socket by using a wildcard address [V6MAPPED]. This should be considered in more detail when applications are designed.",
      "ja": "アプリケーションの遷移に関する特別な考慮事項は、IPv4マッピングされたIPv6アドレスの処理方法です。APIでの使用は、メリット（アプリケーションの移行の容易）と負担（使用が合法かどうかを確認するのが難しい）の両方として見ることができます。一部のシステムは、内部IPv4マッピングIPv6アドレスの（デフォルトで）サポートを無効にすることに注意してください。ワイヤー上のこれらに関するセキュリティの懸念は合法ですが、それを無効にすると、ワイルドカードアドレス[V6マップ]を使用して、bind（）およびliste（）に単一ソケットにbind（）と（）に書かれたサーバーアプリケーションの1つの遷移メカニズムが内部的に破損します。これは、アプリケーションが設計されている場合に、より詳細に検討する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Acknowledgments",
      "section_title": true,
      "ja": "9. 謝辞"
    },
    {
      "indent": 3,
      "text": "Some of guidelines for development of IP version-independent applications (section 6) were first brought up by [AF-APP]. Other work to document application porting guidelines has also been in progress; for example, [IP-GGF] and [PRT]. We would like to thank the members of the v6ops working group and the application area for helpful comments. Special thanks are due to Brian E. Carpenter, Antonio Querubin, Stig Venaas, Chirayu Patel, Jordi Palet, and Jason Lin for extensive review of this document. We acknowledge Ron Pike for proofreading the document.",
      "ja": "IPバージョンに依存しないアプリケーション（セクション6）の開発に関するガイドラインのいくつかは、最初に[AF-APP]によって提起されました。アプリケーションの移植ガイドラインを文書化する他の作業も進行中です。たとえば、[IP-GGF]および[PRT]。有益なコメントについては、V6OPSワーキンググループのメンバーとアプリケーションエリアに感謝します。この文書の広範なレビューをしてくれたブライアン・E・カーペンター、アントニオ・クルービン、スティグ・ヴェナス、チラユ・パテル、ジョルディ・パレット、ジェイソン・リンに感謝します。ドキュメントを校正してくれたRon Pikeに感謝します。"
    },
    {
      "indent": 0,
      "text": "10. References",
      "section_title": true,
      "ja": "10. 参考文献"
    },
    {
      "indent": 0,
      "text": "10.1. Normative References",
      "section_title": true,
      "ja": "10.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[RFC3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 3493、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3542] Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, \"Advanced Sockets Application Program Interface (API) for IPv6\", RFC 3542, May 2003.",
      "ja": "[RFC3542] Stevens、W.、Thomas、M.、Nordmark、E。、およびT. Jinmei、「IPv6用Advanced Socketsアプリケーションプログラムインターフェイス（API）」、RFC 3542、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[BIS] Tsuchiya, K., Higuchi, H., and Y. Atarashi, \"Dual Stack Hosts using the \"Bump-In-the-Stack\" Technique (BIS)\", RFC 2767, February 2000.",
      "ja": "[Bis] Tsuchiya、K.、Higuchi、H。、およびY. atarashi、「Bump-in-the-Stack」テクニック（BIS）を使用してデュアルスタックホスト」、RFC 2767、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[BIA] Lee, S., Shin, M-K., Kim, Y-J., Nordmark, E., and A. Durand, \"Dual Stack Hosts Using \"Bump-in-the-API\" (BIA)\", RFC 3338, October 2002.",
      "ja": "[Bia] Lee、S.、Shin、M-K。、Kim、Y-J。、Nordmark、E。、およびA. Durand、「Bump-in-api」（BIA）を使用してデュアルスタックホスト」、RFC 3338、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3484] Draves, R., \"Default Address Selection for Internet Protocol version 6 (IPv6)\", RFC 3484, February 2003.",
      "ja": "[RFC3484] Draves、R。、「インターネットプロトコルバージョン6（IPv6）のデフォルトアドレス選択」、RFC 3484、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3513] Hinden, R. and S. Deering, \"Internet Protocol Version 6 (IPv6) Addressing Architecture\", RFC 3513, April 2003.",
      "ja": "[RFC3513] Hinden、R。およびS. Deering、「インターネットプロトコルバージョン6（IPv6）アドレス指定アーキテクチャ」、RFC 3513、2003年4月。"
    },
    {
      "indent": 0,
      "text": "10.2. Informative References",
      "section_title": true,
      "ja": "10.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[2893BIS] Nordmark, E. and R. E. Gilligan, \"Basic Transition Mechanisms for IPv6 Hosts and Routers\", Work in Progress, June 2004.",
      "ja": "[2893bis] Nordmark、E。およびR. E. Gilligan、「IPv6ホストとルーターの基本的な遷移メカニズム」、2004年6月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[RFC2133] Gilligan, R., Thomson, S., Bound, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 2133, April 1997.",
      "ja": "[RFC2133] Gilligan、R.、Thomson、S.、Bound、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 2133、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2732] Hinden, R., Carpenter, B., and L. Masinter, \"Format for Literal IPv6 Addresses in URL's\", RFC 2732, December 1999.",
      "ja": "[RFC2732] Hinden、R.、Carpenter、B。、およびL. Masinter、「URLのリテラルIPv6アドレスの形式」、RFC 2732、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2821] Klensin, J., \"Simple Mail Transfer Protocol\", RFC 2821, April 2001.",
      "ja": "[RFC2821]クレンシン、J。、「Simple Mail Transfer Protocol」、RFC 2821、2001年4月。"
    },
    {
      "indent": 3,
      "text": "[TextRep] Main, A., \"Textual Representation of IPv4 and IPv6 Addresses\", Work in Progress, October 2003.",
      "ja": "[Textrep] Main、A。、「IPv4およびIPv6アドレスのテキスト表現」、2003年10月の作業。"
    },
    {
      "indent": 3,
      "text": "[NAT-PT] Tsirtsis, G. and P. Srisuresh, \"Network Address Translation - Protocol Translation (NAT-PT)\", RFC 2766, February 2000.",
      "ja": "[Nat-Pt] Tsirtsis、G。およびP. Srisuresh、「ネットワークアドレス変換 - プロトコル翻訳（NAT-PT）」、RFC 2766、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[DNSTRANS] Durand, A. and J. Ihren, \"DNS IPv6 Transport Operational Guidelines\", BCP 91, RFC 3901, September 2004.",
      "ja": "[Dnstrans] Durand、A。およびJ. Ihren、「DNS IPv6輸送運用ガイドライン」、BCP 91、RFC 3901、2004年9月。"
    },
    {
      "indent": 3,
      "text": "[DNSOPV6] Durand, A., Ihren, J. and P. Savola, \"Operational Considerations and Issues with IPv6 DNS\", Work in Progress, May 2004.",
      "ja": "[Dnsopv6] Durand、A.、Ihren、J。、およびP. Savola、「IPv6 DNSの運用上の考慮事項と問題」、2004年5月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[AF-APP] Hagino, J., \"Implementing AF-independent application\", http://www.kame.net/newsletter/19980604/, 2001.",
      "ja": "[AF-APP] Hagino、J。、「AF独立アプリケーションの実装」、http：//www.kame.net/newsletter/19980604/、2001。"
    },
    {
      "indent": 3,
      "text": "[V6MAPPED] Hagino, J., \"IPv4 mapped address considered harmful\", Work in Progress, April 2002.",
      "ja": "[V6Mapped] Hagino、J。、「有害と見なされるIPv4マッピングアドレス」、2002年4月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[IP-GGF] Chown, T., Bound, J., Jiang, S. and P. O'Hanlon, \"Guidelines for IP version independence in GGF specifications\", Global Grid Forum(GGF) Documentation, work in Progress, September 2003.",
      "ja": "[IP-GGF] Chown、T.、Bound、J.、Jiang、S。、およびP. O'Hanlon、「GGF仕様におけるIPバージョンの独立性のガイドライン」、Global Grid Forum（GGF）ドキュメント、作業中の作業、9月2003年。"
    },
    {
      "indent": 3,
      "text": "[Embed-RP] Savola, P. and B. Haberman, \"Embedding the Rendezvous Point (RP) Address in an IPv6 Multicast Address\", RFC 3956, November 2004.",
      "ja": "[Embed-RP] Savola、P。およびB. Haberman、「IPv6マルチキャストアドレスにRendezvous Point（RP）アドレスを埋め込む」、RFC 3956、2004年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3306] Haberman, B. and D. Thaler, \"Unicast-Prefix-based IPv6 Multicast Addresses\", RFC 3306, August 2002.",
      "ja": "[RFC3306] Haberman、B。およびD. Thaler、「Unicast-PrefixベースのIPv6マルチキャストアドレス」、RFC 3306、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3678] Thaler, D., Fenner, B., and B. Quinn, \"Socket Interface Extensions for Multicast Source Filters, RFC 3678, January 2004.",
      "ja": "[RFC3678] Thaler、D.、Fenner、B。、およびB. Quinn、「マルチキャストソースフィルターのソケットインターフェイス拡張、RFC 3678、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[MUL-GW] Venaas, S., \"An IPv4 - IPv6 multicast gateway\", Work in Progress, February 2003.",
      "ja": "[Mul -GW] Venaas、S。、「IPv4 -IPv6マルチキャストゲートウェイ」、2003年2月に進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[PRT] Castro, E. M., \"Programming guidelines on transition to IPv6 LONG project\", Work in Progress, January 2003.",
      "ja": "[PRT] Castro、E。M.、「IPv6 Long Projectへの移行に関するプログラミングガイドライン」、2003年1月の作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Other Binary/Presentation Format Conversions",
      "ja": "付録A. その他のバイナリ/プレゼンテーション形式変換"
    },
    {
      "indent": 3,
      "text": "Section 6.2.3 describes the preferred way to perform binary/presentation format conversions; these can also be done by using inet_pton() and inet_ntop() and by writing protocol-dependent code. This approach is not recommended, but it is provided here for reference and comparison.",
      "ja": "セクション6.2.3では、バイナリ/プレゼンテーション形式の変換を実行するための好ましい方法について説明します。これらは、inet_pton（）およびinet_ntop（）を使用したり、プロトコル依存コードを作成したりすることもできます。このアプローチは推奨されませんが、参照と比較のためにここで提供されています。"
    },
    {
      "indent": 3,
      "text": "Note that inet_ntop()/inet_pton() lose the scope identifier (if used, e.g., with link-local addresses) in the conversions, contrary to the getaddrinfo()/getnameinfo() functions.",
      "ja": "inet_ntop（）/inet_pton（）は、getaddrinfo（）/getnameInfo（）関数に反して、変換でスコープ識別子（例えば、リンクローカルアドレスを使用して、リンクローカルアドレスを使用する場合）を失うことに注意してください。"
    },
    {
      "indent": 0,
      "text": "A.1. Binary to Presentation Using inet_ntop()",
      "section_title": true,
      "ja": "A.1. INET_NTOP（）を使用してプレゼンテーションするバイナリからプレゼンテーション"
    },
    {
      "indent": 3,
      "text": "Conversions from network address structure to presentation format can be written as follows:",
      "ja": "ネットワークアドレス構造からプレゼンテーション形式への変換は、次のように記述できます。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_storage ss; char addrStr[INET6_ADDRSTRLEN];",
      "ja": "struct sockaddr_storage ss;char addrstr [inet6_addrstrlen];"
    },
    {
      "indent": 6,
      "text": "/* fill ss structure */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "switch (ss.ss_family) {",
      "ja": "switch（ss.ss_family）{"
    },
    {
      "indent": 11,
      "text": "case AF_INET:\n     inet_ntop(ss.ss_family,\n              &((struct sockaddr_in *)&ss)->sin_addr,\n              addrStr,\n              sizeof(addrStr));\n     break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "case AF_INET6:\n     inet_ntop(ss.ss_family,\n               &((struct sockaddr_in6 *)&ss)->sin6_addr,\n               addrStr,\n               sizeof(addrStr));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "break;",
      "ja": "壊す;"
    },
    {
      "indent": 6,
      "text": "     default:\n          /* handle unknown family */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that, the destination buffer addrStr should be long enough to contain the presentation address format: INET_ADDRSTRLEN for IPv4 and INET6_ADDRSTRLEN for IPv6. As INET6_ADDRSTRLEN is longer than INET_ADDRSTRLEN, the first one is used as the destination buffer length.",
      "ja": "宛先バッファaddRSTRは、プレゼンテーションアドレス形式を含めるのに十分な長さである必要があります：IPv4のINET_ADDRSTRLENおよびIPv6のINET6_ADDRSTRLEN。INET6_ADDRSTRLENはINET_ADDRSTRLENよりも長いため、最初のものは宛先バッファーの長さとして使用されます。"
    },
    {
      "indent": 0,
      "text": "A.2. Presentation to Binary Using inet_pton()",
      "section_title": true,
      "ja": "A.2. inet_pton（）を使用してバイナリへのプレゼンテーション"
    },
    {
      "indent": 3,
      "text": "Conversions from presentation format to network address structure can be written as follows:",
      "ja": "プレゼンテーション形式からネットワークアドレス構造への変換は、次のように記述できます。"
    },
    {
      "indent": 6,
      "text": "struct sockaddr_storage ss;\nstruct sockaddr_in *sin;\nstruct sockaddr_in6 *sin6;\nchar addrStr[INET6_ADDRSTRLEN];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* fill addrStr buffer and ss.ss_family */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "switch (ss.ss_family) {\n      case AF_INET:\n            sin = (struct sockaddr_in *)&ss;\n            inet_pton(ss.ss_family,\n                      addrStr,\n                      (sockaddr *)&sin->sin_addr));\n            break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "case AF_INET6:\n      sin6 = (struct sockaddr_in6 *)&ss;\n      inet_pton(ss.ss_family,\n                addrStr,\n                (sockaddr *)&sin6->sin6_addr);\n      break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "      default:\n          /* handle unknown family */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that, the address family of the presentation format must be known.",
      "ja": "プレゼンテーション形式のアドレスファミリを既知である必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Myung-Ki Shin ETRI/NIST 820 West Diamond Avenue Gaithersburg, MD 20899, USA",
      "ja": "Myung-ki shin etri/nist 820 West Diamond Avenue Gaithersburg、MD 20899、米国"
    },
    {
      "indent": 3,
      "text": "Phone: +1 301 975-3613\nFax:   +1 301 590-0932\nEMail: mshin@nist.gov",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Yong-Guen Hong ETRI PEC 161 Gajeong-Dong, Yuseong-Gu, Daejeon 305-350, Korea",
      "ja": "Yong-Guen Hong Etri Pec 161 Gajeong-Dong、Yusong-Gu、Daejeon 305-350、韓国"
    },
    {
      "indent": 3,
      "text": "Phone: +82 42 860 6447\nFax:   +82 42 861 5404\nEMail: yghong@pec.etri.re.kr",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jun-ichiro itojun HAGINO Research Laboratory, Internet Initiative Japan Inc. Takebashi Yasuda Bldg., 3-13 Kanda Nishiki-cho, Chiyoda-ku,Tokyo 101-0054, JAPAN",
      "ja": "Jun-Ithiro Itojun Hagino Research Laboratory、Internet Initiative Japan Inc. Takebashi Yasuda Bldg。、3-13 Kanda Nishiki-Cho、Chiyoda-Ku、Tokyo 101-0054、日本"
    },
    {
      "indent": 3,
      "text": "Phone: +81-3-5259-6350\nFax:   +81-3-5259-6351\nEMail: itojun@iijlab.net",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pekka Savola CSC/FUNET Espoo, Finland",
      "ja": "Pekka Savola CSC/Funet Espoo、フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: psavola@funet.fi",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Eva M. Castro Rey Juan Carlos University (URJC) Departamento de Informatica, Estadistica y Telematica C/Tulipan s/n 28933 Madrid - SPAIN",
      "ja": "Eva M. Castro Rey Juan Carlos University（URJC）Departamento de Informatica、Estadistica y Telematica C/Tulipan S/N 28933 Madrid -Spain"
    },
    {
      "indent": 3,
      "text": "EMail: eva@gsyc.escet.urjc.es",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、本書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスに基づくライセンスの範囲に関連すると主張される可能性のある他の権利に関しては、立場を取得しません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要なテクノロジーをカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}