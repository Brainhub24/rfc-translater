{
  "title": {
    "text": "RFC 4120 - The Kerberos Network Authentication Service (V5)",
    "ja": "RFC 4120 - Kerberosネットワーク認証サービス（V5）"
  },
  "number": 4120,
  "created_at": "2022-12-30 12:10:19.403931+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          C. Neuman\nRequest for Comments: 4120                                       USC-ISI\nObsoletes: 1510                                                    T. Yu\nCategory: Standards Track                                     S. Hartman\n                                                              K. Raeburn\n                                                                     MIT\n                                                               July 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "The Kerberos Network Authentication Service (V5)",
      "ja": "Kerberosネットワーク認証サービス（V5）"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、インターネット公式プロトコル標準の現在の版（STD 1）を参照してください。このメモの分布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document provides an overview and specification of Version 5 of the Kerberos protocol, and it obsoletes RFC 1510 to clarify aspects of the protocol and its intended use that require more detailed or clearer explanation than was provided in RFC 1510. This document is intended to provide a detailed description of the protocol, suitable for implementation, together with descriptions of the appropriate use of protocol messages and fields within those messages.",
      "ja": "このドキュメントは、Kerberosプロトコルのバージョン5の概要と仕様を提供し、RFC 1510で提供されたよりも詳細またはより明確な説明を必要とするプロトコルの側面とその意図した使用を明確にするためにRFC 1510を廃止します。このドキュメントは、プロトコルの詳細な説明は、実装に適したもので、これらのメッセージ内のプロトコルメッセージとフィールドの適切な使用の説明とともに。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n   1.1. The Kerberos Protocol ......................................6\n   1.2. Cross-Realm Operation ......................................8\n   1.3. Choosing a Principal with Which to Communicate .............9\n   1.4. Authorization .............................................10\n   1.5. Extending Kerberos without Breaking Interoperability ......11\n        1.5.1. Compatibility with RFC 1510 ........................11\n        1.5.2. Sending Extensible Messages ........................12\n   1.6. Environmental Assumptions .................................12\n   1.7. Glossary of Terms .........................................13\n2. Ticket Flag Uses and Requests ..................................16\n   2.1. Initial, Pre-authenticated, and\n        Hardware-Authenticated Tickets ............................17\n   2.2. Invalid Tickets ...........................................17\n   2.3. Renewable Tickets .........................................17\n   2.4. Postdated Tickets .........................................18\n   2.5. Proxiable and Proxy Tickets ...............................19\n   2.6. Forwardable Tickets .......................................19\n   2.7. Transited Policy Checking .................................20\n   2.8. OK as Delegate ............................................21\n   2.9. Other KDC Options .........................................21\n        2.9.1. Renewable-OK .......................................21\n        2.9.2. ENC-TKT-IN-SKEY ....................................22\n        2.9.3. Passwordless Hardware Authentication ...............22\n3. Message Exchanges ..............................................22\n   3.1. The Authentication Service Exchange .......................22\n        3.1.1. Generation of KRB_AS_REQ Message ...................24\n        3.1.2. Receipt of KRB_AS_REQ Message ......................24\n        3.1.3. Generation of KRB_AS_REP Message ...................24\n        3.1.4. Generation of KRB_ERROR Message ....................27\n        3.1.5. Receipt of KRB_AS_REP Message ......................27\n        3.1.6. Receipt of KRB_ERROR Message .......................28\n   3.2. The Client/Server Authentication Exchange .................29\n        3.2.1. The KRB_AP_REQ Message .............................29\n        3.2.2. Generation of a KRB_AP_REQ Message .................29\n        3.2.3. Receipt of KRB_AP_REQ Message ......................30\n        3.2.4. Generation of a KRB_AP_REP Message .................33\n        3.2.5. Receipt of KRB_AP_REP Message ......................33\n        3.2.6. Using the Encryption Key ...........................33\n   3.3. The Ticket-Granting Service (TGS) Exchange ................34\n        3.3.1. Generation of KRB_TGS_REQ Message ..................35\n        3.3.2. Receipt of KRB_TGS_REQ Message .....................37\n        3.3.3. Generation of KRB_TGS_REP Message ..................38\n        3.3.4. Receipt of KRB_TGS_REP Message .....................42",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   3.4. The KRB_SAFE Exchange .....................................42\n        3.4.1. Generation of a KRB_SAFE Message ...................42\n        3.4.2. Receipt of KRB_SAFE Message ........................43\n   3.5. The KRB_PRIV Exchange .....................................44\n        3.5.1. Generation of a KRB_PRIV Message ...................44\n        3.5.2. Receipt of KRB_PRIV Message ........................44\n   3.6. The KRB_CRED Exchange .....................................45\n        3.6.1. Generation of a KRB_CRED Message ...................45\n        3.6.2. Receipt of KRB_CRED Message ........................46\n   3.7. User-to-User Authentication Exchanges .....................47\n4. Encryption and Checksum Specifications .........................48\n5. Message Specifications .........................................50\n   5.1. Specific Compatibility Notes on ASN.1 .....................51\n        5.1.1. ASN.1 Distinguished Encoding Rules .................51\n        5.1.2. Optional Integer Fields ............................52\n        5.1.3. Empty SEQUENCE OF Types ............................52\n        5.1.4. Unrecognized Tag Numbers ...........................52\n        5.1.5. Tag Numbers Greater Than 30 ........................53\n   5.2. Basic Kerberos Types ......................................53\n        5.2.1. KerberosString .....................................53\n        5.2.2. Realm and PrincipalName ............................55\n        5.2.3. KerberosTime .......................................55\n        5.2.4. Constrained Integer Types ..........................55\n        5.2.5. HostAddress and HostAddresses ......................56\n        5.2.6. AuthorizationData ..................................57\n        5.2.7. PA-DATA ............................................60\n        5.2.8. KerberosFlags ......................................64\n        5.2.9. Cryptosystem-Related Types .........................65\n   5.3. Tickets ...................................................66\n   5.4. Specifications for the AS and TGS Exchanges ...............73\n        5.4.1. KRB_KDC_REQ Definition .............................73\n        5.4.2. KRB_KDC_REP Definition .............................81\n   5.5. Client/Server (CS) Message Specifications .................84\n        5.5.1. KRB_AP_REQ Definition ..............................84\n        5.5.2. KRB_AP_REP Definition ..............................88\n        5.5.3. Error Message Reply ................................89\n   5.6. KRB_SAFE Message Specification ............................89\n        5.6.1. KRB_SAFE definition ................................89\n   5.7. KRB_PRIV Message Specification ............................91\n        5.7.1. KRB_PRIV Definition ................................91\n   5.8. KRB_CRED Message Specification ............................92\n        5.8.1. KRB_CRED Definition ................................92\n   5.9. Error Message Specification ...............................94\n        5.9.1. KRB_ERROR Definition ...............................94\n   5.10. Application Tag Numbers ..................................96",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "6. Naming Constraints .............................................97\n   6.1. Realm Names ...............................................97\n   6.2. Principal Names .......................................... 99\n        6.2.1. Name of Server Principals .........................100\n7. Constants and Other Defined Values ............................101\n   7.1. Host Address Types .......................................101\n   7.2. KDC Messaging: IP Transports .............................102\n        7.2.1. UDP/IP transport ..................................102\n        7.2.2. TCP/IP Transport ..................................103\n        7.2.3. KDC Discovery on IP Networks ......................104\n   7.3. Name of the TGS ..........................................105\n   7.4. OID Arc for KerberosV5 ...................................106\n   7.5. Protocol Constants and Associated Values .................106\n        7.5.1. Key Usage Numbers .................................106\n        7.5.2. PreAuthentication Data Types ......................108\n        7.5.3. Address Types .....................................109\n        7.5.4. Authorization Data Types ..........................109\n        7.5.5. Transited Encoding Types ..........................109\n        7.5.6. Protocol Version Number ...........................109\n        7.5.7. Kerberos Message Types ............................110\n        7.5.8. Name Types ........................................110\n        7.5.9. Error Codes .......................................110\n8. Interoperability Requirements .................................113\n   8.1. Specification 2 ..........................................113\n   8.2. Recommended KDC Values ...................................116\n9. IANA Considerations ...........................................116\n10. Security Considerations ......................................117\n11. Acknowledgements .............................................121\nA. ASN.1 Module ..................................................123\nB. Changes since RFC 1510 ........................................131\nNormative References .............................................134\nInformative References ...........................................135",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the concepts and model upon which the Kerberos network authentication system is based. It also specifies Version 5 of the Kerberos protocol. The motivations, goals, assumptions, and rationale behind most design decisions are treated cursorily; they are more fully described in a paper available in IEEE communications [NT94] and earlier in the Kerberos portion of the Athena Technical Plan [MNSS87].",
      "ja": "このドキュメントでは、Kerberos Network認証システムの基礎となる概念とモデルについて説明します。また、Kerberosプロトコルのバージョン5を指定します。ほとんどの設計上の決定の背後にある動機、目標、仮定、および理論的根拠は、ひどく扱われます。それらは、IEEEコミュニケーションズ[NT94]およびアテナ技術計画[MNSS87]のKerberos部分で入手可能な論文でより完全に説明されています。"
    },
    {
      "indent": 3,
      "text": "This document is not intended to describe Kerberos to the end user, system administrator, or application developer. Higher-level papers describing Version 5 of the Kerberos system [NT94] and documenting version 4 [SNS88] are available elsewhere.",
      "ja": "このドキュメントは、Kerberosをエンドユーザー、システム管理者、またはアプリケーション開発者に説明するものではありません。Kerberosシステム[NT94]のバージョン5を説明し、バージョン4 [SNS88]の文書化を説明する高レベルの論文は、他の場所で入手できます。"
    },
    {
      "indent": 3,
      "text": "The Kerberos model is based in part on Needham and Schroeder's trusted third-party authentication protocol [NS78] and on modifications suggested by Denning and Sacco [DS81]. The original design and implementation of Kerberos Versions 1 through 4 was the work of two former Project Athena staff members, Steve Miller of Digital Equipment Corporation and Clifford Neuman (now at the Information Sciences Institute of the University of Southern California), along with Jerome Saltzer, Technical Director of Project Athena, and Jeffrey Schiller, MIT Campus Network Manager. Many other members of Project Athena have also contributed to the work on Kerberos.",
      "ja": "Kerberosモデルの一部は、NeedhamとSchroederの信頼できるサードパーティ認証プロトコル[NS78]に基づいており、DenningとSacco [DS81]によって提案された修正に基づいています。Kerberosバージョン1から4のオリジナルの設計と実装は、2人の元プロジェクトAthena Staffメンバー、デジタル機器コーポレーションのSteve MillerとClifford Neuman（現在は南カリフォルニア大学情報科学研究所）とJerome Saltzerの仕事でした。、Project Athenaのテクニカルディレクター、およびMIT Campus Network ManagerのJeffrey Schiller。Project Athenaの他の多くのメンバーも、Kerberosの作業に貢献しています。"
    },
    {
      "indent": 3,
      "text": "Version 5 of the Kerberos protocol (described in this document) has evolved because of new requirements and desires for features not available in Version 4. The design of Version 5 was led by Clifford Neuman and John Kohl with much input from the community. The development of the MIT reference implementation was led at MIT by John Kohl and Theodore Ts'o, with help and contributed code from many others. Since RFC 1510 was issued, many individuals have proposed extensions and revisions to the protocol. This document reflects some of these proposals. Where such changes involved significant effort, the document cites the contribution of the proposer.",
      "ja": "Kerberos Protocolのバージョン5（このドキュメントで説明）は、バージョン5では利用できない機能に対する新しい要件と希望のために進化しました。バージョン5の設計は、Clifford NeumanとJohn Kohlがコミュニティから多くの情報を提供して主導しました。MITリファレンス実装の開発は、MITでJohn KohlとTheodore Ts'oによって主導され、他の多くの人々からのヘルプと貢献コードがありました。RFC 1510が発行されて以来、多くの個人がプロトコルの拡張と改訂を提案しています。このドキュメントは、これらの提案のいくつかを反映しています。そのような変更が大幅に努力する場合、文書は提案者の貢献を引用しています。"
    },
    {
      "indent": 3,
      "text": "Reference implementations of both Version 4 and Version 5 of Kerberos are publicly available, and commercial implementations have been developed and are widely used. Details on the differences between Versions 4 and 5 can be found in [KNT94].",
      "ja": "Kerberosのバージョン4とバージョン5の両方の参照実装は公開されており、商業実装が開発されており、広く使用されています。バージョン4と5の違いの詳細は、[KNT94]に記載されています。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "1.1. The Kerberos Protocol",
      "section_title": true,
      "ja": "1.1. Kerberosプロトコル"
    },
    {
      "indent": 3,
      "text": "Kerberos provides a means of verifying the identities of principals, (e.g., a workstation user or a network server) on an open (unprotected) network. This is accomplished without relying on assertions by the host operating system, without basing trust on host addresses, without requiring physical security of all the hosts on the network, and under the assumption that packets traveling along the network can be read, modified, and inserted at will. Kerberos performs authentication under these conditions as a trusted third-party authentication service by using conventional (shared secret key) cryptography. Extensions to Kerberos (outside the scope of this document) can provide for the use of public key cryptography during certain phases of the authentication protocol. Such extensions support Kerberos authentication for users registered with public key certification authorities and provide certain benefits of public key cryptography in situations where they are needed.",
      "ja": "Kerberosは、オープン（保護されていない）ネットワークで、プリンシパルのアイデンティティ（ワークステーションユーザーやネットワークサーバーなど）を確認する手段を提供します。これは、ホストオペレーティングシステムによるアサーションに依存することなく、ホストアドレスに信頼することなく、ネットワーク上のすべてのホストの物理的なセキュリティを必要とせず、ネットワークに沿って移動するパケットを読み取り、変更、挿入できるという仮定の下で達成されます。意のままに。Kerberosは、従来の（共有秘密の鍵）暗号化を使用して、信頼できるサードパーティ認証サービスとしてこれらの条件下で認証を実行します。Kerberosへの拡張（このドキュメントの範囲外）は、認証プロトコルの特定の段階で公開キー暗号化を使用することができます。このような拡張機能は、公開キー認証当局に登録されたユーザー向けのKerberos認証をサポートし、必要な状況で公開キー暗号化の特定の利点を提供します。"
    },
    {
      "indent": 3,
      "text": "The basic Kerberos authentication process proceeds as follows: A client sends a request to the authentication server (AS) for \"credentials\" for a given server. The AS responds with these credentials, encrypted in the client's key. The credentials consist of a \"ticket\" for the server and a temporary encryption key (often called a \"session key\"). The client transmits the ticket (which contains the client's identity and a copy of the session key, all encrypted in the server's key) to the server. The session key (now shared by the client and server) is used to authenticate the client and may optionally be used to authenticate the server. It may also be used to encrypt further communication between the two parties or to exchange a separate sub-session key to be used to encrypt further communication. Note that many applications use Kerberos' functions only upon the initiation of a stream-based network connection. Unless an application performs encryption or integrity protection for the data stream, the identity verification applies only to the initiation of the connection, and it does not guarantee that subsequent messages on the connection originate from the same principal.",
      "ja": "基本的なKerberos認証プロセスは次のように進みます。クライアントは、特定のサーバーの「資格情報」の認証サーバー（AS）にリクエストを送信します。ASは、クライアントのキーで暗号化されたこれらの資格情報で応答します。資格情報は、サーバーの「チケット」と一時的な暗号化キー（「セッションキー」と呼ばれることが多い）で構成されています。クライアントは、チケット（クライアントの身元とセッションキーのコピーが含まれており、すべてサーバーのキーに暗号化されています）をサーバーに送信します。セッションキー（現在はクライアントとサーバーが共有している）は、クライアントの認証に使用され、オプションでサーバーの認証に使用される場合があります。また、2つの当事者間のさらなる通信を暗号化するか、さらに通信を暗号化するために使用される別のサブセッションキーを交換するために使用する場合があります。多くのアプリケーションは、河川ベースのネットワーク接続の開始時にのみKerberosの機能を使用していることに注意してください。アプリケーションがデータストリームに対して暗号化または整合性保護を実行しない限り、IDの検証は接続の開始にのみ適用され、接続の後続のメッセージが同じプリンシパルから発生することを保証するものではありません。"
    },
    {
      "indent": 3,
      "text": "Implementation of the basic protocol consists of one or more authentication servers running on physically secure hosts. The authentication servers maintain a database of principals (i.e., users and servers) and their secret keys. Code libraries provide encryption and implement the Kerberos protocol. In order to add authentication to its transactions, a typical network application adds calls to the Kerberos library directly or through the Generic Security Services Application Programming Interface (GSS-API) described in a separate document [RFC4121]. These calls result in the transmission of the messages necessary to achieve authentication.",
      "ja": "基本プロトコルの実装は、物理的に安全なホストで実行される1つ以上の認証サーバーで構成されています。認証サーバーは、プリンシパル（つまり、ユーザーとサーバー）のデータベースとその秘密キーを維持します。コードライブラリは、暗号化を提供し、Kerberosプロトコルを実装します。トランザクションに認証を追加するために、典型的なネットワークアプリケーションは、Kerberos Libraryに直接または汎用セキュリティサービスアプリケーションプログラミングインターフェイス（GSS-API）に電話を追加します[RFC4121]。これらの呼び出しは、認証を達成するために必要なメッセージの送信につながります。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol consists of several sub-protocols (or exchanges). There are two basic methods by which a client can ask a Kerberos server for credentials. In the first approach, the client sends a cleartext request for a ticket for the desired server to the AS. The reply is sent encrypted in the client's secret key. Usually this request is for a ticket-granting ticket (TGT), which can later be used with the ticket-granting server (TGS). In the second method, the client sends a request to the TGS. The client uses the TGT to authenticate itself to the TGS in the same manner as if it were contacting any other application server that requires Kerberos authentication. The reply is encrypted in the session key from the TGT. Though the protocol specification describes the AS and the TGS as separate servers, in practice they are implemented as different protocol entry points within a single Kerberos server.",
      "ja": "Kerberosプロトコルは、いくつかのサブプロトコル（または交換）で構成されています。クライアントがKerberosサーバーに資格情報を求めることができる2つの基本的な方法があります。最初のアプローチでは、クライアントは目的のサーバーのチケットのクリアテキストリクエストをASに送信します。返信は、クライアントのシークレットキーで暗号化されて送信されます。通常、このリクエストはチケット獲得チケット（TGT）のものであり、後でチケット栽培サーバー（TGS）で使用できます。2番目の方法では、クライアントはTGSにリクエストを送信します。クライアントは、TGTを使用して、Kerberos認証を必要とする他のアプリケーションサーバーに連絡している場合と同じ方法でTGSに認証します。返信は、TGTのセッションキーで暗号化されています。プロトコル仕様はASおよびTGSを別々のサーバーとして記述していますが、実際には、単一のKerberosサーバー内の異なるプロトコルエントリポイントとして実装されています。"
    },
    {
      "indent": 3,
      "text": "Once obtained, credentials may be used to verify the identity of the principals in a transaction, to ensure the integrity of messages exchanged between them, or to preserve privacy of the messages. The application is free to choose whatever protection may be necessary.",
      "ja": "取得すると、資格情報を使用して、トランザクションのプリンシパルのIDを検証し、それらの間で交換されるメッセージの整合性を確保するか、メッセージのプライバシーを維持することができます。アプリケーションは、必要になる可能性のあるものを自由に選択できます。"
    },
    {
      "indent": 3,
      "text": "To verify the identities of the principals in a transaction, the client transmits the ticket to the application server. Because the ticket is sent \"in the clear\" (parts of it are encrypted, but this encryption doesn't thwart replay) and might be intercepted and reused by an attacker, additional information is sent to prove that the message originated with the principal to whom the ticket was issued. This information (called the authenticator) is encrypted in the session key and includes a timestamp. The timestamp proves that the message was recently generated and is not a replay. Encrypting the authenticator in the session key proves that it was generated by a party possessing the session key. Since no one except the requesting principal and the server know the session key (it is never sent over the network in the clear), this guarantees the identity of the client.",
      "ja": "トランザクションでプリンシパルの身元を確認するために、クライアントはチケットをアプリケーションサーバーに送信します。チケットは「クリア」で送信されるため（その一部は暗号化されていますが、この暗号化はリプレイを阻止しません）、攻撃者によって傍受され、再利用される可能性があるため、追加情報が送信されて、メッセージがプリンシパルから発信されたことを証明するために送信されます。チケットが発行された人。この情報（Authenticatorと呼ばれる）は、セッションキーで暗号化され、タイムスタンプが含まれています。タイムスタンプは、メッセージが最近生成され、リプレイではないことを証明しています。セッションキーで認証器を暗号化することは、セッションキーを所有する当事者によって生成されたことを証明します。リクエストプリンシパルとサーバーがセッションキーを知っていることを除いて（クリアのネットワークを介して送信されることはありません）、これによりクライアントの身元が保証されます。"
    },
    {
      "indent": 3,
      "text": "The integrity of the messages exchanged between principals can also be guaranteed by using the session key (passed in the ticket and contained in the credentials). This approach provides detection of both replay attacks and message stream modification attacks. It is accomplished by generating and transmitting a collision-proof checksum (elsewhere called a hash or digest function) of the client's message, keyed with the session key. Privacy and integrity of the messages exchanged between principals can be secured by encrypting the data to be passed by using the session key contained in the ticket or the sub-session key found in the authenticator.",
      "ja": "プリンシパル間で交換されるメッセージの整合性は、セッションキーを使用して保証することもできます（チケットに渡され、資格情報に含まれる）。このアプローチは、リプレイ攻撃とメッセージストリーム変更攻撃の両方の検出を提供します。これは、セッションキーを備えたクライアントのメッセージの衝突防止チェックサム（他の場所でハッシュまたはダイジェスト関数と呼ばれる他の場所）を生成および送信することによって達成されます。プリンシパル間で交換されるメッセージのプライバシーと整合性は、チケットに含まれるセッションキーまたは認証装置にあるサブセッションキーを使用して、渡されるデータを暗号化することにより保護できます。"
    },
    {
      "indent": 3,
      "text": "The authentication exchanges mentioned above require read-only access to the Kerberos database. Sometimes, however, the entries in the database must be modified, such as when adding new principals or changing a principal's key. This is done using a protocol between a client and a third Kerberos server, the Kerberos Administration Server (KADM). There is also a protocol for maintaining multiple copies of the Kerberos database. Neither of these protocols are described in this document.",
      "ja": "上記の認証交換では、Kerberosデータベースへの読み取り専用アクセスが必要です。ただし、新しいプリンシパルを追加したり、プリンシパルのキーを変更したりするなど、データベース内のエントリを変更する必要がある場合があります。これは、クライアントと3番目のKerberosサーバー、Kerberos Administration Server（KADM）の間のプロトコルを使用して行われます。Kerberosデータベースの複数のコピーを維持するためのプロトコルもあります。これらのプロトコルはどちらもこのドキュメントに記載されていません。"
    },
    {
      "indent": 0,
      "text": "1.2. Cross-Realm Operation",
      "section_title": true,
      "ja": "1.2. クロスリアム操作"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol is designed to operate across organizational boundaries. A client in one organization can be authenticated to a server in another. Each organization wishing to run a Kerberos server establishes its own \"realm\". The name of the realm in which a client is registered is part of the client's name and can be used by the end-service to decide whether to honor a request.",
      "ja": "Kerberosプロトコルは、組織の境界を越えて動作するように設計されています。ある組織のクライアントは、別の組織のサーバーに認証できます。Kerberosサーバーの実行を希望する各組織は、独自の「レルム」を確立します。クライアントが登録されている領域の名前は、クライアントの名前の一部であり、エンドサービスで使用してリクエストを尊重するかどうかを決定できます。"
    },
    {
      "indent": 3,
      "text": "By establishing \"inter-realm\" keys, the administrators of two realms can allow a client authenticated in the local realm to prove its identity to servers in other realms. The exchange of inter-realm keys (a separate key may be used for each direction) registers the ticket-granting service of each realm as a principal in the other realm. A client is then able to obtain a TGT for the remote realm's ticket-granting service from its local realm. When that TGT is used, the remote ticket-granting service uses the inter-realm key (which usually differs from its own normal TGS key) to decrypt the TGT; thus it is certain that the ticket was issued by the client's own TGS. Tickets issued by the remote ticket-granting service will indicate to the end-service that the client was authenticated from another realm.",
      "ja": "「間違った」キーを確立することにより、2つの領域の管理者は、地元の領域で認証されたクライアントが他の領域のサーバーに対するアイデンティティを証明できるようにすることができます。リアルム間キーの交換（各方向に個別のキーを使用できます）は、他の領域のプリンシパルとして各領域のチケット授与サービスを登録します。クライアントは、地元の領域からリモートレルムのチケット栽培サービスのTGTを取得できます。そのTGTを使用すると、リモートチケット栽培サービスは、REALM間キー（通常は通常のTGSキーとは異なります）を使用してTGTを復号化します。したがって、チケットがクライアント自身のTGによって発行されたことは確かです。リモートチケット栽培サービスによって発行されたチケットは、クライアントが別の領域から認証されたことを最終サービスに示します。"
    },
    {
      "indent": 3,
      "text": "Without cross-realm operation, and with appropriate permission, the client can arrange registration of a separately-named principal in a remote realm and engage in normal exchanges with that realm's services. However, for even small numbers of clients this becomes cumbersome, and more automatic methods as described here are necessary.",
      "ja": "クロスリアムの操作がなく、適切な許可を得て、クライアントは、リモートレルムの別々の名前のプリンシパルの登録を手配し、その領域のサービスとの通常の交換を行うことができます。ただし、少数のクライアントでさえ、これは面倒になり、ここで説明するより自動的な方法が必要になります。"
    },
    {
      "indent": 3,
      "text": "A realm is said to communicate with another realm if the two realms share an inter-realm key, or if the local realm shares an inter-realm key with an intermediate realm that communicates with the remote realm. An authentication path is the sequence of intermediate realms that are transited in communicating from one realm to another.",
      "ja": "領域は、2つの領域がリアルム間キーを共有している場合、またはローカルレルムがリモートレルムと通信する中間領域とリアルム間キーを共有している場合、別の領域と通信すると言われています。認証パスは、ある領域から別の領域への通信で通過する中間領域のシーケンスです。"
    },
    {
      "indent": 3,
      "text": "Realms may be organized hierarchically. Each realm shares a key with its parent and a different key with each child. If an inter-realm key is not directly shared by two realms, the hierarchical organization allows an authentication path to be easily constructed.",
      "ja": "領域は階層的に編成される場合があります。各領域は、親とキーを共有し、各子供とは異なるキーを共有しています。Realm間キーが2つの領域で直接共有されていない場合、階層組織は認証パスを簡単に構築できるようにします。"
    },
    {
      "indent": 3,
      "text": "If a hierarchical organization is not used, it may be necessary to consult a database in order to construct an authentication path between realms.",
      "ja": "階層組織が使用されていない場合、レルム間の認証パスを構築するためにデータベースを参照する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "Although realms are typically hierarchical, intermediate realms may be bypassed to achieve cross-realm authentication through alternate authentication paths. (These might be established to make communication between two realms more efficient.) It is important for the end-service to know which realms were transited when deciding how much faith to place in the authentication process. To facilitate this decision, a field in each ticket contains the names of the realms that were involved in authenticating the client.",
      "ja": "レルムは通常階層的ですが、中間の領域をバイパスして、代替認証パスを介してクロスリアム認証を実現することができます。（これらは、2つの領域間のコミュニケーションをより効率的にするために確立される可能性があります。）エンドサービスが、認証プロセスにどの程度の信仰を置くかを決定する際にどの領域が通過したかを知ることが重要です。この決定を容易にするために、各チケットのフィールドには、クライアントの認証に関与していた領域の名前が含まれています。"
    },
    {
      "indent": 3,
      "text": "The application server is ultimately responsible for accepting or rejecting authentication and SHOULD check the transited field. The application server may choose to rely on the Key Distribution Center (KDC) for the application server's realm to check the transited field. The application server's KDC will set the TRANSITED-POLICY-CHECKED flag in this case. The KDCs for intermediate realms may also check the transited field as they issue TGTs for other realms, but they are encouraged not to do so. A client may request that the KDCs not check the transited field by setting the DISABLE-TRANSITED-CHECK flag. KDCs SHOULD honor this flag.",
      "ja": "アプリケーションサーバーは、最終的に認証を受け入れるか拒否する責任があり、通過フィールドを確認する必要があります。アプリケーションサーバーは、アプリケーションサーバーのレルムのキー配布センター（KDC）に依存することを選択して、通過フィールドを確認することができます。この場合、アプリケーションサーバーのKDCは、送信されたポリシーチェックフラグを設定します。中間領域のKDCは、他の領域にTGTを発行するため、通過フィールドをチェックすることもできますが、そうしないように奨励されています。クライアントは、KDCSが無効化された転換チェックフラグを設定して、通過フィールドをチェックしないように要求する場合があります。KDCはこの旗を称えるべきです。"
    },
    {
      "indent": 0,
      "text": "1.3. Choosing a Principal with Which to Communicate",
      "section_title": true,
      "ja": "1.3. 通信する校長を選択する"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol provides the means for verifying (subject to the assumptions in Section 1.6) that the entity with which one communicates is the same entity that was registered with the KDC using the claimed identity (principal name). It is still necessary to determine whether that identity corresponds to the entity with which one intends to communicate.",
      "ja": "Kerberos Protocolは、請求されたID（主名）を使用してKDCに登録されたエンティティと同じエンティティが同じエンティティであることを確認するための手段（セクション1.6の仮定の対象となる）を提供します。そのアイデンティティが通信する意図があるエンティティに対応するかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "When appropriate data has been exchanged in advance, the application may perform this determination syntactically based on the application protocol specification, information provided by the user, and configuration files. For example, the server principal name (including realm) for a telnet server might be derived from the user-specified host name (from the telnet command line), the \"host/\" prefix specified in the application protocol specification, and a mapping to a Kerberos realm derived syntactically from the domain part of the specified hostname and information from the local Kerberos realms database.",
      "ja": "適切なデータが事前に交換された場合、アプリケーションはアプリケーションプロトコル仕様、ユーザーが提供する情報、および構成ファイルに基づいて構文的にこの決定を実行できます。たとえば、Telnetサーバーのサーバープリンシパル名（Realmを含む）は、ユーザー指定のホスト名（Telnetコマンドラインから）、アプリケーションプロトコル仕様で指定された「ホスト/」プレフィックス、およびマッピングから派生する場合があります。Kerberos Realmは、指定されたホスト名のドメイン部分から構文的に派生し、ローカルKerberos Realmsデータベースの情報から派生しました。"
    },
    {
      "indent": 3,
      "text": "One can also rely on trusted third parties to make this determination, but only when the data obtained from the third party is suitably integrity-protected while resident on the third-party server and when transmitted. Thus, for example, one should not rely on an unprotected DNS record to map a host alias to the primary name of a server, accepting the primary name as the party that one intends to contact, since an attacker can modify the mapping and impersonate the party.",
      "ja": "また、この決定を行うために信頼できる第三者に依存することもできますが、サードパーティから得られたデータがサードパーティサーバーの居住者および送信中に適切に整合性保護されている場合にのみです。したがって、たとえば、保護されていないDNSレコードに依存してホストエイリアスをサーバーの主な名前にマッピングするべきではありません。パーティ。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos and protocols based on Kerberos MUST NOT use insecure DNS queries to canonicalize the hostname components of the service principal names (i.e., they MUST NOT use insecure DNS queries to map one name to another to determine the host part of the principal name with which one is to communicate). In an environment without secure name service, application authors MAY append a statically configured domain name to unqualified hostnames before passing the name to the security mechanisms, but they should do no more than that. Secure name service facilities, if available, might be trusted for hostname canonicalization, but such canonicalization by the client SHOULD NOT be required by KDC implementations.",
      "ja": "Kerberosの実装とKerberosに基づくプロトコルの実装は、サービスプリンシパル名のホスト名コンポーネントを正規化するために不安定なDNSクエリを使用してはなりません（つまり、安全でないDNSクエリを使用して、1つの名前を別の名前にマッピングして、プリンシパル名のホストパーツを決定してはなりません。どちらが通信するか）。安全な名前サービスのない環境では、アプリケーションの著者は、セキュリティメカニズムに名前を渡す前に、静的に構成されたドメイン名を資格のないホスト名に追加することができますが、それ以上のことを行う必要があります。安全な名前サービス施設は、利用可能な場合は、ホスト名の標準化について信頼される可能性がありますが、クライアントによるそのような標準化は、KDCの実装では要求されるべきではありません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many current implementations do some degree of canonicalization of the provided service name, often using DNS even though it creates security problems. However, there is no consistency among implementations as to whether the service name is case folded to lowercase or whether reverse resolution is used. To maximize interoperability and security, applications SHOULD provide security mechanisms with names that result from folding the user-entered name to lowercase without performing any other modifications or canonicalization.",
      "ja": "実装注：多くの現在の実装は、提供されたサービス名のある程度の正規化を行い、多くの場合、セキュリティの問題を作成してもDNSを使用しています。ただし、サービス名が小文字に折りたたまれているかどうか、または逆分解能が使用されているかどうかについて、実装間で一貫性はありません。相互運用性とセキュリティを最大化するために、アプリケーションは、他の変更や標準化を実行せずにユーザーが入力した名前を小文字に折りたたむことに起因する名前をセキュリティメカニズムに提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "1.4. Authorization",
      "section_title": true,
      "ja": "1.4. 許可"
    },
    {
      "indent": 3,
      "text": "As an authentication service, Kerberos provides a means of verifying the identity of principals on a network. Authentication is usually useful primarily as a first step in the process of authorization, determining whether a client may use a service, which objects the client is allowed to access, and the type of access allowed for each. Kerberos does not, by itself, provide authorization. Possession of a client ticket for a service provides only for authentication of the client to that service, and in the absence of a separate authorization procedure, an application should not consider it to authorize the use of that service.",
      "ja": "認証サービスとして、Kerberosはネットワーク上のプリンシパルのIDを確認する手段を提供します。認証は通常、主に許可のプロセスの最初のステップとして有用であり、クライアントがサービスを使用し、クライアントがアクセスできるようにするかどうか、それぞれに許可されているアクセスの種類を決定することができるかどうかを判断します。Kerberosは、それ自体が認可を提供しません。サービスのクライアントチケットの所有は、そのサービスに対するクライアントの認証のみを提供し、別の承認手順がない場合、アプリケーションはそのサービスの使用を承認するためにそれを考慮すべきではありません。"
    },
    {
      "indent": 3,
      "text": "Separate authorization methods MAY be implemented as application-specific access control functions and may utilize files on the application server, on separately issued authorization credentials such as those based on proxies [Neu93], or on other authorization services. Separately authenticated authorization credentials MAY be embedded in a ticket's authorization data when encapsulated by the KDC-issued authorization data element.",
      "ja": "個別の承認方法は、アプリケーション固有のアクセス制御関数として実装され、アプリケーションサーバー、プロキシ[NEU93]に基づくものなどの個別に発行された認証資格情報、または他の承認サービスにファイルを使用できます。個別に認証された認証資格情報は、KDC発行の認証データ要素によってカプセル化された場合、チケットの承認データに埋め込まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "Applications should not accept the mere issuance of a service ticket by the Kerberos server (even by a modified Kerberos server) as granting authority to use the service, since such applications may become vulnerable to the bypass of this authorization check in an environment where other options for application authentication are provided, or if they interoperate with other KDCs.",
      "ja": "アプリケーションは、そのようなアプリケーションが他のオプションである環境でこの承認チェックのバイパスに対して脆弱になる可能性があるため、サービスを使用するための権限を付与するために、Kerberos Server（修正されたKerberosサーバーでも）によるサービスチケットの単なる発行を受け入れないでください。アプリケーションの認証が提供される場合、または他のKDCと相互運用する場合。"
    },
    {
      "indent": 0,
      "text": "1.5. Extending Kerberos without Breaking Interoperability",
      "section_title": true,
      "ja": "1.5. 相互運用性を破らずにカレベロスを拡張します"
    },
    {
      "indent": 3,
      "text": "As the deployed base of Kerberos implementations grows, extending Kerberos becomes more important. Unfortunately, some extensions to the existing Kerberos protocol create interoperability issues because of uncertainty regarding the treatment of certain extensibility options by some implementations. This section includes guidelines that will enable future implementations to maintain interoperability.",
      "ja": "Kerberosの実装の展開ベースが成長するにつれて、Kerberosの拡張がより重要になります。残念ながら、既存のKerberosプロトコルへの一部の拡張は、一部の実装による特定の拡張性オプションの処理に関する不確実性のため、相互運用性の問題を作成します。このセクションには、将来の実装が相互運用性を維持できるようにするガイドラインが含まれています。"
    },
    {
      "indent": 3,
      "text": "Kerberos provides a general mechanism for protocol extensibility. Some protocol messages contain typed holes -- sub-messages that contain an octet-string along with an integer that defines how to interpret the octet-string. The integer types are registered centrally, but they can be used both for vendor extensions and for extensions standardized through the IETF.",
      "ja": "Kerberosは、プロトコルの拡張性の一般的なメカニズムを提供します。一部のプロトコルメッセージには、タイプされた穴が含まれています。これは、オクテットストリングの解釈方法を定義する整数とともに、オクテット弦を含むサブメッセージです。整数タイプは中央に登録されていますが、ベンダー拡張機能とIETFを介して標準化された拡張機能の両方に使用できます。"
    },
    {
      "indent": 3,
      "text": "In this document, the word \"extension\" refers to extension by defining a new type to insert into an existing typed hole in a protocol message. It does not refer to extension by addition of new fields to ASN.1 types, unless the text explicitly indicates otherwise.",
      "ja": "このドキュメントでは、「拡張機能」という単語は、プロトコルメッセージに既存の型穴に挿入する新しいタイプを定義することにより、拡張機能を指します。テキストが明示的に特に示されていない限り、ASN.1タイプに新しいフィールドを追加することによって拡張を指すものではありません。"
    },
    {
      "indent": 0,
      "text": "1.5.1. Compatibility with RFC 1510",
      "section_title": true,
      "ja": "1.5.1. RFC 1510との互換性"
    },
    {
      "indent": 3,
      "text": "Note that existing Kerberos message formats cannot readily be extended by adding fields to the ASN.1 types. Sending additional fields often results in the entire message being discarded without an error indication. Future versions of this specification will provide guidelines to ensure that ASN.1 fields can be added without creating an interoperability problem.",
      "ja": "ASN.1タイプにフィールドを追加しても、既存のKerberosメッセージフォーマットを容易に拡張できないことに注意してください。多くの場合、追加のフィールドを送信すると、エラーの表示なしにメッセージ全体が破棄されます。この仕様の将来のバージョンは、相互運用性の問題を作成せずにASN.1フィールドを追加できるようにするガイドラインを提供します。"
    },
    {
      "indent": 3,
      "text": "In the meantime, all new or modified implementations of Kerberos that receive an unknown message extension SHOULD preserve the encoding of the extension but otherwise ignore its presence. Recipients MUST NOT decline a request simply because an extension is present.",
      "ja": "それまでの間、未知のメッセージ拡張子を受け取るKerberosのすべての新しいまたは変更された実装は、拡張機能のエンコードを保持する必要がありますが、それ以外の場合はその存在を無視します。拡張機能が存在するという理由だけで、受信者はリクエストを拒否してはなりません。"
    },
    {
      "indent": 3,
      "text": "There is one exception to this rule. If an unknown authorization data element type is received by a server other than the ticket-granting service either in an AP-REQ or in a ticket contained in an AP-REQ, then authentication MUST fail. One of the primary uses of authorization data is to restrict the use of the ticket. If the service cannot determine whether the restriction applies to that service, then a security weakness may result if the ticket can be used for that service. Authorization elements that are optional SHOULD be enclosed in the AD-IF-RELEVANT element.",
      "ja": "このルールには1つの例外があります。不明な承認データ要素タイプが、AP-REQまたはAP-REQに含まれるチケットのいずれかのチケット栽培サービス以外のサーバーによって受信された場合、認証が失敗する必要があります。承認データの主な用途の1つは、チケットの使用を制限することです。サービスが制限がそのサービスに適用されるかどうかを判断できない場合、チケットをそのサービスに使用できる場合、セキュリティの弱点が生じる場合があります。オプションの承認要素は、AD-IFリレッド要素に同封する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ticket-granting service MUST ignore but propagate to derivative tickets any unknown authorization data types, unless those data types are embedded in a MANDATORY-FOR-KDC element, in which case the request will be rejected. This behavior is appropriate because requiring that the ticket-granting service understand unknown authorization data types would require that KDC software be upgraded to understand new application-level restrictions before applications used these restrictions, decreasing the utility of authorization data as a mechanism for restricting the use of tickets. No security problem is created because services to which the tickets are issued will verify the authorization data.",
      "ja": "チケット栽培サービスは、それらのデータ型が必須のkdc要素に埋め込まれていない限り、未知の承認データ型をデリバティブチケットに無視する必要がありますが、その場合、リクエストが拒否されます。チケット授与サービスが不明な承認データ型を理解することを要求することで、アプリケーションがこれらの制限を使用する前にKDCソフトウェアをアップグレードするようにKDCソフトウェアをアップグレードする必要があるため、この動作は適切です。チケットの。チケットが発行されるサービスが認証データを検証するため、セキュリティの問題は作成されません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many RFC 1510 implementations ignore unknown authorization data elements. Depending on these implementations to honor authorization data restrictions may create a security weakness.",
      "ja": "実装注：多くのRFC 1510実装は、未知の承認データ要素を無視します。認可データの制限を尊重するためのこれらの実装に応じて、セキュリティの弱点が生じる可能性があります。"
    },
    {
      "indent": 0,
      "text": "1.5.2. Sending Extensible Messages",
      "section_title": true,
      "ja": "1.5.2. 拡張可能なメッセージの送信"
    },
    {
      "indent": 3,
      "text": "Care must be taken to ensure that old implementations can understand messages sent to them, even if they do not understand an extension that is used. Unless the sender knows that an extension is supported, the extension cannot change the semantics of the core message or previously defined extensions.",
      "ja": "使用されている拡張機能を理解していなくても、古い実装が送信されたメッセージを理解できるように注意する必要があります。送信者が拡張機能がサポートされていることを知らない限り、拡張機能はコアメッセージまたは以前に定義された拡張機能のセマンティクスを変更することはできません。"
    },
    {
      "indent": 3,
      "text": "For example, an extension including key information necessary to decrypt the encrypted part of a KDC-REP could only be used in situations where the recipient was known to support the extension. Thus when designing such extensions it is important to provide a way for the recipient to notify the sender of support for the extension. For example in the case of an extension that changes the KDC-REP reply key, the client could indicate support for the extension by including a padata element in the AS-REQ sequence. The KDC should only use the extension if this padata element is present in the AS-REQ. Even if policy requires the use of the extension, it is better to return an error indicating that the extension is required than to use the extension when the recipient may not support it. Debugging implementations that do not interoperate is easier when errors are returned.",
      "ja": "たとえば、KDC-REPの暗号化された部分を復号化するために必要な重要な情報を含む拡張機能は、受信者が拡張をサポートすることが知られている状況でのみ使用できます。したがって、そのような拡張機能を設計するとき、受信者が送信者に拡張機能のサポートを通知する方法を提供することが重要です。たとえば、KDC-REP応答キーを変更する拡張機能の場合、クライアントはAS-REQシーケンスにPadata要素を含めることにより、拡張機能のサポートを示すことができます。KDCは、このPadata要素がAS-Reqに存在する場合にのみ拡張機能を使用する必要があります。ポリシーが拡張機能を使用する必要がある場合でも、受信者がサポートしない場合に拡張機能を使用するよりも拡張機能が必要であることを示すエラーを返す方が良いです。エラーが返されると、相互運用しない実装のデバッグが簡単になります。"
    },
    {
      "indent": 0,
      "text": "1.6. Environmental Assumptions",
      "section_title": true,
      "ja": "1.6. 環境の仮定"
    },
    {
      "indent": 3,
      "text": "Kerberos imposes a few assumptions on the environment in which it can properly function, including the following:",
      "ja": "Kerberosは、以下を含む、適切に機能できる環境にいくつかの仮定を課しています。"
    },
    {
      "indent": 3,
      "text": "* \"Denial of service\" attacks are not solved with Kerberos. There are places in the protocols where an intruder can prevent an application from participating in the proper authentication steps. Detection and solution of such attacks (some of which can appear to be not-uncommon \"normal\" failure modes for the system) are usually best left to the human administrators and users.",
      "ja": "* 「サービスの拒否」攻撃は、Kerberosで解決されません。プロトコルには、侵入者がアプリケーションが適切な認証手順に参加するのを防ぐことができる場所があります。このような攻撃の検出と解決策（その一部は、システムの非都合ではない「通常の」障害モードのように見えることがあります）は、通常、人間の管理者とユーザーに任されるのが最善です。"
    },
    {
      "indent": 3,
      "text": "* Principals MUST keep their secret keys secret. If an intruder somehow steals a principal's key, it will be able to masquerade as that principal or to impersonate any server to the legitimate principal.",
      "ja": "* 校長は秘密の鍵を秘密にしなければなりません。侵入者がどういうわけかプリンシパルの鍵を盗むと、その校長を装ったり、正当なプリンシパルにサーバーになりすましたりすることができます。"
    },
    {
      "indent": 3,
      "text": "* \"Password guessing\" attacks are not solved by Kerberos. If a user chooses a poor password, it is possible for an attacker to successfully mount an offline dictionary attack by repeatedly attempting to decrypt, with successive entries from a dictionary, messages obtained which are encrypted under a key derived from the user's password.",
      "ja": "* 「パスワード推測」攻撃は、Kerberosによって解決されません。ユーザーが悪いパスワードを選択した場合、攻撃者は、ユーザーのパスワードから派生したキーの下で暗号化された辞書からの連続したエントリ、辞書からの連続したエントリを使用して、繰り返し復号化しようとすることにより、オフライン辞書攻撃を正常に取り付けることができます。"
    },
    {
      "indent": 3,
      "text": "* Each host on the network MUST have a clock which is \"loosely synchronized\" to the time of the other hosts; this synchronization is used to reduce the bookkeeping needs of application servers when they do replay detection. The degree of \"looseness\" can be configured on a per-server basis, but it is typically on the order of 5 minutes. If the clocks are synchronized over the network, the clock synchronization protocol MUST itself be secured from network attackers.",
      "ja": "* ネットワーク上の各ホストには、他のホストの時間に「ゆるく同期した」クロックが必要です。この同期は、リプレイ検出を行うときにアプリケーションサーバーの簿記ニーズを減らすために使用されます。「ゆるみ」の程度は、サーバーごとに構成できますが、通常は5分程度です。クロックがネットワークを介して同期されている場合、クロック同期プロトコル自体はネットワーク攻撃者から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Principal identifiers are not recycled on a short-term basis. A typical mode of access control will use access control lists (ACLs) to grant permissions to particular principals. If a stale ACL entry remains for a deleted principal and the principal identifier is reused, the new principal will inherit rights specified in the stale ACL entry. By not re-using principal identifiers, the danger of inadvertent access is removed.",
      "ja": "* 主要な識別子は、短期的にリサイクルされません。典型的なアクセス制御モードは、アクセス制御リスト（ACL）を使用して、特定のプリンシパルに許可を付与します。削除されたプリンシパルの古いACLエントリが残り、プリンシパル識別子が再利用される場合、新しいプリンシパルは古いACLエントリで指定された権利を継承します。元本の識別子を再利用しないことにより、不注意なアクセスの危険が削除されます。"
    },
    {
      "indent": 0,
      "text": "1.7. Glossary of Terms",
      "section_title": true,
      "ja": "1.7. 用語の用語集"
    },
    {
      "indent": 3,
      "text": "Below is a list of terms used throughout this document.",
      "ja": "以下は、このドキュメント全体で使用される用語のリストです。"
    },
    {
      "indent": 3,
      "text": "Authentication Verifying the claimed identity of a principal.",
      "ja": "主張されたプリンシパルのアイデンティティを検証する認証。"
    },
    {
      "indent": 3,
      "text": "Authentication header A record containing a Ticket and an Authenticator to be presented to a server as part of the authentication process.",
      "ja": "認証ヘッダー認証プロセスの一部としてサーバーに提示されるチケットと認証器を含むレコード。"
    },
    {
      "indent": 3,
      "text": "Authentication path A sequence of intermediate realms transited in the authentication process when communicating from one realm to another.",
      "ja": "認証パスある領域から別の領域に通信する際に、認証プロセスで一連の中間レルムが通過しました。"
    },
    {
      "indent": 3,
      "text": "Authenticator A record containing information that can be shown to have been recently generated using the session key known only by the client and server.",
      "ja": "Authenticatorクライアントとサーバーのみが知っているセッションキーを使用して最近生成されたことが示された情報を含むレコード。"
    },
    {
      "indent": 3,
      "text": "Authorization The process of determining whether a client may use a service, which objects the client is allowed to access, and the type of access allowed for each.",
      "ja": "許可クライアントがサービスを使用するかどうかを判断するプロセス、クライアントがアクセスすることが許可されているサービス、およびそれぞれに許可されたアクセスの種類を許可します。"
    },
    {
      "indent": 3,
      "text": "Capability A token that grants the bearer permission to access an object or service. In Kerberos, this might be a ticket whose use is restricted by the contents of the authorization data field, but which lists no network addresses, together with the session key necessary to use the ticket.",
      "ja": "機能担当者にオブジェクトまたはサービスにアクセスする許可を付与するトークン。Kerberosでは、これは認証データフィールドの内容によって使用されるが、チケットを使用するために必要なセッションキーとともにネットワークアドレスをリストしないチケットかもしれません。"
    },
    {
      "indent": 3,
      "text": "Ciphertext The output of an encryption function. Encryption transforms plaintext into ciphertext.",
      "ja": "暗号化暗号化関数の出力。暗号化は、プレーンテキストをciphertextに変換します。"
    },
    {
      "indent": 3,
      "text": "Client A process that makes use of a network service on behalf of a user. Note that in some cases a Server may itself be a client of some other server (e.g., a print server may be a client of a file server).",
      "ja": "クライアントユーザーに代わってネットワークサービスを利用するプロセス。場合によっては、サーバー自体が他のサーバーのクライアントである可能性があることに注意してください（たとえば、印刷サーバーはファイルサーバーのクライアントである場合があります）。"
    },
    {
      "indent": 3,
      "text": "Credentials A ticket plus the secret session key necessary to use that ticket successfully in an authentication exchange.",
      "ja": "資格情報チケットと、認証交換でそのチケットを正常に使用するために必要な秘密セッションキー。"
    },
    {
      "indent": 3,
      "text": "Encryption Type (etype) When associated with encrypted data, an encryption type identifies the algorithm used to encrypt the data and is used to select the appropriate algorithm for decrypting the data. Encryption type tags are communicated in other messages to enumerate algorithms that are desired, supported, preferred, or allowed to be used for encryption of data between parties. This preference is combined with local information and policy to select an algorithm to be used.",
      "ja": "暗号化タイプ（ETYPE）暗号化されたデータに関連付けられている場合、暗号化タイプはデータの暗号化に使用されるアルゴリズムを識別し、データを復号化するための適切なアルゴリズムを選択するために使用されます。暗号化タイプのタグは、他のメッセージで通知され、当事者間のデータの暗号化に使用される、サポート、支持、優先、または使用されるアルゴリズムを列挙します。この好みは、ローカル情報とポリシーと組み合わせて、使用するアルゴリズムを選択します。"
    },
    {
      "indent": 3,
      "text": "KDC Key Distribution Center. A network service that supplies tickets and temporary session keys; or an instance of that service or the host on which it runs. The KDC services both initial ticket and ticket-granting ticket requests. The initial ticket portion is sometimes referred to as the Authentication Server (or service). The ticket-granting ticket portion is sometimes referred to as the ticket-granting server (or service).",
      "ja": "KDCキーディストリビューションセンター。チケットと一時的なセッションキーを提供するネットワークサービス。または、そのサービスまたはそれが実行されるホストのインスタンス。KDCは、初期チケットとチケットを獲得するチケットの両方のリクエストの両方にサービスを提供します。最初のチケット部分は、認証サーバー（またはサービス）と呼ばれることがあります。チケット獲得チケットの部分は、チケット栽培サーバー（またはサービス）と呼ばれることもあります。"
    },
    {
      "indent": 3,
      "text": "Kerberos The name given to the Project Athena's authentication service, the protocol used by that service, or the code used to implement the authentication service. The name is adopted from the three-headed dog that guards Hades.",
      "ja": "KerberosプロジェクトAthenaの認証サービス、そのサービスで使用されるプロトコル、または認証サービスの実装に使用されるコードに与えられた名前。名前は、ハデスを守る3頭の犬から採用されています。"
    },
    {
      "indent": 3,
      "text": "Key Version Number (kvno) A tag associated with encrypted data identifies which key was used for encryption when a long-lived key associated with a principal changes over time. It is used during the transition to a new key so that the party decrypting a message can tell whether the data was encrypted with the old or the new key.",
      "ja": "キーバージョン番号（KVNO）暗号化されたデータに関連付けられたタグは、主要なキーが時間の経過とともに変化した場合に、暗号化に使用されたキーを特定します。新しいキーへの移行中に使用されるため、メッセージを復号化する当事者は、データが古いキーまたは新しいキーで暗号化されたかどうかを知ることができます。"
    },
    {
      "indent": 3,
      "text": "Plaintext The input to an encryption function or the output of a decryption function. Decryption transforms ciphertext into plaintext.",
      "ja": "暗号化関数への入力または復号化関数の出力をプレーンテキストします。復号化は、暗号文化をPlantextに変換します。"
    },
    {
      "indent": 3,
      "text": "Principal A named client or server entity that participates in a network communication, with one name that is considered canonical.",
      "ja": "ネットワーク通信に参加する名前付きクライアントまたはサーバーエンティティ。1つの名前は正規と見なされます。"
    },
    {
      "indent": 3,
      "text": "Principal identifier The canonical name used to identify each different principal uniquely.",
      "ja": "プリンシパル識別子異なる各プリンシパルを一意に識別するために使用される正規名。"
    },
    {
      "indent": 3,
      "text": "Seal To encipher a record containing several fields in such a way that the fields cannot be individually replaced without knowledge of the encryption key or leaving evidence of tampering.",
      "ja": "暗号化キーの知識や改ざんの証拠を残すことなく、フィールドを個別に置き換えることができないように、いくつかのフィールドを含むレコードを含むレコードを取り付けるためのシール。"
    },
    {
      "indent": 3,
      "text": "Secret key An encryption key shared by a principal and the KDC, distributed outside the bounds of the system, with a long lifetime. In the case of a human user's principal, the secret key MAY be derived from a password.",
      "ja": "Secret KeyプリンシパルとKDCが共有する暗号化キーは、システムの境界の外に分配され、長い寿命で分散されています。人間のユーザーの校長の場合、シークレットキーはパスワードから派生する場合があります。"
    },
    {
      "indent": 3,
      "text": "Server A particular Principal that provides a resource to network clients. The server is sometimes referred to as the Application Server.",
      "ja": "サーバーネットワーククライアントにリソースを提供する特定のプリンシパル。サーバーは、アプリケーションサーバーと呼ばれることがあります。"
    },
    {
      "indent": 3,
      "text": "Service A resource provided to network clients; often provided by more than one server (for example, remote file service).",
      "ja": "ネットワーククライアントに提供されるリソースをサービス。多くの場合、複数のサーバー（リモートファイルサービスなど）によって提供されます。"
    },
    {
      "indent": 3,
      "text": "Session key A temporary encryption key used between two principals, with a lifetime limited to the duration of a single login \"session\". In the Kerberos system, a session key is generated by the KDC. The session key is distinct from the sub-session key, described next.",
      "ja": "セッションキー2つのプリンシパル間で使用される一時的な暗号化キー。単一のログイン「セッション」の期間に限定されています。Kerberosシステムでは、セッションキーがKDCによって生成されます。セッションキーは、次に説明するサブセッションキーとは異なります。"
    },
    {
      "indent": 3,
      "text": "Sub-session key A temporary encryption key used between two principals, selected and exchanged by the principals using the session key, and with a lifetime limited to the duration of a single association. The sub-session key is also referred to as the subkey.",
      "ja": "サブセッションキー2つのプリンシパル間で使用される一時的な暗号化キーは、セッションキーを使用してプリンシパルによって選択および交換され、単一の関連付けの期間に制限されています。サブセッションキーは、サブキーとも呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Ticket A record that helps a client authenticate itself to a server; it contains the client's identity, a session key, a timestamp, and other information, all sealed using the server's secret key. It only serves to authenticate a client when presented along with a fresh Authenticator.",
      "ja": "チケットクライアントがサーバーに認証するのに役立つレコード。クライアントのID、セッションキー、タイムスタンプ、およびその他の情報が含まれており、すべてサーバーのシークレットキーを使用して封印されています。新鮮な認証者と一緒に提示された場合にのみ、クライアントを認証するのに役立ちます。"
    },
    {
      "indent": 0,
      "text": "2. Ticket Flag Uses and Requests",
      "section_title": true,
      "ja": "2. チケットフラグの使用とリクエスト"
    },
    {
      "indent": 3,
      "text": "Each Kerberos ticket contains a set of flags that are used to indicate attributes of that ticket. Most flags may be requested by a client when the ticket is obtained; some are automatically turned on and off by a Kerberos server as required. The following sections explain what the various flags mean and give examples of reasons to use them. With the exception of the INVALID flag, clients MUST ignore ticket flags that are not recognized. KDCs MUST ignore KDC options that are not recognized. Some implementations of RFC 1510 are known to reject unknown KDC options, so clients may need to resend a request without new KDC options if the request was rejected when sent with options added since RFC 1510. Because new KDCs will ignore unknown options, clients MUST confirm that the ticket returned by the KDC meets their needs.",
      "ja": "各Kerberosチケットには、そのチケットの属性を示すために使用されるフラグのセットが含まれています。チケットが取得されたとき、ほとんどのフラグはクライアントから要求される場合があります。必要に応じて、Kerberosサーバーによって自動的にオン /オフにされるものもあります。次のセクションでは、さまざまなフラグの意味を説明し、それらを使用する理由の例を示します。無効なフラグを除き、クライアントは認識されていないチケットフラグを無視する必要があります。KDCは、認識されていないKDCオプションを無視する必要があります。RFC 1510のいくつかの実装は不明なKDCオプションを拒否することが知られているため、RFC 1510以降に追加されたオプションで送信された場合にリクエストが拒否された場合、クライアントは新しいKDCオプションなしでリクエストを再送信する必要がある場合があります。新しいKDCは未知のオプションを無視するため、クライアントは確認する必要がありますKDCによって返されたチケットがニーズを満たしていること。"
    },
    {
      "indent": 3,
      "text": "Note that it is not, in general, possible to determine whether an option was not honored because it was not understood or because it was rejected through either configuration or policy. When adding a new option to the Kerberos protocol, designers should consider whether the distinction is important for their option. If it is, a mechanism for the KDC to return an indication that the option was understood but rejected needs to be provided in the specification of the option. Often in such cases, the mechanism needs to be broad enough to permit an error or reason to be returned.",
      "ja": "一般的に、オプションが理解されていないため、または構成またはポリシーのいずれかで拒否されたためにオプションが尊重されなかったかどうかを判断することはできないことに注意してください。Kerberosプロトコルに新しいオプションを追加する場合、設計者はそのオプションにとって区別が重要かどうかを検討する必要があります。もしそうなら、KDCがオプションが理解されたが拒否されたという兆候を返すメカニズムは、オプションの仕様で提供する必要があります。多くの場合、そのような場合、メカニズムはエラーや理由を返すのに十分な広さである必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Initial, Pre-authenticated, and Hardware-Authenticated Tickets",
      "section_title": true,
      "ja": "2.1. 初期、事前に、およびハードウェア認証型チケット"
    },
    {
      "indent": 3,
      "text": "The INITIAL flag indicates that a ticket was issued using the AS protocol, rather than issued based on a TGT. Application servers that want to require the demonstrated knowledge of a client's secret key (e.g., a password-changing program) can insist that this flag be set in any tickets they accept, and can thus be assured that the client's key was recently presented to the authentication server.",
      "ja": "最初のフラグは、TGTに基づいて発行されるのではなく、ASプロトコルを使用してチケットが発行されたことを示しています。クライアントの秘密鍵の実証された知識（パスワード変更プログラムなど）を要求したいアプリケーションサーバーは、このフラグを受け入れるチケットに設定することを主張することができ、したがって、クライアントのキーが最近提示されたことを保証できます。認証サーバー。"
    },
    {
      "indent": 3,
      "text": "The PRE-AUTHENT and HW-AUTHENT flags provide additional information about the initial authentication, regardless of whether the current ticket was issued directly (in which case INITIAL will also be set) or issued on the basis of a TGT (in which case the INITIAL flag is clear, but the PRE-AUTHENT and HW-AUTHENT flags are carried forward from the TGT).",
      "ja": "現在のチケットが直接発行されたか（この場合も設定される）か、TGTに基づいて発行されたかどうかに関係なく、事前にhw-authentのフラグは、初期認証に関する追加情報を提供します（この場合、初期の場合は最初のフラグは明確ですが、容認前とhWの告発フラグはTGTから繰り越されます）。"
    },
    {
      "indent": 0,
      "text": "2.2. Invalid Tickets",
      "section_title": true,
      "ja": "2.2. 無効なチケット"
    },
    {
      "indent": 3,
      "text": "The INVALID flag indicates that a ticket is invalid. Application servers MUST reject tickets that have this flag set. A postdated ticket will be issued in this form. Invalid tickets MUST be validated by the KDC before use, by being presented to the KDC in a TGS request with the VALIDATE option specified. The KDC will only validate tickets after their starttime has passed. The validation is required so that postdated tickets that have been stolen before their starttime can be rendered permanently invalid (through a hot-list mechanism) (see Section 3.3.3.1).",
      "ja": "無効なフラグは、チケットが無効であることを示します。アプリケーションサーバーは、このフラグがセットされたチケットを拒否する必要があります。この形式で郵便局面チケットが発行されます。無効なチケットは、指定された検証オプションを使用してTGSリクエストでKDCに提示されることにより、使用前にKDCによって検証する必要があります。KDCは、開始時刻が経過した後にのみチケットを検証します。検証は、開始時刻が永久に無効になる前に盗まれた郵便局面チケットを（ホットリストメカニズムを介して）レンダリングする必要があります（セクション3.3.3.1を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3. Renewable Tickets",
      "section_title": true,
      "ja": "2.3. 再生可能チケット"
    },
    {
      "indent": 3,
      "text": "Applications may desire to hold tickets that can be valid for long periods of time. However, this can expose their credentials to potential theft for equally long periods, and those stolen credentials would be valid until the expiration time of the ticket(s). Simply using short-lived tickets and obtaining new ones periodically would require the client to have long-term access to its secret key, an even greater risk. Renewable tickets can be used to mitigate the consequences of theft. Renewable tickets have two \"expiration times\": the first is when the current instance of the ticket expires, and the second is the latest permissible value for an individual expiration time. An application client must periodically (i.e., before it expires) present a renewable ticket to the KDC, with the RENEW option set in the KDC request. The KDC will issue a new ticket with a new session key and a later expiration time. All other fields of the ticket are left unmodified by the renewal process. When the latest permissible expiration time arrives, the ticket expires permanently. At each renewal, the KDC MAY consult a hot-list to determine whether the ticket had been reported stolen since its last renewal; it will refuse to renew stolen tickets, and thus the usable lifetime of stolen tickets is reduced.",
      "ja": "アプリケーションは、長期間有効なチケットを保持したい場合があります。ただし、これにより、資格情報を潜在的な盗難に等しく長期間さらす可能性があり、それらの盗まれた資格情報は、チケットの有効期限まで有効になります。単に短命のチケットを使用して定期的に新しいチケットを取得するには、クライアントがその秘密の鍵に長期的にアクセスできるようにする必要があります。これはさらに大きなリスクです。再生可能なチケットは、盗難の結果を軽減するために使用できます。再生可能なチケットには2つの「有効期限」があります。1つ目は、チケットの現在のインスタンスが期限切れになる場合、2つ目は個々の有効期限の最新の許容値です。アプリケーションクライアントは、定期的に（つまり、期限切れになる前に）KDCへの再生可能チケットを提示する必要があり、KDCリクエストに更新オプションが設定されています。KDCは、新しいセッションキーとその後の有効期限を備えた新しいチケットを発行します。チケットの他のすべてのフィールドは、更新プロセスによって修正されていません。最新の許容期限が到着すると、チケットは永久に期限切れになります。各更新時に、KDCはホットリストに相談して、チケットが最後の更新以来盗まれたかどうかを判断することができます。盗まれたチケットの更新を拒否するため、盗まれたチケットの使用可能な寿命が削減されます。"
    },
    {
      "indent": 3,
      "text": "The RENEWABLE flag in a ticket is normally only interpreted by the ticket-granting service (discussed below in Section 3.3). It can usually be ignored by application servers. However, some particularly careful application servers MAY disallow renewable tickets.",
      "ja": "チケットの再生可能フラグは、通常、チケット栽培サービスによってのみ解釈されます（以下ではセクション3.3で説明します）。通常、アプリケーションサーバーでは無視できます。ただし、特に慎重なアプリケーションサーバーが再生可能チケットを禁止する場合があります。"
    },
    {
      "indent": 3,
      "text": "If a renewable ticket is not renewed by its expiration time, the KDC will not renew the ticket. The RENEWABLE flag is reset by default, but a client MAY request it be set by setting the RENEWABLE option in the KRB_AS_REQ message. If it is set, then the renew-till field in the ticket contains the time after which the ticket may not be renewed.",
      "ja": "再生可能なチケットが有効期限までに更新されない場合、KDCはチケットを更新しません。再生可能フラグはデフォルトでリセットされますが、クライアントはKRB_AS_REQメッセージに再生可能オプションを設定することで設定することを要求できます。設定されている場合、チケットの更新フィールドには、チケットが更新されない時間が含まれています。"
    },
    {
      "indent": 0,
      "text": "2.4. Postdated Tickets",
      "section_title": true,
      "ja": "2.4. 郵便券"
    },
    {
      "indent": 3,
      "text": "Applications may occasionally need to obtain tickets for use much later; e.g., a batch submission system would need tickets to be valid at the time the batch job is serviced. However, it is dangerous to hold valid tickets in a batch queue, since they will be on-line longer and more prone to theft. Postdated tickets provide a way to obtain these tickets from the KDC at job submission time, but to leave them \"dormant\" until they are activated and validated by a further request of the KDC. If a ticket theft were reported in the interim, the KDC would refuse to validate the ticket, and the thief would be foiled.",
      "ja": "アプリケーションは、後で使用するためのチケットを入手する必要がある場合があります。たとえば、バッチ提出システムでは、バッチジョブが修理された時点でチケットを有効にする必要があります。ただし、バッチキューに有効なチケットを保持することは危険です。なぜなら、それらはより長く、より盗難に陥りやすいからです。郵便局面チケットは、求人時間にKDCからこれらのチケットを入手する方法を提供しますが、KDCのさらなる要求によってアクティブ化および検証されるまで「休眠」したままにします。暫定的にチケットの盗難が報告された場合、KDCはチケットの検証を拒否し、泥棒は失敗します。"
    },
    {
      "indent": 3,
      "text": "The MAY-POSTDATE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. This flag MUST be set in a TGT in order to issue a postdated ticket based on the presented ticket. It is reset by default; a client MAY request it by setting the ALLOW-POSTDATE option in the KRB_AS_REQ message. This flag does not allow a client to obtain a postdated TGT; postdated TGTs can only be obtained by requesting the postdating in the KRB_AS_REQ message. The life (endtime-starttime) of a postdated ticket will be the remaining life of the TGT at the time of the request, unless the RENEWABLE option is also set, in which case it can be the full life (endtime-starttime) of the TGT. The KDC MAY limit how far in the future a ticket may be postdated.",
      "ja": "チケットの5月のフラグは、通常、チケット栽培サービスによってのみ解釈されます。アプリケーションサーバーでは無視できます。このフラグは、提示されたチケットに基づいて延期されたチケットを発行するためにTGTに設定する必要があります。デフォルトでリセットされます。クライアントは、KRB_AS_REQメッセージにAllow-PostDateオプションを設定してそれを要求できます。このフラグでは、クライアントが郵便局のTGTを取得することはできません。郵便延期されたTGTは、KRB_AS_REQメッセージのポストデートを要求することによってのみ取得できます。再生可能なオプションも設定されていない限り、リクエスト時のTGTの残りの寿命は、郵便局のチケットの寿命（終了時間）は、リクエスト時のTGTの残りの寿命になります。ターゲット。KDCは、将来チケットがどの程度延期されるかを制限する場合があります。"
    },
    {
      "indent": 3,
      "text": "The POSTDATED flag indicates that a ticket has been postdated. The application server can check the authtime field in the ticket to see when the original authentication occurred. Some services MAY choose to reject postdated tickets, or they may only accept them within a certain period after the original authentication. When the KDC issues a POSTDATED ticket, it will also be marked as INVALID, so that the application client MUST present the ticket to the KDC to be validated before use.",
      "ja": "郵便局は、チケットが延期されたことを示しています。アプリケーションサーバーは、チケットのAuthTimeフィールドをチェックして、元の認証がいつ発生したかを確認できます。一部のサービスは、郵便局面チケットを拒否することを選択する場合があります。または、元の認証後の特定の期間以内にのみ受け入れる場合があります。KDCが延期されたチケットを発行すると、アプリケーションクライアントが使用する前に検証されるためにKDCにチケットを提示する必要があるため、KDCが延期されたチケットを発行する場合もあります。"
    },
    {
      "indent": 0,
      "text": "2.5. Proxiable and Proxy Tickets",
      "section_title": true,
      "ja": "2.5. プロキシ可能なチケットと代理チケット"
    },
    {
      "indent": 3,
      "text": "At times it may be necessary for a principal to allow a service to perform an operation on its behalf. The service must be able to take on the identity of the client, but only for a particular purpose. A principal can allow a service to do this by granting it a proxy.",
      "ja": "プリンシパルがサービスに代わって操作を実行できるようにすることが必要になる場合があります。サービスは、クライアントの身元を引き受けることができなければなりませんが、特定の目的のためだけです。プリンシパルは、プロキシを付与することにより、サービスがこれを行うことができます。"
    },
    {
      "indent": 3,
      "text": "The process of granting a proxy by using the proxy and proxiable flags is used to provide credentials for use with specific services. Though conceptually also a proxy, users wishing to delegate their identity in a form usable for all purposes MUST use the ticket forwarding mechanism described in the next section to forward a TGT.",
      "ja": "プロキシと委任状のフラグを使用してプロキシを付与するプロセスは、特定のサービスで使用する資格情報を提供するために使用されます。概念的にはプロキシでもありますが、すべての目的で使用可能な形式で身元を委任したいユーザーは、次のセクションで説明したチケット転送メカニズムを使用してTGTを転送する必要があります。"
    },
    {
      "indent": 3,
      "text": "The PROXIABLE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. When set, this flag tells the ticket-granting server that it is OK to issue a new ticket (but not a TGT) with a different network address based on this ticket. This flag is set if requested by the client on initial authentication. By default, the client will request that it be set when requesting a TGT, and that it be reset when requesting any other ticket.",
      "ja": "チケットのプロキシ可能なフラグは、通常、チケット栽培サービスによってのみ解釈されます。アプリケーションサーバーでは無視できます。設定すると、このフラグは、このチケットに基づいて別のネットワークアドレスを備えた新しいチケット（TGTではなく）を発行しても問題ないことをチケット栽培サーバーに伝えます。このフラグは、最初の認証でクライアントが要求する場合に設定されます。デフォルトでは、クライアントはTGTを要求するときに設定され、他のチケットを要求するときにリセットされることを要求します。"
    },
    {
      "indent": 3,
      "text": "This flag allows a client to pass a proxy to a server to perform a remote request on its behalf (e.g., a print service client can give the print server a proxy to access the client's files on a particular file server in order to satisfy a print request).",
      "ja": "このフラグを使用すると、クライアントはサーバーにプロキシを渡すことができます。たとえば、印刷サービスクライアントは、印刷サーバーに、印刷を満たすために特定のファイルサーバー上のクライアントのファイルにアクセスするためのプロキシを提供できます。リクエスト）。"
    },
    {
      "indent": 3,
      "text": "In order to complicate the use of stolen credentials, Kerberos tickets are often valid only from those network addresses specifically included in the ticket, but it is permissible as a policy option to allow requests and to issue tickets with no network addresses specified. When granting a proxy, the client MUST specify the new network address from which the proxy is to be used or indicate that the proxy is to be issued for use from any address.",
      "ja": "盗まれた資格情報の使用を複雑にするために、Kerberosのチケットは多くの場合、チケットに特に含まれるネットワークアドレスからのみ有効ですが、リクエストを許可し、ネットワークアドレスを指定しないチケットを発行するポリシーオプションとして許可されます。プロキシを付与する場合、クライアントはプロキシを使用する新しいネットワークアドレスを指定するか、任意のアドレスから使用するためにプロキシが発行されることを示す必要があります。"
    },
    {
      "indent": 3,
      "text": "The PROXY flag is set in a ticket by the TGS when it issues a proxy ticket. Application servers MAY check this flag; and at their option they MAY require additional authentication from the agent presenting the proxy in order to provide an audit trail.",
      "ja": "プロキシフラグは、TGSがプロキシチケットを発行したときにチケットに設定されます。アプリケーションサーバーはこのフラグを確認できます。また、オプションでは、監査証跡を提供するためにプロキシを提示するエージェントからの追加認証が必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "2.6. Forwardable Tickets",
      "section_title": true,
      "ja": "2.6. フォワード可能なチケット"
    },
    {
      "indent": 3,
      "text": "Authentication forwarding is an instance of a proxy where the service that is granted is complete use of the client's identity. An example of where it might be used is when a user logs in to a remote system and wants authentication to work from that system as if the login were local.",
      "ja": "認証転送は、許可されているサービスがクライアントの身元を完全に使用するプロキシのインスタンスです。使用できる場所の例は、ユーザーがリモートシステムにログインし、ログインがローカルであるかのように認証がそのシステムから動作することを望んでいる場合です。"
    },
    {
      "indent": 3,
      "text": "The FORWARDABLE flag in a ticket is normally only interpreted by the ticket-granting service. It can be ignored by application servers. The FORWARDABLE flag has an interpretation similar to that of the PROXIABLE flag, except TGTs may also be issued with different network addresses. This flag is reset by default, but users MAY request that it be set by setting the FORWARDABLE option in the AS request when they request their initial TGT.",
      "ja": "チケット内のフォワーダブルフラグは、通常、チケット栽培サービスによってのみ解釈されます。アプリケーションサーバーでは無視できます。転送可能なフラグには、TGTSが異なるネットワークアドレスで発行される場合を除き、プロキシ可能なフラグと同様の解釈があります。このフラグはデフォルトでリセットされますが、ユーザーは、最初のTGTを要求したときにASリクエストにフォローダブルオプションを設定して設定することを要求する場合があります。"
    },
    {
      "indent": 3,
      "text": "This flag allows for authentication forwarding without requiring the user to enter a password again. If the flag is not set, then authentication forwarding is not permitted, but the same result can still be achieved if the user engages in the AS exchange, specifies the requested network addresses, and supplies a password.",
      "ja": "このフラグにより、ユーザーがパスワードを再度入力することなく、認証転送が可能になります。フラグが設定されていない場合、認証転送は許可されませんが、ユーザーがAS Exchangeに従事し、要求されたネットワークアドレスを指定し、パスワードを提供する場合、同じ結果を達成できます。"
    },
    {
      "indent": 3,
      "text": "The FORWARDED flag is set by the TGS when a client presents a ticket with the FORWARDABLE flag set and requests a forwarded ticket by specifying the FORWARDED KDC option and supplying a set of addresses for the new ticket. It is also set in all tickets issued based on tickets with the FORWARDED flag set. Application servers may choose to process FORWARDED tickets differently than non-FORWARDED tickets.",
      "ja": "転送されたフラグは、クライアントが転送可能なフラグセットを備えたチケットを提示し、転送されたKDCオプションを指定し、新しいチケットのアドレスのセットを提供することにより、転送されたチケットを要求するときにTGSによって設定されます。また、転送されたフラグセットのあるチケットに基づいて発行されたすべてのチケットに設定されています。アプリケーションサーバーは、転送されていないチケットを不適当なチケットとは異なる方法で処理することを選択できます。"
    },
    {
      "indent": 3,
      "text": "If addressless tickets are forwarded from one system to another, clients SHOULD still use this option to obtain a new TGT in order to have different session keys on the different systems.",
      "ja": "アドレスレスチケットがあるシステムから別のシステムに転送されている場合、クライアントはこのオプションを使用して新しいTGTを取得して、異なるシステムに異なるセッションキーを作成する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.7. Transited Policy Checking",
      "section_title": true,
      "ja": "2.7. 輸送されたポリシーチェック"
    },
    {
      "indent": 3,
      "text": "In Kerberos, the application server is ultimately responsible for accepting or rejecting authentication, and it SHOULD check that only suitably trusted KDCs are relied upon to authenticate a principal. The transited field in the ticket identifies which realms (and thus which KDCs) were involved in the authentication process, and an application server would normally check this field. If any of these are untrusted to authenticate the indicated client principal (probably determined by a realm-based policy), the authentication attempt MUST be rejected. The presence of trusted KDCs in this list does not provide any guarantee; an untrusted KDC may have fabricated the list.",
      "ja": "Kerberosでは、アプリケーションサーバーは最終的に認証の受け入れまたは拒否を担当し、適切に信頼できるKDCのみが元本を認証するために依存していることを確認する必要があります。チケットの通過フィールドは、どのレルム（したがってどのKDC）が認証プロセスに関与していたかを特定し、アプリケーションサーバーは通常このフィールドをチェックします。これらのいずれかが、指定されたクライアントプリンシパルを認証するために信頼されていない場合（おそらくレルムベースのポリシーによって決定される）、認証試行を拒否する必要があります。このリストに信頼できるKDCの存在は、保証を提供しません。信頼されていないKDCがリストを作成した可能性があります。"
    },
    {
      "indent": 3,
      "text": "Although the end server ultimately decides whether authentication is valid, the KDC for the end server's realm MAY apply a realm-specific policy for validating the transited field and accepting credentials for cross-realm authentication. When the KDC applies such checks and accepts such cross-realm authentication, it will set the TRANSITED-POLICY-CHECKED flag in the service tickets it issues based on the cross-realm TGT. A client MAY request that the KDCs not check the transited field by setting the DISABLE-TRANSITED-CHECK flag. KDCs are encouraged but not required to honor this flag.",
      "ja": "エンドサーバーは最終的に認証が有効かどうかを決定しますが、エンドサーバーの領域のKDCは、交通フィールドを検証し、クロスリアム認証の資格情報を受け入れるためのレルム固有のポリシーを適用する場合があります。KDCがそのようなチェックを適用し、そのようなクロスリアム認証を受け入れると、Cross-Realm TGTに基づいて問題のあるサービスチケットに通過するポリシーチェックフラグを設定します。クライアントは、KDCSが無効化された転換チェックフラグを設定して、通過フィールドをチェックしないように要求する場合があります。KDCは奨励されていますが、この旗を称えるために必要はありません。"
    },
    {
      "indent": 3,
      "text": "Application servers MUST either do the transited-realm checks themselves or reject cross-realm tickets without TRANSITED-POLICY-CHECKED set.",
      "ja": "アプリケーションサーバーは、Transited-RealMチェックを自分で行うか、Transited-Policyチェックセットなしでクロスリアムチケットを拒否する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.8. OK as Delegate",
      "section_title": true,
      "ja": "2.8. 委任としてわかりました"
    },
    {
      "indent": 3,
      "text": "For some applications, a client may need to delegate authority to a server to act on its behalf in contacting other services. This requires that the client forward credentials to an intermediate server. The ability for a client to obtain a service ticket to a server conveys no information to the client about whether the server should be trusted to accept delegated credentials. The OK-AS-DELEGATE provides a way for a KDC to communicate local realm policy to a client regarding whether an intermediate server is trusted to accept such credentials.",
      "ja": "一部のアプリケーションでは、クライアントが他のサービスに連絡する際に代わって行動するために、クライアントをサーバーに委任する必要がある場合があります。これには、クライアントが中間サーバーに資格情報を転送する必要があります。クライアントがサーバーへのサービスチケットを取得する機能は、委任された資格情報を受け入れるためにサーバーが信頼されるべきかどうかについて、クライアントに情報を伝えません。OK-AS-DELEGATEは、KDCが中間サーバーがそのような資格情報を受け入れると信頼されているかどうかについて、クライアントにローカルレルムポリシーをクライアントに伝える方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The copy of the ticket flags in the encrypted part of the KDC reply may have the OK-AS-DELEGATE flag set to indicate to the client that the server specified in the ticket has been determined by the policy of the realm to be a suitable recipient of delegation. A client can use the presence of this flag to help it decide whether to delegate credentials (grant either a proxy or a forwarded TGT) to this server. It is acceptable to ignore the value of this flag. When setting this flag, an administrator should consider the security and placement of the server on which the service will run, as well as whether the service requires the use of delegated credentials.",
      "ja": "KDC応答の暗号化された部分のチケットフラグのコピーには、チケットで指定されたサーバーが適切な受信者であると領域のポリシーによって決定されていることをクライアントに示すように設定されるように設定されている場合があります。委任。クライアントは、このフラグの存在を使用して、このサーバーに資格情報（プロキシまたは転送されたTGTのいずれかを付与）を委任するかどうかを決定するのに役立ちます。このフラグの価値を無視することは受け入れられます。このフラグを設定するとき、管理者は、サービスが実行されるサーバーのセキュリティと配置、およびサービスが委任された資格情報の使用を必要とするかどうかを考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.9. Other KDC Options",
      "section_title": true,
      "ja": "2.9. その他のKDCオプション"
    },
    {
      "indent": 3,
      "text": "There are three additional options that MAY be set in a client's request of the KDC.",
      "ja": "KDCのクライアントの要求に設定される可能性のある3つの追加オプションがあります。"
    },
    {
      "indent": 0,
      "text": "2.9.1. Renewable-OK",
      "section_title": true,
      "ja": "2.9.1. 再生可能可能"
    },
    {
      "indent": 3,
      "text": "The RENEWABLE-OK option indicates that the client will accept a renewable ticket if a ticket with the requested life cannot otherwise be provided. If a ticket with the requested life cannot be provided, then the KDC MAY issue a renewable ticket with a renew-till equal to the requested endtime. The value of the renew-till field MAY still be adjusted by site-determined limits or limits imposed by the individual principal or server.",
      "ja": "再生可能可能なOKオプションは、要求された寿命のあるチケットが提供されない場合、クライアントが再生可能チケットを受け入れることを示します。要求された寿命を備えたチケットを提供できない場合、KDCは要求されたエンドタイムに等しい更新のある再生可能チケットを発行する場合があります。更新フィールドの値は、個々のプリンシパルまたはサーバーによって課されるサイトで決定された制限または制限によって調整される場合があります。"
    },
    {
      "indent": 0,
      "text": "2.9.2. ENC-TKT-IN-SKEY",
      "section_title": true,
      "ja": "2.9.2. enc-tkt-in-skey"
    },
    {
      "indent": 3,
      "text": "In its basic form, the Kerberos protocol supports authentication in a client-server setting and is not well suited to authentication in a peer-to-peer environment because the long-term key of the user does not remain on the workstation after initial login. Authentication of such peers may be supported by Kerberos in its user-to-user variant. The ENC-TKT-IN-SKEY option supports user-to-user authentication by allowing the KDC to issue a service ticket encrypted using the session key from another TGT issued to another user. The ENC-TKT-IN-SKEY option is honored only by the ticket-granting service. It indicates that the ticket to be issued for the end server is to be encrypted in the session key from the additional second TGT provided with the request. See Section 3.3.3 for specific details.",
      "ja": "基本的な形式では、Kerberosプロトコルはクライアントサーバーの設定で認証をサポートしており、ユーザーの長期キーが最初のログイン後にワークステーションに残っていないため、ピアツーピア環境での認証にはあまり適していません。このようなピアの認証は、ユーザーからユーザーへのバリアントでKerberosによってサポートされる場合があります。Enc-TKT-in-Skeyオプションは、KDCが別のユーザーに発行された別のTGTからセッションキーを使用して暗号化されたサービスチケットを発行できるようにすることにより、ユーザーからユーザーへの認証をサポートします。ENC-TKT-IN-SKEYオプションは、チケット栽培サービスによってのみ表彰されます。これは、エンドサーバーに発行されるチケットが、リクエストに提供された追加の2番目のTGTのセッションキーで暗号化されることを示しています。特定の詳細については、セクション3.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.9.3. Passwordless Hardware Authentication",
      "section_title": true,
      "ja": "2.9.3. パスワードレスハードウェア認証"
    },
    {
      "indent": 3,
      "text": "The OPT-HARDWARE-AUTH option indicates that the client wishes to use some form of hardware authentication instead of or in addition to the client's password or other long-lived encryption key. OPT-HARDWARE-AUTH is honored only by the authentication service. If supported and allowed by policy, the KDC will return an error code of KDC_ERR_PREAUTH_REQUIRED and include the required METHOD-DATA to perform such authentication.",
      "ja": "Opt-Hardware-Authオプションは、クライアントのパスワードまたはその他の長寿命の暗号化キーではなく、またはその他の長寿命の暗号化キーではなく、何らかの形のハードウェア認証を使用したいことを示しています。Opt-Hardware-Authは、認証サービスによってのみ表彰されます。ポリシーでサポートおよび許可された場合、KDCはKDC_ERR_PREAUTH_REQUIREDのエラーコードを返し、そのような認証を実行するために必要なメソッドデータを含めます。"
    },
    {
      "indent": 0,
      "text": "3. Message Exchanges",
      "section_title": true,
      "ja": "3. メッセージ交換"
    },
    {
      "indent": 3,
      "text": "The following sections describe the interactions between network clients and servers and the messages involved in those exchanges.",
      "ja": "次のセクションでは、ネットワーククライアントとサーバー間の相互作用と、それらの交換に関連するメッセージについて説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. The Authentication Service Exchange",
      "section_title": true,
      "ja": "3.1. 認証サービス交換"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "Message direction Message type Section 1. Client to Kerberos KRB_AS_REQ 5.4.1 2. Kerberos to client KRB_AS_REP or 5.4.2 KRB_ERROR 5.9.1",
      "ja": "メッセージ方向メッセージタイプタイプセクション1. Kerberos KRB_AS_REQ 5.4.1へのクライアント2. KerberosからクライアントKRB_AS_REPまたは5.4.2 KRB_ERROR 5.9.1"
    },
    {
      "indent": 3,
      "text": "The Authentication Service (AS) Exchange between the client and the Kerberos Authentication Server is initiated by a client when it wishes to obtain authentication credentials for a given server but currently holds no credentials. In its basic form, the client's secret key is used for encryption and decryption. This exchange is typically used at the initiation of a login session to obtain credentials for a Ticket-Granting Server, which will subsequently be used to obtain credentials for other servers (see Section 3.3) without requiring further use of the client's secret key. This exchange is also used to request credentials for services that must not be mediated through the Ticket-Granting Service, but rather require knowledge of a principal's secret key, such as the password-changing service (the password-changing service denies requests unless the requester can demonstrate knowledge of the user's old password; requiring this knowledge prevents unauthorized password changes by someone walking up to an unattended session).",
      "ja": "クライアントとKerberos認証サーバーとの間の認証サービス（AS）交換は、特定のサーバーの認証資格情報を取得したいが、現在は資格情報を保持していないときにクライアントによって開始されます。基本的な形式では、クライアントのシークレットキーは暗号化と復号化に使用されます。この交換は通常、ログインセッションの開始時に使用され、チケット栽培サーバーの資格情報を取得します。これは、クライアントのシークレットキーをさらに使用することなく、他のサーバーの資格情報を取得するために使用されます（セクション3.3を参照）。また、この交換は、チケット栽培サービスを通じて媒介してはならないサービスの資格情報を要求するためにも使用されますが、パスワードを変更するサービスなどのプリンシパルの秘密キーの知識が必要です（パスワードを変更するサービスは、リクエスターがいない限りリクエストを拒否します。ユーザーの古いパスワードに関する知識を示すことができます。この知識を必要とすることで、無人セッションまで歩いて行く人による不正なパスワードの変更が妨げられます）。"
    },
    {
      "indent": 3,
      "text": "This exchange does not by itself provide any assurance of the identity of the user. To authenticate a user logging on to a local system, the credentials obtained in the AS exchange may first be used in a TGS exchange to obtain credentials for a local server; those credentials must then be verified by a local server through successful completion of the Client/Server exchange.",
      "ja": "この交換は、それ自体でユーザーの身元を保証するものではありません。ローカルシステムにログオンするユーザーを認証するために、AS Exchangeで取得した資格情報を最初にTGS Exchangeで使用して、ローカルサーバーの資格情報を取得できます。これらの資格情報は、クライアント/サーバー交換が正常に完了することにより、ローカルサーバーによって検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The AS exchange consists of two messages: KRB_AS_REQ from the client to Kerberos, and KRB_AS_REP or KRB_ERROR in reply. The formats for these messages are described in Sections 5.4.1, 5.4.2, and 5.9.1.",
      "ja": "AS Exchangeは、クライアントからKerberosへのKRB_AS_REQと、KRB_AS_REPまたはKRB_ERRORの2つのメッセージで構成されています。これらのメッセージの形式は、セクション5.4.1、5.4.2、および5.9.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "In the request, the client sends (in cleartext) its own identity and the identity of the server for which it is requesting credentials, other information about the credentials it is requesting, and a randomly generated nonce, which can be used to detect replays and to associate replies with the matching requests. This nonce MUST be generated randomly by the client and remembered for checking against the nonce in the expected reply. The response, KRB_AS_REP, contains a ticket for the client to present to the server, and a session key that will be shared by the client and the server. The session key and additional information are encrypted in the client's secret key. The encrypted part of the KRB_AS_REP message also contains the nonce that MUST be matched with the nonce from the KRB_AS_REQ message.",
      "ja": "リクエストでは、クライアントは（ClearTextで）資格情報を要求しているサーバーのアイデンティティ、要求している資格情報に関するその他の情報、およびリプレイとリプレイの検出に使用できるランダムに生成されたNONCEを送信します。返信を一致するリクエストと関連付ける。この非CEは、クライアントによってランダムに生成され、予想される返信でNonCEに対してチェックすることを覚えておく必要があります。応答であるKRB_AS_REPには、クライアントがサーバーに提示するチケットと、クライアントとサーバーが共有するセッションキーが含まれています。セッションキーと追加情報は、クライアントのシークレットキーで暗号化されています。KRB_AS_REPメッセージの暗号化された部分には、KRB_AS_REQメッセージのNONCEと一致する必要があるNONCEも含まれています。"
    },
    {
      "indent": 3,
      "text": "Without pre-authentication, the authentication server does not know whether the client is actually the principal named in the request. It simply sends a reply without knowing or caring whether they are the same. This is acceptable because nobody but the principal whose identity was given in the request will be able to use the reply. Its critical information is encrypted in that principal's key. However, an attacker can send a KRB_AS_REQ message to get known plaintext in order to attack the principal's key. Especially if the key is based on a password, this may create a security exposure. So the initial request supports an optional field that can be used to pass additional information that might be needed for the initial exchange. This field SHOULD be used for pre-authentication as described in sections 3.1.1 and 5.2.7.",
      "ja": "認証サーバーは、事前認証がなければ、クライアントが実際にリクエストで名前が付けられたプリンシパルであるかどうかを知りません。それは、それらが同じかどうかを知らずに返信するだけです。これは、リクエストで身元が与えられた校長以外の誰も返信を使用できるため、受け入れられます。その重要な情報は、その校長の鍵で暗号化されています。ただし、攻撃者はKRB_AS_REQメッセージを送信して、プリンシパルのキーを攻撃するために既知のプレーンテキストを取得できます。特にキーがパスワードに基づいている場合、これによりセキュリティ露出が生じる可能性があります。そのため、最初のリクエストは、最初の交換に必要な追加情報を渡すために使用できるオプションのフィールドをサポートします。このフィールドは、セクション3.1.1および5.2.7で説明されているように、事前認証に使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Various errors can occur; these are indicated by an error response (KRB_ERROR) instead of the KRB_AS_REP response. The error message is not encrypted. The KRB_ERROR message contains information that can be used to associate it with the message to which it replies. The contents of the KRB_ERROR message are not integrity-protected. As such, the client cannot detect replays, fabrications, or modifications. A solution to this problem will be included in a future version of the protocol.",
      "ja": "さまざまなエラーが発生する可能性があります。これらは、krb_as_rep応答の代わりにエラー応答（krb_error）で示されます。エラーメッセージは暗号化されていません。KRB_ERRORメッセージには、返信するメッセージに関連付けるために使用できる情報が含まれています。KRB_ERRORメッセージの内容は、整合性で保護されていません。そのため、クライアントはリプレイ、製造、または変更を検出できません。この問題の解決策は、プロトコルの将来のバージョンに含まれます。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Generation of KRB_AS_REQ Message",
      "section_title": true,
      "ja": "3.1.1. KRB_AS_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The client may specify a number of options in the initial request. Among these options are whether pre-authentication is to be performed; whether the requested ticket is to be renewable, proxiable, or forwardable; whether it should be postdated or allow postdating of derivative tickets; and whether a renewable ticket will be accepted in lieu of a non-renewable ticket if the requested ticket expiration date cannot be satisfied by a non-renewable ticket (due to configuration constraints).",
      "ja": "クライアントは、最初のリクエストで多くのオプションを指定する場合があります。これらのオプションの中には、事前認証が実行されるかどうかがあります。要求されたチケットが再生可能、プロキシ可能、またはフォワーダブルであるかどうか。郵便局を課すべきか、デリバティブチケットのポストデートを許可する必要があるかどうか。また、要求されたチケットの有効期限が再生不可能なチケットで満たされない場合、再生可能なチケットの代わりに再生可能チケットが受け入れられるかどうか（構成の制約により）。"
    },
    {
      "indent": 3,
      "text": "The client prepares the KRB_AS_REQ message and sends it to the KDC.",
      "ja": "クライアントはKRB_AS_REQメッセージを準備し、KDCに送信します。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Receipt of KRB_AS_REQ Message",
      "section_title": true,
      "ja": "3.1.2. KRB_AS_REQメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If all goes well, processing the KRB_AS_REQ message will result in the creation of a ticket for the client to present to the server. The format for the ticket is described in Section 5.3.",
      "ja": "すべてがうまくいけば、KRB_AS_REQメッセージを処理すると、クライアントがサーバーに提示するチケットが作成されます。チケットの形式については、セクション5.3で説明します。"
    },
    {
      "indent": 3,
      "text": "Because Kerberos can run over unreliable transports such as UDP, the KDC MUST be prepared to retransmit responses in case they are lost. If a KDC receives a request identical to one it has recently processed successfully, the KDC MUST respond with a KRB_AS_REP message rather than a replay error. In order to reduce ciphertext given to a potential attacker, KDCs MAY send the same response generated when the request was first handled. KDCs MUST obey this replay behavior even if the actual transport in use is reliable.",
      "ja": "KerberosはUDPなどの信頼性の低い輸送を走ることができるため、KDCが失われた場合に応答を再送信する準備をする必要があります。KDCが最近正常に処理されたリクエストを受け取った場合、KDCはリプレイエラーではなくKRB_AS_REPメッセージで応答する必要があります。潜在的な攻撃者に与えられた暗号文を減らすために、KDCSは、リクエストが最初に処理されたときに生成された同じ応答を送信することができます。KDCは、使用中の実際の輸送が信頼できる場合でも、このリプレイ動作に従わなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Generation of KRB_AS_REP Message",
      "section_title": true,
      "ja": "3.1.3. KRB_AS_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The authentication server looks up the client and server principals named in the KRB_AS_REQ in its database, extracting their respective keys. If the requested client principal named in the request is unknown because it doesn't exist in the KDC's principal database, then an error message with a KDC_ERR_C_PRINCIPAL_UNKNOWN is returned.",
      "ja": "認証サーバーは、データベースのKRB_AS_REQに名前が付けられたクライアントとサーバーのプリンシパルを検索し、それぞれのキーを抽出します。リクエストに名前が付けられた要求されたクライアントプリンシパルがKDCのプリンシパルデータベースに存在しないため不明である場合、KDC_ERR_C_PRINCIPAL_UNKNOWNを使用したエラーメッセージが返されます。"
    },
    {
      "indent": 3,
      "text": "If required to do so, the server pre-authenticates the request, and if the pre-authentication check fails, an error message with the code KDC_ERR_PREAUTH_FAILED is returned. If pre-authentication is required, but was not present in the request, an error message with the code KDC_ERR_PREAUTH_REQUIRED is returned, and a METHOD-DATA object will be stored in the e-data field of the KRB-ERROR message to specify which pre-authentication mechanisms are acceptable. Usually this will include PA-ETYPE-INFO and/or PA-ETYPE-INFO2 elements as described below. If the server cannot accommodate any encryption type requested by the client, an error message with code KDC_ERR_ETYPE_NOSUPP is returned. Otherwise, the KDC generates a 'random' session key, meaning that, among other things, it should be impossible to guess the next session key based on knowledge of past session keys. Although this can be achieved in a pseudo-random number generator if it is based on cryptographic principles, it is more desirable to use a truly random number generator, such as one based on measurements of random physical phenomena. See [RFC4086] for an in-depth discussion of randomness.",
      "ja": "そのために必要な場合、サーバーはリクエストを事前に認識し、認証前のチェックが失敗した場合、コードKDC_ERR_PREAUTH_FAILEDのエラーメッセージが返されます。事前認証が必要であるがリクエストに存在しなかった場合、コードKDC_ERR_PREAUTH_REQUIREDを含むエラーメッセージが返され、Method-DataオブジェクトがKRB-ERRORメッセージのe-DATAフィールドに保存され、どのPREを指定します - 認証メカニズムは許容されます。通常、これには、以下で説明するように、PA-ETYPE-INFOおよび/またはPA-ETYPE-INFO2要素が含まれます。サーバーがクライアントが要求した暗号化タイプに対応できない場合、コードKDC_ERR_ETYPE_NOSUPPを使用したエラーメッセージが返されます。それ以外の場合、KDCは「ランダム」セッションキーを生成します。つまり、とりわけ、過去のセッションキーの知識に基づいて次のセッションキーを推測することは不可能なはずです。これは、暗号化の原則に基づいている場合、擬似ランダム数ジェネレーターで達成できますが、ランダムな物理現象の測定に基づいたものなど、真に乱数ジェネレーターを使用することがより望ましいです。ランダム性の詳細な議論については、[RFC4086]を参照してください。"
    },
    {
      "indent": 3,
      "text": "In response to an AS request, if there are multiple encryption keys registered for a client in the Kerberos database, then the etype field from the AS request is used by the KDC to select the encryption method to be used to protect the encrypted part of the KRB_AS_REP message that is sent to the client. If there is more than one supported strong encryption type in the etype list, the KDC SHOULD use the first valid strong etype for which an encryption key is available.",
      "ja": "ASリクエストに応じて、Kerberosデータベース内のクライアントに登録されている複数の暗号化キーがある場合、ASリクエストからのETYPEフィールドは、KDCによって使用されて、暗号化メソッドを選択するために使用される暗号化メソッドを選択して、暗号化された部分を保護するために使用されます。クライアントに送信されるKRB_AS_REPメッセージ。Etypeリストにサポートされている強力な暗号化タイプが複数ある場合、KDCは暗号化キーが利用可能な最初の有効な強いEtypeを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "When the user's key is generated from a password or pass phrase, the string-to-key function for the particular encryption key type is used, as specified in [RFC3961]. The salt value and additional parameters for the string-to-key function have default values (specified by Section 4 and by the encryption mechanism specification, respectively) that may be overridden by pre-authentication data (PA-PW-SALT, PA-AFS3-SALT, PA-ETYPE-INFO, PA-ETYPE-INFO2, etc). Since the KDC is presumed to store a copy of the resulting key only, these values should not be changed for password-based keys except when changing the principal's key.",
      "ja": "ユーザーのキーがパスワードまたはパスフレーズから生成されると、[RFC3961]で指定されているように、特定の暗号化キータイプの文字列間関数が使用されます。文字列間関数の塩値と追加のパラメーターには、事前認証データ（PA-PW-SALT、PA-AFS3）によってオーバーライドされる可能性のあるデフォルト値（それぞれセクション4および暗号化メカニズム仕様によって指定）を持っています。-SALT、PA-ETYPE-INFO、PA-ETYPE-INFO2など）。KDCは、結果のキーのみのコピーを保存すると推定されるため、プリンシパルのキーを変更する場合を除き、これらの値をパスワードベースのキーに対して変更しないでください。"
    },
    {
      "indent": 3,
      "text": "When the AS server is to include pre-authentication data in a KRB-ERROR or in an AS-REP, it MUST use PA-ETYPE-INFO2, not PA-ETYPE-INFO, if the etype field of the client's AS-REQ lists at least one \"newer\" encryption type. Otherwise (when the etype field of the client's AS-REQ does not list any \"newer\" encryption types), it MUST send both PA-ETYPE-INFO2 and PA-ETYPE-INFO (both with an entry for each enctype). A \"newer\" enctype is any enctype first officially specified concurrently with or subsequent to the issue of this RFC. The enctypes DES, 3DES, or RC4 and any defined in [RFC1510] are not \"newer\" enctypes.",
      "ja": "ASサーバーがKRB-ERRORまたはAS-REPに事前認証データを含める場合、クライアントのAS-REQリストのETYPEフィールドの場合、PA-ETYPE-INFOではなくPA-ETYPE-INFO2を使用する必要があります少なくとも1つの「新しい」暗号化タイプ。それ以外の場合（クライアントのAS-REQのETYPEフィールドが「新しい」暗号化タイプをリストしない場合）、PA-ETYPE-INFO2とPA-ETYPE-INFOの両方を送信する必要があります（どちらも各ENCTYPEのエントリがあります）。「より新しい」enctypeは、このRFCの問題と同時に、またはその後に最初に正式に指定された任意のenctypeです。[rfc1510]で定義されている任意の任意の任意のenctypes des、3des、またはrc4は、「新しい」enctypesではありません。"
    },
    {
      "indent": 3,
      "text": "It is not possible to generate a user's key reliably given a pass phrase without contacting the KDC, since it will not be known whether alternate salt or parameter values are required.",
      "ja": "KDCに連絡せずにパスフレーズを確実に与えられるユーザーのキーを生成することはできません。これは、代替塩またはパラメーター値が必要かどうかはわからないためです。"
    },
    {
      "indent": 3,
      "text": "The KDC will attempt to assign the type of the random session key from the list of methods in the etype field. The KDC will select the appropriate type using the list of methods provided and information from the Kerberos database indicating acceptable encryption methods for the application server. The KDC will not issue tickets with a weak session key encryption type.",
      "ja": "KDCは、ETYPEフィールドのメソッドのリストからランダムセッションキーのタイプを割り当てようとします。KDCは、提供されたメソッドのリストと、アプリケーションサーバーの許容可能な暗号化方法を示すKerberosデータベースの情報を使用して、適切なタイプを選択します。KDCは、セッションキーの暗号化タイプが弱いチケットを発行しません。"
    },
    {
      "indent": 3,
      "text": "If the requested starttime is absent, indicates a time in the past, or is within the window of acceptable clock skew for the KDC and the POSTDATE option has not been specified, then the starttime of the ticket is set to the authentication server's current time. If it indicates a time in the future beyond the acceptable clock skew, but the POSTDATED option has not been specified, then the error KDC_ERR_CANNOT_POSTDATE is returned. Otherwise the requested starttime is checked against the policy of the local realm (the administrator might decide to prohibit certain types or ranges of postdated tickets), and if the ticket's starttime is acceptable, it is set as requested, and the INVALID flag is set in the new ticket. The postdated ticket MUST be validated before use by presenting it to the KDC after the starttime has been reached.",
      "ja": "要求された開始時刻が不在の場合、過去の時間を示している場合、またはKDCの許容時計スキューのウィンドウ内にある場合、ポストデートオプションが指定されていない場合、チケットの開始時刻は認証サーバーの現在の時刻に設定されます。許容されるクロックスキューを超えて将来の時間を示しているが、延期されたオプションが指定されていない場合、エラーKDC_ERR_CANNOT_POSTDATEが返されます。それ以外の場合は、要求された開始時刻がローカルの領域のポリシーに対してチェックされます（管理者は特定のタイプまたは郵便延期チケットの範囲を禁止することを決定する場合があります）。新しいチケット。開始時刻に到達した後にKDCに提示することにより、使用する前に、郵便局面チケットを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "The expiration time of the ticket will be set to the earlier of the requested endtime and a time determined by local policy, possibly by using realm- or principal-specific factors. For example, the expiration time MAY be set to the earliest of the following:",
      "ja": "チケットの有効期限は、要求されたエンドタイムの早い時期に設定され、おそらくレルムまたはプリンシパル固有の要因を使用することにより、ローカルポリシーによって決定される時間が設定されます。たとえば、有効期限は次のうち最も早く設定できます。"
    },
    {
      "indent": 6,
      "text": "* The expiration time (endtime) requested in the KRB_AS_REQ message.",
      "ja": "* krb_as_reqメッセージで要求された有効期限（終了時間）。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum allowable lifetime associated with the client principal from the authentication server's database.",
      "ja": "* チケットの開始時刻に加えて、認証サーバーのデータベースからクライアントプリンシパルに関連付けられた最大許容寿命。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum allowable lifetime associated with the server principal.",
      "ja": "* チケットの開始時刻に加えて、サーバープリンシパルに関連付けられた最大許容寿命。"
    },
    {
      "indent": 6,
      "text": "* The ticket's starttime plus the maximum lifetime set by the policy of the local realm.",
      "ja": "* チケットの開始時刻に加えて、地元の領域のポリシーによって設定された最大生涯になります。"
    },
    {
      "indent": 3,
      "text": "If the requested expiration time minus the starttime (as determined above) is less than a site-determined minimum lifetime, an error message with code KDC_ERR_NEVER_VALID is returned. If the requested expiration time for the ticket exceeds what was determined as above, and if the 'RENEWABLE-OK' option was requested, then the 'RENEWABLE' flag is set in the new ticket, and the renew-till value is set as if the 'RENEWABLE' option were requested (the field and option names are described fully in Section 5.4.1).",
      "ja": "要求された有効期限を差し引いた時間（上記で決定されたように）を差し引いて（上記のように）がサイトで決定された最低寿命よりも少ない場合、コードKDC_ERR_NEREVER_VALIDを使用したエラーメッセージが返されます。チケットの要求された有効期限が上記のように決定されたものを超え、「再生可能可能なOK」オプションが要求された場合、「更新可能」フラグが新しいチケットに設定され、更新値が設定されているかのように設定されています。「再生可能な」オプションが要求されました（フィールドとオプション名は、セクション5.4.1で完全に説明されています）。"
    },
    {
      "indent": 3,
      "text": "If the RENEWABLE option has been requested or if the RENEWABLE-OK option has been set and a renewable ticket is to be issued, then the renew-till field MAY be set to the earliest of:",
      "ja": "再生可能オプションが要求されている場合、または再生可能なOKオプションが設定され、再生可能なチケットが発行される場合、更新フィールドは以前に設定できます。"
    },
    {
      "indent": 6,
      "text": "* Its requested value.",
      "ja": "* その要求された価値。"
    },
    {
      "indent": 6,
      "text": "* The starttime of the ticket plus the minimum of the two maximum renewable lifetimes associated with the principals' database entries.",
      "ja": "* チケットの開始時刻と、プリンシパルのデータベースエントリに関連する2つの最大再生可能寿命の最小値。"
    },
    {
      "indent": 6,
      "text": "* The starttime of the ticket plus the maximum renewable lifetime set by the policy of the local realm.",
      "ja": "* チケットの開始時刻と、地元の領域のポリシーによって設定された最大再生可能な寿命。"
    },
    {
      "indent": 3,
      "text": "The flags field of the new ticket will have the following options set if they have been requested and if the policy of the local realm allows: FORWARDABLE, MAY-POSTDATE, POSTDATED, PROXIABLE, RENEWABLE. If the new ticket is postdated (the starttime is in the future), its INVALID flag will also be set.",
      "ja": "新しいチケットのフラグフィールドには、リクエストされた場合、およびローカルレルムのポリシーが許可されている場合、次のオプションが設定されます。新しいチケットが登録されている場合（開始時刻は将来）、その無効なフラグも設定されます。"
    },
    {
      "indent": 3,
      "text": "If all of the above succeed, the server will encrypt the ciphertext part of the ticket using the encryption key extracted from the server principal's record in the Kerberos database using the encryption type associated with the server principal's key. (This choice is NOT affected by the etype field in the request.) It then formats a KRB_AS_REP message (see Section 5.4.2), copying the addresses in the request into the caddr of the response, placing any required pre-authentication data into the padata of the response, and encrypts the ciphertext part in the client's key using an acceptable encryption method requested in the etype field of the request, or in some key specified by pre-authentication mechanisms being used.",
      "ja": "上記のすべてが成功した場合、サーバーは、サーバープリンシパルのキーに関連付けられた暗号化タイプを使用して、Kerberosデータベースのサーバープリンシパルのレコードから抽出された暗号化キーを使用して、チケットの暗号文化部を暗号化します。（この選択は、リクエストのETYPEフィールドの影響を受けません。）次に、KRB_AS_REPメッセージ（セクション5.4.2を参照）をフォーマットし、リクエストのアドレスを応答のCADDRにコピーし、必要な事前認証データを配置します。応答のPadataは、リクエストのETYPEフィールドで要求された許容可能な暗号化方法、または使用されている事前認証メカニズムによって指定されたいくつかのキーで、クライアントのキーの暗号文の部分を暗号化します。"
    },
    {
      "indent": 0,
      "text": "3.1.4. Generation of KRB_ERROR Message",
      "section_title": true,
      "ja": "3.1.4. KRB_ERRORメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Several errors can occur, and the Authentication Server responds by returning an error message, KRB_ERROR, to the client, with the error-code and e-text fields set to appropriate values. The error message contents and details are described in Section 5.9.1.",
      "ja": "いくつかのエラーが発生する可能性があり、認証サーバーは、エラーコードとeテキストフィールドを適切な値に設定して、エラーメッセージkrb_errorをクライアントに返すことで応答します。エラーメッセージの内容と詳細については、セクション5.9.1で説明します。"
    },
    {
      "indent": 0,
      "text": "3.1.5. Receipt of KRB_AS_REP Message",
      "section_title": true,
      "ja": "3.1.5. KRB_AS_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If the reply message type is KRB_AS_REP, then the client verifies that the cname and crealm fields in the cleartext portion of the reply match what it requested. If any padata fields are present, they may be used to derive the proper secret key to decrypt the message. The client decrypts the encrypted part of the response using its secret key and verifies that the nonce in the encrypted part matches the nonce it supplied in its request (to detect replays). It also verifies that the sname and srealm in the response match those in the request (or are otherwise expected values), and that the host address field is also correct. It then stores the ticket, session key, start and expiration times, and other information for later use. The last-req field (and the deprecated key-expiration field) from the encrypted part of the response MAY be checked to notify the user of impending key expiration. This enables the client program to suggest remedial action, such as a password change.",
      "ja": "返信メッセージタイプがkrb_as_repの場合、クライアントは、返信のクリアテキスト部分のcnameおよびcrealmフィールドが要求されたものと一致することを確認します。Padataフィールドが存在する場合、メッセージを復号化するための適切な秘密鍵を導き出すために使用される場合があります。クライアントは、そのシークレットキーを使用して応答の暗号化された部分を復号化し、暗号化された部分のNonCEがリクエストで提供されたNonCEと一致することを確認します（リプレイを検出するため）。また、応答のスナムとsRealmがリクエストのスナムと一致する（またはそうでなければ期待値）、ホストアドレスフィールドも正しいことを確認します。次に、チケット、セッションキー、開始時間、有効期限、その他の情報を後で使用するためのその他の情報を保存します。応答の暗号化された部分からの最後のREQフィールド（および非推奨のキーエクスポイアルフィールド）をチェックして、差し迫ったキーの有効期限をユーザーに通知することができます。これにより、クライアントプログラムは、パスワードの変更などの修復アクションを提案できます。"
    },
    {
      "indent": 3,
      "text": "Upon validation of the KRB_AS_REP message (by checking the returned nonce against that sent in the KRB_AS_REQ message), the client knows that the current time on the KDC is that read from the authtime field of the encrypted part of the reply. The client can optionally use this value for clock synchronization in subsequent messages by recording with the ticket the difference (offset) between the authtime value and the local clock. This offset can then be used by the same user to adjust the time read from the system clock when generating messages [DGT96].",
      "ja": "KRB_AS_REPメッセージを検証すると（KRB_AS_REQメッセージで送信されたものに対して返されたノンセをチェックすることにより）、クライアントはKDCの現在の時刻は、応答の暗号化された部分の認証フィールドから読み取られていることを知っています。クライアントは、チケットでAuthTime値とローカルクロックの間の違い（オフセット）を記録することにより、後続のメッセージでクロック同期にこの値をオプションで使用できます。このオフセットは、同じユーザーがメッセージを生成するときにシステムクロックから読み取り時間を調整するために使用できます[DGT96]。"
    },
    {
      "indent": 3,
      "text": "This technique MUST be used when adjusting for clock skew instead of directly changing the system clock, because the KDC reply is only authenticated to the user whose secret key was used, but not to the system or workstation. If the clock were adjusted, an attacker colluding with a user logging into a workstation could agree on a password, resulting in a KDC reply that would be correctly validated even though it did not originate from a KDC trusted by the workstation.",
      "ja": "KDCの返信は、システムやワークステーションには使用ではなく、秘密キーが使用されていないユーザーにのみ認証されるため、この手法は、システムクロックを直接変更する代わりにクロックスキューを調整するときに使用する必要があります。クロックが調整された場合、ワークステーションにログインするユーザーと共謀する攻撃者は、パスワードに同意する可能性があり、その結果、ワークステーションから信頼されているKDCから発生していなくても、正しく検証されるKDCの返信が得られます。"
    },
    {
      "indent": 3,
      "text": "Proper decryption of the KRB_AS_REP message is not sufficient for the host to verify the identity of the user; the user and an attacker could cooperate to generate a KRB_AS_REP format message that decrypts properly but is not from the proper KDC. If the host wishes to verify the identity of the user, it MUST require the user to present application credentials that can be verified using a securely-stored secret key for the host. If those credentials can be verified, then the identity of the user can be assured.",
      "ja": "KRB_AS_REPメッセージの適切な復号化は、ホストがユーザーの身元を確認するには十分ではありません。ユーザーと攻撃者は協力して、適切に復号化するが適切なKDCからではないKRB_AS_REP形式のメッセージを生成することができます。ホストがユーザーの身元を確認したい場合、ユーザーは、ホストの安全に保存されたシークレットキーを使用して検証できるアプリケーション資格情報を提示する必要があります。これらの資格情報を検証できる場合、ユーザーの身元を保証できます。"
    },
    {
      "indent": 0,
      "text": "3.1.6. Receipt of KRB_ERROR Message",
      "section_title": true,
      "ja": "3.1.6. krb_errorメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If the reply message type is KRB_ERROR, then the client interprets it as an error and performs whatever application-specific tasks are necessary for recovery.",
      "ja": "返信メッセージタイプがKRB_ERRORの場合、クライアントはそれをエラーとして解釈し、回復に必要なアプリケーション固有のタスクを実行します。"
    },
    {
      "indent": 0,
      "text": "3.2. The Client/Server Authentication Exchange",
      "section_title": true,
      "ja": "3.2. クライアント/サーバー認証交換"
    },
    {
      "indent": 32,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Message direction                         Message type    Section\nClient to Application server              KRB_AP_REQ      5.5.1\n[optional] Application server to client   KRB_AP_REP or   5.5.2\n                                          KRB_ERROR       5.9.1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client/server authentication (CS) exchange is used by network applications to authenticate the client to the server and vice versa. The client MUST have already acquired credentials for the server using the AS or TGS exchange.",
      "ja": "クライアント/サーバー認証（CS）交換は、ネットワークアプリケーションで使用され、クライアントをサーバーに認証し、その逆も同様です。クライアントは、ASまたはTGS Exchangeを使用してサーバーの資格情報をすでに取得している必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. The KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.1. KRB_AP_REQメッセージ"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REQ contains authentication information that SHOULD be part of the first message in an authenticated transaction. It contains a ticket, an authenticator, and some additional bookkeeping information (see Section 5.5.1 for the exact format). The ticket by itself is insufficient to authenticate a client, since tickets are passed across the network in cleartext (tickets contain both an encrypted and unencrypted portion, so cleartext here refers to the entire unit, which can be copied from one message and replayed in another without any cryptographic skill). The authenticator is used to prevent invalid replay of tickets by proving to the server that the client knows the session key of the ticket and thus is entitled to use the ticket. The KRB_AP_REQ message is referred to elsewhere as the 'authentication header'.",
      "ja": "KRB_AP_REQには、認証されたトランザクションの最初のメッセージの一部である必要がある認証情報が含まれています。チケット、認証者、およびいくつかの追加の簿記情報が含まれています（正確な形式については、セクション5.5.1を参照）。チケットはクライアントを認証するには不十分です。チケットはクリアテキストでネットワーク全体に渡されるためです（チケットには暗号化された部分と暗号化されていない部分の両方が含まれているため、ここではユニット全体を指します。暗号化スキルなし）。Authenticatorは、クライアントがチケットのセッションキーを知っていることをサーバーに証明することにより、チケットの無効なリプレイを防ぐために使用され、したがってチケットを使用する権利があります。KRB_AP_REQメッセージは、他の場所で「認証ヘッダー」と呼ばれます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Generation of a KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.2. KRB_AP_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When a client wishes to initiate authentication to a server, it obtains (either through a credentials cache, the AS exchange, or the TGS exchange) a ticket and session key for the desired service. The client MAY re-use any tickets it holds until they expire. To use a ticket, the client constructs a new Authenticator from the system time and its name, and optionally from an application-specific checksum, an initial sequence number to be used in KRB_SAFE or KRB_PRIV messages, and/or a session subkey to be used in negotiations for a session key unique to this particular session. Authenticators MUST NOT be re-used and SHOULD be rejected if replayed to a server. Note that this can make applications based on unreliable transports difficult to code correctly. If the transport might deliver duplicated messages, either a new authenticator MUST be generated for each retry, or the application server MUST match requests and replies and replay the first reply in response to a detected duplicate.",
      "ja": "クライアントがサーバーへの認証を開始したい場合、目的のサービスのチケットとセッションキーを（資格情報、AS Exchange、またはTGS Exchange）を取得します。クライアントは、期限切れになるまで保持するチケットを再利用できます。チケットを使用するには、クライアントはシステム時間とその名前から新しい認証機を構築し、オプションではアプリケーション固有のチェックサム、krb_safeまたはkrb_privメッセージで使用する初期シーケンス番号、および/または使用するセッションサブキーを構築します。この特定のセッションに固有のセッションキーの交渉で。認証者は再利用されてはならず、サーバーに再生された場合は拒否される必要があります。これにより、信頼性の低いトランスポートに基づいたアプリケーションを正しくコーディングするのが難しくなることに注意してください。トランスポートが複製されたメッセージを配信する場合は、再試行ごとに新しい認証器を生成する必要があります。または、アプリケーションサーバーは、検出された複製に応じてリクエストと返信を一致させ、最初の返信を再生する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a sequence number is to be included, it SHOULD be randomly chosen so that even after many messages have been exchanged it is not likely to collide with other sequence numbers in use.",
      "ja": "シーケンス番号を含める場合、多くのメッセージが交換された後でも、使用中の他のシーケンス番号と衝突する可能性が低いように、ランダムに選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MAY indicate a requirement of mutual authentication or the use of a session-key based ticket (for user-to-user authentication, see section 3.7) by setting the appropriate flag(s) in the ap-options field of the message.",
      "ja": "クライアントは、メッセージのAPオプションフィールドに適切なフラグを設定することにより、相互認証の要件またはセッションキーベースのチケット（ユーザーからユーザーへの認証用、セクション3.7を参照）の使用を示している場合があります。"
    },
    {
      "indent": 3,
      "text": "The Authenticator is encrypted in the session key and combined with the ticket to form the KRB_AP_REQ message, which is then sent to the end server along with any additional application-specific information.",
      "ja": "Authenticatorはセッションキーで暗号化され、チケットと組み合わせてKRB_AP_REQメッセージを形成し、追加のアプリケーション固有の情報とともにエンドサーバーに送信されます。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Receipt of KRB_AP_REQ Message",
      "section_title": true,
      "ja": "3.2.3. krb_ap_reqメッセージの受領"
    },
    {
      "indent": 3,
      "text": "Authentication is based on the server's current time of day (clocks MUST be loosely synchronized), the authenticator, and the ticket. Several errors are possible. If an error occurs, the server is expected to reply to the client with a KRB_ERROR message. This message MAY be encapsulated in the application protocol if its raw form is not acceptable to the protocol. The format of error messages is described in Section 5.9.1.",
      "ja": "認証は、サーバーの現在の時刻（クロックはゆるく同期する必要がある）、認証機、およびチケットに基づいています。いくつかのエラーが可能です。エラーが発生した場合、サーバーはKRB_ERRORメッセージでクライアントに返信することが期待されます。このメッセージは、RAWフォームがプロトコルに受け入れられない場合、アプリケーションプロトコルにカプセル化される場合があります。エラーメッセージの形式は、セクション5.9.1で説明されています。"
    },
    {
      "indent": 3,
      "text": "The algorithm for verifying authentication information is as follows. If the message type is not KRB_AP_REQ, the server returns the KRB_AP_ERR_MSG_TYPE error. If the key version indicated by the Ticket in the KRB_AP_REQ is not one the server can use (e.g., it indicates an old key, and the server no longer possesses a copy of the old key), the KRB_AP_ERR_BADKEYVER error is returned. If the USE-SESSION-KEY flag is set in the ap-options field, it indicates to the server that user-to-user authentication is in use, and that the ticket is encrypted in the session key from the server's TGT rather than in the server's secret key. See Section 3.7 for a more complete description of the effect of user-to-user authentication on all messages in the Kerberos protocol.",
      "ja": "認証情報を検証するためのアルゴリズムは次のとおりです。メッセージタイプがkrb_ap_reqでない場合、サーバーはkrb_ap_err_msg_typeエラーを返します。KRB_AP_REQのチケットで示されたキーバージョンがサーバーが使用できるものではない場合（たとえば、古いキーを示し、サーバーはもはや古いキーのコピーを所有していません）、KRB_AP_ERR_BADKEYVERエラーが返されます。使用セッションキーフラグがAPオプションフィールドに設定されている場合、ユーザーからユーザーへの認証が使用されていること、およびチケットがサーバーのTGTからではなくサーバーのTGTから暗号化されていることをサーバーに示します。サーバーのシークレットキー。Kerberosプロトコル内のすべてのメッセージに対するユーザー間認証の効果のより完全な説明については、セクション3.7を参照してください。"
    },
    {
      "indent": 3,
      "text": "Because it is possible for the server to be registered in multiple realms, with different keys in each, the srealm field in the unencrypted portion of the ticket in the KRB_AP_REQ is used to specify which secret key the server should use to decrypt that ticket. The KRB_AP_ERR_NOKEY error code is returned if the server doesn't have the proper key to decipher the ticket.",
      "ja": "それぞれに異なるキーを持つ複数の領域でサーバーを登録することが可能であるため、KRB_AP_REQのチケットの暗号化されていない部分のSREALMフィールドは、サーバーがそのチケットを復号化するために使用する秘密キーを指定するために使用されます。サーバーにチケットを解読するための適切なキーがない場合、KRB_AP_ERR_NOKEYエラーコードが返されます。"
    },
    {
      "indent": 3,
      "text": "The ticket is decrypted using the version of the server's key specified by the ticket. If the decryption routines detect a modification of the ticket (each encryption system MUST provide safeguards to detect modified ciphertext), the KRB_AP_ERR_BAD_INTEGRITY error is returned (chances are good that different keys were used to encrypt and decrypt).",
      "ja": "チケットは、チケットで指定されたサーバーのキーのバージョンを使用して復号化されます。復号化ルーチンがチケットの変更を検出した場合（各暗号化システムは、修正された暗号文を検出するためのセーフガードを提供する必要があります）、krb_ap_err_bad_integrityエラーが返されます（異なるキーが暗号化と復号化に使用される可能性があります）。"
    },
    {
      "indent": 3,
      "text": "The authenticator is decrypted using the session key extracted from the decrypted ticket. If decryption shows that is has been modified, the KRB_AP_ERR_BAD_INTEGRITY error is returned. The name and realm of the client from the ticket are compared against the same fields in the authenticator. If they don't match, the KRB_AP_ERR_BADMATCH error is returned; normally this is caused by a client error or an attempted attack. The addresses in the ticket (if any) are then searched for an address matching the operating-system reported address of the client. If no match is found or the server insists on ticket addresses but none are present in the ticket, the KRB_AP_ERR_BADADDR error is returned. If the local (server) time and the client time in the authenticator differ by more than the allowable clock skew (e.g., 5 minutes), the KRB_AP_ERR_SKEW error is returned.",
      "ja": "Authenticatorは、復号化されたチケットから抽出されたセッションキーを使用して復号化されます。復号化が変更された場合、krb_ap_err_bad_integrityエラーが返されます。チケットのクライアントの名前と領域は、認証機の同じフィールドと比較されます。それらが一致しない場合、krb_ap_err_badmatchエラーが返されます。通常、これはクライアントエラーまたは攻撃の試みによって引き起こされます。チケットのアドレス（もしあれば）は、クライアントの操作システム報告アドレスに一致するアドレスを検索します。一致が見つからない場合、またはサーバーがチケットアドレスを主張するが、チケットに存在するものはない場合、krb_ap_err_badaddrエラーが返されます。Authenticatorのローカル（サーバー）の時間とクライアント時間が許容時計スキュー（5分など）よりも大きく異なる場合、KRB_AP_ERR_SKEWエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Unless the application server provides its own suitable means to protect against replay (for example, a challenge-response sequence initiated by the server after authentication, or use of a server-generated encryption subkey), the server MUST utilize a replay cache to remember any authenticator presented within the allowable clock skew. Careful analysis of the application protocol and implementation is recommended before eliminating this cache. The replay cache will store at least the server name, along with the client name, time, and microsecond fields from the recently-seen authenticators, and if a matching tuple is found, the KRB_AP_ERR_REPEAT error is returned. Note that the rejection here is restricted to authenticators from the same principal to the same server. Other client principals communicating with the same server principal should not have their authenticators rejected if the time and microsecond fields happen to match some other client's authenticator.",
      "ja": "アプリケーションサーバーがリプレイから保護するための独自の適切な手段を提供しない限り（たとえば、認証後にサーバーによって開始されたチャレンジ応答シーケンス、またはサーバー生成暗号化サブキーの使用）、サーバーはリプレイキャッシュを使用して任意のリプレイを使用する必要があります許容時計スキュー内で提示された認証器。このキャッシュを排除する前に、アプリケーションプロトコルと実装の慎重な分析をお勧めします。リプレイキャッシュは、少なくともサーバー名と、最近見られた認証器からのクライアント名、時間、およびマイクロ秒フィールドとともに保存され、一致するタプルが見つかった場合、KRB_AP_ERR_REPEATエラーが返されます。ここでの拒否は、同じプリンシパルから同じサーバーへの認証機に制限されていることに注意してください。同じサーバープリンシパルと通信する他のクライアントプリンシパルは、時間とマイクロ秒のフィールドがたまたま他のクライアントの認証器と一致する場合、認証機を拒否してはいけません。"
    },
    {
      "indent": 3,
      "text": "If a server loses track of authenticators presented within the allowable clock skew, it MUST reject all requests until the clock skew interval has passed, providing assurance that any lost or replayed authenticators will fall outside the allowable clock skew and can no longer be successfully replayed. If this were not done, an attacker could subvert the authentication by recording the ticket and authenticator sent over the network to a server and replaying them following an event that caused the server to lose track of recently seen authenticators.",
      "ja": "サーバーが許容時計スキュー内で提示された認証器のトラックを失った場合、クロックスキュー間隔が通過するまですべての要求を拒否する必要があり、失われたまたは再生された認証機が許容時計のゆがみの外に落ち、正常にリプレイできなくなることを保証します。これが完了していない場合、攻撃者は、ネットワークを介して送信されたチケットと認証機をサーバーに録音し、サーバーが最近見られた認証器の追跡を失うイベントに続いてそれらをリプレイすることにより、認証を破壊することができます。"
    },
    {
      "indent": 3,
      "text": "Implementation note: If a client generates multiple requests to the KDC with the same timestamp, including the microsecond field, all but the first of the requests received will be rejected as replays. This might happen, for example, if the resolution of the client's clock is too coarse. Client implementations SHOULD ensure that the timestamps are not reused, possibly by incrementing the microseconds field in the time stamp when the clock returns the same time for multiple requests.",
      "ja": "実装注：クライアントが、マイクロ秒フィールドを含む同じタイムスタンプでKDCに複数のリクエストを生成する場合、受信した最初のリクエストを除くすべてがリプレイとして拒否されます。これは、たとえば、クライアントのクロックの解像度が粗すぎる場合に発生する可能性があります。クライアントの実装では、複数のリクエストに対してクロックが同じ時間に戻ったときにタイムスタンプでマイクロ秒フィールドをインクリメントすることにより、タイムスタンプが再利用されないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple servers (for example, different services on one machine, or a single service implemented on multiple machines) share a service principal (a practice that we do not recommend in general, but that we acknowledge will be used in some cases), either they MUST share this replay cache, or the application protocol MUST be designed so as to eliminate the need for it. Note that this applies to all of the services. If any of the application protocols does not have replay protection built in, an authenticator used with such a service could later be replayed to a different service with the same service principal but no replay protection, if the former doesn't record the authenticator information in the common replay cache.",
      "ja": "複数のサーバー（たとえば、1つのマシンのさまざまなサービス、または複数のマシンに実装された単一のサービス）がサービスプリンシパル（一般的には推奨されないプラクティスであるが、場合によっては使用されることを認めます）を共有する場合、このリプレイキャッシュを共有する必要があります。そうしないと、アプリケーションプロトコルを設計する必要があります。これはすべてのサービスに適用されることに注意してください。アプリケーションプロトコルのいずれかにリプレイ保護が組み込まれていない場合、そのようなサービスで使用される認証器は、後で同じサービスプリンシパルを持つがリプレイ保護を持たない別のサービスにリプレイすることができます。一般的なリプレイキャッシュ。"
    },
    {
      "indent": 3,
      "text": "If a sequence number is provided in the authenticator, the server saves it for later use in processing KRB_SAFE and/or KRB_PRIV messages. If a subkey is present, the server either saves it for later use or uses it to help generate its own choice for a subkey to be returned in a KRB_AP_REP message.",
      "ja": "Authenticatorでシーケンス番号が提供されている場合、サーバーはkrb_safeおよび/またはkrb_privメッセージの処理において使用するために保存します。サブキーが存在する場合、サーバーは後で使用するために保存するか、それを使用して、krb_ap_repメッセージでサブキーを返すために独自の選択を生成します。"
    },
    {
      "indent": 3,
      "text": "The server computes the age of the ticket: local (server) time minus the starttime inside the Ticket. If the starttime is later than the current time by more than the allowable clock skew, or if the INVALID flag is set in the ticket, the KRB_AP_ERR_TKT_NYV error is returned. Otherwise, if the current time is later than end time by more than the allowable clock skew, the KRB_AP_ERR_TKT_EXPIRED error is returned.",
      "ja": "サーバーは、チケットの年齢を計算します：ローカル（サーバー）時間は、チケット内の開始時刻を差し引いています。開始時刻が許容時計のゆっくりを超えて現在よりも遅い場合、またはチケットに無効なフラグが設定されている場合、KRB_AP_ERR_TKT_NYVエラーが返されます。それ以外の場合、現在の時刻が許容時計のスキューを超えて終了時間より遅い場合、KRB_AP_ERR_TKT_EXPIREDエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If all these checks succeed without an error, the server is assured that the client possesses the credentials of the principal named in the ticket, and thus, that the client has been authenticated to the server.",
      "ja": "これらのすべてのチェックがエラーなしで成功した場合、サーバーは、クライアントがチケットに名前が付けられたプリンシパルの資格情報を所有しているため、クライアントがサーバーに認証されていることを保証します。"
    },
    {
      "indent": 3,
      "text": "Passing these checks provides only authentication of the named principal; it does not imply authorization to use the named service. Applications MUST make a separate authorization decision based upon the authenticated name of the user, the requested operation, local access control information such as that contained in a .k5login or .k5users file, and possibly a separate distributed authorization service.",
      "ja": "これらのチェックを渡すと、指名されたプリンシパルの認証のみが提供されます。指定されたサービスを使用する許可を意味するものではありません。アプリケーションは、ユーザーの認証された名前、要求された操作、.k5loginまたは.k5usersファイルに含まれるようなローカルアクセス制御情報、およびおそらく個別の分散承認サービスに基づいて、個別の承認決定を下す必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Generation of a KRB_AP_REP Message",
      "section_title": true,
      "ja": "3.2.4. KRB_AP_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Typically, a client's request will include both the authentication information and its initial request in the same message, and the server need not explicitly reply to the KRB_AP_REQ. However, if mutual authentication (authenticating not only the client to the server, but also the server to the client) is being performed, the KRB_AP_REQ message will have MUTUAL-REQUIRED set in its ap-options field, and a KRB_AP_REP message is required in response. As with the error message, this message MAY be encapsulated in the application protocol if its \"raw\" form is not acceptable to the application's protocol. The timestamp and microsecond field used in the reply MUST be the client's timestamp and microsecond field (as provided in the authenticator). If a sequence number is to be included, it SHOULD be randomly chosen as described above for the authenticator. A subkey MAY be included if the server desires to negotiate a different subkey. The KRB_AP_REP message is encrypted in the session key extracted from the ticket.",
      "ja": "通常、クライアントの要求には、同じメッセージに認証情報とその初期リクエストの両方が含まれ、サーバーはkrb_ap_reqに明示的に返信する必要はありません。ただし、相互認証（サーバーへのクライアントだけでなく、クライアントへのサーバーも認証する）が実行されている場合、KRB_AP_REQメッセージはAP-Optionsフィールドに相互に必要なセットを持ち、KRB_AP_REPメッセージが必要になります。応答。エラーメッセージと同様に、このメッセージは、アプリケーションのプロトコルに「生」フォームが受け入れられない場合、アプリケーションプロトコルにカプセル化される場合があります。返信で使用されるタイムスタンプとマイクロ秒フィールドは、クライアントのタイムスタンプとマイクロ秒フィールド（認証機に提供されている）でなければなりません。シーケンス番号を含める場合は、認証器について上記のようにランダムに選択する必要があります。サーバーが別のサブキーを交渉したい場合は、サブキーを含めることができます。KRB_AP_REPメッセージは、チケットから抽出されたセッションキーで暗号化されています。"
    },
    {
      "indent": 3,
      "text": "Note that in the Kerberos Version 4 protocol, the timestamp in the reply was the client's timestamp plus one. This is not necessary in Version 5 because Version 5 messages are formatted in such a way that it is not possible to create the reply by judicious message surgery (even in encrypted form) without knowledge of the appropriate encryption keys.",
      "ja": "Kerberosバージョン4プロトコルでは、返信のタイムスタンプがクライアントのタイムスタンプと1つのものであったことに注意してください。バージョン5のメッセージは、適切な暗号化キーを知らずに賢明なメッセージ手術（暗号化された形式でも）で返信を作成することができないようにフォーマットされているため、これはバージョン5では必要ありません。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Receipt of KRB_AP_REP Message",
      "section_title": true,
      "ja": "3.2.5. KRB_AP_REPメッセージの受信"
    },
    {
      "indent": 3,
      "text": "If a KRB_AP_REP message is returned, the client uses the session key from the credentials obtained for the server to decrypt the message and verifies that the timestamp and microsecond fields match those in the Authenticator it sent to the server. If they match, then the client is assured that the server is genuine. The sequence number and subkey (if present) are retained for later use. (Note that for encrypting the KRB_AP_REP message, the sub-session key is not used, even if it is present in the Authentication.)",
      "ja": "KRB_AP_REPメッセージが返された場合、クライアントは、サーバーが取得した資格情報からセッションキーを使用してメッセージを解読し、タイムスタンプとマイクロ秒フィールドがサーバーに送信された認証器のフィールドと一致することを確認します。それらが一致する場合、クライアントはサーバーが本物であることを保証します。シーケンス番号とサブキー（存在する場合）は、後で使用するために保持されます。（KRB_AP_REPメッセージを暗号化するためには、認証に存在していても、サブセッションキーは使用されないことに注意してください。）"
    },
    {
      "indent": 0,
      "text": "3.2.6. Using the Encryption Key",
      "section_title": true,
      "ja": "3.2.6. 暗号化キーを使用します"
    },
    {
      "indent": 3,
      "text": "After the KRB_AP_REQ/KRB_AP_REP exchange has occurred, the client and server share an encryption key that can be used by the application. In some cases, the use of this session key will be implicit in the protocol; in others the method of use must be chosen from several alternatives. The application MAY choose the actual encryption key to be used for KRB_PRIV, KRB_SAFE, or other application-specific uses based on the session key from the ticket and subkeys in the KRB_AP_REP message and the authenticator. Implementations of the protocol MAY provide routines to choose subkeys based on session keys and random numbers and to generate a negotiated key to be returned in the KRB_AP_REP message.",
      "ja": "KRB_AP_REQ/KRB_AP_REP Exchangeが発生した後、クライアントとサーバーはアプリケーションで使用できる暗号化キーを共有します。場合によっては、このセッションキーの使用はプロトコルで暗黙的になります。その他では、いくつかの選択肢から使用する方法を選択する必要があります。アプリケーションは、krb_ap_repメッセージおよび認証者のチケットとサブキーのセッションキーに基づいて、krb_priv、krb_safe、またはその他のアプリケーション固有の使用に使用する実際の暗号化キーを選択できます。プロトコルの実装は、セッションキーと乱数に基づいてサブキーを選択し、krb_ap_repメッセージで返されるネゴシエートキーを生成するためのルーチンを提供する場合があります。"
    },
    {
      "indent": 3,
      "text": "To mitigate the effect of failures in random number generation on the client, it is strongly encouraged that any key derived by an application for subsequent use include the full key entropy derived from the KDC-generated session key carried in the ticket. We leave the protocol negotiations of how to use the key (e.g., for selecting an encryption or checksum type) to the application programmer. The Kerberos protocol does not constrain the implementation options, but an example of how this might be done follows.",
      "ja": "クライアントに対する乱数生成の障害の影響を軽減するために、その後の使用のためにアプリケーションによって導出されたキーには、チケットに掲載されたKDC生成セッションキーから派生した完全なキーエントロピーが含まれることが強く推奨されます。キーを使用する方法のプロトコル交渉（例：暗号化またはチェックサムタイプを選択するため）をアプリケーションプログラマに任せます。Kerberosプロトコルは、実装オプションを制約するのではなく、これがどのように行われるかの例が続きます。"
    },
    {
      "indent": 3,
      "text": "One way that an application may choose to negotiate a key to be used for subsequent integrity and privacy protection is for the client to propose a key in the subkey field of the authenticator. The server can then choose a key using the key proposed by the client as input, returning the new subkey in the subkey field of the application reply. This key could then be used for subsequent communication.",
      "ja": "アプリケーションが、その後の整合性とプライバシー保護に使用するキーをネゴシエートすることを選択する1つの方法は、クライアントが認証者のサブキーフィールドでキーを提案することです。サーバーは、クライアントが提案したキーを入力として使用してキーを選択し、アプリケーションの応答のサブキーフィールドで新しいサブキーを返します。このキーは、後続の通信に使用できます。"
    },
    {
      "indent": 3,
      "text": "With both the one-way and mutual authentication exchanges, the peers should take care not to send sensitive information to each other without proper assurances. In particular, applications that require privacy or integrity SHOULD use the KRB_AP_REP response from the server to the client to assure both client and server of their peer's identity. If an application protocol requires privacy of its messages, it can use the KRB_PRIV message (section 3.5). The KRB_SAFE message (Section 3.4) can be used to ensure integrity.",
      "ja": "一方向と相互認証交換の両方で、ピアは適切な保証なしに互いに敏感な情報を送信しないように注意する必要があります。特に、プライバシーまたは整合性を必要とするアプリケーションは、サーバーからクライアントへのkrb_ap_rep応答を使用して、ピアのIDのクライアントとサーバーの両方に保証する必要があります。アプリケーションプロトコルがメッセージのプライバシーを必要とする場合、KRB_PRIVメッセージ（セクション3.5）を使用できます。KRB_SAFEメッセージ（セクション3.4）を使用して、整合性を確保できます。"
    },
    {
      "indent": 0,
      "text": "3.3. The Ticket-Granting Service (TGS) Exchange",
      "section_title": true,
      "ja": "3.3. チケット栽培サービス（TGS）交換"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 9,
      "text": "Message direction Message type Section 1. Client to Kerberos KRB_TGS_REQ 5.4.1 2. Kerberos to client KRB_TGS_REP or 5.4.2 KRB_ERROR 5.9.1",
      "ja": "メッセージの方向メッセージタイプセクション1. Kerberos KRB_TGS_REQ 5.4.1からクライアントからクライアントKRB_TGS_REPまたは5.4.2 KRB_ERROR 5.9.1へ"
    },
    {
      "indent": 3,
      "text": "The TGS exchange between a client and the Kerberos TGS is initiated by a client when it seeks to obtain authentication credentials for a given server (which might be registered in a remote realm), when it seeks to renew or validate an existing ticket, or when it seeks to obtain a proxy ticket. In the first case, the client must already have acquired a ticket for the Ticket-Granting Service using the AS exchange (the TGT is usually obtained when a client initially authenticates to the system, such as when a user logs in). The message format for the TGS exchange is almost identical to that for the AS exchange. The primary difference is that encryption and decryption in the TGS exchange does not take place under the client's key. Instead, the session key from the TGT or renewable ticket, or sub-session key from an Authenticator is used. As is the case for all application servers, expired tickets are not accepted by the TGS, so once a renewable or TGT expires, the client must use a separate exchange to obtain valid tickets.",
      "ja": "クライアントとKerberos TGSの間のTGS交換は、特定のサーバーの認証資格情報を取得しようとする場合（リモート領域に登録される可能性がある）、既存のチケットを更新または検証しようとするとき、またはいつ、または既存のチケットを検証しようとするとき、またはクライアントによって開始されます。プロキシチケットを取得しようとしています。最初のケースでは、クライアントはAS Exchangeを使用してチケット栽培サービスのチケットを取得している必要があります（通常、TGTは、ユーザーがログインするときなど、クライアントが最初にシステムに認証するときに取得されます）。TGS Exchangeのメッセージ形式は、AS Exchangeのメッセージとほぼ同じです。主な違いは、TGS交換の暗号化と復号化がクライアントのキーの下で行われないことです。代わりに、TGTのセッションキーまたは再生可能なチケット、または認証機のサブセッションキーが使用されます。すべてのアプリケーションサーバーの場合と同様に、期限切れのチケットはTGSに受け入れられないため、再生可能またはTGTの有効期限が切れると、クライアントは有効なチケットを取得するために別の交換を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The TGS exchange consists of two messages: a request (KRB_TGS_REQ) from the client to the Kerberos Ticket-Granting Server, and a reply (KRB_TGS_REP or KRB_ERROR). The KRB_TGS_REQ message includes information authenticating the client plus a request for credentials. The authentication information consists of the authentication header (KRB_AP_REQ), which includes the client's previously obtained ticket-granting, renewable, or invalid ticket. In the TGT and proxy cases, the request MAY include one or more of the following: a list of network addresses, a collection of typed authorization data to be sealed in the ticket for authorization use by the application server, or additional tickets (the use of which are described later). The TGS reply (KRB_TGS_REP) contains the requested credentials, encrypted in the session key from the TGT or renewable ticket, or, if present, in the sub-session key from the Authenticator (part of the authentication header). The KRB_ERROR message contains an error code and text explaining what went wrong. The KRB_ERROR message is not encrypted. The KRB_TGS_REP message contains information that can be used to detect replays, and to associate it with the message to which it replies. The KRB_ERROR message also contains information that can be used to associate it with the message to which it replies. The same comments about integrity protection of KRB_ERROR messages mentioned in Section 3.1 apply to the TGS exchange.",
      "ja": "TGS Exchangeは、クライアントからKerberosチケット栽培サーバーへのリクエスト（krb_tgs_req）と返信（krb_tgs_repまたはkrb_error）の2つのメッセージで構成されています。KRB_TGS_REQメッセージには、クライアントに認証された情報と資格情報のリクエストが含まれています。認証情報は、認証ヘッダー（krb_ap_req）で構成されています。これには、以前に取得したチケット栽培、再生可能、または無効なチケットが含まれます。TGTおよびプロキシのケースでは、リクエストには、次の1つ以上が含まれる場合があります。ネットワークアドレスのリスト、アプリケーションサーバーが認証を使用するためにチケットに封印されるタイプ化された許可データのコレクション、または追加チケット（使用）そのうち、後で説明します）。TGS応答（krb_tgs_rep）には、TGTまたは再生可能チケットのセッションキーに暗号化された要求された資格情報、または存在する場合は、認証ヘッダーの一部）からサブセッションキーに暗号化されています。KRB_ERRORメッセージには、何がうまくいかなかったかを説明するエラーコードとテキストが含まれています。KRB_ERRORメッセージは暗号化されていません。KRB_TGS_REPメッセージには、リプレイを検出し、それを返信するメッセージに関連付けるために使用できる情報が含まれています。KRB_ERRORメッセージには、返信するメッセージに関連付けるために使用できる情報も含まれています。セクション3.1に記載されているKRB_ERRORメッセージの整合性保護に関する同じコメントは、TGS Exchangeに適用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Generation of KRB_TGS_REQ Message",
      "section_title": true,
      "ja": "3.3.1. KRB_TGS_REQメッセージの生成"
    },
    {
      "indent": 3,
      "text": "Before sending a request to the ticket-granting service, the client MUST determine in which realm the application server is believed to be registered. This can be accomplished in several ways. It might be known beforehand (since the realm is part of the principal identifier), it might be stored in a nameserver, or it might be obtained from a configuration file. If the realm to be used is obtained from a nameserver, there is a danger of being spoofed if the nameservice providing the realm name is not authenticated. This might result in the use of a realm that has been compromised, which would result in an attacker's ability to compromise the authentication of the application server to the client.",
      "ja": "チケット授与サービスにリクエストを送信する前に、クライアントは、アプリケーションサーバーが登録されていると考えられるレルムを決定する必要があります。これはいくつかの方法で達成できます。事前に知られている可能性があります（領域は主要な識別子の一部であるため）、名前サーバーに保存されるか、構成ファイルから取得される場合があります。使用する領域が名前サーバーから取得される場合、レルム名を提供する名前サービスが認証されていない場合、スプーフィングされる危険があります。これにより、侵害された領域が使用される可能性があり、その結果、アプリケーションサーバーの認証をクライアントに侵害する攻撃者の能力が生じる可能性があります。"
    },
    {
      "indent": 3,
      "text": "If the client knows the service principal name and realm and it does not already possess a TGT for the appropriate realm, then one must be obtained. This is first attempted by requesting a TGT for the destination realm from a Kerberos server for which the client possesses a TGT (by using the KRB_TGS_REQ message recursively). The Kerberos server MAY return a TGT for the desired realm, in which case one can proceed. Alternatively, the Kerberos server MAY return a TGT for a realm that is 'closer' to the desired realm (further along the standard hierarchical path between the client's realm and the requested realm server's realm). Note that in this case misconfiguration of the Kerberos servers may cause loops in the resulting authentication path, which the client should be careful to detect and avoid.",
      "ja": "クライアントがサービスプリンシパル名と領域を知っており、適切な領域のTGTをまだ所有していない場合は、取得する必要があります。これは、クライアントがTGTを所有しているKerberosサーバーから宛先領域のTGTを要求することにより最初に試みられます（KRB_TGS_REQメッセージを再帰的に使用することにより）。Kerberosサーバーは、目的の領域に対してTGTを返す場合があります。その場合、進行することができます。あるいは、Kerberosサーバーは、目的の領域に「近い」領域のTGTを返すことができます（さらに、クライアントの領域と要求されたレルムサーバーの領域の間の標準的な階層パスに沿って）。この場合、Kerberosサーバーの誤った構成は、結果の認証パスにループを引き起こす可能性があることに注意してください。クライアントは、検出して避けるように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the Kerberos server returns a TGT for a realm 'closer' than the desired realm, the client MAY use local policy configuration to verify that the authentication path used is an acceptable one. Alternatively, a client MAY choose its own authentication path, rather than rely on the Kerberos server to select one. In either case, any policy or configuration information used to choose or validate authentication paths, whether by the Kerberos server or by the client, MUST be obtained from a trusted source.",
      "ja": "Kerberosサーバーが目的の領域よりも「近い」領域のTGTを返す場合、クライアントはローカルポリシー構成を使用して、使用される認証パスが許容可能なパスであることを確認できます。あるいは、クライアントは、Kerberosサーバーに依存して1つを選択するのではなく、独自の認証パスを選択する場合があります。どちらの場合でも、認証パスを選択または検証するために使用されるポリシーまたは構成情報は、Kerberosサーバーによって、またはクライアントによるものであれ、信頼できるソースから取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client obtains a TGT that is 'closer' to the destination realm, the client MAY cache this ticket and reuse it in future KRB-TGS exchanges with services in the 'closer' realm. However, if the client were to obtain a TGT for the 'closer' realm by starting at the initial KDC rather than as part of obtaining another ticket, then a shorter path to the 'closer' realm might be used. This shorter path may be desirable because fewer intermediate KDCs would know the session key of the ticket involved. For this reason, clients SHOULD evaluate whether they trust the realms transited in obtaining the 'closer' ticket when making a decision to use the ticket in future.",
      "ja": "クライアントが宛先の領域に「近い」TGTを取得すると、クライアントはこのチケットをキャッシュし、将来のKRB-TGSで「より近い」領域のサービスと再利用できます。ただし、クライアントが別のチケットを取得するのではなく、最初のKDCから開始することにより、「近い」領域のTGTを取得する場合、「より近い」領域への短いパスが使用される可能性があります。この短いパスが望ましい場合があります。なぜなら、中間KDCが少ないため、関与するチケットのセッションキーがわかっているからです。このため、クライアントは、将来チケットを使用することを決定する際に、「より近い」チケットを取得する際に領域を信頼しているかどうかを評価する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once the client obtains a TGT for the appropriate realm, it determines which Kerberos servers serve that realm and contacts one of them. The list might be obtained through a configuration file or network service, or it MAY be generated from the name of the realm. As long as the secret keys exchanged by realms are kept secret, only denial of service results from using a false Kerberos server.",
      "ja": "クライアントが適切な領域のTGTを取得すると、どのKerberosサーバーがその領域にサービスを提供し、そのうちの1つに接触するかを決定します。リストは、構成ファイルまたはネットワークサービスを介して取得される場合があります。または、レルムの名前から生成される場合があります。領域によって交換される秘密のキーが秘密にされている限り、誤ったKerberosサーバーを使用することによるサービスの拒否のみが結果です。"
    },
    {
      "indent": 3,
      "text": "As in the AS exchange, the client MAY specify a number of options in the KRB_TGS_REQ message. One of these options is the ENC-TKT-IN-SKEY option used for user-to-user authentication. An overview of user-to-user authentication can be found in Section 3.7. When generating the KRB_TGS_REQ message, this option indicates that the client is including a TGT obtained from the application server in the additional tickets field of the request and that the KDC SHOULD encrypt the ticket for the application server using the session key from this additional ticket, instead of a server key from the principal database.",
      "ja": "AS Exchangeのように、クライアントはkrb_tgs_reqメッセージに多くのオプションを指定する場合があります。これらのオプションの1つは、ユーザーからユーザーへの認証に使用されるEnc-Tkt-in-Skeyオプションです。ユーザーからユーザーへの認証の概要は、セクション3.7に記載されています。KRB_TGS_REQメッセージを生成するとき、このオプションは、クライアントがリクエストの追加チケットフィールドにアプリケーションサーバーから取得したTGTを含めていることを示しています。主要なデータベースのサーバーキーの代わりに。"
    },
    {
      "indent": 3,
      "text": "The client prepares the KRB_TGS_REQ message, providing an authentication header as an element of the padata field, and including the same fields as used in the KRB_AS_REQ message along with several optional fields: the enc-authorizatfion-data field for application server use and additional tickets required by some options.",
      "ja": "クライアントはKRB_TGS_REQメッセージを準備し、Padataフィールドの要素として認証ヘッダーを提供し、KRB_AS_REQメッセージで使用される同じフィールドと、アプリケーションサーバーの使用と追加チケットのENC-Authorizatfion-Dataフィールドとともにいくつかのオプションフィールドを含めます。いくつかのオプションで必要です。"
    },
    {
      "indent": 3,
      "text": "In preparing the authentication header, the client can select a sub-session key under which the response from the Kerberos server will be encrypted. If the client selects a sub-session key, care must be taken to ensure the randomness of the selected sub-session key.",
      "ja": "認証ヘッダーを準備する際、クライアントは、Kerberosサーバーからの応答が暗号化されるサブセッションキーを選択できます。クライアントがサブセッションキーを選択した場合、選択したサブセッションキーのランダム性を確保するように注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the sub-session key is not specified, the session key from the TGT will be used. If the enc-authorization-data is present, it MUST be encrypted in the sub-session key, if present, from the authenticator portion of the authentication header, or, if not present, by using the session key from the TGT.",
      "ja": "サブセッションキーが指定されていない場合、TGTのセッションキーが使用されます。Enc-authorization-Dataが存在する場合、認証ヘッダーの認証因子部分から、またはTGTのセッションキーを使用して、存在する場合は、サブセッションキーに暗号化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once prepared, the message is sent to a Kerberos server for the destination realm.",
      "ja": "準備ができたら、メッセージは宛先の領域のためにKerberosサーバーに送信されます。"
    },
    {
      "indent": 0,
      "text": "3.3.2. Receipt of KRB_TGS_REQ Message",
      "section_title": true,
      "ja": "3.3.2. krb_tgs_reqメッセージの受領"
    },
    {
      "indent": 3,
      "text": "The KRB_TGS_REQ message is processed in a manner similar to the KRB_AS_REQ message, but there are many additional checks to be performed. First, the Kerberos server MUST determine which server the accompanying ticket is for, and it MUST select the appropriate key to decrypt it. For a normal KRB_TGS_REQ message, it will be for the ticket-granting service, and the TGS's key will be used. If the TGT was issued by another realm, then the appropriate inter-realm key MUST be used. If (a) the accompanying ticket is not a TGT for the current realm, but is for an application server in the current realm, (b) the RENEW, VALIDATE, or PROXY options are specified in the request, and (c) the server for which a ticket is requested is the server named in the accompanying ticket, then the KDC will decrypt the ticket in the authentication header using the key of the server for which it was issued. If no ticket can be found in the padata field, the KDC_ERR_PADATA_TYPE_NOSUPP error is returned.",
      "ja": "KRB_TGS_REQメッセージは、KRB_AS_REQメッセージと同様の方法で処理されますが、実行する追加のチェックがたくさんあります。まず、Kerberosサーバーは、付随するチケットのサーバーを決定する必要があり、それを復号化するための適切なキーを選択する必要があります。通常のKRB_TGS_REQメッセージの場合、チケット栽培サービス用であり、TGSのキーが使用されます。TGTが別の領域によって発行された場合、適切なリアルム間キーを使用する必要があります。（a）添付チケットは現在の領域のTGTではなく、現在の領域のアプリケーションサーバー用であり、（b）リクエストで更新、検証、またはプロキシオプションが指定されている場合、（c）サーバーチケットが要求されているのは、添付のチケットに名前が付けられたサーバーであるため、KDCは発行されたサーバーのキーを使用して認証ヘッダーのチケットを復号化します。Padataフィールドにチケットが見つからない場合、KDC_ERR_PADATA_TYPE_NOSUPPエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "Once the accompanying ticket has been decrypted, the user-supplied checksum in the Authenticator MUST be verified against the contents of the request, and the message MUST be rejected if the checksums do not match (with an error code of KRB_AP_ERR_MODIFIED) or if the checksum is not collision-proof (with an error code of KRB_AP_ERR_INAPP_CKSUM). If the checksum type is not supported, the KDC_ERR_SUMTYPE_NOSUPP error is returned. If the authorization-data are present, they are decrypted using the sub-session key from the Authenticator.",
      "ja": "付随するチケットが復号化されたら、認証機のユーザーがサプライされたチェックサムをリクエストの内容に対して検証する必要があり、チェックサムが一致しない場合（KRB_AP_ERR_ERR_IDEFIEDのエラーコード）、またはチェックサムの場合はメッセージを拒否する必要があります。衝突防止ではありません（krb_ap_err_inapp_cksumのエラーコードを使用）。チェックサムのタイプがサポートされていない場合、KDC_ERR_SUMTYPE_NOSUPPエラーが返されます。承認データが存在する場合、それらは認証機のサブセッションキーを使用して復号化されます。"
    },
    {
      "indent": 3,
      "text": "If any of the decryptions indicate failed integrity checks, the KRB_AP_ERR_BAD_INTEGRITY error is returned.",
      "ja": "復号のいずれかが整合性チェックの失敗を示している場合、krb_ap_err_bad_integrityエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "As discussed in Section 3.1.2, the KDC MUST send a valid KRB_TGS_REP message if it receives a KRB_TGS_REQ message identical to one it has recently processed. However, if the authenticator is a replay, but the rest of the request is not identical, then the KDC SHOULD return KRB_AP_ERR_REPEAT.",
      "ja": "セクション3.1.2で説明したように、KDCは、最近処理されたものと同一のkrb_tgs_reqメッセージを受信した場合、有効なkrb_tgs_repメッセージを送信する必要があります。ただし、Authenticatorがリプレイであるが、リクエストの残りの部分が同一ではない場合、KDCはKRB_AP_ERR_REPEATを返す必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3.3. Generation of KRB_TGS_REP Message",
      "section_title": true,
      "ja": "3.3.3. KRB_TGS_REPメッセージの生成"
    },
    {
      "indent": 3,
      "text": "The KRB_TGS_REP message shares its format with the KRB_AS_REP (KRB_KDC_REP), but with its type field set to KRB_TGS_REP. The detailed specification is in Section 5.4.2.",
      "ja": "KRB_TGS_REPメッセージは、KRB_AS_REP（krb_kdc_rep）とその形式を共有しますが、そのタイプフィールドはkrb_tgs_repに設定されています。詳細な仕様はセクション5.4.2にあります。"
    },
    {
      "indent": 3,
      "text": "The response will include a ticket for the requested server or for a ticket granting server of an intermediate KDC to be contacted to obtain the requested ticket. The Kerberos database is queried to retrieve the record for the appropriate server (including the key with which the ticket will be encrypted). If the request is for a TGT for a remote realm, and if no key is shared with the requested realm, then the Kerberos server will select the realm 'closest' to the requested realm with which it does share a key and use that realm instead. This is the only case where the response for the KDC will be for a different server than that requested by the client.",
      "ja": "応答には、要求されたサーバーのチケット、または要求されたチケットを取得するために連絡する中間KDCのチケット付与サーバーが含まれます。Kerberosデータベースは、適切なサーバーのレコードを取得するために照会されています（チケットが暗号化されるキーを含む）。リクエストがリモートレルムのTGTのリクエストであり、キーが要求された領域と共有されていない場合、Kerberosサーバーは、キーを共有し、代わりにその領域を使用する要求された領域に「最も近い」領域を選択します。これは、KDCの応答がクライアントがリクエストしたサーバーとは異なるサーバーに対してである唯一のケースです。"
    },
    {
      "indent": 3,
      "text": "By default, the address field, the client's name and realm, the list of transited realms, the time of initial authentication, the expiration time, and the authorization data of the newly-issued ticket will be copied from the TGT or renewable ticket. If the transited field needs to be updated, but the transited type is not supported, the KDC_ERR_TRTYPE_NOSUPP error is returned.",
      "ja": "デフォルトでは、アドレスフィールド、クライアントの名前と領域、通過領域のリスト、初期認証の時間、有効期限、新たに発行されたチケットの承認データは、TGTまたは再生可能なチケットからコピーされます。通過フィールドを更新する必要があるが、通過型がサポートされていない場合、KDC_ERR_TRTYPE_NOSUPPエラーが返されます。"
    },
    {
      "indent": 3,
      "text": "If the request specifies an endtime, then the endtime of the new ticket is set to the minimum of (a) that request, (b) the endtime from the TGT, and (c) the starttime of the TGT plus the minimum of the maximum life for the application server and the maximum life for the local realm (the maximum life for the requesting principal was already applied when the TGT was issued). If the new ticket is to be a renewal, then the endtime above is replaced by the minimum of (a) the value of the renew_till field of the ticket and (b) the starttime for the new ticket plus the life (endtime-starttime) of the old ticket.",
      "ja": "リクエストが終了時間を指定する場合、新しいチケットの終了時間は（a）その要求、（b）TGTからの終了時刻、および（c）TGTの開始時刻と最大値の最小値に設定されます。アプリケーションサーバーの寿命とローカルレルムの最大寿命（TGTが発行されたとき、要求プリンシパルの最大寿命はすでに適用されていました）。新しいチケットが更新である場合、上記のエンドタイムは（a）チケットの更新フィールドの値と（b）新しいチケットと寿命の開始時刻（終了時間 - スタートタイム）の最小値に置き換えられます。古いチケットの。"
    },
    {
      "indent": 3,
      "text": "If the FORWARDED option has been requested, then the resulting ticket will contain the addresses specified by the client. This option will only be honored if the FORWARDABLE flag is set in the TGT. The PROXY option is similar; the resulting ticket will contain the addresses specified by the client. It will be honored only if the PROXIABLE flag in the TGT is set. The PROXY option will not be honored on requests for additional TGTs.",
      "ja": "転送されたオプションが要求されている場合、結果のチケットにはクライアントが指定したアドレスが含まれます。このオプションは、転送可能なフラグがTGTに設定されている場合にのみ表彰されます。プロキシオプションは似ています。結果のチケットには、クライアントが指定したアドレスが含まれます。TGTのプロキシ可能なフラグが設定されている場合にのみ、表彰されます。プロキシオプションは、追加のTGTのリクエストに応じて尊重されません。"
    },
    {
      "indent": 3,
      "text": "If the requested starttime is absent, indicates a time in the past, or is within the window of acceptable clock skew for the KDC and the POSTDATE option has not been specified, then the starttime of the ticket is set to the authentication server's current time. If it indicates a time in the future beyond the acceptable clock skew, but the POSTDATED option has not been specified or the MAY-POSTDATE flag is not set in the TGT, then the error KDC_ERR_CANNOT_POSTDATE is returned. Otherwise, if the TGT has the MAY-POSTDATE flag set, then the resulting ticket will be postdated, and the requested starttime is checked against the policy of the local realm. If acceptable, the ticket's starttime is set as requested, and the INVALID flag is set. The postdated ticket MUST be validated before use by presenting it to the KDC after the starttime has been reached. However, in no case may the starttime, endtime, or renew-till time of a newly-issued postdated ticket extend beyond the renew-till time of the TGT.",
      "ja": "要求された開始時刻が不在の場合、過去の時間を示している場合、またはKDCの許容時計スキューのウィンドウ内にある場合、ポストデートオプションが指定されていない場合、チケットの開始時刻は認証サーバーの現在の時刻に設定されます。許容されるクロックスキューを超えて将来の時間を示しているが、延期されたオプションが指定されていないか、May-postdateフラグがTGTに設定されていない場合、エラーKDC_ERR_CANNOT_POSTDATEが返されます。それ以外の場合、TGTに5月のフラグが設定されている場合、結果のチケットが延期され、要求された開始時刻がローカル領域のポリシーに対してチェックされます。許容可能な場合、チケットの起動時刻は要求に従って設定され、無効なフラグが設定されます。開始時刻に到達した後にKDCに提示することにより、使用する前に、郵便局面チケットを検証する必要があります。ただし、いかなる場合でも、新しく発行された郵便券の開始時、終了時、または更新時間がTGTの更新時間を超えて延長されることはありません。"
    },
    {
      "indent": 3,
      "text": "If the ENC-TKT-IN-SKEY option has been specified and an additional ticket has been included in the request, it indicates that the client is using user-to-user authentication to prove its identity to a server that does not have access to a persistent key. Section 3.7 describes the effect of this option on the entire Kerberos protocol. When generating the KRB_TGS_REP message, this option in the KRB_TGS_REQ message tells the KDC to decrypt the additional ticket using the key for the server to which the additional ticket was issued and to verify that it is a TGT. If the name of the requested server is missing from the request, the name of the client in the additional ticket will be used. Otherwise, the name of the requested server will be compared to the name of the client in the additional ticket. If it is different, the request will be rejected. If the request succeeds, the session key from the additional ticket will be used to encrypt the new ticket that is issued instead of using the key of the server for which the new ticket will be used.",
      "ja": "Enc-Tkt-in-Skeyオプションが指定され、追加のチケットがリクエストに含まれている場合、クライアントがユーザー間認証を使用して、アクセスできないサーバーにIDを証明していることを示しています。永続的なキー。セクション3.7では、Kerberosプロトコル全体に対するこのオプションの効果について説明します。KRB_TGS_REPメッセージを生成するとき、KRB_TGS_REQメッセージのこのオプションはKDCに、追加のチケットが発行されたサーバーのキーを使用して追加のチケットを復号化し、TGTであることを確認するようにKDCに指示します。要求されたサーバーの名前がリクエストから欠落している場合、追加のチケットのクライアントの名前が使用されます。それ以外の場合、要求されたサーバーの名前は、追加のチケットのクライアントの名前と比較されます。違う場合、リクエストは拒否されます。リクエストが成功した場合、追加チケットのセッションキーを使用して、新しいチケットが使用されるサーバーのキーを使用する代わりに、発行される新しいチケットを暗号化するために使用されます。"
    },
    {
      "indent": 3,
      "text": "If (a) the name of the server in the ticket that is presented to the KDC as part of the authentication header is not that of the TGS itself, (b) the server is registered in the realm of the KDC, and (c) the RENEW option is requested, then the KDC will verify that the RENEWABLE flag is set in the ticket, that the INVALID flag is not set in the ticket, and that the renew_till time is still in the future. If the VALIDATE option is requested, the KDC will check that the starttime has passed and that the INVALID flag is set. If the PROXY option is requested, then the KDC will check that the PROXIABLE flag is set in the ticket. If the tests succeed and the ticket passes the hotlist check described in the next section, the KDC will issue the appropriate new ticket.",
      "ja": "（a）認証ヘッダーの一部としてKDCに提示されるチケット内のサーバーの名前はTGS自体ではなく、（b）サーバーはKDCの領域に登録されている、および（c）更新オプションが要求され、KDCはチケットに再生可能フラグが設定されていること、無効なフラグがチケットに設定されておらず、更新時間がまだ将来的にあることを確認します。検証オプションが要求された場合、KDCは開始時刻が通過したことと無効なフラグが設定されていることを確認します。プロキシオプションが要求された場合、KDCはProxaibleフラグがチケットに設定されていることを確認します。テストが成功し、チケットが次のセクションで説明されているホットリストチェックに合格した場合、KDCは適切な新しいチケットを発行します。"
    },
    {
      "indent": 3,
      "text": "The ciphertext part of the response in the KRB_TGS_REP message is encrypted in the sub-session key from the Authenticator, if present, or in the session key from the TGT. It is not encrypted using the client's secret key. Furthermore, the client's key's expiration date and the key version number fields are left out since these values are stored along with the client's database record, and that record is not needed to satisfy a request based on a TGT.",
      "ja": "KRB_TGS_REPメッセージの応答のciphertext部分は、存在する場合、認証機のサブセッションキー、またはTGTのセッションキーで暗号化されます。クライアントのシークレットキーを使用して暗号化されていません。さらに、クライアントのキーの有効期限とキーバージョン番号フィールドは、これらの値がクライアントのデータベースレコードとともに保存され、TGTに基づくリクエストを満たすためにそのレコードは必要ありません。"
    },
    {
      "indent": 0,
      "text": "3.3.3.1. Checking for Revoked Tickets",
      "section_title": true,
      "ja": "3.3.3.1. 取り消されたチケットのチェック"
    },
    {
      "indent": 3,
      "text": "Whenever a request is made to the ticket-granting server, the presented ticket(s) is (are) checked against a hot-list of tickets that have been canceled. This hot-list might be implemented by storing a range of issue timestamps for 'suspect tickets'; if a presented ticket had an authtime in that range, it would be rejected. In this way, a stolen TGT or renewable ticket cannot be used to gain additional tickets (renewals or otherwise) once the theft has been reported to the KDC for the realm in which the server resides. Any normal ticket obtained before it was reported stolen will still be valid (because tickets require no interaction with the KDC), but only until its normal expiration time. If TGTs have been issued for cross-realm authentication, use of the cross-realm TGT will not be affected unless the hot-list is propagated to the KDCs for the realms for which such cross-realm tickets were issued.",
      "ja": "チケット栽培サーバーにリクエストが行われるたびに、提示されたチケットは、キャンセルされたチケットのホットリストに対して（AR）チェックされます。このホットリストは、「疑わしいチケット」のために一連の問題のタイムスタンプを保存することによって実装される場合があります。提示されたチケットがその範囲で認定時間を持っていた場合、それは拒否されます。このようにして、盗まれたTGTまたは再生可能チケットを使用して、サーバーが存在する領域のKDCに盗難が報告された後、追加のチケット（更新など）を取得することはできません。盗まれたと報告される前に取得された通常のチケットは、依然として有効です（チケットはKDCとのやり取りを必要としないため）が、通常の有効期限までのみです。Cross-RealM認証のためにTGTが発行された場合、Hotリストがそのようなクロスリアムチケットが発行された領域のKDCに伝播されない限り、Cross-Realm TGTの使用は影響を受けません。"
    },
    {
      "indent": 0,
      "text": "3.3.3.2. Encoding the Transited Field",
      "section_title": true,
      "ja": "3.3.3.2. 通過フィールドのエンコード"
    },
    {
      "indent": 3,
      "text": "If the identity of the server in the TGT that is presented to the KDC as part of the authentication header is that of the ticket-granting service, but the TGT was issued from another realm, the KDC will look up the inter-realm key shared with that realm and use that key to decrypt the ticket. If the ticket is valid, then the KDC will honor the request, subject to the constraints outlined above in the section describing the AS exchange. The realm part of the client's identity will be taken from the TGT. The name of the realm that issued the TGT, if it is not the realm of the client principal, will be added to the transited field of the ticket to be issued. This is accomplished by reading the transited field from the TGT (which is treated as an unordered set of realm names), adding the new realm to the set, and then constructing and writing out its encoded (shorthand) form (this may involve a rearrangement of the existing encoding).",
      "ja": "認証ヘッダーの一部としてKDCに提示されるTGTのサーバーのIDはチケット授与サービスのIDですが、TGTは別の領域から発行された場合、KDCは共有されたRealm Inter-Realmキーを検索しますその領域を使用して、そのキーを使用してチケットを復号化します。チケットが有効な場合、KDCは、AS Exchangeを説明するセクションで上記の制約を条件として、リクエストを尊重します。クライアントの身元の領域部分はTGTから取得されます。TGTを発行した領域の名前は、それがクライアントプリンシパルの領域ではない場合、発行されるチケットの通過フィールドに追加されます。これは、TGT（順序付けられていないレルム名のセットとして扱われている）から通過したフィールドを読み取り、新しいレルムをセットに追加してから、エンコードされた（速記）フォームを構築して書き出すことによって達成されます（これには再配置が含まれる場合があります既存のエンコーディングの）。"
    },
    {
      "indent": 3,
      "text": "Note that the ticket-granting service does not add the name of its own realm. Instead, its responsibility is to add the name of the previous realm. This prevents a malicious Kerberos server from intentionally leaving out its own name (it could, however, omit other realms' names).",
      "ja": "チケット栽培サービスは、独自の領域の名前を追加しないことに注意してください。代わりに、その責任は以前の領域の名前を追加することです。これにより、悪意のあるKerberosサーバーが意図的に独自の名前を除外することを防ぎます（ただし、他のレルムの名前を省略できます）。"
    },
    {
      "indent": 3,
      "text": "The names of neither the local realm nor the principal's realm are to be included in the transited field. They appear elsewhere in the ticket and both are known to have taken part in authenticating the principal. Because the endpoints are not included, both local and single-hop inter-realm authentication result in a transited field that is empty.",
      "ja": "地元の領域でも校長の領域も、通過分野に含まれるべきではありません。彼らはチケットの他の場所に登場し、両方とも校長の認証に参加したことが知られています。エンドポイントは含まれていないため、ローカルとシングルホップ間の両方のリアルム認証の両方が、空の輸送フィールドになります。"
    },
    {
      "indent": 3,
      "text": "Because this field has the name of each transited realm added to it, it might potentially be very long. To decrease the length of this field, its contents are encoded. The initially supported encoding is optimized for the normal case of inter-realm communication: a hierarchical arrangement of realms using either domain or X.500 style realm names. This encoding (called DOMAIN-X500-COMPRESS) is now described.",
      "ja": "このフィールドには、各通過領域の名前が追加されているため、潜在的に非常に長くなる可能性があります。このフィールドの長さを減らすために、その内容がエンコードされます。最初にサポートされているエンコードは、REALM間通信の通常のケースで最適化されています。ドメインまたはX.500スタイルのレルム名を使用したレルムの階層的配置です。このエンコード（Domain-X500-Compressと呼ばれる）について説明します。"
    },
    {
      "indent": 3,
      "text": "Realm names in the transited field are separated by a \",\". The \",\", \"\\\", trailing \".\"s, and leading spaces (\" \") are special characters, and if they are part of a realm name, they MUST be quoted in the transited field by preceding them with a \"\\\".",
      "ja": "輸送フィールドのレルム名は「、」で区切られています。「、」、「\\」、トレイル \"、「s」、および主要なスペース（\" \"）は特殊文字であり、それらが領域名の一部である場合、それらは彼らの前にそれらを前にすることによって輸送フィールドで引用されなければなりません」\\ \"。"
    },
    {
      "indent": 3,
      "text": "A realm name ending with a \".\" is interpreted as being prepended to the previous realm. For example, we can encode traversal of EDU, MIT.EDU, ATHENA.MIT.EDU, WASHINGTON.EDU, and CS.WASHINGTON.EDU as:",
      "ja": "「。」で終わるレルム名が終わります。以前の領域に加えられていると解釈されます。たとえば、Edu、Mit.edu、Athena.mit.edu、Washington.edu、Cs.washington.eduのトラバーサルを次のようにエンコードできます。"
    },
    {
      "indent": 6,
      "text": "\"EDU,MIT.,ATHENA.,WASHINGTON.EDU,CS.\".",
      "ja": "「Edu、Mit。、Athena。、Washington.edu、CS。」。"
    },
    {
      "indent": 3,
      "text": "Note that if either ATHENA.MIT.EDU, or CS.WASHINGTON.EDU were endpoints, they would not be included in this field, and we would have:",
      "ja": "Athena.mit.edu、またはcs.washington.eduがエンドポイントである場合、彼らはこの分野に含まれていないことに注意してください。"
    },
    {
      "indent": 6,
      "text": "\"EDU,MIT.,WASHINGTON.EDU\"",
      "ja": "「Edu、Mit。、Washington.edu」"
    },
    {
      "indent": 3,
      "text": "A realm name beginning with a \"/\" is interpreted as being appended to the previous realm. For the purpose of appending, the realm preceding the first listed realm is considered the null realm (\"\"). If a realm name beginning with a \"/\" is to stand by itself, then it SHOULD be preceded by a space (\" \"). For example, we can encode traversal of /COM/HP/APOLLO, /COM/HP, /COM, and /COM/DEC as:",
      "ja": "「/」で始まる領域名は、前の領域に追加されていると解釈されます。Appendingを目的として、最初にリストされた領域に先行する領域は、ヌル領域（ \"\"）と見なされます。「/」で始まるレルム名が単独で立つことである場合、それはスペース（ \"\"）が先行する必要があります。たとえば、 /com /hp /apollo、 /com /hp、 /com、および /com /decのトラバーサルをエンコードできます。"
    },
    {
      "indent": 6,
      "text": "\"/COM,/HP,/APOLLO, /COM/DEC\".",
      "ja": "「/com、/hp、/apollo、/com/dec」。"
    },
    {
      "indent": 3,
      "text": "As in the example above, if /COM/HP/APOLLO and /COM/DEC were endpoints, they would not be included in this field, and we would have:",
      "ja": "上記の例のように、/com/hp/apolloおよび/com/decがエンドポイントである場合、それらはこの分野に含まれていません。"
    },
    {
      "indent": 6,
      "text": "\"/COM,/HP\"",
      "ja": "「/com、/hp」"
    },
    {
      "indent": 3,
      "text": "A null subfield preceding or following a \",\" indicates that all realms between the previous realm and the next realm have been traversed. For the purpose of interpreting null subfields, the client's realm is considered to precede those in the transited field, and the server's realm is considered to follow them. Thus, \",\" means that all realms along the path between the client and the server have been traversed. \",EDU, /COM,\" means that all realms from the client's realm up to EDU (in a domain style hierarchy) have been traversed, and that everything from /COM down to the server's realm in an X.500 style has also been traversed. This could occur if the EDU realm in one hierarchy shares an inter-realm key directly with the /COM realm in another hierarchy.",
      "ja": "「前またはその後のヌルサブフィールド」は、前の領域と次の領域の間のすべての領域が横断されていることを示します。ヌルサブフィールドを解釈する目的で、クライアントの領域は通過フィールドの領域に先行すると考えられており、サーバーの領域はそれらに従うと考えられています。したがって、「」とは、クライアントとサーバーの間のパスに沿ったすべてのレルムが通過していることを意味します。「、edu、 /com」とは、クライアントの領域からEDUまでのすべての領域（ドメインスタイルの階層）が通過しており、 /comからサーバーの領域までのすべてがx.500スタイルであることを意味します。横断した。これは、ある階層内のEDU領域が別の階層の /comレルムと直接リアルム間キーを共有している場合に発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "3.3.4. Receipt of KRB_TGS_REP Message",
      "section_title": true,
      "ja": "3.3.4. krb_tgs_repメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When the KRB_TGS_REP is received by the client, it is processed in the same manner as the KRB_AS_REP processing described above. The primary difference is that the ciphertext part of the response must be decrypted using the sub-session key from the Authenticator, if it was specified in the request, or the session key from the TGT, rather than the client's secret key. The server name returned in the reply is the true principal name of the service.",
      "ja": "KRB_TGS_REPがクライアントによって受信されると、上記のKRB_AS_REP処理と同じ方法で処理されます。主な違いは、クライアントのシークレットキーではなく、リクエストで指定されている場合、またはリクエストで指定された場合、応答のサブセッションキーまたはTGTのセッションキーを使用して、応答の暗号文の部分を復号化する必要があることです。返信で返されるサーバー名は、サービスの真の主要名です。"
    },
    {
      "indent": 0,
      "text": "3.4. The KRB_SAFE Exchange",
      "section_title": true,
      "ja": "3.4. KRB_SAFE Exchange"
    },
    {
      "indent": 3,
      "text": "The KRB_SAFE message MAY be used by clients requiring the ability to detect modifications of messages they exchange. It achieves this by including a keyed collision-proof checksum of the user data and some control information. The checksum is keyed with an encryption key (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred).",
      "ja": "KRB_SAFEメッセージは、交換するメッセージの変更を検出する機能を必要とするクライアントが使用する場合があります。これは、ユーザーデータのキー付き衝突防止チェックサムといくつかの制御情報を含めることで実現します。チェックサムは、暗号化キー（通常、サブキーを介してネゴシエートされた最後のキー、または交渉が発生していない場合はセッションキー）でキーが付けられています。"
    },
    {
      "indent": 0,
      "text": "3.4.1. Generation of a KRB_SAFE Message",
      "section_title": true,
      "ja": "3.4.1. KRB_SAFEメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_SAFE message, it collects its data and the appropriate control information and computes a checksum over them. The checksum algorithm should be the keyed checksum mandated to be implemented along with the crypto system used for the sub-session or session key. The checksum is generated using the sub-session key, if present, or the session key. Some implementations use a different checksum algorithm for the KRB_SAFE messages, but doing so in an interoperable manner is not always possible.",
      "ja": "アプリケーションがkrb_safeメッセージの送信を希望する場合、データと適切な制御情報を収集し、それらのチェックサムを計算します。チェックサムアルゴリズムは、サブセッションまたはセッションキーに使用される暗号システムとともに実装されるように義務付けられているキー付きチェックサムである必要があります。チェックサムは、存在する場合はサブセッションキーまたはセッションキーを使用して生成されます。いくつかの実装は、krb_safeメッセージに異なるチェックサムアルゴリズムを使用していますが、相互運用可能な方法でそうすることは常に可能ではありません。"
    },
    {
      "indent": 3,
      "text": "The control information for the KRB_SAFE message includes both a timestamp and a sequence number. The designer of an application using the KRB_SAFE message MUST choose at least one of the two mechanisms. This choice SHOULD be based on the needs of the application protocol.",
      "ja": "KRB_SAFEメッセージの制御情報には、タイムスタンプとシーケンス番号の両方が含まれています。krb_safeメッセージを使用するアプリケーションの設計者は、2つのメカニズムの少なくとも1つを選択する必要があります。この選択は、アプリケーションプロトコルのニーズに基づいている必要があります。"
    },
    {
      "indent": 3,
      "text": "Sequence numbers are useful when all messages sent will be received by one's peer. Connection state is presently required to maintain the session key, so maintaining the next sequence number should not present an additional problem.",
      "ja": "シーケンス番号は、送信されたすべてのメッセージがピアによって受信される場合に役立ちます。現在、接続状態はセッションキーを維持するために必要であるため、次のシーケンス番号を維持することは追加の問題を提示しません。"
    },
    {
      "indent": 3,
      "text": "If the application protocol is expected to tolerate lost messages without their being resent, the use of the timestamp is the appropriate replay detection mechanism. Using timestamps is also the appropriate mechanism for multi-cast protocols in which all of one's peers share a common sub-session key, but some messages will be sent to a subset of one's peers.",
      "ja": "アプリケーションプロトコルが失われたメッセージをresすることなく容認することが期待される場合、タイムスタンプの使用は適切なリプレイ検出メカニズムです。タイムスタンプを使用することは、すべてのピアが共通のサブセッションキーを共有するマルチキャストプロトコルの適切なメカニズムでもありますが、一部のメッセージはピアのサブセットに送信されます。"
    },
    {
      "indent": 3,
      "text": "After computing the checksum, the client then transmits the information and checksum to the recipient in the message format specified in Section 5.6.1.",
      "ja": "チェックサムを計算した後、クライアントはセクション5.6.1で指定されたメッセージ形式で情報とチェックサムを受信者に送信します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Receipt of KRB_SAFE Message",
      "section_title": true,
      "ja": "3.4.2. krb_safeメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_SAFE message, it verifies it as follows. If any error occurs, an error code is reported for use by the application.",
      "ja": "アプリケーションがKRB_SAFEメッセージを受信すると、次のように検証します。エラーが発生した場合、アプリケーションで使用するためにエラーコードが報告されます。"
    },
    {
      "indent": 3,
      "text": "The message is first checked by verifying that the protocol version and type fields match the current version and KRB_SAFE, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application verifies that the checksum used is a collision-proof keyed checksum that uses keys compatible with the sub-session or session key as appropriate (or with the application key derived from the session or sub-session keys). If it is not, a KRB_AP_ERR_INAPP_CKSUM error is generated. The sender's address MUST be included in the control information; the recipient verifies that the operating system's report of the sender's address matches the sender's address in the message, and (if a recipient address is specified or the recipient requires an address) that one of the recipient's addresses appears as the recipient's address in the message. To work with network address translation, senders MAY use the directional address type specified in Section 8.1 for the sender address and not include recipient addresses. A failed match for either case generates a KRB_AP_ERR_BADADDR error. Then the timestamp and usec and/or the sequence number fields are checked. If timestamp and usec are expected and not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated. Timestamps are not required to be strictly ordered; they are only required to be in the skew window. If the server name, along with the client name, time, and microsecond fields from the Authenticator match any recently-seen (sent or received) such tuples, the KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included, or if a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error is generated. If neither a time-stamp and usec nor a sequence number is present, a KRB_AP_ERR_MODIFIED error is generated. Finally, the checksum is computed over the data and control information, and if it doesn't match the received checksum, a KRB_AP_ERR_MODIFIED error is generated.",
      "ja": "メッセージは、プロトコルバージョンとタイプフィールドがそれぞれ現在のバージョンとkrb_safeと一致することを確認することにより、最初にチェックされます。不一致はKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。アプリケーションは、使用されるチェックサムがサブセッションまたはセッションキーと互換性のあるキーを使用する衝突防止キー付きチェックサムであることを確認します（またはセッションまたはサブセッションキーから派生したアプリケーションキーと）。そうでない場合は、KRB_AP_ERR_INAPP_CKSUMエラーが生成されます。送信者のアドレスは、制御情報に含める必要があります。受信者は、送信者のアドレスのオペレーティングシステムのレポートがメッセージ内の送信者のアドレスと一致し、（受信者アドレスが指定されている場合、または受信者がアドレスを必要とする場合）受信者のアドレスの1つがメッセージ内の受信者のアドレスとして表示されることを確認します。ネットワークアドレスの変換を操作するために、送信者は、送信者アドレスのセクション8.1で指定された方向アドレスタイプを使用し、受信者アドレスを含めない場合があります。いずれかのケースで失敗した一致は、KRB_AP_ERR_BADADDRエラーを生成します。次に、タイムスタンプとUSECおよび/またはシーケンス番号フィールドがチェックされます。タイムスタンプとUSECが存在しない場合、または存在しない場合、または現在ではない場合は、KRB_AP_ERR_SKEWエラーが生成されます。タイムスタンプは、厳密に注文する必要はありません。それらは、スキューウィンドウにいるだけである必要があります。サーバー名が、Authenticatorのクライアント名、時間、およびマイクロ秒フィールドとともに、最近見られた（送信または受信）そのようなタプルと一致する場合、KRB_AP_ERR_REPEATエラーが生成されます。誤ったシーケンス番号が含まれている場合、またはシーケンス番号が予想されているが存在しない場合、KRB_AP_ERR_BADORDERエラーが生成されます。タイムスタンプとUSECまたはシーケンス番号が存在しない場合、KRB_AP_ERR_MODIFIEDエラーが生成されます。最後に、チェックサムはデータと制御情報を介して計算され、受信したチェックサムと一致しない場合、krb_ap_err_modifiedエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application is assured that the message was generated by its peer and was not modified in transit.",
      "ja": "すべてのチェックが成功した場合、アプリケーションはメッセージがピアによって生成され、輸送中に変更されていないことが保証されています。"
    },
    {
      "indent": 3,
      "text": "Implementations SHOULD accept any checksum algorithm they implement that has both adequate security and keys compatible with the sub-session or session key. Unkeyed or non-collision-proof checksums are not suitable for this use.",
      "ja": "実装は、サブセッションまたはセッションキーと互換性のある適切なセキュリティとキーの両方を備えた実装されたチェックサムアルゴリズムを受け入れる必要があります。キーのないまたは非衝突防止チェックサムは、この使用には適していません。"
    },
    {
      "indent": 0,
      "text": "3.5. The KRB_PRIV Exchange",
      "section_title": true,
      "ja": "3.5. KRB_PRIV Exchange"
    },
    {
      "indent": 3,
      "text": "The KRB_PRIV message MAY be used by clients requiring confidentiality and the ability to detect modifications of exchanged messages. It achieves this by encrypting the messages and adding control information.",
      "ja": "KRB_PRIVメッセージは、機密性と交換されたメッセージの変更を検出する機能を必要とするクライアントが使用する場合があります。これは、メッセージを暗号化し、制御情報を追加することで達成します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Generation of a KRB_PRIV Message",
      "section_title": true,
      "ja": "3.5.1. KRB_PRIVメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_PRIV message, it collects its data and the appropriate control information (specified in Section 5.7.1) and encrypts them under an encryption key (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred). As part of the control information, the client MUST choose to use either a timestamp or a sequence number (or both); see the discussion in Section 3.4.1 for guidelines on which to use. After the user data and control information are encrypted, the client transmits the ciphertext and some 'envelope' information to the recipient.",
      "ja": "アプリケーションがkrb_privメッセージを送信したい場合、データと適切な制御情報（セクション5.7.1で指定）を収集し、暗号化キー（通常はサブキーを介してネゴシエートされた最後のキー、またはネゴシエーションがない場合はセッションキーを暗号化します。発生した）。制御情報の一部として、クライアントはタイムスタンプまたはシーケンス番号（またはその両方）のいずれかを使用することを選択する必要があります。使用するガイドラインについては、セクション3.4.1の説明を参照してください。ユーザーデータと制御情報が暗号化された後、クライアントはciphertextといくつかの「エンベロープ」情報を受信者に送信します。"
    },
    {
      "indent": 0,
      "text": "3.5.2. Receipt of KRB_PRIV Message",
      "section_title": true,
      "ja": "3.5.2. krb_privメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_PRIV message, it verifies it as follows. If any error occurs, an error code is reported for use by the application.",
      "ja": "アプリケーションがKRB_PRIVメッセージを受信すると、次のように検証します。エラーが発生した場合、アプリケーションで使用するためにエラーコードが報告されます。"
    },
    {
      "indent": 3,
      "text": "The message is first checked by verifying that the protocol version and type fields match the current version and KRB_PRIV, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application then decrypts the ciphertext and processes the resultant plaintext. If decryption shows that the data has been modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.",
      "ja": "メッセージは、プロトコルバージョンとタイプフィールドがそれぞれ現在のバージョンとkrb_privと一致することを確認することにより、最初にチェックされます。不一致はKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。次に、アプリケーションは暗号文を復号化し、結果のプレーンテキストを処理します。復号化がデータが変更されたことを示している場合、KRB_AP_ERR_BAD_INTERITYエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "The sender's address MUST be included in the control information; the recipient verifies that the operating system's report of the sender's address matches the sender's address in the message. If a recipient address is specified or the recipient requires an address, then one of the recipient's addresses MUST also appear as the recipient's address in the message. Where a sender's or receiver's address might not otherwise match the address in a message because of network address translation, an application MAY be written to use addresses of the directional address type in place of the actual network address.",
      "ja": "送信者のアドレスは、制御情報に含める必要があります。受信者は、送信者のアドレスのオペレーティングシステムのレポートがメッセージ内の送信者のアドレスと一致することを確認します。受信者アドレスが指定されている場合、または受信者がアドレスを必要とする場合、受信者のアドレスの1つもメッセージ内の受信者のアドレスとして表示される必要があります。ネットワークアドレスの変換により、送信者または受信者のアドレスがメッセージのアドレスと一致しない場合がある場合、実際のネットワークアドレスの代わりに方向アドレスタイプのアドレスを使用するためにアプリケーションを書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "A failed match for either case generates a KRB_AP_ERR_BADADDR error. To work with network address translation, implementations MAY use the directional address type defined in Section 7.1 for the sender address and include no recipient address.",
      "ja": "いずれかのケースで失敗した一致は、KRB_AP_ERR_BADADDRエラーを生成します。ネットワークアドレスの変換で動作するために、実装は、送信者アドレスのセクション7.1で定義された方向アドレスタイプを使用し、受信者アドレスを含めない場合があります。"
    },
    {
      "indent": 3,
      "text": "Next the timestamp and usec and/or the sequence number fields are checked. If timestamp and usec are expected and not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated. If the server name, along with the client name, time, and microsecond fields from the Authenticator match any such recently-seen tuples, the KRB_AP_ERR_REPEAT error is generated. If an incorrect sequence number is included, or if a sequence number is expected but not present, the KRB_AP_ERR_BADORDER error is generated. If neither a time-stamp and usec nor a sequence number is present, a KRB_AP_ERR_MODIFIED error is generated.",
      "ja": "次に、タイムスタンプとUSECおよび/またはシーケンス番号フィールドがチェックされます。タイムスタンプとUSECが存在しない場合、または存在しない場合、または現在ではない場合は、KRB_AP_ERR_SKEWエラーが生成されます。サーバー名が、認証機のクライアント名、時間、およびマイクロ秒フィールドとともに、そのような最近見られるタプルと一致する場合、KRB_AP_ERR_REPEATエラーが生成されます。誤ったシーケンス番号が含まれている場合、またはシーケンス番号が予想されているが存在しない場合、KRB_AP_ERR_BADORDERエラーが生成されます。タイムスタンプとUSECまたはシーケンス番号が存在しない場合、KRB_AP_ERR_MODIFIEDエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application can assume the message was generated by its peer and was securely transmitted (without intruders seeing the unencrypted contents).",
      "ja": "すべてのチェックが成功した場合、アプリケーションはメッセージがピアによって生成され、安全に送信されたと想定できます（侵入者が暗号化されていない内容を見ることなく）。"
    },
    {
      "indent": 0,
      "text": "3.6. The KRB_CRED Exchange",
      "section_title": true,
      "ja": "3.6. KRB_CRED Exchange"
    },
    {
      "indent": 3,
      "text": "The KRB_CRED message MAY be used by clients requiring the ability to send Kerberos credentials from one host to another. It achieves this by sending the tickets together with encrypted data containing the session keys and other information associated with the tickets.",
      "ja": "KRB_CREDメッセージは、Kerberosの資格情報をあるホストから別のホストに送信する機能を必要とするクライアントが使用する場合があります。これは、チケットとチケットに関連付けられたその他の情報を含む暗号化されたデータとチケットを一緒に送信することで実現します。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Generation of a KRB_CRED Message",
      "section_title": true,
      "ja": "3.6.1. KRB_CREDメッセージの生成"
    },
    {
      "indent": 3,
      "text": "When an application wishes to send a KRB_CRED message, it first (using the KRB_TGS exchange) obtains credentials to be sent to the remote host. It then constructs a KRB_CRED message using the ticket or tickets so obtained, placing the session key needed to use each ticket in the key field of the corresponding KrbCredInfo sequence of the encrypted part of the KRB_CRED message.",
      "ja": "アプリケーションがKRB_CREDメッセージの送信を希望する場合、最初に（KRB_TGS Exchangeを使用）、リモートホストに送信される資格情報を取得します。次に、取得したチケットまたはチケットを使用してKRB_CREDメッセージを作成し、KRB_CREDメッセージの暗号化された部分の対応するKRBCREDINFOシーケンスのキーフィールドに各チケットを使用するために必要なセッションキーを配置します。"
    },
    {
      "indent": 3,
      "text": "Other information associated with each ticket and obtained during the KRB_TGS exchange is also placed in the corresponding KrbCredInfo sequence in the encrypted part of the KRB_CRED message. The current time and, if they are specifically required by the application, the nonce, s-address, and r-address fields are placed in the encrypted part of the KRB_CRED message, which is then encrypted under an encryption key previously exchanged in the KRB_AP exchange (usually the last key negotiated via subkeys, or the session key if no negotiation has occurred).",
      "ja": "各チケットに関連付けられ、KRB_TGS交換中に取得されたその他の情報は、KRB_CREDメッセージの暗号化された部分の対応するKRBCREDINFOシーケンスにも配置されます。現在の時刻、およびそれらがアプリケーションで具体的に必要な場合、NonCe、S-Address、およびR-Addressフィールドは、KRB_CREDメッセージの暗号化された部分に配置されます。Exchange（通常、サブキーを介して交渉された最後のキー、または交渉が行われていない場合はセッションキー）。"
    },
    {
      "indent": 3,
      "text": "Implementation note: When constructing a KRB_CRED message for inclusion in a GSSAPI initial context token, the MIT implementation of Kerberos will not encrypt the KRB_CRED message if the session key is a DES or triple DES key. For interoperability with MIT, the Microsoft implementation will not encrypt the KRB_CRED in a GSSAPI token if it is using a DES session key. Starting at version 1.2.5, MIT Kerberos can receive and decode either encrypted or unencrypted KRB_CRED tokens in the GSSAPI exchange. The Heimdal implementation of Kerberos can also accept either encrypted or unencrypted KRB_CRED messages. Since the KRB_CRED message in a GSSAPI token is encrypted in the authenticator, the MIT behavior does not present a security problem, although it is a violation of the Kerberos specification.",
      "ja": "実装注：GSSAPI初期コンテキストトークンに含めるためのKRB_CREDメッセージを作成する場合、セッションキーがDESまたはTRIPLE DEキーの場合、KerberosのMIT実装はKRB_CREDメッセージを暗号化しません。MITとの相互運用性のために、Microsoftの実装は、DESセッションキーを使用している場合、GSSAPIトークンでKRB_CREDを暗号化しません。バージョン1.2.5から、MIT Kerberosは、GSSAPI Exchangeで暗号化または暗号化されていないKRB_CREDトークンのいずれかを受信およびデコードできます。KerberosのHeimdal実装は、暗号化されたKRB_CREDメッセージの暗号化または非暗号化されていないメッセージのいずれかを受け入れることもできます。GSSAPIトークンのKRB_CREDメッセージは認証器で暗号化されているため、MITの動作はセキュリティの問題を提示しませんが、Kerberosの仕様に違反しています。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Receipt of KRB_CRED Message",
      "section_title": true,
      "ja": "3.6.2. KRB_CREDメッセージの受信"
    },
    {
      "indent": 3,
      "text": "When an application receives a KRB_CRED message, it verifies it. If any error occurs, an error code is reported for use by the application. The message is verified by checking that the protocol version and type fields match the current version and KRB_CRED, respectively. A mismatch generates a KRB_AP_ERR_BADVERSION or KRB_AP_ERR_MSG_TYPE error. The application then decrypts the ciphertext and processes the resultant plaintext. If decryption shows the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.",
      "ja": "アプリケーションがKRB_CREDメッセージを受信すると、検証します。エラーが発生した場合、アプリケーションで使用するためにエラーコードが報告されます。このメッセージは、プロトコルバージョンとタイプフィールドが現在のバージョンとそれぞれkrb_credと一致していることを確認することにより検証されます。不一致はKRB_AP_ERR_BADVERSIONまたはKRB_AP_ERR_MSG_TYPEエラーを生成します。次に、アプリケーションは暗号文を復号化し、結果のプレーンテキストを処理します。復号化が変更されたデータが示されている場合、krb_ap_err_bad_integrityエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If present or required, the recipient MAY verify that the operating system's report of the sender's address matches the sender's address in the message, and that one of the recipient's addresses appears as the recipient's address in the message. The address check does not provide any added security, since the address, if present, has already been checked in the KRB_AP_REQ message and there is not any benefit to be gained by an attacker in reflecting a KRB_CRED message back to its originator. Thus, the recipient MAY ignore the address even if it is present in order to work better in Network Address Translation (NAT) environments. A failed match for either case generates a KRB_AP_ERR_BADADDR error. Recipients MAY skip the address check, as the KRB_CRED message cannot generally be reflected back to the originator. The timestamp and usec fields (and the nonce field, if required) are checked next. If the timestamp and usec are not present, or if they are present but not current, the KRB_AP_ERR_SKEW error is generated.",
      "ja": "存在または必要な場合、受信者は、送信者のアドレスのオペレーティングシステムのレポートがメッセージ内の送信者のアドレスと一致し、受信者のアドレスの1つがメッセージ内の受信者のアドレスとして表示されることを確認できます。アドレスチェックは、存在する場合はkrb_ap_reqメッセージで既にチェックされており、攻撃者がKRB_CREDメッセージをそのオリジネーターに反映する際に得られる利点はないため、追加のセキュリティは提供されません。したがって、受信者は、ネットワークアドレス変換（NAT）環境でより良く動作するために存在する場合でも、アドレスを無視する場合があります。いずれかのケースで失敗した一致は、KRB_AP_ERR_BADADDRエラーを生成します。KRB_CREDメッセージを一般に反映して元のオリジネーターに戻すことができないため、受信者はアドレスチェックをスキップする場合があります。次に、タイムスタンプとUSECフィールド（および必要に応じて非CEフィールド）がチェックされます。タイムスタンプとUSECが存在しない場合、またはそれらが存在しているが現在ではない場合、KRB_AP_ERR_SKEWエラーが生成されます。"
    },
    {
      "indent": 3,
      "text": "If all the checks succeed, the application stores each of the new tickets in its credentials cache together with the session key and other information in the corresponding KrbCredInfo sequence from the encrypted part of the KRB_CRED message.",
      "ja": "すべてのチェックが成功した場合、アプリケーションは、CRB_CREDメッセージの暗号化された部分から、セッションキーや対応するKRBCREDINFOシーケンスのセッションキーおよびその他の情報とともに、その新しいチケットのそれぞれをキャッシュに保存します。"
    },
    {
      "indent": 0,
      "text": "3.7. User-to-User Authentication Exchanges",
      "section_title": true,
      "ja": "3.7. ユーザー間認証交換"
    },
    {
      "indent": 3,
      "text": "User-to-User authentication provides a method to perform authentication when the verifier does not have a access to long-term service key. This might be the case when running a server (for example, a window server) as a user on a workstation. In such cases, the server may have access to the TGT obtained when the user logged in to the workstation, but because the server is running as an unprivileged user, it might not have access to system keys. Similar situations may arise when running peer-to-peer applications.",
      "ja": "ユーザーからユーザーの認証は、検証者が長期的なサービスキーにアクセスできない場合、認証を実行する方法を提供します。これは、ワークステーションでユーザーとしてサーバー（たとえば、ウィンドウサーバー）を実行する場合に当てはまる可能性があります。そのような場合、サーバーは、ユーザーがワークステーションにログインしたときに取得されたTGTにアクセスできる場合がありますが、サーバーが恵まれないユーザーとして実行されているため、システムキーにアクセスできない場合があります。ピアツーピアアプリケーションを実行すると、同様の状況が発生する可能性があります。"
    },
    {
      "indent": 29,
      "text": "Summary",
      "ja": "概要"
    },
    {
      "indent": 7,
      "text": "Message direction                    Message type     Sections\n0. Message from application server   Not specified\n1. Client to Kerberos                KRB_TGS_REQ      3.3 & 5.4.1\n2. Kerberos to client                KRB_TGS_REP or   3.3 & 5.4.2\n                                     KRB_ERROR        5.9.1\n3. Client to application server      KRB_AP_REQ       3.2 & 5.5.1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "To address this problem, the Kerberos protocol allows the client to request that the ticket issued by the KDC be encrypted using a session key from a TGT issued to the party that will verify the authentication. This TGT must be obtained from the verifier by means of an exchange external to the Kerberos protocol, usually as part of the application protocol. This message is shown in the summary above as message 0. Note that because the TGT is encrypted in the KDC's secret key, it cannot be used for authentication without possession of the corresponding secret key. Furthermore, because the verifier does not reveal the corresponding secret key, providing a copy of the verifier's TGT does not allow impersonation of the verifier.",
      "ja": "この問題に対処するために、Kerberosプロトコルにより、クライアントは、認証を確認するTGTから発行されたTGTのセッションキーを使用してKDCによって発行されたチケットを暗号化することを要求できます。このTGTは、通常、アプリケーションプロトコルの一部として、Kerberosプロトコルの外部の交換によって検証者から取得する必要があります。このメッセージは、上記の概要にメッセージ0として表示されます。TGTはKDCのシークレットキーに暗号化されているため、対応するシークレットキーを所有せずに認証に使用できないことに注意してください。さらに、検証者は対応する秘密の鍵を明らかにしないため、検証剤のTGTのコピーを提供しても、検証剤のなりすましを許可しません。"
    },
    {
      "indent": 3,
      "text": "Message 0 in the table above represents an application-specific negotiation between the client and server, at the end of which both have determined that they will use user-to-user authentication, and the client has obtained the server's TGT.",
      "ja": "上記のテーブルのメッセージ0は、クライアントとサーバーの間のアプリケーション固有のネゴシエーションを表します。最後に、どちらもユーザーからユーザーへの認証を使用すると判断し、クライアントはサーバーのTGTを取得しました。"
    },
    {
      "indent": 3,
      "text": "Next, the client includes the server's TGT as an additional ticket in its KRB_TGS_REQ request to the KDC (message 1 in the table above) and specifies the ENC-TKT-IN-SKEY option in its request.",
      "ja": "次に、クライアントは、KRB_TGS_REQリクエストのKDC（上記の表のメッセージ1）の追加チケットとしてサーバーのTGTを含め、リクエストでEnc-TKT-in-Skeyオプションを指定します。"
    },
    {
      "indent": 3,
      "text": "If validated according to the instructions in Section 3.3.3, the application ticket returned to the client (message 2 in the table above) will be encrypted using the session key from the additional ticket and the client will note this when it uses or stores the application ticket.",
      "ja": "セクション3.3.3の指示に従って検証された場合、クライアントに返されるアプリケーションチケット（上記の表のメッセージ2）は、追加チケットのセッションキーを使用して暗号化され、クライアントはこれに注意してください。アプリケーションチケット。"
    },
    {
      "indent": 3,
      "text": "When contacting the server using a ticket obtained for user-to-user authentication (message 3 in the table above), the client MUST specify the USE-SESSION-KEY flag in the ap-options field. This tells the application server to use the session key associated with its TGT to decrypt the server ticket provided in the application request.",
      "ja": "ユーザーからユーザーの認証のために取得したチケットを使用してサーバーに連絡する場合（上記の表のメッセージ3）、クライアントはAPオプションフィールドの使用セッションキーフラグを指定する必要があります。これにより、アプリケーションサーバーは、TGTに関連付けられたセッションキーを使用して、アプリケーションリクエストで提供されるサーバーチケットを復号化するように指示します。"
    },
    {
      "indent": 0,
      "text": "4. Encryption and Checksum Specifications",
      "section_title": true,
      "ja": "4. 暗号化とチェックサムの仕様"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocols described in this document are designed to encrypt messages of arbitrary sizes, using stream or block encryption ciphers. Encryption is used to prove the identities of the network entities participating in message exchanges. The Key Distribution Center for each realm is trusted by all principals registered in that realm to store a secret key in confidence. Proof of knowledge of this secret key is used to verify the authenticity of a principal.",
      "ja": "このドキュメントで説明されているKerberosプロトコルは、ストリームまたはブロック暗号化の暗号を使用して、任意のサイズのメッセージを暗号化するように設計されています。暗号化は、メッセージ交換に参加するネットワークエンティティのIDを証明するために使用されます。各領域のキー流通センターは、その領域に登録されているすべてのプリンシパルによって信頼され、秘密の鍵を自信を持って保存します。この秘密の鍵の知識の証明は、プリンシパルの信ity性を検証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The KDC uses the principal's secret key (in the AS exchange) or a shared session key (in the TGS exchange) to encrypt responses to ticket requests; the ability to obtain the secret key or session key implies the knowledge of the appropriate keys and the identity of the KDC. The ability of a principal to decrypt the KDC response and to present a Ticket and a properly formed Authenticator (generated with the session key from the KDC response) to a service verifies the identity of the principal; likewise the ability of the service to extract the session key from the Ticket and to prove its knowledge thereof in a response verifies the identity of the service.",
      "ja": "KDCは、プリンシパルの秘密キー（AS Exchange）または共有セッションキー（TGS Exchange）を使用して、チケットリクエストに対する応答を暗号化します。シークレットキーまたはセッションキーを取得する機能は、適切なキーの知識とKDCのアイデンティティを意味します。KDC応答を復号化し、チケットと適切に形成された認証機（KDC応答からセッションキーで生成された）をサービスに提示する能力は、プリンシパルのIDを検証します。同様に、セッションキーをチケットから抽出し、応答でその知識を証明するサービスの能力は、サービスのIDを検証します。"
    },
    {
      "indent": 3,
      "text": "[RFC3961] defines a framework for defining encryption and checksum mechanisms for use with Kerberos. It also defines several such mechanisms, and more may be added in future updates to that document.",
      "ja": "[RFC3961]は、Kerberosで使用するための暗号化とチェックサムメカニズムを定義するためのフレームワークを定義します。また、そのようなメカニズムをいくつか定義し、そのドキュメントの将来の更新でさらに追加される可能性があります。"
    },
    {
      "indent": 3,
      "text": "The string-to-key operation provided by [RFC3961] is used to produce a long-term key for a principal (generally for a user). The default salt string, if none is provided via pre-authentication data, is the concatenation of the principal's realm and name components, in order, with no separators. Unless it is indicated otherwise, the default string-to-key opaque parameter set as defined in [RFC3961] is used.",
      "ja": "[RFC3961]によって提供される文字列間操作は、プリンシパル（一般にユーザー向け）に長期キーを生成するために使用されます。デフォルトの塩文字列は、認証前のデータを介して提供されていない場合、セパレータなしの順番で、プリンシパルの領域と名前コンポーネントの連結です。特に示されていない限り、[RFC3961]で定義されているデフォルトの文字列からキーの不透明パラメーターセットが使用されます。"
    },
    {
      "indent": 3,
      "text": "Encrypted data, keys, and checksums are transmitted using the EncryptedData, EncryptionKey, and Checksum data objects defined in Section 5.2.9. The encryption, decryption, and checksum operations described in this document use the corresponding encryption, decryption, and get_mic operations described in [RFC3961], with implicit \"specific key\" generation using the \"key usage\" values specified in the description of each EncryptedData or Checksum object to vary the key for each operation. Note that in some cases, the value to be used is dependent on the method of choosing the key or the context of the message.",
      "ja": "暗号化されたデータ、キー、およびチェックサムは、セクション5.2.9で定義されている暗号化、encryptionKey、およびチェックサムデータオブジェクトを使用して送信されます。このドキュメントで説明されている暗号化、復号化、およびチェックサムの操作は、[RFC3961]で説明されている[RFC3961]で説明されている[キー使用]値を使用して暗黙の「特定のキー」生成を使用して、対応する暗号化、復号化、およびGET_MIC操作を使用します。チェックサムオブジェクトは、操作ごとにキーを変更します。場合によっては、使用する値は、メッセージのキーまたはコンテキストを選択する方法に依存していることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Key usages are unsigned 32-bit integers; zero is not permitted. The key usage values for encrypting or checksumming Kerberos messages are indicated in Section 5 along with the message definitions. The key usage values 512-1023 are reserved for uses internal to a Kerberos implementation. (For example, seeding a pseudo-random number generator with a value produced by encrypting something with a session key and a key usage value not used for any other purpose.) Key usage values between 1024 and 2047 (inclusive) are reserved for application use; applications SHOULD use even values for encryption and odd values for checksums within this range. Key usage values are also summarized in a table in Section 7.5.1.",
      "ja": "主要な使用法は、署名されていない32ビット整数です。ゼロは許可されていません。暗号化またはチェックサムのKerberosメッセージの主要な使用値は、メッセージの定義とともにセクション5に示されています。主要な使用値512-1023は、Kerberosの実装の内部の使用のために予約されています。（たとえば、セッションキーを使用して何かを暗号化することによって生成される値で擬似ランダム数ジェネレーターをシードし、他の目的には使用されていないキー使用値を使用します。）1024から2047（包括的）の間のキー使用値は、アプリケーション使用のために予約されています;アプリケーションは、暗号化の値とこの範囲内のチェックサムに奇数値を使用する必要があります。主要な使用値は、セクション7.5.1の表にも要約されています。"
    },
    {
      "indent": 3,
      "text": "There might exist other documents that define protocols in terms of the RFC 1510 encryption types or checksum types. These documents would not know about key usages. In order that these specifications continue to be meaningful until they are updated, if no key usage values are specified, then key usages 1024 and 1025 must be used to derive keys for encryption and checksums, respectively. (This does not apply to protocols that do their own encryption independent of this framework, by directly using the key resulting from the Kerberos authentication exchange.) New protocols defined in terms of the Kerberos encryption and checksum types SHOULD use their own key usage values.",
      "ja": "RFC 1510暗号化タイプまたはチェックサムタイプの観点からプロトコルを定義する他のドキュメントが存在する可能性があります。これらのドキュメントでは、主要な使用法については知りません。これらの仕様が更新されるまで意味があり続けるために、キー使用値が指定されていない場合、それぞれ暗号化とチェックサムのキーを導き出すためにキー使用量1024と1025を使用する必要があります。（これは、Kerberos認証交換から生じるキーを直接使用することにより、このフレームワークとは無関係に独自の暗号化を行うプロトコルには適用されません。）Kerberosの暗号化とチェックサムタイプに関して定義された新しいプロトコルは、独自のキー使用値を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless it is indicated otherwise, no cipher state chaining is done from one encryption operation to another.",
      "ja": "特に示されていない限り、暗号化操作から別の暗号化操作までは暗号状態のチェーンは行われません。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Although it is not recommended, some application protocols will continue to use the key data directly, even if only in currently existing protocol specifications. An implementation intended to support general Kerberos applications may therefore need to make key data available, as well as the attributes and operations described in [RFC3961]. One of the more common reasons for directly performing encryption is direct control over negotiation and selection of a \"sufficiently strong\" encryption algorithm (in the context of a given application). Although Kerberos does not directly provide a facility for negotiating encryption types between the application client and server, there are approaches for using Kerberos to facilitate this negotiation. For example, a client may request only \"sufficiently strong\" session key types from the KDC and expect that any type returned by the KDC will be understood and supported by the application server.",
      "ja": "実装注：推奨されませんが、一部のアプリケーションプロトコルは、現在既存のプロトコル仕様でのみであっても、キーデータを直接使用し続けます。したがって、一般的なKerberosアプリケーションをサポートすることを目的とした実装は、[RFC3961]に記載されている属性と操作を利用可能にする必要がある場合があります。暗号化を直接実行するより一般的な理由の1つは、「十分に強力な」暗号化アルゴリズムの交渉と選択を直接制御することです（特定のアプリケーションのコンテキストで）。Kerberosは、アプリケーションクライアントとサーバーの間で暗号化タイプを交渉するための施設を直接提供していませんが、Kerberosを使用してこの交渉を促進するためのアプローチがあります。たとえば、クライアントは、KDCに「十分に強力な」セッションキータイプのみを要求し、KDCによって返された任意のタイプがアプリケーションサーバーによって理解され、サポートされることを期待することができます。"
    },
    {
      "indent": 0,
      "text": "5. Message Specifications",
      "section_title": true,
      "ja": "5. メッセージ仕様"
    },
    {
      "indent": 3,
      "text": "The ASN.1 collected here should be identical to the contents of Appendix A. In the case of a conflict, the contents of Appendix A shall take precedence.",
      "ja": "ここで収集されたASN.1は、付録Aの内容と同一である必要があります。紛争の場合、付録Aの内容が優先されるものとします。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol is defined here in terms of Abstract Syntax Notation One (ASN.1) [X680], which provides a syntax for specifying both the abstract layout of protocol messages as well as their encodings. Implementors not utilizing an existing ASN.1 compiler or support library are cautioned to understand the actual ASN.1 specification thoroughly in order to ensure correct implementation behavior. There is more complexity in the notation than is immediately obvious, and some tutorials and guides to ASN.1 are misleading or erroneous.",
      "ja": "Kerberosプロトコルは、ここでは、プロトコルメッセージの抽象レイアウトとそのエンコードの両方を指定するための構文を提供する抽象的構文表記1（asn.1）[x680]の観点から定義されています。既存のASN.1コンパイラまたはサポートライブラリを使用していない実装者は、正しい実装動作を確保するために、実際のASN.1仕様を徹底的に理解するよう警告されています。表記には、すぐに明白であるよりも複雑さがあり、ASN.1へのいくつかのチュートリアルとガイドは誤解を招くまたは誤っています。"
    },
    {
      "indent": 3,
      "text": "Note that in several places, changes to abstract types from RFC 1510 have been made. This is in part to address widespread assumptions that various implementors have made, in some cases resulting in unintentional violations of the ASN.1 standard. These are clearly flagged where they occur. The differences between the abstract types in RFC 1510 and abstract types in this document can cause incompatible encodings to be emitted when certain encoding rules, e.g., the Packed Encoding Rules (PER), are used. This theoretical incompatibility should not be relevant for Kerberos, since Kerberos explicitly specifies the use of the Distinguished Encoding Rules (DER). It might be an issue for protocols seeking to use Kerberos types with other encoding rules. (This practice is not recommended.) With very few exceptions (most notably the usages of BIT STRING), the encodings resulting from using the DER remain identical between the types defined in RFC 1510 and the types defined in this document.",
      "ja": "いくつかの場所では、RFC 1510の抽象タイプの変更が行われたことに注意してください。これは、さまざまな実装者が行った広範な仮定に対処することであり、場合によってはASN.1基準の意図しない違反をもたらします。これらは、発生する場所で明確にフラグが付けられています。RFC 1510の抽象タイプとこのドキュメントの抽象型の違いは、特定のエンコードルール（たとえば、梱包されたエンコードルール（PER）が使用されると、互換性のないエンコーディングが放出される可能性があります。Kerberosは、識別されたエンコーディングルール（DER）の使用を明示的に指定するため、この理論的互換性はKerberosに関連するものではありません。他のエンコードルールでKerberosタイプを使用しようとするプロトコルにとっては問題かもしれません。（このプラクティスは推奨されません。）例外はほとんどありません（特にビット文字列の使用法）、DERを使用することから生じるエンコーディングは、RFC 1510で定義されているタイプとこのドキュメントで定義されているタイプの間で同一のままです。"
    },
    {
      "indent": 3,
      "text": "The type definitions in this section assume an ASN.1 module\ndefinition of the following form:\n   KerberosV5Spec2 {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2) modules(4) krb5spec2(2)\n} DEFINITIONS EXPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- rest of definitions here",
      "ja": " - ここでの残りの定義"
    },
    {
      "indent": 3,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 3,
      "text": "This specifies that the tagging context for the module will be explicit and non-automatic.",
      "ja": "これは、モジュールのタグ付けコンテキストが明示的で非自動的であることを指定します。"
    },
    {
      "indent": 3,
      "text": "Note that in some other publications (such as [RFC1510] and [RFC1964]), the \"dod\" portion of the object identifier is erroneously specified as having the value \"5\". In the case of RFC 1964, use of the \"correct\" OID value would result in a change in the wire protocol; therefore, it remains unchanged for now.",
      "ja": "他のいくつかの出版物（[RFC1510]や[RFC1964]など）では、オブジェクト識別子の「DOD」部分は、値「5」を持っていると誤って指定されていることに注意してください。RFC 1964の場合、「正しい」OID値を使用すると、ワイヤプロトコルが変化します。したがって、今のところ変更されていません。"
    },
    {
      "indent": 3,
      "text": "Note that elsewhere in this document, nomenclature for various message types is inconsistent, but it largely follows C language conventions, including use of underscore (_) characters and all-caps spelling of names intended to be numeric constants. Also, in some places, identifiers (especially those referring to constants) are written in all-caps in order to distinguish them from surrounding explanatory text.",
      "ja": "このドキュメントの他の場所では、さまざまなメッセージタイプの命名法は一貫していませんが、主に、アンダースコア（_）文字の使用や数値定数であることを目的とした名前のすべてのキャップスペルを含むC言語規則に従っています。また、一部の場所では、識別子（特に定数を参照するもの）は、周囲の説明テキストと区別するためにすべてのキャップで記述されています。"
    },
    {
      "indent": 3,
      "text": "The ASN.1 notation does not permit underscores in identifiers, so in actual ASN.1 definitions, underscores are replaced with hyphens (-). Additionally, structure member names and defined values in ASN.1 MUST begin with a lowercase letter, whereas type names MUST begin with an uppercase letter.",
      "ja": "ASN.1表記では、識別子のアンダースコアが許可されていないため、実際のASN.1の定義では、アンダースコアはハイフン（ - ）に置き換えられます。さらに、asn.1の構造メンバー名と定義された値は、小文字で開始する必要がありますが、タイプ名は大文字で開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Specific Compatibility Notes on ASN.1",
      "section_title": true,
      "ja": "5.1. ASN.1に関する特定の互換性ノート"
    },
    {
      "indent": 3,
      "text": "For compatibility purposes, implementors should heed the following specific notes regarding the use of ASN.1 in Kerberos. These notes do not describe deviations from standard usage of ASN.1. The purpose of these notes is instead to describe some historical quirks and non-compliance of various implementations, as well as historical ambiguities, which, although they are valid ASN.1, can lead to confusion during implementation.",
      "ja": "互換性のために、実装者は、KerberosでのASN.1の使用に関する次の特定のメモに留意する必要があります。これらのメモは、asn.1の標準使用からの逸脱を説明していません。これらのメモの目的は、代わりに、いくつかの歴史的な癖とさまざまな実装の不遵守、ならびに歴史的なあいまいさを説明することです。"
    },
    {
      "indent": 0,
      "text": "5.1.1. ASN.1 Distinguished Encoding Rules",
      "section_title": true,
      "ja": "5.1.1. ASN.1特別なエンコードルール"
    },
    {
      "indent": 3,
      "text": "The encoding of Kerberos protocol messages shall obey the Distinguished Encoding Rules (DER) of ASN.1 as described in [X690]. Some implementations (believed primarily to be those derived from DCE 1.1 and earlier) are known to use the more general Basic Encoding Rules (BER); in particular, these implementations send indefinite encodings of lengths. Implementations MAY accept such encodings in the interest of backward compatibility, though implementors are warned that decoding fully-general BER is fraught with peril.",
      "ja": "Kerberosプロトコルメッセージのエンコーディングは、[x690]で説明されているように、ASN.1の顕著なエンコードルール（der）に従うものとします。いくつかの実装（主にDCE 1.1以前から派生したものであると考えられている）は、より一般的な基本エンコードルール（BER）を使用することが知られています。特に、これらの実装は、長さの無期限のエンコーディングを送信します。実装は、後方互換性のためにそのようなエンコーディングを受け入れる可能性がありますが、実装者は、完全な将軍のBERのデコードに危険が悩まされていると警告されています。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Optional Integer Fields",
      "section_title": true,
      "ja": "5.1.2. オプションの整数フィールド"
    },
    {
      "indent": 3,
      "text": "Some implementations do not internally distinguish between an omitted optional integer value and a transmitted value of zero. The places in the protocol where this is relevant include various microseconds fields, nonces, and sequence numbers. Implementations SHOULD treat omitted optional integer values as having been transmitted with a value of zero, if the application is expecting this.",
      "ja": "一部の実装では、省略されたオプションの整数値とゼロの送信値を内部的に区別しません。これが関連するプロトコル内の場所には、さまざまなマイクロ秒フィールド、ノンセ、シーケンス番号が含まれます。アプリケーションがこれを期待している場合、実装は省略された整数値をゼロで送信したとして省略された整理値を扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Empty SEQUENCE OF Types",
      "section_title": true,
      "ja": "5.1.3. タイプの空のシーケンス"
    },
    {
      "indent": 3,
      "text": "There are places in the protocol where a message contains a SEQUENCE OF type as an optional member. This can result in an encoding that contains an empty SEQUENCE OF encoding. The Kerberos protocol does not semantically distinguish between an absent optional SEQUENCE OF type and a present optional but empty SEQUENCE OF type. Implementations SHOULD NOT send empty SEQUENCE OF encodings that are marked OPTIONAL, but SHOULD accept them as being equivalent to an omitted OPTIONAL type. In the ASN.1 syntax describing Kerberos messages, instances of these problematic optional SEQUENCE OF types are indicated with a comment.",
      "ja": "プロトコルには、メッセージにオプションのメンバーとしてタイプのシーケンスが含まれる場所があります。これにより、エンコードの空のシーケンスを含むエンコードが発生する可能性があります。Kerberosプロトコルは、タイプの存在しないオプションのシーケンスと現在のオプションであるが空のタイプのシーケンスを意味的に区別しません。実装は、オプションのマークされたエンコードの空のシーケンスを送信しないでください。ただし、省略されたオプションのタイプに相当するものとしてそれらを受け入れる必要があります。Kerberosメッセージを説明するASN.1構文では、これらの問題のあるオプションのタイプのインスタンスがコメントで示されています。"
    },
    {
      "indent": 0,
      "text": "5.1.4. Unrecognized Tag Numbers",
      "section_title": true,
      "ja": "5.1.4. 認識されていないタグ番号"
    },
    {
      "indent": 3,
      "text": "Future revisions to this protocol may include new message types with different APPLICATION class tag numbers. Such revisions should protect older implementations by only sending the message types to parties that are known to understand them; e.g., by means of a flag bit set by the receiver in a preceding request. In the interest of robust error handling, implementations SHOULD gracefully handle receiving a message with an unrecognized tag anyway, and return an error message, if appropriate.",
      "ja": "このプロトコルの将来の改訂には、異なるアプリケーションクラスのタグ番号を持つ新しいメッセージタイプが含まれる場合があります。このような改訂は、メッセージタイプを理解していることが知られている関係者にのみ送信することにより、古い実装を保護する必要があります。たとえば、前のリクエストで受信機によって設定されたフラグビットによって。堅牢なエラー処理のために、実装は、とにかく認識されていないタグでメッセージの受信を優雅に処理し、必要に応じてエラーメッセージを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "In particular, KDCs SHOULD return KRB_AP_ERR_MSG_TYPE if the incorrect tag is sent over a TCP transport. The KDCs SHOULD NOT respond to messages received with an unknown tag over UDP transport in order to avoid denial of service attacks. For non-KDC applications, the Kerberos implementation typically indicates an error to the application which takes appropriate steps based on the application protocol.",
      "ja": "特に、KDCSは、誤ったタグがTCPトランスポートを介して送信される場合、KRB_AP_ERR_MSG_TYPEを返す必要があります。KDCは、サービス攻撃の拒否を避けるために、UDPトランスポートを介した未知のタグで受信したメッセージに応答してはなりません。非KDCアプリケーションの場合、Kerberosの実装は通常、アプリケーションプロトコルに基づいて適切な手順を実行するアプリケーションへのエラーを示します。"
    },
    {
      "indent": 0,
      "text": "5.1.5. Tag Numbers Greater Than 30",
      "section_title": true,
      "ja": "5.1.5. 30を超えるタグ番号"
    },
    {
      "indent": 3,
      "text": "A naive implementation of a DER ASN.1 decoder may experience problems with ASN.1 tag numbers greater than 30, due to such tag numbers being encoded using more than one byte. Future revisions of this protocol may utilize tag numbers greater than 30, and implementations SHOULD be prepared to gracefully return an error, if appropriate, when they do not recognize the tag.",
      "ja": "der asn.1デコーダーの素朴な実装では、複数のバイトを使用してそのようなタグ番号がエンコードされているため、30を超えるASN.1タグ番号の問題が発生する場合があります。このプロトコルの将来の改訂は、30を超えるタグ番号を利用する可能性があり、実装は、タグを認識しない場合、必要に応じてエラーを優雅に返すように準備する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. Basic Kerberos Types",
      "section_title": true,
      "ja": "5.2. 基本的なKerberosタイプ"
    },
    {
      "indent": 3,
      "text": "This section defines a number of basic types that are potentially used in multiple Kerberos protocol messages.",
      "ja": "このセクションでは、複数のKerberosプロトコルメッセージで使用される可能性のあるいくつかの基本タイプを定義します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. KerberosString",
      "section_title": true,
      "ja": "5.2.1. Kerberostring"
    },
    {
      "indent": 3,
      "text": "The original specification of the Kerberos protocol in RFC 1510 uses GeneralString in numerous places for human-readable string data. Historical implementations of Kerberos cannot utilize the full power of GeneralString. This ASN.1 type requires the use of designation and invocation escape sequences as specified in ISO-2022/ECMA-35 [ISO-2022/ECMA-35] to switch character sets, and the default character set that is designated as G0 is the ISO-646/ECMA-6 [ISO-646/ECMA-6] International Reference Version (IRV) (a.k.a. U.S. ASCII), which mostly works.",
      "ja": "RFC 1510のKerberosプロトコルの元の仕様では、人間が読みやすい文字列データのために多くの場所でGeneralStringを使用しています。Kerberosの歴史的な実装は、将軍の全力を活用することはできません。このASN.1タイプでは、ISO-2022/ECMA-35 [ISO-2022/ECMA-35]で指定された指定と呼び出しエスケープシーケンスを使用する必要があります。ISO-646/ECMA-6 [ISO-646/ECMA-6] International Referenceバージョン（IRV）（A.K.A。U.S. ASCII）。"
    },
    {
      "indent": 3,
      "text": "ISO-2022/ECMA-35 defines four character-set code elements (G0..G3) and two Control-function code elements (C0..C1). DER prohibits the designation of character sets as any but the G0 and C0 sets. Unfortunately, this seems to have the side effect of prohibiting the use of ISO-8859 (ISO Latin) [ISO-8859] character sets or any other character sets that utilize a 96-character set, as ISO-2022/ECMA-35 prohibits designating them as the G0 code element. This side effect is being investigated in the ASN.1 standards community.",
      "ja": "ISO-2022/ECMA-35は、4つの文字セットコード要素（G0..G3）と2つの制御機能コード要素（C0..C1）を定義します。DERは、G0およびC0セット以外の任意のように、文字セットの指定を禁止しています。残念ながら、これはISO-8859（ISOラテン語）[ISO-8859]文字セットまたはISO-2022/ECMA-35のように96文字のセットを利用する他のキャラクターセットの使用を禁止する副作用を持っているようです。それらをG0コード要素として指定します。この副作用は、ASN.1規格コミュニティで調査されています。"
    },
    {
      "indent": 3,
      "text": "In practice, many implementations treat GeneralStrings as if they were 8-bit strings of whichever character set the implementation defaults to, without regard to correct usage of character-set designation escape sequences. The default character set is often determined by the current user's operating system-dependent locale. At least one major implementation places unescaped UTF-8 encoded Unicode characters in the GeneralString. This failure to adhere to the GeneralString specifications results in interoperability issues when conflicting character encodings are utilized by the Kerberos clients, services, and KDC.",
      "ja": "実際には、多くの実装は、キャラクターセットの指定エスケープシーケンスの正しい使用法に関係なく、デフォルトの実装セットのどの文字セットの8ビット文字列であるかのように将軍を扱います。デフォルトの文字セットは、多くの場合、現在のユーザーのオペレーティングシステム依存ロケールによって決定されます。少なくとも1つの主要な実装は、UNESCAPED UTF-8エンコードされたUnicode文字を将軍に配置します。将軍の仕様を遵守しないと、競合する文字エンコーディングがKerberosのクライアント、サービス、KDCによって利用される場合、相互運用性の問題が発生します。"
    },
    {
      "indent": 3,
      "text": "This unfortunate situation is the result of improper documentation of the restrictions of the ASN.1 GeneralString type in prior Kerberos specifications.",
      "ja": "この不幸な状況は、以前のKerberosの仕様におけるASN.1 GeneralStringタイプの制限の不適切な文書化の結果です。"
    },
    {
      "indent": 3,
      "text": "The new (post-RFC 1510) type KerberosString, defined below, is a GeneralString that is constrained to contain only characters in IA5String.",
      "ja": "以下に定義されている新しい（RFC 1510）タイプのKerberostringは、IA5Stringの文字のみを含むように制約されている将軍です。"
    },
    {
      "indent": 6,
      "text": "KerberosString  ::= GeneralString (IA5String)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In general, US-ASCII control characters should not be used in KerberosString. Control characters SHOULD NOT be used in principal names or realm names.",
      "ja": "一般に、US-ASCII制御文字はKerberostringで使用しないでください。コントロール文字は、主名またはレルム名で使用しないでください。"
    },
    {
      "indent": 3,
      "text": "For compatibility, implementations MAY choose to accept GeneralString values that contain characters other than those permitted by IA5String, but they should be aware that character set designation codes will likely be absent, and that the encoding should probably be treated as locale-specific in almost every way. Implementations MAY also choose to emit GeneralString values that are beyond those permitted by IA5String, but they should be aware that doing so is extraordinarily risky from an interoperability perspective.",
      "ja": "互換性のために、実装はIA5STRINGで許可されている文字以外の文字を含む一般的な値を受け入れることを選択できますが、キャラクターセットの指定コードはおそらく存在しない可能性があり、エンコードはおそらくほぼすべての場合にロケール固有として扱われるべきであることに注意する必要があります。仕方。また、実装は、IA5STRINGで許可されているものを超える将軍の価値を放出することを選択する場合がありますが、そうすることは相互運用性の観点から非常に危険であることに注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "Some existing implementations use GeneralString to encode unescaped locale-specific characters. This is a violation of the ASN.1 standard. Most of these implementations encode US-ASCII in the left-hand half, so as long as the implementation transmits only US-ASCII, the ASN.1 standard is not violated in this regard. As soon as such an implementation encodes unescaped locale-specific characters with the high bit set, it violates the ASN.1 standard.",
      "ja": "一部の既存の実装では、将軍を使用して、未脱型のロケール固有の文字をエンコードしています。これは、ASN.1規格の違反です。これらの実装のほとんどは、左半分にUS-ASCIIをエンコードします。そのため、実装がUS-ASCIIのみを送信する限り、ASN.1標準はこの点で違反していません。そのような実装がハイビットセットを使用してUnescaped Locale固有の文字をエンコードするとすぐに、ASN.1標準に違反します。"
    },
    {
      "indent": 3,
      "text": "Other implementations have been known to use GeneralString to contain a UTF-8 encoding. This also violates the ASN.1 standard, since UTF-8 is a different encoding, not a 94 or 96 character \"G\" set as defined by ISO 2022. It is believed that these implementations do not even use the ISO 2022 escape sequence to change the character encoding. Even if implementations were to announce the encoding change by using that escape sequence, the ASN.1 standard prohibits the use of any escape sequences other than those used to designate/invoke \"G\" or \"C\" sets allowed by GeneralString.",
      "ja": "その他の実装は、UTF-8エンコーディングを含むために将軍を使用していることが知られています。また、UTF-8はISO 2022で定義されている94または96文字「G」セットではなく、異なるエンコードであるため、ASN.1標準にも違反します。これらの実装は、ISO 2022エスケープシーケンスを使用しないと考えられています。文字エンコードを変更します。実装がそのエスケープシーケンスを使用してエンコーディングの変更を発表したとしても、ASN.1標準は、将軍が許可する「G」または「C」セットを指定/呼び出すために使用されるもの以外のエスケープシーケンスの使用を禁止しています。"
    },
    {
      "indent": 3,
      "text": "Future revisions to this protocol will almost certainly allow for a more interoperable representation of principal names, probably including UTF8String.",
      "ja": "このプロトコルの将来の改訂により、ほぼ確実に、おそらくUTF8Stringを含む主名のより操作可能な表現が可能になります。"
    },
    {
      "indent": 3,
      "text": "Note that applying a new constraint to a previously unconstrained type constitutes creation of a new ASN.1 type. In this particular case, the change does not result in a changed encoding under DER.",
      "ja": "以前に制約されていないタイプに新しい制約を適用することは、新しいasn.1タイプの作成を構成することに注意してください。この特定のケースでは、この変更はDERの下でのエンコードの変更をもたらされません。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Realm and PrincipalName",
      "section_title": true,
      "ja": "5.2.2. レルムとプリンシパル名"
    },
    {
      "indent": 3,
      "text": "Realm           ::= KerberosString",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PrincipalName   ::= SEQUENCE {\n        name-type       [0] Int32,\n        name-string     [1] SEQUENCE OF KerberosString\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kerberos realm names are encoded as KerberosStrings. Realms shall not contain a character with the code 0 (the US-ASCII NUL). Most realms will usually consist of several components separated by periods (.), in the style of Internet Domain Names, or separated by slashes (/), in the style of X.500 names. Acceptable forms for realm names are specified in Section 6.1. A PrincipalName is a typed sequence of components consisting of the following subfields:",
      "ja": "Kerberos Realmの名前はKerberosstringsとしてエンコードされています。レルムには、コード0（US-ascii nul）の文字が含まれてはなりません。ほとんどの領域は通常、期間（。）で区切られたいくつかのコンポーネント、インターネットドメイン名のスタイル、またはx.500名のスタイルでスラッシュ（/）で区切られたいくつかのコンポーネントで構成されます。レルム名の許容可能なフォームは、セクション6.1で指定されています。プリンシパル名は、次のサブフィールドで構成されるコンポーネントのタイプ付きシーケンスです。"
    },
    {
      "indent": 3,
      "text": "name-type This field specifies the type of name that follows. Pre-defined values for this field are specified in Section 6.2. The name-type SHOULD be treated as a hint. Ignoring the name type, no two names can be the same (i.e., at least one of the components, or the realm, must be different).",
      "ja": "name-typeこのフィールドは、次の名前のタイプを指定します。このフィールドの事前定義された値は、セクション6.2で指定されています。名前タイプはヒントとして扱う必要があります。名前タイプを無視すると、2つの名前が同じではありません（つまり、少なくとも1つのコンポーネント、またはレルムが異なる必要があります）。"
    },
    {
      "indent": 3,
      "text": "name-string This field encodes a sequence of components that form a name, each component encoded as a KerberosString. Taken together, a PrincipalName and a Realm form a principal identifier. Most PrincipalNames will have only a few components (typically one or two).",
      "ja": "名前ストリングこのフィールドは、名前を形成するコンポーネントのシーケンスをエンコードします。各コンポーネントはKerberostringとしてエンコードされます。まとめると、プリンシパル名と領域がプリンシパル識別子を形成します。ほとんどのプリンシパル名には、いくつかのコンポーネントしかありません（通常は1つまたは2つ）。"
    },
    {
      "indent": 0,
      "text": "5.2.3. KerberosTime",
      "section_title": true,
      "ja": "5.2.3. kerberostime"
    },
    {
      "indent": 3,
      "text": "KerberosTime    ::= GeneralizedTime -- with no fractional seconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The timestamps used in Kerberos are encoded as GeneralizedTimes. A KerberosTime value shall not include any fractional portions of the seconds. As required by the DER, it further shall not include any separators, and it shall specify the UTC time zone (Z). Example: The only valid format for UTC time 6 minutes, 27 seconds after 9 pm on 6 November 1985 is 19851106210627Z.",
      "ja": "Kerberosで使用されるタイムスタンプは、一般化されたものとしてエンコードされています。kerberostime値には、秒単位の部分を含めてはなりません。DERで要求されるように、さらにセパレーターは含まれていません。また、UTCタイムゾーン（Z）を指定します。例：1985年11月6日の午後9時から27秒後、UTC時間の唯一の有効な形式は19851106210627zです。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Constrained Integer Types",
      "section_title": true,
      "ja": "5.2.4. 制約付き整数タイプ"
    },
    {
      "indent": 3,
      "text": "Some integer members of types SHOULD be constrained to values representable in 32 bits, for compatibility with reasonable implementation limits.",
      "ja": "タイプの一部の整数メンバーは、合理的な実装制限と互換性があるため、32ビットで表される値に制約される必要があります。"
    },
    {
      "indent": 3,
      "text": "Int32           ::= INTEGER (-2147483648..2147483647)\n                    -- signed values representable in 32 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "UInt32          ::= INTEGER (0..4294967295)\n                    -- unsigned 32 bit values",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Microseconds    ::= INTEGER (0..999999)\n                    -- microseconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Although this results in changes to the abstract types from the RFC 1510 version, the encoding in DER should be unaltered. Historical implementations were typically limited to 32-bit integer values anyway, and assigned numbers SHOULD fall in the space of integer values representable in 32 bits in order to promote interoperability anyway.",
      "ja": "これにより、RFC 1510バージョンの抽象タイプが変更されますが、DERでのエンコードは変更されていません。履歴の実装は通常、32ビットの整数値に制限されていたため、相互運用性を促進するために、割り当てられた数値は32ビットで表される整数値の空間に落ちるはずです。"
    },
    {
      "indent": 3,
      "text": "Several integer fields in messages are constrained to fixed values.",
      "ja": "メッセージ内のいくつかの整数フィールドは、固定値に制約されています。"
    },
    {
      "indent": 3,
      "text": "pvno also TKT-VNO or AUTHENTICATOR-VNO, this recurring field is always the constant integer 5. There is no easy way to make this field into a useful protocol version number, so its value is fixed.",
      "ja": "PVNO TKT-VNOまたはAuthenticator-VNOも、この繰り返しのフィールドは常に一定の整数5です。このフィールドを有用なプロトコルバージョン番号にする簡単な方法はありません。"
    },
    {
      "indent": 3,
      "text": "msg-type this integer field is usually identical to the application tag number of the containing message type.",
      "ja": "MSGタイプこの整数フィールドは、通常、メッセージタイプのアプリケーションタグ番号と同じです。"
    },
    {
      "indent": 0,
      "text": "5.2.5. HostAddress and HostAddresses",
      "section_title": true,
      "ja": "5.2.5. hostAddressとhostAddresses"
    },
    {
      "indent": 3,
      "text": "HostAddress     ::= SEQUENCE  {\n        addr-type       [0] Int32,\n        address         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- NOTE: HostAddresses is always used as an OPTIONAL field and\n-- should not be empty.\nHostAddresses   -- NOTE: subtly different from rfc1510,\n                -- but has a value mapping and encodes the same\n        ::= SEQUENCE OF HostAddress",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The host address encodings consist of two fields:",
      "ja": "ホストアドレスエンコーディングは、2つのフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "addr-type This field specifies the type of address that follows. Pre-defined values for this field are specified in Section 7.5.3.",
      "ja": "ADDRタイプこのフィールドは、次のアドレスのタイプを指定します。このフィールドの事前定義された値は、セクション7.5.3で指定されています。"
    },
    {
      "indent": 3,
      "text": "address This field encodes a single address of type addr-type.",
      "ja": "アドレスこのフィールドは、タイプADDRタイプの単一のアドレスをエンコードします。"
    },
    {
      "indent": 0,
      "text": "5.2.6. AuthorizationData",
      "section_title": true,
      "ja": "5.2.6. AuthorizationData"
    },
    {
      "indent": 6,
      "text": "-- NOTE: AuthorizationData is always used as an OPTIONAL field and\n-- should not be empty.\nAuthorizationData       ::= SEQUENCE OF SEQUENCE {\n        ad-type         [0] Int32,\n        ad-data         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ad-data This field contains authorization data to be interpreted according to the value of the corresponding ad-type field.",
      "ja": "AD-DATAこのフィールドには、対応するADタイプフィールドの値に従って解釈する許可データが含まれています。"
    },
    {
      "indent": 3,
      "text": "ad-type This field specifies the format for the ad-data subfield. All negative values are reserved for local use. Non-negative values are reserved for registered use.",
      "ja": "ADタイプこのフィールドは、AD-DATAサブフィールドの形式を指定します。すべての負の値は、ローカル使用のために予約されています。非陰性値は、登録された使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Each sequence of type and data is referred to as an authorization element. Elements MAY be application specific; however, there is a common set of recursive elements that should be understood by all implementations. These elements contain other elements embedded within them, and the interpretation of the encapsulating element determines which of the embedded elements must be interpreted, and which may be ignored.",
      "ja": "タイプとデータの各シーケンスは、認証要素と呼ばれます。要素はアプリケーション固有の場合があります。ただし、すべての実装で理解する必要がある共通の再帰要素のセットがあります。これらの要素には、それらに埋め込まれた他の要素が含まれており、カプセル化要素の解釈により、どの埋め込まれた要素を解釈する必要があり、どちらが無視される可能性があるかが決まります。"
    },
    {
      "indent": 3,
      "text": "These common authorization data elements are recursively defined, meaning that the ad-data for these types will itself contain a sequence of authorization data whose interpretation is affected by the encapsulating element. Depending on the meaning of the encapsulating element, the encapsulated elements may be ignored, might be interpreted as issued directly by the KDC, or might be stored in a separate plaintext part of the ticket. The types of the encapsulating elements are specified as part of the Kerberos specification because the behavior based on these values should be understood across implementations, whereas other elements need only be understood by the applications that they affect.",
      "ja": "これらの一般的な認証データ要素は再帰的に定義されています。つまり、これらのタイプのAD-DATA自体には、解釈がカプセル化要素の影響を受ける一連の認証データが含まれます。カプセル化要素の意味に応じて、カプセル化された要素は無視されたり、KDCによって直接発行されていると解釈される可能性があるか、チケットの別のプレーンテキスト部分に保存される場合があります。カプセル化要素のタイプは、これらの値に基づく動作が実装全体で理解されるべきであるため、Kerberos仕様の一部として指定されますが、他の要素は影響するアプリケーションによってのみ理解される必要があります。"
    },
    {
      "indent": 3,
      "text": "Authorization data elements are considered critical if present in a ticket or authenticator. If an unknown authorization data element type is received by a server either in an AP-REQ or in a ticket contained in an AP-REQ, then, unless it is encapsulated in a known authorization data element amending the criticality of the elements it contains, authentication MUST fail. Authorization data is intended to restrict the use of a ticket. If the service cannot determine whether the restriction applies to that service, then a security weakness may result if the ticket can be used for that service. Authorization elements that are optional can be enclosed in an AD-IF-RELEVANT element.",
      "ja": "承認データ要素は、チケットまたは認証者に存在する場合、重要であると見なされます。不明な認証データ要素タイプがAP-REQまたはAP-REQに含まれるチケットのいずれかでサーバーによって受信された場合、それが含む要素の重要性を修正する既知の認証データ要素にカプセル化されていない限り、認証は失敗する必要があります。承認データは、チケットの使用を制限することを目的としています。サービスが制限がそのサービスに適用されるかどうかを判断できない場合、チケットをそのサービスに使用できる場合、セキュリティの弱点が生じる場合があります。オプションの承認要素は、AD-IFリレッド要素に囲むことができます。"
    },
    {
      "indent": 3,
      "text": "In the definitions that follow, the value of the ad-type for the element will be specified as the least significant part of the subsection number, and the value of the ad-data will be as shown in the ASN.1 structure that follows the subsection heading.",
      "ja": "以下の定義では、要素のADタイプの値がサブセクション番号の最も重要な部分として指定され、AD-DATAの値はASN.1構造に示されているように、サブセクションの見出し。"
    },
    {
      "indent": 3,
      "text": "Contents of ad-data ad-type",
      "ja": "AD-DATA ADタイプの内容"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-IF-RELEVANT 1",
      "ja": "AD-IF関連のAD-IFのエンコード1"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-KDCIssued 4",
      "ja": "AD-KDCISSUED 4のderエンコード4"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-AND-OR 5",
      "ja": "Ad-and-or 5のderエンコード"
    },
    {
      "indent": 3,
      "text": "DER encoding of AD-MANDATORY-FOR-KDC 8",
      "ja": "Ad-Mandatory-for-KDCのderエンコード8"
    },
    {
      "indent": 0,
      "text": "5.2.6.1. IF-RELEVANT",
      "section_title": true,
      "ja": "5.2.6.1. 関連する場合"
    },
    {
      "indent": 3,
      "text": "AD-IF-RELEVANT          ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AD elements encapsulated within the if-relevant element are intended for interpretation only by application servers that understand the particular ad-type of the embedded element. Application servers that do not understand the type of an element embedded within the if-relevant element MAY ignore the uninterpretable element. This element promotes interoperability across implementations that may have local extensions for authorization. The ad-type for AD-IF-RELEVANT is (1).",
      "ja": "ifリレバント要素内でカプセル化されたAD要素は、埋め込まれた要素の特定のADタイプを理解するアプリケーションサーバーによってのみ解釈を目的としています。IFリレッド要素に埋め込まれた要素のタイプを理解していないアプリケーションサーバーは、解釈不可能な要素を無視する可能性があります。この要素は、承認のためのローカル拡張機能を備えている可能性のある実装全体の相互運用性を促進します。Ad-if RelevantのADタイプは（1）です。"
    },
    {
      "indent": 0,
      "text": "5.2.6.2. KDCIssued",
      "section_title": true,
      "ja": "5.2.6.2. kdcissued"
    },
    {
      "indent": 3,
      "text": "AD-KDCIssued            ::= SEQUENCE {\n        ad-checksum     [0] Checksum,\n        i-realm         [1] Realm OPTIONAL,\n        i-sname         [2] PrincipalName OPTIONAL,\n        elements        [3] AuthorizationData\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ad-checksum A cryptographic checksum computed over the DER encoding of the AuthorizationData in the \"elements\" field, keyed with the session key. Its checksumtype is the mandatory checksum type for the encryption type of the session key, and its key usage value is 19.",
      "ja": "AD-CHECKSUMセッションキーでキーを付けた「要素」フィールドのauthorizationDataのderエンコードを介して計算された暗号化チェックサム。CheckSumTypeは、セッションキーの暗号化タイプの必須チェックサムタイプであり、そのキー使用値は19です。"
    },
    {
      "indent": 3,
      "text": "i-realm, i-sname The name of the issuing principal if different from that of the KDC itself. This field would be used when the KDC can verify the authenticity of elements signed by the issuing principal, and it allows this KDC to notify the application server of the validity of those elements.",
      "ja": "i-realm、i-sname発行校長の名前は、KDC自体とは異なる場合。このフィールドは、KDCが発行プリンシパルによって署名された要素の信頼性を検証できる場合に使用され、このKDCはアプリケーションサーバーにそれらの要素の有効性を通知できるようにします。"
    },
    {
      "indent": 3,
      "text": "elements A sequence of authorization data elements issued by the KDC.",
      "ja": "要素KDCによって発行された承認データ要素のシーケンス。"
    },
    {
      "indent": 3,
      "text": "The KDC-issued ad-data field is intended to provide a means for Kerberos principal credentials to embed within themselves privilege attributes and other mechanisms for positive authorization, amplifying the privileges of the principal beyond what can be done using credentials without such an a-data element.",
      "ja": "KDCが発行したAD-DATAフィールドは、Kerberosの校長資格情報が、肯定的な承認のために特権属性やその他のメカニズムを組み込むための手段を提供することを目的としています。エレメント。"
    },
    {
      "indent": 3,
      "text": "The above means cannot be provided without this element because the definition of the authorization-data field allows elements to be added at will by the bearer of a TGT at the time when they request service tickets, and elements may also be added to a delegated ticket by inclusion in the authenticator.",
      "ja": "Authorization-Dataフィールドの定義により、サービスチケットをリクエストした時点でTGTの担い手が要素を自由に追加できるため、上記の手段をこの要素なしでは提供できません。Authenticatorに含めることにより。"
    },
    {
      "indent": 3,
      "text": "For KDC-issued elements, this is prevented because the elements are signed by the KDC by including a checksum encrypted using the server's key (the same key used to encrypt the ticket or a key derived from that key). Elements encapsulated with in the KDC-issued element MUST be ignored by the application server if this \"signature\" is not present. Further, elements encapsulated within this element from a TGT MAY be interpreted by the KDC, and used as a basis according to policy for including new signed elements within derivative tickets, but they will not be copied to a derivative ticket directly. If they are copied directly to a derivative ticket by a KDC that is not aware of this element, the signature will not be correct for the application ticket elements, and the field will be ignored by the application server.",
      "ja": "KDC発行の要素の場合、これは、サーバーのキーを使用して暗号化されたチェックサム（チケットまたはそのキーから派生したキーに使用される同じキー）を使用して暗号化されたチェックサムを含めることにより、要素がKDCによって署名されるため、防止されます。この「署名」が存在しない場合、KDC発行要素でカプセル化された要素は、アプリケーションサーバーによって無視する必要があります。さらに、TGTからこの要素内でカプセル化された要素は、KDCによって解釈され、デリバティブチケットに新しい署名された要素を含めるためのポリシーに従って基礎として使用される場合がありますが、デリバティブチケットに直接コピーされません。これらがこの要素を認識していないKDCによってデリバティブチケットに直接コピーされた場合、署名はアプリケーションチケット要素の正しいものではなく、フィールドはアプリケーションサーバーによって無視されます。"
    },
    {
      "indent": 3,
      "text": "This element and the elements it encapsulates MAY safely be ignored by applications, application servers, and KDCs that do not implement this element.",
      "ja": "この要素とそれがカプセル化する要素は、この要素を実装していないアプリケーション、アプリケーションサーバー、およびKDCによって安全に無視される場合があります。"
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-KDC-ISSUED is (4).",
      "ja": "AD-KDC発行のADタイプは（4）です。"
    },
    {
      "indent": 0,
      "text": "5.2.6.3. AND-OR",
      "section_title": true,
      "ja": "5.2.6.3. and-Or"
    },
    {
      "indent": 3,
      "text": "AD-AND-OR               ::= SEQUENCE {\n        condition-count [0] Int32,\n        elements        [1] AuthorizationData\n}\n   When restrictive AD elements are encapsulated within the and-or\nelement, the and-or element is considered satisfied if and only if at\nleast the number of encapsulated elements specified in condition-\ncount are satisfied.  Therefore, this element MAY be used to\nimplement an \"or\" operation by setting the condition-count field to\n1, and it MAY specify an \"and\" operation by setting the condition\ncount to the number of embedded elements.  Application servers that\ndo not implement this element MUST reject tickets that contain\nauthorization data elements of this type.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-AND-OR is (5).",
      "ja": "広告とORの広告タイプは（5）です。"
    },
    {
      "indent": 0,
      "text": "5.2.6.4. MANDATORY-FOR-KDC",
      "section_title": true,
      "ja": "5.2.6.4. 必須-KDC"
    },
    {
      "indent": 3,
      "text": "AD-MANDATORY-FOR-KDC    ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AD elements encapsulated within the mandatory-for-kdc element are to be interpreted by the KDC. KDCs that do not understand the type of an element embedded within the mandatory-for-kdc element MUST reject the request.",
      "ja": "義務的な要素内にカプセル化されたAD要素は、KDCによって解釈されます。必須のkdc要素に埋め込まれた要素のタイプを理解していないKDCは、リクエストを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ad-type for AD-MANDATORY-FOR-KDC is (8).",
      "ja": "ADMANDARY-FOR-KDCのADタイプは（8）です。"
    },
    {
      "indent": 0,
      "text": "5.2.7. PA-DATA",
      "section_title": true,
      "ja": "5.2.7. pa-data"
    },
    {
      "indent": 3,
      "text": "Historically, PA-DATA have been known as \"pre-authentication data\", meaning that they were used to augment the initial authentication with the KDC. Since that time, they have also been used as a typed hole with which to extend protocol exchanges with the KDC.",
      "ja": "歴史的に、PA-DATAは「事前認証データ」として知られていました。つまり、KDCによる初期認証を増強するために使用されていました。それ以来、それらはKDCとのプロトコル交換を拡張するためのタイプされた穴としても使用されてきました。"
    },
    {
      "indent": 3,
      "text": "PA-DATA         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        padata-type     [1] Int32,\n        padata-value    [2] OCTET STRING -- might be encoded AP-REQ\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "padata-type Indicates the way that the padata-value element is to be interpreted. Negative values of padata-type are reserved for unregistered use; non-negative values are used for a registered interpretation of the element type.",
      "ja": "Padataタイプは、Padata値要素を解釈する方法を示します。Padata型の負の値は、未登録の使用のために予約されています。非陰性値は、要素タイプの登録解釈に使用されます。"
    },
    {
      "indent": 3,
      "text": "padata-value Usually contains the DER encoding of another type; the padata-type field identifies which type is encoded here.",
      "ja": "Padata値には通常、別のタイプのderエンコードが含まれます。Padataタイプのフィールドは、ここでエンコードされているタイプを識別します。"
    },
    {
      "indent": 6,
      "text": "padata-type Name Contents of padata-value",
      "ja": "Padata-Valueのパダタ型名の内容"
    },
    {
      "indent": 6,
      "text": "1 pa-tgs-req DER encoding of AP-REQ",
      "ja": "AP-Reqの1 PA-TGS-REQ DERエンコード"
    },
    {
      "indent": 6,
      "text": "2 pa-enc-timestamp DER encoding of PA-ENC-TIMESTAMP",
      "ja": "2 PA-ECN-TIMESTAMP DERエンコードPA-ECC-TIMESTAMP"
    },
    {
      "indent": 6,
      "text": "3 pa-pw-salt salt (not ASN.1 encoded)",
      "ja": "3 PA-PW-SALT塩（asn.1エンコードされていない）"
    },
    {
      "indent": 6,
      "text": "11 pa-etype-info DER encoding of ETYPE-INFO",
      "ja": "11 PA-ETYPE-INFO DER ETYPE-INFOのエンコード"
    },
    {
      "indent": 6,
      "text": "19 pa-etype-info2 DER encoding of ETYPE-INFO2",
      "ja": "19 PA-ETYPE-INFO2 der ETYPE-INFO2のエンコード"
    },
    {
      "indent": 6,
      "text": "This field MAY also contain information needed by certain extensions to the Kerberos protocol. For example, it might be used to verify the identity of a client initially before any response is returned.",
      "ja": "このフィールドには、Kerberosプロトコルの特定の拡張機能が必要な情報も含める場合があります。たとえば、応答が返される前に、最初にクライアントの身元を確認するために使用される場合があります。"
    },
    {
      "indent": 6,
      "text": "The padata field can also contain information needed to help the KDC or the client select the key needed for generating or decrypting the response. This form of the padata is useful for supporting the use of certain token cards with Kerberos. The details of such extensions are specified in separate documents. See [Pat92] for additional uses of this field.",
      "ja": "Padataフィールドには、KDCまたはクライアントが応答を生成または復号化するために必要なキーを選択するのに役立つために必要な情報を含めることもできます。この形式のパダタは、Kerberosで特定のトークンカードの使用をサポートするのに役立ちます。このような拡張機能の詳細は、個別のドキュメントで指定されています。このフィールドの追加の使用については、[PAT92]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.7.1. PA-TGS-REQ",
      "section_title": true,
      "ja": "5.2.7.1. PA-TGS-Req"
    },
    {
      "indent": 3,
      "text": "In the case of requests for additional tickets (KRB_TGS_REQ), padata-value will contain an encoded AP-REQ. The checksum in the authenticator (which MUST be collision-proof) is to be computed over the KDC-REQ-BODY encoding.",
      "ja": "追加のチケット（krb_tgs_req）のリクエストの場合、Padata-ValueにはエンコードされたAP-Reqが含まれます。Authenticatorのチェックサム（衝突防止装置である必要があります）は、KDC-Req-Bodyエンコードを介して計算されます。"
    },
    {
      "indent": 0,
      "text": "5.2.7.2. Encrypted Timestamp Pre-authentication",
      "section_title": true,
      "ja": "5.2.7.2. 暗号化されたタイムスタンプの事前認証"
    },
    {
      "indent": 3,
      "text": "There are pre-authentication types that may be used to pre-authenticate a client by means of an encrypted timestamp.",
      "ja": "暗号化されたタイムスタンプを使用して、クライアントを事前に認めるために使用される可能性のある事前認証タイプがあります。"
    },
    {
      "indent": 3,
      "text": "PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PA-ENC-TS-ENC           ::= SEQUENCE {\n        patimestamp     [0] KerberosTime -- client's time --,\n        pausec          [1] Microseconds OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Patimestamp contains the client's time, and pausec contains the microseconds, which MAY be omitted if a client will not generate more than one request per second. The ciphertext (padata-value) consists of the PA-ENC-TS-ENC encoding, encrypted using the client's secret key and a key usage value of 1.",
      "ja": "Patimestampにはクライアントの時間が含まれており、Pausecにはマイクロ秒が含まれています。クライアントが1秒あたり複数のリクエストを生成しない場合は省略できます。暗号文（Padata-Value）は、クライアントのシークレットキーと1のキー使用値を使用して暗号化されたPA-enc-TS-ENCエンコードで構成されています。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations support it.",
      "ja": "この認証前のタイプはRFC 1510には存在しませんでしたが、多くの実装はそれをサポートしています。"
    },
    {
      "indent": 0,
      "text": "5.2.7.3. PA-PW-SALT",
      "section_title": true,
      "ja": "5.2.7.3. PA-PW-SALT"
    },
    {
      "indent": 3,
      "text": "The padata-value for this pre-authentication type contains the salt for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part of an AS-REP message. Unfortunately, for historical reasons, the character set to be used is unspecified and probably locale-specific.",
      "ja": "この受精前タイプのPadata値には、クライアントが使用する弦が使用される塩が含まれており、AS-REPメッセージの暗号化された部分を復号化するためのキーを取得します。残念ながら、歴史的な理由から、使用されるキャラクターセットは不特定であり、おそらくロケール固有です。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations support it. It is necessary in any case where the salt for the string-to-key algorithm is not the default.",
      "ja": "この認証前のタイプはRFC 1510には存在しませんでしたが、多くの実装はそれをサポートしています。文字列間アルゴリズムの塩がデフォルトではない場合に必要です。"
    },
    {
      "indent": 3,
      "text": "In the trivial example, a zero-length salt string is very commonplace for realms that have converted their principal databases from Kerberos Version 4.",
      "ja": "些細な例では、ゼロの長さの塩の糸は、Kerberosバージョン4から主要なデータベースを変換した領域では非常に一般的です。"
    },
    {
      "indent": 3,
      "text": "A KDC SHOULD NOT send PA-PW-SALT when issuing a KRB-ERROR message that requests additional pre-authentication. Implementation note: Some KDC implementations issue an erroneous PA-PW-SALT when issuing a KRB-ERROR message that requests additional pre-authentication. Therefore, clients SHOULD ignore a PA-PW-SALT accompanying a KRB-ERROR message that requests additional pre-authentication. As noted in section 3.1.3, a KDC MUST NOT send PA-PW-SALT when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "KDCは、追加の事前認証を要求するKRB-Errorメッセージを発行する際にPA-PW-Saltを送信しないでください。実装注：一部のKDC実装は、追加の事前認証を要求するKRB-Errorメッセージを発行する際に、誤ったPA-PW-Saltを発行します。したがって、クライアントは、追加の事前認証を要求するKRB-Errorメッセージを伴うPA-PW-Saltを無視する必要があります。セクション3.1.3で述べたように、KDCは、クライアントのAS-REQに少なくとも1つの「新しい」ETYPEが含まれている場合、PA-PW-Saltを送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.7.4. PA-ETYPE-INFO",
      "section_title": true,
      "ja": "5.2.7.4. PA-ETYPE-INFO"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO pre-authentication type is sent by the KDC in a KRB-ERROR indicating a requirement for additional pre-authentication. It is usually used to notify a client of which key to use for the encryption of an encrypted timestamp for the purposes of sending a PA-ENC-TIMESTAMP pre-authentication value. It MAY also be sent in an AS-REP to provide information to the client about which key salt to use for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part the AS-REP.",
      "ja": "ETYPE-INFOの事前認証タイプは、KRB-ERRORでKDCによって送信され、追加の事前認証の要件が示されています。通常、PA-ECC-TIMESTAMPの事前認証値を送信する目的で、暗号化されたタイムスタンプの暗号化に使用するキーをクライアントに通知するために使用されます。また、クライアントに使用するキーソルトをクライアントに提供するために、クライアントが使用するために使用するキーソルトをクライアントに提供して、暗号化された部分をAS-REPで復号化するためのキーを取得するための情報をクライアントに提供することもできます。"
    },
    {
      "indent": 3,
      "text": "ETYPE-INFO-ENTRY        ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The salt, like that of PA-PW-SALT, is also completely unspecified with respect to character set and is probably locale-specific.",
      "ja": "PA-PW-saltの塩のように、塩もキャラクターセットに関して完全に特定されておらず、おそらくロケール固有です。"
    },
    {
      "indent": 3,
      "text": "If ETYPE-INFO is sent in an AS-REP, there shall be exactly one ETYPE-INFO-ENTRY, and its etype shall match that of the enc-part in the AS-REP.",
      "ja": "Etype-INFOがAS-REPで送信される場合、正確に1つのETYPE-INFO-ENTRYがあり、そのETYPEはAS-REPでエンクパートのETYPEと一致するものとします。"
    },
    {
      "indent": 3,
      "text": "This pre-authentication type was not present in RFC 1510, but many implementations that support encrypted timestamps for pre-authentication need to support ETYPE-INFO as well. As noted in Section 3.1.3, a KDC MUST NOT send PA-ETYPE-INFO when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "この受容前のタイプはRFC 1510には存在しませんでしたが、暗号化されたタイムスタンプをサポートする多くの実装は、ETYPE-INFOもサポートする必要があります。セクション3.1.3で述べたように、KDCは、クライアントのAS-REQに少なくとも1つの「新しい」ETYPEが含まれている場合、PA-ETYPE-INFOを送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "5.2.7.5. PA-ETYPE-INFO2",
      "section_title": true,
      "ja": "5.2.7.5. PA-ETYPE-INFO2"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO2 pre-authentication type is sent by the KDC in a KRB-ERROR indicating a requirement for additional pre-authentication. It is usually used to notify a client of which key to use for the encryption of an encrypted timestamp for the purposes of sending a PA-ENC-TIMESTAMP pre-authentication value. It MAY also be sent in an AS-REP to provide information to the client about which key salt to use for the string-to-key to be used by the client to obtain the key for decrypting the encrypted part the AS-REP.",
      "ja": "ETYPE-INFO2前免除タイプは、KRB-ERRORでKDCによって送信され、追加の事前認証の要件が示されています。通常、PA-ECC-TIMESTAMPの事前認証値を送信する目的で、暗号化されたタイムスタンプの暗号化に使用するキーをクライアントに通知するために使用されます。また、クライアントに使用するキーソルトをクライアントに提供するために、クライアントが使用するために使用するキーソルトをクライアントに提供して、暗号化された部分をAS-REPで復号化するためのキーを取得するための情報をクライアントに提供することもできます。"
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2              ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The type of the salt is KerberosString, but existing installations might have locale-specific characters stored in salt strings, and implementors MAY choose to handle them.",
      "ja": "塩のタイプはkerberostringですが、既存のインストールでは塩の弦にロケール固有の文字が保存されている可能性があり、実装者はそれらを処理することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The interpretation of s2kparams is specified in the cryptosystem description associated with the etype. Each cryptosystem has a default interpretation of s2kparams that will hold if that element is omitted from the encoding of ETYPE-INFO2-ENTRY.",
      "ja": "S2KPARAMSの解釈は、ETYPEに関連付けられた暗号システムの説明で指定されています。各暗号システムには、etype-info2-entryのエンコードからその要素が省略されている場合に保持されるs2kparamsのデフォルトの解釈があります。"
    },
    {
      "indent": 3,
      "text": "If ETYPE-INFO2 is sent in an AS-REP, there shall be exactly one ETYPE-INFO2-ENTRY, and its etype shall match that of the enc-part in the AS-REP.",
      "ja": "eType-INFO2がAS-REPで送信される場合、正確に1つのETYPE-INFO2-ENTRYがあり、そのETYPEはAS-REPのエンクパートのETYPEと一致するものとします。"
    },
    {
      "indent": 3,
      "text": "The preferred ordering of the \"hint\" pre-authentication data that affect client key selection is: ETYPE-INFO2, followed by ETYPE-INFO, followed by PW-SALT. As noted in Section 3.1.3, a KDC MUST NOT send ETYPE-INFO or PW-SALT when the client's AS-REQ includes at least one \"newer\" etype.",
      "ja": "クライアントキーの選択に影響を与える「ヒント」前発見データの優先順序は、ETYPE-INFO2、続いてETYPE-INFO、続いてPW-SALTが続きます。セクション3.1.3で述べたように、KDCは、クライアントのAS-REQに少なくとも1つの「新しい」ETYPEが含まれている場合、ETYPE-INFOまたはPW-SALTを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "The ETYPE-INFO2 pre-authentication type was not present in RFC 1510.",
      "ja": "etype-info2前免除タイプは、RFC 1510には存在しませんでした。"
    },
    {
      "indent": 0,
      "text": "5.2.8. KerberosFlags",
      "section_title": true,
      "ja": "5.2.8. Kerberos Flags"
    },
    {
      "indent": 3,
      "text": "For several message types, a specific constrained bit string type, KerberosFlags, is used.",
      "ja": "いくつかのメッセージタイプでは、特定の制約されたビット文字列タイプであるKerberosflagsが使用されます。"
    },
    {
      "indent": 3,
      "text": "KerberosFlags   ::= BIT STRING (SIZE (32..MAX))\n                    -- minimum number of bits shall be sent,\n                    -- but no fewer than 32",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Compatibility note: The following paragraphs describe a change from the RFC 1510 description of bit strings that would result in incompatility in the case of an implementation that strictly conformed to ASN.1 DER and RFC 1510.",
      "ja": "互換性メモ：次の段落では、ASN.1 DERおよびRFC 1510に厳密に適合した実装の場合に、非互換性をもたらすビット文字列のRFC 1510の説明からの変更について説明します。"
    },
    {
      "indent": 3,
      "text": "ASN.1 bit strings have multiple uses. The simplest use of a bit string is to contain a vector of bits, with no particular meaning attached to individual bits. This vector of bits is not necessarily a multiple of eight bits long. The use in Kerberos of a bit string as a compact boolean vector wherein each element has a distinct meaning poses some problems. The natural notation for a compact boolean vector is the ASN.1 \"NamedBit\" notation, and the DER require that encodings of a bit string using \"NamedBit\" notation exclude any trailing zero bits. This truncation is easy to neglect, especially given C language implementations that naturally choose to store boolean vectors as 32-bit integers.",
      "ja": "ASN.1ビット文字列には複数の用途があります。ビット文字列の最も単純な使用は、個々のビットに特別な意味が付いていないビットのベクトルを含むことです。このビットのベクトルは、必ずしも長さ8ビットの倍数ではありません。各要素が異なる意味を持つコンパクトなブールベクターとしての少しひものKerberosでの使用は、いくつかの問題をもたらします。コンパクトなブールベクトルの自然表記は、asn.1 \"namedbit\" notationであり、derは、「namedbit」表記を使用してビット文字列のエンコーディングがトレーリングゼロビットを除外することを要求します。この切り捨ては、特にブールベクターを32ビット整数として保存することを自然に選択するC言語の実装を考えると、無視するのが簡単です。"
    },
    {
      "indent": 3,
      "text": "For example, if the notation for KDCOptions were to include the \"NamedBit\" notation, as in RFC 1510, and a KDCOptions value to be encoded had only the \"forwardable\" (bit number one) bit set, the DER encoding MUST include only two bits: the first reserved bit (\"reserved\", bit number zero, value zero) and the one-valued bit (bit number one) for \"forwardable\".",
      "ja": "たとえば、kdcoptionsの表記にRFC 1510のように「名前付きビット」表記が含まれていて、エンコードされるkdcoptions値には「フォワーダブル」（ビット番号1）のビットセットのみがある場合、derエンコードには2つのみを含める必要があります。ビット：最初の予約ビット（「予約済み」、ビット番号ゼロ、値ゼロ）、および「フォワーダブル」の1値ビット（ビット番号1）。"
    },
    {
      "indent": 3,
      "text": "Most existing implementations of Kerberos unconditionally send 32 bits on the wire when encoding bit strings used as boolean vectors. This behavior violates the ASN.1 syntax used for flag values in RFC 1510, but it occurs on such a widely installed base that the protocol description is being modified to accommodate it.",
      "ja": "Kerberosのほとんどの既存の実装は、ブールベクターとして使用されるビット文字列をエンコードすると、ワイヤに32ビットを無条件に送信します。この動作は、RFC 1510のフラグ値に使用されるASN.1構文に違反しますが、広くインストールされたベースで発生し、プロトコルの説明がそれに対応するように変更されています。"
    },
    {
      "indent": 3,
      "text": "Consequently, this document removes the \"NamedBit\" notations for individual bits, relegating them to comments. The size constraint on the KerberosFlags type requires that at least 32 bits be encoded at all times, though a lenient implementation MAY choose to accept fewer than 32 bits and to treat the missing bits as set to zero.",
      "ja": "その結果、このドキュメントは、個々のビットの「名前付き」表記を削除し、コメントに委ねます。KerberosFlagsタイプのサイズの制約には、少なくとも32ビットを常にエンコードする必要がありますが、寛大な実装では32ビット未満を受け入れ、欠落しているビットをゼロに設定するように扱うことができます。"
    },
    {
      "indent": 3,
      "text": "Currently, no uses of KerberosFlags specify more than 32 bits' worth of flags, although future revisions of this document may do so. When more than 32 bits are to be transmitted in a KerberosFlags value, future revisions to this document will likely specify that the smallest number of bits needed to encode the highest-numbered one-valued bit should be sent. This is somewhat similar to the DER encoding of a bit string that is declared with the \"NamedBit\" notation.",
      "ja": "現在、Kerberosflagsの使用は32ビット以上のフラグを指定していませんが、このドキュメントの将来の改訂はそうするかもしれません。32ビット以上がKerberosflagsの値で送信される場合、このドキュメントの将来の改訂により、最高の数値の1値ビットをエンコードするために必要な最小のビット数が送信されることを指定する可能性があります。これは、「名前の付いた」表記で宣言されたビット文字列のderエンコードに多少似ています。"
    },
    {
      "indent": 0,
      "text": "5.2.9. Cryptosystem-Related Types",
      "section_title": true,
      "ja": "5.2.9. 暗号システム関連のタイプ"
    },
    {
      "indent": 3,
      "text": "Many Kerberos protocol messages contain an EncryptedData as a container for arbitrary encrypted data, which is often the encrypted encoding of another data type. Fields within EncryptedData assist the recipient in selecting a key with which to decrypt the enclosed data.",
      "ja": "多くのKerberosプロトコルメッセージには、任意の暗号化されたデータのコンテナとして暗号化されたdataが含まれています。これは、多くの場合、別のデータ型の暗号化されたエンコードです。暗号化されたData内のフィールドは、囲まれたデータを復号化するためのキーを選択するのを支援します。"
    },
    {
      "indent": 3,
      "text": "EncryptedData   ::= SEQUENCE {\n        etype   [0] Int32 -- EncryptionType --,\n        kvno    [1] UInt32 OPTIONAL,\n        cipher  [2] OCTET STRING -- ciphertext\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "etype This field identifies which encryption algorithm was used to encipher the cipher.",
      "ja": "Etypeこのフィールドは、暗号化アルゴリズムを使用して暗号を格納するかを識別します。"
    },
    {
      "indent": 3,
      "text": "kvno This field contains the version number of the key under which data is encrypted. It is only present in messages encrypted under long lasting keys, such as principals' secret keys.",
      "ja": "KVNOこのフィールドには、データが暗号化されているキーのバージョン番号が含まれています。プリンシパルのシークレットキーなど、長持ちするキーの下で暗号化されたメッセージにのみ存在します。"
    },
    {
      "indent": 3,
      "text": "cipher This field contains the enciphered text, encoded as an OCTET STRING. (Note that the encryption mechanisms defined in [RFC3961] MUST incorporate integrity protection as well, so no additional checksum is required.)",
      "ja": "Cipherこのフィールドには、オクテット文字列としてエンコードされたエンキファーテキストが含まれています。（[RFC3961]で定義されている暗号化メカニズムには、整合性保護も組み込まなければならないため、追加のチェックサムは必要ありません。）"
    },
    {
      "indent": 3,
      "text": "The EncryptionKey type is the means by which cryptographic keys used for encryption are transferred.",
      "ja": "暗号化キータイプは、暗号化に使用される暗号化キーが転送される手段です。"
    },
    {
      "indent": 3,
      "text": "EncryptionKey   ::= SEQUENCE {\n        keytype         [0] Int32 -- actually encryption type --,\n        keyvalue        [1] OCTET STRING\n}\n   keytype\n   This field specifies the encryption type of the encryption key\n   that follows in the keyvalue field.  Although its name is\n   \"keytype\", it actually specifies an encryption type.  Previously,\n   multiple cryptosystems that performed encryption differently but\n   were capable of using keys with the same characteristics were\n   permitted to share an assigned number to designate the type of\n   key; this usage is now deprecated.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "keyvalue This field contains the key itself, encoded as an octet string.",
      "ja": "KeyValueこのフィールドには、オクテット文字列としてエンコードされたキー自体が含まれています。"
    },
    {
      "indent": 3,
      "text": "Messages containing cleartext data to be authenticated will usually do so by using a member of type Checksum. Most instances of Checksum use a keyed hash, though exceptions will be noted.",
      "ja": "認証されるクリアテキストデータを含むメッセージは、通常、タイプチェックサムのメンバーを使用してそうします。チェックサムのほとんどのインスタンスは、キー付きハッシュを使用しますが、例外が記載されています。"
    },
    {
      "indent": 3,
      "text": "Checksum        ::= SEQUENCE {\n        cksumtype       [0] Int32,\n        checksum        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "cksumtype This field indicates the algorithm used to generate the accompanying checksum.",
      "ja": "cksumtypeこのフィールドは、付随するチェックサムを生成するために使用されるアルゴリズムを示します。"
    },
    {
      "indent": 3,
      "text": "checksum This field contains the checksum itself, encoded as an octet string.",
      "ja": "Checksumこのフィールドには、Octet Stringとしてエンコードされたチェックサム自体が含まれています。"
    },
    {
      "indent": 3,
      "text": "See Section 4 for a brief description of the use of encryption and checksums in Kerberos.",
      "ja": "Kerberosでの暗号化とチェックサムの使用の簡単な説明については、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3. Tickets",
      "section_title": true,
      "ja": "5.3. 切符売場"
    },
    {
      "indent": 3,
      "text": "This section describes the format and encryption parameters for tickets and authenticators. When a ticket or authenticator is included in a protocol message, it is treated as an opaque object. A ticket is a record that helps a client authenticate to a service. A Ticket contains the following information:",
      "ja": "このセクションでは、チケットと認証器のフォーマットパラメーターと暗号化パラメーターについて説明します。チケットまたは認証器がプロトコルメッセージに含まれる場合、それは不透明なオブジェクトとして扱われます。チケットは、クライアントがサービスに認証するのに役立つレコードです。チケットには次の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "Ticket          ::= [APPLICATION 1] SEQUENCE {\n        tkt-vno         [0] INTEGER (5),\n        realm           [1] Realm,\n        sname           [2] PrincipalName,\n        enc-part        [3] EncryptedData -- EncTicketPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- Encrypted part of ticket\n   EncTicketPart   ::= [APPLICATION 3] SEQUENCE {\n        flags                   [0] TicketFlags,\n        key                     [1] EncryptionKey,\n        crealm                  [2] Realm,\n        cname                   [3] PrincipalName,\n        transited               [4] TransitedEncoding,\n        authtime                [5] KerberosTime,\n        starttime               [6] KerberosTime OPTIONAL,\n        endtime                 [7] KerberosTime,\n        renew-till              [8] KerberosTime OPTIONAL,\n        caddr                   [9] HostAddresses OPTIONAL,\n        authorization-data      [10] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- encoded Transited field\nTransitedEncoding       ::= SEQUENCE {\n        tr-type         [0] Int32 -- must be registered --,\n        contents        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TicketFlags     ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- may-postdate(5),\n        -- postdated(6),\n        -- invalid(7),\n        -- renewable(8),\n        -- initial(9),\n        -- pre-authent(10),\n        -- hw-authent(11),\n-- the following are new since 1510\n        -- transited-policy-checked(12),\n        -- ok-as-delegate(13)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tkt-vno This field specifies the version number for the ticket format. This document describes version number 5.",
      "ja": "TKT-VNOこのフィールドは、チケット形式のバージョン番号を指定します。このドキュメントでは、バージョン番号5について説明します。"
    },
    {
      "indent": 3,
      "text": "realm This field specifies the realm that issued a ticket. It also serves to identify the realm part of the server's principal identifier. Since a Kerberos server can only issue tickets for servers within its realm, the two will always be identical.",
      "ja": "レルムこのフィールドは、チケットを発行した領域を指定します。また、サーバーの主要な識別子のレルム部分を識別するのにも役立ちます。Kerberosサーバーは、その領域内のサーバーのチケットのみを発行できるため、2つは常に同じです。"
    },
    {
      "indent": 3,
      "text": "sname This field specifies all components of the name part of the server's identity, including those parts that identify a specific instance of a service.",
      "ja": "Snameこのフィールドは、サービスの特定のインスタンスを識別するパーツを含む、サーバーのIDの名前部分のすべてのコンポーネントを指定します。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds the encrypted encoding of the EncTicketPart sequence. It is encrypted in the key shared by Kerberos and the end server (the server's secret key), using a key usage value of 2.",
      "ja": "このフィールドは、encticketpartシーケンスの暗号化されたエンコードを保持します。KerberosとEnd Server（サーバーのシークレットキー）が共有するキーで暗号化されており、キー使用値は2です。"
    },
    {
      "indent": 3,
      "text": "flags This field indicates which of various options were used or requested when the ticket was issued. The meanings of the flags are as follows:",
      "ja": "フラグこのフィールドは、チケットが発行されたときに使用または要求されたさまざまなオプションのどれを示します。フラグの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Bit(s) Name Description",
      "ja": "ビット名の説明"
    },
    {
      "indent": 3,
      "text": "0 reserved Reserved for future expansion of this field.",
      "ja": "0このフィールドの将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "1 forwardable The FORWARDABLE flag is normally only interpreted by the TGS, and can be ignored by end servers. When set, this flag tells the ticket-granting server that it is OK to issue a new TGT with a different network address based on the presented ticket.",
      "ja": "1フォローダブルフォワーダブルフラグは通常、TGSによってのみ解釈され、ENDサーバーでは無視できます。設定すると、このフラグはチケットを獲得するサーバーに、提示されたチケットに基づいて別のネットワークアドレスで新しいTGTを発行しても問題ないことを伝えます。"
    },
    {
      "indent": 3,
      "text": "2 forwarded When set, this flag indicates that the ticket has either been forwarded or was issued based on authentication involving a forwarded TGT.",
      "ja": "2設定されたときに転送されるこのフラグは、チケットが転送されたTGTを含む認証に基づいて転送されたか、発行されたことを示します。"
    },
    {
      "indent": 3,
      "text": "3 proxiable The PROXIABLE flag is normally only interpreted by the TGS, and can be ignored by end servers. The PROXIABLE flag has an interpretation identical to that of the FORWARDABLE flag, except that the PROXIABLE flag tells the ticket-granting server that only non-TGTs may be issued with different network addresses.",
      "ja": "3プロキシ可能なプロキシ可能なフラグは通常、TGSによってのみ解釈され、ENDサーバーでは無視できます。Proxaibleフラグには、転送可能なフラグと同一の解釈がありますが、Proxaibleフラグはチケット栽培サーバーに、非TGTのみが異なるネットワークアドレスで発行される可能性があることを伝えます。"
    },
    {
      "indent": 3,
      "text": "4 proxy When set, this flag indicates that a ticket is a proxy.",
      "ja": "4プロキシ設定すると、このフラグはチケットがプロキシであることを示します。"
    },
    {
      "indent": 3,
      "text": "5 may-postdate The MAY-POSTDATE flag is normally only interpreted by the TGS, and can be ignored by end servers. This flag tells the ticket-granting server that a post-dated ticket MAY be issued based on this TGT.",
      "ja": "5 5月ポストデート5月撮影フラグは通常、TGSによってのみ解釈され、ENDサーバーによって無視できます。このフラグは、チケットを獲得するサーバーに、このTGTに基づいて事後のチケットが発行される可能性があることを伝えます。"
    },
    {
      "indent": 3,
      "text": "6 postdated This flag indicates that this ticket has been postdated. The end-service can check the authtime field to see when the original authentication occurred.",
      "ja": "6郵便番号このフラグは、このチケットが延期されたことを示しています。エンドサービスは、AuthTimeフィールドをチェックして、元の認証がいつ発生したかを確認できます。"
    },
    {
      "indent": 3,
      "text": "7 invalid This flag indicates that a ticket is invalid, and it must be validated by the KDC before use. Application servers must reject tickets which have this flag set.",
      "ja": "7無効このフラグは、チケットが無効であることを示し、使用前にKDCによって検証する必要があります。アプリケーションサーバーは、このフラグがセットされたチケットを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "8 renewable The RENEWABLE flag is normally only interpreted by the TGS, and can usually be ignored by end servers (some particularly careful servers MAY disallow renewable tickets). A renewable ticket can be used to obtain a replacement ticket that expires at a later date.",
      "ja": "8再生可能再生可能フラグは通常、TGSによってのみ解釈され、通常はエンドサーバーによって無視できます（特に慎重なサーバーは再生可能チケットを禁止する可能性があります）。再生可能なチケットを使用して、後日有効期限が切れる交換チケットを入手できます。"
    },
    {
      "indent": 3,
      "text": "9 initial This flag indicates that this ticket was issued using the AS protocol, and not issued based on a TGT.",
      "ja": "9初期このフラグは、このチケットがASプロトコルを使用して発行され、TGTに基づいて発行されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "10 pre-authent This flag indicates that during initial authentication, the client was authenticated by the KDC before a ticket was issued. The strength of the pre-authentication method is not indicated, but is acceptable to the KDC.",
      "ja": "10事前認証このフラグは、最初の認証中に、チケットが発行される前にクライアントがKDCによって認証されたことを示しています。受託前の方法の強度は示されていませんが、KDCには受け入れられます。"
    },
    {
      "indent": 3,
      "text": "11 hw-authent This flag indicates that the protocol employed for initial authentication required the use of hardware expected to be possessed solely by the named client. The hardware authentication method is selected by the KDC and the strength of the method is not indicated.",
      "ja": "11 HW-authentこのフラグは、初期認証に使用されたプロトコルが、指名されたクライアントのみが所有すると予想されるハードウェアの使用を必要とすることを示しています。ハードウェア認証方法はKDCによって選択され、メソッドの強度は示されていません。"
    },
    {
      "indent": 3,
      "text": "12 transited- This flag indicates that the KDC for policy-checked the realm has checked the transited field against a realm-defined policy for trusted certifiers. If this flag is reset (0), then the application server must check the transited field itself, and if unable to do so, it must reject the authentication. If the flag is set (1), then the application server MAY skip its own validation of the transited field, relying on the validation performed by the KDC. At its option the application server MAY still apply its own validation based on a separate policy for acceptance.",
      "ja": "12 TRANSIED-このフラグは、ポリシーチェックのKDCが、信頼できる認定因子の領域定義ポリシーに対して輸送フィールドをチェックしたことを示しています。このフラグがリセットされている場合（0）、アプリケーションサーバーは通過フィールド自体を確認する必要があり、そうしない場合は認証を拒否する必要があります。フラグが設定されている場合（1）、アプリケーションサーバーは、KDCによって実行された検証に依存して、送信フィールドの独自の検証をスキップする場合があります。そのオプションでは、アプリケーションサーバーは、受け入れのための個別のポリシーに基づいて、独自の検証を適用する場合があります。"
    },
    {
      "indent": 28,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以来新しいものです。"
    },
    {
      "indent": 3,
      "text": "13 ok-as-delegate This flag indicates that the server (not the client) specified in the ticket has been determined by policy of the realm to be a suitable recipient of delegation. A client can use the presence of this flag to help it decide whether to delegate credentials (either grant a proxy or a forwarded TGT) to this server. The client is free to ignore the value of this flag. When setting this flag, an administrator should consider the security and placement of the server on which the service will run, as well as whether the service requires the use of delegated credentials.",
      "ja": "13 OK-DELEGATEこのフラグは、チケットで指定されたサーバー（クライアントではない）が、領域のポリシーによって、代表団の適切な受信者であると判断されていることを示しています。クライアントは、このフラグの存在を使用して、このサーバーに資格情報（プロキシまたは転送されたTGTを付与）を委任するかどうかを決定するのに役立ちます。クライアントは、このフラグの価値を自由に無視できます。このフラグを設定するとき、管理者は、サービスが実行されるサーバーのセキュリティと配置、およびサービスが委任された資格情報の使用を必要とするかどうかを考慮する必要があります。"
    },
    {
      "indent": 28,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以来新しいものです。"
    },
    {
      "indent": 3,
      "text": "14-31 reserved Reserved for future use.",
      "ja": "14-31将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "key This field exists in the ticket and the KDC response and is used to pass the session key from Kerberos to the application server and the client.",
      "ja": "キーこのフィールドはチケットとKDC応答に存在し、Kerberosからアプリケーションサーバーとクライアントにセッションキーを渡すために使用されます。"
    },
    {
      "indent": 3,
      "text": "crealm This field contains the name of the realm in which the client is registered and in which initial authentication took place.",
      "ja": "CREALMこのフィールドには、クライアントが登録され、初期認証が行われた領域の名前が含まれています。"
    },
    {
      "indent": 3,
      "text": "cname This field contains the name part of the client's principal identifier.",
      "ja": "CNAMEこのフィールドには、クライアントの主要な識別子の名前部分が含まれています。"
    },
    {
      "indent": 3,
      "text": "transited This field lists the names of the Kerberos realms that took part in authenticating the user to whom this ticket was issued. It does not specify the order in which the realms were transited. See Section 3.3.3.2 for details on how this field encodes the traversed realms. When the names of CAs are to be embedded in the transited field (as specified for some extensions to the protocol), the X.500 names of the CAs SHOULD be mapped into items in the transited field using the mapping defined by RFC 2253.",
      "ja": "Transitedこのフィールドは、このチケットが発行されたユーザーを認証することに参加したKerberos Realmsの名前をリストします。領域が通過した順序は指定されていません。このフィールドでは、トラバースレルムをエンコードする方法の詳細については、セクション3.3.3.2を参照してください。CASの名前を通過フィールドに（プロトコルへの一部の拡張に指定するように）埋め込まれる場合、RFC 2253で定義されたマッピングを使用して、CASのX.500名を通過フィールドのアイテムにマッピングする必要があります。"
    },
    {
      "indent": 3,
      "text": "authtime This field indicates the time of initial authentication for the named principal. It is the time of issue for the original ticket on which this ticket is based. It is included in the ticket to provide additional information to the end service, and to provide the necessary information for implementation of a \"hot list\" service at the KDC. An end service that is particularly paranoid could refuse to accept tickets for which the initial authentication occurred \"too far\" in the past. This field is also returned as part of the response from the KDC. When it is returned as part of the response to initial authentication (KRB_AS_REP), this is the current time on the Kerberos server. It is NOT recommended that this time value be used to adjust the workstation's clock, as the workstation cannot reliably determine that such a KRB_AS_REP actually came from the proper KDC in a timely manner.",
      "ja": "AuthTimeこのフィールドは、指名されたプリンシパルの初期認証の時間を示します。これは、このチケットが基づいている元のチケットの問題の時間です。最終サービスに追加情報を提供し、KDCでの「ホットリスト」サービスの実装に必要な情報を提供するために、チケットに含まれています。特に妄想的な最終サービスは、過去に「あまりにも遠すぎる」最初の認証が発生したチケットの受け入れを拒否する可能性があります。このフィールドは、KDCからの応答の一部としても返されます。初期認証（KRB_AS_REP）への応答の一部として返されると、これはKerberosサーバーの現在の時刻です。ワークステーションは、そのようなKRB_AS_REPが実際に適切なKDCからタイムリーに来たことを確実に判断できないため、この時間値をワークステーションの時計を調整するために使用することはお勧めしません。"
    },
    {
      "indent": 3,
      "text": "starttime This field in the ticket specifies the time after which the ticket is valid. Together with endtime, this field specifies the life of the ticket. If the starttime field is absent from the ticket, then the authtime field SHOULD be used in its place to determine the life of the ticket.",
      "ja": "チケットのこのフィールドの開始時刻は、チケットが有効な時間を指定します。終了時間とともに、このフィールドはチケットの寿命を指定します。開始時刻フィールドがチケットに存在しない場合、チケットの寿命を決定するために、その代わりにAuthTimeフィールドを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "endtime This field contains the time after which the ticket will not be honored (its expiration time). Note that individual services MAY place their own limits on the life of a ticket and MAY reject tickets which have not yet expired. As such, this is really an upper bound on the expiration time for the ticket.",
      "ja": "終了時間このフィールドには、チケットが尊重されない時間（有効期限）が含まれています。個々のサービスは、チケットの寿命に独自の制限を設ける可能性があり、まだ期限切れになっていないチケットを拒否する可能性があることに注意してください。そのため、これは本当にチケットの有効期限の上限です。"
    },
    {
      "indent": 3,
      "text": "renew-till This field is only present in tickets that have the RENEWABLE flag set in the flags field. It indicates the maximum endtime that may be included in a renewal. It can be thought of as the absolute expiration time for the ticket, including all renewals.",
      "ja": "更新このフィールドは、フラグフィールドに再生可能フラグが設定されたチケットにのみ存在します。更新に含まれる可能性のある最大エンドタイムを示します。それは、すべての更新を含むチケットの絶対的な有効期限と考えることができます。"
    },
    {
      "indent": 3,
      "text": "caddr This field in a ticket contains zero (if omitted) or more (if present) host addresses. These are the addresses from which the ticket can be used. If there are no addresses, the ticket can be used from any location. The decision by the KDC to issue or by the end server to accept addressless tickets is a policy decision and is left to the Kerberos and end-service administrators; they MAY refuse to issue or accept such tickets. Because of the wide deployment of network address translation, it is recommended that policy allow the issue and acceptance of such tickets.",
      "ja": "CADDRチケットのこのフィールドには、ゼロ（省略されている場合）またはそれ以上（存在する場合）ホストアドレスが含まれています。これらは、チケットを使用できるアドレスです。アドレスがない場合、チケットは任意の場所から使用できます。KDCが発行するか、アドレスレスチケットを受け入れるという最終サーバーによる決定は、ポリシー決定であり、KerberosおよびEnd-Service管理者に任されています。彼らはそのようなチケットを発行または受け入れることを拒否するかもしれません。ネットワークアドレスの変換が幅広く展開されているため、ポリシーがそのようなチケットの問題と受け入れを許可することをお勧めします。"
    },
    {
      "indent": 6,
      "text": "Network addresses are included in the ticket to make it harder for an attacker to use stolen credentials. Because the session key is not sent over the network in cleartext, credentials can't be stolen simply by listening to the network; an attacker has to gain access to the session key (perhaps through operating system security breaches or a careless user's unattended session) to make use of stolen tickets.",
      "ja": "ネットワークアドレスは、攻撃者が盗まれた資格情報を使用することを難しくするためにチケットに含まれています。セッションキーはClearTextのネットワーク上に送信されないため、ネットワークを聞くだけで資格情報を盗むことはできません。攻撃者は、盗まれたチケットを利用するために、セッションキー（おそらくオペレーティングシステムのセキュリティ侵害または不注意なユーザーの無人セッションを通じて）にアクセスする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note that the network address from which a connection is received cannot be reliably determined. Even if it could be, an attacker who has compromised the client's workstation could use the credentials from there. Including the network addresses only makes it more difficult, not impossible, for an attacker to walk off with stolen credentials and then to use them from a \"safe\" location.",
      "ja": "接続が受信されるネットワークアドレスを確実に決定できないことに注意してください。たとえそうであっても、クライアントのワークステーションを妥協した攻撃者は、そこから資格情報を使用できます。ネットワークアドレスを含めるだけで、攻撃者が盗まれた資格情報を持って立ち去り、「安全な」場所からそれらを使用することが不可能ではなく、より困難になります。"
    },
    {
      "indent": 3,
      "text": "authorization-data The authorization-data field is used to pass authorization data from the principal on whose behalf a ticket was issued to the application service. If no authorization data is included, this field will be left out. Experience has shown that the name of this field is confusing, and that a better name would be \"restrictions\". Unfortunately, it is not possible to change the name at this time.",
      "ja": "承認-DATA Authorization-DATAフィールドは、チケットが申請サービスに発行された校長から認証データを渡すために使用されます。承認データが含まれていない場合、このフィールドは除外されます。経験は、このフィールドの名前が混乱しており、より良い名前が「制限」であることを示しています。残念ながら、現時点では名前を変更することはできません。"
    },
    {
      "indent": 6,
      "text": "This field contains restrictions on any authority obtained on the basis of authentication using the ticket. It is possible for any principal in possession of credentials to add entries to the authorization data field since these entries further restrict what can be done with the ticket. Such additions can be made by specifying the additional entries when a new ticket is obtained during the TGS exchange, or they MAY be added during chained delegation using the authorization data field of the authenticator.",
      "ja": "このフィールドには、チケットを使用した認証に基づいて取得された当局の制限が含まれています。資格情報を所有しているプリンシパルは、これらのエントリがチケットで何ができるかをさらに制限するため、承認データフィールドにエントリを追加することが可能です。このような追加は、TGS交換中に新しいチケットが取得されたときに追加のエントリを指定することによって行うことができます。または、認証機の認証データフィールドを使用してチェーン委任中に追加される場合があります。"
    },
    {
      "indent": 6,
      "text": "Because entries may be added to this field by the holder of credentials, except when an entry is separately authenticated by encapsulation in the KDC-issued element, it is not allowable for the presence of an entry in the authorization data field of a ticket to amplify the privileges one would obtain from using a ticket.",
      "ja": "エントリがKDC発行要素のカプセル化によってエントリが個別に認証されている場合を除き、エントリは資格情報の所有者によってこのフィールドに追加される可能性があるため、チケットの認証データフィールドにエントリが存在する場合は許可されません。チケットの使用から得られる特権。"
    },
    {
      "indent": 6,
      "text": "The data in this field may be specific to the end service; the field will contain the names of service specific objects, and the rights to those objects. The format for this field is described in Section 5.2.6. Although Kerberos is not concerned with the format of the contents of the subfields, it does carry type information (ad-type).",
      "ja": "このフィールドのデータは、最終サービスに固有の場合があります。フィールドには、サービス固有のオブジェクトの名前とそれらのオブジェクトに対する権利が含まれます。このフィールドの形式については、セクション5.2.6で説明しています。Kerberosはサブフィールドの内容の形式には関心がありませんが、タイプ情報（AD-Type）を運びます。"
    },
    {
      "indent": 6,
      "text": "By using the authorization_data field, a principal is able to issue a proxy that is valid for a specific purpose. For example, a client wishing to print a file can obtain a file server proxy to be passed to the print server. By specifying the name of the file in the authorization_data field, the file server knows that the print server can only use the client's rights when accessing the particular file to be printed.",
      "ja": "Authorization_Dataフィールドを使用することにより、プリンシパルは特定の目的に有効なプロキシを発行できます。たとえば、ファイルを印刷したいクライアントは、印刷サーバーに渡されるファイルサーバープロキシを取得できます。Authorization_Dataフィールドにファイルの名前を指定することにより、ファイルサーバーは、印刷サーバーが印刷する特定のファイルにアクセスするときにのみクライアントの権利を使用できることを知っています。"
    },
    {
      "indent": 6,
      "text": "A separate service providing authorization or certifying group membership may be built using the authorization-data field. In this case, the entity granting authorization (not the authorized entity) may obtain a ticket in its own name (e.g., the ticket is issued in the name of a privilege server), and this entity adds restrictions on its own authority and delegates the restricted authority through a proxy to the client. The client would then present this authorization credential to the application server separately from the authentication exchange. Alternatively, such authorization credentials MAY be embedded in the ticket authenticating the authorized entity, when the authorization is separately authenticated using the KDC-issued authorization data element (see 5.2.6.2).",
      "ja": "認証または認定グループメンバーシップを提供する別のサービスは、認証データフィールドを使用して構築できます。この場合、認可を付与するエンティティ（認定エンティティではない）は、独自の名前でチケットを取得できます（たとえば、チケットは特権サーバーの名前で発行されます）。このエンティティは、独自の権限に制限を追加し、クライアントへのプロキシを通じて権限を制限しました。クライアントは、この認証資格情報を認証交換とは別にアプリケーションサーバーに提示します。あるいは、KDC発行の認証データ要素を使用して認証が個別に認証されている場合、そのような承認資格情報は、認可されたエンティティを認証するチケットに埋め込まれる場合があります（5.2.6.2を参照）。"
    },
    {
      "indent": 6,
      "text": "Similarly, if one specifies the authorization-data field of a proxy and leaves the host addresses blank, the resulting ticket and session key can be treated as a capability. See [Neu93] for some suggested uses of this field.",
      "ja": "同様に、プロキシの承認データフィールドを指定し、ホストアドレスを空白のままにすると、結果のチケットとセッションキーを機能として扱うことができます。このフィールドのいくつかの提案された使用については、[neu93]を参照してください。"
    },
    {
      "indent": 6,
      "text": "The authorization-data field is optional and does not have to be included in a ticket.",
      "ja": "承認データフィールドはオプションであり、チケットに含める必要はありません。"
    },
    {
      "indent": 0,
      "text": "5.4. Specifications for the AS and TGS Exchanges",
      "section_title": true,
      "ja": "5.4. ASおよびTGS交換の仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of the messages used in the exchange between the client and the Kerberos server. The format of possible error messages appears in Section 5.9.1.",
      "ja": "このセクションでは、クライアントとKerberosサーバーの交換で使用されるメッセージの形式を指定します。可能なエラーメッセージの形式は、セクション5.9.1に表示されます。"
    },
    {
      "indent": 0,
      "text": "5.4.1. KRB_KDC_REQ Definition",
      "section_title": true,
      "ja": "5.4.1. KRB_KDC_REQ定義"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REQ message has no application tag number of its own. Instead, it is incorporated into either KRB_AS_REQ or KRB_TGS_REQ, each of which has an application tag, depending on whether the request is for an initial ticket or an additional ticket. In either case, the message is sent from the client to the KDC to request credentials for a service.",
      "ja": "KRB_KDC_REQメッセージには、独自のアプリケーションタグ番号がありません。代わりに、krb_as_reqまたはkrb_tgs_reqのいずれかに組み込まれます。各krb_tgs_reqには、リクエストが初期チケットか追加チケットのかどうかに応じて、アプリケーションタグがあります。どちらの場合でも、メッセージはクライアントからKDCに送信され、サービスの資格情報を要求します。"
    },
    {
      "indent": 3,
      "text": "The message fields are as follows:",
      "ja": "メッセージフィールドは次のとおりです。"
    },
    {
      "indent": 0,
      "text": "AS-REQ          ::= [APPLICATION 10] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REQ         ::= [APPLICATION 12] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n                            -- NOTE: not empty --,\n        req-body        [4] KDC-REQ-BODY\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions,\n        cname                   [1] PrincipalName OPTIONAL\n                                    -- Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    -- Server's realm\n                                    -- Also client's in AS-REQ --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from                    [4] KerberosTime OPTIONAL,\n        till                    [5] KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce                   [7] UInt32,\n        etype                   [8] SEQUENCE OF Int32 -- EncryptionType\n                                    -- in preference order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data  [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                       -- NOTE: not empty\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        -- renewable(8),\n        -- unused9(9),\n        -- unused10(10),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "        -- opt-hardware-auth(11),\n        -- unused12(12),\n        -- unused13(13),\n-- 15 is reserved for canonicalize\n        -- unused15(15),\n-- 26 was unused in 1510\n        -- disable-transited-check(26),\n--\n        -- renewable-ok(27),\n        -- enc-tkt-in-skey(28),\n        -- renew(30),\n        -- validate(31)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields in this message are as follows:",
      "ja": "このメッセージのフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "pvno This field is included in each message, and specifies the protocol version number. This document specifies protocol version 5.",
      "ja": "PVNOこのフィールドは各メッセージに含まれており、プロトコルバージョン番号を指定します。このドキュメントは、プロトコルバージョン5を指定します。"
    },
    {
      "indent": 3,
      "text": "msg-type This field indicates the type of a protocol message. It will almost always be the same as the application identifier associated with a message. It is included to make the identifier more readily accessible to the application. For the KDC-REQ message, this type will be KRB_AS_REQ or KRB_TGS_REQ.",
      "ja": "MSGタイプこのフィールドは、プロトコルメッセージのタイプを示します。ほとんどの場合、メッセージに関連付けられたアプリケーション識別子と同じです。識別子をアプリケーションに対してより簡単にアクセスしやすくするために含まれています。KDC-REQメッセージの場合、このタイプはkrb_as_reqまたはkrb_tgs_reqです。"
    },
    {
      "indent": 3,
      "text": "padata Contains pre-authentication data. Requests for additional tickets (KRB_TGS_REQ) MUST contain a padata of PA-TGS-REQ.",
      "ja": "Padataには、認証前のデータが含まれています。追加のチケット（krb_tgs_req）のリクエストには、pa-tgs-reqのパダタが含まれている必要があります。"
    },
    {
      "indent": 6,
      "text": "The padata (pre-authentication data) field contains a sequence of authentication information that may be needed before credentials can be issued or decrypted.",
      "ja": "Padata（Pre-Authentication Data）フィールドには、資格情報を発行または復号化する前に必要になる可能性のある認証情報のシーケンスが含まれています。"
    },
    {
      "indent": 3,
      "text": "req-body This field is a placeholder delimiting the extent of the remaining fields. If a checksum is to be calculated over the request, it is calculated over an encoding of the KDC-REQ-BODY sequence which is enclosed within the req-body field.",
      "ja": "req-bodyこのフィールドは、残りのフィールドの範囲を区切るプレースホルダーです。チェックサムがリクエストを介して計算される場合、Req-Bodyフィールド内に囲まれたKDC-Req-Bodyシーケンスのエンコードで計算されます。"
    },
    {
      "indent": 3,
      "text": "kdc-options This field appears in the KRB_AS_REQ and KRB_TGS_REQ requests to the KDC and indicates the flags that the client wants set on the tickets as well as other information that is to modify the behavior of the KDC. Where appropriate, the name of an option may be the same as the flag that is set by that option. Although in most cases, the bit in the options field will be the same as that in the flags field, this is not guaranteed, so it is not acceptable simply to copy the options field to the flags field. There are various checks that must be made before an option is honored anyway.",
      "ja": "KDC-OPTIONSこのフィールドは、KRB_AS_REQおよびKRB_TGS_REQリクエストにKDCに表示され、クライアントがチケットに設定したいフラグと、KDCの動作を変更する他の情報を示します。必要に応じて、オプションの名前は、そのオプションによって設定されたフラグと同じである場合があります。ほとんどの場合、オプションフィールドのビットはフラグフィールドのビットと同じですが、これは保証されていないため、オプションフィールドをフラグフィールドにコピーするだけでは受け入れられません。とにかくオプションが尊重される前に行う必要があるさまざまなチェックがあります。"
    },
    {
      "indent": 6,
      "text": "The kdc_options field is a bit-field, where the selected options are indicated by the bit being set (1), and the unselected options and reserved fields being reset (0). The encoding of the bits is specified in Section 5.2. The options are described in more detail above in Section 2. The meanings of the options are as follows:",
      "ja": "KDC_OPTIONSフィールドはビットフィールドであり、選択したオプションはビットが設定されていること（1）で示され、選択されていないオプションとリセットされたフィールド（0）が表示されます。ビットのエンコードは、セクション5.2で指定されています。オプションについては、セクション2で上記の詳細について説明します。オプションの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Bits Name Description",
      "ja": "ビット名の説明"
    },
    {
      "indent": 3,
      "text": "0 RESERVED Reserved for future expansion of this field.",
      "ja": "0このフィールドの将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "1 FORWARDABLE The FORWARDABLE option indicates that the ticket to be issued is to have its forwardable flag set. It may only be set on the initial request, or in a subsequent request if the TGT on which it is based is also forwardable.",
      "ja": "1フォローダブルフォワーダーブルオプションは、発行されるチケットがフォローダブルフラグを設定することであることを示しています。最初のリクエストでのみ設定されるか、その後のTGTが先送り可能な場合にのみ設定できます。"
    },
    {
      "indent": 3,
      "text": "2 FORWARDED The FORWARDED option is only specified in a request to the ticket-granting server and will only be honored if the TGT in the request has its FORWARDABLE bit set. This option indicates that this is a request for forwarding. The address(es) of the host from which the resulting ticket is to be valid are included in the addresses field of the request.",
      "ja": "2転送された転送オプションは、チケット獲得サーバーへのリクエストでのみ指定され、リクエストのTGTにフォローダブルビットセットがある場合にのみ表彰されます。このオプションは、これが転送のリクエストであることを示しています。結果のチケットを有効にするホストのアドレスは、リクエストのアドレスフィールドに含まれています。"
    },
    {
      "indent": 3,
      "text": "3 PROXIABLE The PROXIABLE option indicates that the ticket to be issued is to have its proxiable flag set. It may only be set on the initial request, or a subsequent request if the TGT on which it is based is also proxiable.",
      "ja": "3プロキシ可能なプロキシ可能なオプションは、発行されるチケットがProxaibleフラグを設定することであることを示しています。最初のリクエスト、またはそれが基づいているTGTもプロキシ可能な場合にのみ設定される場合があります。"
    },
    {
      "indent": 3,
      "text": "4 PROXY The PROXY option indicates that this is a request for a proxy. This option will only be honored if the TGT in the request has its PROXIABLE bit set. The address(es) of the host from which the resulting ticket is to be valid are included in the addresses field of the request.",
      "ja": "4プロキシプロキシオプションは、これがプロキシのリクエストであることを示します。このオプションは、リクエストのTGTにProxaible Bit Setが設定されている場合にのみ表彰されます。結果のチケットを有効にするホストのアドレスは、リクエストのアドレスフィールドに含まれています。"
    },
    {
      "indent": 3,
      "text": "5 ALLOW-POSTDATE The ALLOW-POSTDATE option indicates that the ticket to be issued is to have its MAY-POSTDATE flag set. It may only be set on the initial request, or in a subsequent request if the TGT on which it is based also has its MAY-POSTDATE flag set.",
      "ja": "5 Allow-PostDate Allow-PostDateオプションは、発行されるチケットが5月のフラグを設定することであることを示しています。最初のリクエストでのみ設定される場合があります。または、そのベースのTGTに5月のフラグセットもある場合、後続のリクエストでのみ設定できます。"
    },
    {
      "indent": 3,
      "text": "6 POSTDATED The POSTDATED option indicates that this is a request for a postdated ticket. This option will only be honored if the TGT on which it is based has its MAY-POSTDATE flag set. The resulting ticket will also have its INVALID flag set, and that flag may be reset by a subsequent request to the KDC after the starttime in the ticket has been reached.",
      "ja": "6郵便延期オプションは、これが郵便局面のチケットのリクエストであることを示します。このオプションは、そのベースのTGTに5月のフラグセットがある場合にのみ表彰されます。結果のチケットには無効なフラグが設定され、チケットの開始時にその後のKDCへのリクエストが到達した後、そのフラグがリセットされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "7 RESERVED This option is presently unused.",
      "ja": "7予約されたこのオプションは現在未使用です。"
    },
    {
      "indent": 3,
      "text": "8 RENEWABLE The RENEWABLE option indicates that the ticket to be issued is to have its RENEWABLE flag set. It may only be set on the initial request, or when the TGT on which the request is based is also renewable. If this option is requested, then the rtime field in the request contains the desired absolute expiration time for the ticket.",
      "ja": "8再生可能再生可能オプションは、発行されるチケットが再生可能フラグを設定することであることを示しています。最初の要求に基づいてのみ、またはリクエストの基礎となるTGTが再生可能である場合にのみ設定されます。このオプションが要求された場合、リクエストのRTIMEフィールドには、チケットの目的の絶対有効期限が含まれます。"
    },
    {
      "indent": 3,
      "text": "9 RESERVED Reserved for PK-Cross.",
      "ja": "9 PK-Crossの予約された予約。"
    },
    {
      "indent": 3,
      "text": "10 RESERVED Reserved for future use.",
      "ja": "10将来の使用のために予約された予約。"
    },
    {
      "indent": 3,
      "text": "11 RESERVED Reserved for opt-hardware-auth.",
      "ja": "11は、opt-hardware-auth専用の予約されています。"
    },
    {
      "indent": 3,
      "text": "12-25 RESERVED Reserved for future use.",
      "ja": "12-25将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "26 DISABLE-TRANSITED-CHECK By default the KDC will check the transited field of a TGT against the policy of the local realm before it will issue derivative tickets based on the TGT. If this flag is set in the request, checking of the transited field is disabled. Tickets issued without the performance of this check will be noted by the reset (0) value of the TRANSITED-POLICY-CHECKED flag, indicating to the application server that the transited field must be checked locally. KDCs are encouraged but not required to honor the DISABLE-TRANSITED-CHECK option.",
      "ja": "26無効輸送チェックデフォルトでは、KDCは、TGTに基づいてデリバティブチケットを発行する前に、ローカルレルムのポリシーに対してTGTの通過フィールドをチェックします。このフラグがリクエストに設定されている場合、輸送フィールドのチェックが無効になります。このチェックのパフォーマンスなしで発行されたチケットは、トランジーされたポリシーチェックフラグのリセット（0）値によって記録され、輸送フィールドをローカルでチェックする必要があることをアプリケーションサーバーに示します。KDCは奨励されていますが、無効化されたチェックチェックオプションを尊重する必要はありません。"
    },
    {
      "indent": 36,
      "text": "This flag is new since RFC 1510.",
      "ja": "このフラグは、RFC 1510以来新しいものです。"
    },
    {
      "indent": 3,
      "text": "27 RENEWABLE-OK The RENEWABLE-OK option indicates that a renewable ticket will be acceptable if a ticket with the requested life cannot otherwise be provided, in which case a renewable ticket may be issued with a renew-till equal to the requested endtime. The value of the renew-till field may still be limited by local limits, or limits selected by the individual principal or server.",
      "ja": "27 Renewable-OK Renewable-OKオプションは、要求された寿命のあるチケットを提供できない場合、再生可能チケットが許容できることを示しています。更新フィールドの値は、局所的な制限によって制限される場合があります。また、個々のプリンシパルまたはサーバーによって選択された制限があります。"
    },
    {
      "indent": 3,
      "text": "28 ENC-TKT-IN-SKEY This option is used only by the ticket-granting service. The ENC-TKT-IN-SKEY option indicates that the ticket for the end server is to be encrypted in the session key from the additional TGT provided.",
      "ja": "28 ENC-TKT-IN-SKEYこのオプションは、チケット栽培サービスによってのみ使用されます。Enc-TKT-in-Skeyオプションは、提供された追加のTGTのセッションキーでエンドサーバーのチケットが暗号化されることを示します。"
    },
    {
      "indent": 3,
      "text": "29 RESERVED Reserved for future use.",
      "ja": "29将来の使用のために予約された予約。"
    },
    {
      "indent": 3,
      "text": "30 RENEW This option is used only by the ticket-granting service. The RENEW option indicates that the present request is for a renewal. The ticket provided is encrypted in the secret key for the server on which it is valid. This option will only be honored if the ticket to be renewed has its RENEWABLE flag set and if the time in its renew-till field has not passed. The ticket to be renewed is passed in the padata field as part of the authentication header.",
      "ja": "30更新このオプションは、チケット栽培サービスによってのみ使用されます。更新オプションは、現在のリクエストが更新のものであることを示しています。提供されるチケットは、有効なサーバーのシークレットキーで暗号化されています。このオプションは、更新されるチケットに再生可能フラグが設定されており、更新フィールドの時間が経過していない場合にのみ表彰されます。更新されるチケットは、認証ヘッダーの一部としてPadataフィールドで渡されます。"
    },
    {
      "indent": 3,
      "text": "31 VALIDATE This option is used only by the ticket-granting service. The VALIDATE option indicates that the request is to validate a postdated ticket. It will only be honored if the ticket presented is postdated, presently has its INVALID flag set, and would otherwise be usable at this time. A ticket cannot be validated before its starttime. The ticket presented for validation is encrypted in the key of the server for which it is valid and is passed in the padata field as part of the authentication header.",
      "ja": "31検証このオプションは、チケット栽培サービスによってのみ使用されます。検証オプションは、リクエストが延期されたチケットを検証することであることを示します。提示されたチケットが郵便登録されており、現在その無効なフラグが設定されており、そうでなければ現時点では使用可能である場合にのみ光栄です。チケットは、開始時に検証することはできません。検証のために提示されたチケットは、それが有効であるサーバーのキーで暗号化され、認証ヘッダーの一部としてPadataフィールドに渡されます。"
    },
    {
      "indent": 3,
      "text": "cname and sname These fields are the same as those described for the ticket in section 5.3. The sname may only be absent when the ENC-TKT-IN-SKEY option is specified. If the sname is absent, the name of the server is taken from the name of the client in the ticket passed as additional-tickets.",
      "ja": "これらのフィールドは、セクション5.3のチケットについて説明したものと同じです。Snameは、Enc-TKT-In-Skeyオプションが指定されている場合にのみ存在しない場合があります。スナムが欠けている場合、サーバーの名前は、チケットのクライアントの名前から追加のチケットとして渡されます。"
    },
    {
      "indent": 3,
      "text": "enc-authorization-data The enc-authorization-data, if present (and it can only be present in the TGS_REQ form), is an encoding of the desired authorization-data encrypted under the sub-session key if present in the Authenticator, or alternatively from the session key in the TGT (both the Authenticator and TGT come from the padata field in the KRB_TGS_REQ). The key usage value used when encrypting is 5 if a sub-session key is used, or 4 if the session key is used.",
      "ja": "enc-authorization-data存在する場合（およびTGS_REQ形式にのみ存在することができる場合）、enc-authorization-dataは、サブセッションキーの下に暗号化された希望の認証データのエンコードです。代わりに、TGTのセッションキーから（AuthenticatorとTGTの両方がKRB_TGS_REQのPadataフィールドから来ています）。暗号化の場合に使用されるキー使用値は、サブセッションキーが使用される場合は5、セッションキーが使用されている場合は4です。"
    },
    {
      "indent": 3,
      "text": "realm This field specifies the realm part of the server's principal identifier. In the AS exchange, this is also the realm part of the client's principal identifier.",
      "ja": "レルムこのフィールドは、サーバーの主要な識別子のレルム部分を指定します。AS Exchangeでは、これはクライアントの主要な識別子の領域でもあります。"
    },
    {
      "indent": 3,
      "text": "from This field is included in the KRB_AS_REQ and KRB_TGS_REQ ticket requests when the requested ticket is to be postdated. It specifies the desired starttime for the requested ticket. If this field is omitted, then the KDC SHOULD use the current time instead.",
      "ja": "このフィールドから、要求されたチケットを郵送する場合、KRB_AS_REQおよびKRB_TGS_REQチケットリクエストに含まれています。要求されたチケットの目的の開始時間を指定します。このフィールドが省略されている場合、KDCは代わりに現在の時間を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "till This field contains the expiration date requested by the client in a ticket request. It is not optional, but if the requested endtime is \"19700101000000Z\", the requested ticket is to have the maximum endtime permitted according to KDC policy. Implementation note: This special timestamp corresponds to a UNIX time_t value of zero on most systems.",
      "ja": "このフィールドには、チケットリクエストでクライアントが要求した有効期限が含まれています。オプションではありませんが、要求されたエンドタイムが「19700101000000Z」の場合、要求されたチケットは、KDCポリシーに従って最大エンドタイムを許可することです。実装注：この特別なタイムスタンプは、ほとんどのシステムでゼロのUNIX Time_T値に対応しています。"
    },
    {
      "indent": 3,
      "text": "rtime This field is the requested renew-till time sent from a client to the KDC in a ticket request. It is optional.",
      "ja": "rtimeこのフィールドは、チケットリクエストでクライアントからKDCに送信される要求された更新時間です。オプションです。"
    },
    {
      "indent": 3,
      "text": "nonce This field is part of the KDC request and response. It is intended to hold a random number generated by the client. If the same number is included in the encrypted response from the KDC, it provides evidence that the response is fresh and has not been replayed by an attacker. Nonces MUST NEVER be reused.",
      "ja": "Nonceこのフィールドは、KDCリクエストと応答の一部です。クライアントによって生成された乱数を保持することを目的としています。KDCからの暗号化された応答に同じ番号が含まれている場合、応答が新鮮で攻撃者によって再生されていないという証拠が提供されます。Noncesを再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "etype This field specifies the desired encryption algorithm to be used in the response.",
      "ja": "Etypeこのフィールドは、応答で使用する目的の暗号化アルゴリズムを指定します。"
    },
    {
      "indent": 3,
      "text": "addresses This field is included in the initial request for tickets, and it is optionally included in requests for additional tickets from the ticket-granting server. It specifies the addresses from which the requested ticket is to be valid. Normally it includes the addresses for the client's host. If a proxy is requested, this field will contain other addresses. The contents of this field are usually copied by the KDC into the caddr field of the resulting ticket.",
      "ja": "アドレスこのフィールドは、チケットの最初のリクエストに含まれており、オプションでチケット栽培サーバーからの追加チケットのリクエストに含まれています。要求されたチケットが有効であるアドレスを指定します。通常、クライアントのホストのアドレスが含まれます。プロキシが要求された場合、このフィールドには他のアドレスが含まれます。このフィールドの内容は、通常、KDCによって結果のチケットのCADDRフィールドにコピーされます。"
    },
    {
      "indent": 3,
      "text": "additional-tickets Additional tickets MAY be optionally included in a request to the ticket-granting server. If the ENC-TKT-IN-SKEY option has been specified, then the session key from the additional ticket will be used in place of the server's key to encrypt the new ticket. When the ENC-TKT-IN-SKEY option is used for user-to-user authentication, this additional ticket MAY be a TGT issued by the local realm or an inter-realm TGT issued for the current KDC's realm by a remote KDC. If more than one option that requires additional tickets has been specified, then the additional tickets are used in the order specified by the ordering of the options bits (see kdc-options, above).",
      "ja": "追加のチケット追加チケットは、オプションでチケット獲得サーバーへのリクエストに含まれる場合があります。Enc-Tkt-in-Skeyオプションが指定されている場合、追加のチケットのセッションキーがサーバーのキーの代わりに使用され、新しいチケットを暗号化します。ユーザーからユーザーへの認証にEnc-TKT-In-Skeyオプションが使用される場合、この追加チケットは、ローカルレルムが発行したTGTまたはリモートKDCによって現在のKDCの領域に対して発行されたTGTである場合があります。追加のチケットが必要な複数のオプションが指定されている場合、追加のチケットは、オプションビットの注文によって指定された順序で使用されます（上記のKDCオプションを参照）。"
    },
    {
      "indent": 3,
      "text": "The application tag number will be either ten (10) or twelve (12) depending on whether the request is for an initial ticket (AS-REQ) or for an additional ticket (TGS-REQ).",
      "ja": "アプリケーションタグ番号は、リクエストが初期チケット（AS-REQ）または追加のチケット（TGS-REQ）のかどうかに応じて、10（10）または12（12）のいずれかです。"
    },
    {
      "indent": 3,
      "text": "The optional fields (addresses, authorization-data, and additional-tickets) are only included if necessary to perform the operation specified in the kdc-options field.",
      "ja": "オプションのフィールド（アドレス、承認データ、および追加チケット）は、必要に応じてKDCオプションフィールドで指定された操作を実行するためにのみ含まれます。"
    },
    {
      "indent": 3,
      "text": "Note that in KRB_TGS_REQ, the protocol version number appears twice and two different message types appear: the KRB_TGS_REQ message contains these fields as does the authentication header (KRB_AP_REQ) that is passed in the padata field.",
      "ja": "KRB_TGS_REQでは、プロトコルバージョン番号が2回表示され、2つの異なるメッセージタイプが表示されます。KRB_TGS_REQメッセージには、Padataフィールドで渡される認証ヘッダー（krb_ap_req）と同様にこれらのフィールドが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.4.2. KRB_KDC_REP Definition",
      "section_title": true,
      "ja": "5.4.2. KRB_KDC_REP定義"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REP message format is used for the reply from the KDC for either an initial (AS) request or a subsequent (TGS) request. There is no message type for KRB_KDC_REP. Instead, the type will be either KRB_AS_REP or KRB_TGS_REP. The key used to encrypt the ciphertext part of the reply depends on the message type. For KRB_AS_REP, the ciphertext is encrypted in the client's secret key, and the client's key version number is included in the key version number for the encrypted data. For KRB_TGS_REP, the ciphertext is encrypted in the sub-session key from the Authenticator; if it is absent, the ciphertext is encrypted in the session key from the TGT used in the request. In that case, no version number will be present in the EncryptedData sequence.",
      "ja": "KRB_KDC_REPメッセージ形式は、初期（AS）要求または後続（TGS）リクエストのいずれかについて、KDCからの返信に使用されます。krb_kdc_repのメッセージタイプはありません。代わりに、タイプはkrb_as_repまたはkrb_tgs_repのいずれかになります。応答の暗号文の部分を暗号化するために使用されるキーは、メッセージタイプによって異なります。KRB_AS_REPの場合、ciphertextはクライアントのシークレットキーで暗号化され、クライアントのキーバージョン番号は暗号化されたデータのキーバージョン番号に含まれています。krb_tgs_repの場合、ciphertextは、認証機のサブセッションキーで暗号化されます。存在しない場合、ciphertextは、リクエストで使用されているTGTのセッションキーで暗号化されます。その場合、暗号化されたシーケンスにバージョン番号は存在しません。"
    },
    {
      "indent": 3,
      "text": "The KRB_KDC_REP message contains the following fields:",
      "ja": "KRB_KDC_REPメッセージには、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "AS-REP          ::= [APPLICATION 11] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TGS-REP         ::= [APPLICATION 13] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KDC-REP         ::= SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),\n        padata          [2] SEQUENCE OF PA-DATA OPTIONAL\n                                -- NOTE: not empty --,\n        crealm          [3] Realm,\n        cname           [4] PrincipalName,\n        ticket          [5] Ticket,\n        enc-part        [6] EncryptedData\n                                -- EncASRepPart or EncTGSRepPart,\n                                -- as appropriate\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart\n   EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKDCRepPart   ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        last-req        [1] LastReq,\n        nonce           [2] UInt32,\n        key-expiration  [3] KerberosTime OPTIONAL,\n        flags           [4] TicketFlags,\n        authtime        [5] KerberosTime,\n        starttime       [6] KerberosTime OPTIONAL,\n        endtime         [7] KerberosTime,\n        renew-till      [8] KerberosTime OPTIONAL,\n        srealm          [9] Realm,\n        sname           [10] PrincipalName,\n        caddr           [11] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "LastReq         ::=     SEQUENCE OF SEQUENCE {\n        lr-type         [0] Int32,\n        lr-value        [1] KerberosTime\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is either KRB_AS_REP or KRB_TGS_REP.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。MSG-TypeはKRB_AS_REPまたはKRB_TGS_REPのいずれかです。"
    },
    {
      "indent": 3,
      "text": "padata This field is described in detail in Section 5.4.1. One possible use for it is to encode an alternate \"salt\" string to be used with a string-to-key algorithm. This ability is useful for easing transitions if a realm name needs to change (e.g., when a company is acquired); in such a case all existing password-derived entries in the KDC database would be flagged as needing a special salt string until the next password change.",
      "ja": "Padataこのフィールドについては、セクション5.4.1で詳しく説明しています。そのための1つの用途は、文字列間アルゴリズムで使用される代替の「塩」文字列をエンコードすることです。この機能は、レルム名を変更する必要がある場合（たとえば、会社が買収されたとき）、移行を緩和するのに役立ちます。このような場合、KDCデータベースの既存のパスワード由来エントリはすべて、次のパスワードが変更されるまで特別な塩文字列が必要であるとフラグが付けられます。"
    },
    {
      "indent": 3,
      "text": "crealm, cname, srealm, and sname These fields are the same as those described for the ticket in section 5.3.",
      "ja": "CREALM、CNAME、SREALM、およびSNAMEこれらのフィールドは、セクション5.3のチケットについて説明したものと同じです。"
    },
    {
      "indent": 3,
      "text": "ticket The newly-issued ticket, from Section 5.3.",
      "ja": "セクション5.3から新しく発行されたチケットをチケット。"
    },
    {
      "indent": 3,
      "text": "enc-part This field is a place holder for the ciphertext and related information that forms the encrypted part of a message. The description of the encrypted part of the message follows each appearance of this field.",
      "ja": "エンクパートこのフィールドは、暗号文の場所と、メッセージの暗号化された部分を形成する関連情報の場所です。メッセージの暗号化された部分の説明は、このフィールドの各外観に従います。"
    },
    {
      "indent": 6,
      "text": "The key usage value for encrypting this field is 3 in an AS-REP message, using the client's long-term key or another key selected via pre-authentication mechanisms. In a TGS-REP message, the key usage value is 8 if the TGS session key is used, or 9 if a TGS authenticator subkey is used.",
      "ja": "このフィールドを暗号化するためのキーの使用値は、クライアントの長期キーまたは事前認証メカニズムによって選択された別のキーを使用して、AS-REPメッセージで3です。TGS-REPメッセージでは、TGSセッションキーが使用される場合、キー使用値は8、またはTGS認証装置のサブキーを使用する場合は9です。"
    },
    {
      "indent": 6,
      "text": "Compatibility note: Some implementations unconditionally send an encrypted EncTGSRepPart (application tag number 26) in this field regardless of whether the reply is a AS-REP or a TGS-REP. In the interest of compatibility, implementors MAY relax the check on the tag number of the decrypted ENC-PART.",
      "ja": "互換性メモ：一部の実装では、返信がAS-REPまたはTGS-REPであるかどうかに関係なく、このフィールドに暗号化されたenctgSreppart（アプリケーションタグ番号26）を無条件に送信します。互換性のために、実装者は、復号化されたエンクパートのタグ番号のチェックを緩和することができます。"
    },
    {
      "indent": 3,
      "text": "key This field is the same as described for the ticket in Section 5.3.",
      "ja": "キーこのフィールドは、セクション5.3のチケットの説明と同じです。"
    },
    {
      "indent": 3,
      "text": "last-req This field is returned by the KDC and specifies the time(s) of the last request by a principal. Depending on what information is available, this might be the last time that a request for a TGT was made, or the last time that a request based on a TGT was successful. It also might cover all servers for a realm, or just the particular server. Some implementations MAY display this information to the user to aid in discovering unauthorized use of one's identity. It is similar in spirit to the last login time displayed when logging in to timesharing systems.",
      "ja": "Last-reqこのフィールドはKDCによって返され、プリンシパルによる最後の要求の時間を指定します。利用可能な情報に応じて、TGTのリクエストが行われたのはこれが最後であるか、TGTに基づいたリクエストが成功した最後の時間かもしれません。また、すべてのサーバーを領域または特定のサーバーのみをカバーする場合があります。一部の実装では、この情報をユーザーに表示して、自分のアイデンティティの不正使用の発見を支援する場合があります。精神的には、タイムシェアリングシステムにログインするときに表示される最後のログイン時間と似ています。"
    },
    {
      "indent": 3,
      "text": "lr-type This field indicates how the following lr-value field is to be interpreted. Negative values indicate that the information pertains only to the responding server. Non-negative values pertain to all servers for the realm.",
      "ja": "LRタイプこのフィールドは、次のLR値フィールドをどのように解釈するかを示します。負の値は、情報が応答サーバーのみに関係していることを示しています。非陰性値は、領域のすべてのサーバーに関係します。"
    },
    {
      "indent": 6,
      "text": "If the lr-type field is zero (0), then no information is conveyed by the lr-value subfield. If the absolute value of the lr-type field is one (1), then the lr-value subfield is the time of last initial request for a TGT. If it is two (2), then the lr-value subfield is the time of last initial request. If it is three (3), then the lr-value subfield is the time of issue for the newest TGT used. If it is four (4), then the lr-value subfield is the time of the last renewal. If it is five (5), then the lr-value subfield is the time of last request (of any type). If it is (6), then the lr-value subfield is the time when the password will expire. If it is (7), then the lr-value subfield is the time when the account will expire.",
      "ja": "LRタイプのフィールドがゼロ（0）の場合、LR値サブフィールドによって情報は伝えられません。LRタイプフィールドの絶対値が1つ（1）の場合、LR値サブフィールドはTGTの最後の初期リクエストの時間です。2つの場合、LR値サブフィールドは最後の初期リクエストの時間です。3つの場合、LR値サブフィールドは、使用される最新のTGTの問題の時間です。4つの場合、LR値サブフィールドは最後の更新の時間です。5（5）の場合、LR値サブフィールドは（任意のタイプの）最後の要求の時間です。（6）の場合、LR値サブフィールドは、パスワードが期限切れになる時間です。（7）の場合、LR値サブフィールドは、アカウントが期限切れになる時間です。"
    },
    {
      "indent": 3,
      "text": "lr-value This field contains the time of the last request. The time MUST be interpreted according to the contents of the accompanying lr-type subfield.",
      "ja": "LR値このフィールドには、最後のリクエストの時間が含まれています。時間は、付随するLRタイプのサブフィールドの内容に従って解釈する必要があります。"
    },
    {
      "indent": 3,
      "text": "nonce This field is described above in Section 5.4.1.",
      "ja": "Nonceこのフィールドは、上記のセクション5.4.1で説明しています。"
    },
    {
      "indent": 3,
      "text": "key-expiration The key-expiration field is part of the response from the KDC and specifies the time that the client's secret key is due to expire. The expiration might be the result of password aging or an account expiration. If present, it SHOULD be set to the earlier of the user's key expiration and account expiration. The use of this field is deprecated, and the last-req field SHOULD be used to convey this information instead. This field will usually be left out of the TGS reply since the response to the TGS request is encrypted in a session key and no client information has to be retrieved from the KDC database. It is up to the application client (usually the login program) to take appropriate action (such as notifying the user) if the expiration time is imminent.",
      "ja": "キーエクスペニレーションキーエクサイアルフィールドは、KDCからの応答の一部であり、クライアントの秘密鍵が期限切れになる時間を指定します。有効期限は、パスワードの老化またはアカウントの有効期限の結果である可能性があります。存在する場合は、ユーザーの主要な有効期限とアカウントの有効期限の早い段階に設定する必要があります。このフィールドの使用は非推奨であり、最後のREQフィールドを使用して、代わりにこの情報を伝える必要があります。TGSリクエストへの応答がセッションキーで暗号化され、KDCデータベースからクライアント情報を取得する必要がないため、このフィールドは通常、TGSの返信から除外されます。有効期限が差し迫っている場合、適切なアクション（ユーザーへの通知など）を実行するのは、アプリケーションクライアント（通常はログインプログラム）次第です。"
    },
    {
      "indent": 3,
      "text": "flags, authtime, starttime, endtime, renew-till and caddr These fields are duplicates of those found in the encrypted portion of the attached ticket (see Section 5.3), provided so the client MAY verify that they match the intended request and in order to assist in proper ticket caching. If the message is of type KRB_TGS_REP, the caddr field will only be filled in if the request was for a proxy or forwarded ticket, or if the user is substituting a subset of the addresses from the TGT. If the client-requested addresses are not present or not used, then the addresses contained in the ticket will be the same as those included in the TGT.",
      "ja": "フラグ、auth-time、starttime、endtime、renew-till and caddrこれらのフィールドは、添付チケットの暗号化された部分に見られるものの複製です（セクション5.3を参照）。適切なチケットキャッシュを支援します。メッセージがkrb_tgs_repのタイプの場合、CADDRフィールドは、リクエストがプロキシまたは転送チケットの場合、またはユーザーがTGTのアドレスのサブセットを置き換えている場合にのみ入力されます。クライアントが要求していないアドレスが存在しないか、使用されていない場合、チケットに含まれるアドレスはTGTに含まれるアドレスと同じです。"
    },
    {
      "indent": 0,
      "text": "5.5. Client/Server (CS) Message Specifications",
      "section_title": true,
      "ja": "5.5. クライアント/サーバー（CS）メッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of the messages used for the authentication of the client to the application server.",
      "ja": "このセクションでは、クライアントのアプリケーションサーバーへの認証に使用されるメッセージの形式を指定します。"
    },
    {
      "indent": 0,
      "text": "5.5.1. KRB_AP_REQ Definition",
      "section_title": true,
      "ja": "5.5.1. KRB_AP_REQ定義"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REQ message contains the Kerberos protocol version number, the message type KRB_AP_REQ, an options field to indicate any options in use, and the ticket and authenticator themselves. The KRB_AP_REQ message is often referred to as the \"authentication header\".",
      "ja": "KRB_AP_REQメッセージには、Kerberosプロトコルバージョン番号、メッセージタイプkrb_ap_req、使用中のオプションを示すオプションフィールド、チケットと認証者自身が含まれています。KRB_AP_REQメッセージは、多くの場合、「認証ヘッダー」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (14),\n        ap-options      [2] APOptions,\n        ticket          [3] Ticket,\n        authenticator   [4] EncryptedData -- Authenticator\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "APOptions       ::= KerberosFlags\n        -- reserved(0),\n        -- use-session-key(1),\n        -- mutual-required(2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_AP_REQ.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。msg-typeはkrb_ap_reqです。"
    },
    {
      "indent": 3,
      "text": "ap-options This field appears in the application request (KRB_AP_REQ) and affects the way the request is processed. It is a bit-field, where the selected options are indicated by the bit being set (1), and the unselected options and reserved fields by being reset (0). The encoding of the bits is specified in Section 5.2. The meanings of the options are as follows:",
      "ja": "APオプションこのフィールドは、アプリケーションリクエスト（krb_ap_req）に表示され、リクエストの処理方法に影響します。選択されたオプションは、ビットが設定されている（1）、およびリセットされることで選択されていないオプションと予約フィールド（0）によって示されるビットフィールドです。ビットのエンコードは、セクション5.2で指定されています。オプションの意味は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Bit(s) Name Description",
      "ja": "ビット名の説明"
    },
    {
      "indent": 3,
      "text": "0 reserved Reserved for future expansion of this field.",
      "ja": "0このフィールドの将来の拡張のために予約されています。"
    },
    {
      "indent": 3,
      "text": "1 use-session-key The USE-SESSION-KEY option indicates that the ticket the client is presenting to a server is encrypted in the session key from the server's TGT. When this option is not specified, the ticket is encrypted in the server's secret key.",
      "ja": "1 use-session-key Use-session-Keyオプションは、クライアントがサーバーに提示しているチケットがサーバーのTGTのセッションキーで暗号化されていることを示します。このオプションが指定されていない場合、チケットはサーバーのシークレットキーで暗号化されます。"
    },
    {
      "indent": 3,
      "text": "2 mutual-required The MUTUAL-REQUIRED option tells the server that the client requires mutual authentication, and that it must respond with a KRB_AP_REP message.",
      "ja": "2相互に必要な相互に必要なオプションは、クライアントが相互認証を必要とし、krb_ap_repメッセージで応答する必要があることをサーバーに伝えます。"
    },
    {
      "indent": 3,
      "text": "3-31 reserved Reserved for future use.",
      "ja": "3-31将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "ticket This field is a ticket authenticating the client to the server.",
      "ja": "チケットこのフィールドは、クライアントをサーバーに認証するチケットです。"
    },
    {
      "indent": 3,
      "text": "authenticator This contains the encrypted authenticator, which includes the client's choice of a subkey.",
      "ja": "Authenticatorこれには、暗号化されたAuthenticatorが含まれています。これには、クライアントのサブキーの選択が含まれます。"
    },
    {
      "indent": 3,
      "text": "The encrypted authenticator is included in the AP-REQ; it certifies to a server that the sender has recent knowledge of the encryption key in the accompanying ticket, to help the server detect replays. It also assists in the selection of a \"true session key\" to use with the particular session. The DER encoding of the following is encrypted in the ticket's session key, with a key usage value of 11 in normal application exchanges, or 7 when used as the PA-TGS-REQ PA-DATA field of a TGS-REQ exchange (see Section 5.4.1):",
      "ja": "暗号化された認証器はAP-Reqに含まれています。サーバーは、サーバーがリプレイを検出するのを支援するために、添付チケットの暗号化キーに関する最近の知識を持っていることをサーバーに証明します。また、特定のセッションで使用する「真のセッションキー」の選択を支援します。以下のDERエンコードは、チケットのセッションキーで暗号化され、通常のアプリケーション交換ではキー使用値が11、またはTGS-REQ ExchangeのPA-TGS-REQ PA-DATAフィールドとして使用された場合（セクションを参照してください。5.4.1）："
    },
    {
      "indent": 3,
      "text": "-- Unencrypted authenticator\nAuthenticator   ::= [APPLICATION 2] SEQUENCE  {\n        authenticator-vno       [0] INTEGER (5),\n        crealm                  [1] Realm,\n        cname                   [2] PrincipalName,\n        cksum                   [3] Checksum OPTIONAL,\n        cusec                   [4] Microseconds,\n        ctime                   [5] KerberosTime,\n        subkey                  [6] EncryptionKey OPTIONAL,\n        seq-number              [7] UInt32 OPTIONAL,\n        authorization-data      [8] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "authenticator-vno This field specifies the version number for the format of the authenticator. This document specifies version 5.",
      "ja": "Authenticator-VNOこのフィールドは、Authenticatorの形式のバージョン番号を指定します。このドキュメントは、バージョン5を指定します。"
    },
    {
      "indent": 3,
      "text": "crealm and cname These fields are the same as those described for the ticket in section 5.3.",
      "ja": "CREALMとCNAMEこれらのフィールドは、セクション5.3のチケットについて説明したフィールドと同じです。"
    },
    {
      "indent": 3,
      "text": "cksum This field contains a checksum of the application data that accompanies the KRB_AP_REQ, computed using a key usage value of 10 in normal application exchanges, or 6 when used in the TGS-REQ PA-TGS-REQ AP-DATA field.",
      "ja": "CKSUMこのフィールドには、KRB_AP_REQに付随するアプリケーションデータのチェックサムが含まれています。通常のアプリケーション交換で10の主要な使用値を使用して計算され、TGS-REQ PA-TGS-REQ AP-Dataフィールドで使用する場合は6が含まれています。"
    },
    {
      "indent": 3,
      "text": "cusec This field contains the microsecond part of the client's timestamp. Its value (before encryption) ranges from 0 to 999999. It often appears along with ctime. The two fields are used together to specify a reasonably accurate timestamp.",
      "ja": "CUSECこのフィールドには、クライアントのタイムスタンプのマイクロ秒部分が含まれています。その値（暗号化前）は0から999999の範囲です。これは、しばしばCtimeとともに表示されます。2つのフィールドは、合理的に正確なタイムスタンプを指定するために一緒に使用されます。"
    },
    {
      "indent": 3,
      "text": "ctime This field contains the current time on the client's host.",
      "ja": "CTIMEこのフィールドには、クライアントのホストに現在の時間が含まれています。"
    },
    {
      "indent": 3,
      "text": "subkey This field contains the client's choice for an encryption key to be used to protect this specific application session. Unless an application specifies otherwise, if this field is left out, the session key from the ticket will be used.",
      "ja": "Subkeyこのフィールドには、この特定のアプリケーションセッションを保護するために使用される暗号化キーのクライアントの選択が含まれています。アプリケーションが特に指定されていない限り、このフィールドが除外されている場合、チケットのセッションキーが使用されます。"
    },
    {
      "indent": 3,
      "text": "seq-number This optional field includes the initial sequence number to be used by the KRB_PRIV or KRB_SAFE messages when sequence numbers are used to detect replays. (It may also be used by application specific messages.) When included in the authenticator, this field specifies the initial sequence number for messages from the client to the server. When included in the AP-REP message, the initial sequence number is that for messages from the server to the client. When used in KRB_PRIV or KRB_SAFE messages, it is incremented by one after each message is sent. Sequence numbers fall in the range 0 through 2^32 - 1 and wrap to zero following the value 2^32 - 1.",
      "ja": "seq-numberこのオプションフィールドには、リプレイを検出するためにシーケンス番号を使用した場合、krb_privまたはkrb_safeメッセージが使用する初期シーケンス番号が含まれています。（アプリケーション固有のメッセージでも使用できます。）Authenticatorに含まれる場合、このフィールドは、クライアントからサーバーへのメッセージの初期シーケンス番号を指定します。AP-REPメッセージに含まれる場合、最初のシーケンス番号は、サーバーからクライアントへのメッセージの場合です。krb_privまたはkrb_safeメッセージで使用すると、各メッセージが送信された後に1つずつ増加します。シーケンス番号は0から2^32-1の範囲に低下し、値2^32-1に続いてゼロにラップします。"
    },
    {
      "indent": 6,
      "text": "For sequence numbers to support the detection of replays adequately, they SHOULD be non-repeating, even across connection boundaries. The initial sequence number SHOULD be random and uniformly distributed across the full space of possible sequence numbers, so that it cannot be guessed by an attacker and so that it and the successive sequence numbers do not repeat other sequences. In the event that more than 2^32 messages are to be generated in a series of KRB_PRIV or KRB_SAFE messages, rekeying SHOULD be performed before sequence numbers are reused with the same encryption key.",
      "ja": "リプレイの検出を適切にサポートするためのシーケンス番号の場合、接続境界を越えて、繰り返し、非回復である必要があります。初期シーケンス番号はランダムであり、可能なシーケンス番号の完全な空間全体に均一に分布する必要があります。そうすることで、攻撃者が推測できないようにし、それと連続したシーケンス番号が他のシーケンスを繰り返さないようにします。一連のkrb_privまたはkrb_safeメッセージで2^32以上のメッセージを生成する場合、シーケンス番号が同じ暗号化キーで再利用される前に、再キーイングを実行する必要があります。"
    },
    {
      "indent": 6,
      "text": "Implmentation note: Historically, some implementations transmit signed twos-complement numbers for sequence numbers. In the interests of compatibility, implementations MAY accept the equivalent negative number where a positive number greater than 2^31 - 1 is expected.",
      "ja": "実装注：歴史的に、いくつかの実装は、シーケンス番号の署名された2つの補完番号を送信します。互換性の利益のために、実装は、2^31-1を超える正の数が予想される同等の負の数を受け入れる場合があります。"
    },
    {
      "indent": 6,
      "text": "Implementation note: As noted before, some implementations omit the optional sequence number when its value would be zero. Implementations MAY accept an omitted sequence number when expecting a value of zero, and SHOULD NOT transmit an Authenticator with a initial sequence number of zero.",
      "ja": "実装注：以前に記載されているように、一部の実装は、その値がゼロになる場合にオプションのシーケンス番号を省略します。実装は、ゼロの値を期待する場合に省略されたシーケンス番号を受け入れる場合があり、初期シーケンス数のゼロで認証器を送信しないでください。"
    },
    {
      "indent": 3,
      "text": "authorization-data This field is the same as described for the ticket in Section 5.3. It is optional and will only appear when additional restrictions are to be placed on the use of a ticket, beyond those carried in the ticket itself.",
      "ja": "Authorization-Dataこのフィールドは、セクション5.3のチケットの説明と同じです。これはオプションであり、チケット自体で運ばれたものを超えて、チケットの使用に追加の制限が配置される場合にのみ表示されます。"
    },
    {
      "indent": 0,
      "text": "5.5.2. KRB_AP_REP Definition",
      "section_title": true,
      "ja": "5.5.2. KRB_AP_REP定義"
    },
    {
      "indent": 3,
      "text": "The KRB_AP_REP message contains the Kerberos protocol version number, the message type, and an encrypted time-stamp. The message is sent in response to an application request (KRB_AP_REQ) for which the mutual authentication option has been selected in the ap-options field.",
      "ja": "KRB_AP_REPメッセージには、Kerberosプロトコルバージョン番号、メッセージタイプ、暗号化されたタイムスタンプが含まれています。メッセージは、APオプションフィールドで相互認証オプションが選択されているアプリケーションリクエスト（krb_ap_req）に応じて送信されます。"
    },
    {
      "indent": 3,
      "text": "AP-REP          ::= [APPLICATION 15] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (15),\n        enc-part        [2] EncryptedData -- EncAPRepPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {\n        ctime           [0] KerberosTime,\n        cusec           [1] Microseconds,\n        subkey          [2] EncryptionKey OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The encoded EncAPRepPart is encrypted in the shared session key of the ticket. The optional subkey field can be used in an application-arranged negotiation to choose a per association session key.",
      "ja": "エンコードされたEncapReppartは、チケットの共有セッションキーに暗号化されています。オプションのサブキーフィールドは、アプリケーションアレンジの交渉で使用して、Associationセッションキーごとに選択できます。"
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_AP_REP.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。msg-typeはkrb_ap_repです。"
    },
    {
      "indent": 3,
      "text": "enc-part This field is described above in Section 5.4.2. It is computed with a key usage value of 12.",
      "ja": "このフィールドは、上記のセクション5.4.2で説明します。12の主要な使用値で計算されます。"
    },
    {
      "indent": 3,
      "text": "ctime This field contains the current time on the client's host.",
      "ja": "CTIMEこのフィールドには、クライアントのホストに現在の時間が含まれています。"
    },
    {
      "indent": 3,
      "text": "cusec This field contains the microsecond part of the client's timestamp.",
      "ja": "CUSECこのフィールドには、クライアントのタイムスタンプのマイクロ秒部分が含まれています。"
    },
    {
      "indent": 3,
      "text": "subkey This field contains an encryption key that is to be used to protect this specific application session. See Section 3.2.6 for specifics on how this field is used to negotiate a key. Unless an application specifies otherwise, if this field is left out, the sub-session key from the authenticator or if the latter is also left out, the session key from the ticket will be used.",
      "ja": "Subkeyこのフィールドには、この特定のアプリケーションセッションを保護するために使用される暗号化キーが含まれています。このフィールドがキーをネゴシエートするためにどのように使用されるかについての詳細については、セクション3.2.6を参照してください。アプリケーションが特に指定されていない限り、このフィールドが除外されている場合、認証機のサブセッションキー、または後者も除外されている場合、チケットのセッションキーが使用されます。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "seq-numberこのフィールドは、上記のセクション5.3.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "5.5.3. Error Message Reply",
      "section_title": true,
      "ja": "5.5.3. エラーメッセージ返信"
    },
    {
      "indent": 3,
      "text": "If an error occurs while processing the application request, the KRB_ERROR message will be sent in response. See Section 5.9.1 for the format of the error message. The cname and crealm fields MAY be left out if the server cannot determine their appropriate values from the corresponding KRB_AP_REQ message. If the authenticator was decipherable, the ctime and cusec fields will contain the values from it.",
      "ja": "アプリケーションリクエストの処理中にエラーが発生した場合、KRB_ERRORメッセージはそれに応じて送信されます。エラーメッセージの形式については、セクション5.9.1を参照してください。サーバーが対応するKRB_AP_REQメッセージから適切な値を決定できない場合、CNAMEおよびCREALMフィールドが除外される場合があります。認証器が解読可能な場合、CtimeとCUSECフィールドにはそれから値が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.6. KRB_SAFE Message Specification",
      "section_title": true,
      "ja": "5.6. krb_safeメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used by either side (client or server) of an application to send a tamper-proof message to its peer. It presumes that a session key has previously been exchanged (for example, by using the KRB_AP_REQ/KRB_AP_REP messages).",
      "ja": "このセクションでは、アプリケーションのいずれかの側（クライアントまたはサーバー）で使用できるメッセージの形式を指定して、改ざん防止メッセージをピアに送信します。これは、セッションキーが以前に交換されたと推定しています（たとえば、krb_ap_req/krb_ap_repメッセージを使用して）。"
    },
    {
      "indent": 0,
      "text": "5.6.1. KRB_SAFE definition",
      "section_title": true,
      "ja": "5.6.1. KRB_SAFE定義"
    },
    {
      "indent": 3,
      "text": "The KRB_SAFE message contains user data along with a collision-proof checksum keyed with the last encryption key negotiated via subkeys, or with the session key if no negotiation has occurred. The message fields are as follows:",
      "ja": "KRB_SAFEメッセージには、サブキーを介してネゴシエートされた最後の暗号化キー、または交渉が発生していない場合はセッションキーでキーがキー付き衝突防止チェックサムとともにユーザーデータが含まれています。メッセージフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (20),\n        safe-body       [2] KRB-SAFE-BODY,\n        cksum           [3] Checksum\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KRB-SAFE-BODY   ::= SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_SAFE.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。msg-typeはkrb_safeです。"
    },
    {
      "indent": 3,
      "text": "safe-body This field is a placeholder for the body of the KRB-SAFE message.",
      "ja": "SAFE-BODYこのフィールドは、KRBセーフメッセージの本文のプレースホルダーです。"
    },
    {
      "indent": 3,
      "text": "cksum This field contains the checksum of the application data, computed with a key usage value of 15.",
      "ja": "CKSUMこのフィールドには、15の主要な使用値で計算されたアプリケーションデータのチェックサムが含まれています。"
    },
    {
      "indent": 6,
      "text": "The checksum is computed over the encoding of the KRB-SAFE sequence. First, the cksum is set to a type zero, zero-length value, and the checksum is computed over the encoding of the KRB-SAFE sequence. Then the checksum is set to the result of that computation. Finally, the KRB-SAFE sequence is encoded again. This method, although different than the one specified in RFC 1510, corresponds to existing practice.",
      "ja": "チェックサムは、KRBセーフシーケンスのエンコードで計算されます。まず、CKSUMはタイプゼロ、ゼロ長値に設定され、チェックサムはKRBセーフシーケンスのエンコードで計算されます。その後、チェックサムはその計算の結果に設定されます。最後に、KRBセーフシーケンスが再びエンコードされます。この方法は、RFC 1510で指定された方法とは異なりますが、既存の実践に対応しています。"
    },
    {
      "indent": 3,
      "text": "user-data This field is part of the KRB_SAFE and KRB_PRIV messages, and contains the application-specific data that is being passed from the sender to the recipient.",
      "ja": "user-dataこのフィールドは、krb_safeおよびkrb_privメッセージの一部であり、送信者から受信者に渡されているアプリケーション固有のデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "timestamp This field is part of the KRB_SAFE and KRB_PRIV messages. Its contents are the current time as known by the sender of the message. By checking the timestamp, the recipient of the message is able to make sure that it was recently generated, and is not a replay.",
      "ja": "タイムスタンプこのフィールドは、krb_safeおよびkrb_privメッセージの一部です。その内容は、メッセージの送信者によって知られている現在の時刻です。タイムスタンプをチェックすることにより、メッセージの受信者は最近生成されたことを確認することができ、リプレイではありません。"
    },
    {
      "indent": 3,
      "text": "usec This field is part of the KRB_SAFE and KRB_PRIV headers. It contains the microsecond part of the timestamp.",
      "ja": "USECこのフィールドは、KRB_SAFEおよびKRB_PRIVヘッダーの一部です。タイムスタンプのマイクロ秒部分が含まれています。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "seq-numberこのフィールドは、上記のセクション5.3.2で説明しています。"
    },
    {
      "indent": 3,
      "text": "s-address Sender's address.",
      "ja": "S-Address Senderのアドレス。"
    },
    {
      "indent": 6,
      "text": "This field specifies the address in use by the sender of the message.",
      "ja": "このフィールドは、メッセージの送信者が使用しているアドレスを指定します。"
    },
    {
      "indent": 3,
      "text": "r-address This field specifies the address in use by the recipient of the message. It MAY be omitted for some uses (such as broadcast protocols), but the recipient MAY arbitrarily reject such messages. This field, along with s-address, can be used to help detect messages that have been incorrectly or maliciously delivered to the wrong recipient.",
      "ja": "r-Addressこのフィールドは、メッセージの受信者が使用しているアドレスを指定します。一部の用途（ブロードキャストプロトコルなど）では省略される場合がありますが、受信者はそのようなメッセージを任意に拒否する場合があります。このフィールドは、S-Addressとともに、間違った受信者に誤ってまたは悪意を持って配信されたメッセージを検出するのに役立つために使用できます。"
    },
    {
      "indent": 0,
      "text": "5.7. KRB_PRIV Message Specification",
      "section_title": true,
      "ja": "5.7. krb_privメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used by either side (client or server) of an application to send a message to its peer securely and privately. It presumes that a session key has previously been exchanged (for example, by using the KRB_AP_REQ/KRB_AP_REP messages).",
      "ja": "このセクションでは、アプリケーションのいずれかの側（クライアントまたはサーバー）で使用できるメッセージの形式を指定して、ピアに安全かつ個人的にメッセージを送信します。これは、セッションキーが以前に交換されたと推定しています（たとえば、krb_ap_req/krb_ap_repメッセージを使用して）。"
    },
    {
      "indent": 0,
      "text": "5.7.1. KRB_PRIV Definition",
      "section_title": true,
      "ja": "5.7.1. KRB_PRIV定義"
    },
    {
      "indent": 3,
      "text": "The KRB_PRIV message contains user data encrypted in the Session Key. The message fields are as follows:",
      "ja": "KRB_PRIVメッセージには、セッションキーで暗号化されたユーザーデータが含まれています。メッセージフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (21),\n                        -- NOTE: there is no [2] tag\n        enc-part        [3] EncryptedData -- EncKrbPrivPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress -- sender's addr --,\n        r-address       [5] HostAddress OPTIONAL -- recip's addr\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_PRIV.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。msg-typeはkrb_privです。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds an encoding of the EncKrbPrivPart sequence encrypted under the session key, with a key usage value of 13. This encrypted encoding is used for the enc-part field of the KRB-PRIV message.",
      "ja": "このフィールドは、セッションキーの下で暗号化されたEnckrbprivpartシーケンスのエンコードを保持し、キー使用値は13です。"
    },
    {
      "indent": 3,
      "text": "user-data, timestamp, usec, s-address, and r-address These fields are described above in Section 5.6.1.",
      "ja": "ユーザーデータ、タイムスタンプ、USEC、S-アドレス、およびRアドレスこれらのフィールドは、上記のセクション5.6.1で説明しています。"
    },
    {
      "indent": 3,
      "text": "seq-number This field is described above in Section 5.3.2.",
      "ja": "seq-numberこのフィールドは、上記のセクション5.3.2で説明しています。"
    },
    {
      "indent": 0,
      "text": "5.8. KRB_CRED Message Specification",
      "section_title": true,
      "ja": "5.8. KRB_CREDメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format of a message that can be used to send Kerberos credentials from one principal to another. It is presented here to encourage a common mechanism to be used by applications when forwarding tickets or providing proxies to subordinate servers. It presumes that a session key has already been exchanged, perhaps by using the KRB_AP_REQ/KRB_AP_REP messages.",
      "ja": "このセクションでは、Kerberosの資格情報をあるプリンシパルから別のものに送信するために使用できるメッセージの形式を指定します。ここでは、チケットを転送したり、下位サーバーにプロキシを提供する際に、アプリケーションで使用される共通のメカニズムを奨励するために提示されています。おそらくKRB_AP_REQ/KRB_AP_REPメッセージを使用して、セッションキーがすでに交換されていると推定します。"
    },
    {
      "indent": 0,
      "text": "5.8.1. KRB_CRED Definition",
      "section_title": true,
      "ja": "5.8.1. KRB_CRED定義"
    },
    {
      "indent": 3,
      "text": "The KRB_CRED message contains a sequence of tickets to be sent and information needed to use the tickets, including the session key from each. The information needed to use the tickets is encrypted under an encryption key previously exchanged or transferred alongside the KRB_CRED message. The message fields are as follows:",
      "ja": "KRB_CREDメッセージには、送信するチケットのシーケンスと、それぞれのセッションキーを含むチケットを使用するために必要な情報が含まれています。チケットを使用するために必要な情報は、以前に交換または転送された暗号化キーの下で暗号化されています。メッセージフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "KRB-CRED        ::= [APPLICATION 22] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (22),\n        tickets         [2] SEQUENCE OF Ticket,\n        enc-part        [3] EncryptedData -- EncKrbCredPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {\n        ticket-info     [0] SEQUENCE OF KrbCredInfo,\n        nonce           [1] UInt32 OPTIONAL,\n        timestamp       [2] KerberosTime OPTIONAL,\n        usec            [3] Microseconds OPTIONAL,\n        s-address       [4] HostAddress OPTIONAL,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KrbCredInfo     ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        prealm          [1] Realm OPTIONAL,\n        pname           [2] PrincipalName OPTIONAL,\n        flags           [3] TicketFlags OPTIONAL,\n        authtime        [4] KerberosTime OPTIONAL,\n        starttime       [5] KerberosTime OPTIONAL,\n        endtime         [6] KerberosTime OPTIONAL,\n        renew-till      [7] KerberosTime OPTIONAL,\n        srealm          [8] Realm OPTIONAL,\n        sname           [9] PrincipalName OPTIONAL,\n        caddr           [10] HostAddresses OPTIONAL\n}\n   pvno and msg-type\n   These fields are described above in Section 5.4.1.  msg-type is\n   KRB_CRED.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "tickets These are the tickets obtained from the KDC specifically for use by the intended recipient. Successive tickets are paired with the corresponding KrbCredInfo sequence from the enc-part of the KRB-CRED message.",
      "ja": "チケットこれらは、意図した受信者が使用するために特別にKDCから入手したチケットです。連続したチケットは、KRB-CREDメッセージのエンクパートから対応するKRBCREDINFOシーケンスとペアになっています。"
    },
    {
      "indent": 3,
      "text": "enc-part This field holds an encoding of the EncKrbCredPart sequence encrypted under the session key shared by the sender and the intended recipient, with a key usage value of 14. This encrypted encoding is used for the enc-part field of the KRB-CRED message.",
      "ja": "EncPartこのフィールドは、送信者と意図した受信者が共有するセッションキーの下で暗号化されたEnckrbcredPartシーケンスのエンコードを保持します。キー使用値は14です。メッセージ。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Implementations of certain applications, most notably certain implementations of the Kerberos GSS-API mechanism, do not separately encrypt the contents of the EncKrbCredPart of the KRB-CRED message when sending it. In the case of those GSS-API mechanisms, this is not a security vulnerability, as the entire KRB-CRED message is itself embedded in an encrypted message.",
      "ja": "実装注：特定のアプリケーションの実装、特にKerberos GSS-APIメカニズムの特定の実装は、送信時にKRBがクレジットしたメッセージのEnckRBCrededPartのコンテンツを個別に暗号化しないでください。これらのGSS-APIメカニズムの場合、これはセキュリティの脆弱性ではありません。これは、KRBがクレジットしたメッセージ全体が暗号化されたメッセージに埋め込まれているためです。"
    },
    {
      "indent": 3,
      "text": "nonce If practical, an application MAY require the inclusion of a nonce generated by the recipient of the message. If the same value is included as the nonce in the message, it provides evidence that the message is fresh and has not been replayed by an attacker. A nonce MUST NEVER be reused.",
      "ja": "NonCEの場合、アプリケーションでは、メッセージの受信者によって生成された非CEを含める必要があります。メッセージのNONCEと同じ値が含まれている場合、メッセージが新鮮で、攻撃者によって再生されていないという証拠が提供されます。ノンセは決して再利用してはなりません。"
    },
    {
      "indent": 3,
      "text": "timestamp and usec These fields specify the time that the KRB-CRED message was generated. The time is used to provide assurance that the message is fresh.",
      "ja": "TimestampとUSECこれらのフィールドは、KRBがクレジットしたメッセージが生成された時間を指定します。この時間は、メッセージが新鮮であるという保証を提供するために使用されます。"
    },
    {
      "indent": 3,
      "text": "s-address and r-address These fields are described above in Section 5.6.1. They are used optionally to provide additional assurance of the integrity of the KRB-CRED message.",
      "ja": "S-AddressおよびR-Addressこれらのフィールドは、上記のセクション5.6.1で説明しています。それらは、KRBがクレジットしたメッセージの完全性を追加の保証を提供するためにオプションで使用されます。"
    },
    {
      "indent": 3,
      "text": "key This field exists in the corresponding ticket passed by the KRB-CRED message and is used to pass the session key from the sender to the intended recipient. The field's encoding is described in Section 5.2.9.",
      "ja": "キーこのフィールドは、KRBがクレジットしたメッセージで渡される対応するチケットに存在し、セッションキーを送信者から意図した受信者に渡すために使用されます。フィールドのエンコードについては、セクション5.2.9で説明しています。"
    },
    {
      "indent": 3,
      "text": "The following fields are optional. If present, they can be associated with the credentials in the remote ticket file. If left out, then it is assumed that the recipient of the credentials already knows their values.",
      "ja": "次のフィールドはオプションです。存在する場合、それらはリモートチケットファイルの資格情報に関連付けられます。除外された場合、資格情報の受信者はすでに価値を知っていると想定されています。"
    },
    {
      "indent": 3,
      "text": "prealm and pname The name and realm of the delegated principal identity.",
      "ja": "委任された主要なアイデンティティの名前と領域をPREALMとPNAME。"
    },
    {
      "indent": 3,
      "text": "flags, authtime, starttime, endtime, renew-till, srealm, sname, and caddr These fields contain the values of the corresponding fields from the ticket found in the ticket field. Descriptions of the fields are identical to the descriptions in the KDC-REP message.",
      "ja": "フラグ、authtime、starttime、endtime、inled till、srealm、sname、and caddrこれらのフィールドには、チケットフィールドにあるチケットから対応するフィールドの値が含まれています。フィールドの説明は、KDC-REPメッセージの説明と同じです。"
    },
    {
      "indent": 0,
      "text": "5.9. Error Message Specification",
      "section_title": true,
      "ja": "5.9. エラーメッセージ仕様"
    },
    {
      "indent": 3,
      "text": "This section specifies the format for the KRB_ERROR message. The fields included in the message are intended to return as much information as possible about an error. It is not expected that all the information required by the fields will be available for all types of errors. If the appropriate information is not available when the message is composed, the corresponding field will be left out of the message.",
      "ja": "このセクションは、krb_errorメッセージの形式を指定します。メッセージに含まれるフィールドは、エラーについてできるだけ多くの情報を返すことを目的としています。フィールドに必要なすべての情報が、あらゆる種類のエラーに利用可能になることは予想されません。メッセージが作成されたときに適切な情報が利用できない場合、対応するフィールドはメッセージから除外されます。"
    },
    {
      "indent": 3,
      "text": "Note that because the KRB_ERROR message is not integrity protected, it is quite possible for an intruder to synthesize or modify it. In particular, this means that the client SHOULD NOT use any fields in this message for security-critical purposes, such as setting a system clock or generating a fresh authenticator. The message can be useful, however, for advising a user on the reason for some failure.",
      "ja": "KRB_ERRORメッセージは整合性保護されていないため、侵入者がそれを合成または変更することは非常に可能であることに注意してください。特に、これは、システムクロックの設定や新鮮な認証器の生成など、セキュリティが重要な目的でこのメッセージのフィールドを使用してはならないことを意味します。ただし、このメッセージは、ある程度の失敗の理由についてユーザーに助言するために役立ちます。"
    },
    {
      "indent": 0,
      "text": "5.9.1. KRB_ERROR Definition",
      "section_title": true,
      "ja": "5.9.1. KRB_ERROR定義"
    },
    {
      "indent": 3,
      "text": "The KRB_ERROR message consists of the following fields:",
      "ja": "KRB_ERRORメッセージは、次のフィールドで構成されています。"
    },
    {
      "indent": 3,
      "text": "KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (30),\n        ctime           [2] KerberosTime OPTIONAL,\n        cusec           [3] Microseconds OPTIONAL,\n        stime           [4] KerberosTime,\n        susec           [5] Microseconds,\n        error-code      [6] Int32,\n        crealm          [7] Realm OPTIONAL,\n        cname           [8] PrincipalName OPTIONAL,\n        realm           [9] Realm -- service realm --,\n        sname           [10] PrincipalName -- service name --,\n        e-text          [11] KerberosString OPTIONAL,\n           e-data          [12] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pvno and msg-type These fields are described above in Section 5.4.1. msg-type is KRB_ERROR.",
      "ja": "PVNOおよびMSGタイプこれらのフィールドは、上記のセクション5.4.1で説明しています。msg-typeはkrb_errorです。"
    },
    {
      "indent": 3,
      "text": "ctime and cusec These fields are described above in Section 5.5.2. If the values for these fields are known to the entity generating the error (as they would be if the KRB-ERROR is generated in reply to, e.g., a failed authentication service request), they should be populated in the KRB-ERROR. If the values are not available, these fields can be omitted.",
      "ja": "CTIMEとCUSECこれらのフィールドは、上記のセクション5.5.2で説明しています。これらのフィールドの値がエンティティに既知のエラーを生成する場合（たとえば、認証サービスリクエストの失敗に応じてKRB-Errorが生成された場合のように）、KRB-Errorに入力する必要があります。値が利用できない場合、これらのフィールドは省略できます。"
    },
    {
      "indent": 3,
      "text": "stime This field contains the current time on the server. It is of type KerberosTime.",
      "ja": "STIMEこのフィールドには、サーバー上に現在の時間が含まれています。タイプのkerberostimeです。"
    },
    {
      "indent": 3,
      "text": "susec This field contains the microsecond part of the server's timestamp. Its value ranges from 0 to 999999. It appears along with stime. The two fields are used in conjunction to specify a reasonably accurate timestamp.",
      "ja": "SUSECこのフィールドには、サーバーのタイムスタンプのマイクロ秒部分が含まれています。その値は0から999999の範囲です。これは、シュートとともに表示されます。2つのフィールドは、合理的に正確なタイムスタンプを指定するために組み合わせて使用されます。"
    },
    {
      "indent": 3,
      "text": "error-code This field contains the error code returned by Kerberos or the server when a request fails. To interpret the value of this field see the list of error codes in Section 7.5.9. Implementations are encouraged to provide for national language support in the display of error messages.",
      "ja": "エラーコードこのフィールドには、要求が失敗したときにKerberosまたはサーバーによって返されるエラーコードが含まれます。このフィールドの値を解釈するには、セクション7.5.9のエラーコードのリストを参照してください。エラーメッセージの表示で国語サポートを提供することを実装することが推奨されます。"
    },
    {
      "indent": 3,
      "text": "crealm, and cname These fields are described above in Section 5.3. When the entity generating the error knows these values, they should be populated in the KRB-ERROR. If the values are not known, the crealm and cname fields SHOULD be omitted.",
      "ja": "CREALM、およびCNAMEこれらのフィールドは、上記のセクション5.3で説明します。エラーを生成するエンティティがこれらの値を知っている場合、それらはkrb-errorに入力する必要があります。値が不明な場合は、CREALMとCNAMEフィールドを省略する必要があります。"
    },
    {
      "indent": 3,
      "text": "realm and sname These fields are described above in Section 5.3.",
      "ja": "領域とスナームこれらのフィールドは、上記のセクション5.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "e-text This field contains additional text to help explain the error code associated with the failed request (for example, it might include a principal name which was unknown).",
      "ja": "e-textこのフィールドには、リクエストの失敗に関連付けられたエラーコードの説明に役立つ追加のテキストが含まれています（たとえば、不明な主名が含まれる場合があります）。"
    },
    {
      "indent": 3,
      "text": "e-data This field contains additional data about the error for use by the application to help it recover from or handle the error. If the errorcode is KDC_ERR_PREAUTH_REQUIRED, then the e-data field will contain an encoding of a sequence of padata fields, each corresponding to an acceptable pre-authentication method and optionally containing data for the method:",
      "ja": "e-dataこのフィールドには、アプリケーションが使用するためのエラーに関する追加データが含まれており、エラーから回復または処理するのに役立ちます。エラーコードがKDC_ERR_PREAUTH_REQUIREDの場合、E-DATAフィールドには、それぞれが許容可能な事前認証方法に対応し、オプションでメソッドのデータを含めるパダタフィールドのシーケンスのエンコードが含まれます。"
    },
    {
      "indent": 6,
      "text": "METHOD-DATA     ::= SEQUENCE OF PA-DATA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For error codes defined in this document other than KDC_ERR_PREAUTH_REQUIRED, the format and contents of the e-data field are implementation-defined. Similarly, for future error codes, the format and contents of the e-data field are implementation-defined unless specified otherwise. Whether defined by the implementation or in a future document, the e-data field MAY take the form of TYPED-DATA:",
      "ja": "KDC_ERR_PREAUTH_REQUIRED以外のこのドキュメントで定義されているエラーコードの場合、E-DATAフィールドの形式と内容は実装定義です。同様に、将来のエラーコードの場合、E-DATAフィールドの形式と内容は、特に指定されていない限り実装定義が定義されます。実装によって定義されているか、将来のドキュメントで定義されているかにかかわらず、e-DATAフィールドは、型dataの形をとることができます。"
    },
    {
      "indent": 3,
      "text": "TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n        data-type       [0] Int32,\n        data-value      [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.10. Application Tag Numbers",
      "section_title": true,
      "ja": "5.10. アプリケーションタグ番号"
    },
    {
      "indent": 3,
      "text": "The following table lists the application class tag numbers used by various data types defined in this section.",
      "ja": "次の表には、このセクションで定義されているさまざまなデータ型で使用されるアプリケーションクラスのタグ番号を示します。"
    },
    {
      "indent": 3,
      "text": "Tag Number(s) Type Name Comments",
      "ja": "タグ番号タイプ名のコメント"
    },
    {
      "indent": 3,
      "text": "0 unused",
      "ja": "0未使用"
    },
    {
      "indent": 3,
      "text": "1 Ticket PDU",
      "ja": "1チケットPDU"
    },
    {
      "indent": 3,
      "text": "2 Authenticator non-PDU",
      "ja": "2 Authenticator Non-PDU"
    },
    {
      "indent": 3,
      "text": "3 EncTicketPart non-PDU",
      "ja": "3 encticketpart non-pdu"
    },
    {
      "indent": 3,
      "text": "4-9 unused",
      "ja": "4-9未使用"
    },
    {
      "indent": 3,
      "text": "10 AS-REQ PDU",
      "ja": "10 as-req pdu"
    },
    {
      "indent": 3,
      "text": "11 AS-REP PDU",
      "ja": "11 AS-REP PDU"
    },
    {
      "indent": 3,
      "text": "12 TGS-REQ PDU",
      "ja": "12 TGS-REQ PDU"
    },
    {
      "indent": 3,
      "text": "13             TGS-REP        PDU\n   14             AP-REQ         PDU",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "15 AP-REP PDU",
      "ja": "15 AP-REP PDU"
    },
    {
      "indent": 3,
      "text": "16 RESERVED16 TGT-REQ (for user-to-user)",
      "ja": "16 RESERVED16 TGT-REQ（ユーザーツーユーザー用）"
    },
    {
      "indent": 3,
      "text": "17 RESERVED17 TGT-REP (for user-to-user)",
      "ja": "17 RESERVED17 TGT-REP（ユーザーからユーザーへ）"
    },
    {
      "indent": 3,
      "text": "18-19 unused",
      "ja": "18-19未使用"
    },
    {
      "indent": 3,
      "text": "20 KRB-SAFE PDU",
      "ja": "20 KRBセーフPDU"
    },
    {
      "indent": 3,
      "text": "21 KRB-PRIV PDU",
      "ja": "21 KRB-PRIV PDU"
    },
    {
      "indent": 3,
      "text": "22 KRB-CRED PDU",
      "ja": "22 KRB-CRED PDU"
    },
    {
      "indent": 3,
      "text": "23-24 unused",
      "ja": "23-24未使用"
    },
    {
      "indent": 3,
      "text": "25 EncASRepPart non-PDU",
      "ja": "25 ENCASREPPART非PDU"
    },
    {
      "indent": 3,
      "text": "26 EncTGSRepPart non-PDU",
      "ja": "26 enctgsreppart non-pdu"
    },
    {
      "indent": 3,
      "text": "27 EncApRepPart non-PDU",
      "ja": "27 encapreppart non-pdu"
    },
    {
      "indent": 3,
      "text": "28 EncKrbPrivPart non-PDU",
      "ja": "28 enckrbprivpart non-pdu"
    },
    {
      "indent": 3,
      "text": "29 EncKrbCredPart non-PDU",
      "ja": "29 ckrbcrededpart non-pdu"
    },
    {
      "indent": 3,
      "text": "30 KRB-ERROR PDU",
      "ja": "30 KRB-ERROR PDU"
    },
    {
      "indent": 3,
      "text": "The ASN.1 types marked above as \"PDU\" (Protocol Data Unit) are the only ASN.1 types intended as top-level types of the Kerberos protocol, and are the only types that may be used as elements in another protocol that makes use of Kerberos.",
      "ja": "上記の「PDU」（プロトコルデータユニット）としてマークされたASN.1タイプは、Kerberosプロトコルのトップレベルタイプとして意図された唯一のASN.1タイプであり、別のプロトコルの要素として使用できる唯一のタイプです。Kerberosの使用。"
    },
    {
      "indent": 0,
      "text": "6. Naming Constraints",
      "section_title": true,
      "ja": "6. 命名制約"
    },
    {
      "indent": 0,
      "text": "6.1. Realm Names",
      "section_title": true,
      "ja": "6.1. レルム名"
    },
    {
      "indent": 3,
      "text": "Although realm names are encoded as GeneralStrings and technically a realm can select any name it chooses, interoperability across realm boundaries requires agreement on how realm names are to be assigned, and what information they imply.",
      "ja": "レルム名はジェネラルストリングスとしてエンコードされており、技術的にはレルムが選択する名前を選択できますが、レルムの境界を越えた相互運用性には、レルム名の割り当て方法とそれらが暗示する情報について一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "To enforce these conventions, each realm MUST conform to the conventions itself, and it MUST require that any realms with which inter-realm keys are shared also conform to the conventions and require the same from its neighbors.",
      "ja": "これらの慣習を実施するには、各領域が慣習自体に準拠する必要があり、リアルム間キーが共有される領域も慣習に適合し、隣人から同じものを必要とする必要があります。"
    },
    {
      "indent": 3,
      "text": "Kerberos realm names are case sensitive. Realm names that differ only in the case of the characters are not equivalent. There are presently three styles of realm names: domain, X500, and other. Examples of each style follow:",
      "ja": "Kerberos Realmの名前はケースに敏感です。文字の場合にのみ異なるレルム名は同等ではありません。現在、ドメイン、X500などの3つのスタイルの領域名があります。各スタイルの例が続きます："
    },
    {
      "indent": 8,
      "text": "domain:   ATHENA.MIT.EDU\n  X500:   C=US/O=OSF\n other:   NAMETYPE:rest/of.name=without-restrictions",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Domain style realm names MUST look like domain names: they consist of components separated by periods (.) and they contain neither colons (:) nor slashes (/). Though domain names themselves are case insensitive, in order for realms to match, the case must match as well. When establishing a new realm name based on an internet domain name it is recommended by convention that the characters be converted to uppercase.",
      "ja": "ドメインスタイルのレルム名はドメイン名のように見える必要があります。これらは、ピリオド（。）で区切られたコンポーネントで構成され、コロン（:)もスラッシュも含まれていません（/）。ドメイン名自体は、領域と一致させるためにはケースが鈍感ですが、ケースも同様に一致する必要があります。インターネットドメイン名に基づいて新しいレルム名を確立するときは、キャラクターが大文字に変換されることを条約によって推奨されます。"
    },
    {
      "indent": 3,
      "text": "X.500 names contain an equals sign (=) and cannot contain a colon (:) before the equals sign. The realm names for X.500 names will be string representations of the names with components separated by slashes. Leading and trailing slashes will not be included. Note that the slash separator is consistent with Kerberos implementations based on RFC 1510, but it is different from the separator recommended in RFC 2253.",
      "ja": "X.500名には等しい記号（=）が含まれており、等しい記号の前にコロン（:)を含めることはできません。X.500名のレルム名は、スラッシュで区切られたコンポーネントを持つ名前の文字列表現です。リーディングおよびトレーリングスラッシュは含まれません。スラッシュセパレーターは、RFC 1510に基づくKerberosの実装と一致しているが、RFC 2253で推奨されるセパレーターとは異なることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Names that fall into the other category MUST begin with a prefix that contains no equals sign (=) or period (.), and the prefix MUST be followed by a colon (:) and the rest of the name. All prefixes expect those beginning with used. Presently none are assigned.",
      "ja": "他のカテゴリに分類される名前は、等しい符号（=）または周期（。）を含む接頭辞から始まる必要があり、プレフィックスの後にコロン（:)および残りの名前が続く必要があります。すべての接頭辞は、使用されているものから始まるものを期待しています。現在は割り当てられていません。"
    },
    {
      "indent": 3,
      "text": "The reserved category includes strings that do not fall into the first three categories. All names in this category are reserved. It is unlikely that names will be assigned to this category unless there is a very strong argument for not using the 'other' category.",
      "ja": "予約されたカテゴリには、最初の3つのカテゴリに分類されない文字列が含まれています。このカテゴリのすべての名前は予約されています。「他の」カテゴリを使用しないための非常に強力な議論がない限り、名前がこのカテゴリに割り当てられる可能性は低いです。"
    },
    {
      "indent": 3,
      "text": "These rules guarantee that there will be no conflicts between the various name styles. The following additional constraints apply to the assignment of realm names in the domain and X.500 categories: either the name of a realm for the domain or X.500 formats must be used by the organization owning (to whom it was assigned) an Internet domain name or X.500 name, or, in the case that no such names are registered, authority to use a realm name MAY be derived from the authority of the parent realm. For example, if there is no domain name for E40.MIT.EDU, then the administrator of the MIT.EDU realm can authorize the creation of a realm with that name.",
      "ja": "これらのルールは、さまざまな名前スタイルの間に競合がないことを保証します。ドメインおよびX.500カテゴリのレルム名の割り当てには、次の追加の制約が適用されます。ドメインのレルムの名前またはX.500形式は、インターネットを所有する（割り当てられた）組織が使用する必要があります。ドメイン名またはx.500名、またはそのような名前が登録されていない場合、レルム名を使用する権限は、親の領域の権限から派生する場合があります。たとえば、e40.mit.eduのドメイン名がない場合、mit.edu remoの管理者は、その名前で領域の作成を承認できます。"
    },
    {
      "indent": 3,
      "text": "This is acceptable because the organization to which the parent is assigned is presumably the organization authorized to assign names to its children in the X.500 and domain name systems as well. If the parent assigns a realm name without also registering it in the domain name or X.500 hierarchy, it is the parent's responsibility to make sure that in the future there will not exist a name identical to the realm name of the child unless it is assigned to the same entity as the realm name.",
      "ja": "これは、親が割り当てられる組織は、おそらくX.500およびドメイン名システムの子供に名前を割り当てることを許可されている組織であると考えられているため、受け入れられます。親がドメイン名またはx.500階層に登録せずにレルム名を割り当てる場合、将来、子供のレルム名と同じ名前が存在しないことを確認することは親の責任です。レルム名と同じエンティティに割り当てられます。"
    },
    {
      "indent": 0,
      "text": "6.2. Principal Names",
      "section_title": true,
      "ja": "6.2. 主名"
    },
    {
      "indent": 3,
      "text": "As was the case for realm names, conventions are needed to ensure that all agree on what information is implied by a principal name. The name-type field that is part of the principal name indicates the kind of information implied by the name. The name-type SHOULD be treated only as a hint to interpreting the meaning of a name. It is not significant when checking for equivalence. Principal names that differ only in the name-type identify the same principal. The name type does not partition the name space. Ignoring the name type, no two names can be the same (i.e., at least one of the components, or the realm, MUST be different). The following name types are defined:",
      "ja": "レルム名の場合と同様に、すべてが主名で暗示される情報にすべてが同意することを保証するために慣習が必要です。主名の一部である名前タイプのフィールドは、名前で暗示される情報の種類を示します。名前タイプは、名前の意味を解釈するためのヒントとしてのみ扱う必要があります。同等性をチェックするときは重要ではありません。名前タイプでのみ異なるプリンシパル名は、同じプリンシパルを識別します。名前タイプは、名前空間を分割しません。名前タイプを無視すると、2つの名前が同じではありません（つまり、少なくとも1つのコンポーネント、またはレルムが異なる必要があります）。次の名前のタイプが定義されています。"
    },
    {
      "indent": 3,
      "text": "Name Type Value Meaning",
      "ja": "名前タイプ値の意味"
    },
    {
      "indent": 3,
      "text": "NT-UNKNOWN 0 Name type not known NT-PRINCIPAL 1 Just the name of the principal as in DCE, or for users NT-SRV-INST 2 Service and other unique instance (krbtgt) NT-SRV-HST 3 Service with host name as instance (telnet, rcommands) NT-SRV-XHST 4 Service with host as remaining components NT-UID 5 Unique ID NT-X500-PRINCIPAL 6 Encoded X.509 Distinguished name [RFC2253] NT-SMTP-NAME 7 Name in form of SMTP email name (e.g., user@example.com) NT-ENTERPRISE 10 Enterprise name - may be mapped to principal name",
      "ja": "nt-unknown 0 name type noteble noted nt-principal 1 dceのようなプリンシパルの名前、またはnt-srv-inst 2サービスおよびその他のユニークなインスタンス（krbtgt）nt-srv-hst 3サービスのホスト名としてnt-srv-hst 3サービスインスタンス（telnet、rcommands）nt-srv-xhst 4サービス残りコンポーネントとしてホストを含む4サービス電子メール名（例：user@example.com）"
    },
    {
      "indent": 3,
      "text": "When a name implies no information other than its uniqueness at a particular time, the name type PRINCIPAL SHOULD be used. The principal name type SHOULD be used for users, and it might also be used for a unique server. If the name is a unique machine-generated ID that is guaranteed never to be reassigned, then the name type of UID SHOULD be used. (Note that it is generally a bad idea to reassign names of any type since stale entries might remain in access control lists.)",
      "ja": "名前が特定の時間にその独自性以外の情報を意味しない場合、名前タイプのプリンシパルを使用する必要があります。主名のタイプはユーザーに使用する必要があり、一意のサーバーにも使用される場合があります。名前が決して再割り当てされないことが保証されている一意の機械生成IDである場合、UIDの名前タイプを使用する必要があります。（古いエントリがアクセス制御リストに残っている可能性があるため、あらゆるタイプの名前を再割り当てすることは一般に悪い考えであることに注意してください。）"
    },
    {
      "indent": 3,
      "text": "If the first component of a name identifies a service and the remaining components identify an instance of the service in a server-specified manner, then the name type of SRV-INST SHOULD be used. An example of this name type is the Kerberos ticket-granting service whose name has a first component of krbtgt and a second component identifying the realm for which the ticket is valid.",
      "ja": "名前の最初のコンポーネントがサービスを識別し、残りのコンポーネントがサーバー指定の方法でサービスのインスタンスを識別する場合、SRV-INSTの名前タイプを使用する必要があります。この名前のタイプの例は、Kerberosのチケット栽培サービスです。その名前は、Krbtgtの最初のコンポーネントと、チケットが有効な領域を識別する2番目のコンポーネントです。"
    },
    {
      "indent": 3,
      "text": "If the first component of a name identifies a service and there is a single component following the service name identifying the instance as the host on which the server is running, then the name type SRV-HST SHOULD be used. This type is typically used for Internet services such as telnet and the Berkeley R commands. If the separate components of the host name appear as successive components following the name of the service, then the name type SRV-XHST SHOULD be used. This type might be used to identify servers on hosts with X.500 names, where the slash (/) might otherwise be ambiguous.",
      "ja": "名前の最初のコンポーネントがサービスを識別し、サーバーが実行されているホストとしてインスタンスを識別するサービス名に続く単一のコンポーネントがある場合、名前タイプSRV-HSTを使用する必要があります。このタイプは通常、TelnetやBerkeley R Commandsなどのインターネットサービスに使用されます。ホスト名の個別のコンポーネントがサービスの名前に続く連続コンポーネントとして表示される場合、名前タイプSRV-XHSTを使用する必要があります。このタイプは、x.500名のホストのサーバーを識別するために使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "A name type of NT-X500-PRINCIPAL SHOULD be used when a name from an X.509 certificate is translated into a Kerberos name. The encoding of the X.509 name as a Kerberos principal shall conform to the encoding rules specified in RFC 2253.",
      "ja": "X.509証明書の名前がKerberosの名前に翻訳されている場合、NT-X500-Principalの名前を使用する必要があります。Kerberosの校長としてのX.509名のエンコードは、RFC 2253で指定されたエンコードルールに準拠するものとします。"
    },
    {
      "indent": 3,
      "text": "A name type of SMTP allows a name to be of a form that resembles an SMTP email name. This name, including an \"@\" and a domain name, is used as the one component of the principal name.",
      "ja": "SMTPの名前タイプを使用すると、名前をSMTPメール名に似たフォームにすることができます。「@」とドメイン名を含むこの名前は、主名の1つのコンポーネントとして使用されます。"
    },
    {
      "indent": 3,
      "text": "A name type of UNKNOWN SHOULD be used when the form of the name is not known. When comparing names, a name of type UNKNOWN will match principals authenticated with names of any type. A principal authenticated with a name of type UNKNOWN, however, will only match other names of type UNKNOWN.",
      "ja": "名前の形式が不明な場合は、名前のタイプの未知のタイプを使用する必要があります。名前を比較する場合、型の名前の名前は、あらゆるタイプの名前で認証されたプリンシパルと一致します。ただし、未知のタイプの名前で認証されたプリンシパルは、未知のタイプの他の名前のみと一致します。"
    },
    {
      "indent": 3,
      "text": "Names of any type with an initial component of 'krbtgt' are reserved for the Kerberos ticket-granting service. See Section 7.3 for the form of such names.",
      "ja": "「krbtgt」の初期コンポーネントを持つあらゆるタイプの名前は、Kerberosのチケット栽培サービス用に予約されています。そのような名前の形式については、セクション7.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.2.1. Name of Server Principals",
      "section_title": true,
      "ja": "6.2.1. サーバープリンシパルの名前"
    },
    {
      "indent": 3,
      "text": "The principal identifier for a server on a host will generally be composed of two parts: (1) the realm of the KDC with which the server is registered, and (2) a two-component name of type NT-SRV-HST, if the host name is an Internet domain name, or a multi-component name of type NT-SRV-XHST, if the name of the host is of a form (such as X.500) that allows slash (/) separators. The first component of the two- or multi-component name will identify the service, and the latter components will identify the host. Where the name of the host is not case sensitive (for example, with Internet domain names) the name of the host MUST be lowercase. If specified by the application protocol for services such as telnet and the Berkeley R commands that run with system privileges, the first component MAY be the string 'host' instead of a service-specific identifier.",
      "ja": "ホストのサーバーの主要な識別子は、通常、2つの部分で構成されます。（1）サーバーが登録されているKDCの領域と（2）タイプNT-SRV-HSTの2成分名、場合ホスト名は、インターネットドメイン名、またはタイプNT-SRV-XHSTのマルチコンポーネント名です。ホストの名前がスラッシュ（/）セパレータを許可するフォーム（X.500など）の場合。2コンポーネントまたはマルチコンポーネント名の最初のコンポーネントはサービスを識別し、後者のコンポーネントはホストを識別します。ホストの名前がケースに敏感ではない場合（たとえば、インターネットドメイン名の場合）、ホストの名前は小文字でなければなりません。TelnetやBerkeley Rコマンドなどのサービスのアプリケーションプロトコルによって指定された場合、システム特権で実行されるバークレーRコマンドは、最初のコンポーネントは、サービス固有の識別子ではなく、文字列「ホスト」です。"
    },
    {
      "indent": 0,
      "text": "7. Constants and Other Defined Values",
      "section_title": true,
      "ja": "7. 定数およびその他の定義された値"
    },
    {
      "indent": 0,
      "text": "7.1. Host Address Types",
      "section_title": true,
      "ja": "7.1. ホストアドレスタイプ"
    },
    {
      "indent": 3,
      "text": "All negative values for the host address type are reserved for local use. All non-negative values are reserved for officially assigned type fields and interpretations.",
      "ja": "ホストアドレスタイプのすべての負の値は、ローカル使用のために予約されています。すべての非陰性値は、正式に割り当てられたタイプフィールドと解釈のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Internet (IPv4) Addresses",
      "ja": "インターネット（IPv4）アドレス"
    },
    {
      "indent": 6,
      "text": "Internet (IPv4) addresses are 32-bit (4-octet) quantities, encoded in MSB order (most significant byte first). The IPv4 loopback address SHOULD NOT appear in a Kerberos PDU. The type of IPv4 addresses is two (2).",
      "ja": "インターネット（IPv4）アドレスは32ビット（4-OCTET）数量で、MSB順序でエンコードされています（最初に最も重要なバイト）。IPv4ループバックアドレスは、Kerberos PDUに表示されないでください。IPv4アドレスのタイプは2つです。"
    },
    {
      "indent": 3,
      "text": "Internet (IPv6) Addresses",
      "ja": "インターネット（IPv6）アドレス"
    },
    {
      "indent": 6,
      "text": "IPv6 addresses [RFC3513] are 128-bit (16-octet) quantities, encoded in MSB order (most significant byte first). The type of IPv6 addresses is twenty-four (24). The following addresses MUST NOT appear in any Kerberos PDU:",
      "ja": "IPv6アドレス[RFC3513]は128ビット（16-OCTET）量で、MSB順序でエンコードされています（最初に最も重要なバイト）。IPv6アドレスのタイプは24（24）です。次のアドレスは、Kerberos PDUに表示されてはなりません。"
    },
    {
      "indent": 9,
      "text": "* the Unspecified Address\n\n* the Loopback Address\n\n* Link-Local addresses",
      "ja": "*不特定のアドレス\n\n*ループバックアドレス\n\n* Link-Localアドレス"
    },
    {
      "indent": 6,
      "text": "This restriction applies to the inclusion in the address fields of Kerberos PDUs, but not to the address fields of packets that might carry such PDUs. The restriction is necessary because the use of an address with non-global scope could allow the acceptance of a message sent from a node that may have the same address, but which is not the host intended by the entity that added the restriction. If the link-local address type needs to be used for communication, then the address restriction in tickets must not be used (i.e., addressless tickets must be used).",
      "ja": "この制限は、Kerberos PDUSのアドレスフィールドに含めることに適用されますが、そのようなPDUを運ぶ可能性のあるパケットのアドレスフィールドには適用されません。グローバル以外のスコープを持つアドレスを使用すると、同じアドレスがある可能性のあるノードから送信されたメッセージの受け入れが可能になる可能性があるため、制限が必要です。リンクローカルアドレスタイプを通信に使用する必要がある場合、チケットのアドレス制限を使用してはなりません（つまり、アドレスレスチケットを使用する必要があります）。"
    },
    {
      "indent": 6,
      "text": "IPv4-mapped IPv6 addresses MUST be represented as addresses of type 2.",
      "ja": "IPv4-Mapped IPv6アドレスは、タイプ2のアドレスとして表す必要があります。"
    },
    {
      "indent": 3,
      "text": "DECnet Phase IV Addresses",
      "ja": "デコネットフェーズIVアドレス"
    },
    {
      "indent": 6,
      "text": "DECnet Phase IV addresses are 16-bit addresses, encoded in LSB order. The type of DECnet Phase IV addresses is twelve (12).",
      "ja": "DECNETフェーズIVアドレスは16ビットアドレスで、LSB順序でエンコードされています。DECNETフェーズIVアドレスのタイプは12（12）です。"
    },
    {
      "indent": 3,
      "text": "Netbios Addresses",
      "ja": "NetBiosアドレス"
    },
    {
      "indent": 6,
      "text": "Netbios addresses are 16-octet addresses typically composed of 1 to 15 alphanumeric characters and padded with the US-ASCII SPC character (code 32). The 16th octet MUST be the US-ASCII NUL character (code 0). The type of Netbios addresses is twenty (20).",
      "ja": "NetBiosアドレスは、通常1〜15個の英数字で構成され、US-ASCII SPC文字でパッドで構成される16オクテットアドレスです（コード32）。16番目のオクテットは、US-Ascii Nulの文字（コード0）でなければなりません。NetBIOSアドレスのタイプは20（20）です。"
    },
    {
      "indent": 3,
      "text": "Directional Addresses",
      "ja": "方向アドレス"
    },
    {
      "indent": 6,
      "text": "Including the sender address in KRB_SAFE and KRB_PRIV messages is undesirable in many environments because the addresses may be changed in transport by network address translators. However, if these addresses are removed, the messages may be subject to a reflection attack in which a message is reflected back to its originator. The directional address type provides a way to avoid transport addresses and reflection attacks. Directional addresses are encoded as four-byte unsigned integers in network byte order. If the message is originated by the party sending the original KRB_AP_REQ message, then an address of 0 SHOULD be used. If the message is originated by the party to whom that KRB_AP_REQ was sent, then the address 1 SHOULD be used. Applications involving multiple parties can specify the use of other addresses.",
      "ja": "krb_safeおよびkrb_privメッセージの送信者アドレスを含めることは、ネットワークアドレス翻訳者による輸送でアドレスが変更される可能性があるため、多くの環境で望ましくありません。ただし、これらのアドレスが削除された場合、メッセージは、メッセージがそのオリジネーターに反映される反射攻撃の対象となる場合があります。方向アドレスタイプは、輸送アドレスと反射攻撃を避ける方法を提供します。方向アドレスは、ネットワークバイトの順序で4バイトの符号なし整数としてエンコードされます。メッセージが元のkrb_ap_reqメッセージを送信するパーティーによって発信される場合、0のアドレスを使用する必要があります。メッセージがそのKRB_AP_REQが送信された当事者によって発信される場合、アドレス1を使用する必要があります。複数の関係者が関与するアプリケーションは、他のアドレスの使用を指定できます。"
    },
    {
      "indent": 6,
      "text": "Directional addresses MUST only be used for the sender address field in the KRB_SAFE or KRB_PRIV messages. They MUST NOT be used as a ticket address or in a KRB_AP_REQ message. This address type SHOULD only be used in situations where the sending party knows that the receiving party supports the address type. This generally means that directional addresses may only be used when the application protocol requires their support. Directional addresses are type (3).",
      "ja": "方向アドレスは、krb_safeまたはkrb_privメッセージの送信者アドレスフィールドにのみ使用する必要があります。それらは、チケットアドレスとして、またはkrb_ap_reqメッセージで使用してはなりません。このアドレスタイプは、送信者が受信当事者がアドレスタイプをサポートしていることを知っている状況でのみ使用する必要があります。これは一般に、アプリケーションプロトコルがサポートを必要とする場合にのみ、方向アドレスを使用できることを意味します。方向アドレスはタイプ（3）です。"
    },
    {
      "indent": 0,
      "text": "7.2. KDC Messaging: IP Transports",
      "section_title": true,
      "ja": "7.2. KDCメッセージング：IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos defines two IP transport mechanisms for communication between clients and servers: UDP/IP and TCP/IP.",
      "ja": "Kerberosは、クライアントとサーバー間の通信のための2つのIPトランスポートメカニズムを定義しています：UDP/IPとTCP/IP。"
    },
    {
      "indent": 0,
      "text": "7.2.1. UDP/IP transport",
      "section_title": true,
      "ja": "7.2.1. UDP/IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos servers (KDCs) supporting IP transports MUST accept UDP requests and SHOULD listen for them on port 88 (decimal) unless specifically configured to listen on an alternative UDP port. Alternate ports MAY be used when running multiple KDCs for multiple realms on the same host.",
      "ja": "IPトランスポートをサポートするKerberosサーバー（KDCS）は、UDPリクエストを受け入れる必要があり、別のUDPポートでリッスンするように特別に構成されていない限り、ポート88（小数）でそれらを聞く必要があります。同じホストで複数の領域に対して複数のKDCを実行する場合、代替ポートを使用できます。"
    },
    {
      "indent": 3,
      "text": "Kerberos clients supporting IP transports SHOULD support the sending of UDP requests. Clients SHOULD use KDC discovery [7.2.3] to identify the IP address and port to which they will send their request.",
      "ja": "IPトランスポートをサポートするKerberosクライアントは、UDPリクエストの送信をサポートする必要があります。クライアントは、KDC Discovery [7.2.3]を使用して、リクエストを送信するIPアドレスとポートを特定する必要があります。"
    },
    {
      "indent": 3,
      "text": "When contacting a KDC for a KRB_KDC_REQ request using UDP/IP transport, the client shall send a UDP datagram containing only an encoding of the request to the KDC. The KDC will respond with a reply datagram containing only an encoding of the reply message (either a KRB_ERROR or a KRB_KDC_REP) to the sending port at the sender's IP address. The response to a request made through UDP/IP transport MUST also use UDP/IP transport. If the response cannot be handled using UDP (for example, because it is too large), the KDC MUST return KRB_ERR_RESPONSE_TOO_BIG, forcing the client to retry the request using the TCP transport.",
      "ja": "UDP/IPトランスポートを使用してKRB_KDC_REQ要求についてKDCに連絡する場合、クライアントは、要求のエンコードのみをKDCに含むUDPデータグラムを送信するものとします。KDCは、返信メッセージ（KRB_ERRORまたはKRB_KDC_REPのいずれか）のエンコードのみを含む返信データグラムで、送信者のIPアドレスの送信ポートに応答します。UDP/IPトランスポートを介して行われた要求に対する応答も、UDP/IPトランスポートを使用する必要があります。UDPを使用して応答を処理できない場合（たとえば、大きすぎるため）、KDCはKRB_ERR_RESPONSE_TOO_BIGを返し、TCPトランスポートを使用してクライアントにリクエストを再試行するように強制する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.2.2. TCP/IP Transport",
      "section_title": true,
      "ja": "7.2.2. TCP/IPトランスポート"
    },
    {
      "indent": 3,
      "text": "Kerberos servers (KDCs) supporting IP transports MUST accept TCP requests and SHOULD listen for them on port 88 (decimal) unless specifically configured to listen on an alternate TCP port. Alternate ports MAY be used when running multiple KDCs for multiple realms on the same host.",
      "ja": "IPトランスポートをサポートするKerberosサーバー（KDCS）は、TCPリクエストを受け入れる必要があり、代替TCPポートでリッスンするように特別に構成されていない限り、ポート88（小数）でそれらを聞く必要があります。同じホストで複数の領域に対して複数のKDCを実行する場合、代替ポートを使用できます。"
    },
    {
      "indent": 3,
      "text": "Clients MUST support the sending of TCP requests, but MAY choose to try a request initially using the UDP transport. Clients SHOULD use KDC discovery [7.2.3] to identify the IP address and port to which they will send their request.",
      "ja": "クライアントはTCPリクエストの送信をサポートする必要がありますが、最初にUDPトランスポートを使用してリクエストを試すことを選択できます。クライアントは、KDC Discovery [7.2.3]を使用して、リクエストを送信するIPアドレスとポートを特定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Some extensions to the Kerberos protocol will not succeed if any client or KDC not supporting the TCP transport is involved. Implementations of RFC 1510 were not required to support TCP/IP transports.",
      "ja": "実装注：Kerberosプロトコルの一部の拡張機能は、TCPトランスポートをサポートしていないクライアントまたはKDCが関与していない場合、成功しません。RFC 1510の実装は、TCP/IPトランスポートをサポートするために必要ではありませんでした。"
    },
    {
      "indent": 3,
      "text": "When the KRB_KDC_REQ message is sent to the KDC over a TCP stream, the response (KRB_KDC_REP or KRB_ERROR message) MUST be returned to the client on the same TCP stream that was established for the request. The KDC MAY close the TCP stream after sending a response, but MAY leave the stream open for a reasonable period of time if it expects a follow-up. Care must be taken in managing TCP/IP connections on the KDC to prevent denial of service attacks based on the number of open TCP/IP connections.",
      "ja": "KRB_KDC_REQメッセージがTCPストリームを介してKDCに送信される場合、応答（KRB_KDC_REPまたはKRB_ERRORメッセージ）は、リクエストのために確立された同じTCPストリームでクライアントに返す必要があります。KDCは、応答を送信した後、TCPストリームを閉じることができますが、フォローアップが予想される場合は、妥当な期間ストリームを開いたままにすることがあります。Open TCP/IP接続の数に基づいてサービス拒否攻撃を防ぐために、KDCのTCP/IP接続の管理に注意する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client MUST be prepared to have the stream closed by the KDC at any time after the receipt of a response. A stream closure SHOULD NOT be treated as a fatal error. Instead, if multiple exchanges are required (e.g., certain forms of pre-authentication), the client may need to establish a new connection when it is ready to send subsequent messages. A client MAY close the stream after receiving a response, and SHOULD close the stream if it does not expect to send follow-up messages.",
      "ja": "クライアントは、応答を受け取った後、いつでもKDCによってストリームを閉じる準備をする必要があります。ストリームの閉鎖は、致命的なエラーとして扱われるべきではありません。代わりに、複数の交換が必要な場合（たとえば、特定の形式の事前認証）、クライアントは、後続のメッセージを送信する準備ができたときに新しい接続を確立する必要がある場合があります。クライアントは、応答を受け取った後にストリームを閉じることができ、フォローアップメッセージを送信する予定がない場合は、ストリームを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "A client MAY send multiple requests before receiving responses, though it must be prepared to handle the connection being closed after the first response.",
      "ja": "クライアントは、応答を受信する前に複数のリクエストを送信する場合がありますが、最初の応答の後に閉じられている接続を処理する準備をする必要があります。"
    },
    {
      "indent": 3,
      "text": "Each request (KRB_KDC_REQ) and response (KRB_KDC_REP or KRB_ERROR) sent over the TCP stream is preceded by the length of the request as 4 octets in network byte order. The high bit of the length is reserved for future expansion and MUST currently be set to zero. If a KDC that does not understand how to interpret a set high bit of the length encoding receives a request with the high order bit of the length set, it MUST return a KRB-ERROR message with the error KRB_ERR_FIELD_TOOLONG and MUST close the TCP stream.",
      "ja": "TCPストリームを介して送信された各要求（krb_kdc_req）および応答（krb_kdc_repまたはkrb_error）の前に、ネットワークバイト順序で4オクテットとして要求の長さがあります。長さの高いビットは将来の拡張のために予約されており、現在ゼロに設定する必要があります。長さのエンコードの高さのハイビットを解釈する方法を理解していないKDCが、長さセットの高次ビットを使用してリクエストを受信した場合、エラーKRB_ERR_FIELD_TOOLONGでKRB-Errorメッセージを返す必要があり、TCPストリームを閉じる必要があります。"
    },
    {
      "indent": 3,
      "text": "If multiple requests are sent over a single TCP connection and the KDC sends multiple responses, the KDC is not required to send the responses in the order of the corresponding requests. This may permit some implementations to send each response as soon as it is ready, even if earlier requests are still being processed (for example, waiting for a response from an external device or database).",
      "ja": "単一のTCP接続で複数の要求が送信され、KDCが複数の応答を送信する場合、KDCは対応するリクエストの順序で応答を送信する必要はありません。これにより、以前のリクエストがまだ処理されていても（たとえば、外部デバイスまたはデータベースからの応答を待っている場合でも、準備ができたらすぐに各応答を送信できる場合があります。"
    },
    {
      "indent": 0,
      "text": "7.2.3. KDC Discovery on IP Networks",
      "section_title": true,
      "ja": "7.2.3. IPネットワークでのKDCディスカバリー"
    },
    {
      "indent": 3,
      "text": "Kerberos client implementations MUST provide a means for the client to determine the location of the Kerberos Key Distribution Centers (KDCs). Traditionally, Kerberos implementations have stored such configuration information in a file on each client machine. Experience has shown that this method of storing configuration information presents problems with out-of-date information and scaling, especially when using cross-realm authentication. This section describes a method for using the Domain Name System [RFC1035] for storing KDC location information.",
      "ja": "Kerberosクライアントの実装は、クライアントがKerberosキー配信センター（KDCS）の位置を決定する手段を提供する必要があります。従来、Kerberosの実装は、このような構成情報を各クライアントマシンのファイルに保存してきました。経験によると、この構成情報を保存する方法は、特にクロスリアム認証を使用する場合、時代遅れの情報とスケーリングの問題を提示することが示されています。このセクションでは、KDCの位置情報を保存するためにドメイン名システム[RFC1035]を使用する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "7.2.3.1. DNS vs. Kerberos: Case Sensitivity of Realm Names",
      "section_title": true,
      "ja": "7.2.3.1. DNS vs. Kerberos：レルム名の症例感度"
    },
    {
      "indent": 3,
      "text": "In Kerberos, realm names are case sensitive. Although it is strongly encouraged that all realm names be all uppercase, this recommendation has not been adopted by all sites. Some sites use all lowercase names and other use mixed case. DNS, on the other hand, is case insensitive for queries. Because the realm names \"MYREALM\", \"myrealm\", and \"MyRealm\" are all different, but resolve the same in the domain name system, it is necessary that only one of the possible combinations of upper- and lowercase characters be used in realm names.",
      "ja": "Kerberosでは、レルム名はケースに敏感です。すべてのレルム名がすべて大文字であることが強く奨励されていますが、この推奨事項はすべてのサイトで採用されていません。一部のサイトでは、すべての小文字の名前とその他のミックスケースを使用しています。一方、DNSは、クエリに対して鈍感な場合です。領域は「myrealm」、「myrealm」、および「myrealm」という名前であるため、ドメイン名システムでは同じものを解決するため、上位および小文字の可能な組み合わせの1つだけが領域で使用される必要があります。名前。"
    },
    {
      "indent": 0,
      "text": "7.2.3.2. Specifying KDC Location Information with DNS SRV records",
      "section_title": true,
      "ja": "7.2.3.2. DNS SRVレコードを使用してKDCの位置情報を指定します"
    },
    {
      "indent": 3,
      "text": "KDC location information is to be stored using the DNS SRV RR [RFC2782]. The format of this RR is as follows:",
      "ja": "KDCの位置情報は、DNS SRV RR [RFC2782]を使用して保存されます。このRRの形式は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "_Service._Proto.Realm TTL Class SRV Priority Weight Port Target",
      "ja": "_Service._Proto.RealM TTLクラスSRV優先ウェイトポートターゲット"
    },
    {
      "indent": 3,
      "text": "The Service name for Kerberos is always \"kerberos\".",
      "ja": "Kerberosのサービス名は常に「Kerberos」です。"
    },
    {
      "indent": 3,
      "text": "The Proto can be either \"udp\" or \"tcp\". If these SRV records are to be used, both \"udp\" and \"tcp\" records MUST be specified for all KDC deployments.",
      "ja": "プロトは「UDP」または「TCP」のいずれかです。これらのSRVレコードを使用する場合、すべてのKDC展開に対して「UDP」と「TCP」レコードの両方を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Realm is the Kerberos realm that this record corresponds to. The realm MUST be a domain-style realm name.",
      "ja": "領域は、このレコードが対応するKerberos Realmです。領域はドメインスタイルのレルム名でなければなりません。"
    },
    {
      "indent": 3,
      "text": "TTL, Class, SRV, Priority, Weight, and Target have the standard meaning as defined in RFC 2782.",
      "ja": "TTL、クラス、SRV、優先度、重量、およびターゲットには、RFC 2782で定義されている標準的な意味があります。"
    },
    {
      "indent": 3,
      "text": "As per RFC 2782, the Port number used for \"_udp\" and \"_tcp\" SRV records SHOULD be the value assigned to \"kerberos\" by the Internet Assigned Number Authority: 88 (decimal), unless the KDC is configured to listen on an alternate TCP port.",
      "ja": "RFC 2782によると、「_udp」および「_tcp」srvレコードに使用されるポート番号は、インターネットが割り当てられたナンバー当局によって「kerberos」に割り当てられた値である必要があります。TCPポート。"
    },
    {
      "indent": 3,
      "text": "Implementation note: Many existing client implementations do not support KDC Discovery and are configured to send requests to the IANA assigned port (88 decimal), so it is strongly recommended that KDCs be configured to listen on that port.",
      "ja": "実装注：多くの既存のクライアント実装はKDCの発見をサポートせず、IANAが割り当てられたポート（88小数）にリクエストを送信するように構成されているため、KDCをそのポートでリッスンするように構成することを強くお勧めします。"
    },
    {
      "indent": 0,
      "text": "7.2.3.3. KDC Discovery for Domain Style Realm Names on IP Networks",
      "section_title": true,
      "ja": "7.2.3.3. IPネットワーク上のドメインスタイルレルム名のKDCディスカバリー"
    },
    {
      "indent": 3,
      "text": "These are DNS records for a Kerberos realm EXAMPLE.COM. It has two Kerberos servers, kdc1.example.com and kdc2.example.com. Queries should be directed to kdc1.example.com first as per the specified priority. Weights are not used in these sample records.",
      "ja": "これらは、Kerberos Realm example.comのDNSレコードです。Kerberosサーバーの2つのKdc1.example.comとKdc2.example.comがあります。指定された優先度に従って、最初にkdc1.example.comにクエリを送信する必要があります。これらのサンプルレコードでは、ウェイトは使用されません。"
    },
    {
      "indent": 5,
      "text": "_kerberos._udp.EXAMPLE.COM. IN SRV 0 0 88 kdc1.example.com. _kerberos._udp.EXAMPLE.COM. IN SRV 1 0 88 kdc2.example.com. _kerberos._tcp.EXAMPLE.COM. IN SRV 0 0 88 kdc1.example.com. _kerberos._tcp.EXAMPLE.COM. IN SRV 1 0 88 kdc2.example.com.",
      "ja": "_kerberos._udp.example.com。in srv 0 0 88 kdc1.example.com_kerberos._udp.example.com。in srv 1 0 88 kdc2.example.com。_kerberos._tcp.example.com。in srv 0 0 88 kdc1.example.com_kerberos._tcp.example.com。in srv 1 0 88 kdc2.example.com。"
    },
    {
      "indent": 0,
      "text": "7.3. Name of the TGS",
      "section_title": true,
      "ja": "7.3. TGSの名前"
    },
    {
      "indent": 3,
      "text": "The principal identifier of the ticket-granting service shall be composed of three parts: the realm of the KDC issuing the TGS ticket, and a two-part name of type NT-SRV-INST, with the first part \"krbtgt\" and the second part the name of the realm that will accept the TGT. For example, a TGT issued by the ATHENA.MIT.EDU realm to be used to get tickets from the ATHENA.MIT.EDU KDC has a principal identifier of \"ATHENA.MIT.EDU\" (realm), (\"krbtgt\", \"ATHENA.MIT.EDU\") (name). A TGT issued by the ATHENA.MIT.EDU realm to be used to get tickets from the MIT.EDU realm has a principal identifier of \"ATHENA.MIT.EDU\" (realm), (\"krbtgt\", \"MIT.EDU\") (name).",
      "ja": "チケット栽培サービスの主要な識別子は、TGSチケットを発行するKDCの領域と、最初の部品「KRBTGT」と2番目の部品のタイプNT-SRV-INSTの2部構成名の3つの部分で構成されるものとします。TGTを受け入れる領域の名前の一部。たとえば、athena.mit.edu kdcからチケットを入手するために使用されるathena.mit.edu領域によって発行されたTGTには、「athena.mit.edu」（remal）、（ \"krbtgt\"、 \"の主要な識別子があります。athena.mit.edu \"）（名前）。athena.mit.edu remoが発行したTGTは、mit.edu remoからチケットを入手するために使用されます。（名前）。"
    },
    {
      "indent": 0,
      "text": "7.4. OID Arc for KerberosV5",
      "section_title": true,
      "ja": "7.4. kerberosv5のoid arc"
    },
    {
      "indent": 3,
      "text": "This OID MAY be used to identify Kerberos protocol messages encapsulated in other protocols. It also designates the OID arc for KerberosV5-related OIDs assigned by future IETF action. Implementation note: RFC 1510 had an incorrect value (5) for \"dod\" in its OID.",
      "ja": "このOIDは、他のプロトコルにカプセル化されたKerberosプロトコルメッセージを識別するために使用できます。また、将来のIETFアクションによって割り当てられたKerberosv5関連のOIDのOIDアークを指定します。実装注：RFC 1510には、OIDの「DOD」に対して誤った値（5）がありました。"
    },
    {
      "indent": 3,
      "text": "id-krb5         OBJECT IDENTIFIER ::= {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Assignment of OIDs beneath the id-krb5 arc must be obtained by contacting the registrar for the id-krb5 arc, or its designee. At the time of the issuance of this RFC, such registrations can be obtained by contacting krb5-oid-registrar@mit.edu.",
      "ja": "ID-KRB5 ARCの下にあるOIDの割り当ては、ID-KRB5 ARCまたはその被指名人のレジストラに連絡することにより、取得する必要があります。このRFCの発行の時点で、そのような登録はkrb5-oid-registrar@mit.eduに連絡することで取得できます。"
    },
    {
      "indent": 0,
      "text": "7.5. Protocol Constants and Associated Values",
      "section_title": true,
      "ja": "7.5. プロトコル定数と関連する値"
    },
    {
      "indent": 3,
      "text": "The following tables list constants used in the protocol and define their meanings. In the \"specification\" section, ranges are specified that limit the values of constants for which values are defined here. This allows implementations to make assumptions about the maximum values that will be received for these constants. Implementations receiving values outside the range specified in the \"specification\" section MAY reject the request, but they MUST recover cleanly.",
      "ja": "次の表には、プロトコルで使用されている定数がリストされ、その意味を定義します。「仕様」セクションでは、ここで定義されている定数の値を制限する範囲が指定されています。これにより、実装は、これらの定数で受信される最大値について仮定を行うことができます。「仕様」セクションで指定された範囲外の値を受信する実装では、リクエストを拒否する場合がありますが、きれいに回復する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.5.1. Key Usage Numbers",
      "section_title": true,
      "ja": "7.5.1. 主要な使用数"
    },
    {
      "indent": 3,
      "text": "The encryption and checksum specifications in [RFC3961] require as input a \"key usage number\", to alter the encryption key used in any specific message in order to make certain types of cryptographic attack more difficult. These are the key usage values assigned in this document:",
      "ja": "[RFC3961]の暗号化とチェックサムの仕様は、特定のタイプの暗号攻撃をより困難にするために、特定のメッセージで使用される暗号化キーを変更するために、入力として「キー使用番号」を入力する必要があります。これらは、このドキュメントで割り当てられている主要な使用値です。"
    },
    {
      "indent": 11,
      "text": "1. AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the client key (Section 5.2.7.2)",
      "ja": "1. クライアントキーで暗号化されたAS-REQ PA-ECN-TIMESTAMP PADATAタイムスタンプ（セクション5.2.7.2）"
    },
    {
      "indent": 4,
      "text": " 2. AS-REP Ticket and TGS-REP Ticket (includes TGS session key or application session key), encrypted with the service key (Section 5.3) 3. AS-REP encrypted part (includes TGS session key or application session key), encrypted with the client key (Section 5.4.2) 4. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS session key (Section 5.4.1) 5. TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS authenticator subkey (Section 5.4.1) 6. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum, keyed with the TGS session key (Section 5.5.1) 7. TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes TGS authenticator subkey), encrypted with the TGS session key (Section 5.5.1) 8. TGS-REP encrypted part (includes application session key), encrypted with the TGS session key (Section 5.4.2) 9. TGS-REP encrypted part (includes application session key), encrypted with the TGS authenticator subkey (Section 5.4.2) 10. AP-REQ Authenticator cksum, keyed with the application session key (Section 5.5.1) 11. AP-REQ Authenticator (includes application authenticator subkey), encrypted with the application session key (Section 5.5.1) 12. AP-REP encrypted part (includes application session subkey), encrypted with the application session key (Section 5.5.2) 13. KRB-PRIV encrypted part, encrypted with a key chosen by the application (Section 5.7.1) 14. KRB-CRED encrypted part, encrypted with a key chosen by the application (Section 5.8.1) 15. KRB-SAFE cksum, keyed with a key chosen by the application (Section 5.6.1) 16-18. Reserved for future use in Kerberos and related protocols. 19. AD-KDC-ISSUED checksum (ad-checksum in 5.2.6.4) 20-21. Reserved for future use in Kerberos and related protocols. 22-25. Reserved for use in the Kerberos Version 5 GSS-API mechanisms [RFC4121]. 26-511. Reserved for future use in Kerberos and related protocols. 512-1023. Reserved for uses internal to a Kerberos implementation. 1024. Encryption for application use in protocols that do not specify key usage values",
      "ja": "2. AS-REPチケットとTGS-REPチケット（TGSセッションキーまたはアプリケーションセッションキーを含む）、サービスキー（セクション5.3）で暗号化された3. AS-REP暗号化パーツ（TGSセッションキーまたはアプリケーションセッションキーを含む）、暗号化された暗号化クライアントキー（セクション5.4.2）4。TGS-REQ KDC-REQ-BODY AUTHORIZATIONDATA、TGSセッションキー（セクション5.4.1）で暗号化された5. TGS-REQ KDC-REQ-Body AuthorizationData、TGSで暗号化されたクライアAuthenticator Subkey（セクション5.4.1）6。TGS-REQ PA-TGS-REQ PADATA AP-REQ Authenticator CKSUM、TGSセッションキー（セクション5.5.1）7。TGS-REQ PA-TGS-REQ Padata AP-TGSセッションキー（セクション5.5.1）で暗号化されたReq Authenticator（TGS Authenticator Subkeyを含む）8。-REP暗号化された部品（アプリケーションセッションキーを含む）、TGS認証者サブキー（セクション5.4.2）で暗号化された10. AP-REQ Authenticator CKSUM、アプリケーションSESSIでキー付きキー（セクション5.5.1）11。アプリケーションセッションキー（セクション5.5.1）で暗号化されたAP-REQ Authenticator（Application Authenticator Subkeyを含む）12。アプリケーションセッションキー（セクション5.5.2）13。アプリケーションによって選択されたキーで暗号化されたKRB-PRIV暗号化されたパーツ（セクション5.7.1）14。アプリケーションによって選択されたキーで暗号化されたKRB-CREDの暗号化されたパーツ.1）15。KRB-Safe Cksum、アプリケーションによって選択されたキー（セクション5.6.1）16-18。Kerberosおよび関連プロトコルでの将来の使用のために予約されています。19. AD-KDC発行チェックサム（5.2.6.4のAD-Checksum）20-21。Kerberosおよび関連プロトコルでの将来の使用のために予約されています。22-25。Kerberosバージョン5 GSS-APIメカニズム[RFC4121]で使用するために予約されています。26-511。Kerberosおよび関連プロトコルでの将来の使用のために予約されています。512-1023。Kerberosの実装の内部を使用するために予約されています。1024.主要な使用値を指定しないプロトコルでのアプリケーション使用のための暗号化"
    },
    {
      "indent": 3,
      "text": " 1025. Checksums for application use in protocols that do not specify key usage values 1026-2047. Reserved for application use.",
      "ja": "1025.主要な使用値1026-2047を指定しないプロトコルでのアプリケーション使用のためのチェックサム。アプリケーションの使用のために予約されています。"
    },
    {
      "indent": 0,
      "text": "7.5.2. PreAuthentication Data Types",
      "section_title": true,
      "ja": "7.5.2. 事前認定データ型"
    },
    {
      "indent": 3,
      "text": "Padata and Data Type Padata-type Comment Value",
      "ja": "Padataおよびデータ型Padataタイプのコメント値"
    },
    {
      "indent": 3,
      "text": "PA-TGS-REQ                  1\nPA-ENC-TIMESTAMP            2\nPA-PW-SALT                  3\n[reserved]                  4\nPA-ENC-UNIX-TIME            5        (deprecated)\nPA-SANDIA-SECUREID          6\nPA-SESAME                   7\nPA-OSF-DCE                  8\nPA-CYBERSAFE-SECUREID       9\nPA-AFS3-SALT                10\nPA-ETYPE-INFO               11\nPA-SAM-CHALLENGE            12       (sam/otp)\nPA-SAM-RESPONSE             13       (sam/otp)\nPA-PK-AS-REQ_OLD            14       (pkinit)\nPA-PK-AS-REP_OLD            15       (pkinit)\nPA-PK-AS-REQ                16       (pkinit)\nPA-PK-AS-REP                17       (pkinit)\nPA-ETYPE-INFO2              19       (replaces pa-etype-info)\nPA-USE-SPECIFIED-KVNO       20\nPA-SAM-REDIRECT             21       (sam/otp)\nPA-GET-FROM-TYPED-DATA      22       (embedded in typed data)\nTD-PADATA                   22       (embeds padata)\nPA-SAM-ETYPE-INFO           23       (sam/otp)\nPA-ALT-PRINC                24       (crawdad@fnal.gov)\nPA-SAM-CHALLENGE2           30       (kenh@pobox.com)\nPA-SAM-RESPONSE2            31       (kenh@pobox.com)\nPA-EXTRA-TGT                41       Reserved extra TGT\nTD-PKINIT-CMS-CERTIFICATES  101      CertificateSet from CMS\nTD-KRB-PRINCIPAL            102      PrincipalName\nTD-KRB-REALM                103      Realm\nTD-TRUSTED-CERTIFIERS       104      from PKINIT\nTD-CERTIFICATE-INDEX        105      from PKINIT\nTD-APP-DEFINED-ERROR        106      application specific\nTD-REQ-NONCE                107      INTEGER\nTD-REQ-SEQ                  108      INTEGER\nPA-PAC-REQUEST              128      (jbrezak@exchange.microsoft.com)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.3. Address Types",
      "section_title": true,
      "ja": "7.5.3. アドレスタイプ"
    },
    {
      "indent": 3,
      "text": "Address Type Value",
      "ja": "アドレスタイプ値"
    },
    {
      "indent": 3,
      "text": "IPv4                             2\nDirectional                      3\nChaosNet                         5\nXNS                              6\nISO                              7\nDECNET Phase IV                 12\nAppleTalk DDP                   16\nNetBios                         20\nIPv6                            24",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.4. Authorization Data Types",
      "section_title": true,
      "ja": "7.5.4. 認証データ型"
    },
    {
      "indent": 3,
      "text": "Authorization Data Type Ad-type Value",
      "ja": "認証データ型ADタイプの値"
    },
    {
      "indent": 3,
      "text": "AD-IF-RELEVANT                     1\nAD-INTENDED-FOR-SERVER             2\nAD-INTENDED-FOR-APPLICATION-CLASS  3\nAD-KDC-ISSUED                      4\nAD-AND-OR                          5\nAD-MANDATORY-TICKET-EXTENSIONS     6\nAD-IN-TICKET-EXTENSIONS            7\nAD-MANDATORY-FOR-KDC               8\nReserved values                 9-63\nOSF-DCE                           64\nSESAME                            65\nAD-OSF-DCE-PKI-CERTID             66 (hemsath@us.ibm.com)\nAD-WIN2K-PAC                     128 (jbrezak@exchange.microsoft.com)\nAD-ETYPE-NEGOTIATION             129  (lzhu@windows.microsoft.com)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.5. Transited Encoding Types",
      "section_title": true,
      "ja": "7.5.5. トランジー済みエンコードタイプ"
    },
    {
      "indent": 3,
      "text": "Transited Encoding Type Tr-type Value",
      "ja": "Transited Encoding Type TR-Type値"
    },
    {
      "indent": 3,
      "text": "DOMAIN-X500-COMPRESS            1\nReserved values                 All others",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.5.6. Protocol Version Number",
      "section_title": true,
      "ja": "7.5.6. プロトコルバージョン番号"
    },
    {
      "indent": 3,
      "text": "Label Value Meaning or MIT Code",
      "ja": "ラベル値の意味またはMITコード"
    },
    {
      "indent": 3,
      "text": "pvno 5 Current Kerberos protocol version number",
      "ja": "PVNO 5現在のKerberosプロトコルバージョン番号"
    },
    {
      "indent": 0,
      "text": "7.5.7. Kerberos Message Types",
      "section_title": true,
      "ja": "7.5.7. Kerberosメッセージタイプ"
    },
    {
      "indent": 3,
      "text": "Message Type Value Meaning",
      "ja": "メッセージタイプの値の意味"
    },
    {
      "indent": 3,
      "text": "KRB_AS_REQ 10 Request for initial authentication KRB_AS_REP 11 Response to KRB_AS_REQ request KRB_TGS_REQ 12 Request for authentication based on TGT KRB_TGS_REP 13 Response to KRB_TGS_REQ request KRB_AP_REQ 14 Application request to server KRB_AP_REP 15 Response to KRB_AP_REQ_MUTUAL KRB_RESERVED16 16 Reserved for user-to-user krb_tgt_request KRB_RESERVED17 17 Reserved for user-to-user krb_tgt_reply KRB_SAFE 20 Safe (checksummed) application message KRB_PRIV 21 Private (encrypted) application message KRB_CRED 22 Private (encrypted) message to forward credentials KRB_ERROR 30 Error response",
      "ja": "ユーザーからユーザーへのkrb_tgt_reply krb_safe 20セーフ（チェックサム）アプリケーションメッセージKRB_PRIV 21プライベート（暗号化）アプリケーションメッセージKRB_CRED 22プライベート（暗号化）メッセージ"
    },
    {
      "indent": 0,
      "text": "7.5.8. Name Types",
      "section_title": true,
      "ja": "7.5.8. 名前タイプ"
    },
    {
      "indent": 3,
      "text": "Name Type Value Meaning",
      "ja": "名前タイプ値の意味"
    },
    {
      "indent": 3,
      "text": "KRB_NT_UNKNOWN 0 Name type not known KRB_NT_PRINCIPAL 1 Just the name of the principal as in DCE, or for users KRB_NT_SRV_INST 2 Service and other unique instance (krbtgt) KRB_NT_SRV_HST 3 Service with host name as instance (telnet, rcommands) KRB_NT_SRV_XHST 4 Service with host as remaining components KRB_NT_UID 5 Unique ID KRB_NT_X500_PRINCIPAL 6 Encoded X.509 Distinguished name [RFC2253] KRB_NT_SMTP_NAME 7 Name in form of SMTP email name (e.g., user@example.com) KRB_NT_ENTERPRISE 10 Enterprise name; may be mapped to principal name",
      "ja": "krb_nt_unknown 0 name type not nowneble krb_nt_principal 1 dceのようにプリンシパルの名前のみ、またはユーザーの場合はkrb_nt_srv_inst 2サービスおよびその他のユニークなインスタンス（krbtgt）krb_nt_srv_hst 3ホスト名のあるインスタンス、rcommand残りのコンポーネントKRB_NT_UID 5ユニークなID KRB_NT_X500_PRINCIPAL 6エンコードX.509著名な名前[RFC2253] KRB_NT_SMTP_NAME 7名前SMTPメール名（例：user@example.com）krb_nt_enterprise 10 Enterprise name;主名にマッピングされる場合があります"
    },
    {
      "indent": 0,
      "text": "7.5.9. Error Codes",
      "section_title": true,
      "ja": "7.5.9. エラーコード"
    },
    {
      "indent": 3,
      "text": "Error Code Value Meaning",
      "ja": "エラーコード値の意味"
    },
    {
      "indent": 3,
      "text": "KDC_ERR_NONE                           0  No error\nKDC_ERR_NAME_EXP                       1  Client's entry in database\n                                            has expired\nKDC_ERR_SERVICE_EXP                    2  Server's entry in database\n                                            has expired\nKDC_ERR_BAD_PVNO                       3  Requested protocol version\n                                            number not supported",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KDC_ERR_C_OLD_MAST_KVNO                4  Client's key encrypted in\n                                            old master key\nKDC_ERR_S_OLD_MAST_KVNO                5  Server's key encrypted in\n                                            old master key\nKDC_ERR_C_PRINCIPAL_UNKNOWN            6  Client not found in\n                                            Kerberos database\nKDC_ERR_S_PRINCIPAL_UNKNOWN            7  Server not found in\n                                            Kerberos database\nKDC_ERR_PRINCIPAL_NOT_UNIQUE           8  Multiple principal entries\n                                            in database\nKDC_ERR_NULL_KEY                       9  The client or server has a\n                                            null key\nKDC_ERR_CANNOT_POSTDATE               10  Ticket not eligible for\n                                            postdating\nKDC_ERR_NEVER_VALID                   11  Requested starttime is\n                                            later than end time\nKDC_ERR_POLICY                        12  KDC policy rejects request\nKDC_ERR_BADOPTION                     13  KDC cannot accommodate\n                                            requested option\nKDC_ERR_ETYPE_NOSUPP                  14  KDC has no support for\n                                            encryption type\nKDC_ERR_SUMTYPE_NOSUPP                15  KDC has no support for\n                                            checksum type\nKDC_ERR_PADATA_TYPE_NOSUPP            16  KDC has no support for\n                                            padata type\nKDC_ERR_TRTYPE_NOSUPP                 17  KDC has no support for\n                                            transited type\nKDC_ERR_CLIENT_REVOKED                18  Clients credentials have\n                                            been revoked\nKDC_ERR_SERVICE_REVOKED               19  Credentials for server have\n                                            been revoked\nKDC_ERR_TGT_REVOKED                   20  TGT has been revoked\nKDC_ERR_CLIENT_NOTYET                 21  Client not yet valid; try\n                                            again later\nKDC_ERR_SERVICE_NOTYET                22  Server not yet valid; try\n                                            again later\nKDC_ERR_KEY_EXPIRED                   23  Password has expired;\n                                            change password to reset\nKDC_ERR_PREAUTH_FAILED                24  Pre-authentication\n                                            information was invalid\nKDC_ERR_PREAUTH_REQUIRED              25  Additional pre-\n                                            authentication required\nKDC_ERR_SERVER_NOMATCH                26  Requested server and ticket\n                                            don't match\nKDC_ERR_MUST_USE_USER2USER            27  Server principal valid for\n                                            user2user only\nKDC_ERR_PATH_NOT_ACCEPTED             28  KDC Policy rejects\n                                            transited path",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "KDC_ERR_SVC_UNAVAILABLE               29  A service is not available\nKRB_AP_ERR_BAD_INTEGRITY              31  Integrity check on\n                                            decrypted field failed\nKRB_AP_ERR_TKT_EXPIRED                32  Ticket expired\nKRB_AP_ERR_TKT_NYV                    33  Ticket not yet valid\nKRB_AP_ERR_REPEAT                     34  Request is a replay\nKRB_AP_ERR_NOT_US                     35  The ticket isn't for us\nKRB_AP_ERR_BADMATCH                   36  Ticket and authenticator\n                                            don't match\nKRB_AP_ERR_SKEW                       37  Clock skew too great\nKRB_AP_ERR_BADADDR                    38  Incorrect net address\nKRB_AP_ERR_BADVERSION                 39  Protocol version mismatch\nKRB_AP_ERR_MSG_TYPE                   40  Invalid msg type\nKRB_AP_ERR_MODIFIED                   41  Message stream modified\nKRB_AP_ERR_BADORDER                   42  Message out of order\nKRB_AP_ERR_BADKEYVER                  44  Specified version of key is\n                                            not available\nKRB_AP_ERR_NOKEY                      45  Service key not available\nKRB_AP_ERR_MUT_FAIL                   46  Mutual authentication\n                                            failed\nKRB_AP_ERR_BADDIRECTION               47  Incorrect message direction\nKRB_AP_ERR_METHOD                     48  Alternative authentication\n                                            method required\nKRB_AP_ERR_BADSEQ                     49  Incorrect sequence number\n                                            in message\nKRB_AP_ERR_INAPP_CKSUM                50  Inappropriate type of\n                                            checksum in message\nKRB_AP_PATH_NOT_ACCEPTED              51  Policy rejects transited\n                                            path\nKRB_ERR_RESPONSE_TOO_BIG              52  Response too big for UDP;\n                                            retry with TCP\nKRB_ERR_GENERIC                       60  Generic error (description\n                                            in e-text)\nKRB_ERR_FIELD_TOOLONG                 61  Field is too long for this\n                                            implementation\nKDC_ERROR_CLIENT_NOT_TRUSTED          62  Reserved for PKINIT\nKDC_ERROR_KDC_NOT_TRUSTED             63  Reserved for PKINIT\nKDC_ERROR_INVALID_SIG                 64  Reserved for PKINIT\nKDC_ERR_KEY_TOO_WEAK                  65  Reserved for PKINIT\nKDC_ERR_CERTIFICATE_MISMATCH          66  Reserved for PKINIT\nKRB_AP_ERR_NO_TGT                     67  No TGT available to\n                                            validate USER-TO-USER\nKDC_ERR_WRONG_REALM                   68  Reserved for future use\nKRB_AP_ERR_USER_TO_USER_REQUIRED      69  Ticket must be for\n                                            USER-TO-USER\nKDC_ERR_CANT_VERIFY_CERTIFICATE       70  Reserved for PKINIT\nKDC_ERR_INVALID_CERTIFICATE           71  Reserved for PKINIT\nKDC_ERR_REVOKED_CERTIFICATE           72  Reserved for PKINIT\n   KDC_ERR_REVOCATION_STATUS_UNKNOWN     73  Reserved for PKINIT\nKDC_ERR_REVOCATION_STATUS_UNAVAILABLE 74  Reserved for PKINIT\nKDC_ERR_CLIENT_NAME_MISMATCH          75  Reserved for PKINIT\nKDC_ERR_KDC_NAME_MISMATCH             76  Reserved for PKINIT",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Interoperability Requirements",
      "section_title": true,
      "ja": "8. 相互運用性要件"
    },
    {
      "indent": 3,
      "text": "Version 5 of the Kerberos protocol supports a myriad of options. Among these are multiple encryption and checksum types; alternative encoding schemes for the transited field; optional mechanisms for pre-authentication; the handling of tickets with no addresses; options for mutual authentication; user-to-user authentication; support for proxies; the format of realm names; the handling of authorization data; and forwarding, postdating, and renewing tickets.",
      "ja": "Kerberosプロトコルのバージョン5は、無数のオプションをサポートしています。これらの中には、複数の暗号化とチェックサムタイプがあります。交通フィールドの代替エンコーディングスキーム。事前認証のためのオプションのメカニズム。アドレスのないチケットの取り扱い。相互認証のオプション。ユーザーからユーザーへの認証。プロキシのサポート。レルム名の形式。承認データの処理。チケットの転送、ポストデート、更新。"
    },
    {
      "indent": 3,
      "text": "In order to ensure the interoperability of realms, it is necessary to define a minimal configuration that must be supported by all implementations. This minimal configuration is subject to change as technology does. For example, if at some later date it is discovered that one of the required encryption or checksum algorithms is not secure, it will be replaced.",
      "ja": "領域の相互運用性を確保するために、すべての実装でサポートする必要がある最小限の構成を定義する必要があります。この最小限の構成は、テクノロジーのように変更される可能性があります。たとえば、後日、必要な暗号化またはチェックサムアルゴリズムの1つが安全でないことが発見された場合、交換されます。"
    },
    {
      "indent": 0,
      "text": "8.1. Specification 2",
      "section_title": true,
      "ja": "8.1. 仕様2"
    },
    {
      "indent": 3,
      "text": "This section defines the second specification of these options. Implementations which are configured in this way can be said to support Kerberos Version 5 Specification 2 (5.2). Specification 1 (deprecated) may be found in RFC 1510.",
      "ja": "このセクションでは、これらのオプションの2番目の仕様を定義します。このように構成された実装は、Kerberosバージョン5仕様2（5.2）をサポートすると言われます。仕様1（非推奨）は、RFC 1510にあります。"
    },
    {
      "indent": 3,
      "text": "Transport",
      "ja": "輸送"
    },
    {
      "indent": 6,
      "text": "TCP/IP and UDP/IP transport MUST be supported by clients and KDCs claiming conformance to specification 2.",
      "ja": "TCP/IPおよびUDP/IPトランスポートは、仕様2への適合を主張するクライアントとKDCによってサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Encryption and Checksum Methods",
      "ja": "暗号化とチェックサムの方法"
    },
    {
      "indent": 6,
      "text": "The following encryption and checksum mechanisms MUST be supported:",
      "ja": "次の暗号化とチェックサムのメカニズムをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "Encryption: AES256-CTS-HMAC-SHA1-96 [RFC3962] Checksums: HMAC-SHA1-96-AES256 [RFC3962]",
      "ja": "暗号化：AES256-CTS-HMAC-SHA1-96 [RFC3962]チェックサム：HMAC-SHA1-96-AES256 [RFC3962]"
    },
    {
      "indent": 6,
      "text": "Implementations SHOULD support other mechanisms as well, but the additional mechanisms may only be used when communicating with principals known to also support them. The following mechanisms from [RFC3961] and [RFC3962] SHOULD be supported: Encryption: AES128-CTS-HMAC-SHA1-96, DES-CBC-MD5, DES3-CBC-SHA1-KD Checksums: DES-MD5, HMAC-SHA1-DES3-KD, HMAC-SHA1-96-AES128",
      "ja": "実装は他のメカニズムもサポートする必要がありますが、追加のメカニズムは、それらをサポートすることが知られているプリンシパルと通信する場合にのみ使用できます。[RFC3961]および[RFC3962]からの次のメカニズムをサポートする必要があります：暗号化：AES128-CTS-HMAC-SHA1-96、DES-CBC-MD5、DES3-CBC-SHA1-KDチェックサム：DES-MD5、HMAC-SHA1-DES3-KD、HMAC-SHA1-96-AES128"
    },
    {
      "indent": 6,
      "text": "Implementations MAY support other mechanisms as well, but the additional mechanisms may only be used when communicating with principals known to support them also.",
      "ja": "実装は他のメカニズムもサポートする場合がありますが、追加のメカニズムは、それらをサポートすることが知られているプリンシパルと通信する場合にのみ使用できます。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Earlier implementations of Kerberos generate messages using the CRC-32 and RSA-MD5 checksum methods. For interoperability with these earlier releases, implementors MAY consider supporting these checksum methods but should carefully analyze the security implications to limit the situations within which these methods are accepted.",
      "ja": "実装注：Kerberosの以前の実装は、CRC-32およびRSA-MD5チェックサムメソッドを使用してメッセージを生成します。これらの以前のリリースとの相互運用性のために、実装者はこれらのチェックサム方法のサポートを検討することができますが、これらの方法が受け入れられる状況を制限するためにセキュリティへの影響を慎重に分析する必要があります。"
    },
    {
      "indent": 3,
      "text": "Realm Names",
      "ja": "レルム名"
    },
    {
      "indent": 6,
      "text": "All implementations MUST understand hierarchical realms in both the Internet Domain and the X.500 style. When a TGT for an unknown realm is requested, the KDC MUST be able to determine the names of the intermediate realms between the KDCs realm and the requested realm.",
      "ja": "すべての実装は、インターネットドメインとX.500スタイルの両方で階層的な領域を理解する必要があります。未知の領域のTGTが要求される場合、KDCはKDCS領域と要求された領域の間の中間領域の名前を決定できる必要があります。"
    },
    {
      "indent": 3,
      "text": "Transited Field Encoding",
      "ja": "通過フィールドエンコーディング"
    },
    {
      "indent": 6,
      "text": "DOMAIN-X500-COMPRESS (described in Section 3.3.3.2) MUST be supported. Alternative encodings MAY be supported, but they may only be used when that encoding is supported by ALL intermediate realms.",
      "ja": "Domain-X500-Compress（セクション3.3.3.2で説明）をサポートする必要があります。代替エンコーディングはサポートされる場合がありますが、そのエンコードがすべての中間領域によってサポートされている場合にのみ使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "Pre-authentication Methods",
      "ja": "受容前の方法"
    },
    {
      "indent": 6,
      "text": "The TGS-REQ method MUST be supported. It is not used on the initial request. The PA-ENC-TIMESTAMP method MUST be supported by clients, but whether it is enabled by default MAY be determined on a realm-by-realm basis. If the method is not used in the initial request and the error KDC_ERR_PREAUTH_REQUIRED is returned specifying PA-ENC-TIMESTAMP as an acceptable method, the client SHOULD retry the initial request using the PA-ENC-TIMESTAMP pre-authentication method. Servers need not support the PA-ENC-TIMESTAMP method, but if it is not supported the server SHOULD ignore the presence of PA-ENC-TIMESTAMP pre-authentication in a request.",
      "ja": "TGS-REQメソッドをサポートする必要があります。最初のリクエストでは使用されません。PA-Ecc-Timestampメソッドはクライアントによってサポートする必要がありますが、デフォルトで有効になっているかどうかは、領域ごとに決定される場合があります。メソッドが初期リクエストで使用されず、エラーKDC_ERR_PREAUTH_REQUIREDがPA-ECN-TIMESTAMPを許容可能な方法として指定すると返される場合、クライアントはPA-ENC-TIMESTAMPの認証方法を使用して初期リクエストを再試行する必要があります。サーバーはPA-enc-Timestampメソッドをサポートする必要はありませんが、サポートされていない場合は、サーバーがリクエストでPA-Ecc-Timestampの事前認証の存在を無視する必要があります。"
    },
    {
      "indent": 6,
      "text": "The ETYPE-INFO2 method MUST be supported; this method is used to communicate the set of supported encryption types, and corresponding salt and string to key parameters. The ETYPE-INFO method SHOULD be supported for interoperability with older implementation.",
      "ja": "ETYPE-INFO2メソッドをサポートする必要があります。この方法は、サポートされている暗号化タイプのセットと、対応する塩と弦を重要なパラメーターと通信するために使用されます。ETYPE-INFOメソッドは、古い実装との相互運用性のためにサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Mutual Authentication",
      "ja": "相互認証"
    },
    {
      "indent": 6,
      "text": "Mutual authentication (via the KRB_AP_REP message) MUST be supported.",
      "ja": "相互認証（KRB_AP_REPメッセージを介して）をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Ticket Addresses and Flags",
      "ja": "チケットアドレスとフラグ"
    },
    {
      "indent": 6,
      "text": "All KDCs MUST pass through tickets that carry no addresses (i.e., if a TGT contains no addresses, the KDC will return derivative tickets). Implementations SHOULD default to requesting addressless tickets, as this significantly increases interoperability with network address translation. In some cases, realms or application servers MAY require that tickets have an address.",
      "ja": "すべてのKDCは、アドレスを持たないチケットを通過する必要があります（つまり、TGTにアドレスが含まれていない場合、KDCはデリバティブチケットを返します）。これにより、ネットワークアドレスの変換との相互運用性が大幅に向上するため、実装はデフォルトでアドレスレスチケットを要求する必要があります。場合によっては、レルムまたはアプリケーションサーバーには、チケットに住所があることが必要になる場合があります。"
    },
    {
      "indent": 6,
      "text": "Implementations SHOULD accept directional address type for the KRB_SAFE and KRB_PRIV message and SHOULD include directional addresses in these messages when other address types are not available.",
      "ja": "実装は、krb_safeおよびkrb_privメッセージの方向アドレスタイプを受け入れる必要があり、他のアドレスタイプが利用できない場合、これらのメッセージに方向アドレスを含める必要があります。"
    },
    {
      "indent": 6,
      "text": "Proxies and forwarded tickets MUST be supported. Individual realms and application servers can set their own policy on when such tickets will be accepted.",
      "ja": "プロキシと転送されたチケットをサポートする必要があります。個々のレルムとアプリケーションサーバーは、そのようなチケットがいつ受け入れられるかについて独自のポリシーを設定できます。"
    },
    {
      "indent": 6,
      "text": "All implementations MUST recognize renewable and postdated tickets, but they need not actually implement them. If these options are not supported, the starttime and endtime in the ticket SHALL specify a ticket's entire useful life. When a postdated ticket is decoded by a server, all implementations SHALL make the presence of the postdated flag visible to the calling server.",
      "ja": "すべての実装は、再生可能および郵便局のチケットを認識する必要がありますが、実際にそれらを実装する必要はありません。これらのオプションがサポートされていない場合、チケットの開始時刻と終了時間は、チケットの耐用年数全体を指定するものとします。ポストデートのチケットがサーバーによってデコードされた場合、すべての実装は、呼び出しサーバーに表示されるポストデートフラグの存在を行うものとします。"
    },
    {
      "indent": 3,
      "text": "User-to-User Authentication",
      "ja": "ユーザーからユーザーへの認証"
    },
    {
      "indent": 6,
      "text": "Support for user-to-user authentication (via the ENC-TKT-IN-SKEY KDC option) MUST be provided by implementations, but individual realms MAY decide as a matter of policy to reject such requests on a per-principal or realm-wide basis.",
      "ja": "ユーザーからユーザーへの認証のサポート（Enc-TKT-In-Skey KDCオプションを介して）は実装によって提供される必要がありますが、個々のレルムは、プリンシパルごとにそのような要求を拒否するためのポリシーの問題として決定する場合があります基本。"
    },
    {
      "indent": 3,
      "text": "Authorization Data",
      "ja": "許可データ"
    },
    {
      "indent": 6,
      "text": "Implementations MUST pass all authorization data subfields from TGTs to any derivative tickets unless they are directed to suppress a subfield as part of the definition of that registered subfield type. (It is never incorrect to pass on a subfield, and no registered subfield types presently specify suppression at the KDC.) Implementations MUST make the contents of any authorization data subfields available to the server when a ticket is used. Implementations are not required to allow clients to specify the contents of the authorization data fields.",
      "ja": "実装は、登録されたサブフィールドタイプの定義の一部としてサブフィールドを抑制するように指示されていない限り、すべての承認データサブフィールドをTGTSからデリバティブチケットに渡す必要があります。（サブフィールドを渡すことは決して間違っていませんし、登録されたサブフィールドタイプは現在KDCで抑制を指定していません。）実装は、チケットの使用時にサーバーが利用できる承認データサブフィールドのコンテンツを使用する必要があります。クライアントが認証データフィールドのコンテンツを指定できるようにするためには、実装は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Constant Ranges",
      "ja": "一定の範囲"
    },
    {
      "indent": 6,
      "text": "All protocol constants are constrained to 32-bit (signed) values unless further constrained by the protocol definition. This limit is provided to allow implementations to make assumptions about the maximum values that will be received for these constants. Implementations receiving values outside this range MAY reject the request, but they MUST recover cleanly.",
      "ja": "すべてのプロトコル定数は、プロトコル定義によってさらに制約されない限り、32ビット（署名）値に制約されます。この制限は、実装がこれらの定数で受信される最大値について仮定を行うことを可能にするために提供されます。この範囲外の値を受信する実装は、リクエストを拒否する可能性がありますが、きれいに回復する必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Recommended KDC Values",
      "section_title": true,
      "ja": "8.2. 推奨されるKDC値"
    },
    {
      "indent": 3,
      "text": "Following is a list of recommended values for a KDC configuration.",
      "ja": "以下は、KDC構成の推奨値のリストです。"
    },
    {
      "indent": 6,
      "text": "Minimum lifetime              5 minutes\nMaximum renewable lifetime    1 week\nMaximum ticket lifetime       1 day\nAcceptable clock skew         5 minutes\nEmpty addresses               Allowed\nProxiable, etc.               Allowed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 7 of this document specifies protocol constants and other defined values required for the interoperability of multiple implementations. Until a subsequent RFC specifies otherwise, or the Kerberos working group is shut down, allocations of additional protocol constants and other defined values required for extensions to the Kerberos protocol will be administered by the Kerberos working group. Following the recommendations outlined in [RFC2434], guidance is provided to the IANA as follows:",
      "ja": "このドキュメントのセクション7は、複数の実装の相互運用性に必要なプロトコル定数とその他の定義値を指定します。その後のRFCがそれ以外の場合、またはKerberosワーキンググループがシャットダウンされるまで、Kerberosプロトコルへの拡張に必要な追加のプロトコル定数およびその他の定義値の割り当てがKerberosワーキンググループによって管理されます。[RFC2434]で概説されている推奨事項に従って、次のようにIANAにガイダンスが提供されます。"
    },
    {
      "indent": 3,
      "text": "\"reserved\" realm name types in Section 6.1 and \"other\" realm types except those beginning with \"X-\" or \"x-\" will not be registered without IETF standards action, at which point guidelines for further assignment will be specified. Realm name types beginning with \"X-\" or \"x-\" are for private use.",
      "ja": "「x」または「x-」から始まるものを除くセクション6.1および「その他の」レルムタイプの「予約済み」レルム名のタイプは、IETF標準のアクションなしで登録されません。「x-」または「x-」で始まるレルム名のタイプは、私的使用のためのものです。"
    },
    {
      "indent": 3,
      "text": "For host address types described in Section 7.1, negative values are for private use. Assignment of additional positive numbers is subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.1で説明したホストアドレスタイプの場合、負の値はプライベートで使用されます。追加の正の数の割り当ては、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 3,
      "text": "Additional key usage numbers, as defined in Section 7.5.1, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.1で定義されている追加の主要な使用数は、Kerberos Working Groupまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 3,
      "text": "Additional preauthentication data type values, as defined in section 7.5.2, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.2で定義されている追加の事前認定データ型値は、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 3,
      "text": "Additional authorization data types as defined in Section 7.5.4, will be assigned subject to review by the Kerberos working group or other expert review. Although it is anticipated that there may be significant demand for private use types, provision is intentionally not made for a private use portion of the namespace because conflicts between privately assigned values could have detrimental security implications.",
      "ja": "セクション7.5.4で定義されている追加の承認データ型は、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。私的使用タイプには大きな需要がある可能性があると予想されていますが、個人的に割り当てられた値の間の競合が有害なセキュリティの意味を持つ可能性があるため、名前空間の私的使用部分に対して意図的に提供されていません。"
    },
    {
      "indent": 3,
      "text": "Additional transited encoding types, as defined in Section 7.5.5, present special concerns for interoperability with existing implementations. As such, such assignments will only be made by standards action, except that the Kerberos working group or another other working group with competent jurisdiction may make preliminary assignments for documents that are moving through the standards process.",
      "ja": "セクション7.5.5で定義されている追加の輸送エンコードタイプは、既存の実装との相互運用性に関する特別な懸念を提示します。そのため、そのような割り当ては、Kerberos Working Groupまたは有能な管轄権を持つ他の他のワーキンググループが、標準プロセスを進めている文書の予備的な割り当てを行うことを除いて、標準訴訟によってのみ行われます。"
    },
    {
      "indent": 3,
      "text": "Additional Kerberos message types, as described in Section 7.5.7, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.7で説明されているように、追加のKerberosメッセージタイプは、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 3,
      "text": "Additional name types, as described in Section 7.5.8, will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.8で説明されているように、追加の名前のタイプは、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 3,
      "text": "Additional error codes described in Section 7.5.9 will be assigned subject to review by the Kerberos working group or other expert review.",
      "ja": "セクション7.5.9で説明されている追加のエラーコードは、Kerberosワーキンググループまたはその他の専門家レビューによるレビューの対象となります。"
    },
    {
      "indent": 0,
      "text": "10. Security Considerations",
      "section_title": true,
      "ja": "10. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "As an authentication service, Kerberos provides a means of verifying the identity of principals on a network. By itself, Kerberos does not provide authorization. Applications should not accept the issuance of a service ticket by the Kerberos server as granting authority to use the service, since such applications may become vulnerable to the bypass of this authorization check in an environment where they inter-operate with other KDCs or where other options for application authentication are provided.",
      "ja": "認証サービスとして、Kerberosはネットワーク上のプリンシパルのIDを確認する手段を提供します。それ自体で、Kerberosは許可を提供していません。このようなアプリケーションは、他のKDCまたは他のオプションと相互操作する環境でのこの認可チェックのバイパスに対して脆弱になる可能性があるため、アプリケーションはサービスを使用するための権限を付与するためのkerberosサーバーによるサービスチケットの発行を受け入れるべきではありません。アプリケーションの認証が提供されます。"
    },
    {
      "indent": 3,
      "text": "Denial of service attacks are not solved with Kerberos. There are places in the protocols where an intruder can prevent an application from participating in the proper authentication steps. Because authentication is a required step for the use of many services, successful denial of service attacks on a Kerberos server might result in the denial of other network services that rely on Kerberos for authentication. Kerberos is vulnerable to many kinds of denial of service attacks: those on the network, which would prevent clients from contacting the KDC; those on the domain name system, which could prevent a client from finding the IP address of the Kerberos server; and those by overloading the Kerberos KDC itself with repeated requests.",
      "ja": "サービス拒否攻撃は、Kerberosで解決されません。プロトコルには、侵入者がアプリケーションが適切な認証手順に参加するのを防ぐことができる場所があります。認証は多くのサービスを使用するために必要なステップであるため、Kerberosサーバーでのサービス拒否攻撃の成功により、認証のためにKerberosに依存する他のネットワークサービスが拒否される可能性があります。Kerberosは、多くの種類のサービス攻撃に対して脆弱です。ネットワーク上の攻撃は、クライアントがKDCに連絡できないようにします。クライアントがKerberosサーバーのIPアドレスを見つけることを妨げる可能性のあるドメイン名システム上のそれら。そして、繰り返しリクエストでKerberos KDC自体を過負荷にすることにより。"
    },
    {
      "indent": 3,
      "text": "Interoperability conflicts caused by incompatible character-set usage (see 5.2.1) can result in denial of service for clients that utilize character-sets in Kerberos strings other than those stored in the KDC database.",
      "ja": "互換性のない文字セット使用（5.2.1を参照）によって引き起こされる相互運用性の競合は、KDCデータベースに保存されているもの以外のKerberos文字列の文字セットを利用するクライアントのサービス拒否をもたらす可能性があります。"
    },
    {
      "indent": 3,
      "text": "Authentication servers maintain a database of principals (i.e., users and servers) and their secret keys. The security of the authentication server machines is critical. The breach of security of an authentication server will compromise the security of all servers that rely upon the compromised KDC, and will compromise the authentication of any principals registered in the realm of the compromised KDC.",
      "ja": "認証サーバーは、プリンシパル（つまり、ユーザーとサーバー）とその秘密キーのデータベースを維持します。認証サーバーマシンのセキュリティが重要です。認証サーバーのセキュリティ違反は、侵害されたKDCに依存しているすべてのサーバーのセキュリティを損ない、侵害されたKDCの領域に登録されているプリンシパルの認証を侵害します。"
    },
    {
      "indent": 3,
      "text": "Principals must keep their secret keys secret. If an intruder somehow steals a principal's key, it will be able to masquerade as that principal or impersonate any server to the legitimate principal.",
      "ja": "校長は秘密の鍵を秘密にしなければなりません。侵入者がどういうわけかプリンシパルの鍵を盗むと、その校長を装ったり、正当なプリンシパルにサーバーになりすましたりすることができます。"
    },
    {
      "indent": 3,
      "text": "Password-guessing attacks are not solved by Kerberos. If a user chooses a poor password, it is possible for an attacker to successfully mount an off-line dictionary attack by repeatedly attempting to decrypt, with successive entries from a dictionary, messages obtained that are encrypted under a key derived from the user's password.",
      "ja": "パスワード推測攻撃は、Kerberosによって解決されません。ユーザーが悪いパスワードを選択した場合、攻撃者は、ユーザーのパスワードから派生したキーの下で暗号化された辞書からの連続したエントリ、辞書からの連続したエントリを使用して、繰り返し復号化しようとすることにより、オフラインの辞書攻撃を正常に取り付けることができます。"
    },
    {
      "indent": 3,
      "text": "Unless pre-authentication options are required by the policy of a realm, the KDC will not know whether a request for authentication succeeds. An attacker can request a reply with credentials for any principal. These credentials will likely not be of much use to the attacker unless it knows the client's secret key, but the availability of the response encrypted in the client's secret key provides the attacker with ciphertext that may be used to mount brute force or dictionary attacks to decrypt the credentials, by guessing the user's password. For this reason it is strongly encouraged that Kerberos realms require the use of pre-authentication. Even with pre-authentication, attackers may try brute force or dictionary attacks against credentials that are observed by eavesdropping on the network.",
      "ja": "領域のポリシーによって事前認証オプションが必要でない限り、KDCは認証の要求が成功するかどうかを知りません。攻撃者は、任意のプリンシパルの資格情報を含む返信を要求できます。これらの資格情報は、クライアントのシークレットキーを知っていない限り、攻撃者にはあまり役に立たないでしょうが、クライアントのシークレットキーで暗号化された応答の可用性は、ブルートフォースまたは辞書攻撃をデコリプトにマウントするために使用できる暗号文を攻撃者に提供します。ユーザーのパスワードを推測することにより、資格情報。このため、Kerberos Realmsには事前認証の使用が必要であることが強く奨励されています。攻撃者は、事前に認識していても、ネットワーク上で盗聴することで観察される資格情報に対するブルートフォースまたは辞書攻撃を試みることができます。"
    },
    {
      "indent": 3,
      "text": "Because a client can request a ticket for any server principal and can attempt a brute force or dictionary attack against the server principal's key using that ticket, it is strongly encouraged that keys be randomly generated (rather than generated from passwords) for any principals that are usable as the target principal for a KRB_TGS_REQ or KRB_AS_REQ messages. [RFC4086]",
      "ja": "クライアントは、任意のサーバープリンシパルのチケットを要求し、そのチケットを使用してサーバープリンシパルのキーに対するブルートフォースまたは辞書攻撃を試みることができるため、キーは（パスワードから生成されるのではなく）ランダムに生成されることを強くお勧めしますkrb_tgs_reqまたはkrb_as_reqメッセージのターゲットプリンシパルとして使用できます。[RFC4086]"
    },
    {
      "indent": 3,
      "text": "Although the DES-CBC-MD5 encryption method and DES-MD5 checksum methods are listed as SHOULD be implemented for backward compatibility, the single DES encryption algorithm on which these are based is weak, and stronger algorithms should be used whenever possible.",
      "ja": "DES-CBC-MD5暗号化法とDES-MD5チェックサムメソッドは、後方互換性のために実装する必要があるようにリストされていますが、これらのベースの単一の暗号化アルゴリズムは弱く、可能な限りより強力なアルゴリズムを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each host on the network must have a clock that is loosely synchronized to the time of the other hosts; this synchronization is used to reduce the bookkeeping needs of application servers when they do replay detection. The degree of \"looseness\" can be configured on a per-server basis, but it is typically on the order of 5 minutes. If the clocks are synchronized over the network, the clock synchronization protocol MUST itself be secured from network attackers.",
      "ja": "ネットワーク上の各ホストには、他のホストの時間に大まかに同期されるクロックが必要です。この同期は、リプレイ検出を行うときにアプリケーションサーバーの簿記ニーズを減らすために使用されます。「ゆるみ」の程度は、サーバーごとに構成できますが、通常は5分程度です。クロックがネットワークを介して同期されている場合、クロック同期プロトコル自体はネットワーク攻撃者から保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Principal identifiers must not recycled on a short-term basis. A typical mode of access control will use access control lists (ACLs) to grant permissions to particular principals. If a stale ACL entry remains for a deleted principal and the principal identifier is reused, the new principal will inherit rights specified in the stale ACL entry. By not reusing principal identifiers, the danger of inadvertent access is removed.",
      "ja": "主要な識別子は、短期的にリサイクルしてはなりません。典型的なアクセス制御モードは、アクセス制御リスト（ACL）を使用して、特定のプリンシパルに許可を付与します。削除されたプリンシパルの古いACLエントリが残り、プリンシパル識別子が再利用される場合、新しいプリンシパルは古いACLエントリで指定された権利を継承します。元本の識別子を再利用しないことにより、不注意なアクセスの危険が削除されます。"
    },
    {
      "indent": 3,
      "text": "Proper decryption of an KRB_AS_REP message from the KDC is not sufficient for the host to verify the identity of the user; the user and an attacker could cooperate to generate a KRB_AS_REP format message that decrypts properly but is not from the proper KDC. To authenticate a user logging on to a local system, the credentials obtained in the AS exchange may first be used in a TGS exchange to obtain credentials for a local server. Those credentials must then be verified by a local server through successful completion of the Client/Server exchange.",
      "ja": "KDCからのKRB_AS_REPメッセージの適切な復号化では、ホストがユーザーのIDを確認するには十分ではありません。ユーザーと攻撃者は協力して、適切に復号化するが適切なKDCからではないKRB_AS_REP形式のメッセージを生成することができます。ローカルシステムにログオンするユーザーを認証するために、AS Exchangeで取得した資格情報を最初にTGS Exchangeで使用して、ローカルサーバーの資格情報を取得できます。これらの資格情報は、クライアント/サーバー交換が正常に完了することにより、ローカルサーバーによって検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "Many RFC 1510-compliant implementations ignore unknown authorization data elements. Depending on these implementations to honor authorization data restrictions may create a security weakness.",
      "ja": "多くのRFC 1510準拠の実装は、未知の承認データ要素を無視します。認可データの制限を尊重するためのこれらの実装に応じて、セキュリティの弱点が生じる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Kerberos credentials contain clear-text information identifying the principals to which they apply. If privacy of this information is needed, this exchange should itself be encapsulated in a protocol providing for confidentiality on the exchange of these credentials.",
      "ja": "Kerberosの資格情報には、適用されるプリンシパルを識別する明確なテキスト情報が含まれています。この情報のプライバシーが必要な場合、この交換自体は、これらの資格情報の交換に関する機密性を提供するプロトコルにカプセル化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications must take care to protect communications subsequent to authentication, either by using the KRB_PRIV or KRB_SAFE messages as appropriate, or by applying their own confidentiality or integrity mechanisms on such communications. Completion of the KRB_AP_REQ and KRB_AP_REP exchange without subsequent use of confidentiality and integrity mechanisms provides only for authentication of the parties to the communication and not confidentiality and integrity of the subsequent communication. Applications applying confidentiality and integrity protection mechanisms other than KRB_PRIV and KRB_SAFE must make sure that the authentication step is appropriately linked with the protected communication channel that is established by the application.",
      "ja": "アプリケーションは、krb_privまたはkrb_safeメッセージを必要に応じて、またはそのような通信に独自の機密性または整合性メカニズムを適用することにより、認証に続いて通信を保護するように注意する必要があります。KRB_AP_REQおよびKRB_AP_REP Exchangeの完了は、その後の機密性と整合性メカニズムを使用せずに、コミュニケーションに対する当事者の認証のみを提供し、その後のコミュニケーションの機密性と整合性ではありません。krb_privおよびkrb_safe以外の機密性と整合性保護メカニズムを適用するアプリケーションは、認証ステップがアプリケーションによって確立された保護された通信チャネルと適切にリンクされていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "Unless the application server provides its own suitable means to protect against replay (for example, a challenge-response sequence initiated by the server after authentication, or use of a server-generated encryption subkey), the server must utilize a replay cache to remember any authenticator presented within the allowable clock skew. All services sharing a key need to use the same replay cache. If separate replay caches are used, then an authenticator used with one such service could later be replayed to a different service with the same service principal.",
      "ja": "アプリケーションサーバーがリプレイから保護するための独自の適切な手段を提供しない限り（たとえば、認証後にサーバーによって開始されたチャレンジ応答シーケンス、またはサーバー生成暗号化サブキーの使用）、サーバーはリプレイキャッシュを使用して任意のリプレイを使用する必要があります許容時計スキュー内で提示された認証器。重要なサービスを共有するすべてのサービスは、同じリプレイキャッシュを使用する必要があります。個別のリプレイキャッシュを使用すると、そのようなサービスの1つで使用される認証器を後で同じサービスプリンシパルを持つ別のサービスに再生できます。"
    },
    {
      "indent": 3,
      "text": "If a server loses track of authenticators presented within the allowable clock skew, it must reject all requests until the clock skew interval has passed, providing assurance that any lost or replayed authenticators will fall outside the allowable clock skew and can no longer be successfully replayed.",
      "ja": "サーバーが許容時計スキュー内で提示された認証器のトラックを失った場合、クロックスキュー間隔が通過するまですべての要求を拒否する必要があり、失われたまたは再生された認証者は許容時計のゆがみの外に落ち、再生されることができなくなることを保証します。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos should not use untrusted directory servers to determine the realm of a host. To allow this would allow the compromise of the directory server to enable an attacker to direct the client to accept authentication with the wrong principal (i.e., one with a similar name, but in a realm with which the legitimate host was not registered).",
      "ja": "Kerberosの実装は、信頼できないディレクトリサーバーを使用してホストの領域を決定すべきではありません。これを許可すると、ディレクトリサーバーの妥協が攻撃者に間違ったプリンシパル（つまり、同様の名前のあるものがありますが、正当なホストが登録されていない領域）で認証をクライアントに受け入れるよう指示できるようになります。"
    },
    {
      "indent": 3,
      "text": "Implementations of Kerberos must not use DNS to map one name to another (canonicalize) in order to determine the host part of the principal name with which one is to communicate. To allow this canonicalization would allow a compromise of the DNS to result in a client obtaining credentials and correctly authenticating to the wrong principal. Though the client will know who it is communicating with, it will not be the principal with which it intended to communicate.",
      "ja": "Kerberosの実装は、DNSを使用して1つの名前を別の名前（CanOnicalize）にマッピングしてはいけません。この標準化を許可すると、DNSの妥協が可能になり、クライアントが資格情報を取得し、間違ったプリンシパルに正しく認証することができます。クライアントは誰と通信しているかを知るでしょうが、それが通信することを意図した校長ではありません。"
    },
    {
      "indent": 3,
      "text": "If the Kerberos server returns a TGT for a realm 'closer' than the desired realm, the client may use local policy configuration to verify that the authentication path used is an acceptable one. Alternatively, a client may choose its own authentication path rather than rely on the Kerberos server to select one. In either case, any policy or configuration information used to choose or validate authentication paths, whether by the Kerberos server or client, must be obtained from a trusted source.",
      "ja": "Kerberosサーバーが目的の領域よりも「近い」領域のTGTを返す場合、クライアントはローカルポリシー構成を使用して、使用される認証パスが許容可能なパスであることを確認できます。または、クライアントは、Kerberosサーバーに依存して選択するのではなく、独自の認証パスを選択する場合があります。どちらの場合でも、認証パスを選択または検証するために使用されるポリシーまたは構成情報は、Kerberosサーバーであろうとクライアントであろうと、信頼できるソースから取得する必要があります。"
    },
    {
      "indent": 3,
      "text": "The Kerberos protocol in its basic form does not provide perfect forward secrecy for communications. If traffic has been recorded by an eavesdropper, then messages encrypted using the KRB_PRIV message, or messages encrypted using application-specific encryption under keys exchanged using Kerberos can be decrypted if the user's, application server's, or KDC's key is subsequently discovered. This is because the session key used to encrypt such messages, when transmitted over the network, is encrypted in the key of the application server. It is also encrypted under the session key from the user's TGT when it is returned to the user in the KRB_TGS_REP message. The session key from the TGT is sent to the user in the KRB_AS_REP message encrypted in the user's secret key and embedded in the TGT, which was encrypted in the key of the KDC. Applications requiring perfect forward secrecy must exchange keys through mechanisms that provide such assurance, but may use Kerberos for authentication of the encrypted channel established through such other means.",
      "ja": "基本的な形式のKerberosプロトコルは、コミュニケーションに完全な前進秘密を提供しません。トラフィックが盗聴者によって記録されている場合、krb_privメッセージを使用して暗号化されたメッセージ、またはユーザー、アプリケーションサーバー、またはKDCのキーがその後発見された場合、Kerberosを使用して交換されたキーの下でアプリケーション固有の暗号化を使用して暗号化されたメッセージが発見されます。これは、ネットワークを介して送信されたときにそのようなメッセージを暗号化するために使用されるセッションキーがアプリケーションサーバーのキーで暗号化されているためです。また、krb_tgs_repメッセージでユーザーに返される場合、ユーザーのTGTのセッションキーの下で暗号化されます。TGTのセッションキーは、ユーザーのシークレットキーに暗号化され、KDCのキーに暗号化されたTGTに埋め込まれたKRB_AS_REPメッセージのユーザーに送信されます。完全なフォワードの秘密を必要とするアプリケーションは、そのような保証を提供するメカニズムを通じてキーを交換する必要がありますが、そのような他の手段を通じて確立された暗号化されたチャネルの認証にKerberosを使用する場合があります。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a revision to RFC 1510 which was co-authored with John Kohl. The specification of the Kerberos protocol described in this document is the result of many years of effort. Over this period, many individuals have contributed to the definition of the protocol and to the writing of the specification. Unfortunately, it is not possible to list all contributors as authors of this document, though there are many not listed who are authors in spirit, including those who contributed text for parts of some sections, who contributed to the design of parts of the protocol, and who contributed significantly to the discussion of the protocol in the IETF common authentication technology (CAT) and Kerberos working groups.",
      "ja": "このドキュメントは、John Kohlと共著したRFC 1510の改訂です。このドキュメントで説明されているKerberosプロトコルの仕様は、長年の努力の結果です。この期間中、多くの個人がプロトコルの定義と仕様の執筆に貢献してきました。残念ながら、すべての貢献者をこのドキュメントの著者としてリストすることはできませんが、一部のセクションの一部にテキストを貢献した人、プロトコルの一部のデザインに貢献した人を含め、精神の著者である人がリストされていない人がいます。そして、IETF Common Authentication Technology（CAT）およびKerberosワーキンググループのプロトコルの議論に大きく貢献した人。"
    },
    {
      "indent": 3,
      "text": "Among those contributing to the development and specification of Kerberos were Jeffrey Altman, John Brezak, Marc Colan, Johan Danielsson, Don Davis, Doug Engert, Dan Geer, Paul Hill, John Kohl, Marc Horowitz, Matt Hur, Jeffrey Hutzelman, Paul Leach, John Linn, Ari Medvinsky, Sasha Medvinsky, Steve Miller, Jon Rochlis, Jerome Saltzer, Jeffrey Schiller, Jennifer Steiner, Ralph Swick, Mike Swift, Jonathan Trostle, Theodore Ts'o, Brian Tung, Jacques Vidrine, Assar Westerlund, and Nicolas Williams. Many other members of MIT Project Athena, the MIT networking group, and the Kerberos and CAT working groups of the IETF contributed but are not listed.",
      "ja": "Kerberosの開発と仕様に貢献している人々の中には、Jeffrey Altman、John Brezak、Marc Colan、Johan Danielsson、Don Davis、Doug Engert、Dan Geer、Paul Hill、John Kohl、Marc Horowitz、Matt HuR、Jeffrey Hutzelman、Paul Leach、ジョン・リン、アリ・メドヴィンスキー、サーシャ・メドヴィンスキー、スティーブ・ミラー、ジョン・ロクリス、ジェローム・サルツァー、ジェフリー・シラー、ジェニファー・シュタイナー、ラルフ・スウィック、マイク・スウィフト、ジョナサン・トロストル、セオドア・トゥー、ブライアン・トゥン、ジャック・ヴィドリン、アッサル・ウェスタルランド、アッサル・ウェスタルランド、アッサル・ウェスタルランド、。MIT Project Athena、MIT Networking Group、およびIETFのKerberosと猫のワーキンググループの他の多くのメンバーは、貢献していますが、リストされていません。"
    },
    {
      "indent": 0,
      "text": "A. ASN.1 module",
      "ja": "A. ASN.1モジュール"
    },
    {
      "indent": 0,
      "text": "KerberosV5Spec2 {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2) modules(4) krb5spec2(2)\n} DEFINITIONS EXPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- OID arc for KerberosV5\n--\n-- This OID may be used to identify Kerberos protocol messages\n-- encapsulated in other protocols.\n--\n-- This OID also designates the OID arc for KerberosV5-related OIDs.\n--\n-- NOTE: RFC 1510 had an incorrect value (5) for \"dod\" in its OID.\nid-krb5         OBJECT IDENTIFIER ::= {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Int32           ::= INTEGER (-2147483648..2147483647)\n                    -- signed values representable in 32 bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "UInt32          ::= INTEGER (0..4294967295)\n                    -- unsigned 32 bit values",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Microseconds    ::= INTEGER (0..999999)\n                    -- microseconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosString  ::= GeneralString (IA5String)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Realm           ::= KerberosString",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PrincipalName   ::= SEQUENCE {\n        name-type       [0] Int32,\n        name-string     [1] SEQUENCE OF KerberosString\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosTime    ::= GeneralizedTime -- with no fractional seconds",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "HostAddress     ::= SEQUENCE  {\n        addr-type       [0] Int32,\n        address         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- NOTE: HostAddresses is always used as an OPTIONAL field and\n-- should not be empty.\nHostAddresses   -- NOTE: subtly different from rfc1510,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "        -- but has a value mapping and encodes the same\n::= SEQUENCE OF HostAddress",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- NOTE: AuthorizationData is always used as an OPTIONAL field and\n-- should not be empty.\nAuthorizationData       ::= SEQUENCE OF SEQUENCE {\n        ad-type         [0] Int32,\n        ad-data         [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PA-DATA         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        padata-type     [1] Int32,\n        padata-value    [2] OCTET STRING -- might be encoded AP-REQ\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KerberosFlags   ::= BIT STRING (SIZE (32..MAX))\n                    -- minimum number of bits shall be sent,\n                    -- but no fewer than 32",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncryptedData   ::= SEQUENCE {\n        etype   [0] Int32 -- EncryptionType --,\n        kvno    [1] UInt32 OPTIONAL,\n        cipher  [2] OCTET STRING -- ciphertext\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncryptionKey   ::= SEQUENCE {\n        keytype         [0] Int32 -- actually encryption type --,\n        keyvalue        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Checksum        ::= SEQUENCE {\n        cksumtype       [0] Int32,\n        checksum        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Ticket          ::= [APPLICATION 1] SEQUENCE {\n        tkt-vno         [0] INTEGER (5),\n        realm           [1] Realm,\n        sname           [2] PrincipalName,\n        enc-part        [3] EncryptedData -- EncTicketPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- Encrypted part of ticket\nEncTicketPart   ::= [APPLICATION 3] SEQUENCE {\n        flags                   [0] TicketFlags,\n        key                     [1] EncryptionKey,\n        crealm                  [2] Realm,\n        cname                   [3] PrincipalName,\n        transited               [4] TransitedEncoding,\n        authtime                [5] KerberosTime,\n        starttime               [6] KerberosTime OPTIONAL,\n        endtime                 [7] KerberosTime,\n        renew-till              [8] KerberosTime OPTIONAL,\n        caddr                   [9] HostAddresses OPTIONAL,\n        authorization-data      [10] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- encoded Transited field\nTransitedEncoding       ::= SEQUENCE {\n        tr-type         [0] Int32 -- must be registered --,\n        contents        [1] OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TicketFlags     ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- may-postdate(5),\n        -- postdated(6),\n        -- invalid(7),\n        -- renewable(8),\n        -- initial(9),\n        -- pre-authent(10),\n        -- hw-authent(11),\n-- the following are new since 1510\n        -- transited-policy-checked(12),\n        -- ok-as-delegate(13)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AS-REQ          ::= [APPLICATION 10] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REQ         ::= [APPLICATION 12] KDC-REQ",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ         ::= SEQUENCE {\n        -- NOTE: first tag is [1], not [0]\n        pvno            [1] INTEGER (5) ,\n        msg-type        [2] INTEGER (10 -- AS -- | 12 -- TGS --),\n        padata          [3] SEQUENCE OF PA-DATA OPTIONAL\n                            -- NOTE: not empty --,\n        req-body        [4] KDC-REQ-BODY\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDC-REQ-BODY    ::= SEQUENCE {\n        kdc-options             [0] KDCOptions,\n        cname                   [1] PrincipalName OPTIONAL\n                                    -- Used only in AS-REQ --,\n        realm                   [2] Realm\n                                    -- Server's realm\n                                    -- Also client's in AS-REQ --,\n        sname                   [3] PrincipalName OPTIONAL,\n        from                    [4] KerberosTime OPTIONAL,\n        till                    [5] KerberosTime,\n        rtime                   [6] KerberosTime OPTIONAL,\n        nonce                   [7] UInt32,\n        etype                   [8] SEQUENCE OF Int32 -- EncryptionType\n                                    -- in preference order --,\n        addresses               [9] HostAddresses OPTIONAL,\n        enc-authorization-data  [10] EncryptedData OPTIONAL\n                                    -- AuthorizationData --,\n        additional-tickets      [11] SEQUENCE OF Ticket OPTIONAL\n                                        -- NOTE: not empty\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KDCOptions      ::= KerberosFlags\n        -- reserved(0),\n        -- forwardable(1),\n        -- forwarded(2),\n        -- proxiable(3),\n        -- proxy(4),\n        -- allow-postdate(5),\n        -- postdated(6),\n        -- unused7(7),\n        -- renewable(8),\n        -- unused9(9),\n        -- unused10(10),\n        -- opt-hardware-auth(11),\n        -- unused12(12),\n        -- unused13(13),\n-- 15 is reserved for canonicalize\n        -- unused15(15),\n-- 26 was unused in 1510\n        -- disable-transited-check(26),\n--\n        -- renewable-ok(27),\n        -- enc-tkt-in-skey(28),\n        -- renew(30),\n        -- validate(31)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AS-REP          ::= [APPLICATION 11] KDC-REP",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TGS-REP         ::= [APPLICATION 13] KDC-REP\nKDC-REP         ::= SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (11 -- AS -- | 13 -- TGS --),\n        padata          [2] SEQUENCE OF PA-DATA OPTIONAL\n                                -- NOTE: not empty --,\n        crealm          [3] Realm,\n        cname           [4] PrincipalName,\n        ticket          [5] Ticket,\n        enc-part        [6] EncryptedData\n                                -- EncASRepPart or EncTGSRepPart,\n                                -- as appropriate\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncASRepPart    ::= [APPLICATION 25] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncTGSRepPart   ::= [APPLICATION 26] EncKDCRepPart",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncKDCRepPart   ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        last-req        [1] LastReq,\n        nonce           [2] UInt32,\n        key-expiration  [3] KerberosTime OPTIONAL,\n        flags           [4] TicketFlags,\n        authtime        [5] KerberosTime,\n        starttime       [6] KerberosTime OPTIONAL,\n        endtime         [7] KerberosTime,\n        renew-till      [8] KerberosTime OPTIONAL,\n        srealm          [9] Realm,\n        sname           [10] PrincipalName,\n        caddr           [11] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "LastReq         ::=     SEQUENCE OF SEQUENCE {\n        lr-type         [0] Int32,\n        lr-value        [1] KerberosTime\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AP-REQ          ::= [APPLICATION 14] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (14),\n        ap-options      [2] APOptions,\n        ticket          [3] Ticket,\n        authenticator   [4] EncryptedData -- Authenticator\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "APOptions       ::= KerberosFlags\n        -- reserved(0),\n        -- use-session-key(1),",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "-- mutual-required(2)",
      "ja": " - 相互参照（2）"
    },
    {
      "indent": 0,
      "text": "-- Unencrypted authenticator\nAuthenticator   ::= [APPLICATION 2] SEQUENCE  {\n        authenticator-vno       [0] INTEGER (5),\n        crealm                  [1] Realm,\n        cname                   [2] PrincipalName,\n        cksum                   [3] Checksum OPTIONAL,\n        cusec                   [4] Microseconds,\n        ctime                   [5] KerberosTime,\n        subkey                  [6] EncryptionKey OPTIONAL,\n        seq-number              [7] UInt32 OPTIONAL,\n        authorization-data      [8] AuthorizationData OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AP-REP          ::= [APPLICATION 15] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (15),\n        enc-part        [2] EncryptedData -- EncAPRepPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncAPRepPart    ::= [APPLICATION 27] SEQUENCE {\n        ctime           [0] KerberosTime,\n        cusec           [1] Microseconds,\n        subkey          [2] EncryptionKey OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-SAFE        ::= [APPLICATION 20] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (20),\n        safe-body       [2] KRB-SAFE-BODY,\n        cksum           [3] Checksum\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-SAFE-BODY   ::= SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-PRIV        ::= [APPLICATION 21] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (21),\n                        -- NOTE: there is no [2] tag",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " enc-part [3] EncryptedData -- EncKrbPrivPart }",
      "ja": "enc-part [3] necrypteddata-enckrbprivpart}"
    },
    {
      "indent": 0,
      "text": "EncKrbPrivPart  ::= [APPLICATION 28] SEQUENCE {\n        user-data       [0] OCTET STRING,\n        timestamp       [1] KerberosTime OPTIONAL,\n        usec            [2] Microseconds OPTIONAL,\n        seq-number      [3] UInt32 OPTIONAL,\n        s-address       [4] HostAddress -- sender's addr --,\n        r-address       [5] HostAddress OPTIONAL -- recip's addr\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-CRED        ::= [APPLICATION 22] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (22),\n        tickets         [2] SEQUENCE OF Ticket,\n        enc-part        [3] EncryptedData -- EncKrbCredPart\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "EncKrbCredPart  ::= [APPLICATION 29] SEQUENCE {\n        ticket-info     [0] SEQUENCE OF KrbCredInfo,\n        nonce           [1] UInt32 OPTIONAL,\n        timestamp       [2] KerberosTime OPTIONAL,\n        usec            [3] Microseconds OPTIONAL,\n        s-address       [4] HostAddress OPTIONAL,\n        r-address       [5] HostAddress OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KrbCredInfo     ::= SEQUENCE {\n        key             [0] EncryptionKey,\n        prealm          [1] Realm OPTIONAL,\n        pname           [2] PrincipalName OPTIONAL,\n        flags           [3] TicketFlags OPTIONAL,\n        authtime        [4] KerberosTime OPTIONAL,\n        starttime       [5] KerberosTime OPTIONAL,\n        endtime         [6] KerberosTime OPTIONAL,\n        renew-till      [7] KerberosTime OPTIONAL,\n        srealm          [8] Realm OPTIONAL,\n        sname           [9] PrincipalName OPTIONAL,\n        caddr           [10] HostAddresses OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "KRB-ERROR       ::= [APPLICATION 30] SEQUENCE {\n        pvno            [0] INTEGER (5),\n        msg-type        [1] INTEGER (30),\n        ctime           [2] KerberosTime OPTIONAL,\n        cusec           [3] Microseconds OPTIONAL,\n        stime           [4] KerberosTime,\n        susec           [5] Microseconds,\n        error-code      [6] Int32,\n        crealm          [7] Realm OPTIONAL,\n        cname           [8] PrincipalName OPTIONAL,\n        realm           [9] Realm -- service realm --,\n        sname           [10] PrincipalName -- service name --,\n        e-text          [11] KerberosString OPTIONAL,\n        e-data          [12] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "METHOD-DATA     ::= SEQUENCE OF PA-DATA",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "TYPED-DATA      ::= SEQUENCE SIZE (1..MAX) OF SEQUENCE {\n        data-type       [0] Int32,\n        data-value      [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "-- preauth stuff follows",
      "ja": "-Preauthのものが続きます"
    },
    {
      "indent": 0,
      "text": "PA-ENC-TIMESTAMP        ::= EncryptedData -- PA-ENC-TS-ENC",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "PA-ENC-TS-ENC           ::= SEQUENCE {\n        patimestamp     [0] KerberosTime -- client's time --,\n        pausec          [1] Microseconds OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO-ENTRY        ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO              ::= SEQUENCE OF ETYPE-INFO-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2-ENTRY       ::= SEQUENCE {\n        etype           [0] Int32,\n        salt            [1] KerberosString OPTIONAL,\n        s2kparams       [2] OCTET STRING OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "ETYPE-INFO2             ::= SEQUENCE SIZE (1..MAX) OF ETYPE-INFO2-ENTRY",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-IF-RELEVANT          ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-KDCIssued            ::= SEQUENCE {\n        ad-checksum     [0] Checksum,\n        i-realm         [1] Realm OPTIONAL,\n        i-sname         [2] PrincipalName OPTIONAL,\n        elements        [3] AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "AD-AND-OR               ::= SEQUENCE {\n        condition-count [0] Int32,\n        elements        [1] AuthorizationData\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "AD-MANDATORY-FOR-KDC    ::= AuthorizationData",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "END",
      "ja": "終わり"
    },
    {
      "indent": 0,
      "text": "B. Changes since RFC 1510",
      "ja": "B. RFC 1510以降の変更"
    },
    {
      "indent": 3,
      "text": "This document replaces RFC 1510 and clarifies specification of items that were not completely specified. Where changes to recommended implementation choices were made, or where new options were added, those changes are described within the document and listed in this section. More significantly, \"Specification 2\" in Section 8 changes the required encryption and checksum methods to bring them in line with the best current practices and to deprecate methods that are no longer considered sufficiently strong.",
      "ja": "このドキュメントは、RFC 1510に取って代わり、完全に指定されていないアイテムの仕様を明確にします。推奨される実装の選択肢の変更が行われた場合、または新しいオプションが追加された場合、これらの変更はドキュメント内で説明され、このセクションにリストされています。さらに重要なことに、セクション8の「仕様2」は、必要な暗号化とチェックサムの方法を変更して、最良の現在のプラクティスに沿ったものと、もはや十分に強力であると見なされなくなった方法を非難します。"
    },
    {
      "indent": 3,
      "text": "Discussion was added to Section 1 regarding the ability to rely on the KDC to check the transited field, and on the inclusion of a flag in a ticket indicating that this check has occurred. This is a new capability not present in RFC 1510. Pre-existing implementations may ignore or not set this flag without negative security implications.",
      "ja": "KDCに依存して通過フィールドをチェックする能力、およびこのチェックが発生したことを示すチケットにフラグを含める能力について、セクション1に説明が追加されました。これは、RFC 1510には存在しない新しい機能です。既存の実装は、セキュリティの意味を否定することなくこのフラグを無視するか、設定しない場合があります。"
    },
    {
      "indent": 3,
      "text": "The definition of the secret key says that in the case of a user the key may be derived from a password. In RFC 1510, it said that the key was derived from the password. This change was made to accommodate situations where the user key might be stored on a smart-card, or otherwise obtained independently of a password.",
      "ja": "Secret Keyの定義には、ユーザーの場合、キーはパスワードから導き出される可能性があると述べています。RFC 1510では、キーはパスワードから派生したと述べました。この変更は、ユーザーキーがスマートカードに保存される可能性がある状況に対応するか、パスワードとは独立して取得される状況に対応するために行われました。"
    },
    {
      "indent": 3,
      "text": "The introduction mentions the use of public key cryptography for initial authentication in Kerberos by reference. RFC 1510 did not include such a reference.",
      "ja": "はじめには、参照によりKerberosでの初期認証のための公開キー暗号化の使用について言及しています。RFC 1510にはそのような参照は含まれていませんでした。"
    },
    {
      "indent": 3,
      "text": "Section 1.3 was added to explain that while Kerberos provides authentication of a named principal, it is still the responsibility of the application to ensure that the authenticated name is the entity with which the application wishes to communicate.",
      "ja": "セクション1.3は、Kerberosが指定されたプリンシパルの認証を提供する一方で、認証された名前がアプリケーションが通信したいエンティティであることを確認することは依然としてアプリケーションの責任であることを説明するために追加されました。"
    },
    {
      "indent": 3,
      "text": "Discussion of extensibility has been added to the introduction.",
      "ja": "拡張性の議論が導入に追加されました。"
    },
    {
      "indent": 3,
      "text": "Discussion of how extensibility affects ticket flags and KDC options was added to the introduction of Section 2. No changes were made to existing options and flags specified in RFC 1510, though some of the sections in the specification were renumbered, and text was revised to make the description and intent of existing options clearer, especially with respect to the ENC-TKT-IN-SKEY option (now section 2.9.2) which is used for user-to-user authentication. The new option and ticket flag transited policy checking (Section 2.7) was added.",
      "ja": "拡張性がチケットフラグとKDCオプションにどのように影響するかについての議論セクション2の導入に追加されました。RFC1510で指定された既存のオプションとフラグに変更は行われませんでしたが、仕様のセクションの一部は変更され、テキストは改訂されました。既存のオプションの説明と意図は、特にユーザーからユーザーへの認証に使用されるEnc-TKT-in-Skeyオプション（現在のセクション2.9.2）に関してより明確です。新しいオプションとチケットフラグの通過ポリシーチェック（セクション2.7）が追加されました。"
    },
    {
      "indent": 3,
      "text": "A warning regarding generation of session keys for application use was added to Section 3, urging the inclusion of key entropy from the KDC generated session key in the ticket. An example regarding use of the sub-session key was added to Section 3.2.6. Descriptions of the pa-etype-info, pa-etype-info2, and pa-pw-salt pre-authentication data items were added. The recommendation for use of pre-authentication was changed from \"MAY\" to \"SHOULD\" and a note was added regarding known plaintext attacks.",
      "ja": "アプリケーション使用のためのセッションキーの生成に関する警告がセクション3に追加され、チケットのKDC生成セッションキーからキーエントロピーを含めることが促されました。サブセッションキーの使用に関する例をセクション3.2.6に追加しました。PA-ETYPE-INFO、PA-ETYPE-INFO2、およびPA-PW-SALTの前認証データ項目の説明が追加されました。免除前の使用に関する推奨事項は「5月」から「sufe」に変更され、既知のプレーンテキスト攻撃に関してメモが追加されました。"
    },
    {
      "indent": 3,
      "text": "In RFC 1510, Section 4 described the database in the KDC. This discussion was not necessary for interoperability and unnecessarily constrained implementation. The old Section 4 was removed.",
      "ja": "RFC 1510では、セクション4がKDCのデータベースについて説明しました。この議論は、相互運用性と不必要に制約された実装には必要ありませんでした。古いセクション4が削除されました。"
    },
    {
      "indent": 3,
      "text": "The current Section 4 was formerly Section 6 on encryption and checksum specifications. The major part of this section was brought up to date to support new encryption methods, and moved to a separate document. Those few remaining aspects of the encryption and checksum specification specific to Kerberos are now specified in Section 4.",
      "ja": "現在のセクション4は、暗号化とチェックサムの仕様に関する以前はセクション6でした。このセクションの大部分は、新しい暗号化方法をサポートするために最新の状態になり、別のドキュメントに移動しました。Kerberosに固有の暗号化とチェックサムの仕様の残りの部分は、セクション4で指定されています。"
    },
    {
      "indent": 3,
      "text": "Significant changes were made to the layout of Section 5 to clarify the correct behavior for optional fields. Many of these changes were made necessary because of improper ASN.1 description in the original Kerberos specification which left the correct behavior underspecified. Additionally, the wording in this section was tightened wherever possible to ensure that implementations conforming to this specification will be extensible with the addition of new fields in future specifications.",
      "ja": "オプションのフィールドの正しい動作を明確にするために、セクション5のレイアウトに大きな変更が加えられました。これらの変更の多くは、正しい動作を不十分なままにした元のKerberos仕様の不適切なASN.1説明のために必要になりました。さらに、このセクションの文言は、この仕様に準拠した実装が将来の仕様に新しいフィールドを追加することで拡張可能になるように可能な限り締め付けられました。"
    },
    {
      "indent": 3,
      "text": "Text was added describing time_t=0 issues in the ASN.1. Text was also added, clarifying issues with implementations treating omitted optional integers as zero. Text was added clarifying behavior for optional SEQUENCE or SEQUENCE OF that may be empty. Discussion was added regarding sequence numbers and behavior of some implementations, including \"zero\" behavior and negative numbers. A compatibility note was added regarding the unconditional sending of EncTGSRepPart regardless of the enclosing reply type. Minor changes were made to the description of the HostAddresses type. Integer types were constrained. KerberosString was defined as a (significantly) constrained GeneralString. KerberosFlags was defined to reflect existing implementation behavior that departs from the definition in RFC 1510. The transited-policy-checked(12) and the ok-as-delegate(13) ticket flags were added. The disable-transited-check(26) KDC option was added.",
      "ja": "time_t = 0の問題を説明するテキストが追加されました。テキストも追加され、オプションの整数をゼロとして除去する実装の問題を明確にしました。テキストには、オプションのシーケンスまたはそのシーケンスの明確な動作が空になる可能性があります。「ゼロ」の動作や負の数値など、いくつかの実装のシーケンス番号と動作に関する議論が追加されました。囲まれた返信タイプに関係なく、enctgsreppartの無条件の送信に関する互換性メモが追加されました。HostAddressesタイプの説明にわずかな変更が行われました。整数型が制約されました。Kerberostringは、（大幅に）制約された将軍として定義されていました。Kerberosflagsは、RFC 1510の定義から離れた既存の実装動作を反映するように定義されました。Transited-Policy-Checked（12）およびDelegate（13）のチケットフラグが追加されました。Disable-Transited-Check（26）KDCオプションが追加されました。"
    },
    {
      "indent": 3,
      "text": "Descriptions of commonly implemented PA-DATA were added to Section 5. The description of KRB-SAFE has been updated to note the existing implementation behavior of double-encoding.",
      "ja": "一般的に実装されたPA-DATAの説明をセクション5に追加しました。KRB-Safeの説明は、二重エンコードの既存の実装動作に注意するために更新されました。"
    },
    {
      "indent": 3,
      "text": "There were two definitions of METHOD-DATA in RFC 1510. The second one, intended for use with KRB_AP_ERR_METHOD was removed leaving the SEQUENCE OF PA-DATA definition.",
      "ja": "RFC 1510にはメソッドデータの2つの定義がありました。KRB_AP_ERR_METHODで使用することを目的とした2番目の定義は、PA-DATA定義のシーケンスを残して削除されました。"
    },
    {
      "indent": 3,
      "text": "Section 7, naming constraints, from RFC 1510 was moved to Section 6.",
      "ja": "RFC 1510からの命名制約のセクション7は、セクション6に移動しました。"
    },
    {
      "indent": 3,
      "text": "Words were added describing the convention that domain-based realm names for newly-created realms should be specified as uppercase. This recommendation does not make lowercase realm names illegal. Words were added highlighting that the slash-separated components in the X.500 style of realm names is consistent with existing RFC 1510 based implementations, but that it conflicts with the general recommendation of X.500 name representation specified in RFC 2253.",
      "ja": "新たに作成された領域のドメインベースの領域名が大文字として指定されるべきであるという条約を説明する単語が追加されました。この推奨事項は、小文字の領域名を違法にしません。X.500スタイルのレルム名のスラッシュ分離コンポーネントは、既存のRFC 1510ベースの実装と一致しているが、RFC 2253で指定されたX.500名表現の一般的な推奨事項と矛盾することを強調した単語が追加されました。"
    },
    {
      "indent": 3,
      "text": "Section 8, network transport, constants and defined values, from RFC 1510 was moved to Section 7. Since RFC 1510, the definition of the TCP transport for Kerberos messages was added, and the encryption and checksum number assignments have been moved into a separate document.",
      "ja": "RFC 1510からのセクション8、ネットワークトランスポート、定数、および定義された値はセクション7に移動しました。RFC1510以降、KerberosメッセージのTCPトランスポートの定義が追加され、暗号化とチェックサム番号の割り当てが別のドキュメントに移動されました。。"
    },
    {
      "indent": 3,
      "text": "\"Specification 2\" in Section 8 of the current document changes the required encryption and checksum methods to bring them in line with the best current practices and to deprecate methods that are no longer considered sufficiently strong.",
      "ja": "現在のドキュメントのセクション8の「仕様2」は、必要な暗号化とチェックサムの方法を変更して、最良の現在のプラクティスに沿ったものにし、もはや十分に強力であると見なされなくなった方法を非難します。"
    },
    {
      "indent": 3,
      "text": "Two new sections, on IANA considerations and security considerations were added.",
      "ja": "IANAの考慮事項とセキュリティに関する考慮事項に関する2つの新しいセクションが追加されました。"
    },
    {
      "indent": 3,
      "text": "The pseudo-code has been removed from the appendix. The pseudo-code was sometimes misinterpreted to limit implementation choices and in RFC 1510, it was not always consistent with the words in the specification. Effort was made to clear up any ambiguities in the specification, rather than to rely on the pseudo-code.",
      "ja": "擬似コードは付録から削除されました。擬似コードは、実装の選択肢を制限するために誤って解釈されることがあり、RFC 1510では、仕様内の単語と常に一致するわけではありませんでした。擬似コードに依存するのではなく、仕様のあいまいさを解消する努力がなされました。"
    },
    {
      "indent": 3,
      "text": "An appendix was added containing the complete ASN.1 module drawn from the discussion in Section 5 of the current document.",
      "ja": "現在のドキュメントのセクション5の議論から描かれた完全なasn.1モジュールを含む付録が追加されました。"
    },
    {
      "indent": 0,
      "text": "END NOTES",
      "ja": "エンドノート"
    },
    {
      "indent": 3,
      "text": "(*TM) Project Athena, Athena, and Kerberos are trademarks of the Massachusetts Institute of Technology (MIT).",
      "ja": "（*TM）プロジェクトAthena、Athena、およびKerberosは、マサチューセッツ工科大学（MIT）の商標です。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": "[RFC3961] Raeburn、K。、「Kerberos 5の暗号化とチェックサム仕様」、RFC 3961、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3962] Raeburn, K., \"Advanced Encryption Standard (AES) Encryption for Kerberos 5\", RFC 3962, February 2005.",
      "ja": "[RFC3962] Raeburn、K。、「Kerberos 5の高度な暗号化標準（AES）暗号化」、RFC 3962、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[ISO-646/ECMA-6] International Organization for Standardization, \"7-bit Coded Character Set for Information Interchange\", ISO/IEC 646:1991.",
      "ja": "[ISO-646/ECMA-6]国際標準化機関、「情報交換用の7ビットコード化された文字セット」、ISO/IEC 646：1991。"
    },
    {
      "indent": 3,
      "text": "[ISO-2022/ECMA-35] International Organization for Standardization, \"Character code structure and extension techniques\", ISO/IEC 2022:1994.",
      "ja": "[ISO-2022/ECMA-35]国際標準化機関、「文字コード構造と拡張技術」、ISO/IEC 2022：1994。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名 - 実装と仕様」、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2434] Narten, T. and H. Alvestrand, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 2434, October 1998.",
      "ja": "[RFC2434] Narten、T。およびH. Alvestrand、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 2434、1998年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2253] Wahl, M., Kille, S., and T. Howes, \"Lightweight Directory Access Protocol (v3): UTF-8 String Representation of Distinguished Names\", RFC 2253, December 1997.",
      "ja": "[RFC2253] Wahl、M.、Kille、S。、およびT. Howes、「Lightweight Directory Access Protocol（V3）：UTF-8文字列名の表現」、RFC 2253、1997年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3513] Hinden, R. and S. Deering, \"Internet Protocol Version 6 (IPv6) Addressing Architecture\", RFC 3513, April 2003.",
      "ja": "[RFC3513] Hinden、R。およびS. Deering、「インターネットプロトコルバージョン6（IPv6）アドレス指定アーキテクチャ」、RFC 3513、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[X680] Abstract Syntax Notation One (ASN.1): Specification of Basic Notation, ITU-T Recommendation X.680 (1997) | ISO/IEC International Standard 8824-1:1998.",
      "ja": "[x680]要約構文表記1（ASN.1）：基本表記の仕様、ITU-T推奨X.680（1997）|ISO/IEC International Standard 8824-1：1998。"
    },
    {
      "indent": 3,
      "text": "[X690] ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER), ITU-T Recommendation X.690 (1997)| ISO/IEC International Standard 8825-1:1998.",
      "ja": "[x690] ASN.1エンコーディングルール：基本エンコードルール（BER）、標準エンコードルール（CER）および識別エンコードルール（DER）の指定、ITU-T推奨X.690（1997）|ISO/IEC International Standard 8825-1：1998。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[ISO-8859] International Organization for Standardization, \"8-bit Single-byte Coded Graphic Character Sets -- Latin Alphabet\", ISO/IEC 8859.",
      "ja": "[ISO-8859]国際標準化機関、「8ビットシングルバイトコード化されたグラフィック文字セット - ラテンアルファベット」、ISO/IEC 8859。"
    },
    {
      "indent": 3,
      "text": "[RFC1964] Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964, June 1996.",
      "ja": "[RFC1964] Linn、J。、「Kerberosバージョン5 GSS-APIメカニズム」、RFC 1964、1996年6月。"
    },
    {
      "indent": 3,
      "text": "[DGT96] Don Davis, Daniel Geer, and Theodore Ts'o, \"Kerberos With Clocks Adrift: History, Protocols, and Implementation\", USENIX Computing Systems 9:1, January 1996.",
      "ja": "[DGT96]ドン・デイビス、ダニエル・ジャー、セオドア・ツオ、「時計を添えたケルベロス：歴史、プロトコル、および実装」、USENIX Computing Systems 9：1、1996年1月。"
    },
    {
      "indent": 3,
      "text": "[DS81] Dorothy E. Denning and Giovanni Maria Sacco, \"Time-stamps in Key Distribution Protocols,\" Communications of the ACM, Vol. 24 (8), p. 533- 536, August 1981.",
      "ja": "[DS81] Dorothy E. DenningおよびGiovanni Maria Sacco、「主要な分布プロトコルのタイムスタンプ」、ACMの通信、Vol。24（8）、p。533- 536、1981年8月。"
    },
    {
      "indent": 3,
      "text": "[KNT94] John T. Kohl, B. Clifford Neuman, and Theodore Y. Ts'o, \"The Evolution of the Kerberos Authentication System\". In Distributed Open Systems, pages 78-94. IEEE Computer Society Press, 1994.",
      "ja": "[KNT94]ジョンT.コール、B。クリフォードノイマン、セオドアY. Ts'o、「Kerberos認証システムの進化」。分散オープンシステムでは、78〜94ページ。IEEE Computer Society Press、1994。"
    },
    {
      "indent": 3,
      "text": "[MNSS87] S. P. Miller, B. C. Neuman, J. I. Schiller, and J. H. Saltzer, Section E.2.1: Kerberos Authentication and Authorization System, M.I.T. Project Athena, Cambridge, Massachusetts, December 21, 1987.",
      "ja": "[MNSS87] S. P. Miller、B。C。Neuman、J。I。Schiller、およびJ. H. Saltzer、セクションE.2.1：Kerberos認証および認証システム、M.I.T。プロジェクトアテナ、ケンブリッジ、マサチューセッツ州、1987年12月21日。"
    },
    {
      "indent": 3,
      "text": "[NS78] Roger M. Needham and Michael D. Schroeder, \"Using Encryption for Authentication in Large Networks of Computers,\" Communications of the ACM, Vol. 21 (12), pp. 993-999, December 1978.",
      "ja": "[NS78] Roger M. NeedhamとMichael D. Schroeder、「コンピューターの大規模ネットワークでの認証のために暗号化を使用」、ACMの通信、Vol。21（12）、pp。993-999、1978年12月。"
    },
    {
      "indent": 3,
      "text": "[Neu93] B. Clifford Neuman, \"Proxy-Based Authorization and Accounting for Distributed Systems,\" in Proceedings of the 13th International Conference on Distributed Computing Systems, Pittsburgh, PA, May 1993.",
      "ja": "[Neu93] B. Clifford Neuman、「分散システムの代理ベースの承認と会計」、1993年5月、ペンシルバニア州ピッツバーグの分散コンピューティングシステムに関する第13回国際会議の議事録。"
    },
    {
      "indent": 3,
      "text": "[NT94] B. Clifford Neuman and Theodore Y. Ts'o, \"An Authentication Service for Computer Networks,\" IEEE Communications Magazine, Vol. 32 (9), p. 33- 38, September 1994.",
      "ja": "[NT94] B. Clifford Neuman and Theodore Y. Ts'o、「コンピューターネットワークの認証サービス」、IEEE Communications Magazine、Vol。32（9）、p。33- 38、1994年9月。"
    },
    {
      "indent": 3,
      "text": "[Pat92] J. Pato, Using Pre-Authentication to Avoid Password Guessing Attacks, Open Software Foundation DCE Request for Comments 26 (December 1992.",
      "ja": "[PAT92] J. Pato、パスワード推測攻撃を避けるために事前認証を使用して、コメントのオープンソフトウェア財団DCEリクエスト26（1992年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1510] Kohl, J. and C. Neuman, \"The Kerberos Network Authentication Service (V5)\", RFC 1510, September 1993.",
      "ja": "[RFC1510] Kohl、J。およびC. Neuman、「The Kerberos Network Authentication Service（V5）」、RFC 1510、1993年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[SNS88] J. G. Steiner, B. C. Neuman, and J. I. Schiller, \"Kerberos: An Authentication Service for Open Network Systems,\" p. 191-202, Usenix Conference Proceedings, Dallas, Texas, February 1988.",
      "ja": "[SNS88] J. G. Steiner、B。C。Neuman、およびJ. I. Schiller、「Kerberos：Open Network Systemsの認証サービス」、p。191-202、Usenix Conference Proceedings、テキサス州ダラス、1988年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005.",
      "ja": "[RFC4121] Zhu、L.、Jaganathan、K。、およびS. Hartman、「Kerberosバージョン5ジェネリックセキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）メカニズム：バージョン2、RFC 4121、2005年7月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Clifford Neuman Information Sciences Institute University of Southern California 4676 Admiralty Way Marina del Rey, CA 90292, USA",
      "ja": "Clifford Neuman Information Sciences Institute南カリフォルニア大学4676 ADMIRALTY WAY MARINA DEL REY、CA 90292、米国"
    },
    {
      "indent": 3,
      "text": "EMail: bcn@isi.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tom Yu Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "トムユーマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、マサチューセッツ州02139、米国"
    },
    {
      "indent": 3,
      "text": "EMail: tlyu@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sam Hartman Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "サムハートマンマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、マサチューセッツ州02139、米国"
    },
    {
      "indent": 3,
      "text": "EMail: hartmans-ietf@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Kenneth Raeburn Massachusetts Institute of Technology 77 Massachusetts Avenue Cambridge, MA 02139, USA",
      "ja": "ケネスレイバーンマサチューセッツ工科大学77マサチューセッツアベニューケンブリッジ、マサチューセッツ州02139、米国"
    },
    {
      "indent": 3,
      "text": "EMail: raeburn@mit.edu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供され、貢献者、彼/彼女が代表する組織（もしあれば）、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を免除します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての範囲に関連する可能性があるとは限りません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待します。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}