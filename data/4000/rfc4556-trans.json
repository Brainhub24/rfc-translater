{
  "title": {
    "text": "RFC 4556 - Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)",
    "ja": "RFC 4556 - Kerberos（Pkinit）の初期認証のための公開鍵暗号化"
  },
  "number": 4556,
  "created_at": "2023-06-24 07:18:02.002329+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                             L. Zhu\nRequest for Comments: 4556                         Microsoft Corporation\nCategory: Standards Track                                        B. Tung\n                                                   Aerospace Corporation\n                                                               June 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": " Public Key Cryptography for Initial Authentication in Kerberos (PKINIT)",
      "ja": "Kerberos（Pkinit）の初期認証のための公開鍵暗号化"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes protocol extensions (hereafter called PKINIT) to the Kerberos protocol specification. These extensions provide a method for integrating public key cryptography into the initial authentication exchange, by using asymmetric-key signature and/or encryption algorithms in pre-authentication data fields.",
      "ja": "このドキュメントでは、Kerberosプロトコル仕様に対するプロトコル拡張（以下Pkinitと呼ばれる）について説明します。これらの拡張機能は、非対称の署名および/または暗号化アルゴリズムを使用してから、認証前のデータフィールドに使用することにより、公開キーの暗号化を初期認証交換に統合する方法を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Conventions Used in This Document ...............................4\n3. Extensions ......................................................5\n   3.1. Definitions, Requirements, and Constants ...................6\n        3.1.1. Required Algorithms .................................6\n        3.1.2. Recommended Algorithms ..............................6\n        3.1.3. Defined Message and Encryption Types ................7\n        3.1.4. Kerberos Encryption Types Defined for CMS\n               Algorithm Identifiers ...............................8\n   3.2. PKINIT Pre-authentication Syntax and Use ...................9\n        3.2.1. Generation of Client Request ........................9\n        3.2.2. Receipt of Client Request ..........................14\n        3.2.3. Generation of KDC Reply ............................18\n               3.2.3.1. Using Diffie-Hellman Key Exchange .........21\n               3.2.3.2. Using Public Key Encryption ...............23",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        3.2.4. Receipt of KDC Reply ...............................25\n   3.3. Interoperability Requirements .............................26\n   3.4. KDC Indication of PKINIT Support ..........................27\n4. Security Considerations ........................................27\n5. Acknowledgements ...............................................30\n6. References .....................................................30\n   6.1. Normative References ......................................30\n   6.2. Informative References ....................................32\nAppendix A.  PKINIT ASN.1 Module ..................................33\nAppendix B.  Test Vectors .........................................38\nAppendix C.  Miscellaneous Information about Microsoft Windows\n             PKINIT Implementations ...............................40",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The Kerberos V5 protocol [RFC4120] involves use of a trusted third party known as the Key Distribution Center (KDC) to negotiate shared session keys between clients and services and provide mutual authentication between them.",
      "ja": "Kerberos V5プロトコル[RFC4120]には、クライアントとサービス間の共有セッションキーを交渉し、それらの間の相互認証を提供するために、キーディストリビューションセンター（KDC）として知られる信頼できるサードパーティの使用が含まれます。"
    },
    {
      "indent": 3,
      "text": "The corner-stones of Kerberos V5 are the Ticket and the Authenticator. A Ticket encapsulates a symmetric key (the ticket session key) in an envelope (a public message) intended for a specific service. The contents of the Ticket are encrypted with a symmetric key shared between the service principal and the issuing KDC. The encrypted part of the Ticket contains the client principal name, among other items. An Authenticator is a record that can be shown to have been recently generated using the ticket session key in the associated Ticket. The ticket session key is known by the client who requested the ticket. The contents of the Authenticator are encrypted with the associated ticket session key. The encrypted part of an Authenticator contains a timestamp and the client principal name, among other items.",
      "ja": "Kerberos v5のコーナーストーンは、チケットと認証者です。チケットは、特定のサービスを目的とした封筒（パブリックメッセージ）の対称キー（チケットセッションキー）をカプセル化します。チケットの内容は、サービスプリンシパルと発行KDCの間で共有された対称キーで暗号化されています。チケットの暗号化された部分には、他のアイテムの中でも、クライアントのプリンシパル名が含まれています。Authenticatorは、関連するチケットのチケットセッションキーを使用して最近生成されたことが示されるレコードです。チケットセッションキーは、チケットを要求したクライアントが知られています。Authenticatorの内容は、関連するチケットセッションキーで暗号化されています。認証機の暗号化された部分には、他のアイテムの中でも、タイムスタンプとクライアントの主名が含まれています。"
    },
    {
      "indent": 3,
      "text": "As shown in Figure 1, below, the Kerberos V5 protocol consists of the following message exchanges between the client and the KDC, and the client and the application service:",
      "ja": "以下の図1に示すように、Kerberos V5プロトコルは、クライアントとKDCの間の次のメッセージ交換、およびクライアントとアプリケーションサービスで構成されています。"
    },
    {
      "indent": 4,
      "text": "- The Authentication Service (AS) Exchange",
      "ja": "- 認証サービス（AS）交換"
    },
    {
      "indent": 6,
      "text": "The client obtains an \"initial\" ticket from the Kerberos authentication server (AS), typically a Ticket Granting Ticket (TGT). The AS-REQ message and the AS-REP message are the request and the reply message, respectively, between the client and the AS.",
      "ja": "クライアントは、Kerberos Authentication Server（AS）、通常はチケット付与チケット（TGT）から「初期」チケットを取得します。AS-REQメッセージとAS-REPメッセージは、それぞれクライアントとASの間のリクエストと返信メッセージです。"
    },
    {
      "indent": 4,
      "text": "- The Ticket Granting Service (TGS) Exchange",
      "ja": "- チケット付与サービス（TGS）交換"
    },
    {
      "indent": 6,
      "text": "The client subsequently uses the TGT to authenticate and request a service ticket for a particular service, from the Kerberos ticket-granting server (TGS). The TGS-REQ message and the TGS-REP message are the request and the reply message respectively between the client and the TGS.",
      "ja": "その後、クライアントはTGTを使用して、Kerberosチケット栽培サーバー（TGS）から特定のサービスのサービスチケットを認証およびリクエストします。TGS-REQメッセージとTGS-REPメッセージは、クライアントとTGSの間のそれぞれリクエストと返信メッセージです。"
    },
    {
      "indent": 4,
      "text": "- The Client/Server Authentication Protocol (AP) Exchange",
      "ja": "- クライアント/サーバー認証プロトコル（AP）Exchange"
    },
    {
      "indent": 6,
      "text": "The client then makes a request with an AP-REQ message, consisting of a service ticket and an authenticator that certifies the client's possession of the ticket session key. The server may optionally reply with an AP-REP message. AP exchanges typically negotiate session-specific symmetric keys.",
      "ja": "その後、クライアントは、クライアントのチケットセッションキーの所有を証明するサービスチケットと認証者で構成されるAP-REQメッセージでリクエストを行います。サーバーは、オプションでAP-REPメッセージで返信できます。AP交換は通常、セッション固有の対称キーと交渉します。"
    },
    {
      "indent": 3,
      "text": "Usually, the AS and TGS are integrated in a single device also known as the KDC.",
      "ja": "通常、ASとTGSは、KDCとも呼ばれる単一のデバイスに統合されます。"
    },
    {
      "indent": 7,
      "text": "                   +--------------+\n        +--------->|  KDC         |\nAS-REQ /   +-------|              |\n      /   /        +--------------+\n     /   /          ^           |\n    /    |AS-REP   /            |\n   |     |        / TGS-REQ     + TGS-REP\n   |     |       /             /\n   |     |      /             /\n   |     |     /   +---------+\n   |     |    /   /\n   |     |   /   /\n   |     |  /   /\n   |     v /   v\n  ++-------+------+             +-----------------+\n  |  Client       +------------>|  Application    |\n  |               |    AP-REQ   |  Server         |\n  |               |<------------|                 |\n  +---------------+    AP-REP   +-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 1: The Message Exchanges in the Kerberos V5 Protocol",
      "ja": "図1：Kerberos V5プロトコルのメッセージ交換"
    },
    {
      "indent": 3,
      "text": "In the AS exchange, the KDC reply contains the ticket session key, among other items, that is encrypted using a key (the AS reply key) shared between the client and the KDC. The AS reply key is typically derived from the client's password for human users. Therefore, for human users, the attack resistance strength of the Kerberos protocol is no stronger than the strength of their passwords.",
      "ja": "AS Exchangeでは、KDCの返信には、クライアントとKDCの間で共有されるキー（As Reply Key）を使用して暗号化されたチケットセッションキーなど、チケットセッションキーが含まれています。As As Replyキーは、通常、人間のユーザー向けのクライアントのパスワードから派生します。したがって、人間のユーザーにとって、Kerberosプロトコルの攻撃抵抗強度は、パスワードの強度よりも強くありません。"
    },
    {
      "indent": 3,
      "text": "The use of asymmetric cryptography in the form of X.509 certificates [RFC3280] is popular for facilitating data origin authentication and perfect secrecy. An established Public Key Infrastructure (PKI) provides key management and key distribution mechanisms that can be used to establish authentication and secure communication. Adding public-key cryptography to Kerberos provides a nice congruence to public-key protocols, obviates the human users' burden to manage strong passwords, and allows Kerberized applications to take advantage of existing key services and identity management.",
      "ja": "X.509証明書[RFC3280]の形式での非対称暗号化の使用は、データの起源認証と完全な秘密を促進するために人気があります。確立された公開キーインフラストラクチャ（PKI）は、認証と安全な通信を確立するために使用できる主要な管理および主要な分布メカニズムを提供します。Kerberosにパブリックキーの暗号化を追加すると、パブリックキープロトコルとの優れた一致があり、人間のユーザーの負担を取り除いて強力なパスワードを管理し、Kerberizedアプリケーションが既存の主要サービスとID管理を利用できるようにします。"
    },
    {
      "indent": 3,
      "text": "The advantage afforded by the Kerberos TGT is that the client exposes his long-term secrets only once. The TGT and its associated session key can then be used for any subsequent service ticket requests. One result of this is that all further authentication is independent of the method by which the initial authentication was performed. Consequently, initial authentication provides a convenient place to integrate public-key cryptography into Kerberos authentication. In addition, the use of symmetric cryptography after the initial exchange is preferred for performance.",
      "ja": "Kerberos TGTが提供する利点は、クライアントが長期的な秘密を一度だけ公開することです。TGTとそれに関連するセッションキーは、後続のサービスチケットリクエストに使用できます。この結果の1つは、すべてのさらなる認証は、初期認証が実行された方法とは独立していることです。その結果、初期認証は、パブリックキー暗号化をKerberos認証に統合するための便利な場所を提供します。さらに、最初の交換後の対称暗号化の使用がパフォーマンスに優先されます。"
    },
    {
      "indent": 3,
      "text": "This document describes the methods and data formats using which the client and the KDC can use public and private key pairs to mutually authenticate in the AS exchange and negotiate the AS reply key, known only by the client and the KDC, to encrypt the AS-REP sent by the KDC.",
      "ja": "このドキュメントでは、クライアントとKDCがパブリックキーペアと秘密キーペアを使用して、ASの交換で相互に認証し、クライアントとKDCのみが知っているAS応答キーを交換することができる方法とデータ形式について説明します。KDCから送信された担当者。"
    },
    {
      "indent": 0,
      "text": "2. Conventions Used in This Document",
      "section_title": true,
      "ja": "2. このドキュメントで使用されている規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "In this protocol, both the client and the KDC have a public-private key pair in order to prove their identities to each other over the open network. The term \"signature key\" is used to refer to the private key of the key pair being used.",
      "ja": "このプロトコルでは、クライアントとKDCの両方が、オープンネットワークを介して互いにアイデンティティを証明するために、官民のキーペアを持っています。「署名キー」という用語は、使用されているキーペアの秘密鍵を参照するために使用されます。"
    },
    {
      "indent": 3,
      "text": "The encryption key used to encrypt the enc-part field of the KDC-REP in the AS-REP [RFC4120] is referred to as the AS reply key.",
      "ja": "AS-REP [RFC4120]のKDC-REPのエンクパートフィールドを暗号化するために使用される暗号化キーは、AS応答キーと呼ばれます。"
    },
    {
      "indent": 3,
      "text": "An empty sequence in an optional field can be either included or omitted: both encodings are permitted and considered equivalent.",
      "ja": "オプションフィールドの空のシーケンスを含めるか、省略できます。両方のエンコーディングが許可され、同等のものと見なされます。"
    },
    {
      "indent": 3,
      "text": "The term \"Modular Exponential Diffie-Hellman\" is used to refer to the Diffie-Hellman key exchange, as described in [RFC2631], in order to differentiate it from other equivalent representations of the same key agreement algorithm.",
      "ja": "「Modular Exponertial Diffie-Hellman」という用語は、[RFC2631]に記載されているように、同じキー契約アルゴリズムの他の同等の表現と区別するために、[RFC2631]に記載されているDiffie-Hellmanキー交換を参照するために使用されます。"
    },
    {
      "indent": 0,
      "text": "3. Extensions",
      "section_title": true,
      "ja": "3. 拡張機能"
    },
    {
      "indent": 3,
      "text": "This section describes extensions to [RFC4120] for supporting the use of public-key cryptography in the initial request for a ticket.",
      "ja": "このセクションでは、チケットの最初のリクエストでパブリックキー暗号化の使用をサポートするための[RFC4120]の拡張について説明します。"
    },
    {
      "indent": 3,
      "text": "Briefly, this document defines the following extensions to [RFC4120]:",
      "ja": "簡単に言えば、このドキュメントでは、次の拡張機能を[RFC4120]に定義します。"
    },
    {
      "indent": 3,
      "text": "1. The client indicates the use of public-key authentication by including a special preauthenticator in the initial request. This preauthenticator contains the client's public-key data and a signature.",
      "ja": "1. クライアントは、最初のリクエストに特別な事前受託者を含めることにより、パブリックキー認証の使用を示します。このPreauthenticatorには、クライアントのパブリックキーデータと署名が含まれています。"
    },
    {
      "indent": 3,
      "text": "2. The KDC tests the client's request against its authentication policy and trusted Certification Authorities (CAs).",
      "ja": "2. KDCは、認証ポリシーと信頼できる認証当局（CAS）に対するクライアントの要求をテストします。"
    },
    {
      "indent": 3,
      "text": "3. If the request passes the verification tests, the KDC replies as usual, but the reply is encrypted using either:",
      "ja": "3. リクエストが検証テストに合格した場合、KDCは通常どおり返信しますが、応答は次のいずれかを使用して暗号化されます。"
    },
    {
      "indent": 6,
      "text": "a. a key generated through a Diffie-Hellman (DH) key exchange [RFC2631] [IEEE1363] with the client, signed using the KDC's signature key; or",
      "ja": "a. KDCの署名キーを使用して署名されたクライアントとともに、diffie-hellman（dh）キーエクスチェンジ[RFC2631] [IEEE1363]を介して生成されたキー。また"
    },
    {
      "indent": 6,
      "text": "b. a symmetric encryption key, signed using the KDC's signature key and encrypted using the client's public key.",
      "ja": "b. KDCの署名キーを使用して署名され、クライアントの公開キーを使用して暗号化された対称暗号化キー。"
    },
    {
      "indent": 6,
      "text": "Any keying material required by the client to obtain the encryption key for decrypting the KDC reply is returned in a pre-authentication field accompanying the usual reply.",
      "ja": "KDCの返信を復号化するために暗号化キーを取得するためにクライアントが必要とするキーイング資料は、通常の応答に伴う承認前フィールドで返されます。"
    },
    {
      "indent": 3,
      "text": "4. The client validates the KDC's signature, obtains the encryption key, decrypts the reply, and then proceeds as usual.",
      "ja": "4. クライアントは、KDCの署名を検証し、暗号化キーを取得し、返信を復号化してから通常どおりに進行します。"
    },
    {
      "indent": 3,
      "text": "Section 3.1 of this document enumerates the required algorithms and necessary extension message types. Section 3.2 describes the extension messages in greater detail.",
      "ja": "このドキュメントのセクション3.1では、必要なアルゴリズムと必要な拡張メッセージタイプを列挙しています。セクション3.2では、拡張メッセージを詳細に説明します。"
    },
    {
      "indent": 0,
      "text": "3.1. Definitions, Requirements, and Constants",
      "section_title": true,
      "ja": "3.1. 定義、要件、および定数"
    },
    {
      "indent": 0,
      "text": "3.1.1. Required Algorithms",
      "section_title": true,
      "ja": "3.1.1. 必要なアルゴリズム"
    },
    {
      "indent": 3,
      "text": "All PKINIT implementations MUST support the following algorithms:",
      "ja": "すべてのpkinit実装は、次のアルゴリズムをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o AS reply key enctypes: aes128-cts-hmac-sha1-96 and aes256-cts-hmac-sha1-96 [RFC3962].",
      "ja": "o 返信としてキーエンジェプ：AES128-CTS-HMAC-SHA1-96およびAES256-CTS-HMAC-SHA1-96 [RFC3962]。"
    },
    {
      "indent": 3,
      "text": "o Signature algorithm: sha-1WithRSAEncryption [RFC3370].",
      "ja": "o 署名アルゴリズム：Sha-1withrsaencryption [RFC3370]。"
    },
    {
      "indent": 3,
      "text": "o AS reply key delivery method: the Diffie-Hellman key delivery method, as described in Section 3.2.3.1.",
      "ja": "o 返信としてキー配信方法：セクション3.2.3.1で説明されているように、Diffie-Hellmanキー配信方法。"
    },
    {
      "indent": 3,
      "text": "In addition, implementations of this specification MUST be capable of processing the Extended Key Usage (EKU) extension and the id-pkinit-san (as defined in Section 3.2.2) otherName of the Subject Alternative Name (SAN) extension in X.509 certificates [RFC3280].",
      "ja": "さらに、この仕様の実装は、X.509の主題代替名（SAN）拡張機能の拡張キー使用法（EKU）拡張機能とID-Pkinit-San（セクション3.2.2で定義されている）を処理できる必要があります。証明書[RFC3280]。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Recommended Algorithms",
      "section_title": true,
      "ja": "3.1.2. 推奨アルゴリズム"
    },
    {
      "indent": 3,
      "text": "All PKINIT implementations SHOULD support the following algorithm:",
      "ja": "すべてのpkinit実装は、次のアルゴリズムをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "o AS reply key delivery method: the public key encryption key delivery method, as described in Section 3.2.3.2.",
      "ja": "o 返信としてキー配信方法：セクション3.2.3.2で説明されているように、公開キー暗号化キー配信方法。"
    },
    {
      "indent": 3,
      "text": "For implementations that support the public key encryption key delivery method, the following algorithms MUST be supported:",
      "ja": "公開キー暗号化キー配信方法をサポートする実装のために、次のアルゴリズムをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "a) Key transport algorithms identified in the keyEncryptionAlgorithm field of the type KeyTransRecipientInfo [RFC3852] for encrypting the temporary key in the encryptedKey field [RFC3852] with a public key, as described in Section 3.2.3.2: rsaEncryption (this is the RSAES-PKCS1-v1_5 encryption scheme) [RFC3370] [RFC3447].",
      "ja": "a) 暗号化スキーム）[RFC3370] [RFC3447]。"
    },
    {
      "indent": 3,
      "text": "b) Content encryption algorithms identified in the contentEncryptionAlgorithm field of the type EncryptedContentInfo [RFC3852] for encrypting the AS reply key with the temporary key contained in the encryptedKey field of the type KeyTransRecipientInfo [RFC3852], as described in Section 3.2.3.2: des-ede3-cbc (three-key 3DES, CBC mode) [RFC3370].",
      "ja": "b) Content EncryptionAlgorithmフィールドで識別されたコンテンツ暗号化されたアルゴリズム型暗号化されたContentInfo [RFC3852]のためのAS As Replyキーを暗号化するためのタイプKeyTransRecipientInfo [RFC3852]の暗号化されたキーを暗号化する一時的なキーを暗号化します。CBC（3キー3DES、CBCモード）[RFC3370]。"
    },
    {
      "indent": 0,
      "text": "3.1.3. Defined Message and Encryption Types",
      "section_title": true,
      "ja": "3.1.3. 定義されたメッセージと暗号化タイプ"
    },
    {
      "indent": 3,
      "text": "PKINIT makes use of the following new pre-authentication types:",
      "ja": "Pkinitは、次の新しい認証タイプを使用しています。"
    },
    {
      "indent": 7,
      "text": "PA_PK_AS_REQ                                 16\nPA_PK_AS_REP                                 17",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PKINIT also makes use of the following new authorization data type:",
      "ja": "Pkinitは、次の新しい承認データタイプも使用しています。"
    },
    {
      "indent": 7,
      "text": "AD_INITIAL_VERIFIED_CAS 9",
      "ja": "AD_INITIAL_VERIFIED_CAS 9"
    },
    {
      "indent": 3,
      "text": "PKINIT introduces the following new error codes:",
      "ja": "Pkinitは、次の新しいエラーコードを紹介します。"
    },
    {
      "indent": 7,
      "text": "KDC_ERR_CLIENT_NOT_TRUSTED                   62\nKDC_ERR_INVALID_SIG                          64\nKDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED       65\nKDC_ERR_CANT_VERIFY_CERTIFICATE              70\nKDC_ERR_INVALID_CERTIFICATE                  71\nKDC_ERR_REVOKED_CERTIFICATE                  72\nKDC_ERR_REVOCATION_STATUS_UNKNOWN            73\nKDC_ERR_CLIENT_NAME_MISMATCH                 75\nKDC_ERR_INCONSISTENT_KEY_PURPOSE             77\nKDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED          78\nKDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED         79\nKDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED   80\nKDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED  81",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PKINIT uses the following typed data types for errors:",
      "ja": "Pkinitは、エラーに次の型と入力されたデータ型を使用します。"
    },
    {
      "indent": 7,
      "text": "TD_TRUSTED_CERTIFIERS                       104\nTD_INVALID_CERTIFICATES                     105\nTD_DH_PARAMETERS                            109",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ASN.1 module for all structures defined in this document (plus IMPORT statements for all imported structures) is given in Appendix A.",
      "ja": "このドキュメントで定義されているすべての構造のASN.1モジュール（さらに、すべてのインポートされた構造のインポートステートメント）を付録Aに示します。"
    },
    {
      "indent": 3,
      "text": "All structures defined in or imported into this document MUST be encoded using Distinguished Encoding Rules (DER) [X680] [X690] (unless otherwise noted). All data structures carried in OCTET STRINGs MUST be encoded according to the rules specified in the specifications defining each data structure; a reference to the appropriate specification is provided for each data structure.",
      "ja": "このドキュメントで定義またはインポートされたすべての構造は、著名なエンコードルール（der）[x680] [x690]を使用してエンコードする必要があります（特に明記しない限り）。オクテット文字列で運ばれるすべてのデータ構造は、各データ構造を定義する仕様で指定されたルールに従ってエンコードする必要があります。各データ構造に適切な仕様への参照が提供されます。"
    },
    {
      "indent": 3,
      "text": "Interoperability note: Some implementations may not be able to decode wrapped Cryptographic Message Syntax (CMS) [RFC3852] objects encoded with BER; specifically, they may not be able to decode indefinite-length encodings. To maximize interoperability, implementers SHOULD encode CMS objects used in PKINIT with DER.",
      "ja": "相互運用性注：いくつかの実装は、BERでエンコードされたラップされた暗号化メッセージ構文（CMS）[RFC3852]オブジェクトをデコードできない場合があります。具体的には、無期限の長さのエンコーディングをデコードできない場合があります。相互運用性を最大化するために、実装者はderを使用してpkinitで使用されるCMSオブジェクトをエンコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.4. Kerberos Encryption Types Defined for CMS Algorithm Identifiers",
      "section_title": true,
      "ja": "3.1.4. CMSアルゴリズム識別子に対して定義されたKerberos暗号化タイプ"
    },
    {
      "indent": 3,
      "text": "PKINIT defines the following Kerberos encryption type numbers [RFC3961], which can be used in the etype field of the AS-REQ [RFC4120] message to indicate to the KDC the client's acceptance of the corresponding algorithms (including key transport algorithms [RFC3370], content encryption algorithms [RFC3370], and signature algorithms) for use with Cryptographic Message Syntax (CMS) [RFC3852] [RFC3370].",
      "ja": "Pkinitは、次のKerberos暗号化タイプ数[RFC3961]を定義します。これは、AS-REQ [RFC4120]メッセージのETYPEフィールドで使用して、KDCにクライアントが対応するアルゴリズムの受け入れを示しています（主要な輸送アルゴリズム[RFC3370を含む）、暗号化メッセージ構文（CMS）[RFC3852] [RFC3370]で使用するためのコンテンツ暗号化アルゴリズム[RFC3370]、および署名アルゴリズム）。"
    },
    {
      "indent": 3,
      "text": "Per [RFC4120], the encryption types in the etype field are in the decreasing preference order of the client. Note that there is no significance in the relative order between any two of different types of algorithms: key transport algorithms, content encryption algorithms, and signature algorithms.",
      "ja": "[RFC4120]に従って、ETYPEフィールドの暗号化タイプは、クライアントの優先順位の減少にあります。キートランスポートアルゴリズム、コンテンツ暗号化アルゴリズム、および署名アルゴリズムの2つの異なるタイプのアルゴリズムの間で、相対順序に有意はないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The presence of each of these encryption types in the etype field is equivalent to the presence of the corresponding algorithm Object Identifier (OID) in the supportedCMSTypes field as described in Section 3.2.1. And the preference order expressed in the supportedCMSTypes field would override the preference order listed in the etype field.",
      "ja": "ETYPEフィールドにこれらの暗号化タイプのそれぞれが存在することは、セクション3.2.1で説明されているように、サポートされているCMSTYPESフィールドに対応するアルゴリズムオブジェクト識別子（OID）の存在と同等です。また、supportedCmStypesフィールドで表現された優先順序は、ETYPEフィールドにリストされている優先順序をオーバーライドします。"
    },
    {
      "indent": 4,
      "text": "Kerberos Encryption Type Name  Num  Corresponding Algorithm OID\n============================== === ===============================\nid-dsa-with-sha1-CmsOID         9  id-dsa-with-sha1 [RFC3370]\nmd5WithRSAEncryption-CmsOID    10  md5WithRSAEncryption [RFC3370]\nsha-1WithRSAEncryption-CmsOID  11  sha-1WithRSAEncryption [RFC3370]\nrc2-cbc-EnvOID                 12  rc2-cbc [RFC3370]\nrsaEncryption-EnvOID           13  rsaEncryption [RFC3447][RFC3370]\nid-RSAES-OAEP-EnvOID           14  id-RSAES-OAEP [RFC3447][RFC3560]\ndes-ede3-cbc-EnvOID            15  des-ede3-cbc [RFC3370]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The above encryption type numbers are used only to indicate support for the use of the corresponding algorithms in PKINIT; they do not correspond to actual Kerberos encryption types [RFC3961] and MUST NOT be used in the etype field of the Kerberos EncryptedData type [RFC4120]. The practice of assigning Kerberos encryption type numbers to indicate support for CMS algorithms is considered deprecated, and new numbers should not be assigned for this purpose. Instead, the supportedCMSTypes field should be used to identify the algorithms supported by the client and the preference order of the client.",
      "ja": "上記の暗号化タイプ番号は、Pkinitでの対応するアルゴリズムの使用のサポートを示すためにのみ使用されます。それらは実際のKerberos暗号化タイプ[RFC3961]に対応しておらず、Kerberos EncryptedData Type [RFC4120]のETYPEフィールドで使用してはなりません。CMSアルゴリズムのサポートを示すためにKerberos暗号化タイプ番号を割り当てる慣行は非推奨と見なされ、この目的のために新しい数値を割り当てるべきではありません。代わりに、サポートされているcmStypesフィールドを使用して、クライアントがサポートするアルゴリズムとクライアントの優先順序を識別する必要があります。"
    },
    {
      "indent": 3,
      "text": "For maximum interoperability, however, PKINIT clients wishing to indicate to the KDC the support for one or more of the algorithms listed above SHOULD include the corresponding encryption type number(s) in the etype field of the AS-REQ.",
      "ja": "ただし、最大の相互運用性のために、KDCに示すサポートをKDCに示すことを希望するPkinitクライアントは、上記の1つ以上のアルゴリズムのサポートに、AS-REQのETYPEフィールドに対応する暗号化タイプ数を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2. PKINIT Pre-authentication Syntax and Use",
      "section_title": true,
      "ja": "3.2. Pkinit Prisouthenticationの構文と使用"
    },
    {
      "indent": 3,
      "text": "This section defines the syntax and use of the various pre-authentication fields employed by PKINIT.",
      "ja": "このセクションでは、Pkinitが採用したさまざまな認証フィールドの構文と使用を定義します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Generation of Client Request",
      "section_title": true,
      "ja": "3.2.1. クライアントリクエストの生成"
    },
    {
      "indent": 3,
      "text": "The initial authentication request (AS-REQ) is sent as per [RFC4120]; in addition, a pre-authentication data element, whose padata-type is PA_PK_AS_REQ and whose padata-value contains the DER encoding of the type PA-PK-AS-REQ, is included.",
      "ja": "初期認証要求（AS-REQ）は[RFC4120]に従って送信されます。さらに、PadataタイプがPA_PK_AS_REQであり、Padata-ValueにはタイプPA-PK-As-Reqのderエンコードが含まれていることが含まれています。"
    },
    {
      "indent": 7,
      "text": "PA-PK-AS-REQ ::= SEQUENCE {\n   signedAuthPack          [0] IMPLICIT OCTET STRING,\n            -- Contains a CMS type ContentInfo encoded\n            -- according to [RFC3852].\n            -- The contentType field of the type ContentInfo\n            -- is id-signedData (1.2.840.113549.1.7.2),\n            -- and the content field is a SignedData.\n            -- The eContentType field for the type SignedData is\n            -- id-pkinit-authData (1.3.6.1.5.2.3.1), and the\n            -- eContent field contains the DER encoding of the\n            -- type AuthPack.\n            -- AuthPack is defined below.\n   trustedCertifiers       [1] SEQUENCE OF\n               ExternalPrincipalIdentifier OPTIONAL,\n            -- Contains a list of CAs, trusted by the client,\n            -- that can be used to certify the KDC.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).\n            -- The information contained in the\n            -- trustedCertifiers SHOULD be used by the KDC as",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            -- hints to guide its selection of an appropriate\n            -- certificate chain to return to the client.\n   kdcPkId                 [2] IMPLICIT OCTET STRING\n                               OPTIONAL,\n            -- Contains a CMS type SignerIdentifier encoded\n            -- according to [RFC3852].\n            -- Identifies, if present, a particular KDC\n            -- public key that the client already has.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "DHNonce ::= OCTET STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ExternalPrincipalIdentifier ::= SEQUENCE {\n   subjectName            [0] IMPLICIT OCTET STRING OPTIONAL,\n            -- Contains a PKIX type Name encoded according to\n            -- [RFC3280].\n            -- Identifies the certificate subject by the\n            -- distinguished subject name.\n            -- REQUIRED when there is a distinguished subject\n            -- name present in the certificate.\n  issuerAndSerialNumber   [1] IMPLICIT OCTET STRING OPTIONAL,\n            -- Contains a CMS type IssuerAndSerialNumber encoded\n            -- according to [RFC3852].\n            -- Identifies a certificate of the subject.\n            -- REQUIRED for TD-INVALID-CERTIFICATES and\n            -- TD-TRUSTED-CERTIFIERS.\n  subjectKeyIdentifier    [2] IMPLICIT OCTET STRING OPTIONAL,\n            -- Identifies the subject's public key by a key\n            -- identifier.  When an X.509 certificate is\n            -- referenced, this key identifier matches the X.509\n            -- subjectKeyIdentifier extension value.  When other\n            -- certificate formats are referenced, the documents\n            -- that specify the certificate format and their use\n            -- with the CMS must include details on matching the\n            -- key identifier to the appropriate certificate\n            -- field.\n            -- RECOMMENDED for TD-TRUSTED-CERTIFIERS.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "AuthPack ::= SEQUENCE {\n   pkAuthenticator         [0] PKAuthenticator,\n   clientPublicValue       [1] SubjectPublicKeyInfo OPTIONAL,\n            -- Type SubjectPublicKeyInfo is defined in\n            -- [RFC3280].\n            -- Specifies Diffie-Hellman domain parameters\n            -- and the client's public key value [IEEE1363].",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            -- The DH public key value is encoded as a BIT\n            -- STRING according to [RFC3279].\n            -- This field is present only if the client wishes\n            -- to use the Diffie-Hellman key agreement method.\n   supportedCMSTypes       [2] SEQUENCE OF AlgorithmIdentifier\n                               OPTIONAL,\n            -- Type AlgorithmIdentifier is defined in\n            -- [RFC3280].\n            -- List of CMS algorithm [RFC3370] identifiers\n            -- that identify key transport algorithms, or\n            -- content encryption algorithms, or signature\n            -- algorithms supported by the client in order of\n            -- (decreasing) preference.\n   clientDHNonce           [3] DHNonce OPTIONAL,\n            -- Present only if the client indicates that it\n            -- wishes to reuse DH keys or to allow the KDC to\n            -- do so (see Section 3.2.3.1).\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "PKAuthenticator ::= SEQUENCE {\n   cusec                   [0] INTEGER (0..999999),\n   ctime                   [1] KerberosTime,\n            -- cusec and ctime are used as in [RFC4120], for\n            -- replay prevention.\n   nonce                   [2] INTEGER (0..4294967295),\n            -- Chosen randomly;  this nonce does not need to\n            -- match with the nonce in the KDC-REQ-BODY.\n   paChecksum              [3] OCTET STRING OPTIONAL,\n            -- MUST be present.\n            -- Contains the SHA1 checksum, performed over\n            -- KDC-REQ-BODY.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ContentInfo [RFC3852] structure contained in the signedAuthPack field of the type PA-PK-AS-REQ is encoded according to [RFC3852] and is filled out as follows:",
      "ja": "型PA-PK-as-reqのsignedauthpackフィールドに含まれるcontentinfo [rfc3852]構造は、[rfc3852]に従ってエンコードされ、次のように記入されます。"
    },
    {
      "indent": 3,
      "text": "1. The contentType field of the type ContentInfo is id-signedData (as defined in [RFC3852]), and the content field is a SignedData (as defined in [RFC3852]).",
      "ja": "1. 型ContentInfoのContentTypeフィールドはID-SignedData（[RFC3852]で定義されています）であり、コンテンツフィールドはSignedData（[RFC3852]で定義されています）です。"
    },
    {
      "indent": 3,
      "text": "2. The eContentType field for the type SignedData is id-pkinit-authData: { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2) pkinit(3) authData(1) }. Notes to CMS implementers: the signed attribute content-type MUST be present in this SignedData instance, and its value is id-pkinit-authData according to [RFC3852].",
      "ja": "2. タイプSignedDataのecontentTypeフィールドはid-pkinit-authdataです。CMS実装者へのメモ：署名された属性コンテンツタイプは、このsignedDataインスタンスに存在する必要があり、その値は[RFC3852]によるとid-pkinit-authdataです。"
    },
    {
      "indent": 3,
      "text": "3. The eContent field for the type SignedData contains the DER encoding of the type AuthPack.",
      "ja": "3. タイプSignedDataのecontentフィールドには、タイプAuthPackのderエンコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "4. The signerInfos field of the type SignedData contains a single signerInfo, which contains the signature over the type AuthPack.",
      "ja": "4. SignedDataのタイプのSignerinFosフィールドには、タイプAuthPackの署名が含まれている単一のSignerinfoが含まれています。"
    },
    {
      "indent": 3,
      "text": "5. The AuthPack structure contains a PKAuthenticator, the client public key information, the CMS encryption types supported by the client, and a DHNonce. The pkAuthenticator field certifies to the KDC that the client has recent knowledge of the signing key that authenticates the client. The clientPublicValue field specifies Diffie-Hellman domain parameters and the client's public key value. The DH public key value is encoded as a BIT STRING according to [RFC3279]. The clientPublicValue field is present only if the client wishes to use the Diffie-Hellman key agreement method. The supportedCMSTypes field specifies the list of CMS algorithm identifiers that are supported by the client in order of (decreasing) preference, and can be used to identify a signature algorithm or a key transport algorithm [RFC3370] in the keyEncryptionAlgorithm field of the type KeyTransRecipientInfo, or a content encryption algorithm [RFC3370] in the contentEncryptionAlgorithm field of the type EncryptedContentInfo [RFC3852] when encrypting the AS reply key as described in Section 3.2.3.2. However, there is no significance in the relative order between any two of different types of algorithms: key transport algorithms, content encryption algorithms, and signature algorithms. The clientDHNonce field is described later in this section.",
      "ja": "5. AuthPack構造には、PKAuthenticator、クライアントの公開鍵情報、クライアントがサポートするCMS暗号化タイプ、およびdhnonceが含まれています。PKAuthenticatorフィールドは、クライアントがクライアントを認証する署名キーに関する最近の知識を持っていることをKDCに証明しています。ClientPublicValueフィールドは、diffie-hellmanドメインパラメーターとクライアントの公開キー値を指定します。DH公開キー値は、[RFC3279]に従ってビット文字列としてエンコードされます。クライアントパブリックバリューフィールドは、クライアントがdiffie-hellmanキー契約法の使用を希望する場合にのみ存在します。supportedCMStypesフィールドは、（減少）優先度の順にクライアントによってサポートされているCMSアルゴリズム識別子のリストを指定し、KeyEncranscransrecientinfoのタイプのキーエンクラクリプチンアルゴリズム分野の署名アルゴリズムまたはキー輸送アルゴリズム[RFC3370]を識別するために使用できます。または、セクション3.2.3.2で説明されているAS応答キーを暗号化するときに、型暗号化されたContentInfo [rfc3852]のcontentencryptionalgorithmフィールドのコンテンツ暗号化アルゴリズム[RFC3370]。ただし、キートランスポートアルゴリズム、コンテンツ暗号化アルゴリズム、および署名アルゴリズムの2つの異なるタイプのアルゴリズムの間で、相対順序に有意性はありません。ClientDhnonceフィールドについては、このセクションの後半で説明します。"
    },
    {
      "indent": 3,
      "text": "6. The ctime field in the PKAuthenticator structure contains the current time on the client's host, and the cusec field contains the microsecond part of the client's timestamp. The ctime and cusec fields are used together to specify a reasonably accurate timestamp [RFC4120]. The nonce field is chosen randomly. The paChecksum field MUST be present and it contains a SHA1 checksum that is performed over the KDC-REQ-BODY [RFC4120]. In order to ease future migration from the use of SHA1, the paChecksum field is made optional syntactically: when the request is extended to negotiate hash algorithms, the new client wishing not to use SHA1 will send the request in the extended message syntax without the paChecksum field. The KDC conforming to this specification MUST return a KRB-ERROR [RFC4120] message with the code KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED (see Section 3.2.3). That will allow a new client to retry with SHA1 if allowed by the local policy.",
      "ja": "6. PKAuthenticator構造のCTIMEフィールドには、クライアントのホストの現在の時間が含まれており、CUSECフィールドにはクライアントのタイムスタンプのマイクロ秒の部分が含まれています。CTIMEとCUSECフィールドは、合理的に正確なタイムスタンプ[RFC4120]を指定するために一緒に使用されます。NonCEフィールドはランダムに選択されます。Pacheckumフィールドは存在する必要があり、KDC-Req-Body [RFC4120]で実行されるSHA1チェックサムが含まれています。SHA1の使用からの将来の移行を容易にするために、Pacheckumフィールドは構文的にオプションになります。リクエストがハッシュアルゴリズムを交渉するように拡張された場合、SHA1を使用しないようにする新しいクライアントは、Pachecumなしで拡張メッセージSynTaxでリクエストを送信します。分野。この仕様に準拠しているKDCは、kdc_err_pa_checksum_must_be_included（セクション3.2.3を参照）をコードKDC_ERR_PA_CHECKSUM_MUST_BE_BE_BE_BE_BE_BE_BE_BE_INCLUDEで使用して、KRB-Error [RFC4120]メッセージを返す必要があります。これにより、ローカルポリシーで許可されれば、新しいクライアントがSHA1で再試行することができます。"
    },
    {
      "indent": 3,
      "text": "7. The certificates field of the type SignedData contains certificates intended to facilitate certification path construction, so that the KDC can verify the signature over the type AuthPack. For path validation, these certificates SHOULD be sufficient to construct at least one certification path from the client certificate to one trust anchor acceptable by the KDC [RFC4158]. The client MUST be capable of including such a set of certificates if configured to do so. The certificates field MUST NOT contain \"root\" CA certificates.",
      "ja": "7. タイプSignedDataの証明書フィールドには、認証パス構築を促進することを目的とした証明書が含まれているため、KDCはType AuthPackの署名を確認できます。パス検証のために、これらの証明書は、クライアント証明書からKDC [RFC4158]が許容できる1つの信頼アンカーに少なくとも1つの認証パスを構築するのに十分である必要があります。クライアントは、そうするように構成されている場合、そのような一連の証明書を含めることができなければなりません。証明書フィールドには、「ルート」CA証明書を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "8. The client's Diffie-Hellman public value (clientPublicValue) is included if and only if the client wishes to use the Diffie-Hellman key agreement method. The Diffie-Hellman domain parameters [IEEE1363] for the client's public key are specified in the algorithm field of the type SubjectPublicKeyInfo [RFC3279], and the client's Diffie-Hellman public key value is mapped to a subjectPublicKey (a BIT STRING) according to [RFC3279]. When using the Diffie-Hellman key agreement method, implementations MUST support Oakley 1024-bit Modular Exponential (MODP) well-known group 2 [RFC2412] and Oakley 2048-bit MODP well-known group 14 [RFC3526] and SHOULD support Oakley 4096-bit MODP well-known group 16 [RFC3526].",
      "ja": "8. クライアントのdiffie-hellman public Value（clientPublicValue）が含まれています。クライアントの公開キーのdiffie-hellmanドメインパラメーター[IEEE1363]は、type subjectpublickeyinfo [rfc3279]のアルゴリズムフィールドで指定されており、クライアントのdiffie-hellmanの公開キー値は、[Subjectpublickey（bit string）にマッピングされます。RFC3279]。diffie-hellmanキー契約法を使用する場合、実装はオークリー1024ビットモジュラー指数（MODP）有名なグループ2 [RFC2412]およびオークリー2048ビットMODP有名グループ14 [RFC3526]をサポートする必要があり、オークリー4096-をサポートする必要があります。BIT MODPよく知られたグループ16 [RFC3526]。"
    },
    {
      "indent": 7,
      "text": "The Diffie-Hellman field size should be chosen so as to provide sufficient cryptographic security [RFC3766].",
      "ja": "Diffie-Hellmanのフィールドサイズは、十分な暗号化セキュリティを提供するように選択する必要があります[RFC3766]。"
    },
    {
      "indent": 7,
      "text": "When MODP Diffie-Hellman is used, the exponents should have at least twice as many bits as the symmetric keys that will be derived from them [ODL99].",
      "ja": "modp diffie-hellmanを使用する場合、指数は、それらに由来する対称キーの少なくとも2倍のビットを持つ必要があります[ODL99]。"
    },
    {
      "indent": 3,
      "text": "9. The client may wish to reuse DH keys or to allow the KDC to do so (see Section 3.2.3.1). If so, then the client includes the clientDHNonce field. This nonce string MUST be as long as the longest key length of the symmetric key types that the client supports. This nonce MUST be chosen randomly.",
      "ja": "9. クライアントは、DHキーを再利用するか、KDCがそうすることを許可したい場合があります（セクション3.2.3.1を参照）。もしそうなら、クライアントにはclientDhnonceフィールドが含まれます。このnonce文字列は、クライアントがサポートする対称キータイプの最長キー長である必要があります。この非CEはランダムに選択する必要があります。"
    },
    {
      "indent": 3,
      "text": "The ExternalPrincipalIdentifier structure is used in this document to identify the subject's public key thereby the subject principal. This structure is filled out as follows:",
      "ja": "このドキュメントでは、外部プリンシパルディファイア構造を使用して、被験者の公開鍵を識別するために使用されます。この構造は次のように記入されています。"
    },
    {
      "indent": 3,
      "text": "1. The subjectName field contains a PKIX type Name encoded according to [RFC3280]. This field identifies the certificate subject by the distinguished subject name. This field is REQUIRED when there is a distinguished subject name present in the certificate being used.",
      "ja": "1. 件名フィールドには、[RFC3280]に従ってエンコードされたPKIXタイプ名が含まれています。このフィールドは、著名な件名で証明書の科目を識別します。このフィールドは、使用されている証明書に著名な件名名が存在する場合に必要です。"
    },
    {
      "indent": 3,
      "text": "2. The issuerAndSerialNumber field contains a CMS type IssuerAndSerialNumber encoded according to [RFC3852]. This field identifies a certificate of the subject. This field is REQUIRED for TD-INVALID-CERTIFICATES and TD-TRUSTED-CERTIFIERS (both structures are defined in Section 3.2.2).",
      "ja": "2. IssuerandSerialNumberフィールドには、[RFC3852]に従ってエンコードされたCMSタイプの発行型発行担当者が含まれています。このフィールドは、主題の証明書を識別します。このフィールドは、TD-Invalid認証とTD-Trusted certifiersに必要です（両方の構造はセクション3.2.2で定義されています）。"
    },
    {
      "indent": 3,
      "text": "3. The subjectKeyIdentifier [RFC3852] field identifies the subject's public key by a key identifier. When an X.509 certificate is referenced, this key identifier matches the X.509 subjectKeyIdentifier extension value. When other certificate formats are referenced, the documents that specify the certificate format and their use with the CMS must include details on matching the key identifier to the appropriate certificate field. This field is RECOMMENDED for TD-TRUSTED-CERTIFIERS (as defined in Section 3.2.2).",
      "ja": "3. SubjectKeyIdentifier [RFC3852]フィールドは、キー識別子によって被験者の公開キーを識別します。X.509証明書が参照されると、このキー識別子はX.509件名の既存の拡張値と一致します。他の証明書形式が参照される場合、証明書形式を指定するドキュメントとCMSでの使用を指定するドキュメントには、キー識別子を適切な証明書フィールドに一致させる詳細を含める必要があります。このフィールドは、TD-Trusted-Certifiersに推奨されます（セクション3.2.2で定義されています）。"
    },
    {
      "indent": 3,
      "text": "The trustedCertifiers field of the type PA-PK-AS-REQ contains a list of CAs, trusted by the client, that can be used to certify the KDC. Each ExternalPrincipalIdentifier identifies a CA or a CA certificate (thereby its public key).",
      "ja": "Type PA-PK-As-ReqのTrustedCertifiersフィールドには、KDCの証明に使用できるクライアントが信頼できるCAのリストが含まれています。各外部プリンシパルディファイアは、CAまたはCA証明書を識別します（それにより、その公開鍵）。"
    },
    {
      "indent": 3,
      "text": "The kdcPkId field of the type PA-PK-AS-REQ contains a CMS type SignerIdentifier encoded according to [RFC3852]. This field identifies, if present, a particular KDC public key that the client already has.",
      "ja": "タイプPA-PK-as-reqのKDCPKIDフィールドには、[RFC3852]に従ってエンコードされたCMS型SignerIdentifierが含まれています。このフィールドは、存在する場合、クライアントがすでに持っている特定のKDC公開キーを特定します。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Receipt of Client Request",
      "section_title": true,
      "ja": "3.2.2. クライアントリクエストの受信"
    },
    {
      "indent": 3,
      "text": "Upon receiving the client's request, the KDC validates it. This section describes the steps that the KDC MUST (unless otherwise noted) take in validating the request.",
      "ja": "クライアントのリクエストを受信すると、KDCはそれを検証します。このセクションでは、KDCがリクエストを検証する際に（特に明記しない限り）必要な手順について説明します。"
    },
    {
      "indent": 3,
      "text": "The KDC verifies the client's signature in the signedAuthPack field according to [RFC3852].",
      "ja": "KDCは、[RFC3852]に従って、Signedauthpackフィールドでのクライアントの署名を検証します。"
    },
    {
      "indent": 3,
      "text": "If, while validating the client's X.509 certificate [RFC3280], the KDC cannot build a certification path to validate the client's certificate, it sends back a KRB-ERROR [RFC4120] message with the code KDC_ERR_CANT_VERIFY_CERTIFICATE. The accompanying e-data for this error message is a TYPED-DATA (as defined in [RFC4120]) that contains an element whose data-type is TD_TRUSTED_CERTIFIERS, and whose data-value contains the DER encoding of the type TD-TRUSTED-CERTIFIERS:",
      "ja": "クライアントのX.509証明書[RFC3280]を検証している間、KDCがクライアントの証明書を検証する認定パスを構築できない場合、コードkdc_er_cant_verify_certificateでkrb-error [rfc4120]メッセージを送り返します。このエラーメッセージの付随するE-DATAは、データタイプがTD_TRUSTED_CERTIFIERSであり、データ値にタイプTD-TRUSTED-CERTIFIERSのDERエンコードが含まれている要素を含むタイピングDATA（[RFC4120]で定義）です。："
    },
    {
      "indent": 7,
      "text": "TD-TRUSTED-CERTIFIERS ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Identifies a list of CAs trusted by the KDC.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each ExternalPrincipalIdentifier (as defined in Section 3.2.1) in the TD-TRUSTED-CERTIFIERS structure identifies a CA or a CA certificate (thereby its public key) trusted by the KDC.",
      "ja": "TD-Trusted-Certifiers構造の各外部プリンシパルディファイア（セクション3.2.1で定義されている）は、KDCによって信頼されるCAまたはCA証明書（それによってその公開鍵）を識別します。"
    },
    {
      "indent": 3,
      "text": "Upon receiving this error message, the client SHOULD retry only if it has a different set of certificates (from those of the previous requests) that form a certification path (or a partial path) from one of the trust anchors acceptable by the KDC to its own certificate.",
      "ja": "このエラーメッセージを受信すると、クライアントは、KDCが受け入れられるトラストアンカーのいずれかからその認定パス（または部分的なパス）を形成する別の証明書（以前の要求の証明書から）の別のセットがある場合にのみ再試行する必要があります。独自の証明書。"
    },
    {
      "indent": 3,
      "text": "If, while processing the certification path, the KDC determines that the signature on one of the certificates in the signedAuthPack field is invalid, it returns a KRB-ERROR [RFC4120] message with the code KDC_ERR_INVALID_CERTIFICATE. The accompanying e-data for this error message is a TYPED-DATA that contains an element whose data-type is TD_INVALID_CERTIFICATES, and whose data-value contains the DER encoding of the type TD-INVALID-CERTIFICATES:",
      "ja": "認証パスの処理中に、KDCがSignedAuthPackフィールドの証明書の1つの署名が無効であると判断した場合、コードKDC_ERR_INVALID_CERTIFICATEでKRB-Error [RFC4120]メッセージを返します。このエラーメッセージに付随するe-Dataは、データタイプがTD_INVALID_CERTIFITATESであり、データ値にはタイプTD-Invalid-Certificatesのderエンコードが含まれている要素を含むタイピングDATAです。"
    },
    {
      "indent": 7,
      "text": "TD-INVALID-CERTIFICATES ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Each ExternalPrincipalIdentifier identifies a\n            -- certificate (sent by the client) with an invalid\n            -- signature.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each ExternalPrincipalIdentifier (as defined in Section 3.2.1) in the TD-INVALID-CERTIFICATES structure identifies a certificate (that was sent by the client) with an invalid signature.",
      "ja": "TD-Invalid-Centificates構造の各外部principaridentifier（セクション3.2.1で定義されている）は、無効な署名で証明書（クライアントが送信した）を識別します。"
    },
    {
      "indent": 3,
      "text": "If more than one X.509 certificate signature is invalid, the KDC MAY include one IssuerAndSerialNumber per invalid signature within the TD-INVALID-CERTIFICATES.",
      "ja": "複数のx.509証明書の署名が無効である場合、KDCには、TD-Invalid認証内の無効な署名ごとに1つの発行者および1つの発行命令が含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "The client's X.509 certificate is validated according to [RFC3280].",
      "ja": "クライアントのX.509証明書は[RFC3280]に従って検証されます。"
    },
    {
      "indent": 3,
      "text": "Depending on local policy, the KDC may also check whether any X.509 certificates in the certification path validating the client's certificate have been revoked. If any of them have been revoked, the KDC MUST return an error message with the code KDC_ERR_REVOKED_CERTIFICATE; if the KDC attempts to determine the revocation status but is unable to do so, it SHOULD return an error message with the code KDC_ERR_REVOCATION_STATUS_UNKNOWN. The certificate or certificates affected are identified exactly as for the error code KDC_ERR_INVALID_CERTIFICATE (see above).",
      "ja": "ローカルポリシーに応じて、KDCは、クライアントの証明書を検証する認証パスのX.509証明書が取り消されているかどうかを確認することもできます。それらのいずれかが取り消されている場合、KDCはコードkdc_err_revoked_certificateでエラーメッセージを返す必要があります。KDCが失効ステータスを決定しようとしたが、そうすることができない場合、コードkdc_err_revocation_status_unknownでエラーメッセージを返す必要があります。影響を受ける証明書または証明書は、エラーコードkdc_err_invalid_certificate（上記を参照）のように正確に識別されます。"
    },
    {
      "indent": 3,
      "text": "Note that the TD_INVALID_CERTIFICATES error data is only used to identify invalid certificates sent by the client in the request.",
      "ja": "TD_INVALID_CERTIFITATESエラーデータは、リクエストでクライアントが送信した無効な証明書を識別するためにのみ使用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The client's public key is then used to verify the signature. If the signature fails to verify, the KDC MUST return an error message with the code KDC_ERR_INVALID_SIG. There is no accompanying e-data for this error message.",
      "ja": "その後、クライアントの公開キーを使用して、署名を確認します。署名が検証に失敗した場合、KDCはコードKDC_ERR_INVALID_SIGでエラーメッセージを返す必要があります。このエラーメッセージには伴うe-Dataはありません。"
    },
    {
      "indent": 3,
      "text": "In addition to validating the client's signature, the KDC MUST also check that the client's public key used to verify the client's signature is bound to the client principal name specified in the AS-REQ as follows:",
      "ja": "クライアントの署名の検証に加えて、KDCは、クライアントの署名を確認するために使用されるクライアントの公開キーが、次のようにAS-REQで指定されたクライアントのプリンシパル名にバインドされていることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "1. If the KDC has its own binding between either the client's signature-verification public key or the client's certificate and the client's Kerberos principal name, it uses that binding.",
      "ja": "1. KDCが、クライアントの署名検証公開キーまたはクライアントの証明書とクライアントのKerberosプリンシパル名のいずれかとの間に独自の拘束力がある場合、そのバインディングを使用します。"
    },
    {
      "indent": 3,
      "text": "2. Otherwise, if the client's X.509 certificate contains a Subject Alternative Name (SAN) extension carrying a KRB5PrincipalName (defined below) in the otherName field of the type GeneralName [RFC3280], it binds the client's X.509 certificate to that name.",
      "ja": "2. それ以外の場合、クライアントのX.509証明書に、型一般名[rfc3280]の他のフィールドにkrb5principalname（以下に定義されている）を運ぶ件名の代替名（san）拡張機能が含まれている場合、クライアントのx.509証明書をその名前に結合します。"
    },
    {
      "indent": 6,
      "text": "The type of the otherName field is AnotherName. The type-id field of the type AnotherName is id-pkinit-san:",
      "ja": "他の名前フィールドのタイプは別の名前です。タイプの別の名前のタイプIDフィールドはid-pkinit-sanです。"
    },
    {
      "indent": 7,
      "text": "id-pkinit-san OBJECT IDENTIFIER ::=\n  { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2)\n    x509SanAN (2) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "And the value field of the type AnotherName is a KRB5PrincipalName.",
      "ja": "そして、別の型のタイプの値フィールドはkrb5principalnameです。"
    },
    {
      "indent": 7,
      "text": "KRB5PrincipalName ::= SEQUENCE {\n    realm                   [0] Realm,\n    principalName           [1] PrincipalName\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the Kerberos client name in the AS-REQ does not match a name bound by the KDC (the binding can be in the certificate, for example, as described above), or if there is no binding found by the KDC, the KDC MUST return an error message with the code KDC_ERR_CLIENT_NAME_MISMATCH. There is no accompanying e-data for this error message.",
      "ja": "AS-REQのKerberosのクライアント名がKDCに縛られた名前と一致しない場合（たとえば、上記のように、バインディングは証明書に含まれる可能性があります）、またはKDCによって結合が見つからない場合、KDCはKDCが必要とする必要があります。コードkdc_err_client_name_mismatchでエラーメッセージを返します。このエラーメッセージには伴うe-Dataはありません。"
    },
    {
      "indent": 3,
      "text": "Even if the certification path is validated and the certificate is mapped to the client's principal name, the KDC may decide not to accept the client's certificate, depending on local policy.",
      "ja": "認定パスが検証され、証明書がクライアントの主名にマッピングされた場合でも、KDCはローカルポリシーに応じてクライアントの証明書を受け入れないことを決定する場合があります。"
    },
    {
      "indent": 3,
      "text": "The KDC MAY require the presence of an Extended Key Usage (EKU) KeyPurposeId [RFC3280] id-pkinit-KPClientAuth in the extensions field of the client's X.509 certificate:",
      "ja": "KDCは、クライアントのx.509証明書の拡張フィールドに拡張キー使用量（EKU）keypurposeId [rfc3280] id-pkinit-kpclientauthの存在を必要とする場合があります。"
    },
    {
      "indent": 7,
      "text": "id-pkinit-KPClientAuth OBJECT IDENTIFIER ::=\n  { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2)\n    pkinit(3) keyPurposeClientAuth(4) }\n       -- PKINIT client authentication.\n       -- Key usage bits that MUST be consistent:\n       -- digitalSignature.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The digitalSignature key usage bit [RFC3280] MUST be asserted when the intended purpose of the client's X.509 certificate is restricted with the id-pkinit-KPClientAuth EKU.",
      "ja": "DigitalSignatureキー使用ビット[RFC3280]は、クライアントのX.509証明書の意図された目的がID-Pkinit-KPClientAuth EKUで制限されている場合に主張する必要があります。"
    },
    {
      "indent": 3,
      "text": "If this EKU KeyPurposeId is required but it is not present, or if the client certificate is restricted not to be used for PKINIT client authentication per Section 4.2.1.13 of [RFC3280], the KDC MUST return an error message of the code KDC_ERR_INCONSISTENT_KEY_PURPOSE. There is no accompanying e-data for this error message. KDCs implementing this requirement SHOULD also accept the EKU KeyPurposeId id-ms-kp-sc-logon (1.3.6.1.4.1.311.20.2.2) as meeting the requirement, as there are a large number of X.509 client certificates deployed for use with PKINIT that have this EKU.",
      "ja": "このEKU keypurposeIDが必要であるが存在しない場合、または[RFC3280]のセクション4.2.1.13ごとにPkinitクライアント認証にクライアント証明書を使用しないように制限されている場合、KDCはコードkdc_err_inconsistent_key_purposeのエラーメッセージを返す必要があります。このエラーメッセージには伴うe-Dataはありません。この要件を実装するKDCSは、EKU KeypurposeId ID-MS-KP-SC-Logon（1.3.6.1.1.4.1.311.20.2.2）も要件を満たしている必要があります。このEKUを持っているPkinitと。"
    },
    {
      "indent": 3,
      "text": "As a matter of local policy, the KDC MAY decide to reject requests on the basis of the absence or presence of other specific EKU OIDs.",
      "ja": "ローカルポリシーの問題として、KDCは、他の特定のEKU OIDの不在または存在に基づいて要求を拒否することを決定する場合があります。"
    },
    {
      "indent": 3,
      "text": "If the digest algorithm used in generating the CA signature for the public key in any certificate of the request is not acceptable by the KDC, the KDC MUST return a KRB-ERROR [RFC4120] message with the code KDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTED. The accompanying e-data MUST be encoded in TYPED-DATA, although none is defined at this point.",
      "ja": "リクエストの証明書の公開鍵のCA署名の生成に使用されるダイジェストアルゴリズムがKDCによって受け入れられない場合、KDCはkdc_err_digest_in_cert_not_acceptedをコードKDC_ERR_DIGEST_IN_CERT_NOT_ACCEPTEDでKRB-Error [RFC4120]メッセージを返す必要があります。添付のe-dataは、この時点で定義されているものはありませんが、typed-dataでエンコードする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client's public key is not accepted with reasons other than those specified above, the KDC returns a KRB-ERROR [RFC4120] message with the code KDC_ERR_CLIENT_NOT_TRUSTED. There is no accompanying e-data currently defined for this error message.",
      "ja": "上記の理由以外の理由でクライアントの公開キーが受け入れられない場合、KDCはコードKDC_ERR_CLIENT_NOT_TRUSTEDを使用してKRB-ERROR [RFC4120]メッセージを返します。このエラーメッセージのために現在定義されているe-DATAは添付されていません。"
    },
    {
      "indent": 3,
      "text": "The KDC MUST check the timestamp to ensure that the request is not a replay, and that the time skew falls within acceptable limits. The recommendations for clock skew times in [RFC4120] apply here. If the check fails, the KDC MUST return error code KRB_AP_ERR_REPEAT or KRB_AP_ERR_SKEW, respectively.",
      "ja": "KDCは、リクエストがリプレイではないこと、および時間のスキューが許容できる制限内にあることを確認するために、タイムスタンプをチェックする必要があります。[RFC4120]の時計スキュー時間の推奨事項はここに適用されます。チェックが失敗した場合、KDCはそれぞれエラーコードkrb_ap_erpeatまたはkrb_ap_err_skewを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "If the clientPublicValue is filled in, indicating that the client wishes to use the Diffie-Hellman key agreement method, the KDC SHOULD check to see if the key parameters satisfy its policy. If they do not, it MUST return an error message with the code KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED. The accompanying e-data is a TYPED-DATA that contains an element whose data-type is TD_DH_PARAMETERS, and whose data-value contains the DER encoding of the type TD-DH-PARAMETERS:",
      "ja": "クライアントパブリックバリューが記入されている場合、クライアントがdiffie-hellmanキー契約法を使用したいことを示している場合、KDCはキーパラメーターがポリシーを満たしているかどうかを確認する必要があります。そうでない場合は、コードkdc_err_dh_key_parameters_not_acceptedでエラーメッセージを返す必要があります。付随するE-DATAは、データタイプがTD_DH_PARAMETERSであり、データ値にはタイプTD-DHパラメーターのDERエンコードが含まれている要素を含むタイプ付きDATAです。"
    },
    {
      "indent": 7,
      "text": "TD-DH-PARAMETERS ::= SEQUENCE OF AlgorithmIdentifier\n            -- Each AlgorithmIdentifier specifies a set of\n            -- Diffie-Hellman domain parameters [IEEE1363].\n            -- This list is in decreasing preference order.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "TD-DH-PARAMETERS contains a list of Diffie-Hellman domain parameters that the KDC supports in decreasing preference order, from which the client SHOULD pick one to retry the request.",
      "ja": "TD-DH-Parametersには、KDCが優先順序を減らすためにサポートするDiffie-Hellmanドメインパラメーターのリストが含まれています。"
    },
    {
      "indent": 3,
      "text": "The AlgorithmIdentifier structure is defined in [RFC3280] and is filled in according to [RFC3279]. More specifically, Section 2.3.3 of [RFC3279] describes how to fill in the AlgorithmIdentifier structure in the case where MODP Diffie-Hellman key exchange is used.",
      "ja": "アルゴリズム材料構造は[RFC3280]で定義されており、[RFC3279]に従って記入されています。より具体的には、[RFC3279]のセクション2.3.3は、MODP Diffie-Hellman Key Exchangeが使用されている場合のアルゴリズムIdentifier構造に記入する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "If the client included a kdcPkId field in the PA-PK-AS-REQ and the KDC does not possess the corresponding key, the KDC MUST ignore the kdcPkId field as if the client did not include one.",
      "ja": "クライアントがPA-PK-as-reqにKDCPKIDフィールドを含め、KDCが対応するキーを所有していない場合、KDCはクライアントにそれを含めていないかのようにKDCPKIDフィールドを無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the digest algorithm used by the id-pkinit-authData is not acceptable by the KDC, the KDC MUST return a KRB-ERROR [RFC4120] message with the code KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED. The accompanying e-data MUST be encoded in TYPED-DATA, although none is defined at this point.",
      "ja": "id-pkinit-authdataで使用されるダイジェストアルゴリズムがKDCで受け入れられない場合、KDCはkdc_err_er_digest_in_signed_data_not_acectedでcode kdc_err_digest_in_signed_data_not_acceptedを使用してKRB-error [RFC4120]メッセージを返す必要があります。添付のe-dataは、この時点で定義されているものはありませんが、typed-dataでエンコードする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Generation of KDC Reply",
      "section_title": true,
      "ja": "3.2.3. KDC返信の生成"
    },
    {
      "indent": 3,
      "text": "If the paChecksum filed in the request is not present, the KDC conforming to this specification MUST return a KRB-ERROR [RFC4120] message with the code KDC_ERR_PA_CHECKSUM_MUST_BE_INCLUDED. The accompanying e-data MUST be encoded in TYPED-DATA (no error data is defined by this specification).",
      "ja": "リクエストに提出されたpachecumが存在しない場合、この仕様に準拠したKDCは、コードkdc_err_pa_checksum_must_be_inudedでkrb-error [rfc4120]メッセージを返す必要があります。添付のe-dataは、typed-dataでエンコードする必要があります（この仕様によってエラーデータは定義されていません）。"
    },
    {
      "indent": 3,
      "text": "Assuming that the client's request has been properly validated, the KDC proceeds as per [RFC4120], except as follows.",
      "ja": "クライアントの要求が適切に検証されていると仮定すると、次のようにKDCは[RFC4120]に従って進行します。"
    },
    {
      "indent": 3,
      "text": "The KDC MUST set the initial flag and include an authorization data element of ad-type [RFC4120] AD_INITIAL_VERIFIED_CAS in the issued ticket. The ad-data [RFC4120] field contains the DER encoding of the type AD-INITIAL-VERIFIED-CAS:",
      "ja": "KDCは、最初のフラグを設定し、発行されたチケットにADタイプ[RFC4120] AD_INITIAL_VERIFIED_CASの承認データ要素を含める必要があります。AD-DATA [RFC4120]フィールドには、AD-Initial-Verified-CAのタイプのderエンコードが含まれています。"
    },
    {
      "indent": 7,
      "text": "AD-INITIAL-VERIFIED-CAS ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Identifies the certification path with which\n            -- the client certificate was validated.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The AD-INITIAL-VERIFIED-CAS structure identifies the certification path with which the client certificate was validated. Each ExternalPrincipalIdentifier (as defined in Section 3.2.1) in the AD-INITIAL-VERIFIED-CAS structure identifies a CA or a CA certificate (thereby its public key).",
      "ja": "AD-Initial-Verified-CAS構造は、クライアント証明書が検証された認証パスを識別します。AD-Initial-Verified-CAS構造の各外部プリンシパルディファイア（セクション3.2.1で定義されている）は、CAまたはCA証明書（それによって公開鍵）を識別します。"
    },
    {
      "indent": 3,
      "text": "Note that the syntax for the AD-INITIAL-VERIFIED-CAS authorization data does permit empty SEQUENCEs to be encoded. Such empty sequences may only be used if the KDC itself vouches for the user's certificate.",
      "ja": "AD-Initial-Verified-CAS認証データの構文では、空のシーケンスをエンコードできることに注意してください。このような空のシーケンスは、KDC自体がユーザーの証明書を保証する場合にのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "The AS wraps any AD-INITIAL-VERIFIED-CAS data in AD-IF-RELEVANT containers if the list of CAs satisfies the AS' realm's local policy (this corresponds to the TRANSITED-POLICY-CHECKED ticket flag [RFC4120]). Furthermore, any TGS MUST copy such authorization data from tickets used within a PA-TGS-REQ of the TGS-REQ into the resulting ticket. If the list of CAs satisfies the local KDC's realm's policy, the TGS MAY wrap the data into the AD-IF-RELEVANT container; otherwise, it MAY unwrap the authorization data out of the AD-IF-RELEVANT container.",
      "ja": "ASは、CASのリストが「レルム」のローカルポリシーを満たしている場合、AD-IF関連コンテナのAD-Initial-Verified-CASデータをラップします（これは、トランジーされたポリシーチェックチケットフラグ[RFC4120]に対応しています）。さらに、TGSは、TGS-REQのPA-TGS-REQ内で使用されているチケットから、結果のチケットにそのような承認データをコピーする必要があります。CASのリストがローカルKDCの領域のポリシーを満たしている場合、TGSはデータをAD-IF関連のコンテナに包むことができます。それ以外の場合は、AD-IFリレッドコンテナから承認データを解除する場合があります。"
    },
    {
      "indent": 3,
      "text": "Application servers that understand this authorization data type SHOULD apply local policy to determine whether a given ticket bearing such a type *not* contained within an AD-IF-RELEVANT container is acceptable. (This corresponds to the AP server's checking the transited field when the TRANSITED-POLICY-CHECKED flag has not been set [RFC4120].) If such a data type is contained within an AD-IF-RELEVANT container, AP servers MAY apply local policy to determine whether the authorization data is acceptable.",
      "ja": "この承認データ型を理解しているアプリケーションサーバーは、ローカルポリシーを適用して、AD-IFリレッドコンテナ内に含まれる * not * not * not *が付属している特定のチケットが受け入れられるかどうかを判断する必要があります。（これは、Transited-Policy-Checked Flagが設定されていない場合にAPサーバーが通過フィールドをチェックすることに対応します[RFC4120]。）そのようなデータ型がAD-IF関連コンテナ内に含まれている場合、APサーバーはローカルポリシーを適用する場合があります承認データが許容できるかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "A pre-authentication data element, whose padata-type is PA_PK_AS_REP and whose padata-value contains the DER encoding of the type PA-PK-AS-REP (defined below), is included in the AS-REP [RFC4120].",
      "ja": "PadataタイプがPA_PK_AS_REPであり、PADATA-VALUEにはタイプPA-PK-AS-REP（以下に定義）のderエンコードが含まれていること（以下に定義）が含まれていることがあります[RFC4120]に含まれています。"
    },
    {
      "indent": 7,
      "text": "PA-PK-AS-REP ::= CHOICE {\n   dhInfo                  [0] DHRepInfo,\n            -- Selected when Diffie-Hellman key exchange is\n            -- used.\n   encKeyPack              [1] IMPLICIT OCTET STRING,\n            -- Selected when public key encryption is used.\n            -- Contains a CMS type ContentInfo encoded",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            -- according to [RFC3852].\n            -- The contentType field of the type ContentInfo is\n            -- id-envelopedData (1.2.840.113549.1.7.3).\n            -- The content field is an EnvelopedData.\n            -- The contentType field for the type EnvelopedData\n            -- is id-signedData (1.2.840.113549.1.7.2).\n            -- The eContentType field for the inner type\n            -- SignedData (when unencrypted) is\n            -- id-pkinit-rkeyData (1.3.6.1.5.2.3.3) and the\n            -- eContent field contains the DER encoding of the\n            -- type ReplyKeyPack.\n            -- ReplyKeyPack is defined in Section 3.2.3.2.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "DHRepInfo ::= SEQUENCE {\n   dhSignedData            [0] IMPLICIT OCTET STRING,\n            -- Contains a CMS type ContentInfo encoded according\n            -- to [RFC3852].\n            -- The contentType field of the type ContentInfo is\n            -- id-signedData (1.2.840.113549.1.7.2), and the\n            -- content field is a SignedData.\n            -- The eContentType field for the type SignedData is\n            -- id-pkinit-DHKeyData (1.3.6.1.5.2.3.2), and the\n            -- eContent field contains the DER encoding of the\n            -- type KDCDHKeyInfo.\n            -- KDCDHKeyInfo is defined below.\n   serverDHNonce           [1] DHNonce OPTIONAL,\n            -- Present if and only if dhKeyExpiration is\n            -- present in the KDCDHKeyInfo.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "KDCDHKeyInfo ::= SEQUENCE {\n   subjectPublicKey        [0] BIT STRING,\n            -- The KDC's DH public key.\n            -- The DH public key value is encoded as a BIT\n            -- STRING according to [RFC3279].\n   nonce                   [1] INTEGER (0..4294967295),\n            -- Contains the nonce in the pkAuthenticator field\n            -- in the request if the DH keys are NOT reused,\n            -- 0 otherwise.\n   dhKeyExpiration         [2] KerberosTime OPTIONAL,\n            -- Expiration time for KDC's key pair,\n            -- present if and only if the DH keys are reused.\n            -- If present, the KDC's DH public key MUST not be\n            -- used past the point of this expiration time.\n            -- If this field is omitted then the serverDHNonce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " -- field MUST also be omitted. ... }",
      "ja": " - フィールドも省略する必要があります。...}"
    },
    {
      "indent": 3,
      "text": "The content of the AS-REP is otherwise unchanged from [RFC4120]. The KDC encrypts the reply as usual, but not with the client's long-term key. Instead, it encrypts it with either a shared key derived from a Diffie-Hellman exchange or a generated encryption key. The contents of the PA-PK-AS-REP indicate which key delivery method is used.",
      "ja": "それ以外の場合は、AS-REPの含有量は[RFC4120]から変更されていません。KDCは、通常どおり返信を暗号化しますが、クライアントの長期キーを使用しません。代わりに、Diffie-Hellman Exchangeから派生した共有キーまたは生成された暗号化キーのいずれかで暗号化します。PA-PK-AS-REPの内容は、どのキー配信方法が使用されているかを示しています。"
    },
    {
      "indent": 3,
      "text": "If the client does not wish to use the Diffie-Hellman key delivery method (the clientPublicValue field is not present in the request) and the KDC does not support the public key encryption key delivery method, the KDC MUST return an error message with the code KDC_ERR_PUBLIC_KEY_ENCRYPTION_NOT_SUPPORTED. There is no accompanying e-data for this error message.",
      "ja": "クライアントがdiffie-hellmanキー配信方法を使用したくない場合（クライアントパブリックバリューフィールドはリクエストに存在しません）、KDCが公開キー暗号化キー配信方法をサポートしていない場合、KDCはコードでエラーメッセージを返す必要がありますkdc_err_public_key_encryption_not_supported。このエラーメッセージには伴うe-Dataはありません。"
    },
    {
      "indent": 3,
      "text": "In addition, the lifetime of the ticket returned by the KDC MUST NOT exceed that of the client's public-private key pair. The ticket lifetime, however, can be shorter than that of the client's public-private key pair. For the implementations of this specification, the lifetime of the client's public-private key pair is the validity period in X.509 certificates [RFC3280], unless configured otherwise.",
      "ja": "さらに、KDCによって返されたチケットの寿命は、クライアントの官民キーペアの寿命を超えてはなりません。ただし、チケットの寿命は、クライアントの官民キーペアよりも短くなる可能性があります。この仕様の実装では、クライアントの官民キーペアの寿命は、特に構成されていない限り、X.509証明書[RFC3280]の有効期間です。"
    },
    {
      "indent": 0,
      "text": "3.2.3.1. Using Diffie-Hellman Key Exchange",
      "section_title": true,
      "ja": "3.2.3.1. diffie-hellmanキーエクスチェンジを使用します"
    },
    {
      "indent": 3,
      "text": "In this case, the PA-PK-AS-REP contains a DHRepInfo structure.",
      "ja": "この場合、PA-PK-AS-REPにはDHREPINFO構造が含まれています。"
    },
    {
      "indent": 3,
      "text": "The ContentInfo [RFC3852] structure for the dhSignedData field is filled in as follows:",
      "ja": "dhsignedDataフィールドのContentInfo [RFC3852]構造は、次のように記入されています。"
    },
    {
      "indent": 3,
      "text": "1. The contentType field of the type ContentInfo is id-signedData (as defined in [RFC3852]), and the content field is a SignedData (as defined in [RFC3852]).",
      "ja": "1. 型ContentInfoのContentTypeフィールドはID-SignedData（[RFC3852]で定義されています）であり、コンテンツフィールドはSignedData（[RFC3852]で定義されています）です。"
    },
    {
      "indent": 3,
      "text": "2. The eContentType field for the type SignedData is the OID value for id-pkinit-DHKeyData: { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2) pkinit(3) DHKeyData(2) }. Notes to CMS implementers: the signed attribute content-type MUST be present in this SignedData instance, and its value is id-pkinit-DHKeyData according to [RFC3852].",
      "ja": "2. タイプSignedDataのecontentTypeフィールドは、id-pkinit-dhkeydataのoid値です：{iso（1）org（3）dod（6）インターネット（1）セキュリティ（5）kerberosv5（2）pkinit（3）dhkeydata（2 2））}。CMS実装者へのメモ：署名された属性コンテンツタイプは、このsignedDataインスタンスに存在する必要があり、その値は[RFC3852]によるとid-pkinit-dhkeydataです。"
    },
    {
      "indent": 3,
      "text": "3. The eContent field for the type SignedData contains the DER encoding of the type KDCDHKeyInfo.",
      "ja": "3. タイプSignedDataのecontentフィールドには、型kdcdhkeyinfoのderエンコードが含まれています。"
    },
    {
      "indent": 3,
      "text": "4. The KDCDHKeyInfo structure contains the KDC's public key, a nonce, and, optionally, the expiration time of the KDC's DH key being reused. The subjectPublicKey field of the type KDCDHKeyInfo field identifies KDC's DH public key. This DH public key value is encoded as a BIT STRING according to [RFC3279]. The nonce field contains the nonce in the pkAuthenticator field in the request if the DH keys are NOT reused. The value of this nonce field is 0 if the DH keys are reused. The dhKeyExpiration field is present if and only if the DH keys are reused. If the dhKeyExpiration field is present, the KDC's public key in this KDCDHKeyInfo structure MUST NOT be used past the point of this expiration time. If this field is omitted, then the serverDHNonce field MUST also be omitted.",
      "ja": "4. KDCDHKEYINFO構造には、KDCの公開鍵、NonCE、およびオプションで、KDCのDHキーの有効期限が再利用されています。型KDCDHKEYINFOフィールドの件名フィールドは、KDCのDH公開キーを識別します。このDH公開値は、[RFC3279]に従って少し文字列としてエンコードされます。NonCeフィールドには、DHキーが再利用されない場合、リクエスト内のPKAuthenticatorフィールドのNonCEが含まれています。DHキーが再利用されている場合、この非CEフィールドの値は0です。DHキーが再利用されている場合にのみ、dhkeyExpirationフィールドが存在します。dhkeyExpirationフィールドが存在する場合、このKDCDHKEYINFO構造のKDCの公開鍵は、この有効期限のポイントを過ぎて使用してはなりません。このフィールドが省略されている場合、ServerDhnonceフィールドも省略する必要があります。"
    },
    {
      "indent": 3,
      "text": "5. The signerInfos field of the type SignedData contains a single signerInfo, which contains the signature over the type KDCDHKeyInfo.",
      "ja": "5. タイプのSignedDataのSignerInFosフィールドには、型Kdcdhkeyinfo上の署名が含まれる単一のSignerinfoが含まれています。"
    },
    {
      "indent": 3,
      "text": "6. The certificates field of the type SignedData contains certificates intended to facilitate certification path construction, so that the client can verify the KDC's signature over the type KDCDHKeyInfo. The information contained in the trustedCertifiers in the request SHOULD be used by the KDC as hints to guide its selection of an appropriate certificate chain to return to the client. This field may be left empty if the KDC public key specified by the kdcPkId field in the PA-PK-AS-REQ was used for signing. Otherwise, for path validation, these certificates SHOULD be sufficient to construct at least one certification path from the KDC certificate to one trust anchor acceptable by the client [RFC4158]. The KDC MUST be capable of including such a set of certificates if configured to do so. The certificates field MUST NOT contain \"root\" CA certificates.",
      "ja": "6. タイプSignedDataの証明書フィールドには、クライアントがKDCDHKEYINFOのKDCの署名を検証できるように、認定パス構築を促進することを目的とした証明書が含まれています。リクエストに含まれる信頼性の高い項に含まれる情報は、KDCがクライアントに戻すための適切な証明書チェーンの選択をガイドするためのヒントとして使用する必要があります。このフィールドは、PA-PK-as-reqのKDCPKIDフィールドで指定されたKDC公開キーが署名に使用された場合、空のままになる場合があります。それ以外の場合、PATH検証の場合、これらの証明書は、KDC証明書からクライアントが許容できる1つの信頼アンカーに少なくとも1つの認証パスを構築するのに十分である必要があります[RFC4158]。KDCは、そうするように設定されている場合、そのような一連の証明書を含めることができなければなりません。証明書フィールドには、「ルート」CA証明書を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "7. If the client included the clientDHNonce field, then the KDC may choose to reuse its DH keys. If the server reuses DH keys, then it MUST include an expiration time in the dhKeyExpiration field. Past the point of the expiration time, the signature over the type DHRepInfo is considered expired/invalid. When the server reuses DH keys then, it MUST include a serverDHNonce at least as long as the length of keys for the symmetric encryption system used to encrypt the AS reply. Note that including the serverDHNonce changes how the client and server calculate the key to use to encrypt the reply; see below for details. The KDC SHOULD NOT reuse DH keys unless the clientDHNonce field is present in the request.",
      "ja": "7. クライアントがClientDhnonceフィールドを含めた場合、KDCはDHキーを再利用することを選択できます。サーバーがDHキーを再利用する場合、DHKeyExpirationフィールドに有効期限時間を含める必要があります。有効期限のポイントを過ぎると、dhrepinfoのタイプ上の署名は期限切れ/無効と見なされます。サーバーがDHキーを再利用する場合、少なくともAs As Asの暗号化に使用される対称暗号化システムのキーの長さを少なくともserverdhnonceを含める必要があります。ServerDhnonceを含めることは、クライアントとサーバーが応答を暗号化するために使用するキーを計算する方法を変更することに注意してください。詳細については、以下をご覧ください。KDCは、クライアントDhnonceフィールドがリクエストに存在しない限り、DHキーを再利用しないでください。"
    },
    {
      "indent": 3,
      "text": "The AS reply key is derived as follows:",
      "ja": "As As Replyキーは次のように導き出されます。"
    },
    {
      "indent": 3,
      "text": "1. Both the KDC and the client calculate the shared secret value as follows:",
      "ja": "1. KDCとクライアントの両方が、次のように共有秘密の値を計算します。"
    },
    {
      "indent": 10,
      "text": "a) When MODP Diffie-Hellman is used, let DHSharedSecret be the shared secret value. DHSharedSecret is the value ZZ, as described in Section 2.1.1 of [RFC2631].",
      "ja": "a) Modp Diffie-Hellmanを使用する場合、DhsharedSecretを共有秘密の価値とします。DhsharedSecretは、[RFC2631]のセクション2.1.1で説明されているように、値ZZです。"
    },
    {
      "indent": 6,
      "text": "DHSharedSecret is first padded with leading zeros such that the size of DHSharedSecret in octets is the same as that of the modulus, then represented as a string of octets in big-endian order.",
      "ja": "dhsharedSecretは、最初に先頭のゼロで詰め込まれているため、オクテットのdhsharedsecretのサイズはモジュラスのサイズと同じであり、その後、ビッグエンディアンの順序でオクテットのストリングとして表されます。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Both the client and the KDC can cache the triple (ya, yb, DHSharedSecret), where ya is the client's public key and yb is the KDC's public key. If both ya and yb are the same in a later exchange, the cached DHSharedSecret can be used.",
      "ja": "実装注：クライアントとKDCの両方がトリプル（YA、YB、DHSHAREDSECRET）をキャッシュできます。ここで、YAはクライアントの公開キーであり、YBはKDCの公開キーです。YAとYBの両方が後の交換で同じである場合、キャッシュされたdhsharedSecretを使用できます。"
    },
    {
      "indent": 3,
      "text": "2. Let K be the key-generation seed length [RFC3961] of the AS reply key whose enctype is selected according to [RFC4120].",
      "ja": "2. Kを、[RFC4120]に従ってenctypeが選択されているAs応答キーのキージェネレーションシード長[RFC3961]を使用します。"
    },
    {
      "indent": 3,
      "text": "3. Define the function octetstring2key() as follows:",
      "ja": "3. 次のように関数octetString2key（）を定義します。"
    },
    {
      "indent": 11,
      "text": "octetstring2key(x) == random-to-key(K-truncate(\n                         SHA1(0x00 | x) |\n                         SHA1(0x01 | x) |\n                         SHA1(0x02 | x) |\n                         ...\n                         ))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "where x is an octet string; | is the concatenation operator; 0x00, 0x01, 0x02, etc. are each represented as a single octet; random-to-key() is an operation that generates a protocol key from a bitstring of length K; and K-truncate truncates its input to the first K bits. Both K and random-to-key() are as defined in the kcrypto profile [RFC3961] for the enctype of the AS reply key.",
      "ja": "ここで、xはオクテット文字列です。|連結演算子です。0x00、0x01、0x02などはそれぞれ単一のオクテットとして表されます。ランダムキー（）は、長さkのビットストリングからプロトコルキーを生成する操作です。K-Truncateは、最初のKビットへの入力を切り捨てます。Kとランダムからキー（）の両方は、As As Reply KeyのenctypeのKcryptoプロファイル[RFC3961]で定義されています。"
    },
    {
      "indent": 3,
      "text": "4. When DH keys are reused, let n_c be the clientDHNonce and n_k be the serverDHNonce; otherwise, let both n_c and n_k be empty octet strings.",
      "ja": "4. DHキーが再利用されたら、n_cをclientdhnonceにし、n_kをserverdhnonceとします。それ以外の場合は、N_CとN_Kの両方を空のオクテット文字列にします。"
    },
    {
      "indent": 3,
      "text": "5. The AS reply key k is: k = octetstring2key(DHSharedSecret | n_c | n_k)",
      "ja": "5. As As Reply Key Kは次のとおりです。K= OctetString2Key（dhsharedSecret | n_c | n_k）"
    },
    {
      "indent": 0,
      "text": "3.2.3.2. Using Public Key Encryption",
      "section_title": true,
      "ja": "3.2.3.2. 公開キーの暗号化を使用します"
    },
    {
      "indent": 3,
      "text": "In this case, the PA-PK-AS-REP contains the encKeyPack field where the AS reply key is encrypted.",
      "ja": "この場合、PA-PK-AS-REPには、As As Replyキーが暗号化されているEnckeyPackフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "The ContentInfo [RFC3852] structure for the encKeyPack field is filled in as follows: 1. The contentType field of the type ContentInfo is id-envelopedData (as defined in [RFC3852]), and the content field is an EnvelopedData (as defined in [RFC3852]).",
      "ja": "EnckeyPackフィールドのContentInfo [RFC3852]構造は次のように入力されます。1。型ContentInfoのContentTypeフィールドはID-EnvelopedData（[RFC3852]で定義されています）であり、コンテンツフィールドは[包括的な]です（[で定義されています）RFC3852]）。"
    },
    {
      "indent": 3,
      "text": "2. The contentType field for the type EnvelopedData is id-signedData: { iso (1) member-body (2) us (840) rsadsi (113549) pkcs (1) pkcs7 (7) signedData (2) }.",
      "ja": "2. 型EnvelopedDataのContentTypeフィールドはID-SignedDataです。"
    },
    {
      "indent": 3,
      "text": "3. The eContentType field for the inner type SignedData (when decrypted from the encryptedContent field for the type EnvelopedData) is id-pkinit-rkeyData: { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2) pkinit(3) rkeyData(3) }. Notes to CMS implementers: the signed attribute content-type MUST be present in this SignedData instance, and its value is id-pkinit-rkeyData according to [RFC3852].",
      "ja": "3. 内側のタイプのsignedDataのecontentTypeフィールド（タイプEnvelopedDataの暗号化されたコンテンツフィールドから復号化された場合）はID-Pkinit-rkeyDataです：{ISO（1）org（6）dod（6）インターネット（1）セキュリティ（5）kerberosv5（2）pkinit（3）rkeydata（3）}。CMS実装者へのメモ：署名された属性コンテンツタイプは、このsignedDataインスタンスに存在する必要があり、その値は[RFC3852]によるとid-pkinit-rkeydataです。"
    },
    {
      "indent": 3,
      "text": "4. The eContent field for the inner type SignedData contains the DER encoding of the type ReplyKeyPack (as described below).",
      "ja": "4. 内側のタイプのsignedDataのecontentフィールドには、型ReplyKeypackのderエンコードが含まれています（以下に説明します）。"
    },
    {
      "indent": 3,
      "text": "5. The signerInfos field of the inner type SignedData contains a single signerInfo, which contains the signature for the type ReplyKeyPack.",
      "ja": "5. 内側のタイプのSignerInfosフィールドには、SignedDataが1つのSignerinfoが含まれています。"
    },
    {
      "indent": 3,
      "text": "6. The certificates field of the inner type SignedData contains certificates intended to facilitate certification path construction, so that the client can verify the KDC's signature for the type ReplyKeyPack. The information contained in the trustedCertifiers in the request SHOULD be used by the KDC as hints to guide its selection of an appropriate certificate chain to return to the client. This field may be left empty if the KDC public key specified by the kdcPkId field in the PA-PK-AS-REQ was used for signing. Otherwise, for path validation, these certificates SHOULD be sufficient to construct at least one certification path from the KDC certificate to one trust anchor acceptable by the client [RFC4158]. The KDC MUST be capable of including such a set of certificates if configured to do so. The certificates field MUST NOT contain \"root\" CA certificates.",
      "ja": "6. 内側のタイプのsignedDataの証明書フィールドには、認定パス構築を促進することを目的とした証明書が含まれているため、クライアントは型ReplyKeypackのKDCの署名を確認できます。リクエストに含まれる信頼性の高い項に含まれる情報は、KDCがクライアントに戻すための適切な証明書チェーンの選択をガイドするためのヒントとして使用する必要があります。このフィールドは、PA-PK-as-reqのKDCPKIDフィールドで指定されたKDC公開キーが署名に使用された場合、空のままになる場合があります。それ以外の場合、PATH検証の場合、これらの証明書は、KDC証明書からクライアントが許容できる1つの信頼アンカーに少なくとも1つの認証パスを構築するのに十分である必要があります[RFC4158]。KDCは、そうするように設定されている場合、そのような一連の証明書を含めることができなければなりません。証明書フィールドには、「ルート」CA証明書を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "7. The recipientInfos field of the type EnvelopedData is a SET that MUST contain exactly one member of type KeyTransRecipientInfo. The encryptedKey of this member contains the temporary key that is encrypted using the client's public key.",
      "ja": "7. タイプEnvelopedDataのReciontientInfosフィールドは、型KeyTransrecipientInfoのメンバーを正確に1つ含む必要があるセットです。このメンバーの暗号化されたキーには、クライアントの公開キーを使用して暗号化された一時キーが含まれています。"
    },
    {
      "indent": 3,
      "text": "8. The unprotectedAttrs or originatorInfo fields of the type EnvelopedData MAY be present.",
      "ja": "8. タイプエンベロープドダタの無保護型のフィールドまたはOriginatorInfoフィールドが存在する可能性があります。"
    },
    {
      "indent": 3,
      "text": "If there is a supportedCMSTypes field in the AuthPack, the KDC must check to see if it supports any of the listed types. If it supports more than one of the types, the KDC SHOULD use the one listed first. If it does not support any of them, it MUST return an error message with the code KDC_ERR_ETYPE_NOSUPP [RFC4120].",
      "ja": "authpackにサポートされているcmstypesフィールドがある場合、KDCは、リストされているタイプのいずれかをサポートするかどうかを確認する必要があります。複数のタイプをサポートしている場合、KDCは最初にリストされているものを使用する必要があります。それらのいずれかをサポートしていない場合、コードKDC_ERR_ETYPE_NOSUPP [RFC4120]を使用してエラーメッセージを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the KDC computes the checksum of the AS-REQ in the client request. This checksum is performed over the type AS-REQ, and the protocol key [RFC3961] of the checksum operation is the replyKey, and the key usage number is 6. If the replyKey's enctype is \"newer\" [RFC4120] [RFC4121], the checksum operation is the required checksum operation [RFC3961] of that enctype.",
      "ja": "さらに、KDCはクライアント要求のAS-REQのチェックサムを計算します。このチェックサムは、チェックサム操作のProtocolキー[RFC3961]がReplyKeyであり、キー使用数が6である場合、このチェックサムは実行されます。チェックサム操作は、そのenctypeの必要なチェックサム操作[RFC3961]です。"
    },
    {
      "indent": 7,
      "text": "ReplyKeyPack ::= SEQUENCE {\n   replyKey                [0] EncryptionKey,\n            -- Contains the session key used to encrypt the\n            -- enc-part field in the AS-REP, i.e., the\n            -- AS reply key.\n   asChecksum              [1] Checksum,\n           -- Contains the checksum of the AS-REQ\n           -- corresponding to the containing AS-REP.\n           -- The checksum is performed over the type AS-REQ.\n           -- The protocol key [RFC3961] of the checksum is the\n           -- replyKey and the key usage number is 6.\n           -- If the replyKey's enctype is \"newer\" [RFC4120]\n           -- [RFC4121], the checksum is the required\n           -- checksum operation [RFC3961] for that enctype.\n           -- The client MUST verify this checksum upon receipt\n           -- of the AS-REP.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Implementations of this RSA encryption key delivery method are RECOMMENDED to support RSA keys at least 2048 bits in size.",
      "ja": "このRSA暗号化キー配信方法の実装は、少なくとも2048ビットのサイズをサポートするために推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Receipt of KDC Reply",
      "section_title": true,
      "ja": "3.2.4. KDC返信の受領"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the KDC's reply, the client proceeds as follows. If the PA-PK-AS-REP contains the dhSignedData field, the client derives the AS reply key using the same procedure used by the KDC, as defined in Section 3.2.3.1. Otherwise, the message contains the encKeyPack field, and the client decrypts and extracts the temporary key in the encryptedKey field of the member KeyTransRecipientInfo and then uses that as the AS reply key.",
      "ja": "KDCの返信を受け取ると、クライアントは次のように進みます。PA-PK-AS-REPにDHSIGNEDDATAフィールドが含まれている場合、クライアントは、セクション3.2.3.1で定義されているように、KDCで使用される同じ手順を使用してAs As Replyキーを導き出します。それ以外の場合、メッセージにはEnckeyPackフィールドが含まれ、クライアントはメンバーKeyTransRecipientInfoの暗号化されたキーフィールドの一時キーを解読および抽出し、それをAs As Reply Keyとして使用します。"
    },
    {
      "indent": 3,
      "text": "If the public key encryption method is used, the client MUST verify the asChecksum contained in the ReplyKeyPack.",
      "ja": "公開キー暗号化方法が使用されている場合、クライアントはReplyKeyPackに含まれるaschecksumを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "In either case, the client MUST verify the signature in the SignedData according to [RFC3852]. The KDC's X.509 certificate MUST be validated according to [RFC3280]. In addition, unless the client can otherwise verify that the public key used to verify the KDC's signature is bound to the KDC of the target realm, the KDC's X.509 certificate MUST contain a Subject Alternative Name extension [RFC3280] carrying an AnotherName whose type-id is id-pkinit-san (as defined in Section 3.2.2) and whose value is a KRB5PrincipalName that matches the name of the TGS of the target realm (as defined in Section 7.3 of [RFC4120]).",
      "ja": "どちらの場合でも、クライアントは[RFC3852]に従って署名dataの署名を検証する必要があります。KDCのX.509証明書は、[RFC3280]に従って検証する必要があります。さらに、クライアントがKDCの署名を検証するために使用される公開キーがターゲットレルムのKDCにバインドされていることを確認できない限り、KDCのX.509証明書には、タイプの別の名前を運ぶサブジェクトの代替名拡張[RFC3280]を含める必要があります。-idはid-pkinit-san（セクション3.2.2で定義されている）であり、その値はターゲットレルムのTGSの名前と一致するKrb5PrincipalNameです（[RFC4120]のセクション7.3で定義）。"
    },
    {
      "indent": 3,
      "text": "Unless the client knows by some other means that the KDC certificate is intended for a Kerberos KDC, the client MUST require that the KDC certificate contains the EKU KeyPurposeId [RFC3280] id-pkinit-KPKdc:",
      "ja": "クライアントがKDC証明書がKerberos KDCを対象としていることを他のいくつかの手段で知っていない限り、クライアントはKDC証明書にEKU keypurposeId [rfc3280] id-pkinit-kpkdcを含むことを要求する必要があります。"
    },
    {
      "indent": 7,
      "text": "id-pkinit-KPKdc OBJECT IDENTIFIER ::=\n  { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2)\n    pkinit(3) keyPurposeKdc(5) }\n       -- Signing KDC responses.\n       -- Key usage bits that MUST be consistent:\n       -- digitalSignature.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The digitalSignature key usage bit [RFC3280] MUST be asserted when the intended purpose of the KDC's X.509 certificate is restricted with the id-pkinit-KPKdc EKU.",
      "ja": "DigitalSignatureキー使用ビット[RFC3280]は、KDCのX.509証明書の意図された目的がID-Pkinit-KPKDC EKUで制限されている場合に主張する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the KDC certificate contains the Kerberos TGS name encoded as an id-pkinit-san SAN, this certificate is certified by the issuing CA as a KDC certificate, therefore the id-pkinit-KPKdc EKU is not required.",
      "ja": "KDC証明書にID-Pkinit-san SANとしてエンコードされたKerberos TGS名が含まれている場合、この証明書はKDC証明書としてCAを発行することによって認定されているため、ID-Pkinit-KPKDC EKUは必要ありません。"
    },
    {
      "indent": 3,
      "text": "If all applicable checks are satisfied, the client then decrypts the enc-part field of the KDC-REP in the AS-REP, using the AS reply key, and then proceeds as described in [RFC4120].",
      "ja": "該当するすべてのチェックが満たされている場合、クライアントはAS応答キーを使用して、AS-REPのKDC-REPのエンクパートフィールドを復号化し、[RFC4120]に記載されているように進みます。"
    },
    {
      "indent": 0,
      "text": "3.3. Interoperability Requirements",
      "section_title": true,
      "ja": "3.3. 相互運用性要件"
    },
    {
      "indent": 3,
      "text": "The client MUST be capable of sending a set of certificates sufficient to allow the KDC to construct a certification path for the client's certificate, if the correct set of certificates is provided through configuration or policy.",
      "ja": "クライアントは、構成またはポリシーを通じて正しい証明書セットが提供されている場合、KDCがクライアントの証明書の認定パスを構築できるようにするのに十分な証明書セットを送信できる必要があります。"
    },
    {
      "indent": 3,
      "text": "If the client sends all the X.509 certificates on a certification path to a trust anchor acceptable by the KDC, and if the KDC cannot verify the client's public key otherwise, the KDC MUST be able to process path validation for the client's certificate based on the certificates in the request.",
      "ja": "クライアントがKDCが許容できる信頼アンカーへの認定パスでクライアントがすべてのX.509証明書を送信し、KDCがクライアントの公開キーを確認できない場合、KDCは、に基づいてクライアントの証明書のパス検証を処理できる必要があります。リクエスト内の証明書。"
    },
    {
      "indent": 3,
      "text": "The KDC MUST be capable of sending a set of certificates sufficient to allow the client to construct a certification path for the KDC's certificate, if the correct set of certificates is provided through configuration or policy.",
      "ja": "KDCは、正しい証明書が構成またはポリシーを通じて提供されている場合、クライアントがKDCの証明書の認定パスを構築できるようにするのに十分な証明書セットを送信できる必要があります。"
    },
    {
      "indent": 3,
      "text": "If the KDC sends all the X.509 certificates on a certification path to a trust anchor acceptable by the client, and the client can not verify the KDC's public key otherwise, the client MUST be able to process path validation for the KDC's certificate based on the certificates in the reply.",
      "ja": "KDCがクライアントが許容できる信頼アンカーへの認定パスですべてのX.509証明書を送信し、クライアントがKDCの公開キーを確認できない場合、クライアントはKDCの証明書のパス検証を処理できる必要があります。返信の証明書。"
    },
    {
      "indent": 0,
      "text": "3.4. KDC Indication of PKINIT Support",
      "section_title": true,
      "ja": "3.4. PkinitサポートのKDC表示"
    },
    {
      "indent": 3,
      "text": "If pre-authentication is required but was not present in the request, per [RFC4120] an error message with the code KDC_ERR_PREAUTH_FAILED is returned, and a METHOD-DATA object will be stored in the e-data field of the KRB-ERROR message to specify which pre-authentication mechanisms are acceptable. The KDC can then indicate the support of PKINIT by including an empty element whose padata-type is PA_PK_AS_REQ in that METHOD-DATA object.",
      "ja": "[RFC4120]に従って、コードKDC_ERR_PREAUTH_FAILEDを使用したエラーメッセージが返され、Method-DataオブジェクトがKRB-ERRORメッセージのE-DATAフィールドにエラーメッセージが返された場合、事前認証が必要であるがリクエストに存在しなかった場合どの前認証メカニズムが許容されるかを指定します。KDCは、そのメソッドデータオブジェクトにPadataタイプがPA_PK_AS_REQである空の要素を含めることにより、Pkinitのサポートを示すことができます。"
    },
    {
      "indent": 3,
      "text": "Otherwise if it is required by the KDC's local policy that the client must be pre-authenticated using the pre-authentication mechanism specified in this document, but no PKINIT pre-authentication was present in the request, an error message with the code KDC_ERR_PREAUTH_FAILED SHOULD be returned.",
      "ja": "それ以外の場合は、KDCのローカルポリシーで、クライアントがこのドキュメントで指定された事前認証メカニズムを使用して事前認証を取得する必要があることを要求することが必要な場合は、リクエストにPkinit Pre-authenticationが存在していませんでした。戻ってきた。"
    },
    {
      "indent": 3,
      "text": "KDCs MUST leave the padata-value field of the PA_PK_AS_REQ element in the KRB-ERROR's METHOD-DATA empty (i.e., send a zero-length OCTET STRING), and clients MUST ignore this and any other value. Future extensions to this protocol may specify other data to send instead of an empty OCTET STRING.",
      "ja": "KDCSは、KRB-ErrorのメソッドデータのPA_PK_AS_REQ要素のPADATA値フィールドを空のままにしておく必要があります（つまり、ゼロの長さのオクテット文字列を送信します）、クライアントはこれとその他の値を無視する必要があります。このプロトコルの将来の拡張は、空のオクテット文字列の代わりに送信する他のデータを指定する場合があります。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The security of cryptographic algorithms is dependent on generating secret quantities [RFC4086]. The number of truly random bits is extremely important in determining the attack resistance strength of the cryptosystem; for example, the secret Diffie-Hellman exponents must be chosen based on n truly random bits (where n is the system security requirement). The security of the overall system is significantly weakened by using insufficient random inputs: a sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.",
      "ja": "暗号化アルゴリズムのセキュリティは、秘密の量の生成に依存します[RFC4086]。真にランダムビットの数は、暗号システムの攻撃抵抗強度を決定する上で非常に重要です。たとえば、秘密のdiffie-hellman指数は、nの真のランダムビット（nはシステムセキュリティ要件）に基づいて選択する必要があります。システム全体のセキュリティは、不十分なランダム入力を使用することで大幅に弱体化します。洗練された攻撃者は、秘密の量を生成した環境を再現し、結果として生じる小さな一連の可能性を検索する方が、全体の全体で量を見つけるよりも簡単に検索できます。潜在的な数値スペース。"
    },
    {
      "indent": 3,
      "text": "Kerberos error messages are not integrity protected; as a result, the domain parameters sent by the KDC as TD-DH-PARAMETERS can be tampered with by an attacker so that the set of domain parameters selected could be either weaker or not mutually preferred. Local policy can configure sets of domain parameters acceptable locally, or disallow the negotiation of DH domain parameters.",
      "ja": "Kerberosエラーメッセージは整合性保護されていません。その結果、KDCによってTD-DHパラメーターとして送信されるドメインパラメーターは、攻撃者が改ざんすることができ、選択されたドメインパラメーターのセットが弱くなるか、相互に好まれない可能性があります。ローカルポリシーは、ローカルで許容できるドメインパラメーターのセットを構成するか、DHドメインパラメーターのネゴシエーションを禁止できます。"
    },
    {
      "indent": 3,
      "text": "The symmetric reply key size and Diffie-Hellman field size or RSA modulus size should be chosen so as to provide sufficient cryptographic security [RFC3766].",
      "ja": "対称応答キーサイズとdiffie-hellmanフィールドサイズまたはRSAモジュラスサイズを選択して、十分な暗号セキュリティを提供する必要があります[RFC3766]。"
    },
    {
      "indent": 3,
      "text": "When MODP Diffie-Hellman is used, the exponents should have at least twice as many bits as the symmetric keys that will be derived from them [ODL99].",
      "ja": "modp diffie-hellmanを使用する場合、指数は、それらに由来する対称キーの少なくとも2倍のビットを持つ必要があります[ODL99]。"
    },
    {
      "indent": 3,
      "text": "PKINIT raises certain security considerations beyond those that can be regulated strictly in protocol definitions. We will address them in this section.",
      "ja": "Pkinitは、プロトコル定義で厳密に規制できるものを超えて、特定のセキュリティ上の考慮事項を提起します。このセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "PKINIT extends the cross-realm model to the public-key infrastructure. Users of PKINIT must understand security policies and procedures appropriate to the use of Public Key Infrastructures [RFC3280].",
      "ja": "Pkinitは、クロスリアムモデルをパブリックキーインフラストラクチャに拡張します。Pkinitのユーザーは、公開キーインフラストラクチャの使用に適したセキュリティポリシーと手順を理解する必要があります[RFC3280]。"
    },
    {
      "indent": 3,
      "text": "In order to trust a KDC certificate that is certified by a CA as a KDC certificate for a target realm (for example, by asserting the TGS name of that Kerberos realm as an id-pkinit-san SAN and/or restricting the certificate usage by using the id-pkinit-KPKdc EKU, as described in Section 3.2.4), the client MUST verify that the KDC certificate's issuing CA is authorized to issue KDC certificates for that target realm. Otherwise, the binding between the KDC certificate and the KDC of the target realm is not established.",
      "ja": "ターゲットレルムのKDC証明書としてCAによって認定されたKDC証明書を信頼するために（たとえば、そのKerberos RealmのTGS名をID-Pkinit-San Sanとして主張し、/または証明書の使用量を制限することによりセクション3.2.4で説明されているように、ID-Pkinit-KPKDC EKU）を使用して、クライアントは、KDC証明書の発行CAがそのターゲットレルムのKDC証明書を発行する権限があることを確認する必要があります。それ以外の場合、KDC証明書とターゲット領域のKDCの間のバインディングは確立されていません。"
    },
    {
      "indent": 3,
      "text": "How to validate this authorization is a matter of local policy. A way to achieve this is the configuration of specific sets of intermediary CAs and trust anchors, one of which must be on the KDC certificate's certification path [RFC3280], and, for each CA or trust anchor, the realms for which it is allowed to issue certificates.",
      "ja": "この承認を検証する方法は、現地のポリシーの問題です。これを達成する方法は、中間CAと信頼のアンカーの特定のセットの構成です。そのうちの1つはKDC証明書の認定パス[RFC3280]にあり、各CAまたは信頼のアンカーについて、許可されている領域である必要があります。証明書を発行します。"
    },
    {
      "indent": 3,
      "text": "In addition, if any CA that is trusted to issue KDC certificates can also issue other kinds of certificates, then local policy must be able to distinguish between them; for example, it could require that KDC certificates contain the id-pkinit-KPKdc EKU or that the realm be specified with the id-pkinit-san SAN.",
      "ja": "さらに、KDC証明書を発行すると信頼されているCAも他の種類の証明書を発行できる場合、ローカルポリシーはそれらを区別できる必要があります。たとえば、KDC証明書にはID-Pkinit-KPKDC EKUが含まれているか、Id-Pkinit-SanSanで領域を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "It is the responsibility of the PKI administrators for an organization to ensure that KDC certificates are only issued to KDCs, and that clients can ascertain this using their local policy.",
      "ja": "KDC証明書がKDCにのみ発行され、クライアントがローカルポリシーを使用してこれを確認できることを保証することは、組織のPKI管理者の責任です。"
    },
    {
      "indent": 3,
      "text": "Standard Kerberos allows the possibility of interactions between cryptosystems of varying strengths; this document adds interactions with public-key cryptosystems to Kerberos. Some administrative policies may allow the use of relatively weak public keys. When using such weak asymmetric keys to protect/exchange stronger symmetric Keys, the attack resistant strength of the overall system is no better than that of these weak keys [RFC3766].",
      "ja": "標準のカレベロスは、さまざまな強度の暗号システム間の相互作用の可能性を可能にします。このドキュメントでは、パブリックキー暗号システムとの相互作用がKerberosに追加されます。一部の管理ポリシーでは、比較的弱いパブリックキーの使用を許可する場合があります。このような弱い非対称キーを使用してより強力な対称キーを保護/交換する場合、システム全体の攻撃強度は、これらの弱いキーの攻撃強度よりも優れていません[RFC3766]。"
    },
    {
      "indent": 3,
      "text": "PKINIT requires that keys for symmetric cryptosystems be generated. Some such systems contain \"weak\" keys. For recommendations regarding these weak keys, see [RFC4120].",
      "ja": "Pkinitは、対称的な暗号システムのキーを生成する必要があります。このようなシステムには、「弱い」キーが含まれています。これらの弱いキーに関する推奨事項については、[RFC4120]を参照してください。"
    },
    {
      "indent": 3,
      "text": "PKINIT allows the use of the same RSA key pair for encryption and signing when doing RSA encryption-based key delivery. This is not recommended usage of RSA keys [RFC3447]; by using DH-based key delivery, this is avoided.",
      "ja": "Pkinitを使用すると、RSA暗号化ベースのキー配信を行うときに、暗号化と署名に同じRSAキーペアを使用できます。これは、RSAキー[RFC3447]の使用法ではありません。DHベースのキー配信を使用することにより、これは回避されます。"
    },
    {
      "indent": 3,
      "text": "Care should be taken in how certificates are chosen for the purposes of authentication using PKINIT. Some local policies may require that key escrow be used for certain certificate types. Deployers of PKINIT should be aware of the implications of using certificates that have escrowed keys for the purposes of authentication. Because signing-only certificates are normally not escrowed, by using DH-based key delivery this is avoided.",
      "ja": "Pkinitを使用した認証を目的とするために、証明書がどのように選択されるかに注意する必要があります。一部のローカルポリシーでは、特定の証明書タイプにキーエスクローを使用する必要がある場合があります。Pkinitの展開者は、認証を目的としてキーを排出した証明書を使用することの意味を認識する必要があります。署名のみの証明書は通常エスクローされていないため、DHベースのキー配信を使用することにより、これは回避されます。"
    },
    {
      "indent": 3,
      "text": "PKINIT does not provide for a \"return routability\" test to prevent attackers from mounting a denial-of-service attack on the KDC by causing it to perform unnecessary and expensive public-key operations. Strictly speaking, this is also true of standard Kerberos, although the potential cost is not as great, because standard Kerberos does not make use of public-key cryptography. By using DH-based key delivery and reusing DH keys, the necessary crypto processing cost per request can be minimized.",
      "ja": "Pkinitは、攻撃者が不必要で高価なパブリックキー運用を実行することにより、攻撃者がKDCへのサービス拒否攻撃を導入するのを防ぐための「返品ルー上」テストを提供していません。厳密に言えば、これは標準のケルベロスにも当てはまりますが、標準のKerberosは公開キーの暗号を利用していないため、潜在的なコストはそれほど大きくありません。DHベースのキー配信とDHキーの再利用により、要求ごとに必要な暗号処理コストを最小限に抑えることができます。"
    },
    {
      "indent": 3,
      "text": "When the Diffie-Hellman key exchange method is used, additional pre-authentication data [RFC4120] (in addition to the PA_PK_AS_REQ, as defined in this specification) is not bound to the AS_REQ by the mechanisms discussed in this specification (meaning it may be dropped or added by attackers without being detected by either the client or the KDC). Designers of additional pre-authentication data should take that into consideration if such additional pre-authentication data can be used in conjunction with the PA_PK_AS_REQ. The future work of the Kerberos working group is expected to update the hash algorithms specified in this document and provide a generic mechanism to bind additional pre-authentication data with the accompanying AS_REQ.",
      "ja": "diffie-hellmanキー交換方法を使用すると、追加の前発見データ[RFC4120]（この仕様で定義されているPA_PK_AS_REQに加えて）は、この仕様で説明されているメカニズムによってAS_REQに結合していません（つまりクライアントまたはKDCのいずれかによって検出されることなく攻撃者によってドロップまたは追加されました）。追加の免除前データの設計者は、PA_PK_AS_REQと組み合わせてそのような追加の事前認証データを使用できる場合、それを考慮に入れる必要があります。Kerberos Working Groupの将来の作業は、このドキュメントで指定されたハッシュアルゴリズムを更新し、追加の前免除データを付随するAS_REQに結合するための一般的なメカニズムを提供することが期待されています。"
    },
    {
      "indent": 3,
      "text": "The key usage number 6 used by the asChecksum field is also used for the authenticator checksum (cksum field of AP-REQ) contained in the PA-TGS-REQ preauthentication data contained in a TGS-REQ [RFC4120]. This conflict is present for historical reasons; the reuse of key usage numbers is strongly discouraged.",
      "ja": "Aschecksumフィールドで使用される主要な使用法番号6は、TGS-REQ [RFC4120]に含まれるPA-TGS-REQ事前認証データに含まれる認証装置チェックサム（AP-REQのCKSUMフィールド）にも使用されます。この紛争は歴史的な理由で存在します。主要な使用数の再利用は強く落胆しています。"
    },
    {
      "indent": 0,
      "text": "5. Acknowledgements",
      "section_title": true,
      "ja": "5. 謝辞"
    },
    {
      "indent": 3,
      "text": "The following people have made significant contributions to this document: Paul Leach, Stefan Santesson, Sam Hartman, Love Hornquist Astrand, Ken Raeburn, Nicolas Williams, John Wray, Tom Yu, Jeffrey Hutzelman, David Cross, Dan Simon, Karthik Jaganathan, Chaskiel M Grundman, and Jeffrey Altman.",
      "ja": "次の人々は、この文書に多大な貢献をしています：ポール・リーチ、ステファン・サンテッソン、サム・ハートマン、ラブ・ホーンキスト・アストランド、ケン・レーバーン、ニコラス・ウィリアムズ、ジョン・レイ、トム・ユ、ジェフリー・フッツェルマン、デビッド・クロス、ダン・サイモン、カーシク・ジャガナサン、チャスキエルMグルンドマン、ジェフリー・アルトマン。"
    },
    {
      "indent": 3,
      "text": "Andre Scedrov, Aaron D. Jaggard, Iliano Cervesato, Joe-Kai Tsay, and Chris Walstad discovered a binding issue between the AS-REQ and AS-REP in draft -26; the asChecksum field was added as the result.",
      "ja": "Andre Scedrov、Aaron D. Jaggard、Iliano Cervesato、Joe-Kai Tsay、およびChris Walstadは、ドラフト-26でAS-ReqとAS-Repの間に拘束力のある問題を発見しました。結果としてastchecksumフィールドが追加されました。"
    },
    {
      "indent": 3,
      "text": "Special thanks to Clifford Neuman, Matthew Hur, Ari Medvinsky, Sasha Medvinsky, and Jonathan Trostle who wrote earlier versions of this document.",
      "ja": "この文書の以前のバージョンを書いてくれたクリフォード・ノイマン、マシュー・ハー、アリ・メドビンスキー、サーシャ・メドビンスキー、ジョナサン・トロステルに感謝します。"
    },
    {
      "indent": 3,
      "text": "The authors are indebted to the Kerberos working group chair, Jeffrey Hutzelman, who kept track of various issues and was enormously helpful during the creation of this document.",
      "ja": "著者は、Kerberosワーキンググループの議長であるJeffrey Hutzelmanに感謝しています。ジェフリーハッツェルマンは、さまざまな問題を追跡し、この文書の作成中に非常に役立ちました。"
    },
    {
      "indent": 3,
      "text": "Some of the ideas on which this document is based arose during discussions over several years between members of the SAAG, the IETF CAT working group, and the PSRG, regarding integration of Kerberos and SPX. Some ideas have also been drawn from the DASS system. These changes are by no means endorsed by these groups. This is an attempt to revive some of the goals of those groups, and this document approaches those goals primarily from the Kerberos perspective.",
      "ja": "KerberosとSPXの統合に関するSAAG、IETF猫のワーキンググループ、およびPSRGのメンバー間の数年にわたって議論の際に、この文書が基づいているアイデアのいくつか。DASSシステムからもいくつかのアイデアが描かれています。これらの変更は、これらのグループによって決して承認されていません。これは、これらのグループの目標のいくつかを復活させる試みであり、この文書は主にKerberosの観点からこれらの目標に近づいています。"
    },
    {
      "indent": 3,
      "text": "Lastly, comments from groups working on similar ideas in DCE have been invaluable.",
      "ja": "最後に、DCEで同様のアイデアに取り組んでいるグループからのコメントは非常に貴重です。"
    },
    {
      "indent": 0,
      "text": "6. References",
      "section_title": true,
      "ja": "6. 参考文献"
    },
    {
      "indent": 0,
      "text": "6.1. Normative References",
      "section_title": true,
      "ja": "6.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[IEEE1363] IEEE, \"Standard Specifications for Public Key Cryptography\", IEEE 1363, 2000.",
      "ja": "[IEEE1363] IEEE、「公開キー暗号化の標準仕様」、IEEE 1363、2000。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2412] Orman, H., \"The OAKLEY Key Determination Protocol\", RFC 2412, November 1998.",
      "ja": "[RFC2412] Orman、H。、「The Oakley Key Deicination Protocol」、RFC 2412、1998年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2631] Rescorla, E., \"Diffie-Hellman Key Agreement Method\", RFC 2631, June 1999.",
      "ja": "[RFC2631] Rescorla、E。、「Diffie-Hellman Key Asmatement Method」、RFC 2631、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3279] Bassham, L., Polk, W., and R. Housley, \"Algorithms and Identifiers for the Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3279, April 2002.",
      "ja": "[RFC3279] Bassham、L.、Polk、W。、およびR. Housley、「インターネットのアルゴリズムと識別子X.509公開キーインフラストラクチャ証明書および証明書取消リスト（CRL）プロファイル」、RFC 3279、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3280] Housley, R., Polk, W., Ford, W., and D. Solo, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 3280, April 2002.",
      "ja": "[RFC3280] Housley、R.、Polk、W.、Ford、W.、およびD. Solo、「インターネットX.509公開キーインフラストラクチャ証明書および証明書取消リスト（CRL）プロファイル」、RFC 3280、2002年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3370] Housley, R., \"Cryptographic Message Syntax (CMS) Algorithms\", RFC 3370, August 2002.",
      "ja": "[RFC3370] Housley、R。、「暗号化メッセージ構文（CMS）アルゴリズム」、RFC 3370、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447] Jonsson、J.およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA暗号仕様バージョン2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3526] Kivinen, T. and M. Kojo, \"More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE)\", RFC 3526, May 2003.",
      "ja": "[RFC3526] Kivinen、T。およびM. Kojo、「インターネットキーエクスチェンジ（IKE）のためのよりモジュラー指数（MODP）Diffie-Hellmanグループ」、RFC 3526、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3560] Housley, R., \"Use of the RSAES-OAEP Key Transport Algorithm in Cryptographic Message Syntax (CMS)\", RFC 3560, July 2003.",
      "ja": "[RFC3560] Housley、R。、「暗号化メッセージ構文（CMS）におけるRSAES-OAEPキートランスポートアルゴリズムの使用」、RFC 3560、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3766] Orman, H. and P. Hoffman, \"Determining Strengths For Public Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766, April 2004.",
      "ja": "[RFC3766] Orman、H。およびP. Hoffman、「対称キーの交換に使用される公共キーの強度の決定」、BCP 86、RFC 3766、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3852] Housley, R., \"Cryptographic Message Syntax (CMS)\", RFC 3852, July 2004.",
      "ja": "[RFC3852] Housley、R。、「暗号化メッセージ構文（CMS）」、RFC 3852、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3961] Raeburn, K., \"Encryption and Checksum Specifications for Kerberos 5\", RFC 3961, February 2005.",
      "ja": "[RFC3961] Raeburn、K。、「Kerberos 5の暗号化とチェックサム仕様」、RFC 3961、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3962] Raeburn, K., \"Advanced Encryption Standard (AES) Encryption for Kerberos 5\", RFC 3962, February 2005.",
      "ja": "[RFC3962] Raeburn、K。、「高度な暗号化標準（AES）Kerberos 5の暗号化」、RFC 3962、2005年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., 3rd, Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、3rd、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC4120] Neuman, C., Yu, T., Hartman, S., and K. Raeburn, \"The Kerberos Network Authentication Service (V5)\", RFC 4120, July 2005.",
      "ja": "[RFC4120] Neuman、C.、Yu、T.、Hartman、S。、およびK. Raeburn、「The Kerberos Network認証サービス（V5）」、RFC 4120、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[X680] ITU-T Recommendation X.680 (2002) | ISO/IEC 8824-1:2002, Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation.",
      "ja": "[X680] ITU-T推奨X.680（2002）|ISO/IEC 8824-1：2002、情報技術 - 抽象的構文表記1（ASN.1）：基本表記の仕様。"
    },
    {
      "indent": 3,
      "text": "[X690] ITU-T Recommendation X.690 (2002) | ISO/IEC 8825-1:2002, Information technology - ASN.1 encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER).",
      "ja": "[X690] ITU-T推奨X.690（2002）|ISO/IEC 8825-1：2002、情報技術-ASN.1エンコーディングルール：基本エンコードルール（BER）、標準エンコーディングルール（CER）、および識別されたエンコードルール（DER）の仕様。"
    },
    {
      "indent": 0,
      "text": "6.2. Informative References",
      "section_title": true,
      "ja": "6.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[ODL99] Odlyzko, A., \"Discrete logarithms: The past and the future, Designs, Codes, and Cryptography (1999)\". April 1999.",
      "ja": "[ODL99] Odlyzko、A。、「離散対数：過去と未来、デザイン、コード、および暗号化（1999）」。1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4121] Zhu, L., Jaganathan, K., and S. Hartman, \"The Kerberos Version 5 Generic Security Service Application Program Interface (GSS-API) Mechanism: Version 2\", RFC 4121, July 2005.",
      "ja": "[RFC4121] Zhu、L.、Jaganathan、K。、およびS. Hartman、「Kerberosバージョン5ジェネリックセキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）メカニズム：バージョン2 \"、RFC 4121、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4158] Cooper, M., Dzambasow, Y., Hesse, P., Joseph, S., and R. Nicholas, \"Internet X.509 Public Key Infrastructure: Certification Path Building\", RFC 4158, September 2005.",
      "ja": "[RFC4158] Cooper、M.、Dzambasow、Y.、Hesse、P.、Joseph、S。、およびR. Nicholas、「インターネットX.509公開キーインフラストラクチャ：認定パスビルディング」、RFC 4158、2005年9月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. PKINIT ASN.1 Module",
      "section_title": true,
      "ja": "付録A. pkinit asn.1モジュール"
    },
    {
      "indent": 7,
      "text": "KerberosV5-PK-INIT-SPEC {\n        iso(1) identified-organization(3) dod(6) internet(1)\n        security(5) kerberosV5(2) modules(4) pkinit(5)\n} DEFINITIONS EXPLICIT TAGS ::= BEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "IMPORTS",
      "ja": "輸入"
    },
    {
      "indent": 11,
      "text": "SubjectPublicKeyInfo, AlgorithmIdentifier FROM PKIX1Explicit88 { iso (1) identified-organization (3) dod (6) internet (1) security (5) mechanisms (5) pkix (7) id-mod (0) id-pkix1-explicit (18) } -- As defined in RFC 3280.",
      "ja": "subjectpublickeyinfo、pkix1explicit88 {iso（1）識別付き - 組織化（3）dod（6）インターネット（1）セキュリティ（5）メカニズム（5）PKIX（7）ID-mod（0）ID-PKIX1-EXPLICIT（18）}  -  RFC 3280で定義されています。"
    },
    {
      "indent": 11,
      "text": "KerberosTime, PrincipalName, Realm, EncryptionKey, Checksum FROM KerberosV5Spec2 { iso(1) identified-organization(3) dod(6) internet(1) security(5) kerberosV5(2) modules(4) krb5spec2(2) }; -- as defined in RFC 4120.",
      "ja": "kerberostime、プリンシパルナメ、レルム、encryptionkey、kerberosv5spec2からのチェックサム{iso（1）識別された - 組織化（3）dod（6）インターネット（1）セキュリティ（5）kerberosv5（2）モジュール（4）krb5spec2（2）};-RFC4120で定義されています。"
    },
    {
      "indent": 7,
      "text": "id-pkinit OBJECT IDENTIFIER ::=\n  { iso(1) identified-organization(3) dod(6) internet(1)\n    security(5) kerberosv5(2) pkinit (3) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "id-pkinit-authData      OBJECT IDENTIFIER  ::= { id-pkinit 1 }\nid-pkinit-DHKeyData     OBJECT IDENTIFIER  ::= { id-pkinit 2 }\nid-pkinit-rkeyData      OBJECT IDENTIFIER  ::= { id-pkinit 3 }\nid-pkinit-KPClientAuth  OBJECT IDENTIFIER  ::= { id-pkinit 4 }\nid-pkinit-KPKdc         OBJECT IDENTIFIER  ::= { id-pkinit 5 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "id-pkinit-san OBJECT IDENTIFIER ::=\n  { iso(1) org(3) dod(6) internet(1) security(5) kerberosv5(2)\n    x509SanAN (2) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pa-pk-as-req INTEGER ::=                  16\npa-pk-as-rep INTEGER ::=                  17",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ad-initial-verified-cas INTEGER ::=        9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "td-trusted-certifiers INTEGER ::=        104\ntd-invalid-certificates INTEGER ::=      105\ntd-dh-parameters INTEGER ::=             109",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "PA-PK-AS-REQ ::= SEQUENCE {\n   signedAuthPack          [0] IMPLICIT OCTET STRING,\n            -- Contains a CMS type ContentInfo encoded",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            -- according to [RFC3852].\n            -- The contentType field of the type ContentInfo\n            -- is id-signedData (1.2.840.113549.1.7.2),\n            -- and the content field is a SignedData.\n            -- The eContentType field for the type SignedData is\n            -- id-pkinit-authData (1.3.6.1.5.2.3.1), and the\n            -- eContent field contains the DER encoding of the\n            -- type AuthPack.\n            -- AuthPack is defined below.\n   trustedCertifiers       [1] SEQUENCE OF\n               ExternalPrincipalIdentifier OPTIONAL,\n            -- Contains a list of CAs, trusted by the client,\n            -- that can be used to certify the KDC.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).\n            -- The information contained in the\n            -- trustedCertifiers SHOULD be used by the KDC as\n            -- hints to guide its selection of an appropriate\n            -- certificate chain to return to the client.\n   kdcPkId                 [2] IMPLICIT OCTET STRING\n                               OPTIONAL,\n            -- Contains a CMS type SignerIdentifier encoded\n            -- according to [RFC3852].\n            -- Identifies, if present, a particular KDC\n            -- public key that the client already has.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "DHNonce ::= OCTET STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ExternalPrincipalIdentifier ::= SEQUENCE {\n   subjectName            [0] IMPLICIT OCTET STRING OPTIONAL,\n            -- Contains a PKIX type Name encoded according to\n            -- [RFC3280].\n            -- Identifies the certificate subject by the\n            -- distinguished subject name.\n            -- REQUIRED when there is a distinguished subject\n            -- name present in the certificate.\n  issuerAndSerialNumber   [1] IMPLICIT OCTET STRING OPTIONAL,\n            -- Contains a CMS type IssuerAndSerialNumber encoded\n            -- according to [RFC3852].\n            -- Identifies a certificate of the subject.\n            -- REQUIRED for TD-INVALID-CERTIFICATES and\n            -- TD-TRUSTED-CERTIFIERS.\n  subjectKeyIdentifier    [2] IMPLICIT OCTET STRING OPTIONAL,\n            -- Identifies the subject's public key by a key\n            -- identifier.  When an X.509 certificate is\n            -- referenced, this key identifier matches the X.509",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            -- subjectKeyIdentifier extension value.  When other\n            -- certificate formats are referenced, the documents\n            -- that specify the certificate format and their use\n            -- with the CMS must include details on matching the\n            -- key identifier to the appropriate certificate\n            -- field.\n            -- RECOMMENDED for TD-TRUSTED-CERTIFIERS.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "AuthPack ::= SEQUENCE {\n   pkAuthenticator         [0] PKAuthenticator,\n   clientPublicValue       [1] SubjectPublicKeyInfo OPTIONAL,\n            -- Type SubjectPublicKeyInfo is defined in\n            -- [RFC3280].\n            -- Specifies Diffie-Hellman domain parameters\n            -- and the client's public key value [IEEE1363].\n            -- The DH public key value is encoded as a BIT\n            -- STRING according to [RFC3279].\n            -- This field is present only if the client wishes\n            -- to use the Diffie-Hellman key agreement method.\n   supportedCMSTypes       [2] SEQUENCE OF AlgorithmIdentifier\n                               OPTIONAL,\n            -- Type AlgorithmIdentifier is defined in\n            -- [RFC3280].\n            -- List of CMS algorithm [RFC3370] identifiers\n            -- that identify key transport algorithms, or\n            -- content encryption algorithms, or signature\n            -- algorithms supported by the client in order of\n            -- (decreasing) preference.\n   clientDHNonce           [3] DHNonce OPTIONAL,\n            -- Present only if the client indicates that it\n            -- wishes to reuse DH keys or to allow the KDC to\n            -- do so.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "PKAuthenticator ::= SEQUENCE {\n   cusec                   [0] INTEGER (0..999999),\n   ctime                   [1] KerberosTime,\n            -- cusec and ctime are used as in [RFC4120], for\n            -- replay prevention.\n   nonce                   [2] INTEGER (0..4294967295),\n            -- Chosen randomly; this nonce does not need to\n            -- match with the nonce in the KDC-REQ-BODY.\n   paChecksum              [3] OCTET STRING OPTIONAL,\n            -- MUST be present.\n            -- Contains the SHA1 checksum, performed over",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " -- KDC-REQ-BODY. ... }",
      "ja": "-KDC-Req-Body。...}"
    },
    {
      "indent": 7,
      "text": "TD-TRUSTED-CERTIFIERS ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Identifies a list of CAs trusted by the KDC.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "TD-INVALID-CERTIFICATES ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Each ExternalPrincipalIdentifier identifies a\n            -- certificate (sent by the client) with an invalid\n            -- signature.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "KRB5PrincipalName ::= SEQUENCE {\n    realm                   [0] Realm,\n    principalName           [1] PrincipalName\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "AD-INITIAL-VERIFIED-CAS ::= SEQUENCE OF\n               ExternalPrincipalIdentifier\n            -- Identifies the certification path based on which\n            -- the client certificate was validated.\n            -- Each ExternalPrincipalIdentifier identifies a CA\n            -- or a CA certificate (thereby its public key).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "PA-PK-AS-REP ::= CHOICE {\n   dhInfo                  [0] DHRepInfo,\n            -- Selected when Diffie-Hellman key exchange is\n            -- used.\n   encKeyPack              [1] IMPLICIT OCTET STRING,\n            -- Selected when public key encryption is used.\n            -- Contains a CMS type ContentInfo encoded\n            -- according to [RFC3852].\n            -- The contentType field of the type ContentInfo is\n            -- id-envelopedData (1.2.840.113549.1.7.3).\n            -- The content field is an EnvelopedData.\n            -- The contentType field for the type EnvelopedData\n            -- is id-signedData (1.2.840.113549.1.7.2).\n            -- The eContentType field for the inner type\n            -- SignedData (when unencrypted) is\n            -- id-pkinit-rkeyData (1.3.6.1.5.2.3.3) and the\n            -- eContent field contains the DER encoding of the\n            -- type ReplyKeyPack.\n            -- ReplyKeyPack is defined below.\n   ...",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "DHRepInfo ::= SEQUENCE {\n   dhSignedData            [0] IMPLICIT OCTET STRING,\n            -- Contains a CMS type ContentInfo encoded according\n            -- to [RFC3852].\n            -- The contentType field of the type ContentInfo is\n            -- id-signedData (1.2.840.113549.1.7.2), and the\n            -- content field is a SignedData.\n            -- The eContentType field for the type SignedData is\n            -- id-pkinit-DHKeyData (1.3.6.1.5.2.3.2), and the\n            -- eContent field contains the DER encoding of the\n            -- type KDCDHKeyInfo.\n            -- KDCDHKeyInfo is defined below.\n   serverDHNonce           [1] DHNonce OPTIONAL,\n            -- Present if and only if dhKeyExpiration is\n            -- present.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "KDCDHKeyInfo ::= SEQUENCE {\n   subjectPublicKey        [0] BIT STRING,\n            -- The KDC's DH public key.\n            -- The DH public key value is encoded as a BIT\n            -- STRING according to [RFC3279].\n   nonce                   [1] INTEGER (0..4294967295),\n            -- Contains the nonce in the pkAuthenticator field\n            -- in the request if the DH keys are NOT reused,\n            -- 0 otherwise.\n   dhKeyExpiration         [2] KerberosTime OPTIONAL,\n            -- Expiration time for KDC's key pair,\n            -- present if and only if the DH keys are reused.\n            -- If present, the KDC's DH public key MUST not be\n            -- used past the point of this expiration time.\n            -- If this field is omitted then the serverDHNonce\n            -- field MUST also be omitted.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ReplyKeyPack ::= SEQUENCE {\n   replyKey                [0] EncryptionKey,\n            -- Contains the session key used to encrypt the\n            -- enc-part field in the AS-REP, i.e., the\n            -- AS reply key.\n   asChecksum              [1] Checksum,\n           -- Contains the checksum of the AS-REQ\n           -- corresponding to the containing AS-REP.\n           -- The checksum is performed over the type AS-REQ.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "           -- The protocol key [RFC3961] of the checksum is the\n           -- replyKey and the key usage number is 6.\n           -- If the replyKey's enctype is \"newer\" [RFC4120]\n           -- [RFC4121], the checksum is the required\n           -- checksum operation [RFC3961] for that enctype.\n           -- The client MUST verify this checksum upon receipt\n           -- of the AS-REP.\n   ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "TD-DH-PARAMETERS ::= SEQUENCE OF AlgorithmIdentifier\n            -- Each AlgorithmIdentifier specifies a set of\n            -- Diffie-Hellman domain parameters [IEEE1363].\n            -- This list is in decreasing preference order.\nEND",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. Test Vectors",
      "section_title": true,
      "ja": "付録B. テストベクトル"
    },
    {
      "indent": 3,
      "text": "Function octetstring2key() is defined in Section 3.2.3.1. This section describes a few sets of test vectors that would be useful for implementers of octetstring2key().",
      "ja": "関数OctetString2Key（）は、セクション3.2.3.1で定義されています。このセクションでは、OctetString2Key（）の実装者に役立つテストベクトルのセットについて説明します。"
    },
    {
      "indent": 3,
      "text": "Set 1:\n=====\nInput octet string x is:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Output of K-truncate() when the key size is 32 octets:",
      "ja": "キーサイズが32オクテットの場合のk-truncate（）の出力："
    },
    {
      "indent": 5,
      "text": "5e e5 0d 67 5c 80 9f e5 9e 4a 77 62 c5 4b 65 83 75 47 ea fb 15 9b d8 cd c7 5f fc a5 91 1e 4c 41",
      "ja": "5E E5 0D 67 5C 80 9F E5 9E 4A 77 62 C5 4B 65 83 75 47 EA FB 15 9B D8 CD C7 5F FC A5 91 1E 4C 41"
    },
    {
      "indent": 3,
      "text": "Set 2:\n=====\nInput octet string x is:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00",
      "ja": "00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00"
    },
    {
      "indent": 3,
      "text": "Output of K-truncate() when the key size is 32 octets:",
      "ja": "キーサイズが32オクテットの場合のk-truncate（）の出力："
    },
    {
      "indent": 5,
      "text": "ac f7 70 7c 08 97 3d df db 27 cd 36 14 42 cc fb a3 55 c8 88 4c b4 72 f3 7d a6 36 d0 7d 56 78 7e",
      "ja": "AC F7 70 7C 08 97 3D DF DB 27 CD 36 14 42 CC FB A3 55 C8 88 4C B4 72 F3 7D A6 36 D0 7D 56 78 7E"
    },
    {
      "indent": 3,
      "text": "Set 3:\n======\nInput octet string x is:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08",
      "ja": "00 01 02 03 04 05 06 07 08 09 0A 0B 0c10 00 01 02 03 04 05 06 07 08 09 0a 0B 0C0f 10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0EE 0F 10 00 01 02 03 04 05 06 07 08"
    },
    {
      "indent": 3,
      "text": "Output of K-truncate() when the key size is 32 octets:",
      "ja": "キーサイズが32オクテットの場合のk-truncate（）の出力："
    },
    {
      "indent": 5,
      "text": "c4 42 da 58 5f cb 80 e4 3b 47 94 6f 25 40 93 e3 73 29 d9 90 01 38 0d b7 83 71 db 3a cf 5c 79 7e",
      "ja": "C4 42 DA 58 5F CB 80 E4 3B 47 94 6F 25 40 93 E3 73 29 D9 90 01 38 0D B7 83 71 DB 3A CF 5C 79 7E 7E"
    },
    {
      "indent": 3,
      "text": "Set 4:\n=====\nInput octet string x is:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 00 01 02 03 04 05 06 07 08",
      "ja": "00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 00 01 02 03 04 05 06 07 07 08 09 0A 0B 0C 0D 0E 0F 1000 01 02 02 03 04 05 06 07 08 09 0A 0C10 00 01 02 03 04 05 06 07 08 09 0A 0B 0C0D 0E 0F 10 00 01 02 03 04 05 06 07 08"
    },
    {
      "indent": 3,
      "text": "Output of K-truncate() when the key size is 32 octets:",
      "ja": "キーサイズが32オクテットの場合のk-truncate（）の出力："
    },
    {
      "indent": 5,
      "text": "00 53 95 3b 84 c8 96 f4 eb 38 5c 3f 2e 75 1c 4a 59 0e d6 ff ad ca 6f f6 4f 47 eb eb 8d 78 0f fc",
      "ja": "00 53 95 3B 84 C8 96 F4 EB 38 5C 3F 2E 75 1C 4A 59 0E D6 FF AD CA 6F F6 4F 47 EB EB EB 8D 78 0F FC"
    },
    {
      "indent": 0,
      "text": "Appendix C. Miscellaneous Information about Microsoft Windows PKINIT Implementations",
      "ja": "付録C. Microsoft Windows Pkinitの実装に関するその他の情報"
    },
    {
      "indent": 3,
      "text": "Earlier revisions of the PKINIT I-D were implemented in various releases of Microsoft Windows and deployed in fairly large numbers. To enable the community to interoperate better with systems running those releases, the following information may be useful.",
      "ja": "Pkinit I-Dの以前の改訂は、Microsoft Windowsのさまざまなリリースに実装され、かなり多数展開されました。コミュニティがリリースを実行しているシステムとより適切に相互運用できるようにするには、次の情報が役立つ場合があります。"
    },
    {
      "indent": 3,
      "text": "KDC certificates issued by Windows 2000 Enterprise CAs contain a dNSName SAN with the DNS name of the host running the KDC, and the id-kp-serverAuth EKU [RFC3280].",
      "ja": "Windows 2000 Enterprise CASが発行したKDC証明書には、KDCを実行しているホストのDNS名とID-KP-Serverauth EKU [RFC3280]を備えたDNSName SANが含まれています。"
    },
    {
      "indent": 3,
      "text": "KDC certificates issued by Windows 2003 Enterprise CAs contain a dNSName SAN with the DNS name of the host running the KDC, the id-kp-serverAuth EKU, and the id-ms-kp-sc-logon EKU.",
      "ja": "Windows 2003 Enterprise CASが発行したKDC証明書には、KDC、ID-KP-Serverauth EKU、およびID-MS-KP-SC-Logon EKUを実行しているホストのDNS名が付いたDNSName SANが含まれています。"
    },
    {
      "indent": 3,
      "text": "It is anticipated that the next release of Windows is already too far along to allow it to support the issuing KDC certificates with id-pkinit-san SAN as specified in this RFC. Instead, they will have a dNSName SAN containing the domain name of the KDC, and the intended purpose of these KDC certificates will be restricted by the presence of the id-pkinit-KPKdc EKU and id-kp-serverAuth EKU.",
      "ja": "このRFCで指定されているように、次のWindowsのリリースはすでに既に遠すぎてID-Pkinit-San SANとの発行KDC証明書をサポートすることができないと予想されています。代わりに、KDCのドメイン名を含むDNSNAME SANがあり、これらのKDC証明書の意図された目的は、ID-Pkinit-KPKDC EKUとID-KP-Serverauth EKUの存在により制限されます。"
    },
    {
      "indent": 3,
      "text": "In addition to checking that the above are present in a KDC certificate, Windows clients verify that the issuer of the KDC certificate is one of a set of allowed issuers of such certificates, so those wishing to issue KDC certificates need to configure their Windows clients appropriately.",
      "ja": "上記がKDC証明書に存在することを確認することに加えて、Windowsクライアントは、KDC証明書の発行者がそのような証明書の許可されている一連の発行者の1つであることを確認しているため、KDC証明書を発行したい人はWindowsクライアントを適切に構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Client certificates accepted by Windows 2000 and Windows 2003 Server KDCs must contain an id-ms-san-sc-logon-upn (1.3.6.1.4.1.311.20.2.3) SAN and the id-ms-kp-sc-logon EKU. The id-ms-san-sc-logon-upn SAN contains a UTF8-encoded string whose value is that of the Directory Service attribute UserPrincipalName of the client account object, and the purpose of including the id-ms-san-sc-logon-upn SAN in the client certificate is to validate the client mapping (in other words, the client's public key is bound to the account that has this UserPrincipalName value).",
      "ja": "Windows 2000およびWindows 2003サーバーKDCが受け入れたクライアント証明書には、ID-MS-SAN-SC-Logon-Upn（1.3.6.1.4.1.1.311.20.2.3）SANおよびID-MS-KP-SC-Logon EKUが含まれている必要があります。ID-MS-SAN-SC-LOGON-UPN SANには、クライアントアカウントオブジェクトのDirectory Service属性属性ユーザープリンシパルネームの値とID-MS-SAN-SC-Logonを含める目的の値の値がUTF8エンコードされた文字列が含まれています。-UPN SANクライアント証明書は、クライアントマッピングを検証することです（つまり、クライアントの公開キーは、このユーザープリンシパルの値を持つアカウントにバインドされます）。"
    },
    {
      "indent": 3,
      "text": "It should be noted that all Microsoft Kerberos realm names are domain-style realm names and strictly in uppercase. In addition, the UserPrincipalName attribute is globally unique in Windows 2000 and Windows 2003.",
      "ja": "すべてのMicrosoft Kerberos Realmの名前はドメインスタイルのレルム名であり、厳密には大文字であることに注意する必要があります。さらに、UserPrincipalName属性は、Windows 2000およびWindows 2003でグローバルにユニークです。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Larry Zhu Microsoft Corporation One Microsoft Way Redmond, WA 98052 US",
      "ja": "Larry Zhu Microsoft Corporation One Microsoft Way Redmond、WA 98052 US"
    },
    {
      "indent": 3,
      "text": "EMail: lzhu@microsoft.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Brian Tung Aerospace Corporation 2350 E. El Segundo Blvd. El Segundo, CA 90245 US",
      "ja": "Brian Tung Aerospace Corporation 2350 E. El Segundo Blvd.El Segundo、CA 90245 US"
    },
    {
      "indent": 3,
      "text": "EMail: brian@aero.org",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}