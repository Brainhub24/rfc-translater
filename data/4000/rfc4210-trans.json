{
  "title": {
    "text": "RFC 4210 - Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)",
    "ja": "RFC 4210 - インターネットX.509公開キーインフラストラクチャ証明書管理プロトコル（CMP）"
  },
  "number": 4210,
  "created_at": "2023-07-28 13:17:29.295182+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           C. Adams\nRequest for Comments: 4210                          University of Ottawa\nObsoletes: 2510                                               S. Farrell\nCategory: Standards Track                         Trinity College Dublin\n                                                                T. Kause\n                                                                     SSH\n                                                              T. Mononen\n                                                                 SafeNet\n                                                          September 2005",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Internet X.509 Public Key Infrastructure Certificate Management Protocol (CMP)",
      "ja": "インターネットX.509公開キーインフラストラクチャ証明書管理プロトコル（CMP）"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 Public Key Infrastructure (PKI) Certificate Management Protocol (CMP). Protocol messages are defined for X.509v3 certificate creation and management. CMP provides on-line interactions between PKI components, including an exchange between a Certification Authority (CA) and a client system.",
      "ja": "このドキュメントでは、インターネットX.509公開キーインフラストラクチャ（PKI）証明書管理プロトコル（CMP）について説明しています。プロトコルメッセージは、x.509v3証明書の作成と管理に対して定義されます。CMPは、認証機関（CA）とクライアントシステム間の交換など、PKIコンポーネント間のオンライン相互作用を提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................5\n2. Requirements ....................................................5\n3. PKI Management Overview .........................................5\n   3.1. PKI Management Model .......................................6\n        3.1.1. Definitions of PKI Entities .........................6\n               3.1.1.1. Subjects and End Entities ..................6\n               3.1.1.2. Certification Authority ....................7\n               3.1.1.3. Registration Authority .....................7\n        3.1.2. PKI Management Requirements .........................8\n        3.1.3. PKI Management Operations ..........................10\n4. Assumptions and Restrictions ...................................14\n   4.1. End Entity Initialization .................................14\n      4.2. Initial Registration/Certification ........................14\n        4.2.1. Criteria Used ......................................15\n               4.2.1.1. Initiation of Registration/Certification ..15\n               4.2.1.2. End Entity Message Origin Authentication ..15\n               4.2.1.3. Location of Key Generation ................15\n               4.2.1.4. Confirmation of Successful Certification ..16\n        4.2.2. Mandatory Schemes ..................................16\n               4.2.2.1. Centralized Scheme ........................16\n               4.2.2.2. Basic Authenticated Scheme ................17\n   4.3. Proof-of-Possession (POP) of Private Key ..................17\n        4.3.1. Signature Keys .....................................18\n        4.3.2. Encryption Keys ....................................18\n        4.3.3. Key Agreement Keys .................................19\n   4.4. Root CA Key Update ........................................19\n        4.4.1. CA Operator Actions ................................20\n        4.4.2. Verifying Certificates .............................21\n               4.4.2.1. Verification in Cases 1, 4, 5, and 8 ......22\n               4.4.2.2. Verification in Case 2 ....................22\n               4.4.2.3. Verification in Case 3 ....................23\n               4.4.2.4. Failure of Verification in Case 6 .........23\n               4.4.2.5. Failure of Verification in Case 7 .........23\n        4.4.3. Revocation - Change of CA Key ......................23\n5. Data Structures ................................................24\n   5.1. Overall PKI Message .......................................24\n        5.1.1. PKI Message Header .................................24\n               5.1.1.1. ImplicitConfirm ...........................27\n               5.1.1.2. ConfirmWaitTime ...........................27\n        5.1.2. PKI Message Body ...................................27\n        5.1.3. PKI Message Protection .............................28\n               5.1.3.1. Shared Secret Information .................29\n               5.1.3.2. DH Key Pairs ..............................30\n               5.1.3.3. Signature .................................30\n               5.1.3.4. Multiple Protection .......................30\n   5.2. Common Data Structures ....................................31\n        5.2.1. Requested Certificate Contents .....................31\n        5.2.2. Encrypted Values ...................................31\n        5.2.3. Status codes and Failure Information for\n               PKI Messages .......................................32\n        5.2.4. Certificate Identification .........................33\n        5.2.5. Out-of-band root CA Public Key .....................33\n        5.2.6. Archive Options ....................................34\n        5.2.7. Publication Information ............................34\n        5.2.8. Proof-of-Possession Structures .....................34\n               5.2.8.1. Inclusion of the Private Key ..............35\n               5.2.8.2. Indirect Method ...........................35\n               5.2.8.3. Challenge-Response Protocol ...............35\n               5.2.8.4. Summary of PoP Options ....................37",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   5.3. Operation-Specific Data Structures ........................38\n        5.3.1. Initialization Request .............................38\n        5.3.2. Initialization Response ............................39\n        5.3.3. Certification Request ..............................39\n        5.3.4. Certification Response .............................39\n        5.3.5. Key Update Request Content .........................40\n        5.3.6. Key Update Response Content ........................41\n        5.3.7. Key Recovery Request Content .......................41\n        5.3.8. Key Recovery Response Content ......................41\n        5.3.9. Revocation Request Content .........................41\n        5.3.10. Revocation Response Content .......................42\n        5.3.11. Cross Certification Request Content ...............42\n        5.3.12. Cross Certification Response Content ..............42\n        5.3.13. CA Key Update Announcement Content ................42\n        5.3.14. Certificate Announcement ..........................43\n        5.3.15. Revocation Announcement ...........................43\n        5.3.16. CRL Announcement ..................................43\n        5.3.17. PKI Confirmation Content ..........................43\n        5.3.18. Certificate Confirmation Content ..................44\n        5.3.19. PKI General Message Content .......................44\n               5.3.19.1. CA Protocol Encryption Certificate .......44\n               5.3.19.2. Signing Key Pair Types ...................45\n               5.3.19.3. Encryption/Key Agreement Key Pair Types ..45\n               5.3.19.4. Preferred Symmetric Algorithm ............45\n               5.3.19.5. Updated CA Key Pair ......................45\n               5.3.19.6. CRL ......................................46\n               5.3.19.7. Unsupported Object Identifiers ...........46\n               5.3.19.8. Key Pair Parameters ......................46\n               5.3.19.9. Revocation Passphrase ....................46\n               5.3.19.10. ImplicitConfirm .........................46\n               5.3.19.11. ConfirmWaitTime .........................47\n               5.3.19.12. Original PKIMessage .....................47\n               5.3.19.13. Supported Language Tags .................47\n        5.3.20. PKI General Response Content ......................47\n        5.3.21. Error Message Content .............................47\n        5.3.22. Polling Request and Response ......................48\n6. Mandatory PKI Management Functions .............................51\n   6.1. Root CA Initialization ....................................51\n   6.2. Root CA Key Update ........................................51\n   6.3. Subordinate CA Initialization .............................51\n   6.4. CRL production ............................................52\n   6.5. PKI Information Request ...................................52\n   6.6. Cross Certification .......................................52\n        6.6.1. One-Way Request-Response Scheme: ...................52\n   6.7. End Entity Initialization .................................54\n        6.7.1. Acquisition of PKI Information .....................54\n        6.7.2. Out-of-Band Verification of Root-CA Key ............55\n   6.8. Certificate Request .......................................55\n      6.9. Key Update ................................................55\n7. Version Negotiation ............................................56\n   7.1. Supporting RFC 2510 Implementations .......................56\n        7.1.1. Clients Talking to RFC 2510 Servers ................56\n        7.1.2. Servers Receiving Version cmp1999 PKIMessages ......57\n8. Security Considerations ........................................57\n   8.1. Proof-Of-Possession with a Decryption Key .................57\n   8.2. Proof-Of-Possession by Exposing the Private Key ...........57\n   8.3. Attack Against Diffie-Hellman Key Exchange ................57\n9. IANA Considerations ............................................58\nNormative References ..............................................58\nInformative References ............................................59\nA. Reasons for the Presence of RAs ................................61\nB. The Use of Revocation Passphrase ...............................61\nC. Request Message Behavioral Clarifications ......................63\nD. PKI Management Message Profiles (REQUIRED) .....................65\n   D.1. General Rules for Interpretation of These Profiles ........65\n   D.2. Algorithm Use Profile .....................................66\n   D.3. Proof-of-Possession Profile ...............................68\n   D.4. Initial Registration/Certification (Basic\n        Authenticated Scheme) .....................................68\n   D.5. Certificate Request .......................................74\n   D.6. Key Update Request ........................................75\nE. PKI Management Message Profiles (OPTIONAL) .....................75\n   E.1. General Rules for Interpretation of These Profiles ........76\n   E.2. Algorithm Use Profile .....................................76\n   E.3. Self-Signed Certificates ..................................76\n   E.4. Root CA Key Update ........................................77\n   E.5. PKI Information Request/Response ..........................77\n   E.6. Cross Certification Request/Response (1-way) ..............79\n   E.7. In-Band Initialization Using External Identity\n        Certificate  ..............................................82\nF. Compilable ASN.1 Definitions ...................................83\nG. Acknowledgements ...............................................93",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Internet X.509 Public Key Infrastructure (PKI) Certificate Management Protocol (CMP). Protocol messages are defined for certificate creation and management. The term \"certificate\" in this document refers to an X.509v3 Certificate as defined in [X509].",
      "ja": "このドキュメントでは、インターネットX.509公開キーインフラストラクチャ（PKI）証明書管理プロトコル（CMP）について説明しています。プロトコルメッセージは、証明書の作成と管理のために定義されています。このドキュメントの「証明書」という用語は、[x509]で定義されているx.509v3証明書を指します。"
    },
    {
      "indent": 3,
      "text": "This specification obsoletes RFC 2510. This specification differs from RFC 2510 in the following areas:",
      "ja": "この仕様はRFC 2510を廃止します。この仕様は、次の領域でRFC 2510とは異なります。"
    },
    {
      "indent": 6,
      "text": "The PKI management message profile section is split to two appendices: the required profile and the optional profile. Some of the formerly mandatory functionality is moved to the optional profile.",
      "ja": "PKI管理メッセージプロファイルセクションは、必要なプロファイルとオプションプロファイルの2つの付録に分割されます。以前の必須機能の一部は、オプションのプロファイルに移動されます。"
    },
    {
      "indent": 6,
      "text": "The message confirmation mechanism has changed substantially.",
      "ja": "メッセージ確認メカニズムは大幅に変化しました。"
    },
    {
      "indent": 6,
      "text": "A new polling mechanism is introduced, deprecating the old polling method at the CMP transport level.",
      "ja": "CMP輸送レベルで古いポーリング方法を非難し、新しいポーリングメカニズムが導入されています。"
    },
    {
      "indent": 6,
      "text": "The CMP transport protocol issues are handled in a separate document [CMPtrans], thus the Transports section is removed.",
      "ja": "CMPトランスポートプロトコルの問題は、別のドキュメント[cmptrans]で処理されるため、輸送セクションが削除されます。"
    },
    {
      "indent": 6,
      "text": "A new implicit confirmation method is introduced to reduce the number of protocol messages exchanged in a transaction.",
      "ja": "トランザクションで交換されるプロトコルメッセージの数を減らすために、新しい暗黙の確認方法が導入されています。"
    },
    {
      "indent": 6,
      "text": "The new specification contains some less prominent protocol enhancements and improved explanatory text on several issues.",
      "ja": "新しい仕様には、いくつかの顕著なプロトコルの強化といくつかの問題に関する説明テキストが改善されています。"
    },
    {
      "indent": 0,
      "text": "2. Requirements",
      "section_title": true,
      "ja": "2. 要件"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document (in uppercase, as shown) are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「「必要」、「必須」、「必要」、「はない」、「必要」、「推奨」、「5月」、および「オプション」（上記のように、図示）は次のとおりです。[RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. PKI Management Overview",
      "section_title": true,
      "ja": "3. PKI管理の概要"
    },
    {
      "indent": 3,
      "text": "The PKI must be structured to be consistent with the types of individuals who must administer it. Providing such administrators with unbounded choices not only complicates the software required, but also increases the chances that a subtle mistake by an administrator or software developer will result in broader compromise. Similarly, restricting administrators with cumbersome mechanisms will cause them not to use the PKI.",
      "ja": "PKIは、それを管理しなければならない個人のタイプと一致するように構成する必要があります。このような管理者に無制限の選択肢を提供することは、必要なソフトウェアを複雑にするだけでなく、管理者またはソフトウェア開発者による微妙な間違いがより広範な妥協をもたらす可能性を高めます。同様に、管理者を扱いにくいメカニズムで制限すると、PKIを使用しません。"
    },
    {
      "indent": 3,
      "text": "Management protocols are REQUIRED to support on-line interactions between Public Key Infrastructure (PKI) components. For example, a management protocol might be used between a Certification Authority (CA) and a client system with which a key pair is associated, or between two CAs that issue cross-certificates for each other.",
      "ja": "管理プロトコルは、公開キーインフラストラクチャ（PKI）コンポーネント間のオンライン相互作用をサポートするために必要です。たとえば、管理プロトコルは、認証機関（CA）とキーペアが関連付けられているクライアントシステムの間、または相互に相互認証を発行する2つのCAの間で使用される場合があります。"
    },
    {
      "indent": 0,
      "text": "3.1. PKI Management Model",
      "section_title": true,
      "ja": "3.1. PKI管理モデル"
    },
    {
      "indent": 3,
      "text": "Before specifying particular message formats and procedures, we first define the entities involved in PKI management and their interactions (in terms of the PKI management functions required). We then group these functions in order to accommodate different identifiable types of end entities.",
      "ja": "特定のメッセージ形式と手順を指定する前に、まずPKI管理に関与するエンティティとその相互作用を定義します（必要なPKI管理機能の観点から）。次に、さまざまな識別可能なタイプのエンティティに対応するために、これらの関数をグループ化します。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Definitions of PKI Entities",
      "section_title": true,
      "ja": "3.1.1. PKIエンティティの定義"
    },
    {
      "indent": 3,
      "text": "The entities involved in PKI management include the end entity (i.e., the entity to whom the certificate is issued) and the certification authority (i.e., the entity that issues the certificate). A registration authority MAY also be involved in PKI management.",
      "ja": "PKI管理に関与するエンティティには、最終エンティティ（つまり、証明書が発行されるエンティティ）と認証機関（つまり、証明書を発行するエンティティ）が含まれます。登録機関は、PKI管理にも関与している場合があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1.1. Subjects and End Entities",
      "section_title": true,
      "ja": "3.1.1.1. 主題とエンティティ"
    },
    {
      "indent": 3,
      "text": "The term \"subject\" is used here to refer to the entity to whom the certificate is issued, typically named in the subject or subjectAltName field of a certificate. When we wish to distinguish the tools and/or software used by the subject (e.g., a local certificate management module), we will use the term \"subject equipment\". In general, the term \"end entity\" (EE), rather than \"subject\", is preferred in order to avoid confusion with the field name. It is important to note that the end entities here will include not only human users of applications, but also applications themselves (e.g., for IP security). This factor influences the protocols that the PKI management operations use; for example, application software is far more likely to know exactly which certificate extensions are required than are human users. PKI management entities are also end entities in the sense that they are sometimes named in the subject or subjectAltName field of a certificate or cross-certificate. Where appropriate, the term \"end-entity\" will be used to refer to end entities who are not PKI management entities.",
      "ja": "「件名」という用語は、証明書が発行されるエンティティを指すために使用されます。主題が使用するツールやソフトウェア（現地証明書管理モジュールなど）を区別したい場合は、「主題機器」という用語を使用します。一般に、フィールド名との混乱を避けるために、「主題」よりも「終了エンティティ」（EE）という用語が好まれます。ここの最終エンティティには、アプリケーションの人間ユーザーだけでなく、アプリケーション自体（例：IPセキュリティなど）も含まれることに注意することが重要です。この要因は、PKI管理操作が使用するプロトコルに影響を与えます。たとえば、アプリケーションソフトウェアは、人間のユーザーよりもどの証明書拡張機能が必要かを正確に知る可能性がはるかに高くなります。PKI管理エンティティは、証明書またはクロス認証の主題またはsubjectnameフィールドで時々命名されるという意味で、エンティティも終了します。必要に応じて、「エンティティ」という用語は、PKI管理エンティティではないエンティティを指すために使用されます。"
    },
    {
      "indent": 3,
      "text": "All end entities require secure local access to some information -- at a minimum, their own name and private key, the name of a CA that is directly trusted by this entity, and that CA's public key (or a fingerprint of the public key where a self-certified version is available elsewhere). Implementations MAY use secure local storage for more than this minimum (e.g., the end entity's own certificate or application-specific information). The form of storage will also vary -- from files to tamper-resistant cryptographic tokens. The information stored in such local, trusted storage is referred to here as the end entity's Personal Security Environment (PSE).",
      "ja": "すべてのエンティティには、少なくとも独自の名前、秘密鍵、このエンティティから直接信頼されているCAの名前、およびそのCAの公開鍵（または公開鍵の指紋」の名前であるいくつかの情報への安全なローカルアクセスが必要です。自己認証バージョンは他の場所で入手できます）。実装では、この最小限よりも安全なローカルストレージを使用する場合があります（たとえば、エンティティ独自の証明書またはアプリケーション固有の情報など）。ストレージの形式も異なります - ファイルから抵抗性のある暗号化トークンまで。このようなローカルで信頼できるストレージに保存されている情報は、ここでは最終エンティティの個人セキュリティ環境（PSE）と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "Though PSE formats are beyond the scope of this document (they are very dependent on equipment, et cetera), a generic interchange format for PSEs is defined here: a certification response message MAY be used.",
      "ja": "PSE形式はこのドキュメントの範囲を超えていますが（機器などに非常に依存しています）、PSEの一般的な交換形式がここで定義されています。認定応答メッセージを使用できます。"
    },
    {
      "indent": 0,
      "text": "3.1.1.2. Certification Authority",
      "section_title": true,
      "ja": "3.1.1.2. 認証局"
    },
    {
      "indent": 3,
      "text": "The certification authority (CA) may or may not actually be a real \"third party\" from the end entity's point of view. Quite often, the CA will actually belong to the same organization as the end entities it supports.",
      "ja": "認証機関（CA）は、実際にはエンティティの観点から実際に「サードパーティ」である場合があります。多くの場合、CAは実際にサポートする最終エンティティと同じ組織に属します。"
    },
    {
      "indent": 3,
      "text": "Again, we use the term \"CA\" to refer to the entity named in the issuer field of a certificate. When it is necessary to distinguish the software or hardware tools used by the CA, we use the term \"CA equipment\".",
      "ja": "繰り返しますが、「CA」という用語を使用して、証明書の発行者フィールドで指定されたエンティティを参照します。CAが使用するソフトウェアまたはハードウェアツールを区別する必要がある場合は、「CA機器」という用語を使用します。"
    },
    {
      "indent": 3,
      "text": "The CA equipment will often include both an \"off-line\" component and an \"on-line\" component, with the CA private key only available to the \"off-line\" component. This is, however, a matter for implementers (though it is also relevant as a policy issue).",
      "ja": "CA機器には、多くの場合、「オフライン」コンポーネントと「オンライン」コンポーネントの両方が含まれ、CAの秘密鍵は「オフライン」コンポーネントのみが利用できます。ただし、これは実装者にとっての問題です（ただし、ポリシーの問題としても関連しています）。"
    },
    {
      "indent": 3,
      "text": "We use the term \"root CA\" to indicate a CA that is directly trusted by an end entity; that is, securely acquiring the value of a root CA public key requires some out-of-band step(s). This term is not meant to imply that a root CA is necessarily at the top of any hierarchy, simply that the CA in question is trusted directly.",
      "ja": "「ルートCA」という用語を使用して、最終エンティティによって直接信頼されるCAを示します。つまり、ルートCAの公開キーの価値を安全に取得するには、バンド外のステップが必要です。この用語は、ルートCAが必然的に階層の一番上にあることを意味するものではなく、問題のCAが直接信頼されていることを意味します。"
    },
    {
      "indent": 3,
      "text": "A \"subordinate CA\" is one that is not a root CA for the end entity in question. Often, a subordinate CA will not be a root CA for any entity, but this is not mandatory.",
      "ja": "「下位CA」は、問題の最終エンティティのルートCAではないものです。多くの場合、下位CAはどのエンティティにとってもルートCAではありませんが、これは必須ではありません。"
    },
    {
      "indent": 0,
      "text": "3.1.1.3. Registration Authority",
      "section_title": true,
      "ja": "3.1.1.3. 登録認定機関"
    },
    {
      "indent": 3,
      "text": "In addition to end-entities and CAs, many environments call for the existence of a Registration Authority (RA) separate from the Certification Authority. The functions that the registration authority may carry out will vary from case to case but MAY include personal authentication, token distribution, revocation reporting, name assignment, key generation, archival of key pairs, et cetera.",
      "ja": "エンドエンティティとCASに加えて、多くの環境では、認証機関とは別の登録機関（RA）の存在が必要です。登録機関が実行する可能性のある機能は、ケースごとに異なりますが、個人認証、トークン分布、取り消し報告、名前の割り当て、キー生成、キーペアのアーカイブなどが含まれる場合があります。"
    },
    {
      "indent": 3,
      "text": "This document views the RA as an OPTIONAL component: when it is not present, the CA is assumed to be able to carry out the RA's functions so that the PKI management protocols are the same from the end-entity's point of view.",
      "ja": "このドキュメントでは、RAをオプションのコンポーネントと見なします。PKI管理プロトコルがエンドエンティティの観点から同じであるように、CAはRAの関数を実行できると想定されています。"
    },
    {
      "indent": 3,
      "text": "Again, we distinguish, where necessary, between the RA and the tools used (the \"RA equipment\").",
      "ja": "繰り返しますが、必要に応じて、使用されたRAと使用されたツール（「RA装置」）を区別します。"
    },
    {
      "indent": 3,
      "text": "Note that an RA is itself an end entity. We further assume that all RAs are in fact certified end entities and that RAs have private keys that are usable for signing. How a particular CA equipment identifies some end entities as RAs is an implementation issue (i.e., this document specifies no special RA certification operation). We do not mandate that the RA is certified by the CA with which it is interacting at the moment (so one RA may work with more than one CA whilst only being certified once).",
      "ja": "RAはそれ自体が最終エンティティであることに注意してください。さらに、すべてのRAが実際に認定された最終エンティティであり、RAには署名に使用できるプライベートキーがあると仮定します。RASが実装の問題であるため、特定のCA機器がいくつかのエンティティを識別する方法（つまり、このドキュメントは特別なRA認証操作を指定していません）。RAが現時点で相互作用しているCAによって認定されていることを義務付けません（したがって、1つのRAは1回しか認定されていないが、複数のCAで動作する可能性があります）。"
    },
    {
      "indent": 3,
      "text": "In some circumstances, end entities will communicate directly with a CA even where an RA is present. For example, for initial registration and/or certification, the subject may use its RA, but communicate directly with the CA in order to refresh its certificate.",
      "ja": "状況によっては、最終エンティティはRAが存在する場合でもCAと直接通信します。たとえば、最初の登録および/または認定の場合、被験者はRAを使用する場合がありますが、証明書を更新するためにCAと直接通信します。"
    },
    {
      "indent": 0,
      "text": "3.1.2. PKI Management Requirements",
      "section_title": true,
      "ja": "3.1.2. PKI管理要件"
    },
    {
      "indent": 3,
      "text": "The protocols given here meet the following requirements on PKI management",
      "ja": "ここで与えられたプロトコルは、PKI管理に関する次の要件を満たしています"
    },
    {
      "indent": 3,
      "text": "1. PKI management must conform to the ISO/IEC 9594-8/ITU-T X.509 standards.",
      "ja": "1. PKI管理は、ISO/IEC 9594-8/ITU-T X.509標準に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. It must be possible to regularly update any key pair without affecting any other key pair.",
      "ja": "2. 他のキーペアに影響を与えることなく、キーペアを定期的に更新することが可能である必要があります。"
    },
    {
      "indent": 3,
      "text": "3. The use of confidentiality in PKI management protocols must be kept to a minimum in order to ease acceptance in environments where strong confidentiality might cause regulatory problems.",
      "ja": "3. PKI管理プロトコルでの機密性の使用は、強力な機密性が規制上の問題を引き起こす可能性のある環境での受け入れを容易にするために、最小限に抑える必要があります。"
    },
    {
      "indent": 3,
      "text": "4. PKI management protocols must allow the use of different industry-standard cryptographic algorithms (specifically including RSA, DSA, MD5, and SHA-1). This means that any given CA, RA, or end entity may, in principle, use whichever algorithms suit it for its own key pair(s).",
      "ja": "4. PKI管理プロトコルは、異なる業界標準の暗号化アルゴリズム（特にRSA、DSA、MD5、およびSHA-1を含む）を使用することを許可する必要があります。これは、特定のCA、RA、またはENDエンティティが、原則として、独自のキーペアに合わせてどのアルゴリズムを使用するかを使用することを意味します。"
    },
    {
      "indent": 3,
      "text": "5. PKI management protocols must not preclude the generation of key pairs by the end-entity concerned, by an RA, or by a CA. Key generation may also occur elsewhere, but for the purposes of PKI management we can regard key generation as occurring wherever the key is first present at an end entity, RA, or CA.",
      "ja": "5. PKI管理プロトコルは、関係するエンティティ、RA、またはcaによって重要なペアの生成を排除してはなりません。キー生成も他の場所で発生する可能性がありますが、PKI管理の目的のために、キーが終了エンティティ、RA、またはCAで最初に存在する場合でもキー生成を発生すると見なすことができます。"
    },
    {
      "indent": 3,
      "text": "6. PKI management protocols must support the publication of certificates by the end-entity concerned, by an RA, or by a CA. Different implementations and different environments may choose any of the above approaches.",
      "ja": "6. PKI管理プロトコルは、関係するエンティティ、RA、またはCAによって、エンティティのエンティティの公開をサポートする必要があります。さまざまな実装とさまざまな環境が、上記のアプローチのいずれかを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "7. PKI management protocols must support the production of Certificate Revocation Lists (CRLs) by allowing certified end entities to make requests for the revocation of certificates. This must be done in such a way that the denial-of-service attacks, which are possible, are not made simpler.",
      "ja": "7. PKI管理プロトコルは、認定エンティティが証明書の取り消しの要求を行うことを許可することにより、証明書の取り消しリスト（CRL）の作成をサポートする必要があります。これは、可能なサービス拒否攻撃がより単純にならないように行う必要があります。"
    },
    {
      "indent": 3,
      "text": "8. PKI management protocols must be usable over a variety of \"transport\" mechanisms, specifically including mail, http, TCP/IP and ftp.",
      "ja": "8. PKI管理プロトコルは、特にメール、HTTP、TCP/IP、FTPなど、さまざまな「輸送」メカニズムで使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "9. Final authority for certification creation rests with the CA. No RA or end-entity equipment can assume that any certificate issued by a CA will contain what was requested; a CA may alter certificate field values or may add, delete, or alter extensions according to its operating policy. In other words, all PKI entities (end-entities, RAs, and CAs) must be capable of handling responses to requests for certificates in which the actual certificate issued is different from that requested (for example, a CA may shorten the validity period requested). Note that policy may dictate that the CA must not publish or otherwise distribute the certificate until the requesting entity has reviewed and accepted the newly-created certificate (typically through use of the certConf message).",
      "ja": "9. 認証作成の最終的な権限はCAにかかっています。RAまたはエンドエンティティ機器は、CAが発行した証明書には要求されたものが含まれていると想定できません。CAは、証明書のフィールド値を変更したり、その運用ポリシーに従って拡張機能を追加、削除、または変更する場合があります。言い換えれば、すべてのPKIエンティティ（エンドエンティティ、RAS、およびCA）は、発行された実際の証明書が要求された証明書とは異なる証明書のリクエストに対する応答を処理できる必要があります（たとえば、CAは要求された有効性期間を短くすることができます）。ポリシーは、要求エンティティが新たに作成された証明書をレビューして受け入れるまで、CAが証明書を公開またはその他の方法で配布してはならないことを指示する場合があることに注意してください（通常、CertConfメッセージの使用を通じて）。"
    },
    {
      "indent": 3,
      "text": "10. A graceful, scheduled change-over from one non-compromised CA key pair to the next (CA key update) must be supported (note that if the CA key is compromised, re-initialization must be performed for all entities in the domain of that CA). An end entity whose PSE contains the new CA public key (following a CA key update) must also be able to verify certificates verifiable using the old public key. End entities who directly trust the old CA key pair must also be able to verify certificates signed using the new CA private key (required for situations where the old CA public key is \"hardwired\" into the end entity's cryptographic equipment).",
      "ja": "10. 1つの非競合化されていないCAキーペアから次の（CAキーアップデート）までの優雅なスケジュールされた変更をサポートする必要があります（CAキーが侵害された場合、そのドメインのすべてのエンティティに対して再開始化を実行する必要があることに注意してください。CA）。PSEに新しいCA公開キー（CAキーの更新に従っている）が含まれているエンディティは、古い公開キーを使用して検証可能な証明書を検証できる必要があります。古いCAキーペアを直接信頼するエンディティは、新しいCAの秘密鍵を使用して署名された証明書を検証することもできなければなりません（古いCAの公開キーが最終エンティティの暗号機器に「ハードワイヤード」である状況に必要です）。"
    },
    {
      "indent": 3,
      "text": "11. The functions of an RA may, in some implementations or environments, be carried out by the CA itself. The protocols must be designed so that end entities will use the same protocol regardless of whether the communication is with an RA or CA. Naturally, the end entity must use the correct RA of CA public key to protect the communication.",
      "ja": "11. RAの機能は、いくつかの実装または環境で、CA自体によって実行される場合があります。プロトコルは、通信がRAまたはCAにあるかどうかに関係なく、エンディティが同じプロトコルを使用するように設計する必要があります。当然のことながら、最終エンティティは、通信を保護するためにCAの公開鍵の正しいRAを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "12. Where an end entity requests a certificate containing a given public key value, the end entity must be ready to demonstrate possession of the corresponding private key value. This may be accomplished in various ways, depending on the type of certification request. See Section 4.3 for details of the in-band methods defined for the PKIX-CMP (i.e., Certificate Management Protocol) messages.",
      "ja": "12. 終了エンティティが特定の公開キー値を含む証明書を要求する場合、最終エンティティは、対応する秘密キー値の所有を実証する準備ができている必要があります。これは、認証要求の種類に応じて、さまざまな方法で達成できます。PKIX-CMP（つまり、証明書管理プロトコル）メッセージに対して定義された帯域内のメソッドの詳細については、セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "3.1.3. PKI Management Operations",
      "section_title": true,
      "ja": "3.1.3. PKI管理操作"
    },
    {
      "indent": 3,
      "text": "The following diagram shows the relationship between the entities defined above in terms of the PKI management operations. The letters in the diagram indicate \"protocols\" in the sense that a defined set of PKI management messages can be sent along each of the lettered lines.",
      "ja": "次の図は、PKI管理操作に関して上記のエンティティ間の関係を示しています。図の文字は、PKI管理メッセージの定義されたセットを各文字行に沿って送信できるという意味で「プロトコル」を示しています。"
    },
    {
      "indent": 5,
      "text": "+---+     cert. publish        +------------+      j\n|   |  <---------------------  | End Entity | <-------\n| C |             g            +------------+      \"out-of-band\"\n| e |                            | ^                loading\n| r |                            | |      initial\n| t |                          a | | b     registration/\n|   |                            | |       certification\n| / |                            | |      key pair recovery\n|   |                            | |      key pair update\n| C |                            | |      certificate update\n| R |  PKI \"USERS\"               V |      revocation request\n| L | -------------------+-+-----+-+------+-+-------------------\n|   |  PKI MANAGEMENT    | ^              | ^\n|   |    ENTITIES      a | | b          a | | b\n| R |                    V |              | |\n| e |             g   +------+    d       | |\n| p |   <------------ | RA   | <-----+    | |\n| o |      cert.      |      | ----+ |    | |\n| s |       publish   +------+   c | |    | |\n| i |                              | |    | |\n| t |                              V |    V |\n| o |          g                 +------------+   i\n| r |   <------------------------|     CA     |------->\n| y |          h                 +------------+  \"out-of-band\"\n|   |      cert. publish              | ^         publication\n|   |      CRL publish                | |\n+---+                                 | |    cross-certification\n                                    e | | f  cross-certificate\n                                      | |       update\n                                      | |\n                                      V |\n                                    +------+\n                                    | CA-2 |\n                                    +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 1 - PKI Entities",
      "ja": "図1- PKIエンティティ"
    },
    {
      "indent": 5,
      "text": "At a high level, the set of operations for which management messages are defined can be grouped as follows.",
      "ja": "高レベルでは、管理メッセージが定義される一連の操作を次のようにグループ化できます。"
    },
    {
      "indent": 3,
      "text": "1. CA establishment: When establishing a new CA, certain steps are required (e.g., production of initial CRLs, export of CA public key).",
      "ja": "1. CA設立：新しいCAを確立するとき、特定の手順が必要です（例：初期CRLの生産、CA公開鍵の輸出）。"
    },
    {
      "indent": 3,
      "text": "2. End entity initialization: this includes importing a root CA public key and requesting information about the options supported by a PKI management entity.",
      "ja": "2. End Entityの初期化：これには、ルートCAの公開キーのインポートと、PKI管理エンティティによってサポートされているオプションに関する情報の要求が含まれます。"
    },
    {
      "indent": 3,
      "text": "3. Certification: various operations result in the creation of new certificates:",
      "ja": "3. 認定：さまざまな操作により、新しい証明書が作成されます。"
    },
    {
      "indent": 7,
      "text": "1. initial registration/certification: This is the process whereby an end entity first makes itself known to a CA or RA, prior to the CA issuing a certificate or certificates for that end entity. The end result of this process (when it is successful) is that a CA issues a certificate for an end entity's public key, and returns that certificate to the end entity and/or posts that certificate in a public repository. This process may, and typically will, involve multiple \"steps\", possibly including an initialization of the end entity's equipment. For example, the end entity's equipment must be securely initialized with the public key of a CA, to be used in validating certificate paths. Furthermore, an end entity typically needs to be initialized with its own key pair(s).",
      "ja": "1. 初期登録/認証：これは、CAがその最終エンティティの証明書または証明書を発行する前に、最終エンティティが最初にCAまたはRAに自分自身を知られるプロセスです。このプロセスの最終結果（成功した場合）は、CAがEnd End Entityの公開キーの証明書を発行し、その証明書をEnd Entityおよび/またはその証明書に公開リポジトリに投稿することです。このプロセスは、最終エンティティの機器の初期化を含む、複数の「ステップ」が含まれる場合があります。たとえば、End Entityの機器は、CAの公開鍵で安全に初期化され、証明書パスの検証に使用する必要があります。さらに、最終エンティティは通常、独自のキーペアで初期化する必要があります。"
    },
    {
      "indent": 7,
      "text": "2. key pair update: Every key pair needs to be updated regularly (i.e., replaced with a new key pair), and a new certificate needs to be issued.",
      "ja": "2. キーペアの更新：すべてのキーペアを定期的に更新する必要があり（つまり、新しいキーペアに置き換えられます）、新しい証明書を発行する必要があります。"
    },
    {
      "indent": 7,
      "text": "3. certificate update: As certificates expire, they may be \"refreshed\" if nothing relevant in the environment has changed.",
      "ja": "3. 証明書の更新：証明書が期限切れになると、環境に関連するものが変更されていない場合、「リフレッシュ」される可能性があります。"
    },
    {
      "indent": 7,
      "text": "4. CA key pair update: As with end entities, CA key pairs need to be updated regularly; however, different mechanisms are required.",
      "ja": "4. CAキーペアの更新：END ENTITIESと同様に、CAキーペアを定期的に更新する必要があります。ただし、さまざまなメカニズムが必要です。"
    },
    {
      "indent": 7,
      "text": "5. cross-certification request: One CA requests issuance of a cross-certificate from another CA. For the purposes of this standard, the following terms are defined. A \"cross-certificate\" is a certificate in which the subject CA and the issuer CA are distinct and SubjectPublicKeyInfo contains a verification key (i.e., the certificate has been issued for the subject CA's signing key pair). When it is necessary to distinguish more finely, the following terms may be used: a cross-certificate is called an \"inter-domain cross-certificate\" if the subject and issuer CAs belong to different administrative domains; it is called an \"intra-domain cross-certificate\" otherwise.",
      "ja": "5. 相互認証要求：あるCAは、別のCAから相互認証の発行を要求します。この基準の目的のために、次の用語が定義されています。「クロス認証」は、対象CAおよび発行者CAが明確であり、件名PublicKeyInfoが検証キーを含む証明書です（つまり、被験者のCAの署名キーペアに対して証明書が発行されました）。より細かく区別する必要がある場合、次の用語を使用できます。クロス認証は、被験者と発行者CAが異なる管理ドメインに属している場合、「ドメイン間の相互認証」と呼ばれます。それ以外の場合は、「ドメイン内クロス認証」と呼ばれます。"
    },
    {
      "indent": 11,
      "text": "1. Note 1. The above definition of \"cross-certificate\" aligns with the defined term \"CA-certificate\" in X.509. Note that this term is not to be confused with the X.500 \"cACertificate\" attribute type, which is unrelated.",
      "ja": "1. 注1.上記の「クロス認証」の定義は、X.509の定義された用語「Ca certificate」と一致します。この用語は、無関係のX.500 \"cacertificate\"属性タイプと混同しないことに注意してください。"
    },
    {
      "indent": 11,
      "text": "2. Note 2. In many environments, the term \"cross-certificate\", unless further qualified, will be understood to be synonymous with \"inter-domain cross-certificate\" as defined above.",
      "ja": "2. 注2.多くの環境では、「クロス認証」という用語は、さらに資格を与えない限り、上記のように「ドメイン間の相互認証」と同義であると理解されます。"
    },
    {
      "indent": 11,
      "text": "3. Note 3. Issuance of cross-certificates may be, but is not necessarily, mutual; that is, two CAs may issue cross-certificates for each other.",
      "ja": "3. 注3.クロス認証の発行は、必ずしも相互のものではありません。つまり、2つのCASが相互に相互に認証される可能性があります。"
    },
    {
      "indent": 7,
      "text": "6. cross-certificate update: Similar to a normal certificate update, but involving a cross-certificate.",
      "ja": "6. クロス認証の更新：通常の証明書の更新と同様ですが、クロス認証が含まれます。"
    },
    {
      "indent": 3,
      "text": "4. Certificate/CRL discovery operations: some PKI management operations result in the publication of certificates or CRLs:",
      "ja": "4. 証明書/CRL発見操作：一部のPKI管理操作により、証明書またはCRLの公開が発生します。"
    },
    {
      "indent": 7,
      "text": "1. certificate publication: Having gone to the trouble of producing a certificate, some means for publishing it is needed. The \"means\" defined in PKIX MAY involve the messages specified in Sections 5.3.13 to 5.3.16, or MAY involve other methods (LDAP, for example) as described in [RFC2559], [RFC2585] (the \"Operational Protocols\" documents of the PKIX series of specifications).",
      "ja": "1. 証明書の公開：証明書を作成するのに苦労したため、それを公開するための何らかの手段が必要です。PKIXで定義されている「平均」には、セクション5.3.13から5.3.16で指定されたメッセージが含まれる場合があります。または、[RFC2559]、[RFC2585]（「運用プロトコル」文書で説明されている他の方法（LDAPなど）が含まれる場合があります。PKIXシリーズの仕様の）。"
    },
    {
      "indent": 7,
      "text": "2. CRL publication: As for certificate publication.",
      "ja": "2. CRLの公開：証明書の公開について。"
    },
    {
      "indent": 3,
      "text": "5. Recovery operations: some PKI management operations are used when an end entity has \"lost\" its PSE:",
      "ja": "5. 回復操作：一部のPKI管理操作は、最終エンティティがPSEを「失った」ときに使用されます。"
    },
    {
      "indent": 7,
      "text": "1. key pair recovery: As an option, user client key materials (e.g., a user's private key used for decryption purposes) MAY be backed up by a CA, an RA, or a key backup system associated with a CA or RA. If an entity needs to recover these backed up key materials (e.g., as a result of a forgotten password or a lost key chain file), a protocol exchange may be needed to support such recovery.",
      "ja": "1. キーペアの回復：オプションとして、ユーザークライアントのキー資料（たとえば、復号化目的で使用されるユーザーの秘密鍵）は、CA、RA、またはCAまたはRAに関連するキーバックアップシステムによってバックアップされる場合があります。エンティティがこれらのバックアップされた主要な資料を回復する必要がある場合（たとえば、忘れられたパスワードまたは失われたキーチェーンファイルの結果として）、そのような回復をサポートするためにプロトコル交換が必要になる場合があります。"
    },
    {
      "indent": 3,
      "text": "6. Revocation operations: some PKI operations result in the creation of new CRL entries and/or new CRLs:",
      "ja": "6. 取り消し操作：一部のPKI操作により、新しいCRLエントリおよび/または新しいCRLが作成されます。"
    },
    {
      "indent": 7,
      "text": "1. revocation request: An authorized person advises a CA of an abnormal situation requiring certificate revocation.",
      "ja": "1. 取り消しリクエスト：認定者は、CAに証明書の取り消しを必要とする異常な状況を助言します。"
    },
    {
      "indent": 3,
      "text": "7. PSE operations: whilst the definition of PSE operations (e.g., moving a PSE, changing a PIN, etc.) are beyond the scope of this specification, we do define a PKIMessage (CertRepMessage) that can form the basis of such operations.",
      "ja": "7. PSE操作：PSE操作の定義（たとえば、PSEの移動、PINの変更など）はこの仕様の範囲を超えていますが、そのような操作の基礎を形成できるpkimessage（certrepmessage）を定義します。"
    },
    {
      "indent": 3,
      "text": "Note that on-line protocols are not the only way of implementing the above operations. For all operations, there are off-line methods of achieving the same result, and this specification does not mandate use of on-line protocols. For example, when hardware tokens are used, many of the operations MAY be achieved as part of the physical token delivery.",
      "ja": "オンラインプロトコルは、上記の操作を実装する唯一の方法ではないことに注意してください。すべての操作について、同じ結果を達成するオフラインの方法があり、この仕様はオンラインプロトコルの使用を義務付けていません。たとえば、ハードウェアトークンを使用すると、物理トークン配信の一部として多くの操作が達成される場合があります。"
    },
    {
      "indent": 3,
      "text": "Later sections define a set of standard messages supporting the above operations. Transport protocols for conveying these exchanges in different environments (file-based, on-line, E-mail, and WWW) are beyond the scope of this document and are specified separately.",
      "ja": "後のセクションでは、上記の操作をサポートする一連の標準メッセージを定義します。さまざまな環境（ファイルベース、オンライン、電子メール、www）でこれらの交換を伝えるための輸送プロトコルは、このドキュメントの範囲を超えており、個別に指定されています。"
    },
    {
      "indent": 0,
      "text": "4. Assumptions and Restrictions",
      "section_title": true,
      "ja": "4. 仮定と制限"
    },
    {
      "indent": 0,
      "text": "4.1. End Entity Initialization",
      "section_title": true,
      "ja": "4.1. エンティティの初期化を終了します"
    },
    {
      "indent": 3,
      "text": "The first step for an end entity in dealing with PKI management entities is to request information about the PKI functions supported and to securely acquire a copy of the relevant root CA public key(s).",
      "ja": "PKI管理エンティティを扱う最終エンティティの最初のステップは、サポートされているPKI関数に関する情報を要求し、関連するルートCA公開キーのコピーを安全に取得することです。"
    },
    {
      "indent": 0,
      "text": "4.2. Initial Registration/Certification",
      "section_title": true,
      "ja": "4.2. 初期登録/認定"
    },
    {
      "indent": 3,
      "text": "There are many schemes that can be used to achieve initial registration and certification of end entities. No one method is suitable for all situations due to the range of policies that a CA may implement and the variation in the types of end entity which can occur.",
      "ja": "最終エンティティの初期登録と認証を実現するために使用できる多くのスキームがあります。CAが実装できるポリシーの範囲と発生する可能性のあるエンティティのタイプの変動により、すべての状況に適した方法はありません。"
    },
    {
      "indent": 3,
      "text": "However, we can classify the initial registration/certification schemes that are supported by this specification. Note that the word \"initial\", above, is crucial: we are dealing with the situation where the end entity in question has had no previous contact with the PKI. Where the end entity already possesses certified keys, then some simplifications/alternatives are possible.",
      "ja": "ただし、この仕様でサポートされている最初の登録/認証スキームを分類できます。上記の「初期」という言葉が重要であることに注意してください。問題の最終エンティティがPKIと以前に接触していない状況に対処しています。最終エンティティがすでに認定キーを所有している場合、いくつかの単純化/代替案が可能です。"
    },
    {
      "indent": 3,
      "text": "Having classified the schemes that are supported by this specification we can then specify some as mandatory and some as optional. The goal is that the mandatory schemes cover a sufficient number of the cases that will arise in real use, whilst the optional schemes are available for special cases that arise less frequently. In this way, we achieve a balance between flexibility and ease of implementation.",
      "ja": "この仕様でサポートされているスキームを分類した後、一部は必須でオプションとして指定できます。目標は、必須のスキームが実際に使用されて発生する十分な数のケースをカバーしているのに対し、オプションのスキームはあまり頻繁に発生する特別なケースで利用できることです。このようにして、実装の柔軟性と容易さのバランスをとっています。"
    },
    {
      "indent": 3,
      "text": "We will now describe the classification of initial registration/certification schemes.",
      "ja": "ここで、初期登録/認証スキームの分類について説明します。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Criteria Used",
      "section_title": true,
      "ja": "4.2.1. 使用される基準"
    },
    {
      "indent": 0,
      "text": "4.2.1.1. Initiation of Registration/Certification",
      "section_title": true,
      "ja": "4.2.1.1. 登録/認証の開始"
    },
    {
      "indent": 3,
      "text": "In terms of the PKI messages that are produced, we can regard the initiation of the initial registration/certification exchanges as occurring wherever the first PKI message relating to the end entity is produced. Note that the real-world initiation of the registration/certification procedure may occur elsewhere (e.g., a personnel department may telephone an RA operator).",
      "ja": "作成されたPKIメッセージに関しては、終了エンティティに関連する最初のPKIメッセージが作成されている場合でも発生する最初の登録/認証交換の開始を考慮することができます。登録/認証手順の実際の開始は、他の場所で発生する可能性があることに注意してください（たとえば、人事部門がRAオペレーターに電話することができます）。"
    },
    {
      "indent": 3,
      "text": "The possible locations are at the end entity, an RA, or a CA.",
      "ja": "考えられる場所は、終了エンティティ、RA、またはCAです。"
    },
    {
      "indent": 0,
      "text": "4.2.1.2. End Entity Message Origin Authentication",
      "section_title": true,
      "ja": "4.2.1.2. End EntityメッセージOrigin Authentication"
    },
    {
      "indent": 3,
      "text": "The on-line messages produced by the end entity that requires a certificate may be authenticated or not. The requirement here is to authenticate the origin of any messages from the end entity to the PKI (CA/RA).",
      "ja": "証明書を必要とするEnd Entityによって作成されたオンラインメッセージは、認証されるかどうか。ここでの要件は、最終エンティティからPKI（CA/RA）へのメッセージの原点を認証することです。"
    },
    {
      "indent": 3,
      "text": "In this specification, such authentication is achieved by the PKI (CA/RA) issuing the end entity with a secret value (initial authentication key) and reference value (used to identify the secret value) via some out-of-band means. The initial authentication key can then be used to protect relevant PKI messages.",
      "ja": "この仕様では、このような認証は、帯域外の平均を介して秘密値（初期認証キー）と基準値（秘密値を識別するために使用）を持つ最終エンティティを発行するPKI（CA/RA）によって達成されます。その後、初期認証キーを使用して、関連するPKIメッセージを保護できます。"
    },
    {
      "indent": 3,
      "text": "Thus, we can classify the initial registration/certification scheme according to whether or not the on-line end entity -> PKI messages are authenticated or not.",
      "ja": "したがって、オンラインの終了エンティティ - > PKIメッセージが認証されているかどうかに応じて、初期登録/認証スキームを分類できます。"
    },
    {
      "indent": 3,
      "text": "Note 1: We do not discuss the authentication of the PKI -> end entity messages here, as this is always REQUIRED. In any case, it can be achieved simply once the root-CA public key has been installed at the end entity's equipment or it can be based on the initial authentication key.",
      "ja": "注1：これは常に必要なので、ここではPKI-> ENDエンティティメッセージの認証については説明しません。いずれにせよ、それは単にルートCAの公開キーが最後のエンティティの機器にインストールされた後に達成するか、初期認証キーに基づいていることができます。"
    },
    {
      "indent": 3,
      "text": "Note 2: An initial registration/certification procedure can be secure where the messages from the end entity are authenticated via some out-of-band means (e.g., a subsequent visit).",
      "ja": "注2：最初の登録/認証手順は、最終エンティティからのメッセージが帯域外の手段を介して認証されている場合（例：その後の訪問）安全です。"
    },
    {
      "indent": 0,
      "text": "4.2.1.3. Location of Key Generation",
      "section_title": true,
      "ja": "4.2.1.3. キー生成の場所"
    },
    {
      "indent": 3,
      "text": "In this specification, \"key generation\" is regarded as occurring wherever either the public or private component of a key pair first occurs in a PKIMessage. Note that this does not preclude a centralized key generation service; the actual key pair MAY have been generated elsewhere and transported to the end entity, RA, or CA using a (proprietary or standardized) key generation request/response protocol (outside the scope of this specification).",
      "ja": "この仕様では、「キー生成」は、キーペアのパブリックまたはプライベートコンポーネントが最初にpkimessageで発生する場合でも発生すると見なされます。これは、集中化されたキージェネレーションサービスを排除しないことに注意してください。実際のキーペアは他の場所で生成され、（独自または標準化された）キー生成要求/応答プロトコル（この仕様の範囲外）を使用して、最終エンティティ、RA、またはCAに輸送された可能性があります。"
    },
    {
      "indent": 3,
      "text": "Thus, there are three possibilities for the location of \"key generation\": the end entity, an RA, or a CA.",
      "ja": "したがって、「キー生成」の場所には3つの可能性があります。最終エンティティ、RA、またはCA。"
    },
    {
      "indent": 0,
      "text": "4.2.1.4. Confirmation of Successful Certification",
      "section_title": true,
      "ja": "4.2.1.4. 成功した認定の確認"
    },
    {
      "indent": 3,
      "text": "Following the creation of an initial certificate for an end entity, additional assurance can be gained by having the end entity explicitly confirm successful receipt of the message containing (or indicating the creation of) the certificate. Naturally, this confirmation message must be protected (based on the initial authentication key or other means).",
      "ja": "終了エンティティの初期証明書が作成された後、証明書を含む（または作成を示す）メッセージの受領を成功させることを確認することにより、追加の保証を得ることができます。当然のことながら、この確認メッセージは保護する必要があります（初期認証キーまたはその他の手段に基づいて）。"
    },
    {
      "indent": 3,
      "text": "This gives two further possibilities: confirmed or not.",
      "ja": "これにより、さらに2つの可能性が得られます。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Mandatory Schemes",
      "section_title": true,
      "ja": "4.2.2. 必須スキーム"
    },
    {
      "indent": 3,
      "text": "The criteria above allow for a large number of initial registration/certification schemes. This specification mandates that conforming CA equipment, RA equipment, and EE equipment MUST support the second scheme listed below (Section 4.2.2.2). Any entity MAY additionally support other schemes, if desired.",
      "ja": "上記の基準により、多数の初期登録/認証スキームが可能になります。この仕様は、CA機器、RA機器、およびEE機器の適合が、以下にリストされている2番目のスキームをサポートする必要があることを義務付けています（セクション4.2.2.2）。必要に応じて、他のスキームをさらにサポートする場合があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2.1. Centralized Scheme",
      "section_title": true,
      "ja": "4.2.2.1. 集中スキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is, in some ways, the simplest possible, where:",
      "ja": "上記の分類に関しては、このスキームは、可能な限り最も単純なものです。"
    },
    {
      "indent": 3,
      "text": "o initiation occurs at the certifying CA;",
      "ja": "o 認定CAで開始が発生します。"
    },
    {
      "indent": 3,
      "text": "o no on-line message authentication is required;",
      "ja": "o オンラインメッセージ認証は必要ありません。"
    },
    {
      "indent": 3,
      "text": "o \"key generation\" occurs at the certifying CA (see Section 4.2.1.3);",
      "ja": "o 「キー生成」は、認定CAで発生します（セクション4.2.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o no confirmation message is required.",
      "ja": "o 確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, this scheme means that the only message required is sent from the CA to the end entity. The message must contain the entire PSE for the end entity. Some out-of-band means must be provided to allow the end entity to authenticate the message received and to decrypt any encrypted values.",
      "ja": "メッセージフローに関して、このスキームは、必要なメッセージのみがCAからEnd Entityに送信されることを意味します。メッセージには、終了エンティティのPSE全体が含まれている必要があります。最終エンティティが受信したメッセージを認証し、暗号化された値を復号化できるようにするために、いくつかの帯域外の手段を提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.2.2. Basic Authenticated Scheme",
      "section_title": true,
      "ja": "4.2.2.2. 基本的な認証されたスキーム"
    },
    {
      "indent": 3,
      "text": "In terms of the classification above, this scheme is where:",
      "ja": "上記の分類に関しては、このスキームは次の場所です。"
    },
    {
      "indent": 3,
      "text": "o initiation occurs at the end entity;",
      "ja": "o 終了エンティティで開始が発生します。"
    },
    {
      "indent": 3,
      "text": "o message authentication is REQUIRED;",
      "ja": "o メッセージ認証が必要です。"
    },
    {
      "indent": 3,
      "text": "o \"key generation\" occurs at the end entity (see Section 4.2.1.3);",
      "ja": "o 「キー生成」は、最後のエンティティで発生します（セクション4.2.1.3を参照）。"
    },
    {
      "indent": 3,
      "text": "o a confirmation message is REQUIRED.",
      "ja": "o 確認メッセージが必要です。"
    },
    {
      "indent": 3,
      "text": "In terms of message flow, the basic authenticated scheme is as follows:",
      "ja": "メッセージフローに関しては、基本的な認証されたスキームは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "End entity                                          RA/CA\n==========                                      =============\n     out-of-band distribution of Initial Authentication\n     Key (IAK) and reference value (RA/CA -> EE)\nKey generation\nCreation of certification request\nProtect request with IAK\n              -->>-- certification request -->>--\n                                               verify request\n                                               process request\n                                               create response\n              --<<-- certification response --<<--\nhandle response\ncreate confirmation\n              -->>-- cert conf message      -->>--\n                                               verify confirmation\n                                               create response\n              --<<-- conf ack (optional)    --<<--\nhandle response",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Where verification of the cert confirmation message fails, the RA/CA MUST revoke the newly issued certificate if it has been published or otherwise made available.)",
      "ja": "（証明書確認メッセージの検証が失敗した場合、RA/CAは、公開された、またはその他の方法で利用可能になった場合、新しく発行された証明書を取り消す必要があります。）"
    },
    {
      "indent": 0,
      "text": "4.3. Proof-of-Possession (POP) of Private Key",
      "section_title": true,
      "ja": "4.3. プライベートキーのプルーフポッセッション（ポップ）"
    },
    {
      "indent": 3,
      "text": "In order to prevent certain attacks and to allow a CA/RA to properly check the validity of the binding between an end entity and a key pair, the PKI management operations specified here make it possible for an end entity to prove that it has possession of (i.e., is able to use) the private key corresponding to the public key for which a certificate is requested. A given CA/RA is free to choose how to enforce POP (e.g., out-of-band procedural means versus PKIX-CMP in-band messages) in its certification exchanges (i.e., this may be a policy issue). However, it is REQUIRED that CAs/RAs MUST enforce POP by some means because there are currently many non-PKIX operational protocols in use (various electronic mail protocols are one example) that do not explicitly check the binding between the end entity and the private key. Until operational protocols that do verify the binding (for signature, encryption, and key agreement key pairs) exist, and are ubiquitous, this binding can only be assumed to have been verified by the CA/RA. Therefore, if the binding is not verified by the CA/RA, certificates in the Internet Public-Key Infrastructure end up being somewhat less meaningful.",
      "ja": "特定の攻撃を防止し、CA/RAが最終エンティティとキーペアの間の拘束力のある有効性を適切に確認できるようにするために、ここで指定されたPKI管理操作により、エンディティが所有していることを証明することが可能になります。（つまり、使用することができます）証明書が要求されている公開鍵に対応する秘密鍵。特定のCA/RAは、認定交換でPOP（たとえば、帯域外の手続き的平均とPKIX-CMPインバンドメッセージ）を強制する方法を自由に選択できます（つまり、これはポリシーの問題かもしれません）。ただし、現在使用されている非PKIX運用プロトコル（さまざまな電子メールプロトコルが1つの例）があるため、CAS/RASが何らかの形でPOPを実施する必要があります。鍵。バインディング（署名、暗号化、および主要な一致キーペアの場合）を検証する運用プロトコルが存在し、ユビキタスであるまで、この結合はCa/RAによって検証されたとのみ想定できます。したがって、バインディングがCA/RAによって検証されていない場合、インターネットの公開キーインフラストラクチャの証明書は、やや意味が低くなります。"
    },
    {
      "indent": 3,
      "text": "POP is accomplished in different ways depending upon the type of key for which a certificate is requested. If a key can be used for multiple purposes (e.g., an RSA key) then any appropriate method MAY",
      "ja": "POPは、証明書が要求されるキーのタイプに応じて、さまざまな方法で達成されます。キーを複数の目的（RSAキーなど）に使用できる場合、適切な方法は"
    },
    {
      "indent": 3,
      "text": "be used (e.g., a key that may be used for signing, as well as other purposes, SHOULD NOT be sent to the CA/RA in order to prove possession).",
      "ja": "使用する（例えば、署名に使用される可能性のあるキー、およびその他の目的は、所有を証明するためにCA/RAに送信しないでください）。"
    },
    {
      "indent": 3,
      "text": "This specification explicitly allows for cases where an end entity supplies the relevant proof to an RA and the RA subsequently attests to the CA that the required proof has been received (and validated!). For example, an end entity wishing to have a signing key certified could send the appropriate signature to the RA, which then simply notifies the relevant CA that the end entity has supplied the required proof. Of course, such a situation may be disallowed by some policies (e.g., CAs may be the only entities permitted to verify POP during certification).",
      "ja": "この仕様により、最終エンティティが関連する証明をRAに供給し、その後RAが必要な証明を受け取った（および検証された！）CAに明示的に可能にします。たとえば、署名キーの認定を希望するエンティティは、適切な署名をRAに送信することができます。これにより、関連するCAが必要な証明を提供したことを単純に通知します。もちろん、このような状況は、いくつかのポリシーによって許可されている可能性があります（たとえば、CASは、認証中にPOPを検証することを許可されている唯一のエンティティである可能性があります）。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Signature Keys",
      "section_title": true,
      "ja": "4.3.1. 署名キー"
    },
    {
      "indent": 3,
      "text": "For signature keys, the end entity can sign a value to prove possession of the private key.",
      "ja": "署名キーの場合、最終エンティティは秘密鍵の所有を証明するために値に署名できます。"
    },
    {
      "indent": 0,
      "text": "4.3.2. Encryption Keys",
      "section_title": true,
      "ja": "4.3.2. 暗号化キー"
    },
    {
      "indent": 3,
      "text": "For encryption keys, the end entity can provide the private key to the CA/RA, or can be required to decrypt a value in order to prove possession of the private key (see Section 5.2.8). Decrypting a value can be achieved either directly or indirectly.",
      "ja": "暗号化キーの場合、最終エンティティはCA/RAの秘密鍵を提供するか、秘密鍵の所有を証明するために値を復号化するために必要とすることができます（セクション5.2.8を参照）。値を復号化することは、直接または間接的に達成できます。"
    },
    {
      "indent": 3,
      "text": "The direct method is for the RA/CA to issue a random challenge to which an immediate response by the EE is required.",
      "ja": "直接的な方法は、RA/CAがEEによる即時の応答が必要なランダムな課題を発行することです。"
    },
    {
      "indent": 3,
      "text": "The indirect method is to issue a certificate that is encrypted for the end entity (and have the end entity demonstrate its ability to decrypt this certificate in the confirmation message). This allows a CA to issue a certificate in a form that can only be used by the intended end entity.",
      "ja": "間接的な方法は、最終エンティティに対して暗号化された証明書を発行することです（そして、エンティティが確認メッセージでこの証明書を復号化する能力を実証します）。これにより、CAは、意図した最終エンティティによってのみ使用できるフォームで証明書を発行できます。"
    },
    {
      "indent": 3,
      "text": "This specification encourages use of the indirect method because it requires no extra messages to be sent (i.e., the proof can be demonstrated using the {request, response, confirmation} triple of messages).",
      "ja": "この仕様は、送信する余分なメッセージを必要としないため、間接的な方法の使用を促進します（つまり、{要求、応答、確認}メッセージのトリプルを使用して証明を実証できます）。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Key Agreement Keys",
      "section_title": true,
      "ja": "4.3.3. キー契約キー"
    },
    {
      "indent": 3,
      "text": "For key agreement keys, the end entity and the PKI management entity (i.e., CA or RA) must establish a shared secret key in order to prove that the end entity has possession of the private key.",
      "ja": "キー契約キーの場合、最終エンティティとPKI管理エンティティ（つまり、CAまたはRA）は、最終エンティティが秘密鍵を所有していることを証明するために、共有秘密の鍵を確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that this need not impose any restrictions on the keys that can be certified by a given CA. In particular, for Diffie-Hellman keys the end entity may freely choose its algorithm parameters provided that the CA can generate a short-term (or one-time) key pair with the appropriate parameters when necessary.",
      "ja": "これにより、特定のCAによって認証できるキーに制限を課す必要はないことに注意してください。特に、diffie-hellmanキーの場合、最終エンティティは、CAが必要に応じて適切なパラメーターを使用して短期（または1回限りの）キーペアを生成できる場合、そのアルゴリズムパラメーターを自由に選択できます。"
    },
    {
      "indent": 0,
      "text": "4.4. Root CA Key Update",
      "section_title": true,
      "ja": "4.4. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "This discussion only applies to CAs that are directly trusted by some end entities. Self-signed CAs SHALL be considered as directly trusted CAs. Recognizing whether a non-self-signed CA is supposed to be directly trusted for some end entities is a matter of CA policy and is thus beyond the scope of this document.",
      "ja": "この議論は、一部の最終エンティティから直接信頼されるCAにのみ適用されます。自己署名CAは、直接信頼できるCAと見なされます。非自己署名のCAが一部の最終エンティティに対して直接信頼されることになっているかどうかを認識することは、CAポリシーの問題であり、したがって、このドキュメントの範囲を超えています。"
    },
    {
      "indent": 3,
      "text": "The basis of the procedure described here is that the CA protects its new public key using its previous private key and vice versa. Thus, when a CA updates its key pair it must generate two extra cACertificate attribute values if certificates are made available using an X.500 directory (for a total of four: OldWithOld, OldWithNew, NewWithOld, and NewWithNew).",
      "ja": "ここで説明する手順の基礎は、CAが以前の秘密鍵を使用して新しい公開キーを保護し、その逆も同様です。したがって、CAがキーペアを更新する場合、X.500ディレクトリを使用して証明書が利用可能になった場合、2つの追加のCACERTIFICATE属性値を生成する必要があります（OldWithold、OldWithNew、NewWithold、およびNewWithNew）。"
    },
    {
      "indent": 3,
      "text": "When a CA changes its key pair, those entities who have acquired the old CA public key via \"out-of-band\" means are most affected. It is these end entities who will need access to the new CA public key protected with the old CA private key. However, they will only require this for a limited period (until they have acquired the new CA public key via the \"out-of-band\" mechanism). This will typically be easily achieved when these end entities' certificates expire.",
      "ja": "CAがキーペアを変更すると、「帯域外」平均を介して古いCAの公開キーを取得したエンティティが最も影響を受けます。古いCAの秘密鍵で保護されている新しいCA公開キーにアクセスする必要があるのは、これらの最終エンティティです。ただし、限られた期間のみこれを必要とします（「バンド外」メカニズムを介して新しいCA公開キーを取得するまで）。これは通常、これらの最終エンティティの証明書が期限切れになると簡単に達成されます。"
    },
    {
      "indent": 3,
      "text": "The data structure used to protect the new and old CA public keys is a standard certificate (which may also contain extensions). There are no new data structures required.",
      "ja": "新しいCAパブリックキーを保護するために使用されるデータ構造は、標準証明書です（拡張機能も含まれている場合があります）。新しいデータ構造は必要ありません。"
    },
    {
      "indent": 3,
      "text": "Note 1. This scheme does not make use of any of the X.509 v3 extensions as it must be able to work even for version 1 certificates. The presence of the KeyIdentifier extension would make for efficiency improvements.",
      "ja": "注1.このスキームは、バージョン1の証明書でも機能する必要があるため、X.509 V3拡張機能のいずれも使用していません。KeyIdentifier拡張機能の存在により、効率の改善が可能になります。"
    },
    {
      "indent": 3,
      "text": "Note 2. While the scheme could be generalized to cover cases where the CA updates its key pair more than once during the validity period of one of its end entities' certificates, this generalization seems of dubious value. Not having this generalization simply means that the validity periods of certificates issued with the old CA key pair cannot exceed the end of the OldWithNew validity period.",
      "ja": "注2.スキームは、CAがその最終エンティティの証明書の1つの有効期間中にキーペアを複数回更新するケースをカバーするために一般化できますが、この一般化は疑わしい価値のようです。この一般化を持たないということは、単に古いCAキーペアで発行された証明書の有効期間が、古いものの有効性期間の終わりを超えることができないことを意味します。"
    },
    {
      "indent": 3,
      "text": "Note 3. This scheme ensures that end entities will acquire the new CA public key, at the latest by the expiry of the last certificate they owned that was signed with the old CA private key (via the \"out-of-band\" means). Certificate and/or key update operations occurring at other times do not necessarily require this (depending on the end entity's equipment).",
      "ja": "注3.このスキームは、エンディティが新しいCAの公開キーを取得することを保証します。最新の状態で、所有した最後の証明書の有効期限があります。。他の場合に発生する証明書および/または主要な更新操作は、必ずしもこれを必要とするわけではありません（エンティティのエンティティの機器に応じて）。"
    },
    {
      "indent": 0,
      "text": "4.4.1. CA Operator Actions",
      "section_title": true,
      "ja": "4.4.1. CAオペレーターアクション"
    },
    {
      "indent": 3,
      "text": "To change the key of the CA, the CA operator does the following:",
      "ja": "CAのキーを変更するには、CAオペレーターが次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Generate a new key pair;",
      "ja": "1. 新しいキーペアを生成します。"
    },
    {
      "indent": 3,
      "text": "2. Create a certificate containing the old CA public key signed with the new private key (the \"old with new\" certificate);",
      "ja": "2. 新しい秘密鍵（「新しい」証明書を持つ古い証明書）で署名された古いCA公開キーを含む証明書を作成します。"
    },
    {
      "indent": 3,
      "text": "3. Create a certificate containing the new CA public key signed with the old private key (the \"new with old\" certificate);",
      "ja": "3. 古い秘密鍵（「古い」証明書を「新しく」証明書）で署名した新しいCA公開キーを含む証明書を作成します。"
    },
    {
      "indent": 3,
      "text": "4. Create a certificate containing the new CA public key signed with the new private key (the \"new with new\" certificate);",
      "ja": "4. 新しい秘密鍵（「新しい」証明書を持つ「新しい」証明書）で署名された新しいCA公開キーを含む証明書を作成します。"
    },
    {
      "indent": 3,
      "text": "5. Publish these new certificates via the repository and/or other means (perhaps using a CAKeyUpdAnn message);",
      "ja": "5. これらの新しい証明書をリポジトリおよび/またはその他の手段から公開します（おそらくCakeYupDannメッセージを使用）。"
    },
    {
      "indent": 3,
      "text": "6. Export the new CA public key so that end entities may acquire it using the \"out-of-band\" mechanism (if required).",
      "ja": "6. 新しいCA公開キーをエクスポートして、エンティティが「帯域外」メカニズム（必要に応じて）を使用してそれを取得できるようにします。"
    },
    {
      "indent": 3,
      "text": "The old CA private key is then no longer required. However, the old CA public key will remain in use for some time. The old CA public key is no longer required (other than for non-repudiation) when all end entities of this CA have securely acquired the new CA public key.",
      "ja": "古いCAの秘密鍵は不要になりました。ただし、古いCAの公開キーはしばらくの間使用され続けます。このCAのすべての最終エンティティが新しいCAの公開キーを安全に取得した場合、古いCAの公開キーは（非repudiation以外）要求されなくなりました。"
    },
    {
      "indent": 3,
      "text": "The \"old with new\" certificate must have a validity period starting at the generation time of the old key pair and ending at the expiry date of the old public key.",
      "ja": "「古い」証明書は、古いキーペアの生成時に始まり、古い公開キーの有効期限で終了する有効期間を持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "The \"new with old\" certificate must have a validity period starting at the generation time of the new key pair and ending at the time by which all end entities of this CA will securely possess the new CA public key (at the latest, the expiry date of the old public key).",
      "ja": "「古い」証明書は、新しいキーペアの生成時に始まり、このCAのすべてのエンティティが新しいCA公開キーを安全に所有する時点で終了する有効期間を持たなければなりません（最新の場合、有効期限は有効です古い公開鍵の日付）。"
    },
    {
      "indent": 3,
      "text": "The \"new with new\" certificate must have a validity period starting at the generation time of the new key pair and ending at or before the time by which the CA will next update its key pair.",
      "ja": "「新しい」証明書は、新しいキーペアの生成時間から始まり、CAが次にキーペアを更新する時期以前に終了するまでの有効期間を持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Verifying Certificates",
      "section_title": true,
      "ja": "4.4.2. 証明書の検証"
    },
    {
      "indent": 3,
      "text": "Normally when verifying a signature, the verifier verifies (among other things) the certificate containing the public key of the signer. However, once a CA is allowed to update its key there are a range of new possibilities. These are shown in the table below.",
      "ja": "通常、署名を検証するとき、検証者は（とりわけ）署名者の公開鍵を含む証明書を（特に）検証します。ただし、CAがキーを更新することが許可されると、さまざまな新しい可能性があります。これらを下の表に示します。"
    },
    {
      "indent": 16,
      "text": "Repository contains NEW Repository contains only OLD and OLD public keys public key (due to, e.g., delay in publication)",
      "ja": "リポジトリには、新しいリポジトリには古い公開鍵と古い公開鍵のみが含まれています（たとえば、公開の遅延など）"
    },
    {
      "indent": 15,
      "text": "    PSE      PSE Contains  PSE Contains    PSE Contains\n Contains     OLD public    NEW public      OLD public\nNEW public       key            key            key\n    key",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Signer's   Case 1:      Case 3:       Case 5:        Case 7:\ncertifi-   This is      In this case  Although the   In this case\ncate is    the          the verifier  CA operator    the CA\nprotected  standard     must access   has not        operator  has\nusing NEW  case where   the           updated the    not updated\npublic     the          repository in repository the the repository\nkey        verifier     order to get  verifier can   and so the\n           can          the value of  verify the     verification\n           directly     the NEW       certificate    will FAIL\n           verify the   public key    directly -\n           certificate                this is thus\n           without                    the same as\n           using the                  case 1.\n           repository",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Signer's   Case 2:      Case 4:       Case 6:        Case 8:\ncertifi-   In this      In this case  The verifier   Although the\ncate is    case the     the verifier  thinks this    CA operator\nprotected  verifier     can directly  is the         has not\nusing OLD  must         verify the    situation of   updated the\npublic     access the   certificate   case 2 and     repository the\nkey        repository   without       will access    verifier can\n           in order     using the     the            verify the\n           to get the   repository    repository;    certificate\n           value of                   however, the   directly -\n           the OLD                    verification   this is thus\n           public key                 will FAIL      the same as\n                                                     case 4.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4.2.1. Verification in Cases 1, 4, 5, and 8",
      "section_title": true,
      "ja": "4.4.2.1. ケース1、4、5、および8の検証"
    },
    {
      "indent": 3,
      "text": "In these cases, the verifier has a local copy of the CA public key that can be used to verify the certificate directly. This is the same as the situation where no key change has occurred.",
      "ja": "これらの場合、検証者には、証明書を直接検証するために使用できるCA公開キーのローカルコピーがあります。これは、重要な変更が発生していない状況と同じです。"
    },
    {
      "indent": 3,
      "text": "Note that case 8 may arise between the time when the CA operator has generated the new key pair and the time when the CA operator stores the updated attributes in the repository. Case 5 can only arise if",
      "ja": "ケース8は、CAオペレーターが新しいキーペアを生成したときとCAオペレーターが更新された属性をリポジトリに保存するまでに発生する可能性があることに注意してください。ケース5は、場合にのみ発生することができます"
    },
    {
      "indent": 3,
      "text": "the CA operator has issued both the signer's and verifier's certificates during this \"gap\" (the CA operator SHOULD avoid this as it leads to the failure cases described below)",
      "ja": "CAオペレーターは、この「ギャップ」中に署名者と検証者の両方の証明書を発行しました（CAオペレーターは、以下に説明する障害ケースにつながるため、これを回避する必要があります）"
    },
    {
      "indent": 0,
      "text": "4.4.2.2. Verification in Case 2",
      "section_title": true,
      "ja": "4.4.2.2. ケース2の検証"
    },
    {
      "indent": 3,
      "text": "In case 2, the verifier must get access to the old public key of the CA. The verifier does the following:",
      "ja": "ケース2では、検証者はCAの古い公開鍵にアクセスする必要があります。検証者は次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Look up the caCertificate attribute in the repository and pick the OldWithNew certificate (determined based on validity periods; note that the subject and issuer fields must match);",
      "ja": "1. リポジトリのcacertificate属性を検索し、OldwithNew証明書を選択します（有効性期間に基づいて決定されます。被験者と発行者のフィールドは一致する必要があることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "2. Verify that this is correct using the new CA key (which the verifier has locally);",
      "ja": "2. これが新しいCAキー（検証者がローカルに持っている）を使用して正しいことを確認します。"
    },
    {
      "indent": 3,
      "text": "3. If correct, check the signer's certificate using the old CA key.",
      "ja": "3. 正しい場合は、古いCAキーを使用して署名者の証明書を確認してください。"
    },
    {
      "indent": 3,
      "text": "Case 2 will arise when the CA operator has issued the signer's certificate, then changed the key, and then issued the verifier's certificate; so it is quite a typical case.",
      "ja": "CAオペレーターが署名者の証明書を発行し、キーを変更してからVerifierの証明書を発行すると、ケース2が発生します。したがって、それは非常に典型的なケースです。"
    },
    {
      "indent": 0,
      "text": "4.4.2.3. Verification in Case 3",
      "section_title": true,
      "ja": "4.4.2.3. ケース3の検証"
    },
    {
      "indent": 3,
      "text": "In case 3, the verifier must get access to the new public key of the CA. The verifier does the following:",
      "ja": "ケース3では、検証者はCAの新しい公開鍵にアクセスする必要があります。検証者は次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Look up the CACertificate attribute in the repository and pick the NewWithOld certificate (determined based on validity periods; note that the subject and issuer fields must match);",
      "ja": "1. リポジトリのcacertificate属性を検索し、NewWithold証明書を選択します（有効期間に基づいて決定されます。被験者と発行者のフィールドは一致する必要があることに注意してください）。"
    },
    {
      "indent": 3,
      "text": "2. Verify that this is correct using the old CA key (which the verifier has stored locally);",
      "ja": "2. 古いCAキー（検証者がローカルに保存した）を使用してこれが正しいことを確認します。"
    },
    {
      "indent": 3,
      "text": "3. If correct, check the signer's certificate using the new CA key.",
      "ja": "3. 正しい場合は、新しいCAキーを使用して署名者の証明書を確認してください。"
    },
    {
      "indent": 3,
      "text": "Case 3 will arise when the CA operator has issued the verifier's certificate, then changed the key, and then issued the signer's certificate; so it is also quite a typical case.",
      "ja": "CAオペレーターがVerifierの証明書を発行し、キーを変更してから署名者の証明書を発行すると、ケース3が発生します。そのため、非常に典型的なケースでもあります。"
    },
    {
      "indent": 0,
      "text": "4.4.2.4. Failure of Verification in Case 6",
      "section_title": true,
      "ja": "4.4.2.4. ケース6の検証の失敗"
    },
    {
      "indent": 3,
      "text": "In this case, the CA has issued the verifier's PSE, which contains the new key, without updating the repository attributes. This means that the verifier has no means to get a trustworthy version of the CA's old key and so verification fails.",
      "ja": "この場合、CAは、リポジトリ属性を更新せずに、新しいキーを含むVerifierのPSEを発行しました。これは、検証者がCAの古いキーの信頼できるバージョンを取得する手段がないため、検証が失敗することを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that the failure is the CA operator's fault.",
      "ja": "障害はCAオペレーターのせいであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4.2.5. Failure of Verification in Case 7",
      "section_title": true,
      "ja": "4.4.2.5. ケース7の検証の失敗"
    },
    {
      "indent": 3,
      "text": "In this case, the CA has issued the signer's certificate protected with the new key without updating the repository attributes. This means that the verifier has no means to get a trustworthy version of the CA's new key and so verification fails.",
      "ja": "この場合、CAは、リポジトリ属性を更新せずに、新しいキーで保護された署名者の証明書を発行しました。これは、VerifierがCAの新しいキーの信頼できるバージョンを取得する手段がないため、検証が失敗することを意味します。"
    },
    {
      "indent": 3,
      "text": "Note that the failure is again the CA operator's fault.",
      "ja": "障害は再びCA演算子のせいであることに注意してください。"
    },
    {
      "indent": 0,
      "text": "4.4.3. Revocation - Change of CA Key",
      "section_title": true,
      "ja": "4.4.3. 取り消し -  CAキーの変更"
    },
    {
      "indent": 3,
      "text": "As we saw above, the verification of a certificate becomes more complex once the CA is allowed to change its key. This is also true for revocation checks as the CA may have signed the CRL using a newer private key than the one within the user's PSE.",
      "ja": "上で見たように、CAがキーを変更することが許可されると、証明書の検証がより複雑になります。これは、CAがユーザーのPSE内のキーよりも新しいプライベートキーを使用してCRLに署名した可能性があるため、取り消しチェックにも当てはまります。"
    },
    {
      "indent": 3,
      "text": "The analysis of the alternatives is the same as for certificate verification.",
      "ja": "代替案の分析は、証明書の検証と同じです。"
    },
    {
      "indent": 0,
      "text": "5. Data Structures",
      "section_title": true,
      "ja": "5. データ構造"
    },
    {
      "indent": 3,
      "text": "This section contains descriptions of the data structures required for PKI management messages. Section 6 describes constraints on their values and the sequence of events for each of the various PKI management operations.",
      "ja": "このセクションには、PKI管理メッセージに必要なデータ構造の説明が含まれています。セクション6では、さまざまなPKI管理操作のそれぞれの値と一連のイベントに関する制約について説明します。"
    },
    {
      "indent": 0,
      "text": "5.1. Overall PKI Message",
      "section_title": true,
      "ja": "5.1. 全体的なPKIメッセージ"
    },
    {
      "indent": 3,
      "text": "All of the messages used in this specification for the purposes of PKI management use the following structure:",
      "ja": "PKI管理の目的でこの仕様で使用されるすべてのメッセージは、次の構造を使用します。"
    },
    {
      "indent": 5,
      "text": " PKIMessage ::= SEQUENCE {\n    header           PKIHeader,\n    body             PKIBody,\n    protection   [0] PKIProtection OPTIONAL,\n    extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL\n}\nPKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The PKIHeader contains information that is common to many PKI messages.",
      "ja": "PKIHeaderには、多くのPKIメッセージに共通の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIBody contains message-specific information.",
      "ja": "pkibodyにはメッセージ固有の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "The PKIProtection, when used, contains bits that protect the PKI message.",
      "ja": "PKIPROTECTIONは、使用すると、PKIメッセージを保護するビットが含まれています。"
    },
    {
      "indent": 3,
      "text": "The extraCerts field can contain certificates that may be useful to the recipient. For example, this can be used by a CA or RA to present an end entity with certificates that it needs to verify its own new certificate (if, for example, the CA that issued the end entity's certificate is not a root CA for the end entity). Note that this field does not necessarily contain a certification path; the recipient may have to sort, select from, or otherwise process the extra certificates in order to use them.",
      "ja": "Extracertsフィールドには、受信者に役立つ可能性のある証明書を含めることができます。たとえば、これはCAまたはRAによって使用されて、独自の新しい証明書を検証する必要がある証明書を終了エンティティに提示することができます（たとえば、End Entityの証明書を発行したCAが終了のルートCAではない場合実在物）。このフィールドには必ずしも認証パスが含まれているわけではないことに注意してください。受信者は、使用するために追加の証明書を並べ替え、選択、または処理する必要がある場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. PKI Message Header",
      "section_title": true,
      "ja": "5.1.1. PKIメッセージヘッダー"
    },
    {
      "indent": 3,
      "text": "All PKI messages require some header information for addressing and transaction identification. Some of this information will also be present in a transport-specific envelope. However, if the PKI message is protected, then this information is also protected (i.e., we make no assumption about secure transport).",
      "ja": "すべてのPKIメッセージには、アドレス指定とトランザクション識別のためのヘッダー情報が必要です。この情報の一部は、輸送固有のエンベロープにも存在します。ただし、PKIメッセージが保護されている場合、この情報も保護されています（つまり、安全な輸送について仮定しません）。"
    },
    {
      "indent": 3,
      "text": "The following data structure is used to contain this information:",
      "ja": "次のデータ構造は、この情報を抑えるために使用されます。"
    },
    {
      "indent": 5,
      "text": "PKIHeader ::= SEQUENCE {\n    pvno                INTEGER     { cmp1999(1), cmp2000(2) },\n    sender              GeneralName,\n    recipient           GeneralName,\n    messageTime     [0] GeneralizedTime         OPTIONAL,\n    protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,\n    senderKID       [2] KeyIdentifier           OPTIONAL,\n    recipKID        [3] KeyIdentifier           OPTIONAL,\n    transactionID   [4] OCTET STRING            OPTIONAL,\n    senderNonce     [5] OCTET STRING            OPTIONAL,\n    recipNonce      [6] OCTET STRING            OPTIONAL,\n    freeText        [7] PKIFreeText             OPTIONAL,\n    generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                        InfoTypeAndValue     OPTIONAL\n}\nPKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The pvno field is fixed (at 2) for this version of this specification.",
      "ja": "この仕様のこのバージョンのPVNOフィールドは（2）固定されています。"
    },
    {
      "indent": 3,
      "text": "The sender field contains the name of the sender of the PKIMessage. This name (in conjunction with senderKID, if supplied) should be sufficient to indicate the key to use to verify the protection on the message. If nothing about the sender is known to the sending entity (e.g., in the init. req. message, where the end entity may not know its own Distinguished Name (DN), e-mail name, IP address, etc.), then the \"sender\" field MUST contain a \"NULL\" value; that is, the SEQUENCE OF relative distinguished names is of zero length. In such a case, the senderKID field MUST hold an identifier (i.e., a reference number) that indicates to the receiver the appropriate shared secret information to use to verify the message.",
      "ja": "送信者フィールドには、pkimessageの送信者の名前が含まれています。この名前（供給されている場合は、senderkidと併せて）は、メッセージの保護を検証するために使用する鍵を示すのに十分でなければなりません。送信者については、送信エンティティに知られていない場合（たとえば、init。req。メッセージで、最終エンティティが独自の著名な名前（DN）、電子メール名、IPアドレスなどを知らない場合があります）。「送信者」フィールドには、「null」値を含める必要があります。つまり、相対的な識別された名前のシーケンスはゼロの長さです。そのような場合、SenderKidフィールドは、メッセージを検証するために使用する適切な共有秘密情報を受信者に示す識別子（つまり、参照番号）を保持する必要があります。"
    },
    {
      "indent": 3,
      "text": "The recipient field contains the name of the recipient of the PKIMessage. This name (in conjunction with recipKID, if supplied) should be usable to verify the protection on the message.",
      "ja": "受信フィールドには、pkimessageの受信者の名前が含まれています。この名前（Recistkidと併せて、提供される場合）は、メッセージの保護を検証するために使用できる必要があります。"
    },
    {
      "indent": 3,
      "text": "The protectionAlg field specifies the algorithm used to protect the message. If no protection bits are supplied (note that PKIProtection is OPTIONAL) then this field MUST be omitted; if protection bits are supplied, then this field MUST be supplied.",
      "ja": "Protectionalgフィールドは、メッセージを保護するために使用されるアルゴリズムを指定します。保護ビットが供給されない場合（pkiprotectionはオプションであることに注意してください）、このフィールドは省略する必要があります。保護ビットが供給される場合は、このフィールドに供給する必要があります。"
    },
    {
      "indent": 3,
      "text": "senderKID and recipKID are usable to indicate which keys have been used to protect the message (recipKID will normally only be required where protection of the message uses Diffie-Hellman (DH) keys).",
      "ja": "SenderKidとRecipkidは、メッセージを保護するために使用されたキーを示すために使用可能です（通常、メッセージの保護がDiffie-Hellman（DH）キーを使用する場合にのみ必要です）。"
    },
    {
      "indent": 3,
      "text": "These fields MUST be used if required to uniquely identify a key (e.g., if more than one key is associated with a given sender name) and SHOULD be omitted otherwise.",
      "ja": "これらのフィールドは、キーをユニークに識別するために必要な場合（たとえば、特定の送信者名に複数のキーが関連付けられている場合）、それ以外の場合は省略する必要があります。"
    },
    {
      "indent": 3,
      "text": "The transactionID field within the message header is to be used to allow the recipient of a message to correlate this with an ongoing transaction. This is needed for all transactions that consist of more than just a single request/response pair. For transactions that consist of a single request/response pair, the rules are as follows. A client MAY populate the transactionID field of the request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MAY set transactionID field of the response.",
      "ja": "メッセージヘッダー内のTransactionIDフィールドを使用して、メッセージの受信者がこれを継続的なトランザクションと相関させることができます。これは、単一のリクエスト/応答ペア以上のもので構成されるすべてのトランザクションに必要です。単一のリクエスト/応答ペアで構成されるトランザクションの場合、ルールは次のとおりです。クライアントは、リクエストのTransactionIDフィールドに入力する場合があります。サーバーがTransactionIDフィールドセットを備えたそのような要求を受信した場合、同じ値への応答のTransactionIDフィールドを設定する必要があります。サーバーが不足しているTransactionIDフィールドでそのような要求を受信した場合、応答のTransactionIDフィールドを設定する場合があります。"
    },
    {
      "indent": 3,
      "text": "For transactions that consist of more than just a single request/response pair, the rules are as follows. Clients SHOULD generate a transactionID for the first request. If a server receives such a request that has the transactionID field set, then it MUST set the transactionID field of the response to the same value. If a server receives such request with a missing transactionID field, then it MUST populate the transactionID field of the response with a server-generated ID. Subsequent requests and responses MUST all set the transactionID field to the thus established value. In all cases where a transactionID is being used, a given client MUST NOT have more than one transaction with the same transactionID in progress at any time (to a given server). Servers are free to require uniqueness of the transactionID or not, as long as they are able to correctly associate messages with the corresponding transaction. Typically, this means that a server will require the {client, transactionID} tuple to be unique, or even the transactionID alone to be unique, if it cannot distinguish clients based on transport-level information. A server receiving the first message of a transaction (which requires more than a single request/response pair) that contains a transactionID that does not allow it to meet the above constraints (typically because the transactionID is already in use) MUST send back an ErrorMsgContent with a PKIFailureInfo of transactionIdInUse. It is RECOMMENDED that the clients fill the transactionID field with 128 bits of (pseudo-) random data for the start of a transaction to reduce the probability of having the transactionID in use at the server.",
      "ja": "単一のリクエスト/応答ペア以上のもので構成されるトランザクションの場合、ルールは次のとおりです。クライアントは、最初のリクエストのためにTransactionIDを生成する必要があります。サーバーがTransactionIDフィールドセットを備えたそのような要求を受信した場合、同じ値への応答のTransactionIDフィールドを設定する必要があります。サーバーが不足しているTransactionIDフィールドでそのような要求を受信した場合、サーバーで生成されたIDを使用して、応答のトランザクションIDフィールドに設置する必要があります。その後のリクエストと応答はすべて、TransactionIDフィールドをこのように確立された値に設定する必要があります。TransactionIDが使用されているすべての場合において、特定のクライアントは、いつでも（特定のサーバーに）進行中の同じトランザクションIDを使用して複数のトランザクションを持っている必要があります。サーバーは、対応するトランザクションにメッセージを正しく関連付けることができる限り、TransactionIDの独自性を自由に必要とします。通常、これは、サーバーが{クライアント、トランザクションID}タプルが一意であることを要求することを意味します。トランザクションレベルの情報に基づいてクライアントを区別できない場合は、{クライアント、トランザクションID}タプルが一意であることを要求することを意味します。トランザクションの最初のメッセージ（単一のリクエスト/応答ペアが必要）の最初のメッセージを受信するサーバーは、上記の制約を満たすことを許可しないトランザクションIDを含む（通常、トランザクションIDが既に使用されているため）、errormsgcontentを返送する必要があります。transactionidinuseのpkifailureinfoを使用。クライアントは、トランザクションの開始時にTransactionIDフィールドを128ビットの（擬似）ランダムデータで埋めて、サーバーでTransactionIDを使用する可能性を減らすことをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The senderNonce and recipNonce fields protect the PKIMessage against replay attacks. The senderNonce will typically be 128 bits of (pseudo-) random data generated by the sender, whereas the recipNonce is copied from the senderNonce of the previous message in the transaction.",
      "ja": "SendernonceとRecistnonceフィールドは、リプレイ攻撃からPkimessageを保護します。Sendernonceは通常、送信者によって生成された128ビットの（擬似）ランダムデータになりますが、Recipnonceはトランザクションの前のメッセージのSendernonceからコピーされます。"
    },
    {
      "indent": 3,
      "text": "The messageTime field contains the time at which the sender created the message. This may be useful to allow end entities to correct/check their local time for consistency with the time on a central system.",
      "ja": "Messagetimeフィールドには、送信者がメッセージを作成する時間が含まれています。これは、最終エンティティが中央システムの時間との一貫性について現地時間を修正/確認できるようにするのに役立つ場合があります。"
    },
    {
      "indent": 3,
      "text": "The freeText field may be used to send a human-readable message to the recipient (in any number of languages). The first language used in this sequence indicates the desired language for replies.",
      "ja": "フリーテキストフィールドを使用して、人間の読み取り可能なメッセージを受信者に（任意の数の言語で）送信することができます。このシーケンスで使用される第一言語は、返信に望ましい言語を示します。"
    },
    {
      "indent": 3,
      "text": "The generalInfo field may be used to send machine-processable additional data to the recipient. The following generalInfo extensions are defined and MAY be supported.",
      "ja": "GeneralInfoフィールドを使用して、マシン処理可能な追加データを受信者に送信できます。以下のgeneralInfo拡張機能が定義されており、サポートされる場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.1. ImplicitConfirm",
      "section_title": true,
      "ja": "5.1.1.1. 暗黙的なこと"
    },
    {
      "indent": 3,
      "text": "This is used by the EE to inform the CA that it does not wish to send a certificate confirmation for issued certificates.",
      "ja": "これは、発行された証明書の証明書確認を送信したくないことをCAに通知するためにEEによって使用されます。"
    },
    {
      "indent": 9,
      "text": "implicitConfirm OBJECT IDENTIFIER ::= {id-it 13}\nImplicitConfirmValue ::= NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the CA grants the request to the EE, it MUST put the same extension in the PKIHeader of the response. If the EE does not find the extension in the response, it MUST send the certificate confirmation.",
      "ja": "CAがEEに要求を付与する場合、同じ拡張機能を応答のpkiheaderに配置する必要があります。EEが応答に拡張機能を見つけられない場合、証明書の確認を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1.2. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.1.1.2. 確認waittime"
    },
    {
      "indent": 3,
      "text": "This is used by the CA to inform the EE how long it intends to wait for the certificate confirmation before revoking the certificate and deleting the transaction.",
      "ja": "これは、CAによって使用されて、証明書を取り消してトランザクションを削除する前に、証明書の確認を待つ予定のEEにどのくらいの期間を通知します。"
    },
    {
      "indent": 9,
      "text": "confirmWaitTime OBJECT IDENTIFIER ::= {id-it 14}\nConfirmWaitTimeValue ::= GeneralizedTime",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.1.2. PKI Message Body",
      "section_title": true,
      "ja": "5.1.2. PKIメッセージ本文"
    },
    {
      "indent": 8,
      "text": "PKIBody ::= CHOICE {\n  ir       [0]  CertReqMessages,       --Initialization Req\n  ip       [1]  CertRepMessage,        --Initialization Resp\n  cr       [2]  CertReqMessages,       --Certification Req\n  cp       [3]  CertRepMessage,        --Certification Resp\n  p10cr    [4]  CertificationRequest,  --PKCS #10 Cert.  Req.\n  popdecc  [5]  POPODecKeyChallContent --pop Challenge\n  popdecr  [6]  POPODecKeyRespContent, --pop Response\n  kur      [7]  CertReqMessages,       --Key Update Request\n  kup      [8]  CertRepMessage,        --Key Update Response\n  krr      [9]  CertReqMessages,       --Key Recovery Req\n          krp      [10] KeyRecRepContent,      --Key Recovery Resp\n  rr       [11] RevReqContent,         --Revocation Request\n  rp       [12] RevRepContent,         --Revocation Response\n  ccr      [13] CertReqMessages,       --Cross-Cert.  Request\n  ccp      [14] CertRepMessage,        --Cross-Cert.  Resp\n  ckuann   [15] CAKeyUpdAnnContent,    --CA Key Update Ann.\n  cann     [16] CertAnnContent,        --Certificate Ann.\n  rann     [17] RevAnnContent,         --Revocation Ann.\n  crlann   [18] CRLAnnContent,         --CRL Announcement\n  pkiconf  [19] PKIConfirmContent,     --Confirmation\n  nested   [20] NestedMessageContent,  --Nested Message\n  genm     [21] GenMsgContent,         --General Message\n  genp     [22] GenRepContent,         --General Response\n  error    [23] ErrorMsgContent,       --Error Message\n  certConf [24] CertConfirmContent,    --Certificate confirm\n  pollReq  [25] PollReqContent,        --Polling request\n  pollRep  [26] PollRepContent         --Polling response\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The specific types are described in Section 5.3 below.",
      "ja": "特定のタイプについては、以下のセクション5.3で説明します。"
    },
    {
      "indent": 0,
      "text": "5.1.3. PKI Message Protection",
      "section_title": true,
      "ja": "5.1.3. PKIメッセージ保護"
    },
    {
      "indent": 3,
      "text": "Some PKI messages will be protected for integrity. (Note that if an asymmetric algorithm is used to protect a message and the relevant public component has been certified already, then the origin of the message can also be authenticated. On the other hand, if the public component is uncertified, then the message origin cannot be automatically authenticated, but may be authenticated via out-of-band means.)",
      "ja": "一部のPKIメッセージは、完全性のために保護されます。（非対称アルゴリズムを使用してメッセージを保護するために使用され、関連するパブリックコンポーネントがすでに認定されている場合、メッセージの起源も認証できます。一方、パブリックコンポーネントが認証されていない場合、メッセージの原点自動的に認証することはできませんが、帯域外の手段を介して認証される場合があります。"
    },
    {
      "indent": 3,
      "text": "When protection is applied, the following structure is used:",
      "ja": "保護が適用されると、次の構造が使用されます。"
    },
    {
      "indent": 8,
      "text": "PKIProtection ::= BIT STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The input to the calculation of PKIProtection is the DER encoding of the following data structure:",
      "ja": "pkiprotectionの計算への入力は、次のデータ構造のderエンコードです。"
    },
    {
      "indent": 8,
      "text": "ProtectedPart ::= SEQUENCE {\n    header    PKIHeader,\n    body      PKIBody\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "There MAY be cases in which the PKIProtection BIT STRING is deliberately not used to protect a message (i.e., this OPTIONAL field is omitted) because other protection, external to PKIX, will be applied instead. Such a choice is explicitly allowed in this specification. Examples of such external protection include PKCS #7",
      "ja": "PKIXの外部である他の保護が代わりに適用されるため、PKIPROTECTION BIT STRINGがメッセージを保護するために意図的に使用されていない場合があります（つまり、このオプションフィールドは省略されます）。このような選択は、この仕様で明示的に許可されています。このような外部保護の例には、PKCS＃7が含まれます"
    },
    {
      "indent": 3,
      "text": "[PKCS7] and Security Multiparts [RFC1847] encapsulation of the PKIMessage (or simply the PKIBody (omitting the CHOICE tag), if the relevant PKIHeader information is securely carried in the external mechanism). It is noted, however, that many such external mechanisms require that the end entity already possesses a public-key certificate, and/or a unique Distinguished Name, and/or other such infrastructure-related information. Thus, they may not be appropriate for initial registration, key-recovery, or any other process with \"boot-strapping\" characteristics. For those cases it may be necessary that the PKIProtection parameter be used. In the future, if/when external mechanisms are modified to accommodate boot-strapping scenarios, the use of PKIProtection may become rare or non-existent.",
      "ja": "[PKCS7]およびセキュリティマルチパート[RFC1847] PKIMESSAGEのカプセル化（または単にPKIBODY（選択タグを省略）、関連するPKIHEADER情報が外部メカニズムに安全に運ばれる場合）。ただし、そのような外部メカニズムの多くは、最終エンティティがすでに公開された証明書、および/または一意の著名な名前、および/またはその他のインフラストラクチャ関連情報を所有していることを要求することに注意してください。したがって、最初の登録、キー回復、または「ブートストラップ」特性を備えたその他のプロセスには適していない場合があります。これらの場合には、pKiprotectionパラメーターを使用する必要がある場合があります。将来的には、ブートストラップシナリオに対応するために外部メカニズムが変更された場合、PKiprotectionの使用はまれまたは存在しない場合があります。"
    },
    {
      "indent": 3,
      "text": "Depending on the circumstances, the PKIProtection bits may contain a Message Authentication Code (MAC) or signature. Only the following cases can occur:",
      "ja": "状況に応じて、PKIPROTECTIONビットにはメッセージ認証コード（MAC）または署名が含まれる場合があります。次のケースのみが発生する可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.1.3.1. Shared Secret Information",
      "section_title": true,
      "ja": "5.1.3.1. 共有秘密情報"
    },
    {
      "indent": 3,
      "text": "In this case, the sender and recipient share secret information (established via out-of-band means or from a previous PKI management operation). PKIProtection will contain a MAC value and the protectionAlg will be the following (see also Appendix D.2):",
      "ja": "この場合、送信者と受信者は秘密情報を共有します（帯域外の手段を介して、または以前のPKI管理操作から確立されます）。PKIPROTECTIONにはMAC値が含まれ、保護物は次のものになります（付録D.2も参照）。"
    },
    {
      "indent": 5,
      "text": "id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\nPBMParameter ::= SEQUENCE {\n  salt                OCTET STRING,\n  owf                 AlgorithmIdentifier,\n  iterationCount      INTEGER,\n  mac                 AlgorithmIdentifier\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, the salt value is appended to the shared secret input. The OWF is then applied iterationCount times, where the salted secret is the input to the first iteration and, for each successive iteration, the input is set to be the output of the previous iteration. The output of the final iteration (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.] Note: it is RECOMMENDED that the fields of PBMParameter remain constant throughout the messages of a single transaction (e.g., ir/ip/certConf/pkiConf) in order to reduce the overhead associated with PasswordBasedMac computation).",
      "ja": "上記の保護では、塩値は共有秘密の入力に追加されます。その後、OWFは反復時間を適用します。ここで、塩漬けの秘密は最初の反復への入力であり、連続する各反復に対して、入力は前の反復の出力に設定されます。最終的な反復の出力（参照を容易にするための「basekey」と呼ばれ、「H」のサイズのサイズ）は、対称キーを形成するために使用されるものです。MacアルゴリズムにKビットキーとk <= hが必要な場合、ベースキーの最も重要なKビットが使用されます。k> hの場合、キーの最も重要なHビットにすべてのベースキーが使用される場合、OWF（ \"1\" || baseKey）は、キーの次の最も重要なHビットであるOWF（ \"2\" ||に使用されます。BaseKey）は、すべてのKビットが導出されるまで、キーの次の最も重要なHビットなどに使用されます。[ここでは、 \"n\"はnと「||」をエンコードするASCIIバイトです。連結を表します。]注：パスワードベースのMAC計算に関連するオーバーヘッドを減らすために、単一のトランザクション（IR/IP/CERTCONF/PKICONFなど）のメッセージ全体でPBMParameterのフィールドは一定のままであることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "5.1.3.2. DH Key Pairs",
      "section_title": true,
      "ja": "5.1.3.2. DHキーペア"
    },
    {
      "indent": 3,
      "text": "Where the sender and receiver possess Diffie-Hellman certificates with compatible DH parameters, in order to protect the message the end entity must generate a symmetric key based on its private DH key value and the DH public key of the recipient of the PKI message. PKIProtection will contain a MAC value keyed with this derived symmetric key and the protectionAlg will be the following:",
      "ja": "送信者と受信者が互換性のあるDHパラメーターを使用してdiffie-hellman証明書を持っている場合、メッセージを保護するために、最終エンティティは、PKIメッセージの受信者のプライベートDHキー値とDH公開鍵に基づいて対称キーを生成する必要があります。PKIPROTECTIONには、この派生した対称キーでキー付きMAC値が含まれ、保護は次のとおりです。"
    },
    {
      "indent": 8,
      "text": "id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "DHBMParameter ::= SEQUENCE {\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the above protectionAlg, OWF is applied to the result of the Diffie-Hellman computation. The OWF output (called \"BASEKEY\" for ease of reference, with a size of \"H\") is what is used to form the symmetric key. If the MAC algorithm requires a K-bit key and K <= H, then the most significant K bits of BASEKEY are used. If K > H, then all of BASEKEY is used for the most significant H bits of the key, OWF(\"1\" || BASEKEY) is used for the next most significant H bits of the key, OWF(\"2\" || BASEKEY) is used for the next most significant H bits of the key, and so on, until all K bits have been derived. [Here \"N\" is the ASCII byte encoding the number N and \"||\" represents concatenation.]",
      "ja": "上記の保護物では、OWFはdiffie-hellman計算の結果に適用されます。OWF出力（「H」のサイズを備えた参照のための「ベースキー」と呼ばれる）は、対称キーを形成するために使用されるものです。MacアルゴリズムにKビットキーとk <= hが必要な場合、ベースキーの最も重要なKビットが使用されます。k> hの場合、キーの最も重要なHビットにすべてのベースキーが使用される場合、OWF（ \"1\" || baseKey）は、キーの次の最も重要なHビットであるOWF（ \"2\" ||に使用されます。BaseKey）は、すべてのKビットが導出されるまで、キーの次の最も重要なHビットなどに使用されます。[ここでは、 \"n\"はnと「||」をエンコードするASCIIバイトです。連結を表します。]"
    },
    {
      "indent": 0,
      "text": "5.1.3.3. Signature",
      "section_title": true,
      "ja": "5.1.3.3. サイン"
    },
    {
      "indent": 3,
      "text": "In this case, the sender possesses a signature key pair and simply signs the PKI message. PKIProtection will contain the signature value and the protectionAlg will be an AlgorithmIdentifier for a digital signature (e.g., md5WithRSAEncryption or dsaWithSha-1).",
      "ja": "この場合、送信者は署名キーペアを所有し、PKIメッセージに単純に署名します。PKIPROTECTIONには署名値が含まれ、保護物はデジタル署名（MD5WithRSAENCRYPTIONまたはDSAWITHSHA-1など）のアルゴリズムIndidifierになります。"
    },
    {
      "indent": 0,
      "text": "5.1.3.4. Multiple Protection",
      "section_title": true,
      "ja": "5.1.3.4. 複数の保護"
    },
    {
      "indent": 3,
      "text": "In cases where an end entity sends a protected PKI message to an RA, the RA MAY forward that message to a CA, attaching its own protection (which MAY be a MAC or a signature, depending on the information and certificates shared between the RA and the CA). This is accomplished by nesting the entire message sent by the end entity within a new PKI message. The structure used is as follows.",
      "ja": "終了エンティティが保護されたPKIメッセージをRAに送信する場合、RAはそのメッセージをCAに転送し、独自の保護を添付することができます（これは、RAとRAと共有される情報と証明書に応じて、MACまたは署名である可能性があります。CA）。これは、新しいPKIメッセージ内で最終エンティティから送信されたメッセージ全体をネストすることによって達成されます。使用される構造は次のとおりです。"
    },
    {
      "indent": 10,
      "text": "NestedMessageContent ::= PKIMessages",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(The use of PKIMessages, a SEQUENCE OF PKIMessage, lets the RA batch the requests of several EEs in a single new message. For simplicity, all messages in the batch MUST be of the same type (e.g., ir).) If the RA wishes to modify the message(s) in some way (e.g., add particular field values or new extensions), then it MAY create its own desired PKIBody. The original PKIMessage from the EE MAY be included in the generalInfo field of PKIHeader (to accommodate, for example, cases in which the CA wishes to check POP or other information on the original EE message). The infoType to be used in this situation is {id-it 15} (see Section 5.3.19 for the value of id-it) and the infoValue is PKIMessages (contents MUST be in the same order as the requests in PKIBody).",
      "ja": "（pkimessageの使用、一連のpkimessageにより、RAは単一の新しいメッセージで複数のEEの要求をバッチにすることができます。簡単にするには、バッチ内のすべてのメッセージが同じタイプ（例えば、IR）でなければなりません。）何らかの方法でメッセージを変更したい（たとえば、特定のフィールド値または新しい拡張機能を追加する）、独自の望ましいpkibodyを作成する場合があります。EEからの元のpkimessageは、PkiheaderのGeneralInfoフィールドに含まれる場合があります（たとえば、CAが元のEEメッセージのPOPまたはその他の情報をチェックしたい場合に対応するため）。この状況で使用されるインフォタイプは{ID-IT 15}（ID-ITの値についてはセクション5.3.19を参照）であり、情報値はpkimessagesです（内容はpkibodyの要求と同じ順序でなければなりません）。"
    },
    {
      "indent": 0,
      "text": "5.2. Common Data Structures",
      "section_title": true,
      "ja": "5.2. 一般的なデータ構造"
    },
    {
      "indent": 3,
      "text": "Before specifying the specific types that may be placed in a PKIBody, we define some data structures that are used in more than one case.",
      "ja": "pkibodyに配置される可能性のある特定のタイプを指定する前に、複数のケースで使用されるいくつかのデータ構造を定義します。"
    },
    {
      "indent": 0,
      "text": "5.2.1. Requested Certificate Contents",
      "section_title": true,
      "ja": "5.2.1. 要求された証明書の内容"
    },
    {
      "indent": 3,
      "text": "Various PKI management messages require that the originator of the message indicate some of the fields that are required to be present in a certificate. The CertTemplate structure allows an end entity or RA to specify as much as it wishes about the certificate it requires. CertTemplate is identical to a Certificate, but with all fields optional.",
      "ja": "さまざまなPKI管理メッセージには、メッセージの発信者が証明書に存在する必要があるフィールドの一部を示す必要があります。CERTTEMPLATE構造により、エンティティまたはRAは、必要な証明書について希望する限り指定できます。certTemplateは証明書と同一ですが、すべてのフィールドがオプションです。"
    },
    {
      "indent": 3,
      "text": "Note that even if the originator completely specifies the contents of a certificate it requires, a CA is free to modify fields within the certificate actually issued. If the modified certificate is unacceptable to the requester, the requester MUST send back a certConf message that either does not include this certificate (via a CertHash), or does include this certificate (via a CertHash) along with a status of \"rejected\". See Section 5.3.18 for the definition and use of CertHash and the certConf message.",
      "ja": "発信者が必要な証明書の内容を完全に指定したとしても、CAは実際に発行された証明書内のフィールドを自由に変更できることに注意してください。変更された証明書が要求者に受け入れられない場合、要求者は、（Certhashを介して）この証明書を含めないか、この証明書（Certhashを介して）を「拒否」のステータスとともに含める証明書を送信する必要があります。CerthashおよびCertConfメッセージの定義と使用については、セクション5.3.18を参照してください。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertTemplate syntax.",
      "ja": "CERTTEMPLATE構文については、付録Cおよび[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Encrypted Values",
      "section_title": true,
      "ja": "5.2.2. 暗号化された値"
    },
    {
      "indent": 3,
      "text": "Where encrypted values (restricted, in this specification, to be either private keys or certificates) are sent in PKI messages, the EncryptedValue data structure is used.",
      "ja": "暗号化された値（この仕様では、プライベートキーまたは証明書のいずれかに制限されている）がPKIメッセージで送信される場合、暗号化された値データ構造が使用されます。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for EncryptedValue syntax.",
      "ja": "暗号化されたValue構文については[CRMF]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Use of this data structure requires that the creator and intended recipient be able to encrypt and decrypt, respectively. Typically, this will mean that the sender and recipient have, or are able to generate, a shared secret key.",
      "ja": "このデータ構造を使用するには、作成者と意図された受信者がそれぞれ暗号化および復号化できる必要があります。通常、これは、送信者と受信者が共有秘密の鍵を持っている、または生成できることを意味します。"
    },
    {
      "indent": 3,
      "text": "If the recipient of the PKIMessage already possesses a private key usable for decryption, then the encSymmKey field MAY contain a session key encrypted using the recipient's public key.",
      "ja": "pkimessageの受信者が既に復号化のために使用可能な秘密鍵を所有している場合、encsymmkeyフィールドには、受信者の公開キーを使用して暗号化されたセッションキーを含めることができます。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Status codes and Failure Information for PKI Messages",
      "section_title": true,
      "ja": "5.2.3. PKIメッセージのステータスコードと障害情報"
    },
    {
      "indent": 3,
      "text": "All response messages will include some status information. The following values are defined.",
      "ja": "すべての応答メッセージには、いくつかのステータス情報が含まれます。次の値が定義されています。"
    },
    {
      "indent": 8,
      "text": "PKIStatus ::= INTEGER {\n    accepted               (0),\n    grantedWithMods        (1),\n    rejection              (2),\n    waiting                (3),\n    revocationWarning      (4),\n    revocationNotification (5),\n    keyUpdateWarning       (6)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Responders may use the following syntax to provide more information about failure cases.",
      "ja": "レスポンダーは、次の構文を使用して、故障ケースに関する詳細情報を提供する場合があります。"
    },
    {
      "indent": 8,
      "text": "PKIFailureInfo ::= BIT STRING {\n    badAlg              (0),\n    badMessageCheck     (1),\n    badRequest          (2),\n    badTime             (3),\n    badCertId           (4),\n    badDataFormat       (5),\n    wrongAuthority      (6),\n    incorrectData       (7),\n    missingTimeStamp    (8),\n    badPOP              (9),\n    certRevoked         (10),\n    certConfirmed       (11),\n    wrongIntegrity      (12),\n    badRecipientNonce   (13),\n    timeNotAvailable    (14),\n    unacceptedPolicy    (15),\n    unacceptedExtension (16),\n    addInfoNotAvailable (17),\n            badSenderNonce      (18),\n    badCertTemplate     (19),\n    signerNotTrusted    (20),\n    transactionIdInUse  (21),\n    unsupportedVersion  (22),\n    notAuthorized       (23),\n    systemUnavail       (24),\n    systemFailure       (25),\n    duplicateCertReq    (26)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "PKIStatusInfo ::= SEQUENCE {\n    status        PKIStatus,\n    statusString  PKIFreeText     OPTIONAL,\n    failInfo      PKIFailureInfo  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.4. Certificate Identification",
      "section_title": true,
      "ja": "5.2.4. 証明書識別"
    },
    {
      "indent": 3,
      "text": "In order to identify particular certificates, the CertId data structure is used.",
      "ja": "特定の証明書を特定するために、CertIDデータ構造が使用されます。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for CertId syntax.",
      "ja": "CertID構文については[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.5. Out-of-band root CA Public Key",
      "section_title": true,
      "ja": "5.2.5. バンド外のルートCA公開キー"
    },
    {
      "indent": 3,
      "text": "Each root CA must be able to publish its current public key via some \"out-of-band\" means. While such mechanisms are beyond the scope of this document, we define data structures that can support such mechanisms.",
      "ja": "各ルートCAは、いくつかの「帯域外」手段を介して現在の公開キーを公開できる必要があります。このようなメカニズムはこのドキュメントの範囲を超えていますが、そのようなメカニズムをサポートできるデータ構造を定義します。"
    },
    {
      "indent": 3,
      "text": "There are generally two methods available: either the CA directly publishes its self-signed certificate, or this information is available via the Directory (or equivalent) and the CA publishes a hash of this value to allow verification of its integrity before use.",
      "ja": "通常、2つの方法が利用可能です。CAが自己署名証明書を直接公開するか、この情報がディレクトリ（または同等）を介して利用可能であり、CAはこの値のハッシュを公開して、使用前にその完全性の検証を可能にします。"
    },
    {
      "indent": 8,
      "text": "OOBCert ::= Certificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The fields within this certificate are restricted as follows:",
      "ja": "この証明書内のフィールドは、次のように制限されています。"
    },
    {
      "indent": 3,
      "text": "o The certificate MUST be self-signed (i.e., the signature must be verifiable using the SubjectPublicKeyInfo field);",
      "ja": "o 証明書は自己署名する必要があります（つまり、署名はsubjectpublickeyinfoフィールドを使用して検証可能でなければなりません）。"
    },
    {
      "indent": 3,
      "text": "o The subject and issuer fields MUST be identical;",
      "ja": "o 主題と発行者のフィールドは同一でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o If the subject field is NULL, then both subjectAltNames and issuerAltNames extensions MUST be present and have exactly the same value;",
      "ja": "o サブジェクトフィールドがnullの場合、subjectaltnamesとissueraltnames拡張機能の両方が存在し、まったく同じ値を持つ必要があります。"
    },
    {
      "indent": 3,
      "text": "o The values of all other extensions must be suitable for a self-signed certificate (e.g., key identifiers for subject and issuer must be the same).",
      "ja": "o 他のすべての拡張機能の値は、自己署名証明書に適している必要があります（たとえば、被験者と発行者のキー識別子は同じでなければなりません）。"
    },
    {
      "indent": 8,
      "text": "OOBCertHash ::= SEQUENCE {\n    hashAlg     [0] AlgorithmIdentifier     OPTIONAL,\n    certId      [1] CertId                  OPTIONAL,\n    hashVal         BIT STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The intention of the hash value is that anyone who has securely received the hash value (via the out-of-band means) can verify a self-signed certificate for that CA.",
      "ja": "ハッシュ値の意図は、（帯域外の手段を介して）ハッシュ値を安全に受け取った人なら誰でも、そのCAの自己署名証明書を検証できることです。"
    },
    {
      "indent": 0,
      "text": "5.2.6. Archive Options",
      "section_title": true,
      "ja": "5.2.6. アーカイブオプション"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to archive a private key value using the PKIArchiveOptions structure.",
      "ja": "要求者は、PKIがPKIarchiveoptions構造を使用して秘密キー値をアーカイブすることを望んでいることを示す場合があります。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for PKIArchiveOptions syntax.",
      "ja": "pkiarchiveoptionsの構文については[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.7. Publication Information",
      "section_title": true,
      "ja": "5.2.7. 出版情報"
    },
    {
      "indent": 3,
      "text": "Requesters may indicate that they wish the PKI to publish a certificate using the PKIPublicationInfo structure.",
      "ja": "要求者は、PKIがPKIPUBLICITIONINFO構造を使用して証明書を公開することを望んでいることを示している場合があります。"
    },
    {
      "indent": 3,
      "text": "See [CRMF] for PKIPublicationInfo syntax.",
      "ja": "pkipublicationinfo構文については[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.8. Proof-of-Possession Structures",
      "section_title": true,
      "ja": "5.2.8. 所有の証明構造"
    },
    {
      "indent": 3,
      "text": "If the certification request is for a signing key pair (i.e., a request for a verification certificate), then the proof-of-possession of the private signing key is demonstrated through use of the POPOSigningKey structure.",
      "ja": "認定リクエストが署名キーペア（つまり、検証証明書のリクエスト）の場合、プライベート署名キーの入力の証明がポポジンキー構造の使用を通じて実証されます。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for POPOSigningKey syntax, but note that POPOSigningKeyInput has the following semantic stipulations in this specification.",
      "ja": "PoposigingKey Syntaxについては、付録Cおよび[CRMF]を参照してください。ただし、PopoSigingKeyInputには、この仕様には次のセマンティック規定があることに注意してください。"
    },
    {
      "indent": 8,
      "text": "POPOSigningKeyInput ::= SEQUENCE {\n    authInfo            CHOICE {\n        sender              [0] GeneralName,\n        publicKeyMAC            PKMACValue\n    },\n    publicKey           SubjectPublicKeyInfo\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "On the other hand, if the certification request is for an encryption key pair (i.e., a request for an encryption certificate), then the proof-of-possession of the private decryption key may be demonstrated in one of three ways.",
      "ja": "一方、認証要求が暗号化キーペア（つまり、暗号化証明書のリクエスト）の場合、プライベート復号化キーの入力の証明を3つの方法のいずれかで実証できます。"
    },
    {
      "indent": 0,
      "text": "5.2.8.1. Inclusion of the Private Key",
      "section_title": true,
      "ja": "5.2.8.1. 秘密鍵を含める"
    },
    {
      "indent": 3,
      "text": "By the inclusion of the private key (encrypted) in the CertRequest (in the thisMessage field of POPOPrivKey (see Appendix C) or in the PKIArchiveOptions control structure, depending upon whether or not archival of the private key is also desired).",
      "ja": "秘密鍵（付録Cを参照）またはpkiarchiveoptionsコントロール構造に、秘密鍵のアーカイブのアーカイブが必要かどうかに応じて、certrequest（appendix cを参照）またはpkiarchiveoptionsコントロール構造に）に秘密鍵（暗号化）を含めることにより。"
    },
    {
      "indent": 0,
      "text": "5.2.8.2. Indirect Method",
      "section_title": true,
      "ja": "5.2.8.2. 間接的な方法"
    },
    {
      "indent": 3,
      "text": "By having the CA return not the certificate, but an encrypted certificate (i.e., the certificate encrypted under a randomly-generated symmetric key, and the symmetric key encrypted under the public key for which the certification request is being made) -- this is the \"indirect\" method mentioned previously in Section 4.3.2. The end entity proves knowledge of the private decryption key to the CA by providing the correct CertHash for this certificate in the certConf message. This demonstrates POP because the EE can only compute the correct CertHash if it is able to recover the certificate, and it can only recover the certificate if it is able to decrypt the symmetric key using the required private key. Clearly, for this to work, the CA MUST NOT publish the certificate until the certConf message arrives (when certHash is to be used to demonstrate POP). See Section 5.3.18 for further details.",
      "ja": "CAが証明書ではなく、暗号化された証明書（つまり、ランダムに生成された対称キーの下で暗号化された証明書と、認証要求が行われている公開鍵の下で暗号化された対称キー）を返すことにより、これはこれがセクション4.3.2で前述した「間接」方法。End Entityは、CERTCONFメッセージでこの証明書の正しいCerthashを提供することにより、CAのプライベート復号化キーに関する知識を証明します。これは、EEが証明書を回復できる場合にのみ正しいCerthashを計算できるため、POPを示し、必要な秘密鍵を使用して対称キーを復号化できる場合にのみ証明書を回復できるためです。明らかに、これが機能するためには、CAがCERTCONFメッセージが到着するまで証明書を公開してはなりません（CerthashがPOPを実証するために使用する場合）。詳細については、セクション5.3.18を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.2.8.3. Challenge-Response Protocol",
      "section_title": true,
      "ja": "5.2.8.3. チャレンジ応答プロトコル"
    },
    {
      "indent": 3,
      "text": "By having the end entity engage in a challenge-response protocol (using the messages POPODecKeyChall and POPODecKeyResp; see below) between CertReqMessages and CertRepMessage -- this is the \"direct\" method mentioned previously in Section 4.3.2. (This method would typically be used in an environment in which an RA verifies POP and then makes a certification request to the CA on behalf of the end entity. In such a scenario, the CA trusts the RA to have done POP correctly before the RA requests a certificate for the end entity.) The complete protocol then looks as follows (note that req' does not necessarily encapsulate req as a nested message):",
      "ja": "certreqmessagesとcertrepmessageの間で、最終エンティティにチャレンジ応答プロトコル（popodeckeychallとpopodeckeyrespを使用して、以下を参照）に従事させることにより、これはセクション4.3.2で前述した「直接」方法です。（この方法は通常、RAがPOPを検証し、最終エンティティに代わってCAに認証リクエストを行う環境で使用されます。このようなシナリオでは、CAはRAがRAの前に正しくポップしたと信頼しています。終了エンティティの証明書を要求します。）完全なプロトコルは次のように見えます（Req 'は必ずしもネストされたメッセージとしてReqをカプセル化するわけではないことに注意してください）："
    },
    {
      "indent": 19,
      "text": "EE            RA            CA\n ---- req ---->\n <--- chall ---\n ---- resp --->\n               ---- req' --->\n               <--- rep -----\n               ---- conf --->\n               <--- ack -----\n <--- rep -----\n ---- conf --->\n <--- ack -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This protocol is obviously much longer than the 3-way exchange given in choice (2) above, but allows a local Registration Authority to be involved and has the property that the certificate itself is not actually created until the proof-of-possession is complete. In some environments, a different order of the above messages may be required, such as the following (this may be determined by policy):",
      "ja": "このプロトコルは明らかに上記の選択（2）で与えられた3方向の交換よりもはるかに長いですが、現地の登録機関が関与することを許可し、証明書自体が実際に作成されないというプロパティを持っています。。一部の環境では、次のような上記のメッセージの異なる順序が必要になる場合があります（これはポリシーによって決定される場合があります）。"
    },
    {
      "indent": 19,
      "text": "EE            RA            CA\n ---- req ---->\n <--- chall ---\n ---- resp --->\n               ---- req' --->\n               <--- rep -----\n <--- rep -----\n ---- conf --->\n               ---- conf --->\n               <--- ack -----\n <--- ack -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If the cert. request is for a key agreement key (KAK) pair, then the POP can use any of the 3 ways described above for enc. key pairs, with the following changes: (1) the parenthetical text of bullet 2) is replaced with \"(i.e., the certificate encrypted under the symmetric key derived from the CA's private KAK and the public key for which the certification request is being made)\"; (2) the first parenthetical text of the challenge field of \"Challenge\" below is replaced with \"(using PreferredSymmAlg (see Section 5.3.19.4 and Appendix E.5) and a symmetric key derived from the CA's private KAK and the public key for which the certification request is being made)\". Alternatively, the POP can use the POPOSigningKey structure given in [CRMF] (where the alg field is DHBasedMAC and the signature field is the MAC) as a fourth alternative for demonstrating POP if the CA already has a D-H certificate that is known to the EE.",
      "ja": "証明書の場合。リクエストはキー契約キー（KAK）ペアのペアであり、POPは上記の3つの方法のいずれかをENCに使用できます。キーペア、次の変更があります。（1）弾丸2の括弧付きテキストは、「CAのプライベートカックと認定リクエストが行われている公開鍵から派生した対称キーの下で暗号化された証明書」に置き換えられます。） \";（2）以下の「チャレンジ」のチャレンジフィールドの最初の括弧内テキストは、「PreferredSymmalg（セクション5.3.19.4および付録E.5を参照）を使用して、CAのプライベートKAKと公開鍵から派生した対称キーを使用して置き換えられます。認定リクエストが行われています）」。あるいは、POPは[CRMF]（ALGフィールドがDHBasedMACであり、署名フィールドがMACである）に与えられたPopoSigingKey構造を使用することができます。。"
    },
    {
      "indent": 3,
      "text": "The challenge-response messages for proof-of-possession of a private decryption key are specified as follows (see [MvOV97], p.404 for details). Note that this challenge-response exchange is associated with the preceding cert. request message (and subsequent cert. response and confirmation messages) by the transactionID used in the PKIHeader and by the protection (MACing or signing) applied to the PKIMessage.",
      "ja": "プライベート復号化キーの入金の証明に関する課題反応メッセージは、次のように指定されています（詳細については[MVOV97]、p.404を参照）。この課題反応交換は、前の証明書に関連付けられていることに注意してください。pkiheaderで使用されたTransactionIDおよびPkimessageに適用される保護（マッピングまたは署名）によるメッセージ（およびその後のCERT。応答および確認メッセージ）を要求します。"
    },
    {
      "indent": 8,
      "text": "POPODecKeyChallContent ::= SEQUENCE OF Challenge\nChallenge ::= SEQUENCE {\n    owf                 AlgorithmIdentifier  OPTIONAL,\n    witness             OCTET STRING,\n    challenge           OCTET STRING\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the size of Rand needs to be appropriate for encryption under the public key of the requester. Given that \"int\" will typically not be longer than 64 bits, this leaves well over 100 bytes of room for the \"sender\" field when the modulus is 1024 bits. If, in some environment, names are so long that they cannot fit (e.g., very long DNs), then whatever portion will fit should be used (as long as it includes at least the common name, and as long as the receiver is able to deal meaningfully with the abbreviation).",
      "ja": "RANDのサイズは、要求者の公開鍵の下での暗号化に適している必要があることに注意してください。通常、「int」は64ビットを超えないことを考えると、モジュラスが1024ビットの場合、「送信者」フィールドに100バイト以上の部屋が残ります。一部の環境では、名前が非常に長く合わない場合（非常に長いDNSなど）、適合する部分は何でも使用する必要があります（少なくとも共通名が含まれている限り、そして受信機が可能である限り、略語に有意義に対処するため）。"
    },
    {
      "indent": 8,
      "text": "POPODecKeyRespContent ::= SEQUENCE OF INTEGER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2.8.4. Summary of PoP Options",
      "section_title": true,
      "ja": "5.2.8.4. ポップオプションの概要"
    },
    {
      "indent": 3,
      "text": "The text in this section provides several options with respect to POP techniques. Using \"SK\" for \"signing key\", \"EK\" for \"encryption key\", and \"KAK\" for \"key agreement key\", the techniques may be summarized as follows:",
      "ja": "このセクションのテキストは、ポップテクニックに関するいくつかのオプションを提供します。「署名キー」に「SK」、「暗号化キー」の「EK」、および「キー契約キー」の「KAK」を使用すると、テクニックは次のように要約できます。"
    },
    {
      "indent": 9,
      "text": "RAVerified;\nSKPOP;\nEKPOPThisMessage;\nKAKPOPThisMessage;\nKAKPOPThisMessageDHMAC;\nEKPOPEncryptedCert;\nKAKPOPEncryptedCert;\nEKPOPChallengeResp; and\nKAKPOPChallengeResp.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Given this array of options, it is natural to ask how an end entity can know what is supported by the CA/RA (i.e., which options it may use when requesting certificates). The following guidelines should clarify this situation for EE implementers.",
      "ja": "この一連のオプションを考えると、最終エンティティがCA/RAによってサポートされているものをどのように知ることができるかを尋ねるのは自然です（つまり、証明書を要求するときに使用するオプション）。次のガイドラインは、EE実装者にとってこの状況を明確にする必要があります。"
    },
    {
      "indent": 3,
      "text": "RAVerified. This is not an EE decision; the RA uses this if and only if it has verified POP before forwarding the request on to the CA, so it is not possible for the EE to choose this technique.",
      "ja": "ラヴェリッド。これはEEの決定ではありません。RAは、リクエストをCAに転送する前にPOPを検証した場合にのみこれを使用します。したがって、EEがこの手法を選択することは不可能です。"
    },
    {
      "indent": 3,
      "text": "SKPOP. If the EE has a signing key pair, this is the only POP method specified for use in the request for a corresponding certificate.",
      "ja": "skpop。EEが署名キーペアを持っている場合、これは対応する証明書の要求で使用するために指定された唯一のPOPメソッドです。"
    },
    {
      "indent": 3,
      "text": "EKPOPThisMessage and KAKPOPThisMessage. Whether or not to give up its private key to the CA/RA is an EE decision. If the EE decides to reveal its key, then these are the only POP methods available in this specification to achieve this (and the key pair type will determine which of these two methods to use).",
      "ja": "ekpopthismessageとkakpopthismessage。CA/RAの秘密鍵を放棄するかどうかは、EEの決定です。EEがそのキーを明らかにすることを決定した場合、これらはこの仕様で利用できる唯一のPOPメソッドです（そして、キーペアタイプは、これら2つの使用方法のどれを決定します）。"
    },
    {
      "indent": 3,
      "text": "KAKPOPThisMessageDHMAC. The EE can only use this method if (1) the CA has a DH certificate available for this purpose, and (2) the EE already has a copy of this certificate. If both these conditions hold, then this technique is clearly supported and may be used by the EE, if desired.",
      "ja": "kakpopthismessagedhmac。EEは、（1）CAがこの目的で利用可能なDH証明書を持っている場合にのみこの方法を使用できます。（2）EEにはすでにこの証明書のコピーがあります。これらの両方の条件が当てはまる場合、この手法は明確にサポートされており、必要に応じてEEによって使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "EKPOPEncryptedCert, KAKPOPEncryptedCert, EKPOPChallengeResp, KAKPOPChallengeResp. The EE picks one of these (in the subsequentMessage field) in the request message, depending upon preference and key pair type. The EE is not doing POP at this point; it is simply indicating which method it wants to use. Therefore, if the CA/RA replies with a \"badPOP\" error, the EE can re-request using the other POP method chosen in subsequentMessage. Note, however, that this specification encourages the use of the EncryptedCert choice and, furthermore, says that the challenge-response would typically be used when an RA is involved and doing POP verification. Thus, the EE should be able to make an intelligent decision regarding which of these POP methods to choose in the request message.",
      "ja": "ekpopencryptedcert、kakpopencryptedcert、ekpopchallengeresp、kakpopchallengeresp。EEは、好みとキーペアのタイプに応じて、リクエストメッセージでこれらの1つ（後続のメッサージフィールド）を選択します。EEはこの時点でポップをしていません。使用したい方法を単に示しているだけです。したがって、CA/RAが「バッドポップ」エラーで応答する場合、EEは後続のメッセージで選択された他のPOPメソッドを使用して再リケストできます。ただし、この仕様は暗号化された選択の選択の使用を促進し、さらに、RAが関与してポップ検証を行うときにチャレンジ応答が使用されると述べていることに注意してください。したがって、EEは、リクエストメッセージで選択するこれらのPOPメソッドのどれについてインテリジェントな決定を下すことができるはずです。"
    },
    {
      "indent": 0,
      "text": "5.3. Operation-Specific Data Structures",
      "section_title": true,
      "ja": "5.3. 操作固有のデータ構造"
    },
    {
      "indent": 0,
      "text": "5.3.1. Initialization Request",
      "section_title": true,
      "ja": "5.3.1. 初期化リクエスト"
    },
    {
      "indent": 3,
      "text": "An Initialization request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificate(s). Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields which may be supplied for each certificate requested (see Appendix D profiles for further information). This message is intended to be used for entities when first initializing into the PKI.",
      "ja": "初期化要求メッセージには、pkibodyとしてCertreqMessagesデータ構造として含まれています。これは、要求された証明書を指定します。通常、subjectpublickeyinfo、keyID、および有効性は、要求された各証明書に対して提供される可能性のあるテンプレートフィールドです（詳細については、付録Dプロファイルを参照）。このメッセージは、最初にPKIに初期化するときにエンティティに使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、付録Cおよび[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Initialization Response",
      "section_title": true,
      "ja": "5.3.2. 初期化応答"
    },
    {
      "indent": 3,
      "text": "An Initialization response message contains as the PKIBody an CertRepMessage data structure, which has for each certificate requested a PKIStatusInfo field, a subject certificate, and possibly a private key (normally encrypted with a session key, which is itself encrypted with the protocolEncrKey).",
      "ja": "初期化応答メッセージには、pkibodyとして、各証明書に対してpkistatusinfoフィールド、サブジェクト証明書、および場合によっては秘密鍵（通常はプロトコレンキーで暗号化されたセッションキーで暗号化された）が要求されたCertrepmessageデータ構造として含まれています。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax. Note that if the PKI Message Protection is \"shared secret information\" (see Section 5.1.3), then any certificate transported in the caPubs field may be directly trusted as a root CA certificate by the initiator.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。PKIメッセージ保護が「共有秘密情報」である場合（セクション5.1.3を参照）、Capubsフィールドで輸送される証明書は、イニシエーターによってルートCA証明書として直接信頼される場合があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.3. Certification Request",
      "section_title": true,
      "ja": "5.3.3. 認定リクエスト"
    },
    {
      "indent": 3,
      "text": "A Certification request message contains as the PKIBody a CertReqMessages data structure, which specifies the requested certificates. This message is intended to be used for existing PKI entities who wish to obtain additional certificates.",
      "ja": "認定要求メッセージには、pkibodyとしてCertreqMessagesデータ構造として含まれています。これは、要求された証明書を指定します。このメッセージは、追加の証明書を取得したい既存のPKIエンティティに使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、付録Cおよび[CRMF]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Alternatively, the PKIBody MAY be a CertificationRequest (this structure is fully specified by the ASN.1 structure CertificationRequest given in [PKCS10]). This structure may be required for certificate requests for signing key pairs when interoperation with legacy systems is desired, but its use is strongly discouraged whenever not absolutely necessary.",
      "ja": "あるいは、PKIBODYは認証リケストである場合があります（この構造は、[PKCS10]に与えられたASN.1構造認証再クエストによって完全に指定されています）。この構造は、レガシーシステムとの相互操作が望まれている場合、キーペアに署名するための証明書リクエストに必要な場合がありますが、その使用は絶対に必要ではない場合は強く落胆します。"
    },
    {
      "indent": 0,
      "text": "5.3.4. Certification Response",
      "section_title": true,
      "ja": "5.3.4. 認定応答"
    },
    {
      "indent": 3,
      "text": "A Certification response message contains as the PKIBody a CertRepMessage data structure, which has a status value for each certificate requested, and optionally has a CA public key, failure information, a subject certificate, and an encrypted private key.",
      "ja": "認証応答メッセージには、PKIBODYとしてCertrePmessageデータ構造として含まれています。これには、要求された各証明書のステータス値があり、オプションでCAの公開キー、障害情報、件名証明書、暗号化された秘密鍵が含まれています。"
    },
    {
      "indent": 5,
      "text": "CertRepMessage ::= SEQUENCE {\n    caPubs          [1] SEQUENCE SIZE (1..MAX) OF Certificate\n                        OPTIONAL,\n    response            SEQUENCE OF CertResponse\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertResponse ::= SEQUENCE {\n    certReqId           INTEGER,\n    status              PKIStatusInfo,\n    certifiedKeyPair    CertifiedKeyPair    OPTIONAL,\n    rspInfo             OCTET STRING        OPTIONAL\n    -- analogous to the id-regInfo-utf8Pairs string defined",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " -- for regInfo in CertReqMsg [CRMF] }",
      "ja": "-certreqmsgのreginfo [crmf]}"
    },
    {
      "indent": 5,
      "text": "CertifiedKeyPair ::= SEQUENCE {\n    certOrEncCert       CertOrEncCert,\n    privateKey      [0] EncryptedValue      OPTIONAL,\n    -- see [CRMF] for comment on encoding\n    publicationInfo [1] PKIPublicationInfo  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertOrEncCert ::= CHOICE {\n    certificate     [0] Certificate,\n    encryptedCert   [1] EncryptedValue\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Only one of the failInfo (in PKIStatusInfo) and certificate (in CertifiedKeyPair) fields can be present in each CertResponse (depending on the status). For some status values (e.g., waiting), neither of the optional fields will be present.",
      "ja": "FailInfo（pkistatusinfoで）と証明書（認定Keypair）の1つのみが、各certresponse（ステータスに応じて）に存在する可能性があります。一部のステータス値（待機）の場合、オプションのフィールドはどちらも存在しません。"
    },
    {
      "indent": 3,
      "text": "Given an EncryptedCert and the relevant decryption key, the certificate may be obtained. The purpose of this is to allow a CA to return the value of a certificate, but with the constraint that only the intended recipient can obtain the actual certificate. The benefit of this approach is that a CA may reply with a certificate even in the absence of a proof that the requester is the end entity that can use the relevant private key (note that the proof is not obtained until the certConf message is received by the CA). Thus, the CA will not have to revoke that certificate in the event that something goes wrong with the proof-of-possession (but MAY do so anyway, depending upon policy).",
      "ja": "暗号化された暗号化と関連する復号化キーを考えると、証明書が取得される場合があります。これの目的は、CAが証明書の値を返すことを許可することですが、意図した受信者のみが実際の証明書を取得できるという制約を備えています。このアプローチの利点は、CAが関連する秘密鍵を使用できる最終エンティティであるという証明がない場合でも証明書に返信することができることです（証明は、証明書が通知されるまで取得されないことに注意してください。CA）。したがって、CAは、所有の証明に何か問題が発生した場合にその証明書を取り消す必要はありません（ただし、ポリシーに応じて、とにかくそうすることができます）。"
    },
    {
      "indent": 0,
      "text": "5.3.5. Key Update Request Content",
      "section_title": true,
      "ja": "5.3.5. キーアップデートリクエストコンテンツ"
    },
    {
      "indent": 3,
      "text": "For key update requests the CertReqMessages syntax is used. Typically, SubjectPublicKeyInfo, KeyId, and Validity are the template fields that may be supplied for each key to be updated. This message is intended to be used to request updates to existing (non-revoked and non-expired) certificates (therefore, it is sometimes referred to as a \"Certificate Update\" operation). An update is a replacement certificate containing either a new subject public key or the current subject public key (although the latter practice may not be appropriate for some environments).",
      "ja": "キーアップデートリクエストの場合、CertreQMessages構文が使用されます。通常、subjectpublickeyinfo、keyID、および有効性は、更新する各キーに提供されるテンプレートフィールドです。このメッセージは、既存の（非回転および非走行されていない）証明書の更新をリクエストするために使用することを目的としています（したがって、「証明書更新」操作と呼ばれることもあります）。更新は、新しい件名の公開キーまたは現在の件名の公開キーのいずれかを含む交換証明書です（ただし、後者のプラクティスは環境には適切ではない場合があります）。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、付録Cおよび[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.6. Key Update Response Content",
      "section_title": true,
      "ja": "5.3.6. 主要な更新応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "For key update responses, the CertRepMessage syntax is used. The response is identical to the initialization response.",
      "ja": "主要な更新応答には、certrepmessage構文が使用されます。応答は、初期化応答と同じです。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.7. Key Recovery Request Content",
      "section_title": true,
      "ja": "5.3.7. キーリカバリリクエストコンテンツ"
    },
    {
      "indent": 3,
      "text": "For key recovery requests the syntax used is identical to the initialization request CertReqMessages. Typically, SubjectPublicKeyInfo and KeyId are the template fields that may be used to supply a signature public key for which a certificate is required (see Appendix D profiles for further information).",
      "ja": "キーリカバリリクエストの場合、使用される構文は初期化要求CertreQMessagesと同一です。通常、SubjectPublicKeyInfoとKeyIDは、証明書が必要な署名公開鍵を提供するために使用できるテンプレートフィールドです（詳細については、付録Dプロファイルを参照）。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax. Note that if a key history is required, the requester must supply a Protocol Encryption Key control in the request message.",
      "ja": "CertreqMessagesの構文については、付録Cおよび[CRMF]を参照してください。重要な履歴が必要な場合、要求者はリクエストメッセージにプロトコル暗号化キーコントロールを提供する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "5.3.8. Key Recovery Response Content",
      "section_title": true,
      "ja": "5.3.8. キーリカバリ応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "For key recovery responses, the following syntax is used. For some status values (e.g., waiting) none of the optional fields will be present.",
      "ja": "主要な回復応答には、次の構文が使用されます。一部のステータス値（待機）の場合、オプションのフィールドはどれも存在しません。"
    },
    {
      "indent": 4,
      "text": "KeyRecRepContent ::= SEQUENCE {\n    status          PKIStatusInfo,\n    newSigCert  [0] Certificate                   OPTIONAL,\n    caCerts     [1] SEQUENCE SIZE (1..MAX) OF\n                                 Certificate      OPTIONAL,\n    keyPairHist [2] SEQUENCE SIZE (1..MAX) OF\n                                 CertifiedKeyPair OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.9. Revocation Request Content",
      "section_title": true,
      "ja": "5.3.9. 取り消し要求コンテンツ"
    },
    {
      "indent": 3,
      "text": "When requesting revocation of a certificate (or several certificates), the following data structure is used. The name of the requester is present in the PKIHeader structure.",
      "ja": "証明書（または複数の証明書）の取り消しを要求する場合、次のデータ構造が使用されます。要求者の名前は、pkiheader構造に存在します。"
    },
    {
      "indent": 4,
      "text": "RevReqContent ::= SEQUENCE OF RevDetails",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "RevDetails ::= SEQUENCE {\n    certDetails         CertTemplate,\n    crlEntryDetails     Extensions       OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.10. Revocation Response Content",
      "section_title": true,
      "ja": "5.3.10. 取り消し応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "The revocation response is the response to the above message. If produced, this is sent to the requester of the revocation. (A separate revocation announcement message MAY be sent to the subject of the certificate for which revocation was requested.)",
      "ja": "取り消し応答は、上記のメッセージに対する応答です。作成された場合、これは取り消しの要求者に送信されます。（失効が要求された証明書の主題に送信される可能性があります。）"
    },
    {
      "indent": 5,
      "text": "RevRepContent ::= SEQUENCE {\n    status        SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n    revCerts  [0] SEQUENCE SIZE (1..MAX) OF CertId OPTIONAL,\n    crls      [1] SEQUENCE SIZE (1..MAX) OF CertificateList\n                  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.11. Cross Certification Request Content",
      "section_title": true,
      "ja": "5.3.11. クロス認証要求コンテンツ"
    },
    {
      "indent": 3,
      "text": "Cross certification requests use the same syntax (CertReqMessages) as normal certification requests, with the restriction that the key pair MUST have been generated by the requesting CA and the private key MUST NOT be sent to the responding CA. This request MAY also be used by subordinate CAs to get their certificates signed by the parent CA.",
      "ja": "クロス認証要求は、通常の認証要求と同じ構文（certreqmessages）を使用します。キーペアが要求CAによって生成された必要があり、秘密鍵を応答CAに送信してはなりません。このリクエストは、親CAが署名した証明書を取得するために、下位CASによっても使用される場合があります。"
    },
    {
      "indent": 3,
      "text": "See Appendix C and [CRMF] for CertReqMessages syntax.",
      "ja": "CertreqMessagesの構文については、付録Cおよび[CRMF]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.12. Cross Certification Response Content",
      "section_title": true,
      "ja": "5.3.12. クロス認証応答コンテンツ"
    },
    {
      "indent": 3,
      "text": "Cross certification responses use the same syntax (CertRepMessage) as normal certification responses, with the restriction that no encrypted private key can be sent.",
      "ja": "クロス認証応答は、通常の認証応答と同じ構文（certrepmessage）を使用します。暗号化された秘密鍵を送信できないという制限があります。"
    },
    {
      "indent": 3,
      "text": "See Section 5.3.4 for CertRepMessage syntax.",
      "ja": "CertrePmessageの構文については、セクション5.3.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.13. CA Key Update Announcement Content",
      "section_title": true,
      "ja": "5.3.13. CAキーアップデートアナウンスコンテンツ"
    },
    {
      "indent": 3,
      "text": "When a CA updates its own key pair, the following data structure MAY be used to announce this event.",
      "ja": "CAが独自の重要なペアを更新すると、次のデータ構造を使用してこのイベントを発表できます。"
    },
    {
      "indent": 4,
      "text": "CAKeyUpdAnnContent ::= SEQUENCE {\n   oldWithNew         Certificate,\n   newWithOld         Certificate,\n   newWithNew         Certificate\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.14. Certificate Announcement",
      "section_title": true,
      "ja": "5.3.14. 証明書の発表"
    },
    {
      "indent": 3,
      "text": "This structure MAY be used to announce the existence of certificates.",
      "ja": "この構造は、証明書の存在を発表するために使用できます。"
    },
    {
      "indent": 3,
      "text": "Note that this message is intended to be used for those cases (if any) where there is no pre-existing method for publication of certificates; it is not intended to be used where, for example, X.500 is the method for publication of certificates.",
      "ja": "このメッセージは、証明書の公開のための既存の方法がない場合（もしあれば）（ある場合）に使用することを目的としていることに注意してください。たとえば、X.500が証明書の公開方法である場合、使用することを意図していません。"
    },
    {
      "indent": 8,
      "text": "CertAnnContent ::= Certificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.15. Revocation Announcement",
      "section_title": true,
      "ja": "5.3.15. 取り消しの発表"
    },
    {
      "indent": 3,
      "text": "When a CA has revoked, or is about to revoke, a particular certificate, it MAY issue an announcement of this (possibly upcoming) event.",
      "ja": "CAが特定の証明書を取り消した、または取り消そうとしている場合、この（おそらく今後の）イベントの発表を発行する可能性があります。"
    },
    {
      "indent": 8,
      "text": "RevAnnContent ::= SEQUENCE {\n    status              PKIStatus,\n    certId              CertId,\n    willBeRevokedAt     GeneralizedTime,\n    badSinceDate        GeneralizedTime,\n    crlDetails          Extensions  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A CA MAY use such an announcement to warn (or notify) a subject that its certificate is about to be (or has been) revoked. This would typically be used where the request for revocation did not come from the subject concerned.",
      "ja": "CAは、そのような発表を使用して、その証明書が取り消されようとしている（または取り消された）主題に警告する（または通知）することができます。これは通常、取り消しの要求が関係する主題から得られなかった場合に使用されます。"
    },
    {
      "indent": 3,
      "text": "The willBeRevokedAt field contains the time at which a new entry will be added to the relevant CRLs.",
      "ja": "Willberevokedatフィールドには、関連するCRLに新しいエントリが追加される時間が含まれています。"
    },
    {
      "indent": 0,
      "text": "5.3.16. CRL Announcement",
      "section_title": true,
      "ja": "5.3.16. CRLの発表"
    },
    {
      "indent": 3,
      "text": "When a CA issues a new CRL (or set of CRLs) the following data structure MAY be used to announce this event.",
      "ja": "CAが新しいCRL（またはCRLのセット）を発行すると、次のデータ構造を使用してこのイベントを発表できます。"
    },
    {
      "indent": 8,
      "text": "CRLAnnContent ::= SEQUENCE OF CertificateList",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.17. PKI Confirmation Content",
      "section_title": true,
      "ja": "5.3.17. PKI確認コンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure is used in the protocol exchange as the final PKIMessage. Its content is the same in all cases -- actually there is no content since the PKIHeader carries all the required information.",
      "ja": "このデータ構造は、プロトコル交換で最終的なpkimessageとして使用されます。そのコンテンツはすべての場合に同じです - 実際には、PKIHeaderが必要なすべての情報を持っているため、コンテンツはありません。"
    },
    {
      "indent": 8,
      "text": "PKIConfirmContent ::= NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Use of this message for certificate confirmation is NOT RECOMMENDED; certConf SHOULD be used instead. Upon receiving a PKIConfirm for a certificate response, the recipient MAY treat it as a certConf with all certificates being accepted.",
      "ja": "証明書確認のためにこのメッセージを使用することは推奨されません。代わりにCERTCONFを使用する必要があります。証明書の回答のためにPkiconfirmを受け取ると、受信者はそれをすべての証明書を受け入れて証明書作成者として扱うことができます。"
    },
    {
      "indent": 0,
      "text": "5.3.18. Certificate Confirmation Content",
      "section_title": true,
      "ja": "5.3.18. 証明書確認コンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure is used by the client to send a confirmation to the CA/RA to accept or reject certificates.",
      "ja": "このデータ構造は、クライアントがCA/RAに確認を送信して証明書を受け入れるか拒否するために使用されます。"
    },
    {
      "indent": 9,
      "text": "CertConfirmContent ::= SEQUENCE OF CertStatus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "CertStatus ::= SEQUENCE {\n   certHash    OCTET STRING,\n   certReqId   INTEGER,\n   statusInfo  PKIStatusInfo OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For any particular CertStatus, omission of the statusInfo field indicates ACCEPTANCE of the specified certificate. Alternatively, explicit status details (with respect to acceptance or rejection) MAY be provided in the statusInfo field, perhaps for auditing purposes at the CA/RA.",
      "ja": "特定の証明書については、StatusInfoフィールドの省略は、指定された証明書の受け入れを示します。あるいは、おそらくCA/RAでの監査目的で、StatusInfoフィールドで明示的なステータスの詳細を（受け入れまたは拒否に関して）提供することができます。"
    },
    {
      "indent": 3,
      "text": "Within CertConfirmContent, omission of a CertStatus structure corresponding to a certificate supplied in the previous response message indicates REJECTION of the certificate. Thus, an empty CertConfirmContent (a zero-length SEQUENCE) MAY be used to indicate rejection of all supplied certificates. See Section 5.2.8, item (2), for a discussion of the certHash field with respect to proof-of-possession.",
      "ja": "CertConfirmContentでは、以前の応答メッセージで提供された証明書に対応する証明書構造の省略は、証明書の拒否を示しています。したがって、空のcertconfirmcontent（ゼロ長のシーケンス）を使用して、すべての供給された証明書の拒否を示すことができます。所有権の証明に関するセルタシュフィールドの議論については、セクション5.2.8、アイテム（2）を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19. PKI General Message Content",
      "section_title": true,
      "ja": "5.3.19. PKI一般的なメッセージコンテンツ"
    },
    {
      "indent": 5,
      "text": "InfoTypeAndValue ::= SEQUENCE {\n    infoType               OBJECT IDENTIFIER,\n    infoValue              ANY DEFINED BY infoType  OPTIONAL\n}\n-- where {id-it} = {id-pkix 4} = {1 3 6 1 5 5 7 4}\nGenMsgContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.1. CA Protocol Encryption Certificate",
      "section_title": true,
      "ja": "5.3.19.1. CAプロトコル暗号化証明書"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to get a certificate from the CA to use to protect sensitive information during the protocol.",
      "ja": "これは、EEがCAから証明書を取得して、プロトコル中に機密情報を保護するために使用するために使用できます。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 1}, < absent >\nGenRep:    {id-it 1}, Certificate | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "EEs MUST ensure that the correct certificate is used for this purpose.",
      "ja": "EESは、この目的のために正しい証明書が使用されることを確認する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.19.2. Signing Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.2. キーペアの種類に署名します"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to get the list of signature algorithms (e.g., RSA, DSA) whose subject public key values the CA is willing to certify. Note that for the purposes of this exchange, rsaEncryption and rsaWithSHA1, for example, are considered to be equivalent; the question being asked is, \"Is the CA willing to certify an RSA public key?\"",
      "ja": "これは、EEがCAがCAが認証する意思があると主張する署名アルゴリズム（RSA、DSAなど）のリストを取得するために使用することができます。この交換の目的のために、たとえばRsaEncryptionとRsawithsha1は同等であると見なされることに注意してください。尋ねられる質問は、「CAはRSAの公開鍵を認定することをいとわないのですか？」です。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 2}, < absent >\nGenRep:    {id-it 2}, SEQUENCE SIZE (1..MAX) OF\n                      AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.3. Encryption/Key Agreement Key Pair Types",
      "section_title": true,
      "ja": "5.3.19.3. 暗号化/キー契約キーペアタイプ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the list of encryption/key agreement algorithms whose subject public key values the CA is willing to certify.",
      "ja": "これは、CAがCAが認定する意思があると主題と評価する暗号化/キー契約アルゴリズムのリストを取得するためにクライアントが使用することができます。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 3}, < absent >\nGenRep:    {id-it 3}, SEQUENCE SIZE (1..MAX) OF\n                      AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.4. Preferred Symmetric Algorithm",
      "section_title": true,
      "ja": "5.3.19.4. 優先対称アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get the CA-preferred symmetric encryption algorithm for any confidential information that needs to be exchanged between the EE and the CA (for example, if the EE wants to send its private decryption key to the CA for archival purposes).",
      "ja": "これは、EEとCAの間で交換する必要がある機密情報に対してCAプロファーリング対称暗号化アルゴリズムを取得するためにクライアントが使用することができます（たとえば、EEがArchivalのCAにプライベート復号化キーをCAに送信したい場合目的）。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 4}, < absent >\nGenRep:    {id-it 4}, AlgorithmIdentifier",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.5. Updated CA Key Pair",
      "section_title": true,
      "ja": "5.3.19.5. CAキーペアを更新しました"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the CA to announce a CA key update event.",
      "ja": "これは、CAによってCAキーアップデートイベントを発表するために使用できます。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 5}, CAKeyUpdAnnContent",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.6. CRL",
      "section_title": true,
      "ja": "5.3.19.6. CRL"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the client to get a copy of the latest CRL.",
      "ja": "これは、クライアントが最新のCRLのコピーを取得するために使用できます。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 6}, < absent >\nGenRep:    {id-it 6}, CertificateList",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.7. Unsupported Object Identifiers",
      "section_title": true,
      "ja": "5.3.19.7. サポートされていないオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "This is used by the server to return a list of object identifiers that it does not recognize or support from the list submitted by the client.",
      "ja": "これは、クライアントが提出したリストから認識またはサポートしていないオブジェクト識別子のリストを返すためにサーバーによって使用されます。"
    },
    {
      "indent": 6,
      "text": "GenRep:    {id-it 7}, SEQUENCE SIZE (1..MAX) OF OBJECT IDENTIFIER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.8. Key Pair Parameters",
      "section_title": true,
      "ja": "5.3.19.8. キーペアパラメーター"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to request the domain parameters to use for generating the key pair for certain public-key algorithms. It can be used, for example, to request the appropriate P, Q, and G to generate the DH/DSA key, or to request a set of well-known elliptic curves.",
      "ja": "これは、特定のパブリックキーアルゴリズムのキーペアを生成するために使用するドメインパラメーターを要求するためにEEによって使用される場合があります。たとえば、適切なp、q、およびgを要求してDH/DSAキーを生成するか、よく知られている楕円曲線のセットを要求するために使用できます。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 10}, OBJECT IDENTIFIER -- (Algorithm object-id)\nGenRep:    {id-it 11}, AlgorithmIdentifier | < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An absent infoValue in the GenRep indicates that the algorithm specified in GenMsg is not supported.",
      "ja": "GenRepに存在しない情報値は、GenMSGで指定されたアルゴリズムがサポートされていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "EEs MUST ensure that the parameters are acceptable to it and that the GenRep message is authenticated (to avoid substitution attacks).",
      "ja": "EEは、パラメーターがそれに受け入れられること、およびGenRepメッセージが認証されていることを確認する必要があります（代替攻撃を避けるため）。"
    },
    {
      "indent": 0,
      "text": "5.3.19.9. Revocation Passphrase",
      "section_title": true,
      "ja": "5.3.19.9. 取り消しパスフレーズ"
    },
    {
      "indent": 3,
      "text": "This MAY be used by the EE to send a passphrase to a CA/RA for the purpose of authenticating a later revocation request (in the case that the appropriate signing private key is no longer available to authenticate the request). See Appendix B for further details on the use of this mechanism.",
      "ja": "これは、EEが後の取り消しリクエストを認証する目的で、PassPhraseをCA/RAに送信するために使用できます（適切な署名秘密キーがリクエストを認証するために使用できなくなった場合）。このメカニズムの使用に関する詳細については、付録Bを参照してください。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 12}, EncryptedValue\nGenRep:    {id-it 12}, < absent >",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.19.10. ImplicitConfirm",
      "section_title": true,
      "ja": "5.3.19.10. 暗黙的なこと"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.1 for the definition and use of {id-it 13}.",
      "ja": "{id-it 13}の定義と使用については、セクション5.1.1.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.11. ConfirmWaitTime",
      "section_title": true,
      "ja": "5.3.19.11. 確認waittime"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.1.2 for the definition and use of {id-it 14}.",
      "ja": "{id-it 14}の定義と使用については、セクション5.1.1.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.12 Original PKIMessage",
      "section_title": true,
      "ja": "5.3.19.12 オリジナルのpkimessage"
    },
    {
      "indent": 3,
      "text": "See Section 5.1.3 for the definition and use of {id-it 15}.",
      "ja": "{id-it 15}の定義と使用については、セクション5.1.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.3.19.13. Supported Language Tags",
      "section_title": true,
      "ja": "5.3.19.13. サポートされている言語タグ"
    },
    {
      "indent": 3,
      "text": "This MAY be used to determine the appropriate language tag to use in subsequent messages. The sender sends its list of supported languages (in order, most preferred to least); the receiver returns the one it wishes to use. (Note: each UTF8String MUST include a language tag.) If none of the offered tags are supported, an error MUST be returned.",
      "ja": "これは、後続のメッセージで使用する適切な言語タグを決定するために使用できます。送信者は、サポートされている言語のリストを送信します（順番に、最も好まれますが）。レシーバーは、使用したいものを返します。（注：各UTF8STRINGには言語タグを含める必要があります。）提供されたタグがサポートされていない場合、エラーを返す必要があります。"
    },
    {
      "indent": 6,
      "text": "GenMsg:    {id-it 16}, SEQUENCE SIZE (1..MAX) OF UTF8String\nGenRep:    {id-it 16}, SEQUENCE SIZE (1) OF UTF8String",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.3.20. PKI General Response Content",
      "section_title": true,
      "ja": "5.3.20. PKI一般応答コンテンツ"
    },
    {
      "indent": 6,
      "text": "GenRepContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Examples of GenReps that MAY be supported include those listed in the subsections of Section 5.3.19.",
      "ja": "サポートできるGenRepsの例には、セクション5.3.19のサブセクションにリストされている例が含まれます。"
    },
    {
      "indent": 0,
      "text": "5.3.21. Error Message Content",
      "section_title": true,
      "ja": "5.3.21. エラーメッセージコンテンツ"
    },
    {
      "indent": 3,
      "text": "This data structure MAY be used by EE, CA, or RA to convey error info.",
      "ja": "このデータ構造は、EE、CA、またはRAでエラー情報を伝えるために使用できます。"
    },
    {
      "indent": 4,
      "text": "ErrorMsgContent ::= SEQUENCE {\n    pKIStatusInfo          PKIStatusInfo,\n    errorCode              INTEGER           OPTIONAL,\n    errorDetails           PKIFreeText       OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This message MAY be generated at any time during a PKI transaction. If the client sends this request, the server MUST respond with a PKIConfirm response, or another ErrorMsg if any part of the header is not valid. Both sides MUST treat this message as the end of the transaction (if a transaction is in progress).",
      "ja": "このメッセージは、PKIトランザクション中にいつでも生成される場合があります。クライアントがこのリクエストを送信する場合、サーバーはPKICONFIRM応答で応答する必要があります。ヘッダーの一部が有効でない場合は、別のERRORMSGが必要です。双方は、このメッセージをトランザクションの終わりとして扱う必要があります（トランザクションが進行中の場合）。"
    },
    {
      "indent": 3,
      "text": "If protection is desired on the message, the client MUST protect it using the same technique (i.e., signature or MAC) as the starting message of the transaction. The CA MUST always sign it with a signature key.",
      "ja": "メッセージに保護が必要な場合、クライアントは、トランザクションの開始メッセージと同じ手法（つまり、署名またはMac）を使用してそれを保護する必要があります。CAは常に署名キーで署名する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.3.22. Polling Request and Response",
      "section_title": true,
      "ja": "5.3.22. ポーリングリクエストと応答"
    },
    {
      "indent": 3,
      "text": "This pair of messages is intended to handle scenarios in which the client needs to poll the server in order to determine the status of an outstanding ir, cr, or kur transaction (i.e., when the \"waiting\" PKIStatus has been received).",
      "ja": "このメッセージのペアは、傑出したIR、CR、またはKURトランザクションのステータスを決定するために、クライアントがサーバーを投票する必要があるシナリオを処理することを目的としています（つまり、「待機」Pkistatusが受け取られたとき）。"
    },
    {
      "indent": 4,
      "text": "PollReqContent ::= SEQUENCE OF SEQUENCE {\n    certReqId    INTEGER }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "PollRepContent ::= SEQUENCE OF SEQUENCE {\n    certReqId    INTEGER,\n    checkAfter   INTEGER,  -- time in seconds\n    reason       PKIFreeText OPTIONAL }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following clauses describe when polling messages are used, and how they are used. It is assumed that multiple certConf messages can be sent during transactions. There will be one sent in response to each ip, cp, or kup that contains a CertStatus for an issued certificate.",
      "ja": "次の条項では、ポーリングメッセージが使用される時期と使用方法について説明します。トランザクション中に複数のCERTCONFメッセージを送信できると想定されています。発行された証明書の証明書を含む各IP、CP、またはKUPに応答して送信されます。"
    },
    {
      "indent": 3,
      "text": "1. In response to an ip, cp, or kup message, an EE will send a certConf for all issued certificates and, following the ack, a pollReq for all pending certificates.",
      "ja": "1. IP、CP、またはKUPメッセージに応じて、EEはすべての発行された証明書に対して証明書を送信し、ACKに従って、すべての保留中の証明書のPollReqを送信します。"
    },
    {
      "indent": 3,
      "text": "2. In response to a pollReq, a CA/RA will return an ip, cp, or kup if one or more of the pending certificates is ready; otherwise, it will return a pollRep.",
      "ja": "2. Pollreqに応じて、CA/RAは、保留中の証明書の1つ以上が準備ができている場合、IP、CP、またはKUPを返します。それ以外の場合は、Pollrepを返します。"
    },
    {
      "indent": 3,
      "text": "3. If the EE receives a pollRep, it will wait for at least as long as the checkAfter value before sending another pollReq.",
      "ja": "3. EEがPollrepを受け取った場合、別のPollreqを送信する前に、少なくともCheckafter値と同じ長さを待ちます。"
    },
    {
      "indent": 3,
      "text": "4. If an ip, cp, or kup is received in response to a pollReq, then it will be treated in the same way as the initial response.",
      "ja": "4. IP、CP、またはKUPがPollreqに応じて受信された場合、初期応答と同じ方法で扱われます。"
    },
    {
      "indent": 4,
      "text": "                           START\n                             |\n                             v\n                          Send ir\n                             | ip\n                             v\n                        Check status\n                        of returned <------------------------+\n                           certs                             |\n                             |                               |\n   +------------------------>|<------------------+           |\n   |                         |                   |           |\n   |        (issued)         v       (waiting)   |           |\n Add to <----------- Check CertResponse ------> Add to       |\nconf list           for each certificate      pending list   |\n                             /                               |\n                            /                                |\n               (conf list) /     (empty conf list)           |\n                          /                     ip           |\n                         /                 +----------------+\n  (empty pending list)  /                  |    pRep\n    END <---- Send certConf         Send pReq------------>Wait\n                     |                 ^   ^               |\n                     |                 |   |               |\n                     +-----------------+   +---------------+\n                        (pending list)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In the following exchange, the end entity is enrolling for two certificates in one request.",
      "ja": "次の交換では、最終エンティティは1つのリクエストで2つの証明書に登録しています。"
    },
    {
      "indent": 4,
      "text": "Step  End Entity                       PKI\n--------------------------------------------------------------------\n1   Format ir\n2                    -> ir      ->\n3                                    Handle ir\n4                                    Manual intervention is\n                                     required for both certs.\n5                    <- ip      <-\n6   Process ip\n7   Format pReq\n8                    -> pReq     ->\n9                                    Check status of cert requests\n10                                   Certificates not ready\n11                                   Format pRep\n12                   <- pRep     <-\n13  Wait\n14  Format pReq\n15                   -> pReq     ->\n16                                   Check status of cert requests\n17                                   One certificate is ready\n18                                   Format ip\n19                   <- ip       <-\n20  Handle ip\n21  Format certConf\n22                   -> certConf ->\n23                                   Handle certConf\n24                                   Format ack\n25                   <- pkiConf   <-\n26  Format pReq\n27                   -> pReq     ->\n28                                   Check status of certificate\n29                                   Certificate is ready\n30                                   Format ip\n31                   <- ip       <-\n31  Handle ip\n32  Format certConf\n33                   -> certConf ->\n34                                   Handle certConf\n35                                   Format ack\n36                   <- pkiConf  <-",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Mandatory PKI Management Functions",
      "section_title": true,
      "ja": "6. 必須のPKI管理機能"
    },
    {
      "indent": 3,
      "text": "Some of the PKI management functions outlined in Section 3.1 above are described in this section.",
      "ja": "上記のセクション3.1で概説されているPKI管理関数のいくつかについては、このセクションで説明します。"
    },
    {
      "indent": 3,
      "text": "This section deals with functions that are \"mandatory\" in the sense that all end entity and CA/RA implementations MUST be able to provide the functionality described. This part is effectively the profile of the PKI management functionality that MUST be supported. Note, however, that the management functions described in this section do not need to be accomplished using the PKI messages defined in Section 5 if alternate means are suitable for a given environment (see Appendix D for profiles of the PKIMessages that MUST be supported).",
      "ja": "このセクションでは、すべての最終エンティティとCA/RAの実装が説明されている機能を提供できる必要があるという意味で、「必須」の関数を扱います。この部分は、効果的にサポートする必要があるPKI管理機能のプロファイルです。ただし、このセクションで説明した管理機能は、特定の環境に代替手段が適している場合、セクション5で定義されたPKIメッセージを使用して達成する必要はないことに注意してください（サポートする必要があるPKIMESSAGEのプロファイルについては付録Dを参照）。"
    },
    {
      "indent": 0,
      "text": "6.1. Root CA Initialization",
      "section_title": true,
      "ja": "6.1. ルートCA初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"root CA\".]",
      "ja": "[このドキュメントの「ルートCA」の定義については、セクション3.1.1.2を参照してください。]"
    },
    {
      "indent": 3,
      "text": "A newly created root CA must produce a \"self-certificate\", which is a Certificate structure with the profile defined for the \"newWithNew\" certificate issued following a root CA key update.",
      "ja": "新しく作成されたルートCAは、「自己認証」を作成する必要があります。これは、ルートCAキーアップデートに従って発行された「NewWithNew」証明書で定義されたプロファイルを含む証明書構造です。"
    },
    {
      "indent": 3,
      "text": "In order to make the CA's self certificate useful to end entities that do not acquire the self certificate via \"out-of-band\" means, the CA must also produce a fingerprint for its certificate. End entities that acquire this fingerprint securely via some \"out-of-band\" means can then verify the CA's self-certificate and, hence, the other attributes contained therein.",
      "ja": "CAの自己証明書を「帯域外」平均を介して自己証明書を取得しないエンティティを終了するのに役立つようにするために、CAは証明書の指紋を作成する必要があります。いくつかの「帯域外」手段を介してこの指紋を安全に取得するエンティティは、CAの自己認証、したがって、そこに含まれる他の属性を検証できます。"
    },
    {
      "indent": 3,
      "text": "The data structure used to carry the fingerprint is the OOBCertHash.",
      "ja": "指紋を運ぶために使用されるデータ構造は、obcerthashです。"
    },
    {
      "indent": 0,
      "text": "6.2. Root CA Key Update",
      "section_title": true,
      "ja": "6.2. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "CA keys (as all other keys) have a finite lifetime and will have to be updated on a periodic basis. The certificates NewWithNew, NewWithOld, and OldWithNew (see Section 4.4.1) MAY be issued by the CA to aid existing end entities who hold the current self-signed CA certificate (OldWithOld) to transition securely to the new self-signed CA certificate (NewWithNew), and to aid new end entities who will hold NewWithNew to acquire OldWithOld securely for verification of existing data.",
      "ja": "CAキー（他のすべてのキーとして）には有限の寿命があり、定期的に更新する必要があります。NewWithNew、NewWithold、およびOldwithNew（セクション4.4.1を参照）は、CAが発行して、現在の自己署名CA証明書（OldWithold）を保持している既存の最終エンティティを支援して、新しい自己署名CA証明書（新しい自己署名CA証明書（NewWithNew）、およびNewWithNewを保持して既存のデータの検証のためにOldWitholdを安全に取得する新しい最終エンティティを支援するため。"
    },
    {
      "indent": 0,
      "text": "6.3. Subordinate CA Initialization",
      "section_title": true,
      "ja": "6.3. 下位CA初期化"
    },
    {
      "indent": 3,
      "text": "[See Section 3.1.1.2 for this document's definition of \"subordinate CA\".] From the perspective of PKI management protocols, the initialization of a subordinate CA is the same as the initialization of an end entity. The only difference is that the subordinate CA must also produce an initial revocation list.",
      "ja": "[このドキュメントの「下位CA」の定義については、セクション3.1.1.2を参照してください。] PKI管理プロトコルの観点から、下位CAの初期化は終了エンティティの初期化と同じです。唯一の違いは、下位CAが最初の取り消しリストも作成する必要があることです。"
    },
    {
      "indent": 0,
      "text": "6.4. CRL production",
      "section_title": true,
      "ja": "6.4. CRL生産"
    },
    {
      "indent": 3,
      "text": "Before issuing any certificates, a newly established CA (which issues CRLs) must produce \"empty\" versions of each CRL which are to be periodically produced.",
      "ja": "証明書を発行する前に、新しく確立されたCA（CRLを発行する）は、定期的に生成される各CRLの「空の」バージョンを作成する必要があります。"
    },
    {
      "indent": 0,
      "text": "6.5. PKI Information Request",
      "section_title": true,
      "ja": "6.5. PKI情報リクエスト"
    },
    {
      "indent": 3,
      "text": "When a PKI entity (CA, RA, or EE) wishes to acquire information about the current status of a CA, it MAY send that CA a request for such information.",
      "ja": "PKIエンティティ（CA、RA、またはEE）がCAの現在のステータスに関する情報を取得したい場合、CAにそのような情報のリクエストを送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The CA MUST respond to the request by providing (at least) all of the information requested by the requester. If some of the information cannot be provided, then an error must be conveyed to the requester.",
      "ja": "CAは、要求者が要求したすべての情報を（少なくとも）提供することにより、要求に応答する必要があります。情報の一部を提供できない場合は、リクエスターにエラーを伝える必要があります。"
    },
    {
      "indent": 3,
      "text": "If PKIMessages are used to request and supply this PKI information, then the request MUST be the GenMsg message, the response MUST be the GenRep message, and the error MUST be the Error message. These messages are protected using a MAC based on shared secret information (i.e., PasswordBasedMAC) or using any other authenticated means (if the end entity has an existing certificate).",
      "ja": "このPKI情報を要求して提供するためにpkimessagesを使用している場合、リクエストはGenmsgメッセージでなければならず、応答はGenRepメッセージでなければならず、エラーはエラーメッセージでなければなりません。これらのメッセージは、共有秘密情報（つまり、パスワードベースマック）に基づくMACを使用して、または他の認証された手段を使用して保護されます（最終エンティティが既存の証明書がある場合）。"
    },
    {
      "indent": 0,
      "text": "6.6. Cross Certification",
      "section_title": true,
      "ja": "6.6. クロス認証"
    },
    {
      "indent": 3,
      "text": "The requester CA is the CA that will become the subject of the cross-certificate; the responder CA will become the issuer of the cross-certificate.",
      "ja": "リクエスターCAは、クロス認証の対象となるCAです。Responder CAは、クロス認証の発行者になります。"
    },
    {
      "indent": 3,
      "text": "The requester CA must be \"up and running\" before initiating the cross-certification operation.",
      "ja": "リクエスターCAは、相互認定操作を開始する前に「上昇している」必要があります。"
    },
    {
      "indent": 0,
      "text": "6.6.1. One-Way Request-Response Scheme:",
      "ja": "6.6.1. 一元配置リクエスト応答スキーム："
    },
    {
      "indent": 3,
      "text": "The cross-certification scheme is essentially a one way operation; that is, when successful, this operation results in the creation of one new cross-certificate. If the requirement is that cross-certificates be created in \"both directions\", then each CA, in turn, must initiate a cross-certification operation (or use another scheme).",
      "ja": "相互認証スキームは、本質的に一方向操作です。つまり、成功すると、この操作により、1つの新しいクロス認証が作成されます。要件が「両方方向」にクロス認証が作成される場合、各CAは、相互認定操作を開始する必要があります（または別のスキームを使用）。"
    },
    {
      "indent": 3,
      "text": "This scheme is suitable where the two CAs in question can already verify each other's signatures (they have some common points of trust) or where there is an out-of-band verification of the origin of the certification request.",
      "ja": "このスキームは、問題の2つのCAが互いの署名（いくつかの共通の信頼ポイントがある）をすでに検証できる場合、または認証リクエストの起源の帯域外検証がある場合に適しています。"
    },
    {
      "indent": 3,
      "text": "Detailed Description:",
      "ja": "詳細な説明："
    },
    {
      "indent": 3,
      "text": "Cross certification is initiated at one CA known as the responder. The CA administrator for the responder identifies the CA it wants to cross certify and the responder CA equipment generates an authorization code. The responder CA administrator passes this authorization code by out-of-band means to the requester CA administrator. The requester CA administrator enters the authorization code at the requester CA in order to initiate the on-line exchange.",
      "ja": "クロス認証は、レスポンダーとして知られる1つのCAで開始されます。ResponderのCA管理者は、認定を交差させたいCAを識別し、Responder CA機器が認証コードを生成します。Responder CA管理者は、この承認コードを帯域外の手段でリクエスターCA管理者に渡します。Requester CA管理者は、オンライン交換を開始するために、Requester CAに承認コードを入力します。"
    },
    {
      "indent": 3,
      "text": "The authorization code is used for authentication and integrity purposes. This is done by generating a symmetric key based on the authorization code and using the symmetric key for generating Message Authentication Codes (MACs) on all messages exchanged. (Authentication may alternatively be done using signatures instead of MACs, if the CAs are able to retrieve and validate the required public keys by some means, such as an out-of-band hash comparison.)",
      "ja": "認証コードは、認証と整合性の目的で使用されます。これは、認証コードに基づいて対称キーを生成し、交換されたすべてのメッセージでメッセージ認証コード（MAC）を生成するための対称キーを使用することによって行われます。（CASが帯域外ハッシュ比較など、必要なパブリックキーを何らかの手段で取得および検証できる場合、認証はMacの代わりに署名を使用して行われる場合があります。）"
    },
    {
      "indent": 3,
      "text": "The requester CA initiates the exchange by generating a cross-certification request (ccr) with a fresh random number (requester random number). The requester CA then sends the ccr message to the responder CA. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "リクエスターCAは、新鮮な乱数（要求者乱数）で相互認証要求（CCR）を生成することにより、交換を開始します。リクエスターCAは、CCRメッセージをレスポンダーCAに送信します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ccr message, the responder CA validates the message and the MAC, saves the requester random number, and generates its own random number (responder random number). It then generates (and archives, if desired) a new requester certificate that contains the requester CA public key and is signed with the responder CA signature private key. The responder CA responds with the cross certification response (ccp) message. The fields in this message are protected from modification with a MAC based on the authorization code.",
      "ja": "CCRメッセージを受信すると、Responder CAはメッセージとMACを検証し、リクエスターの乱数を保存し、独自の乱数（Responder乱数）を生成します。次に、要求者CAの公開キーを含み、Responder CAの署名秘密鍵で署名された新しい要求者証明書を生成（および必要に応じて）生成します（必要に応じて）生成します。Responder CAは、Cross Certification Response（CCP）メッセージで応答します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the ccp message, the requester CA validates the message (including the received random numbers) and the MAC. The requester CA responds with the certConf message. The fields in this message are protected from modification with a MAC based on the authorization code. The requester CA MAY write the requester certificate to the Repository as an aid to later certificate path construction.",
      "ja": "CCPメッセージを受信すると、Requester CAはメッセージ（受信した乱数を含む）とMACを検証します。Requester CAは、CERTCONFメッセージで応答します。このメッセージのフィールドは、承認コードに基づいてMACを使用して変更から保護されています。リクエスターCAは、後の証明書パス構築への援助として、リクエスター証明書をリポジトリに書き込むことができます。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the certConf message, the responder CA validates the message and the MAC, and sends back an acknowledgement using the PKIConfirm message. It MAY also publish the requester certificate as an aid to later path construction.",
      "ja": "CERTCONFメッセージを受信すると、Responder CAはメッセージとMacを検証し、PKICONFIRMメッセージを使用して確認を送信します。また、後のパス構築への援助として、リクエスター証明書を公開することもできます。"
    },
    {
      "indent": 3,
      "text": "Notes:",
      "ja": "ノート："
    },
    {
      "indent": 3,
      "text": "1. The ccr message must contain a \"complete\" certification request; that is, all fields except the serial number (including, e.g., a BasicConstraints extension) must be specified by the requester CA.",
      "ja": "1. CCRメッセージには、「完全な」認定リクエストが含まれている必要があります。つまり、シリアル番号を除くすべてのフィールド（たとえば、基本的な構成拡張を含む）は、リクエスターCAによって指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The ccp message SHOULD contain the verification certificate of the responder CA; if present, the requester CA must then verify this certificate (for example, via the \"out-of-band\" mechanism).",
      "ja": "2. CCPメッセージには、レスポンダーCAの検証証明書を含める必要があります。存在する場合、要求者CAはこの証明書を検証する必要があります（たとえば、「帯域外」メカニズムを介して）。"
    },
    {
      "indent": 3,
      "text": "(A simpler, non-interactive model of cross-certification may also be envisioned, in which the issuing CA acquires the subject CA's public key from some repository, verifies it via some out-of-band mechanism, and creates and publishes the cross-certificate without the subject CA's explicit involvement. This model may be perfectly legitimate for many environments, but since it does not require any protocol message exchanges, its detailed description is outside the scope of this specification.)",
      "ja": "（相互認証のよりシンプルな非対話的モデルも想定される場合があります。これにより、発行CAは、一部のリポジトリから対象CAの公開キーを取得し、帯域外のメカニズムを介して検証し、クロスを作成および公開することができます。主題CAの明示的な関与のない証明書。このモデルは多くの環境で完全に合法である可能性がありますが、プロトコルメッセージ交換は必要ないため、その詳細な説明はこの仕様の範囲外です。）"
    },
    {
      "indent": 0,
      "text": "6.7. End Entity Initialization",
      "section_title": true,
      "ja": "6.7. エンティティの初期化を終了します"
    },
    {
      "indent": 3,
      "text": "As with CAs, end entities must be initialized. Initialization of end entities requires at least two steps:",
      "ja": "CASと同様に、最終エンティティを初期化する必要があります。ENDエンティティの初期化には、少なくとも2つのステップが必要です。"
    },
    {
      "indent": 3,
      "text": "o acquisition of PKI information",
      "ja": "o PKI情報の取得"
    },
    {
      "indent": 3,
      "text": "o out-of-band verification of one root-CA public key",
      "ja": "o 1つのルートCA公開キーのバンド外の検証"
    },
    {
      "indent": 3,
      "text": "(other possible steps include the retrieval of trust condition information and/or out-of-band verification of other CA public keys).",
      "ja": "（他の考えられる手順には、信頼状態情報の検索および/または他のCAパブリックキーの帯域外検証が含まれます）。"
    },
    {
      "indent": 0,
      "text": "6.7.1. Acquisition of PKI Information",
      "section_title": true,
      "ja": "6.7.1. PKI情報の取得"
    },
    {
      "indent": 3,
      "text": "The information REQUIRED is:",
      "ja": "必要な情報は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o the current root-CA public key",
      "ja": "o 現在のルートCA公開キー"
    },
    {
      "indent": 3,
      "text": "o (if the certifying CA is not a root-CA) the certification path from the root CA to the certifying CA together with appropriate revocation lists",
      "ja": "o （認定CAがルートCAではない場合）適切な取り消しリストと一緒に、ルートCAから認証CAへの認証パス"
    },
    {
      "indent": 3,
      "text": "o the algorithms and algorithm parameters that the certifying CA supports for each relevant usage",
      "ja": "o 認証CAが関連する使用ごとにサポートするアルゴリズムとアルゴリズムパラメーター"
    },
    {
      "indent": 3,
      "text": "Additional information could be required (e.g., supported extensions or CA policy information) in order to produce a certification request that will be successful. However, for simplicity we do not mandate that the end entity acquires this information via the PKI messages. The end result is simply that some certification requests may fail (e.g., if the end entity wants to generate its own encryption key, but the CA doesn't allow that).",
      "ja": "成功する認定要求を作成するために、追加情報（サポートされている拡張情報やCAポリシー情報など）が必要になる場合があります。ただし、簡単にするために、最終エンティティがPKIメッセージを介してこの情報を取得することを義務付けていません。最終結果は、一部の認証要求が失敗する可能性があることです（たとえば、最終エンティティが独自の暗号化キーを生成したいが、CAはそれを許可しない場合）。"
    },
    {
      "indent": 3,
      "text": "The required information MAY be acquired as described in Section 6.5.",
      "ja": "セクション6.5で説明されているように、必要な情報を取得できます。"
    },
    {
      "indent": 0,
      "text": "6.7.2. Out-of-Band Verification of Root-CA Key",
      "section_title": true,
      "ja": "6.7.2. ルートCAキーのバンド外の検証"
    },
    {
      "indent": 3,
      "text": "An end entity must securely possess the public key of its root CA. One method to achieve this is to provide the end entity with the CA's self-certificate fingerprint via some secure \"out-of-band\" means. The end entity can then securely use the CA's self-certificate.",
      "ja": "最終エンティティは、ルートCAの公開鍵を安全に所有する必要があります。これを達成する1つの方法は、安全な「帯域外」平均を介してCAの自己認証指紋を最終エンティティに提供することです。最終エンティティは、CAの自己認証を安全に使用できます。"
    },
    {
      "indent": 3,
      "text": "See Section 6.1 for further details.",
      "ja": "詳細については、セクション6.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "6.8. Certificate Request",
      "section_title": true,
      "ja": "6.8. 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "An initialized end entity MAY request an additional certificate at any time (for any purpose). This request will be made using the certification request (cr) message. If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this cr message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a CertRepMessage.",
      "ja": "初期化された終了エンティティは、いつでも追加の証明書を要求する場合があります（いかなる目的でも）。このリクエストは、認定リクエスト（CR）メッセージを使用して行われます。End Entityがすでに署名キーペアを持っている場合（対応する検証証明書を使用）、このCRメッセージは通常、エンティティのデジタル署名によって保護されます。CAは、certrepmessageで新しい証明書（リクエストが成功した場合）を返します。"
    },
    {
      "indent": 0,
      "text": "6.9. Key Update",
      "section_title": true,
      "ja": "6.9. キーアップデート"
    },
    {
      "indent": 3,
      "text": "When a key pair is due to expire, the relevant end entity MAY request a key update; that is, it MAY request that the CA issue a new certificate for a new key pair (or, in certain circumstances, a new certificate for the same key pair). The request is made using a key update request (kur) message (referred to, in some environments, as a \"Certificate Update\" operation). If the end entity already possesses a signing key pair (with a corresponding verification certificate), then this message will typically be protected by the entity's digital signature. The CA returns the new certificate (if the request is successful) in a key update response (kup) message, which is syntactically identical to a CertRepMessage.",
      "ja": "キーペアの有効期限が切れる場合、関連する最終エンティティはキーアップデートを要求する場合があります。つまり、CAが新しいキーペアの新しい証明書を発行することを要求する場合があります（または、特定の状況では、同じキーペアの新しい証明書）。リクエストは、キーアップデートリクエスト（KUR）メッセージ（一部の環境では、「証明書の更新」操作と呼ばれます）を使用して行われます。End Entityが既に署名キーペアを持っている場合（対応する検証証明書を使用）、このメッセージは通常、エンティティのデジタル署名によって保護されます。CAは、CertrePmessageと構文的に同一のキーアップデート応答（KUP）メッセージで新しい証明書（リクエストが成功した場合）を返します。"
    },
    {
      "indent": 0,
      "text": "7. Version Negotiation",
      "section_title": true,
      "ja": "7. バージョンの交渉"
    },
    {
      "indent": 3,
      "text": "This section defines the version negotiation used to support older protocols between client and servers.",
      "ja": "このセクションでは、クライアントとサーバーの間の古いプロトコルをサポートするために使用されるバージョンネゴシエーションを定義します。"
    },
    {
      "indent": 3,
      "text": "If a client knows the protocol version(s) supported by the server (e.g., from a previous PKIMessage exchange or via some out-of-band means), then it MUST send a PKIMessage with the highest version supported by both it and the server. If a client does not know what version(s) the server supports, then it MUST send a PKIMessage using the highest version it supports.",
      "ja": "クライアントがサーバーでサポートされているプロトコルバージョンを知っている場合（例：以前のPkimessage Exchangeから、またはいくつかの帯域外の手段による）、それとサーバーの両方でサポートされている最高バージョンでpkimessageを送信する必要があります。クライアントがサーバーがサポートするバージョンがわからない場合、サポートする最高のバージョンを使用してpkimessageを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a server receives a message with a version that it supports, then the version of the response message MUST be the same as the received version. If a server receives a message with a version higher or lower than it supports, then it MUST send back an ErrorMsg with the unsupportedVersion bit set (in the failureInfo field of the pKIStatusInfo). If the received version is higher than the highest supported version, then the version in the error message MUST be the highest version the server supports; if the received version is lower than the lowest supported version then the version in the error message MUST be the lowest version the server supports.",
      "ja": "サーバーがサポートするバージョンを使用してメッセージを受信した場合、応答メッセージのバージョンは受信バージョンと同じでなければなりません。サーバーがサポートよりも高いまたは低いバージョンのメッセージを受信する場合、サポートされていないバージョンビットセットを使用してErrorMSGを送信する必要があります（pkistatusinfoの故障フィールド）。受信バージョンが最高のサポートバージョンよりも高い場合、エラーメッセージのバージョンはサーバーがサポートする最高版でなければなりません。受信バージョンが最低サポートバージョンよりも低い場合、エラーメッセージのバージョンはサーバーがサポートする最低バージョンでなければなりません。"
    },
    {
      "indent": 3,
      "text": "If a client gets back an ErrorMsgContent with the unsupportedVersion bit set and a version it supports, then it MAY retry the request with that version.",
      "ja": "クライアントが、サポートされていないバージョンビットセットとサポートするバージョンを使用してErrorMSGContentを取り戻すと、そのバージョンでリクエストを再試行する場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1. Supporting RFC 2510 Implementations",
      "section_title": true,
      "ja": "7.1. RFC 2510実装のサポート"
    },
    {
      "indent": 3,
      "text": "RFC 2510 did not specify the behaviour of implementations receiving versions they did not understand since there was only one version in existence. With the introduction of the present revision of the specification, the following versioning behaviour is recommended.",
      "ja": "RFC 2510は、存在するバージョンが1つしかなかったため、理解できなかったバージョンを受信する実装の動作を指定しませんでした。現在の修正の導入により、次のバージョン化動作が推奨されます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Clients Talking to RFC 2510 Servers",
      "section_title": true,
      "ja": "7.1.1. RFC 2510サーバーと話しているクライアント"
    },
    {
      "indent": 3,
      "text": "If, after sending a cmp2000 message, a client receives an ErrorMsgContent with a version of cmp1999, then it MUST abort the current transaction. It MAY subsequently retry the transaction using version cmp1999 messages.",
      "ja": "CMP2000メッセージを送信した後、クライアントがCMP1999のバージョンを使用してErrormSgContentを受信した場合、現在のトランザクションを中止する必要があります。その後、バージョンCMP1999メッセージを使用してトランザクションを再試行する場合があります。"
    },
    {
      "indent": 3,
      "text": "If a client receives a non-error PKIMessage with a version of cmp1999, then it MAY decide to continue the transaction (if the transaction hasn't finished) using RFC 2510 semantics. If it does not choose to do so and the transaction is not finished, then it MUST abort the transaction and send an ErrorMsgContent with a version of cmp1999.",
      "ja": "クライアントがCMP1999のバージョンで非誤差pkimessageを受信した場合、RFC 2510セマンティクスを使用してトランザクション（トランザクションが終了していない場合）を継続することを決定する場合があります。そうすることを選択しておらず、トランザクションが終了していない場合は、トランザクションを中止し、CMP1999のバージョンでErrormsgContentを送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "7.1.2. Servers Receiving Version cmp1999 PKIMessages",
      "section_title": true,
      "ja": "7.1.2. バージョンを受信するサーバーCMP1999 pkimessages"
    },
    {
      "indent": 3,
      "text": "If a server receives a version cmp1999 message it MAY revert to RFC 2510 behaviour and respond with version cmp1999 messages. If it does not choose to do so, then it MUST send back an ErrorMsgContent as described above in Section 7.",
      "ja": "サーバーがバージョンCMP1999メッセージを受信した場合、RFC 2510の動作に戻り、バージョンCMP1999メッセージで応答する場合があります。そうすることを選択しない場合は、上記のセクション7で説明したように、ErrormSgContentを送り返す必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Proof-Of-Possession with a Decryption Key",
      "section_title": true,
      "ja": "8.1. 復号化キーを使用した所有の証明"
    },
    {
      "indent": 3,
      "text": "Some cryptographic considerations are worth explicitly spelling out. In the protocols specified above, when an end entity is required to prove possession of a decryption key, it is effectively challenged to decrypt something (its own certificate). This scheme (and many others!) could be vulnerable to an attack if the possessor of the decryption key in question could be fooled into decrypting an arbitrary challenge and returning the cleartext to an attacker. Although in this specification a number of other failures in security are required in order for this attack to succeed, it is conceivable that some future services (e.g., notary, trusted time) could potentially be vulnerable to such attacks. For this reason, we re-iterate the general rule that implementations should be very careful about decrypting arbitrary \"ciphertext\" and revealing recovered \"plaintext\" since such a practice can lead to serious security vulnerabilities.",
      "ja": "いくつかの暗号化の考慮事項は、明示的に綴る価値があります。上記のプロトコルでは、復号化キーの所有を証明するために終了エンティティが必要な場合、何か（独自の証明書）を復号化することは事実上挑戦します。このスキーム（および他の多くのもの！）は、問題の復号化キーの所有者が任意の課題を解読し、攻撃者にクリアテキストを返すことにだまされる可能性がある場合、攻撃に対して脆弱になる可能性があります。この仕様では、この攻撃が成功するためにはセキュリティの他の多くの失敗が必要ですが、将来のサービス（例えば、公証人、信頼できる時間など）がそのような攻撃に対して脆弱である可能性があると考えられます。このため、このようなプラクティスは深刻なセキュリティの脆弱性につながる可能性があるため、任意の「暗号文」を復号化し、回復した「プレーンテキスト」を明らかにすることには、実装が非常に注意する必要があるという一般的なルールを繰り返します。"
    },
    {
      "indent": 0,
      "text": "8.2. Proof-Of-Possession by Exposing the Private Key",
      "section_title": true,
      "ja": "8.2. 秘密鍵を公開することによる所有証明"
    },
    {
      "indent": 3,
      "text": "Note also that exposing a private key to the CA/RA as a proof-of-possession technique can carry some security risks (depending upon whether or not the CA/RA can be trusted to handle such material appropriately). Implementers are advised to:",
      "ja": "また、CA/RAに秘密鍵を所有の証明技術として公開すると、いくつかのセキュリティリスクが発生する可能性があることに注意してください（CA/RAがそのような資料を適切に処理すると信頼できるかどうかに応じて）。実装者には次のようにアドバイスされています。"
    },
    {
      "indent": 6,
      "text": "Exercise caution in selecting and using this particular POP mechanism",
      "ja": "この特定のポップメカニズムの選択と使用に注意を払う"
    },
    {
      "indent": 6,
      "text": "When appropriate, have the user of the application explicitly state that they are willing to trust the CA/RA to have a copy of their private key before proceeding to reveal the private key.",
      "ja": "必要に応じて、アプリケーションのユーザーに、秘密鍵を明らかにするために進む前に、CA/RAが秘密鍵のコピーを持っていると信頼することをいとわないことを明示的に述べてください。"
    },
    {
      "indent": 0,
      "text": "8.3. Attack Against Diffie-Hellman Key Exchange",
      "section_title": true,
      "ja": "8.3. Diffie-Hellman Key Exchangeに対する攻撃"
    },
    {
      "indent": 3,
      "text": "A small subgroup attack during a Diffie-Hellman key exchange may be carried out as follows. A malicious end entity may deliberately choose D-H parameters that enable him/her to derive (a significant number of bits of) the D-H private key of the CA during a key archival or key recovery operation. Armed with this knowledge, the EE would then be able to retrieve the decryption private key of another unsuspecting end entity, EE2, during EE2's legitimate key archival or key recovery operation with that CA. In order to avoid the possibility of such an attack, two courses of action are available. (1) The CA may generate a fresh D-H key pair to be used as a protocol encryption key pair for each EE with which it",
      "ja": "Diffie-Hellmanキー交換中の小さなサブグループ攻撃は、次のように実行できます。悪意のある最終エンティティは、キーアーカイブまたはキーリカバリ操作中にCAのD-H秘密鍵を（かなりの数のビット）導き出すことができるD-Hパラメーターを意図的に選択できます。この知識で武装して、EEは、EE2の合法的なキーアーカイブまたはキーリカバリ操作中に、疑いを持たないエンティティEE2の復号化の秘密鍵を取得できるようになります。このような攻撃の可能性を回避するために、2つのアクションコースが利用可能です。（1）CAは、それぞれのEEのプロトコル暗号化キーペアとして使用する新しいD-Hキーペアを生成する場合があります"
    },
    {
      "indent": 3,
      "text": "interacts. (2) The CA may enter into a key validation protocol (not specified in this document) with each requesting end entity to ensure that the EE's protocol encryption key pair will not facilitate this attack. Option (1) is clearly simpler (requiring no extra protocol exchanges from either party) and is therefore RECOMMENDED.",
      "ja": "相互作用します。（2）CAは、EEのプロトコル暗号化キーペアがこの攻撃を容易にしないようにするために、各エンティティを要求する各要求エンティティを使用して、キー検証プロトコル（このドキュメントで指定されていない）を入力することができます。オプション（1）は明らかに単純で（どちらの当事者からの追加のプロトコル交換を必要としない）ため、推奨されます。"
    },
    {
      "indent": 0,
      "text": "9. IANA Considerations",
      "section_title": true,
      "ja": "9. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "The PKI General Message types are identified by object identifiers (OIDs). The OIDs for the PKI General Message types defined in this document were assigned from an arc delegated by the IANA to the PKIX Working Group.",
      "ja": "PKI一般的なメッセージタイプは、オブジェクト識別子（OID）によって識別されます。このドキュメントで定義されているPKI一般メッセージタイプのOIDは、IANAからPKIXワーキンググループに委任されたアークから割り当てられました。"
    },
    {
      "indent": 3,
      "text": "The cryptographic algorithms referred to in this document are identified by object identifiers (OIDs). The OIDs for cryptographic algorithms were assigned from several arcs owned by various organizations, including RSA Security, Entrust Technologies, IANA and IETF.",
      "ja": "このドキュメントで言及されている暗号化アルゴリズムは、オブジェクト識別子（OID）によって識別されます。暗号化アルゴリズムのOIDは、RSA Security、Antrust Technologies、IANA、IETFなど、さまざまな組織が所有するいくつかのアークから割り当てられました。"
    },
    {
      "indent": 3,
      "text": "Should additional encryption algorithms be introduced, the advocates for such algorithms are expected to assign the necessary OIDs from their own arcs.",
      "ja": "追加の暗号化アルゴリズムが導入された場合、そのようなアルゴリズムの支持者は、独自のアークから必要なOIDを割り当てることが期待されます。"
    },
    {
      "indent": 3,
      "text": "No further action by the IANA is necessary for this document or any anticipated updates.",
      "ja": "このドキュメントまたは予想される更新には、IANAによるさらなるアクションは必要ありません。"
    },
    {
      "indent": 0,
      "text": "Normative References",
      "ja": "引用文献"
    },
    {
      "indent": 3,
      "text": "[X509] International Organization for Standardization and International Telecommunications Union, \"Information technology - Open Systems Interconnection - The Directory: Public-key and attribute certificate frameworks\", ISO Standard 9594-8:2001, ITU-T Recommendation X.509, March 2000.",
      "ja": "[X509]国際標準化および国際電気通信組合の組織、「情報技術 - オープンシステムの相互接続 - ディレクトリ：パブリックキーおよび属性証明書フレームワーク」、ISO標準9594-8：2001、ITU-T推奨X.509、2000年3月。"
    },
    {
      "indent": 3,
      "text": "[MvOV97] Menezes, A., van Oorschot, P. and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press ISBN 0-8493-8523-7, 1996.",
      "ja": "[MVOV97] Menezes、A.、Van Oorschot、P。、およびS. Vanstone、「適用された暗号化のハンドブック」、CRC Press ISBN 0-8493-8523-7、1996。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. CaNetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2202] Cheng, P. and R. Glenn, \"Test Cases for HMAC-MD5 and HMAC-SHA-1\", RFC 2202, September 1997.",
      "ja": "[RFC2202] Cheng、P。およびR. Glenn、「HMAC-MD5およびHMAC-SHA-1のテストケース」、RFC 2202、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2482] Whistler, K. and G. Adams, \"Language Tagging in Unicode Plain Text\", RFC 2482, January 1999.",
      "ja": "[RFC2482] Whistler、K。およびG. Adams、「Unicode Plain Textでの言語タグ付け」、RFC 2482、1999年1月。"
    },
    {
      "indent": 3,
      "text": "[CRMF] Schaad, J., \"Internet X.509 Public Key Infrastructure Certificate Request Message Format (CRMF)\", RFC 4211, September 2005.",
      "ja": "[CRMF] Schaad、J。、「インターネットX.509公開キーインフラストラクチャ証明書リクエストメッセージフォーマット（CRMF）」、RFC 4211、2005年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3066] Alvestrand, H., \"Tags for the Identification of Languages\", BCP 47, RFC 3066, January 2001.",
      "ja": "[RFC3066] Alvestrand、H。、「言語の識別のためのタグ」、BCP 47、RFC 3066、2001年1月。"
    },
    {
      "indent": 0,
      "text": "Informative References",
      "ja": "参考引用"
    },
    {
      "indent": 3,
      "text": "[CMPtrans] Kapoor, A., Tschalar, R. and T. Kause, \"Internet X.509 Public Key Infrastructure -- Transport Protocols for CMP\", Work in Progress. 2004.",
      "ja": "[cmptrans] Kapoor、A.、Tschalar、R。and T. Kause、「インターネットX.509公開キーインフラストラクチャ -  CMPの輸送プロトコル」、進行中の作業。2004年。"
    },
    {
      "indent": 3,
      "text": "[PKCS7] RSA Laboratories, \"The Public-Key Cryptography Standards - Cryptographic Message Syntax Standard. Version 1.5\", PKCS 7, November 1993.",
      "ja": "[PKCS7] RSA Laboratories、「パブリックキー暗号化基準 - 暗号化メッセージ構文標準。バージョン1.5」、PKCS 7、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[PKCS10] Nystrom, M., and B. Kaliski, \"The Public-Key Cryptography Standards - Certification Request Syntax Standard, Version 1.7\", RFC 2986, May 2000.",
      "ja": "[PKCS10] Nystrom、M。、およびB. Kaliski、「パブリックキー暗号化基準 - 認証要求構文標準、バージョン1.7」、RFC 2986、2000年5月。"
    },
    {
      "indent": 3,
      "text": "[PKCS11] RSA Laboratories, \"The Public-Key Cryptography Standards - Cryptographic Token Interface Standard. Version 2.10\", PKCS 11, December 1999.",
      "ja": "[PKCS11] RSA Laboratories、「パブリックキー暗号化基準 - 暗号化トークンインターフェイス標準。バージョン2.10」、PKCS 11、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC1847] Galvin, J., Murphy, S., Crocker, S., and N. Freed, \"Security Multiparts for MIME: Multipart/Signed and Multipart/Encrypted\", RFC 1847, October 1995.",
      "ja": "[RFC1847] Galvin、J.、Murphy、S.、Crocker、S。、およびN. Freed、「Mimeのセキュリティマルチパート：MultiPart/SignedおよびMultiPart/暗号化」、1995年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2559] Boeyen, S., Howes, T. and P. Richard, \"Internet X.509 Public Key Infrastructure Operational Protocols - LDAPv2\", RFC 2559, April 1999.",
      "ja": "[RFC2559] Boeyen、S.、Howes、T。およびP. Richard、「Internet X.509公開キーインフラストラクチャオペレーショナルプロトコル-LDAPV2」、RFC 2559、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2585] Housley, R. and P. Hoffman, \"Internet X.509 Public Key Infrastructure Operational Protocols: FTP and HTTP\", RFC 2585, May 1999.",
      "ja": "[RFC2585] Housley、R。およびP. Hoffman、「インターネットX.509公開キーインフラストラクチャ運用プロトコル：FTPおよびHTTP」、RFC 2585、1999年5月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-180] National Institute of Standards and Technology, \"Secure Hash Standard\", FIPS PUB 180-1, May 1994.",
      "ja": "[FIPS-180]国立標準技術研究所、「Secure Hash Standard」、FIPS Pub 180-1、1994年5月。"
    },
    {
      "indent": 3,
      "text": "[FIPS-186] National Institute of Standards and Technology, \"Digital Signature Standard\", FIPS PUB 186, May 1994.",
      "ja": "[FIPS-186]国立標準技術研究所、「デジタル署名標準」、FIPS Pub 186、1994年5月。"
    },
    {
      "indent": 3,
      "text": "[ANSI-X9.42] American National Standards Institute, \"Public Key Cryptography for The Financial Services Industry: Agreement of Symmetric Keys Using Discrete Logarithm Cryptography\", ANSI X9.42, February 2000.",
      "ja": "[ANSI-X9.42] American National Standards Institute、「金融サービス業界向けの公開鍵暗号：離散対数暗号化を使用した対称キーの合意」、ANSI X9.42、2000年2月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Reasons for the Presence of RAs",
      "section_title": true,
      "ja": "付録A. RASの存在の理由"
    },
    {
      "indent": 3,
      "text": "The reasons that justify the presence of an RA can be split into those that are due to technical factors and those which are organizational in nature. Technical reasons include the following.",
      "ja": "RAの存在を正当化する理由は、技術的要因と本質的に組織的な要因によるものに分割される可能性があります。技術的な理由には、以下が含まれます。"
    },
    {
      "indent": 3,
      "text": "o If hardware tokens are in use, then not all end entities will have the equipment needed to initialize these; the RA equipment can include the necessary functionality (this may also be a matter of policy).",
      "ja": "o ハードウェアトークンが使用されている場合、すべてのエンティティがこれらを初期化するために必要な機器を持っているわけではありません。RA機器には、必要な機能を含めることができます（これはポリシーの問題でもあります）。"
    },
    {
      "indent": 3,
      "text": "o Some end entities may not have the capability to publish certificates; again, the RA may be suitably placed for this.",
      "ja": "o 一部のエンティティには、証明書を公開する機能がない場合があります。繰り返しますが、RAはこれに適した場所に配置される可能性があります。"
    },
    {
      "indent": 3,
      "text": "o The RA will be able to issue signed revocation requests on behalf of end entities associated with it, whereas the end entity may not be able to do this (if the key pair is completely lost).",
      "ja": "o RAは、それに関連するエンディティに代わって署名された失効リクエストを発行することができますが、最終エンティティはこれを行うことができない場合があります（キーペアが完全に失われた場合）。"
    },
    {
      "indent": 3,
      "text": "Some of the organizational reasons that argue for the presence of an RA are the following.",
      "ja": "RAの存在を主張する組織の理由のいくつかは、次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o It may be more cost effective to concentrate functionality in the RA equipment than to supply functionality to all end entities (especially if special token initialization equipment is to be used).",
      "ja": "o すべての最終エンティティに機能を供給するよりも、RA機器に機能を集中させる方が費用対効果が高い場合があります（特に特別なトークン初期化機器を使用する場合）。"
    },
    {
      "indent": 3,
      "text": "o Establishing RAs within an organization can reduce the number of CAs required, which is sometimes desirable.",
      "ja": "o 組織内でRASを確立すると、必要なCAの数を減らすことができますが、これは望ましいこともあります。"
    },
    {
      "indent": 3,
      "text": "o RAs may be better placed to identify people with their \"electronic\" names, especially if the CA is physically remote from the end entity.",
      "ja": "o RAは、特にCAが最終エンティティから物理的にリモートである場合、「電子」名を持つ人々を識別するために配置される可能性があります。"
    },
    {
      "indent": 3,
      "text": "o For many applications, there will already be in place some administrative structure so that candidates for the role of RA are easy to find (which may not be true of the CA).",
      "ja": "o 多くのアプリケーションでは、RAの役割の候補者が簡単に見つけることができるように、すでにいくつかの管理構造が整っています（CAには当てはまらないかもしれません）。"
    },
    {
      "indent": 0,
      "text": "Appendix B. The Use of Revocation Passphrase",
      "section_title": true,
      "ja": "付録B. 取り消しパスフレーズの使用"
    },
    {
      "indent": 3,
      "text": "A revocation request must incorporate suitable security mechanisms, including proper authentication, in order to reduce the probability of successful denial-of-service attacks. A digital signature on the request -- MANDATORY to support within this specification if revocation requests are supported -- can provide the authentication required, but there are circumstances under which an alternative mechanism may be desirable (e.g., when the private key is no longer accessible and the entity wishes to request a revocation prior to re-certification of another key pair). In order to accommodate such circumstances, a PasswordBasedMAC on the request is also MANDATORY to support within this specification (subject to local security policy for a given environment) if revocation requests are supported and if shared secret information can be established between the requester and the responder prior to the need for revocation.",
      "ja": "取り消し要求には、サービス拒否攻撃を成功させる確率を減らすために、適切な認証を含む適切なセキュリティメカニズムを組み込む必要があります。リクエストのデジタル署名 - 取り消しリクエストがサポートされている場合にこの仕様内でサポートするために必須 - 必要な認証を提供できますが、代替メカニズムが望ましい状況があります（たとえば、秘密鍵にアクセスできない場合そして、エンティティは、別の重要なペアの再認証の前に取り消しを要求したいと考えています）。そのような状況に対応するために、取り消しリクエストがサポートされている場合、およびリクエスターとレスポンダーの間で共有秘密情報を確立できる場合、この仕様内（特定の環境のローカルセキュリティポリシーの対象となる）内でサポートするために、リクエストのパスワードベースMACも必須です。取り消しの必要性の前。"
    },
    {
      "indent": 3,
      "text": "A mechanism that has seen use in some environments is \"revocation passphrase\", in which a value of sufficient entropy (i.e., a relatively long passphrase rather than a short password) is shared between (only) the entity and the CA/RA at some point prior to revocation; this value is later used to authenticate the revocation request.",
      "ja": "一部の環境で使用されているメカニズムは「取消パスフレーズ」です。このメカニズムでは、十分なエントロピーの値（つまり、短いパスワードではなく比較的長いパスフレーズ）が共有されます（エンティティとCA/RAの間で共有されます。取り消し前のポイント。この値は、後で取り消し要求を認証するために使用されます。"
    },
    {
      "indent": 3,
      "text": "In this specification, the following technique to establish shared secret information (i.e., a revocation passphrase) is OPTIONAL to support. Its precise use in CMP messages is as follows.",
      "ja": "この仕様では、共有された秘密情報（つまり、取り消しパスフレーズ）を確立するための次の手法がオプションをサポートするためにオプションです。CMPメッセージでのその正確な使用は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o The OID and value specified in Section 5.3.19.9 MAY be sent in a GenMsg message at any time, or MAY be sent in the generalInfo field of the PKIHeader of any PKIMessage at any time. (In particular, the EncryptedValue may be sent in the header of the certConf message that confirms acceptance of certificates requested in an initialization request or certificate request message.) This conveys a revocation passphrase chosen by the entity (i.e., the decrypted bytes of the encValue field) to the relevant CA/RA; furthermore, the transfer is accomplished with appropriate confidentiality characteristics (because the passphrase is encrypted under the CA/RA's protocolEncryptionKey).",
      "ja": "o セクション5.3.19.9で指定されているOIDと値は、いつでもGENMSGメッセージで送信されるか、いつでもpkimessageのpkiheaderの一般的なフィールドで送信される場合があります。（特に、暗号化されたバリューは、初期化要求または証明書リクエストメッセージで要求された証明書の受け入れを確認するCERTCONFメッセージのヘッダーに送信される場合があります。）これは、エンティティによって選択された取り消しパスフレーズを伝えます（すなわち、エンセバルの飾られたバイトを伝えます。フィールド）関連するCa/Raへ。さらに、転送は適切な機密性の特性で達成されます（パスフレーズはCA/RAのProtocolencryptionKeyで暗号化されているため）。"
    },
    {
      "indent": 3,
      "text": "o If a CA/RA receives the revocation passphrase (OID and value specified in Section 5.3.19.9) in a GenMsg, it MUST construct and send a GenRep message that includes the OID (with absent value) specified in Section 5.3.19.9. If the CA/RA receives the revocation passphrase in the generalInfo field of a PKIHeader of any PKIMessage, it MUST include the OID (with absent value) in the generalInfo field of the PKIHeader of the corresponding response PKIMessage. If the CA/RA is unable to return the appropriate response message for any reason, it MUST send an error message with a status of \"rejection\" and, optionally, a failInfo reason set.",
      "ja": "o CA/RAがGENMSGでCA/RAが取り消しパスフレーズ（OIDおよび値5.3.19.9で指定されている値）を受信した場合、セクション5.3.19.9で指定されているOID（存在しない値を持つ）を含むGenRepメッセージを構築および送信する必要があります。CA/RAが、pkimessageのpkiheaderのGeneralInfoフィールドで取り消しパスフレーズを受信した場合、対応する応答pkimessageのpkiheaderのGeneralInfoフィールドにoid（価値がない）を含める必要があります。CA/RAが何らかの理由で適切な応答メッセージを返すことができない場合、「拒否」のステータス、およびオプションではfailinfo理由セットのエラーメッセージを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "o The valueHint field of EncryptedValue MAY contain a key identifier (chosen by the entity, along with the passphrase itself) to assist in later retrieval of the correct passphrase (e.g., when the revocation request is constructed by the entity and received by the CA/RA).",
      "ja": "o 暗号化されたバリューのバリューヒントフィールドには、正しいパスフレーズの後の検索を支援するために、キー識別子（パスフレーズ自体とともにエンティティによって選択された）を含めることができます（例えば、エンティティによって取り消し要求が構築され、CA/RAが受信した場合）。"
    },
    {
      "indent": 3,
      "text": "o The revocation request message is protected by a PasswordBasedMAC, with the revocation passphrase as the key. If appropriate, the senderKID field in the PKIHeader MAY contain the value previously transmitted in valueHint.",
      "ja": "o 取り消しリクエストメッセージは、パスワードベースのMACによって保護されており、取り消しパスフレーズがキーになります。必要に応じて、PKIHeaderのSenderKidフィールドには、以前にValueHintで送信された値が含まれている場合があります。"
    },
    {
      "indent": 3,
      "text": "Using the technique specified above, the revocation passphrase may be initially established and updated at any time without requiring extra messages or out-of-band exchanges. For example, the revocation request message itself (protected and authenticated through a MAC that uses the revocation passphrase as a key) may contain, in the PKIHeader, a new revocation passphrase to be used for authenticating future revocation requests for any of the entity's other certificates. In some environments this may be preferable to mechanisms that reveal the passphrase in the revocation request message, since this can allow a denial-of-service attack in which the revealed passphrase is used by an unauthorized third party to authenticate revocation requests on the entity's other certificates. However, because the passphrase is not revealed in the request message, there is no requirement that the passphrase must always be updated when a revocation request is made (that is, the same passphrase MAY be used by an entity to authenticate revocation requests for different certificates at different times).",
      "ja": "上記で指定された手法を使用すると、取り消しパスフレーズは、追加のメッセージや帯域外の交換を必要とせずに、いつでもいつでも確立および更新できます。たとえば、取り消しリクエストメッセージ自体（失効パスフレーズをキーとして使用するMACを介して保護および認証された）には、PKIHeaderに、エンティティの他の証明書の将来の取り消し要求を認証するために使用される新しい取り消しパスフレーズが含まれている場合があります。。一部の環境では、これは取り消し要求メッセージのパスフレーズを明らかにするメカニズムよりも好ましい場合があります。これにより、公開されたパスフレーズが不正な第三者によって使用されるサービス拒否攻撃が可能になり、エンティティの他のエンティティのリクエストを認証することができます。証明書。ただし、パスフレーズはリクエストメッセージで明らかにされていないため、失効リクエストが行われたときにパスフレーズを常に更新する必要はありません（つまり、エンティティが異なる証明書の撤回要求を認証するために同じパスフレーズを使用することができますさまざまな時）。"
    },
    {
      "indent": 3,
      "text": "Furthermore, the above technique can provide strong cryptographic protection over the entire revocation request message even when a digital signature is not used. Techniques that do authentication of the revocation request by simply revealing the revocation passphrase typically do not provide cryptographic protection over the fields of the request message (so that a request for revocation of one certificate may be modified by an unauthorized third party to a request for revocation of another certificate for that entity).",
      "ja": "さらに、上記の手法は、デジタル署名が使用されていない場合でも、取り消し要求メッセージ全体で強力な暗号化保護を提供できます。取り消しパスフレーズを明らかにするだけで取り消し要求を認証する手法は、通常、要求メッセージのフィールドに暗号化保護を提供しません（そのためそのエンティティの別の証明書の）。"
    },
    {
      "indent": 0,
      "text": "Appendix C. Request Message Behavioral Clarifications",
      "section_title": true,
      "ja": "付録C. メッセージの動作の明確化を要求します"
    },
    {
      "indent": 3,
      "text": "In the case of updates to [CRMF], which cause interpretation or interoperability issues, [CRMF] SHALL be the normative document.",
      "ja": "[CRMF]の更新の場合、解釈または相互運用性の問題を引き起こす場合、[CRMF]は規範的な文書とする。"
    },
    {
      "indent": 3,
      "text": "The following definitions are from [CRMF]. They are included here in order to codify behavioral clarifications to that request message; otherwise, all syntax and semantics are identical to [CRMF].",
      "ja": "次の定義は[CRMF]からのものです。これらは、その要求メッセージに対して行動の明確化を成文化するためにここに含まれています。それ以外の場合、すべての構文とセマンティクスは[CRMF]と同一です。"
    },
    {
      "indent": 3,
      "text": "CertRequest ::= SEQUENCE {\n    certReqId     INTEGER,\n    certTemplate  CertTemplate,\n    controls      Controls OPTIONAL }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- If certTemplate is an empty SEQUENCE (i.e., all fields\n-- omitted), then controls MAY contain the",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- id-regCtrl-altCertTemplate control, specifying a template\n-- for a certificate other than an X.509v3 public-key\n-- certificate.  Conversely, if certTemplate is not empty\n-- (i.e., at least one field is present), then controls MUST\n-- NOT contain id-regCtrl- altCertTemplate.  The new control is\n-- defined as follows:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "id-regCtrl-altCertTemplate OBJECT IDENTIFIER ::= {id-regCtrl 7}\nAltCertTemplate ::= AttributeTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "POPOSigningKey ::= SEQUENCE {\n    poposkInput           [0] POPOSigningKeyInput OPTIONAL,\n    algorithmIdentifier   AlgorithmIdentifier,\n    signature             BIT STRING }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- **********\n-- * For the purposes of this specification, the ASN.1 comment\n-- * given in [CRMF] pertains not only to certTemplate, but\n-- * also to the altCertTemplate control.  That is,\n-- **********\n-- * The signature (using \"algorithmIdentifier\") is on the\n-- * DER-encoded value of poposkInput (i.e., the \"value\" OCTETs\n-- * of the POPOSigningKeyInput DER).  NOTE: If CertReqMsg\n-- * certReq certTemplate (or the altCertTemplate control)\n-- * contains the subject and publicKey values, then poposkInput\n-- * MUST be omitted and the signature MUST be computed on the\n-- * DER-encoded value of CertReqMsg certReq (or the DER-\n-- * encoded value of AltCertTemplate).  If\n-- * certTemplate/altCertTemplate does not contain both the\n-- * subject and public key values (i.e., if it contains only\n-- * one of these, or neither), then poposkInput MUST be present\n-- * and MUST be signed.\n-- **********",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "POPOPrivKey ::= CHOICE {\n    thisMessage       [0] BIT STRING,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- **********\n-- * the type of \"thisMessage\" is given as BIT STRING in\n-- * [CRMF]; it should be \"EncryptedValue\" (in accordance\n-- * with Section 5.2.2, \"Encrypted Values\", of this specification).\n-- * Therefore, this document makes the behavioral clarification\n-- * of specifying that the contents of \"thisMessage\" MUST be encoded\n-- * as an EncryptedValue and then wrapped in a BIT STRING.  This\n-- * allows the necessary conveyance and protection of the\n-- * private key while maintaining bits-on-the-wire compatibility\n-- * with [CRMF].\n-- **********",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "subsequentMessage [1] SubsequentMessage, dhMAC [2] BIT STRING }",
      "ja": "sundyentmessage [1] sund shanksmessage、dhmac [2] bit string}"
    },
    {
      "indent": 0,
      "text": "Appendix D. PKI Management Message Profiles (REQUIRED).",
      "ja": "付録D. PKI管理メッセージプロファイル（必須）。"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MUST be supported by conforming implementations (see Section 6).",
      "ja": "この付録には、実装を適合させることでサポートする必要があるこれらのpkimessageの詳細なプロファイルが含まれています（セクション6を参照）。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "次のPKI管理操作で使用されるPKIMESSAGEのプロファイルが提供されます。"
    },
    {
      "indent": 3,
      "text": "o initial registration/certification",
      "ja": "o 初期登録/認定"
    },
    {
      "indent": 3,
      "text": "o basic authenticated scheme",
      "ja": "o 基本的な認証されたスキーム"
    },
    {
      "indent": 3,
      "text": "o certificate request",
      "ja": "o 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "o key update",
      "ja": "o キーアップデート"
    },
    {
      "indent": 0,
      "text": "D.1. General Rules for Interpretation of These Profiles.",
      "ja": "D.1. これらのプロファイルの解釈に関する一般的なルール。"
    },
    {
      "indent": 3,
      "text": "1. Where OPTIONAL or DEFAULT fields are not mentioned in individual profiles, they SHOULD be absent from the relevant message (i.e., a receiver can validly reject a message containing such fields as being syntactically incorrect). Mandatory fields are not mentioned if they have an obvious value (e.g., in this version of the specification, pvno is always 2).",
      "ja": "1. オプションまたはデフォルトのフィールドが個々のプロファイルで言及されていない場合、関連するメッセージに存在しないはずです（つまり、受信者は、このフィールドを含むメッセージを構文的に間違っていることを有効に拒否できます）。必須フィールドには明らかな値がある場合は言及されていません（たとえば、このバージョンの仕様では、PVNOは常に2です）。"
    },
    {
      "indent": 3,
      "text": "2. Where structures occur in more than one message, they are separately profiled as appropriate.",
      "ja": "2. 構造が複数のメッセージで発生する場合、必要に応じて個別にプロファイルされます。"
    },
    {
      "indent": 3,
      "text": "3. The algorithmIdentifiers from PKIMessage structures are profiled separately.",
      "ja": "3. pkimessage構造からのアルゴリズムのdididifiersは、個別にプロファイルされています。"
    },
    {
      "indent": 3,
      "text": "4. A \"special\" X.500 DN is called the \"NULL-DN\"; this means a DN containing a zero-length SEQUENCE OF RelativeDistinguishedNames (its DER encoding is then '3000'H).",
      "ja": "4. 「特別な」X.500 DNは「null-dn」と呼ばれます。これは、relativedististinguednamesのゼロ長シーケンスを含むDN（そのderエンコードは '3000'h）を意味します。"
    },
    {
      "indent": 3,
      "text": "5. Where a GeneralName is required for a field, but no suitable value is available (e.g., an end entity produces a request before knowing its name), then the GeneralName is to be an X.500 NULL-DN (i.e., the Name field of the CHOICE is to contain a NULL-DN). This special value can be called a \"NULL-GeneralName\".",
      "ja": "5. フィールドには一般名が必要ですが、適切な値が利用できない場合（たとえば、エンディティはその名前を知る前にリクエストを生成します）、一般名はx.500 null-dn（すなわち、の名前フィールドのフィールドであることです。選択は、null-dnを含めることです）。この特別な値は、「null-generalname」と呼ぶことができます。"
    },
    {
      "indent": 3,
      "text": "6. Where a profile omits to specify the value for a GeneralName, then the NULL-GeneralName value is to be present in the relevant PKIMessage field. This occurs with the sender field of the PKIHeader for some messages.",
      "ja": "6. プロファイルが省略して一般名の値を指定する場合、null-generalName値は、関連するpkimessageフィールドに存在します。これは、一部のメッセージに対してPKIHeaderの送信者フィールドで発生します。"
    },
    {
      "indent": 3,
      "text": "7. Where any ambiguity arises due to naming of fields, the profile names these using a \"dot\" notation (e.g., \"certTemplate.subject\" means the subject field within a field called certTemplate).",
      "ja": "7. フィールドの命名によりあいまいさが発生する場合、プロファイルは「ドット」表記（「certtemplate.subject」などを使用してこれらに名前を付けます。"
    },
    {
      "indent": 3,
      "text": "8. Where a \"SEQUENCE OF types\" is part of a message, a zero-based array notation is used to describe fields within the SEQUENCE OF (e.g., crm[0].certReq.certTemplate.subject refers to a subfield of the first CertReqMsg contained in a request message).",
      "ja": "8. 「タイプのシーケンス」がメッセージの一部である場合、ゼロベースの配列表記を使用して、一連のシーケンス内のフィールドを記述します（例えば、CRM [0] .Certreq.CertTemplate.Subjectは、含まれる最初のCertreQMSGのサブフィールドを指します。リクエストメッセージで）。"
    },
    {
      "indent": 3,
      "text": "9. All PKI message exchanges in Appendix D.4 to D.6 require a certConf message to be sent by the initiating entity and a PKIConfirm to be sent by the responding entity. The PKIConfirm is not included in some of the profiles given since its body is NULL and its header contents are clear from the context. Any authenticated means can be used for the protectionAlg (e.g., password-based MAC, if shared secret information is known, or signature).",
      "ja": "9. 付録D.4からD.6のすべてのPKIメッセージ交換では、開始エンティティから送信されるCERTCONFメッセージと、応答エンティティによって送信されるPKICONFIRMが必要です。Pkiconfirmは、その体がヌルであり、そのヘッダーの内容がコンテキストから明確であるため、与えられたいくつかのプロファイルには含まれていません。認証された手段は、保護物に使用できます（たとえば、共有された秘密情報がわかっている場合、または署名）。"
    },
    {
      "indent": 0,
      "text": "D.2. Algorithm Use Profile",
      "section_title": true,
      "ja": "D.2. アルゴリズムはプロファイルを使用します"
    },
    {
      "indent": 3,
      "text": "The following table contains definitions of algorithm uses within PKI management protocols. The columns in the table are:",
      "ja": "次の表には、PKI管理プロトコル内のアルゴリズムの使用の定義が含まれています。テーブルの列は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Name: an identifier used for message profiles",
      "ja": "名前：メッセージプロファイルに使用される識別子"
    },
    {
      "indent": 3,
      "text": "Use: description of where and for what the algorithm is used",
      "ja": "使用：アルゴリズムが使用される場所の説明"
    },
    {
      "indent": 3,
      "text": "Mandatory: an AlgorithmIdentifier which MUST be supported by conforming implementations",
      "ja": "必須：実装の適合によってサポートする必要があるアルゴリズムIdentidifier"
    },
    {
      "indent": 3,
      "text": "Others: alternatives to the mandatory AlgorithmIdentifier",
      "ja": "その他：必須のアルゴリズムIdentifierの代替"
    },
    {
      "indent": 4,
      "text": "Name Use Mandatory Others",
      "ja": "名前を使用して、必須の他の人を使用します"
    },
    {
      "indent": 4,
      "text": "MSG_SIG_ALG  Protection of PKI        DSA/SHA-1        RSA/MD5,\n             messages using signature                  ECDSA, ...\nMSG_MAC_ALG  protection of PKI        PasswordBasedMac HMAC,\n             messages using MACing                     X9.9...\nSYM_PENC_ALG symmetric encryption of  3-DES (3-key-    AES,RC5,\n             an end entity's private  EDE, CBC mode)   CAST-128...\n             key where symmetric\n             key is distributed\n             out-of-band\nPROT_ENC_ALG asymmetric algorithm     D-H              RSA,\n             used for encryption of                    ECDH, ...\n             (symmetric keys for\n             encryption of) private\n             keys transported in\n                 PKIMessages\nPROT_SYM_ALG symmetric encryption     3-DES (3-key-    AES,RC5,\n             algorithm used for       EDE, CBC mode)   CAST-128...\n             encryption of private\n             key bits (a key of this\n             type is encrypted using\n             PROT_ENC_ALG)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mandatory AlgorithmIdentifiers and Specifications:",
      "ja": "必須のアルゴリズム科学者と仕様："
    },
    {
      "indent": 3,
      "text": "DSA/SHA-1:\n  AlgId: {1 2 840 10040 4 3};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Digital Signature Standard [FIPS-186]",
      "ja": "デジタル署名標準[FIPS-186]"
    },
    {
      "indent": 5,
      "text": "Public Modulus size: 1024 bits.",
      "ja": "パブリックモジュラスサイズ：1024ビット。"
    },
    {
      "indent": 3,
      "text": "PasswordBasedMac:",
      "ja": "PasswordBasedMac："
    },
    {
      "indent": 5,
      "text": "AlgId: {1 2 840 113533 7 66 13}, with SHA-1 {1 3 14 3 2 26} as the\n       owf parameter and HMAC-SHA1 {1 3 6 1 5 5 8 1 2} as the mac\n       parameter;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "(this specification), along with",
      "ja": "（この仕様）、一緒に"
    },
    {
      "indent": 3,
      "text": "Secure Hash Standard [FIPS-180] and [RFC2104]",
      "ja": "安全なハッシュ標準[FIPS-180]および[RFC2104]"
    },
    {
      "indent": 5,
      "text": "HMAC key size: 160 bits (i.e., \"K\" = \"H\" in Section 5.1.3.1, \"Shared secret information\")",
      "ja": "HMACキーサイズ：160ビット（つまり、セクション5.1.3.1の \"k\" = \"h\"、 \"共有秘密情報\"））"
    },
    {
      "indent": 3,
      "text": "3-DES:",
      "ja": "3-DES："
    },
    {
      "indent": 5,
      "text": "AlgId: {1 2 840 113549 3 7}; (used in RSA's BSAFE and in S/MIME).",
      "ja": "アルギッド：{1 2 840 113549 3 7};（RSAのBSAFEおよびS/MIMEで使用）。"
    },
    {
      "indent": 3,
      "text": "D-H:",
      "ja": "D-H："
    },
    {
      "indent": 5,
      "text": "AlgId:  {1 2 840 10046 2 1};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "[ANSI-X9.42]",
      "ja": "[ANSI-X9.42]"
    },
    {
      "indent": 5,
      "text": "Public Modulus Size:  1024 bits.\nDomainParameters ::= SEQUENCE {\n   p       INTEGER, -- odd prime, p=jq +1\n   g       INTEGER, -- generator, g^q = 1 mod p\n   q       INTEGER, -- prime factor of p-1\n   j       INTEGER OPTIONAL, -- cofactor, j>=2\n   validationParms  ValidationParms OPTIONAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "}\nValidationParms ::= SEQUENCE {\n   seed          BIT STRING, -- seed for prime generation\n   pGenCounter   INTEGER     -- parameter verification\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D.3. Proof-of-Possession Profile",
      "section_title": true,
      "ja": "D.3. プルーフオブポッセッションプロファイル"
    },
    {
      "indent": 3,
      "text": "POP fields for use (in signature field of pop field of ProofOfPossession structure) when proving possession of a private signing key that corresponds to a public verification key for which a certificate has been requested.",
      "ja": "使用するためのポップフィールド（Proofpossession構造のポップフィールドの署名フィールドで）証明書が要求された公開検証キーに対応するプライベート署名キーの所有を証明する場合。"
    },
    {
      "indent": 4,
      "text": "Field Value Comment",
      "ja": "フィールドバリューコメント"
    },
    {
      "indent": 4,
      "text": "algorithmIdentifier MSG_SIG_ALG only signature protection is allowed for this proof",
      "ja": "algorithmidentifier msg_sig_algこの証明には署名保護のみが許可されています"
    },
    {
      "indent": 4,
      "text": "signature present bits calculated using MSG_SIG_ALG",
      "ja": "MSG_SIG_ALGを使用して計算された署名現在のビット"
    },
    {
      "indent": 3,
      "text": "Proof-of-possession of a private decryption key that corresponds to a public encryption key for which a certificate has been requested does not use this profile; the CertHash field of the certConf message is used instead.",
      "ja": "証明書が要求された公開暗号化キーに対応するプライベート復号化キーの入力の証明は、このプロファイルを使用しません。代わりに、CERTCONFメッセージのCerthashフィールドが使用されます。"
    },
    {
      "indent": 3,
      "text": "Not every CA/RA will do Proof-of-Possession (of signing key, decryption key, or key agreement key) in the PKIX-CMP in-band certification request protocol (how POP is done MAY ultimately be a policy issue that is made explicit for any given CA in its publicized Policy OID and Certification Practice Statement). However, this specification MANDATES that CA/RA entities MUST do POP (by some means) as part of the certification process. All end entities MUST be prepared to provide POP (i.e., these components of the PKIX-CMP protocol MUST be supported).",
      "ja": "すべてのCA/RAがPKIX-CMP In-Band認定要求プロトコルで（署名キー、復号化キー、またはキー契約キーの署名、誘導キー、またはキー契約キー）を行うわけではありません（最終的に行われる方法は、最終的に行われる可能性があります。公表されたポリシーOIDおよび認定慣行声明の任意のCAについて明示的。ただし、この仕様は、CA/RAエンティティが認証プロセスの一部として（何らかの方法で）POPを行う必要があることを義務付けています。すべてのエンティティをPOPを提供するために準備する必要があります（つまり、PKIX-CMPプロトコルのこれらのコンポーネントをサポートする必要があります）。"
    },
    {
      "indent": 0,
      "text": "D.4. Initial Registration/Certification (Basic Authenticated Scheme)",
      "section_title": true,
      "ja": "D.4. 初期登録/認定（基本認証スキーム）"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity requests a (first) certificate from a CA. When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA sends a PKIConfirm back, closing the transaction. All messages are authenticated.",
      "ja": "（非初期化されていない）エンティティは、caから（最初の）証明書を要求します。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAはPkiconfirmを送り返し、トランザクションを閉じます。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "This scheme allows the end entity to request certification of a locally-generated public key (typically a signature key). The end entity MAY also choose to request the centralized generation and certification of another key pair (typically an encryption key pair).",
      "ja": "このスキームにより、最終エンティティはローカルで生成された公開キー（通常は署名キー）の認証を要求できます。End Entityは、別のキーペアの集中生成と認証を要求することもできます（通常、暗号化キーペア）。"
    },
    {
      "indent": 3,
      "text": "Certification may only be requested for one locally generated public key (for more, use separate PKIMessages).",
      "ja": "認定は、1つのローカルで生成された公開キーに対してのみ要求される場合があります（詳細については、個別のpkimessageを使用してください）。"
    },
    {
      "indent": 3,
      "text": "The end entity MUST support proof-of-possession of the private key associated with the locally-generated public key.",
      "ja": "最終エンティティは、ローカルで生成された公開鍵に関連する秘密鍵のプルーフの証明をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 3,
      "text": "1. The end entity can authenticate the CA's signature based on out-of-band means",
      "ja": "1. 最終エンティティは、帯域外の平均に基づいてCAの署名を認証できます"
    },
    {
      "indent": 3,
      "text": "2. The end entity and the CA share a symmetric MACing key",
      "ja": "2. End EntityとCAは対称マッキングキーを共有します"
    },
    {
      "indent": 3,
      "text": "Message flow:",
      "ja": "メッセージフロー："
    },
    {
      "indent": 4,
      "text": "Step# End entity                           PKI\n  1   format ir\n  2                      ->   ir      ->\n  3                                        handle ir\n  4                                        format ip\n  5                      <-   ip      <-\n  6   handle ip\n  7   format certConf\n  8                      ->   certConf ->\n  9                                        handle certConf\n 10                                        format PKIConf\n 11                      <-   PKIConf  <-\n 12   handle PKIConf",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For this profile, we mandate that the end entity MUST include all (i.e., one or two) CertReqMsg in a single PKIMessage, and that the PKI (CA) MUST produce a single response PKIMessage that contains the complete response (i.e., including the OPTIONAL second key pair, if it was requested and if centralized key generation is supported). For simplicity, we also mandate that this message MUST be the final one (i.e., no use of \"waiting\" status value).",
      "ja": "このプロファイルでは、最終エンティティにすべての（つまり、1つまたは2つの）certreqmsgを単一のpkimessageに含める必要があり、PKI（CA）は完全な応答を含む単一の応答pkimessageを作成する必要があることを義務付けています。2番目のキーペアは、要求された場合、一元化されたキー生成がサポートされている場合）。簡単にするために、このメッセージが最後のものでなければならないことを義務付けています（つまり、「待機」ステータス値を使用しない）。"
    },
    {
      "indent": 3,
      "text": "The end entity has an out-of-band interaction with the CA/RA. This transaction established the shared secret, the referenceNumber and OPTIONALLY the distinguished name used for both sender and subject name in the certificate template. It is RECOMMENDED that the shared secret be at least 12 characters long.",
      "ja": "End Entityには、CA/RAとの外れの相互作用があります。このトランザクションは、Shared Secret、Referencenumber、およびオプションで、証明書テンプレートの送信者と件名名の両方に使用される著名な名前を確立しました。共有された秘密は、少なくとも12文字の長さであることをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Initialization Request -- ir",
      "ja": "初期化リクエスト-IR"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "recipient CA name",
      "ja": "受信者CA名"
    },
    {
      "indent": 3,
      "text": "  -- the name of the CA who is being asked to produce a certificate\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this request, based\n  -- on initial authentication key\nsenderKID            referenceNum\n  -- the reference number which the CA has previously issued\n  -- to the end entity (together with the MACing key)\ntransactionID        present\n  -- implementation-specific value, meaningful to end\n  -- entity.\n  -- [If already in use at the CA, then a rejection message MUST\n  -- be produced by the CA]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "senderNonce          present\n  -- 128 (pseudo-)random bits\nfreeText             any valid value\nbody                 ir (CertReqMessages)\n                     only one or two CertReqMsg\n                     are allowed\n  -- if more certificates are required, requests MUST be\n  -- packaged in separate PKIMessages",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "CertReqMsg           one or two present\n  -- see below for details, note: crm[0] means the first\n  -- (which MUST be present), crm[1] means the second (which\n  -- is OPTIONAL, and used to ask for a centrally-generated key)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crm[0].certReq.      fixed value of zero\n   certReqId\n  -- this is the index of the template within the message\ncrm[0].certReq       present\n   certTemplate\n  -- MUST include subject public key value, otherwise unconstrained\ncrm[0].pop...        optionally present if public key\n   POPOSigningKey    from crm[0].certReq.certTemplate is\n                     a signing key\n  -- proof-of-possession MAY be required in this exchange\n  -- (see Appendix D.3 for details)\ncrm[0].certReq.      optionally present\n   controls.archiveOptions\n  -- the end entity MAY request that the locally-generated\n  -- private key be archived",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crm[0].certReq. optionally present controls.publicationInfo -- the end entity MAY ask for publication of resulting cert.",
      "ja": "CRM [0] .certreq。オプションでcontrols.publicationinfoを提示する - 最終エンティティは、結果として得られる証明書の公開を要求する場合があります。"
    },
    {
      "indent": 3,
      "text": "crm[1].certReq fixed value of one",
      "ja": "CRM [1] .CERTREQ固定値1"
    },
    {
      "indent": 3,
      "text": "   certReqId\n  -- the index of the template within the message\ncrm[1].certReq       present\n   certTemplate\n   -- MUST NOT include actual public key bits, otherwise\n   -- unconstrained (e.g., the names need not be the same as in\n   -- crm[0]).  Note that subjectPublicKeyInfo MAY be present\n   -- and contain an AlgorithmIdentifier followed by a\n   -- zero-length BIT STRING for the subjectPublicKey if it is\n   -- desired to inform the CA/RA of algorithm and parameter\n   -- preferences regarding the to-be-generated key pair.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crm[1].certReq. present [object identifier MUST be PROT_ENC_ALG]",
      "ja": "CRM [1] .certreq。現在[オブジェクト識別子はprot_enc_algでなければなりません]"
    },
    {
      "indent": 5,
      "text": " controls.protocolEncrKey\n-- if centralized key generation is supported by this CA,\n-- this short-term asymmetric encryption key (generated by\n-- the end entity) will be used by the CA to encrypt (a\n-- symmetric key used to encrypt) a private key generated by\n-- the CA on behalf of the end entity",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crm[1].certReq. optionally present controls.archiveOptions crm[1].certReq. optionally present controls.publicationInfo protection present -- bits calculated using MSG_MAC_ALG",
      "ja": "CRM [1] .certreq。オプションでコントロールを提示します。ARCIVEOPTIONSCRM[1] .CERTREQ。オプションでcontrols.publicationinfo保護存在-msg_mac_algを使用して計算されたビット"
    },
    {
      "indent": 3,
      "text": "Initialization Response -- ip",
      "ja": "初期化応答-IP"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender               CA name\n  -- the name of the CA who produced the message\nmessageTime          present\n  -- time at which CA produced message\nprotectionAlg        MS_MAC_ALG\n  -- only MAC protection is allowed for this response\nsenderKID             referenceNum\n  -- the reference number that the CA has previously issued to the\n  -- end entity (together with the MACing key)\ntransactionID        present\n  -- value from corresponding ir message\nsenderNonce          present\n  -- 128 (pseudo-)random bits\nrecipNonce           present\n  -- value from senderNonce in corresponding ir message\nfreeText             any valid value\n   body                 ip (CertRepMessage)\n                     contains exactly one response\n                     for each request",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  -- The PKI (CA) responds to either one or two requests as\n  -- appropriate.  crc[0] denotes the first (always present);\n  -- crc[1] denotes the second (only present if the ir message\n  -- contained two requests and if the CA supports centralized\n  -- key generation).\ncrc[0].              fixed value of zero\n   certReqId\n  -- MUST contain the response to the first request in the\n  -- corresponding ir message",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crc[0].status.       present, positive values allowed:\n   status               \"accepted\", \"grantedWithMods\"\n                     negative values allowed:\n                        \"rejection\"\ncrc[0].status.       present if and only if\n   failInfo          crc[0].status.status is \"rejection\"\ncrc[0].              present if and only if\n   certifiedKeyPair  crc[0].status.status is\n                        \"accepted\" or \"grantedWithMods\"\ncertificate          present unless end entity's public\n                     key is an encryption key and POP\n                     is done in this in-band exchange\nencryptedCert        present if and only if end entity's\n                     public key is an encryption key and\n                     POP done in this in-band exchange\npublicationInfo      optionally present",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "-- indicates where certificate has been published (present\n-- at discretion of CA)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "crc[1].              fixed value of one\n   certReqId\n  -- MUST contain the response to the second request in the\n  -- corresponding ir message\ncrc[1].status.       present, positive values allowed:\n   status               \"accepted\", \"grantedWithMods\"\n                     negative values allowed:\n                        \"rejection\"\ncrc[1].status.       present if and only if\n   failInfo          crc[0].status.status is \"rejection\"\ncrc[1].              present if and only if\n   certifiedKeyPair  crc[0].status.status is \"accepted\"\n                     or \"grantedWithMods\"\ncertificate          present\n   privateKey           present\n  -- see Appendix C, Request Message Behavioral Clarifications\npublicationInfo      optionally present\n  -- indicates where certificate has been published (present\n  -- at discretion of CA)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "protection           present\n  -- bits calculated using MSG_MAC_ALG\nextraCerts           optionally present\n  -- the CA MAY provide additional certificates to the end\n  -- entity",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Certificate confirm; certConf",
      "ja": "証明書確認。証明書"
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender               present\n  -- same as in ir\nrecipient            CA name\n  -- the name of the CA who was asked to produce a certificate\ntransactionID        present\n  -- value from corresponding ir and ip messages\nsenderNonce          present\n  -- 128 (pseudo-) random bits\nrecipNonce           present\n  -- value from senderNonce in corresponding ip message\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this message.  The\n  -- MAC is based on the initial authentication key shared\n  -- between the EE and the CA.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "senderKID            referenceNum\n  -- the reference number which the CA has previously issued\n  -- to the end entity (together with the MACing key)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "body                 certConf\n  -- see Section 5.3.18, \"PKI Confirmation Content\", for the\n  -- contents of the certConf fields.\n  -- Note: two CertStatus structures are required if both an\n  -- encryption and a signing certificate were sent.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "protection present -- bits calculated using MSG_MAC_ALG",
      "ja": "保護存在-MSG_MAC_ALGを使用して計算されたビット"
    },
    {
      "indent": 3,
      "text": "Confirmation; PKIConf",
      "ja": "確認;pkiconf"
    },
    {
      "indent": 3,
      "text": "Field                Value\n   sender               present\n  -- same as in ip\nrecipient            present\n  -- sender name from certConf\ntransactionID        present\n  -- value from certConf message\nsenderNonce          present\n  -- 128 (pseudo-) random bits\nrecipNonce           present\n  -- value from senderNonce from certConf message\nprotectionAlg        MSG_MAC_ALG\n  -- only MAC protection is allowed for this message.\nsenderKID            referenceNum\nbody                 PKIConf\nprotection           present\n  -- bits calculated using MSG_MAC_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "D.5. Certificate Request",
      "section_title": true,
      "ja": "D.5. 証明書リクエスト"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (for any reason). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a PKIConfirm, to close the transaction. All messages are authenticated.",
      "ja": "（初期化された）ENDエンティティは、CAから証明書を要求します（何らかの理由で）。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAは、トランザクションを閉じるために、pkiconfirmで応答します。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、次の例外を除いて、付録D.4に記載されているプロファイルと同じです。"
    },
    {
      "indent": 3,
      "text": "o sender name SHOULD be present",
      "ja": "o 送信者名が存在する必要があります"
    },
    {
      "indent": 3,
      "text": "o protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConfirm, and PKIConfirm messages;",
      "ja": "o Request、Response、CertConfirm、およびPKICONFIRMメッセージで、MSG_SIG_ALGのProtectionalgをサポートする必要があります（MSG_MAC_ALGもサポートされる場合があります）。"
    },
    {
      "indent": 3,
      "text": "o senderKID and recipKID are only present if required for message verification;",
      "ja": "o SenderKidとRecipkidは、メッセージの確認に必要な場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "o body is cr or cp;",
      "ja": "o ボディはCRまたはCPです。"
    },
    {
      "indent": 3,
      "text": "o body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally-generated public key or a centrally-generated public key (i.e., the position-dependence requirement of Appendix D.4 is removed);",
      "ja": "o ボディには1つまたは2つのcertreqmsg構造が含まれる場合がありますが、CertreqMSGのいずれかを使用して、ローカルで生成された公開キーまたは中央生成された公開キーの認証を要求できます（つまり、付録D.4の位置依存要件が削除されます）。"
    },
    {
      "indent": 3,
      "text": "o protection bits are calculated according to the protectionAlg field.",
      "ja": "o 保護ビットは、保護分野に従って計算されます。"
    },
    {
      "indent": 0,
      "text": "D.6. Key Update Request",
      "section_title": true,
      "ja": "D.6. キーアップデートリクエスト"
    },
    {
      "indent": 3,
      "text": "An (initialized) end entity requests a certificate from a CA (to update the key pair and/or corresponding certificate that it already possesses). When the CA responds with a message containing a certificate, the end entity replies with a certificate confirmation. The CA replies with a PKIConfirm, to close the transaction. All messages are authenticated.",
      "ja": "（初期化された）ENDエンティティは、CAから証明書を要求します（既に所有しているキーペアおよび/または対応する証明書を更新するため）。CAが証明書を含むメッセージで応答すると、End Entityは証明書の確認で応答します。CAは、トランザクションを閉じるために、pkiconfirmで応答します。すべてのメッセージは認証されています。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、次の例外を除いて、付録D.4に記載されているプロファイルと同じです。"
    },
    {
      "indent": 3,
      "text": "1. sender name SHOULD be present",
      "ja": "1. 送信者名が存在する必要があります"
    },
    {
      "indent": 3,
      "text": "2. protectionAlg of MSG_SIG_ALG MUST be supported (MSG_MAC_ALG MAY also be supported) in request, response, certConfirm, and PKIConfirm messages;",
      "ja": "2. Request、Response、CertConfirm、およびPKICONFIRMメッセージで、MSG_SIG_ALGのProtectionalgをサポートする必要があります（MSG_MAC_ALGもサポートされる場合があります）。"
    },
    {
      "indent": 3,
      "text": "3. senderKID and recipKID are only present if required for message verification;",
      "ja": "3. SenderKidとRecipkidは、メッセージの確認に必要な場合にのみ存在します。"
    },
    {
      "indent": 3,
      "text": "4. body is kur or kup;",
      "ja": "4. 体はkurまたはkupです。"
    },
    {
      "indent": 3,
      "text": "5. body may contain one or two CertReqMsg structures, but either CertReqMsg may be used to request certification of a locally-generated public key or a centrally-generated public key (i.e., the position-dependence requirement of Appendix D.4 is removed);",
      "ja": "5. ボディには1つまたは2つのcertreqmsg構造が含まれる場合がありますが、CertreqMSGのいずれかを使用して、ローカルで生成された公開キーまたは中央生成された公開キーの認証を要求できます（つまり、付録D.4の位置依存要件が削除されます）。"
    },
    {
      "indent": 3,
      "text": "6. protection bits are calculated according to the protectionAlg field;",
      "ja": "6. 保護ビットは、保護分野に従って計算されます。"
    },
    {
      "indent": 3,
      "text": "7. regCtrl OldCertId SHOULD be used (unless it is clear to both sender and receiver -- by means not specified in this document -- that it is not needed).",
      "ja": "7. regctrl oldcertidを使用する必要があります（このドキュメントでは指定されていない手段で、送信者と受信機の両方に明確でない限り、必要ではないことを）。"
    },
    {
      "indent": 0,
      "text": "Appendix E. PKI Management Message Profiles (OPTIONAL).",
      "ja": "付録E. PKI管理メッセージプロファイル（オプション）。"
    },
    {
      "indent": 3,
      "text": "This appendix contains detailed profiles for those PKIMessages that MAY be supported by implementations (in addition to the messages which MUST be supported; see Section 6 and Appendix D).",
      "ja": "この付録には、実装によってサポートされる可能性のあるpkimessageの詳細なプロファイルが含まれています（サポートする必要があるメッセージに加えて、セクション6および付録Dを参照）。"
    },
    {
      "indent": 3,
      "text": "Profiles for the PKIMessages used in the following PKI management operations are provided:",
      "ja": "次のPKI管理操作で使用されるPKIMESSAGEのプロファイルが提供されます。"
    },
    {
      "indent": 3,
      "text": "o root CA key update",
      "ja": "o ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "o information request/response o cross-certification request/response (1-way)",
      "ja": "o 情報リクエスト/応答o相互認証リクエスト/応答（1ウェイ）"
    },
    {
      "indent": 3,
      "text": "o in-band initialization using external identity certificate",
      "ja": "o 外部ID証明書を使用したバンドの初期化"
    },
    {
      "indent": 3,
      "text": "Later versions of this document may extend the above to include profiles for the operations listed below (along with other operations, if desired).",
      "ja": "このドキュメントの後のバージョンは、上記を拡張して、以下にリストされている操作のプロファイルを含めることができます（必要に応じて、他の操作とともに）。"
    },
    {
      "indent": 3,
      "text": "o revocation request",
      "ja": "o 取り消しリクエスト"
    },
    {
      "indent": 3,
      "text": "o certificate publication",
      "ja": "o 証明書の出版物"
    },
    {
      "indent": 3,
      "text": "o CRL publication",
      "ja": "o CRL出版物"
    },
    {
      "indent": 0,
      "text": "E.1. General Rules for Interpretation of These Profiles.",
      "ja": "E.1. これらのプロファイルの解釈に関する一般的なルール。"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix D.1.",
      "ja": "付録D.1と同一。"
    },
    {
      "indent": 0,
      "text": "E.2. Algorithm Use Profile",
      "section_title": true,
      "ja": "E.2. アルゴリズムはプロファイルを使用します"
    },
    {
      "indent": 3,
      "text": "Identical to Appendix D.2.",
      "ja": "付録D.2と同一。"
    },
    {
      "indent": 0,
      "text": "E.3. Self-Signed Certificates",
      "section_title": true,
      "ja": "E.3. 自己署名証明書"
    },
    {
      "indent": 3,
      "text": "Profile of how a Certificate structure may be \"self-signed\". These structures are used for distribution of CA public keys. This can occur in one of three ways (see Section 4.4 above for a description of the use of these structures):",
      "ja": "証明書構造が「自己署名」される方法のプロファイル。これらの構造は、CAパブリックキーの分布に使用されます。これは、3つの方法のいずれかで発生する可能性があります（これらの構造の使用の説明については、上記のセクション4.4を参照してください）："
    },
    {
      "indent": 3,
      "text": "Type          Function\n-----------------------------------------------------------------\nnewWithNew a true \"self-signed\" certificate; the contained\n           public key MUST be usable to verify the signature\n           (though this provides only integrity and no\n           authentication whatsoever)\noldWithNew previous root CA public key signed with new private key\nnewWithOld new root CA public key signed with previous private key",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Such certificates (including relevant extensions) must contain \"sensible\" values for all fields. For example, when present, subjectAltName MUST be identical to issuerAltName, and, when present, keyIdentifiers must contain appropriate values, et cetera.",
      "ja": "このような証明書（関連する拡張機能を含む）には、すべてのフィールドに「賢明な」値を含める必要があります。たとえば、存在する場合、subjectaltnameはIssueraltnameと同一である必要があり、存在する場合、keyidentifiersには適切な値などが含まれている必要があります。"
    },
    {
      "indent": 0,
      "text": "E.4. Root CA Key Update",
      "section_title": true,
      "ja": "E.4. ルートCAキーアップデート"
    },
    {
      "indent": 3,
      "text": "A root CA updates its key pair. It then produces a CA key update announcement message that can be made available (via some transport mechanism) to the relevant end entities. A confirmation message is NOT REQUIRED from the end entities.",
      "ja": "ルートCAはキーペアを更新します。次に、関連する最終エンティティに（何らかの輸送メカニズムを介して）利用可能にすることができるCAキーアップデートアナウンスメッセージを作成します。最終エンティティからは確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "ckuann message:",
      "ja": "ckuannメッセージ："
    },
    {
      "indent": 3,
      "text": " Field        Value                        Comment\n--------------------------------------------------------------\n sender       CA name CA name\n body         ckuann(CAKeyUpdAnnContent)\n oldWithNew   present                  see Appendix E.3 above\n newWithOld   present                  see Appendix E.3 above\n newWithNew   present                  see Appendix E.3 above\n extraCerts   optionally present       can be used to \"publish\"\n                                       certificates (e.g.,\n                                       certificates signed using\n                                       the new private key)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.5. PKI Information Request/Response",
      "section_title": true,
      "ja": "E.5. PKI情報リクエスト/応答"
    },
    {
      "indent": 3,
      "text": "The end entity sends a general message to the PKI requesting details that will be required for later PKI management operations. RA/CA responds with a general response. If an RA generates the response, then it will simply forward the equivalent message that it previously received from the CA, with the possible addition of certificates to the extraCerts fields of the PKIMessage. A confirmation message is NOT REQUIRED from the end entity.",
      "ja": "End Entityは、後のPKI管理操作に必要な詳細を要求するPKIに一般的なメッセージを送信します。RA/CAは一般的な応答で応答します。RAが応答を生成する場合、PKIMESSAGEのエクストラアセートフィールドに証明書を追加する可能性があるため、以前にCAから受け取った同等のメッセージを単純に転送します。最終エンティティからは確認メッセージは必要ありません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージの流れ："
    },
    {
      "indent": 3,
      "text": "Step# End entity PKI",
      "ja": "ステップ＃エンティティPKIを終了します"
    },
    {
      "indent": 6,
      "text": "1  format genm\n2                ->   genm   ->\n3                                    handle genm\n4                                    produce genp\n5                <-   genp   <-\n6  handle genp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "genM:",
      "ja": "Genm："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "recipient CA name -- the name of the CA as contained in issuerAltName",
      "ja": "受信者ca名 -  suereraltnameに含まれるCAの名前"
    },
    {
      "indent": 3,
      "text": "  -- extensions or issuer fields within certificates\nprotectionAlg       MSG_MAC_ALG or MSG_SIG_ALG\n  -- any authenticated protection alg.\nSenderKID           present if required\n  -- must be present if required for verification of message\n  -- protection\nfreeText            any valid value\nbody                genr (GenReqContent)\nGenMsgContent       empty SEQUENCE\n  -- all relevant information requested\nprotection          present\n  -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "genP:",
      "ja": "Genp："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender               CA name\n  -- name of the CA which produced the message\nprotectionAlg        MSG_MAC_ALG or MSG_SIG_ALG\n  -- any authenticated protection alg.\nsenderKID            present if required\n  -- must be present if required for verification of message\n  -- protection\nbody                 genp (GenRepContent)\nCAProtEncCert        present (object identifier one\n                     of PROT_ENC_ALG), with relevant\n                     value\n  -- to be used if end entity needs to encrypt information for\n  -- the CA (e.g., private key for recovery purposes)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SignKeyPairTypes     present, with relevant value\n  -- the set of signature algorithm identifiers that this CA will\n  -- certify for subject public keys\nEncKeyPairTypes      present, with relevant value\n  -- the set of encryption/key agreement algorithm identifiers that\n  -- this CA will certify for subject public keys\nPreferredSymmAlg     present (object identifier one\n                     of PROT_SYM_ALG) , with relevant\n                     value\n  -- the symmetric algorithm that this CA expects to be used\n  -- in later PKI messages (for encryption)\nCAKeyUpdateInfo      optionally present, with\n                     relevant value\n  -- the CA MAY provide information about a relevant root CA\n  -- key pair using this field (note that this does not imply\n  -- that the responding CA is the root CA in question)\nCurrentCRL           optionally present, with relevant value",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  -- the CA MAY provide a copy of a complete CRL (i.e.,\n  -- fullest possible one)\nprotection           present\n  -- bits calculated using MSG_MAC_ALG or MSG_SIG_ALG\nextraCerts           optionally present\n  -- can be used to send some certificates to the end\n  -- entity. An RA MAY add its certificate here.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.6. Cross Certification Request/Response (1-way)",
      "section_title": true,
      "ja": "E.6. クロス認証リクエスト/応答（1ウェイ）"
    },
    {
      "indent": 3,
      "text": "Creation of a single cross-certificate (i.e., not two at once). The requesting CA MAY choose who is responsible for publication of the cross-certificate created by the responding CA through use of the PKIPublicationInfo control.",
      "ja": "単一のクロス認証の作成（つまり、一度に2つではありません）。要求するCAは、PKIPUblicationInfoコントロールの使用を通じて、応答するCAによって作成されたクロス認証の公開に誰が責任を負うかを選択できます。"
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 3,
      "text": "1. Responding CA can verify the origin of the request (possibly requiring out-of-band means) before processing the request.",
      "ja": "1. CAの応答は、リクエストを処理する前に、リクエストの原点（おそらく帯域外の手段が必要）を検証できます。"
    },
    {
      "indent": 3,
      "text": "2. Requesting CA can authenticate the authenticity of the origin of the response (possibly requiring out-of-band means) before processing the response",
      "ja": "2. CAを要求することで、応答を処理する前に、応答の起源の信頼性（おそらく帯域外の手段が必要）を認証できます"
    },
    {
      "indent": 3,
      "text": "The use of certificate confirmation and the corresponding server confirmation is determined by the generalInfo field in the PKIHeader (see Section 5.1.1). The following profile does not mandate support for either confirmation.",
      "ja": "証明書確認と対応するサーバーの確認の使用は、PKIHeaderのGeneralInfoフィールドによって決定されます（セクション5.1.1を参照）。次のプロファイルは、どちらの確認もサポートを義務付けていません。"
    },
    {
      "indent": 3,
      "text": "Message Flows:",
      "ja": "メッセージの流れ："
    },
    {
      "indent": 3,
      "text": "Step# Requesting CA                       Responding CA\n  1   format ccr\n  2                   ->    ccr    ->\n  3                                       handle ccr\n  4                                       produce ccp\n  5                   <-    ccp    <-\n  6   handle ccp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ccr:",
      "ja": "CCR："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender                Requesting CA name\n  -- the name of the CA who produced the message\nrecipient             Responding CA name\n  -- the name of the CA who is being asked to produce a certificate\nmessageTime           time of production of message",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "  -- current time at requesting CA\nprotectionAlg         MSG_SIG_ALG\n  -- only signature protection is allowed for this request\nsenderKID             present if required\n  -- must be present if required for verification of message\n  -- protection\nrecipKID             present if required\n  -- must be present if required for verification of message\n  -- protection\ntransactionID         present\n  -- implementation-specific value, meaningful to requesting CA.\n  -- [If already in use at responding CA then a rejection message\n  -- MUST be produced by responding CA]\nsenderNonce           present\n  -- 128 (pseudo-)random bits\nfreeText              any valid value\nbody                  ccr (CertReqMessages)\n                      only one CertReqMsg\n                      allowed\n  -- if multiple cross certificates are required, they MUST be\n  -- packaged in separate PKIMessages\ncertTemplate          present\n  -- details follow\nversion               v1 or v3\n  -- v3 STRONGLY RECOMMENDED\nsigningAlg            present\n  -- the requesting CA must know in advance with which algorithm it\n  -- wishes the certificate to be signed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "subject               present\n  -- may be NULL-DN only if subjectAltNames extension value proposed\nvalidity              present\n  -- MUST be completely specified (i.e., both fields present)\nissuer                present\n  -- may be NULL-DN only if issuerAltNames extension value proposed\npublicKey             present\n  -- the key to be certified (which must be for a signing algorithm)\nextensions            optionally present\n  -- a requesting CA must propose values for all extensions\n  -- that it requires to be in the cross-certificate\nPOPOSigningKey        present\n  -- see Section D3: Proof-of-possession profile\nprotection            present\n  -- bits calculated using MSG_SIG_ALG\nextraCerts            optionally present\n  -- MAY contain any additional certificates that requester wishes\n  -- to include",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ccp:",
      "ja": "CCP："
    },
    {
      "indent": 3,
      "text": "Field Value",
      "ja": "フィールド値"
    },
    {
      "indent": 3,
      "text": "sender                Responding CA name\n  -- the name of the CA who produced the message\nrecipient             Requesting CA name\n  -- the name of the CA who asked for production of a certificate\nmessageTime           time of production of message\n  -- current time at responding CA\nprotectionAlg         MSG_SIG_ALG\n  -- only signature protection is allowed for this message\nsenderKID             present if required\n  -- must be present if required for verification of message\n  -- protection\nrecipKID              present if required\ntransactionID         present\n  -- value from corresponding ccr message\nsenderNonce           present\n  -- 128 (pseudo-)random bits\nrecipNonce            present\n-- senderNonce from corresponding ccr message\nfreeText              any valid value\nbody                  ccp (CertRepMessage)\n                      only one CertResponse allowed\n  -- if multiple cross certificates are required they MUST be\n  -- packaged in separate PKIMessages\nresponse              present\nstatus                present",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "PKIStatusInfo.status  present\n  -- if PKIStatusInfo.status is one of:\n  --   accepted, or\n  --   grantedWithMods,\n  -- then certifiedKeyPair MUST be present and failInfo MUST\n  -- be absent",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "failInfo              present depending on\n                      PKIStatusInfo.status\n  -- if PKIStatusInfo.status is:\n  --   rejection\n  -- then certifiedKeyPair MUST be absent and failInfo MUST be\n  -- present and contain appropriate bit settings",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "certifiedKeyPair present depending on PKIStatusInfo.status certificate present depending on certifiedKeyPair",
      "ja": "pkistatusinfo.status証明書に応じて存在するcertifiedkeypair certifiedkeypairに応じて存在する"
    },
    {
      "indent": 3,
      "text": "  -- content of actual certificate must be examined by requesting CA\n  -- before publication\nprotection            present\n  -- bits calculated using MSG_SIG_ALG\nextraCerts            optionally present\n  -- MAY contain any additional certificates that responder wishes\n  -- to include",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "E.7. In-Band Initialization Using External Identity Certificate",
      "section_title": true,
      "ja": "E.7. 外部ID証明書を使用したバンドの初期化"
    },
    {
      "indent": 3,
      "text": "An (uninitialized) end entity wishes to initialize into the PKI with a CA, CA-1. It uses, for authentication purposes, a pre-existing identity certificate issued by another (external) CA, CA-X. A trust relationship must already have been established between CA-1 and CA-X so that CA-1 can validate the EE identity certificate signed by CA-X. Furthermore, some mechanism must already have been established within the Personal Security Environment (PSE) of the EE that would allow it to authenticate and verify PKIMessages signed by CA-1 (as one example, the PSE may contain a certificate issued for the public key of CA-1, signed by another CA that the EE trusts on the basis of out-of-band authentication techniques).",
      "ja": "（非初期化されていない）エンティティは、CA、CA-1を使用してPKIに初期化したいと考えています。認証のために、別の（外部）CA、CA-Xによって発行された既存のID証明書を使用します。CA-1がCA-Xによって署名されたEE ID証明書を検証できるように、CA-1とCA-Xの間に信頼関係がすでに確立されている必要があります。さらに、CA-1が署名したpkimessageを認証および検証できるEEの個人セキュリティ環境（PSE）内ですでにいくつかのメカニズムが確立されている必要があります（1つの例として、PSEには公開キーに対して発行された証明書が含まれる場合がありますEEが帯域外認証技術に基づいて信頼する別のCAによって署名されたCA-1の。"
    },
    {
      "indent": 3,
      "text": "The EE sends an initialization request to start the transaction. When CA-1 responds with a message containing the new certificate, the end entity replies with a certificate confirmation. CA-1 replies with a PKIConfirm to close the transaction. All messages are signed (the EE messages are signed using the private key that corresponds to the public key in its external identity certificate; the CA-1 messages are signed using the private key that corresponds to the public key in a",
      "ja": "EEは、トランザクションを開始するための初期化リクエストを送信します。CA-1が新しい証明書を含むメッセージで応答すると、End Entityは証明書確認で応答します。CA-1は、トランザクションを閉じるためにpkiconfirmで返信します。すべてのメッセージに署名されます（EEメッセージは、外部ID証明書の公開キーに対応する秘密鍵を使用して署名されます。CA-1メッセージは、Aの公開キーに対応する秘密鍵を使用して署名されます。"
    },
    {
      "indent": 3,
      "text": "certificate that can be chained to a trust anchor in the EE's PSE).",
      "ja": "EEのPSEの信頼アンカーに連鎖できる証明書）。"
    },
    {
      "indent": 3,
      "text": "The profile for this exchange is identical to that given in Appendix D.4, with the following exceptions:",
      "ja": "この交換のプロファイルは、次の例外を除いて、付録D.4に記載されているプロファイルと同じです。"
    },
    {
      "indent": 3,
      "text": "o the EE and CA-1 do not share a symmetric MACing key (i.e., there is no out-of-band shared secret information between these entities);",
      "ja": "o EEとCA-1は、対称マッキングキーを共有していません（つまり、これらのエンティティ間にバンド外の共有秘密情報はありません）。"
    },
    {
      "indent": 3,
      "text": "o sender name in ir MUST be present (and identical to the subject name present in the external identity certificate);",
      "ja": "o IRの送信者名は存在する必要があります（および外部ID証明書に存在する件名と同じ）。"
    },
    {
      "indent": 3,
      "text": "o protectionAlg of MSG_SIG_ALG MUST be used in all messages;",
      "ja": "o MSG_SIG_ALGのProtectionalgは、すべてのメッセージで使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "o external identity cert. MUST be carried in ir extraCerts field",
      "ja": "o 外部アイデンティティ証明書。IRエクストラアサートフィールドで運ぶ必要があります"
    },
    {
      "indent": 3,
      "text": "o senderKID and recipKID are not used;",
      "ja": "o SenderKidとRecipkidは使用されていません。"
    },
    {
      "indent": 3,
      "text": "o body is ir or ip;",
      "ja": "o ボディはIRまたはIPです。"
    },
    {
      "indent": 3,
      "text": "o protection bits are calculated according to the protectionAlg field.",
      "ja": "o 保護ビットは、保護分野に従って計算されます。"
    },
    {
      "indent": 0,
      "text": "Appendix F. Compilable ASN.1 Definitions",
      "section_title": true,
      "ja": "付録F. 編集可能なasn.1定義"
    },
    {
      "indent": 5,
      "text": "PKIXCMP {iso(1) identified-organization(3)\n      dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n      id-mod(0) id-mod-cmp2000(16)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "DEFINITIONS EXPLICIT TAGS ::=",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "BEGIN",
      "ja": "始める"
    },
    {
      "indent": 5,
      "text": "-- EXPORTS ALL --",
      "ja": " - すべてエクスポート - "
    },
    {
      "indent": 5,
      "text": "IMPORTS",
      "ja": "輸入"
    },
    {
      "indent": 9,
      "text": "Certificate, CertificateList, Extensions, AlgorithmIdentifier,\nUTF8String -- if required; otherwise, comment out\n       FROM PKIX1Explicit88 {iso(1) identified-organization(3)\n       dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n       id-mod(0) id-pkix1-explicit-88(1)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "GeneralName, KeyIdentifier\n       FROM PKIX1Implicit88 {iso(1) identified-organization(3)\n       dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n       id-mod(0) id-pkix1-implicit-88(2)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "CertTemplate, PKIPublicationInfo, EncryptedValue, CertId,\nCertReqMessages\n       FROM PKIXCRMF-2005 {iso(1) identified-organization(3)\n       dod(6) internet(1) security(5) mechanisms(5) pkix(7)\n       id-mod(0) id-mod-crmf2005(36)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "-- see also the behavioral clarifications to CRMF codified in\n-- Appendix C of this specification",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "CertificationRequest\n       FROM PKCS-10 {iso(1) member-body(2)\n                     us(840) rsadsi(113549)\n                     pkcs(1) pkcs-10(10) modules(1) pkcs-10(1)}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "-- (specified in RFC 2986 with 1993 ASN.1 syntax and IMPLICIT\n-- tags).  Alternatively, implementers may directly include\n-- the [PKCS10] syntax in this module",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": ";",
      "ja": ";"
    },
    {
      "indent": 3,
      "text": "-- the rest of the module contains locally-defined OIDs and\n-- constructs",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "   CMPCertificate ::= CHOICE {\n      x509v3PKCert        Certificate\n   }\n-- This syntax, while bits-on-the-wire compatible with the\n-- standard X.509 definition of \"Certificate\", allows the\n-- possibility of future certificate types (such as X.509\n-- attribute certificates, WAP WTLS certificates, or other kinds\n-- of certificates) within this certificate management protocol,\n-- should a need ever arise to support such generality.  Those\n-- implementations that do not foresee a need to ever support\n-- other certificate types MAY, if they wish, comment out the\n-- above structure and \"un-comment\" the following one prior to\n-- compiling this ASN.1 module.  (Note that interoperability\n-- with implementations that don't do this will be unaffected by\n-- this change.)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- CMPCertificate ::= Certificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " PKIMessage ::= SEQUENCE {\n    header           PKIHeader,\n    body             PKIBody,\n    protection   [0] PKIProtection OPTIONAL,\n    extraCerts   [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIMessages ::= SEQUENCE SIZE (1..MAX) OF PKIMessage",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIHeader ::= SEQUENCE {\n    pvno                INTEGER     { cmp1999(1), cmp2000(2) },\n    sender              GeneralName,\n    -- identifies the sender\n    recipient           GeneralName,\n    -- identifies the intended recipient\n    messageTime     [0] GeneralizedTime         OPTIONAL,\n    -- time of production of this message (used when sender\n    -- believes that the transport will be \"suitable\"; i.e.,\n    -- that the time will still be meaningful upon receipt)\n    protectionAlg   [1] AlgorithmIdentifier     OPTIONAL,\n    -- algorithm used for calculation of protection bits\n    senderKID       [2] KeyIdentifier           OPTIONAL,\n    recipKID        [3] KeyIdentifier           OPTIONAL,\n    -- to identify specific keys used for protection\n         transactionID   [4] OCTET STRING            OPTIONAL,\n    -- identifies the transaction; i.e., this will be the same in\n    -- corresponding request, response, certConf, and PKIConf\n    -- messages\n    senderNonce     [5] OCTET STRING            OPTIONAL,\n    recipNonce      [6] OCTET STRING            OPTIONAL,\n    -- nonces used to provide replay protection, senderNonce\n    -- is inserted by the creator of this message; recipNonce\n    -- is a nonce previously inserted in a related message by\n    -- the intended recipient of this message\n    freeText        [7] PKIFreeText             OPTIONAL,\n    -- this may be used to indicate context-specific instructions\n    -- (this field is intended for human consumption)\n    generalInfo     [8] SEQUENCE SIZE (1..MAX) OF\n                           InfoTypeAndValue     OPTIONAL\n    -- this may be used to convey context-specific information\n    -- (this field not primarily intended for human consumption)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIFreeText ::= SEQUENCE SIZE (1..MAX) OF UTF8String\n    -- text encoded as UTF-8 String [RFC3629] (note: each\n    -- UTF8String MAY include an [RFC3066] language tag\n    -- to indicate the language of the contained text\n    -- see [RFC2482] for details)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIBody ::= CHOICE {       -- message-specific body elements\n    ir       [0]  CertReqMessages,        --Initialization Request\n    ip       [1]  CertRepMessage,         --Initialization Response\n    cr       [2]  CertReqMessages,        --Certification Request\n    cp       [3]  CertRepMessage,         --Certification Response\n    p10cr    [4]  CertificationRequest,   --imported from [PKCS10]\n    popdecc  [5]  POPODecKeyChallContent, --pop Challenge\n    popdecr  [6]  POPODecKeyRespContent,  --pop Response\n    kur      [7]  CertReqMessages,        --Key Update Request\n    kup      [8]  CertRepMessage,         --Key Update Response\n    krr      [9]  CertReqMessages,        --Key Recovery Request\n    krp      [10] KeyRecRepContent,       --Key Recovery Response\n    rr       [11] RevReqContent,          --Revocation Request\n    rp       [12] RevRepContent,          --Revocation Response\n    ccr      [13] CertReqMessages,        --Cross-Cert. Request\n    ccp      [14] CertRepMessage,         --Cross-Cert. Response\n    ckuann   [15] CAKeyUpdAnnContent,     --CA Key Update Ann.\n    cann     [16] CertAnnContent,         --Certificate Ann.\n    rann     [17] RevAnnContent,          --Revocation Ann.\n    crlann   [18] CRLAnnContent,          --CRL Announcement\n    pkiconf  [19] PKIConfirmContent,      --Confirmation\n    nested   [20] NestedMessageContent,   --Nested Message\n    genm     [21] GenMsgContent,          --General Message\n         genp     [22] GenRepContent,          --General Response\n    error    [23] ErrorMsgContent,        --Error Message\n    certConf [24] CertConfirmContent,     --Certificate confirm\n    pollReq  [25] PollReqContent,         --Polling request\n    pollRep  [26] PollRepContent          --Polling response\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIProtection ::= BIT STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ProtectedPart ::= SEQUENCE {\n    header    PKIHeader,\n    body      PKIBody\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "id-PasswordBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 13}\nPBMParameter ::= SEQUENCE {\n    salt                OCTET STRING,\n    -- note:  implementations MAY wish to limit acceptable sizes\n    -- of this string to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    iterationCount      INTEGER,\n    -- number of times the OWF is applied\n    -- note:  implementations MAY wish to limit acceptable sizes\n    -- of this integer to values appropriate for their environment\n    -- in order to reduce the risk of denial-of-service attacks\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "id-DHBasedMac OBJECT IDENTIFIER ::= {1 2 840 113533 7 66 30}\nDHBMParameter ::= SEQUENCE {\n    owf                 AlgorithmIdentifier,\n    -- AlgId for a One-Way Function (SHA-1 recommended)\n    mac                 AlgorithmIdentifier\n    -- the MAC AlgId (e.g., DES-MAC, Triple-DES-MAC [PKCS11],\n}   -- or HMAC [RFC2104, RFC2202])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "NestedMessageContent ::= PKIMessages",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIStatus ::= INTEGER {\n    accepted                (0),\n    -- you got exactly what you asked for\n    grantedWithMods        (1),\n    -- you got something like what you asked for; the\n    -- requester is responsible for ascertaining the differences\n         rejection              (2),\n    -- you don't get it, more information elsewhere in the message\n    waiting                (3),\n    -- the request body part has not yet been processed; expect to\n    -- hear more later (note: proper handling of this status\n    -- response MAY use the polling req/rep PKIMessages specified\n    -- in Section 5.3.22; alternatively, polling in the underlying\n    -- transport layer MAY have some utility in this regard)\n    revocationWarning      (4),\n    -- this message contains a warning that a revocation is\n    -- imminent\n    revocationNotification (5),\n    -- notification that a revocation has occurred\n    keyUpdateWarning       (6)\n    -- update already done for the oldCertId specified in\n    -- CertReqMsg\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIFailureInfo ::= BIT STRING {\n-- since we can fail in more than one way!\n-- More codes may be added in the future if/when required.\n    badAlg              (0),\n    -- unrecognized or unsupported Algorithm Identifier\n    badMessageCheck     (1),\n    -- integrity check failed (e.g., signature did not verify)\n    badRequest          (2),\n    -- transaction not permitted or supported\n    badTime             (3),\n    -- messageTime was not sufficiently close to the system time,\n    -- as defined by local policy\n    badCertId           (4),\n    -- no certificate could be found matching the provided criteria\n    badDataFormat       (5),\n    -- the data submitted has the wrong format\n    wrongAuthority      (6),\n    -- the authority indicated in the request is different from the\n    -- one creating the response token\n    incorrectData       (7),\n    -- the requester's data is incorrect (for notary services)\n    missingTimeStamp    (8),\n    -- when the timestamp is missing but should be there\n    -- (by policy)\n    badPOP              (9),\n    -- the proof-of-possession failed\n    certRevoked         (10),\n       -- the certificate has already been revoked\n    certConfirmed       (11),\n       -- the certificate has already been confirmed",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    wrongIntegrity      (12),\n       -- invalid integrity, password based instead of signature or\n       -- vice versa\n    badRecipientNonce   (13),\n       -- invalid recipient nonce, either missing or wrong value\n    timeNotAvailable    (14),\n       -- the TSA's time source is not available\n    unacceptedPolicy    (15),\n       -- the requested TSA policy is not supported by the TSA.\n    unacceptedExtension (16),\n       -- the requested extension is not supported by the TSA.\n    addInfoNotAvailable (17),\n       -- the additional information requested could not be\n       -- understood or is not available\n    badSenderNonce      (18),\n       -- invalid sender nonce, either missing or wrong size\n    badCertTemplate     (19),\n       -- invalid cert. template or missing mandatory information\n    signerNotTrusted    (20),\n       -- signer of the message unknown or not trusted\n    transactionIdInUse  (21),\n       -- the transaction identifier is already in use\n    unsupportedVersion  (22),\n       -- the version of the message is not supported\n    notAuthorized       (23),\n       -- the sender was not authorized to make the preceding\n       -- request or perform the preceding action\n    systemUnavail       (24),\n    -- the request cannot be handled due to system unavailability\n    systemFailure       (25),\n    -- the request cannot be handled due to system failure\n    duplicateCertReq    (26)\n    -- certificate cannot be issued because a duplicate\n    -- certificate already exists\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIStatusInfo ::= SEQUENCE {\n    status        PKIStatus,\n    statusString  PKIFreeText     OPTIONAL,\n    failInfo      PKIFailureInfo  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "OOBCert ::= CMPCertificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "OOBCertHash ::= SEQUENCE {\n    hashAlg     [0] AlgorithmIdentifier     OPTIONAL,\n    certId      [1] CertId                  OPTIONAL,\n    hashVal         BIT STRING",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    -- hashVal is calculated over the DER encoding of the\n    -- self-signed certificate with the identifier certID.\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "POPODecKeyChallContent ::= SEQUENCE OF Challenge\n-- One Challenge per encryption key certification request (in the\n-- same order as these requests appear in CertReqMessages).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Challenge ::= SEQUENCE {\n    owf                 AlgorithmIdentifier  OPTIONAL,",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "-- MUST be present in the first Challenge; MAY be omitted in\n-- any subsequent Challenge in POPODecKeyChallContent (if\n-- omitted, then the owf used in the immediately preceding\n-- Challenge is to be used).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    witness             OCTET STRING,\n    -- the result of applying the one-way function (owf) to a\n    -- randomly-generated INTEGER, A.  [Note that a different\n    -- INTEGER MUST be used for each Challenge.]\n    challenge           OCTET STRING\n    -- the encryption (under the public key for which the cert.\n    -- request is being made) of Rand, where Rand is specified as\n    --   Rand ::= SEQUENCE {\n    --      int      INTEGER,\n    --       - the randomly-generated INTEGER A (above)\n    --      sender   GeneralName\n    --       - the sender's name (as included in PKIHeader)\n    --   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "POPODecKeyRespContent ::= SEQUENCE OF INTEGER\n-- One INTEGER per encryption key certification request (in the\n-- same order as these requests appear in CertReqMessages).  The\n-- retrieved INTEGER A (above) is returned to the sender of the\n-- corresponding Challenge.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertRepMessage ::= SEQUENCE {\n    caPubs       [1] SEQUENCE SIZE (1..MAX) OF CMPCertificate\n                     OPTIONAL,\n    response         SEQUENCE OF CertResponse\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertResponse ::= SEQUENCE {\n    certReqId           INTEGER,\n    -- to match this response with corresponding request (a value\n    -- of -1 is to be used if certReqId is not specified in the\n    -- corresponding request)\n         status              PKIStatusInfo,\n    certifiedKeyPair    CertifiedKeyPair    OPTIONAL,\n    rspInfo             OCTET STRING        OPTIONAL\n    -- analogous to the id-regInfo-utf8Pairs string defined\n    -- for regInfo in CertReqMsg [CRMF]\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertifiedKeyPair ::= SEQUENCE {\n    certOrEncCert       CertOrEncCert,\n    privateKey      [0] EncryptedValue      OPTIONAL,\n    -- see [CRMF] for comment on encoding\n    publicationInfo [1] PKIPublicationInfo  OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertOrEncCert ::= CHOICE {\n    certificate     [0] CMPCertificate,\n    encryptedCert   [1] EncryptedValue\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "KeyRecRepContent ::= SEQUENCE {\n    status                  PKIStatusInfo,\n    newSigCert          [0] CMPCertificate OPTIONAL,\n    caCerts             [1] SEQUENCE SIZE (1..MAX) OF\n                                        CMPCertificate OPTIONAL,\n    keyPairHist         [2] SEQUENCE SIZE (1..MAX) OF\n                                        CertifiedKeyPair OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "RevReqContent ::= SEQUENCE OF RevDetails",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "RevDetails ::= SEQUENCE {\n    certDetails         CertTemplate,\n    -- allows requester to specify as much as they can about\n    -- the cert. for which revocation is requested\n    -- (e.g., for cases in which serialNumber is not available)\n    crlEntryDetails     Extensions       OPTIONAL\n    -- requested crlEntryExtensions\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "RevRepContent ::= SEQUENCE {\n    status       SEQUENCE SIZE (1..MAX) OF PKIStatusInfo,\n    -- in same order as was sent in RevReqContent\n    revCerts [0] SEQUENCE SIZE (1..MAX) OF CertId\n                                        OPTIONAL,\n    -- IDs for which revocation was requested\n    -- (same order as status)\n    crls     [1] SEQUENCE SIZE (1..MAX) OF CertificateList\n                                        OPTIONAL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " -- the resulting CRLs (there may be more than one) }",
      "ja": " - 結果のCRLS（複数ある場合があります）}"
    },
    {
      "indent": 5,
      "text": "CAKeyUpdAnnContent ::= SEQUENCE {\n    oldWithNew   CMPCertificate, -- old pub signed with new priv\n    newWithOld   CMPCertificate, -- new pub signed with old priv\n    newWithNew   CMPCertificate  -- new pub signed with new priv\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertAnnContent ::= CMPCertificate",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "RevAnnContent ::= SEQUENCE {\n    status              PKIStatus,\n    certId              CertId,\n    willBeRevokedAt     GeneralizedTime,\n    badSinceDate        GeneralizedTime,\n    crlDetails          Extensions  OPTIONAL\n    -- extra CRL details (e.g., crl number, reason, location, etc.)\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CRLAnnContent ::= SEQUENCE OF CertificateList",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertConfirmContent ::= SEQUENCE OF CertStatus",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CertStatus ::= SEQUENCE {\n   certHash    OCTET STRING,\n   -- the hash of the certificate, using the same hash algorithm\n   -- as is used to create and verify the certificate signature\n   certReqId   INTEGER,\n   -- to match this confirmation with the corresponding req/rep\n   statusInfo  PKIStatusInfo OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PKIConfirmContent ::= NULL",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "InfoTypeAndValue ::= SEQUENCE {\n    infoType               OBJECT IDENTIFIER,\n    infoValue              ANY DEFINED BY infoType  OPTIONAL\n}\n-- Example InfoTypeAndValue contents include, but are not limited\n-- to, the following (un-comment in this ASN.1 module and use as\n-- appropriate for a given environment):\n--\n--   id-it-caProtEncCert    OBJECT IDENTIFIER ::= {id-it 1}\n--      CAProtEncCertValue      ::= CMPCertificate\n--   id-it-signKeyPairTypes OBJECT IDENTIFIER ::= {id-it 2}\n--      SignKeyPairTypesValue   ::= SEQUENCE OF AlgorithmIdentifier\n--   id-it-encKeyPairTypes  OBJECT IDENTIFIER ::= {id-it 3}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "--      EncKeyPairTypesValue    ::= SEQUENCE OF AlgorithmIdentifier\n--   id-it-preferredSymmAlg OBJECT IDENTIFIER ::= {id-it 4}\n--      PreferredSymmAlgValue   ::= AlgorithmIdentifier\n--   id-it-caKeyUpdateInfo  OBJECT IDENTIFIER ::= {id-it 5}\n--      CAKeyUpdateInfoValue    ::= CAKeyUpdAnnContent\n--   id-it-currentCRL       OBJECT IDENTIFIER ::= {id-it 6}\n--      CurrentCRLValue         ::= CertificateList\n--   id-it-unsupportedOIDs  OBJECT IDENTIFIER ::= {id-it 7}\n--      UnsupportedOIDsValue    ::= SEQUENCE OF OBJECT IDENTIFIER\n--   id-it-keyPairParamReq  OBJECT IDENTIFIER ::= {id-it 10}\n--      KeyPairParamReqValue    ::= OBJECT IDENTIFIER\n--   id-it-keyPairParamRep  OBJECT IDENTIFIER ::= {id-it 11}\n--      KeyPairParamRepValue    ::= AlgorithmIdentifer\n--   id-it-revPassphrase    OBJECT IDENTIFIER ::= {id-it 12}\n--      RevPassphraseValue      ::= EncryptedValue\n--   id-it-implicitConfirm  OBJECT IDENTIFIER ::= {id-it 13}\n--      ImplicitConfirmValue    ::= NULL\n--   id-it-confirmWaitTime  OBJECT IDENTIFIER ::= {id-it 14}\n--      ConfirmWaitTimeValue    ::= GeneralizedTime\n--   id-it-origPKIMessage   OBJECT IDENTIFIER ::= {id-it 15}\n--      OrigPKIMessageValue     ::= PKIMessages\n--   id-it-suppLangTags     OBJECT IDENTIFIER ::= {id-it 16}\n--      SuppLangTagsValue       ::= SEQUENCE OF UTF8String\n--\n-- where\n--\n--   id-pkix OBJECT IDENTIFIER ::= {\n--      iso(1) identified-organization(3)\n--      dod(6) internet(1) security(5) mechanisms(5) pkix(7)}\n-- and\n--   id-it   OBJECT IDENTIFIER ::= {id-pkix 4}\n--\n--\n-- This construct MAY also be used to define new PKIX Certificate\n-- Management Protocol request and response messages, or general-\n-- purpose (e.g., announcement) messages for future needs or for\n-- specific environments.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "GenMsgContent ::= SEQUENCE OF InfoTypeAndValue",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "-- May be sent by EE, RA, or CA (depending on message content).\n-- The OPTIONAL infoValue parameter of InfoTypeAndValue will\n-- typically be omitted for some of the examples given above.\n-- The receiver is free to ignore any contained OBJ. IDs that it\n-- does not recognize. If sent from EE to CA, the empty set\n-- indicates that the CA may send\n-- any/all information that it wishes.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "GenRepContent ::= SEQUENCE OF InfoTypeAndValue\n-- Receiver MAY ignore any contained OIDs that it does not\n-- recognize.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ErrorMsgContent ::= SEQUENCE {\n    pKIStatusInfo          PKIStatusInfo,\n    errorCode              INTEGER           OPTIONAL,\n    -- implementation-specific error codes\n    errorDetails           PKIFreeText       OPTIONAL\n    -- implementation-specific error details\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PollReqContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "PollRepContent ::= SEQUENCE OF SEQUENCE {\n    certReqId              INTEGER,\n    checkAfter             INTEGER,  -- time in seconds\n    reason                 PKIFreeText OPTIONAL\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "END -- of CMP module",
      "ja": "END -CMPモジュールの"
    },
    {
      "indent": 0,
      "text": "Appendix G. Acknowledgements",
      "section_title": true,
      "ja": "付録G. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors gratefully acknowledge the contributions of various members of the IETF PKIX Working Group and the ICSA CA-talk mailing list (a list solely devoted to discussing CMP interoperability efforts). Many of these contributions significantly clarified and improved the utility of this specification. Tomi Kause thanks Vesa Suontama and Toni Tammisalo for review and comments.",
      "ja": "著者は、IETF PKIXワーキンググループとICSA CA-Talkメーリングリストのさまざまなメンバーの貢献（CMP相互運用性の取り組みの議論に専念するリスト）の貢献に感謝します。これらの貢献の多くは、この仕様の有用性を大幅に明らかにし、改善しました。Tomi Kauseは、レビューとコメントをしてくれたVesa SuontamaとToni Tammisaloに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Carlisle Adams University of Ottawa 800 King Edward Avenue P.O.Box 450, Station A Ottawa, Ontario K1N 6N5 CA",
      "ja": "カーライルアダムス大学オタワ大学800キングエドワードアベニューP.O.ボックス450、オンタリオ州オタワ駅K1N 6N5 CA"
    },
    {
      "indent": 3,
      "text": "Phone: (613) 562-5800 ext. 2345 Fax: (613) 562-5664 EMail: cadams@site.uottawa.ca",
      "ja": "電話：（613）562-5800内線2345ファックス：（613）562-5664メール：cadams@site.uottawa.ca"
    },
    {
      "indent": 3,
      "text": "Stephen Farrell Trinity College Dublin Distributed Systems Group Computer Science Department Dublin IE",
      "ja": "Stephen Farrell Trinity College Dublin Distributed Systems Groupコンピューターサイエンス部門ダブリンIE"
    },
    {
      "indent": 3,
      "text": "Phone: +353-1-608-2945\nEMail: stephen.farrell@cs.tcd.ie",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tomi Kause SSH Communications Security Corp Valimotie 17 Helsinki 00380 FI",
      "ja": "Tomi Kause SSH Communications Security Corp Valimotie 17 Helsinki 00380 fi"
    },
    {
      "indent": 3,
      "text": "Phone: +358 20 500 7415\nEMail: toka@ssh.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Tero Mononen SafeNet, Inc. Fredrikinkatu 47 Helsinki 00100 FI",
      "ja": "Tero Mononen Safenet、Inc。Fredrikinkatu 47 Helsinki 00100 fi"
    },
    {
      "indent": 3,
      "text": "Phone: +358 20 500 7814\nEMail: tmononen@safenet-inc.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2005).",
      "ja": "Copyright（c）The Internet Society（2005）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得するための試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}