{
  "title": {
    "text": "RFC 4584 - Extension to Sockets API for Mobile IPv6",
    "ja": "RFC 4584 - モバイルIPv6のソケットAPIへの拡張"
  },
  "number": 4584,
  "created_at": "2023-06-21 11:17:51.254678+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                     S. Chakrabarti\nRequest for Comments: 4584                                   E. Nordmark\nCategory: Informational                                 Sun Microsystems\n                                                               July 2006",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Extension to Sockets API for Mobile IPv6",
      "ja": "モバイルIPv6のソケットAPIへの拡張"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo provides information for the Internet community. It does not specify an Internet standard of any kind. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネットコミュニティに情報を提供します。いかなる種類のインターネット標準を指定しません。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes data structures and API support for Mobile IPv6 as an extension to the Advanced Socket API for IPv6.",
      "ja": "このドキュメントでは、IPv6の高度なソケットAPIの拡張として、モバイルIPv6のデータ構造とAPIサポートについて説明しています。"
    },
    {
      "indent": 3,
      "text": "Just as the Advanced Sockets API for IPv6 gives access to various extension headers and the ICMPv6 protocol, this document specifies the same level of access for Mobile IPv6 components. It specifies a mechanism for applications to retrieve and set information for Mobility Header messages, Home Address destination options, and Routing Header Type 2 extension headers. It also specifies the common data structures and definitions that might be used by certain advanced Mobile IPv6 socket applications.",
      "ja": "IPv6の高度なソケットAPIがさまざまな拡張ヘッダーとICMPV6プロトコルにアクセスできるように、このドキュメントは、モバイルIPv6コンポーネントの同じレベルのアクセスを指定します。モビリティヘッダーメッセージ、ホームアドレスの目的地オプション、ルーティングヘッダータイプ2拡張ヘッダーの情報を取得および設定するためのアプリケーションのメカニズムを指定します。また、特定の高度なモバイルIPv6ソケットアプリケーションで使用される可能性のある共通のデータ構造と定義も指定します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................3\n2. Applicability ...................................................4\n3. Overview ........................................................5\n4. Common Structures and Definitions ...............................6\n   4.1. The Mobility Header Data Structures ........................6\n        4.1.1. The ip6_mh Structure ................................6\n        4.1.2. Binding Refresh Request Mobility Message ............7\n        4.1.3. Home Address Test Init (HoTI) Message ...............7\n        4.1.4. Care-of Address Test Init (CoTI) Message ............7\n        4.1.5. Home Address Test (HOT) Message .....................8\n        4.1.6. Care Of Address Test (COT) Message ..................8\n        4.1.7. Binding Update Mobility Message .....................8\n        4.1.8. Binding Acknowledgement Mobility Message ............9\n        4.1.9. Binding Error Mobility Message ......................9\n        4.1.10. Mobility Option TLV data structure .................9\n        4.1.11. Mobility Option Data Structures ...................10\n               4.1.11.1. Binding Refresh Advice ...................10\n               4.1.11.2. Alternate Care-of Address ................10\n               4.1.11.3. Nonce Indices ............................10\n               4.1.11.4. Binding Authorization Data ...............10\n   4.2. Mobility Header Constants .................................10\n   4.3. IPv6 Home Address Destination Option ......................12\n   4.4. Type 2 Routing Header .....................................12\n   4.5. New ICMP Messages for Mobile IPv6 .........................13\n   4.6. IPv6 Neighbor Discovery Changes ...........................14\n5. Access to Home Address Destination Option and Routing Headers ..15\n   5.1. Routing Header Access Functions ...........................17\n   5.2. Content of Type 2 Routing Header ..........................18\n   5.3. Order of Extension Headers for Home Address\n        Destination Options .......................................19\n   5.4. Home Address Destination Option Access Functions ..........20\n   5.5. Content of Home Address Destination Option ................20\n6. Mobility Protocol Headers ......................................21\n   6.1. Receiving and Sending Mobility Header Messages ............21\n7. Protocols File .................................................22\n8. IPv4-Mapped IPv6 Addresses .....................................23\n9. Security Considerations ........................................23\n10. IANA Considerations ...........................................23\n11. Acknowledgements ..............................................23\n12. References ....................................................24\n   12.1. Normative References .....................................24\n   12.2. Informative References ...................................24",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Mobility Support in IPv6 [2] defines a new Mobility Protocol header, a Home Address destination option and a new Routing Header type. It is expected that Mobile IPv6 user-level implementations and some special applications will need to access and process these IPv6 extension headers. This document is an extension to the existing Advanced Sockets API document [1]; it addresses the Advanced IPv6 Sockets API for these new protocol elements defined by Mobile IPv6.",
      "ja": "IPv6 [2]のモビリティサポートは、新しいモビリティプロトコルヘッダー、ホームアドレスの目的地オプション、新しいルーティングヘッダータイプを定義します。モバイルIPv6ユーザーレベルの実装と一部の特別なアプリケーションは、これらのIPv6拡張ヘッダーにアクセスして処理する必要があると予想されます。このドキュメントは、既存のAdvanced Sockets APIドキュメント[1]の拡張機能です。モバイルIPv6によって定義されたこれらの新しいプロトコル要素の高度なIPv6ソケットAPIに対処します。"
    },
    {
      "indent": 3,
      "text": "The applicability of this API mainly targets user-level applications. However, it has also been shown to be useful within some Mobile IPv6 implementations; for instance, where part of the Mobile IPv6 protocol is implemented at user-level and part in the kernel. It is up to any such implementations to architect which part of the Mobile IPv6 and IP Security (IPSec) packet processing should be done at the user-level in order to meet the design needs of the particular platform and operating system.",
      "ja": "このAPIの適用性は、主にユーザーレベルのアプリケーションをターゲットにします。ただし、一部のモバイルIPv6実装では有用であることも示されています。たとえば、モバイルIPv6プロトコルの一部がユーザーレベルとカーネルの一部で実装されています。モバイルIPv6およびIPセキュリティ（IPSEC）パケット処理の一部を、特定のプラットフォームおよびオペレーティングシステムの設計ニーズを満たすために、ユーザーレベルでどの部分を実行する必要があるかが、アーキテクトにとってそのような実装次第です。"
    },
    {
      "indent": 3,
      "text": "The target user-level applications for this socket API are believed to be debugging and diagnostic applications and some policy applications that would like to receive copies of protocol information at the application layer.",
      "ja": "このソケットAPIのターゲットユーザーレベルのアプリケーションは、デバッグおよび診断アプリケーション、およびアプリケーションレイヤーでプロトコル情報のコピーを受信したいポリシーアプリケーションであると考えられています。"
    },
    {
      "indent": 3,
      "text": "The packet information and access to the extension headers (Routing header and Destination options) are specified using the \"ancillary data\" fields that were added to the 4.3BSD Reno sockets API in 1990. The reason is that these ancillary data fields are part of the Posix.1g standard and should therefore be adopted by most vendors. This document is consistent with Advanced Sockets API for IPv6 [1] in structure definitions, header files, and function definitions. Thus, the implementors of this API document are assumed to be familiar with the data structures, data sending and receiving procedures, and the IPv6 extension header access functions described in the Advanced Sockets API for IPv6 [1].",
      "ja": "拡張ヘッダーへのパケット情報とアクセス（ルーティングヘッダーと宛先オプション）は、1990年に4.3bsd Reno Sockets APIに追加された「補助データ」フィールドを使用して指定されています。その理由は、これらの補助データフィールドがの一部であるためです。posix.1g標準であるため、ほとんどのベンダーが採用する必要があります。このドキュメントは、構造定義、ヘッダーファイル、および関数定義のIPv6 [1]の高度なソケットAPIと一致しています。したがって、このAPIドキュメントの実装者は、データ構造、データ送信および受信手順、およびIPv6の高度なソケットAPIで説明されているIPv6拡張ヘッダーアクセス関数に精通していると想定されています[1]。"
    },
    {
      "indent": 3,
      "text": "Non-goals",
      "ja": "非ゴール"
    },
    {
      "indent": 3,
      "text": "This document does not address application access to either the Authentication Header or the Encapsulating Security Payload header. This document also does not address any API that might be necessary for Mobile Network [4] specific needs. Furthermore, note that this API document excludes discussion on application-level API. It assumes that address selection socket API [5] takes care of selection of care-of address or home address as the source address by the application, when source address selection is required due to the nature of the application.",
      "ja": "このドキュメントでは、認証ヘッダーまたはカプセル化セキュリティペイロードヘッダーへのアプリケーションアクセスには対応していません。このドキュメントは、モバイルネットワーク[4]特定のニーズに必要なAPIにも対応していません。さらに、このAPIドキュメントはアプリケーションレベルのAPIに関する議論を除外していることに注意してください。アドレス選択ソケットAPI [5]は、アプリケーションの性質のためにソースアドレスの選択が必要な場合、アプリケーションのソースアドレスとしてのケアのケアまたはホームアドレスの選択を処理することを想定しています。"
    },
    {
      "indent": 3,
      "text": "Providing mobility \"awareness\" to applications, such as applications' being able to tell whether the host is at home or not, is out of scope for this API.",
      "ja": "アプリケーションがホストが自宅にいるかどうかを知ることができるようなアプリケーションにモビリティを「認識」することは、このAPIの範囲外です。"
    },
    {
      "indent": 0,
      "text": "2. Applicability",
      "section_title": true,
      "ja": "2. 適用可能性"
    },
    {
      "indent": 3,
      "text": "This API document can be applied in the following cases:",
      "ja": "このAPIドキュメントは、次の場合に適用できます。"
    },
    {
      "indent": 3,
      "text": "1. User-level debugging and monitoring tools: This socket API is useful for accessing Mobility Headers, Home Address destination options and Type 2 Routing Headers . For example, mh-ping might be a monitoring tool that can process mobility headers on the receiving side to check binding status.",
      "ja": "1. ユーザーレベルのデバッグおよび監視ツール：このソケットAPIは、モビリティヘッダー、ホームアドレスの目的地オプション、タイプ2ルーティングヘッダーにアクセスするのに役立ちます。たとえば、MH-Pingは、受信側のモビリティヘッダーを処理して、バインディングステータスを確認できる監視ツールである可能性があります。"
    },
    {
      "indent": 3,
      "text": "2. Partial user-level implementation of Mobile IPv6: We assume that some implementations may choose to do the Mobility header processing at user level. In that case, this document recommends implementing at least the handling of Home Address destination options and Type 2 Routing Header in the main IP processing paths in the kernel. The API can then be used to send and receive the Mobility Header packets used for Mobile IPv6 signaling.",
      "ja": "2. モバイルIPv6の部分的なユーザーレベルの実装：一部の実装は、ユーザーレベルでモビリティヘッダー処理を行うことを選択できると仮定します。その場合、このドキュメントでは、少なくともホームアドレスの宛先オプションとタイプ2ルーティングヘッダーの処理をカーネルのメインIP処理パスに実装することを推奨しています。APIを使用して、モバイルIPv6シグナル伝達に使用されるモビリティヘッダーパケットを送信および受信できます。"
    },
    {
      "indent": 3,
      "text": "3. Complete header processing at the kernel-level: Many implementations of Mobile IPv6 [2] perform processing of Home Address destination options, Type 2 Routing Headers, and Mobility headers at the kernel level. However, the kernel keeps a copy of the received extension headers and passes them up to the API, which is used by the user-level applications purely for monitoring and debugging Mobile IPv6 packets.",
      "ja": "3. カーネルレベルでの完全なヘッダー処理：モバイルIPv6 [2]の多くの実装は、カーネルレベルでホームアドレスの宛先オプション、タイプ2ルーティングヘッダー、モビリティヘッダーの処理を実行します。ただし、カーネルは受信した拡張ヘッダーのコピーを保持し、モバイルIPv6パケットの監視とデバッグに純粋にユーザーレベルのアプリケーションで使用されるAPIに渡します。"
    },
    {
      "indent": 3,
      "text": "On an IPv6 host that does not implement Mobile IPv6, the IPv6 specification [3] requires that packets with the Home Address option or Type 2 Routing Header (where segments left is non-zero) be dropped on receipt. This means that it is not possible to implement Mobile IPv6 as an application on such a system. Thus, on such a system, the applicability of this API is limited to the first case above, enabling debugging and monitoring applications (such as tcpdump) to parse and interpret Mobile IPv6 packets.",
      "ja": "モバイルIPv6を実装していないIPv6ホストでは、IPv6仕様[3]では、ホームアドレスオプションまたはタイプ2ルーティングヘッダー（残りのセグメントがゼロ以外）を備えたパケットを受信して削除する必要があります。これは、このようなシステム上のアプリケーションとしてモバイルIPv6を実装することができないことを意味します。したがって、このようなシステムでは、このAPIの適用性は上記の最初のケースに限定されており、デバッグおよび監視アプリケーション（TCPDUMPなど）がモバイルIPv6パケットを解析して解釈できるようにします。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概要"
    },
    {
      "indent": 3,
      "text": "This document can be divided into the following parts:",
      "ja": "このドキュメントは、次の部分に分けることができます。"
    },
    {
      "indent": 3,
      "text": "1. Definitions of constants and structures for C programs that capture the Mobile IPv6 packet formats on the wire. A common definition of these is useful at least for packet snooping applications. This is captured in Section 4. In addition, Section 4 also defines data structures for Home Address destination option, Type 2 Routing Header, and new ICMPv6 messages related to Mobile IPv6.",
      "ja": "1. ワイヤー上のモバイルIPv6パケット形式をキャプチャするCプログラムの定数と構造の定義。これらの一般的な定義は、少なくともパケットスヌーピングアプリケーションに役立ちます。これはセクション4でキャプチャされます。さらに、セクション4では、モバイルIPv6に関連するホームアドレスの宛先オプション、タイプ2ルーティングヘッダー、および新しいICMPV6メッセージのデータ構造も定義しています。"
    },
    {
      "indent": 3,
      "text": "2. Notes on how to use the IPv6 Advanced API to access Home Address options and Type 2 Routing Headers. This is captured in Section 5.",
      "ja": "2. IPv6 Advanced APIを使用して、ホームアドレスオプションとタイプ2ルーティングヘッダーにアクセスする方法に関するメモ。これはセクション5でキャプチャされます。"
    },
    {
      "indent": 3,
      "text": "3. Notes on how user-level applications can observe MH (Mobility Header) packets using raw sockets (in Section 6). The IPv6 RAW socket interface described in this document allows applications to receive MH packets whether or not the system's MH processing takes place in the \"kernel\" or at the \"user space\".",
      "ja": "3. ユーザーレベルのアプリケーションが、生のソケットを使用してMH（モビリティヘッダー）パケットを観察する方法についての注意事項（セクション6）。このドキュメントで説明されているIPv6 RAWソケットインターフェイスにより、システムのMH処理が「カーネル」で行われるか「ユーザースペース」で行われるかどうかにかかわらず、アプリケーションがMHパケットを受信できます。"
    },
    {
      "indent": 3,
      "text": "4. A name is suggested for IPv6 Mobility Header protocol in /etc/ protocols (in Section 7).",
      "ja": "4. / etc /プロトコルのIPv6モビリティヘッダープロトコル（セクション7）には名前が提案されています。"
    },
    {
      "indent": 3,
      "text": "All examples in this document omit error checking in favor of brevity, as it is following the same style as the Advanced Socket API [1].",
      "ja": "このドキュメントのすべての例は、Advanced Socket APIと同じスタイルに従っているため、Brevityを支持してエラーチェックを省略します[1]。"
    },
    {
      "indent": 3,
      "text": "Note that many of the functions and socket options defined in this document may have error returns that are not defined in this document.",
      "ja": "このドキュメントで定義されている機能とソケットオプションの多くには、このドキュメントで定義されていないエラーリターンがある場合があります。"
    },
    {
      "indent": 3,
      "text": "Data types in this document follow the Posix.1g format: intN_t means a signed integer of exactly N bits (e.g., int16_t), and uintN_t means an unsigned integer of exactly N bits (e.g., uint32_t).",
      "ja": "このドキュメントのデータ型は、posix.1g形式に従います。INTN_Tは、正確なnビット（int16_tなど）の署名された整数を意味し、uintn_tは正確なnビット（例えば、uint32_t）の符号なし整数を意味します。"
    },
    {
      "indent": 3,
      "text": "Once the API specification becomes mature and is deployed, it may be formally standardized by a more appropriate body, as has been done with the Basic API [6]. However, since this specification largely builds upon the Advanced Socket API [1], such standardization would make sense only if the Advanced Socket API [1] were also standardized.",
      "ja": "API仕様が成熟して展開されると、基本的なAPI [6]で行われているように、より適切な本体によって正式に標準化される可能性があります。ただし、この仕様は主に高度なソケットAPI [1]に基づいているため、このような標準化は、高度なソケットAPI [1]も標準化された場合にのみ意味があります。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、RFC 2119に記載されているとおりに解釈されます。"
    },
    {
      "indent": 0,
      "text": "4. Common Structures and Definitions",
      "section_title": true,
      "ja": "4. 一般的な構造と定義"
    },
    {
      "indent": 3,
      "text": "In this section, the structures are specified in a way so that they maximize the probability that the compiler-layout of data structures are identical to the packet formats on the wire. However, ANSI-C provides few guarantees about the size and alignment of data structures.",
      "ja": "このセクションでは、構造を方法で指定しているため、データ構造のコンパイラレイアウトがワイヤー上のパケット形式と同じである確率を最大化します。ただし、ANSI-Cは、データ構造のサイズとアラインメントに関する保証をほとんど提供しません。"
    },
    {
      "indent": 3,
      "text": "The assumption is that the Advanced Socket API [1] will pass up the actual packet content (the wire format) in the buffer and in the ancillary data objects. Thus, if an implementor has to handle a system where the ANSI-C compiler does not and can not lay out these structures to match the wire formats in RFC 3775 [2], the structures defined by this API can not be supported on such a system.",
      "ja": "仮定は、高度なソケットAPI [1]がバッファーおよび補助データオブジェクトの実際のパケットコンテンツ（ワイヤ形式）を渡すことです。したがって、実装者がANSI-CコンパイラがRFC 3775 [2]のワイヤー形式に一致するようにこれらの構造をレイアウトしないシステムを処理する必要がある場合、このAPIによって定義された構造はそのようなことでサポートできませんシステム。"
    },
    {
      "indent": 3,
      "text": "The constants and structures shown below are in network byte order, so an application needs to perform the appropriate byte order conversion (ntohs(), etc) when necessary.",
      "ja": "以下に示す定数と構造はネットワークバイトの順序であるため、必要に応じて適切なバイト順序変換（NTOHS（）など）を実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "The structures and constants below will be included when the (new) header file is included : <netinet/ip6mh.h>",
      "ja": "（新しい）ヘッダーファイルが含まれている場合、以下の構造と定数が含まれます。<netinet/ip6mh.h>"
    },
    {
      "indent": 0,
      "text": "4.1. The Mobility Header Data Structures",
      "section_title": true,
      "ja": "4.1. モビリティヘッダーデータ構造"
    },
    {
      "indent": 0,
      "text": "4.1.1. The ip6_mh Structure",
      "section_title": true,
      "ja": "4.1.1. IP6_MH構造"
    },
    {
      "indent": 3,
      "text": "The following structure is defined as a result of including <netinet/ip6mh.h>. This is the fixed part of the Mobility Header. Different Mobility message types are defined in Mobile IPv6 [2]. For portability and alignment reasons, each mobility message type includes the mobility header fields instead of including the ip6_mh structure, followed by the message-specific fields.",
      "ja": "次の構造は、<netinet/ip6mh.h>を含めた結果として定義されます。これは、モビリティヘッダーの固定部分です。さまざまなモビリティメッセージタイプがモバイルIPv6で定義されています[2]。移植性とアラインメントの理由のために、各モビリティメッセージタイプには、IP6_MH構造を含める代わりに、モビリティヘッダーフィールドが含まれ、その後にメッセージ固有のフィールドが含まれます。"
    },
    {
      "indent": 6,
      "text": "struct  ip6_mh {\n    uint8_t    ip6mh_proto;   /* NO_NXTHDR by default */\n    uint8_t    ip6mh_hdrlen;  /* Header Len in unit of 8 Octets\n                                 excluding the first 8 Octets */\n    uint8_t    ip6mh_type;    /* Type of Mobility Header */\n    uint8_t    ip6mh_reserved;   /* Reserved */\n    uint16_t   ip6mh_cksum;   /* Mobility Header Checksum */\n    /* Followed by type specific messages */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.2. Binding Refresh Request Mobility Message",
      "section_title": true,
      "ja": "4.1.2. バインディングリフルディングリクエストモビリティメッセージ"
    },
    {
      "indent": 6,
      "text": "struct  ip6_mh_binding_request {\n    uint8_t    ip6mhbr_proto;\n    uint8_t    ip6mhbr_hdrlen;\n    uint8_t    ip6mhbr_type;\n    uint8_t    ip6mhbr_reserved;\n    uint16_t   ip6mhbr_cksum;\n    uint16_t   ip6mhbr_reserved2;\n    /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.3. Home Address Test Init (HoTI) Message",
      "section_title": true,
      "ja": "4.1.3. ホームアドレステストinit（hoti）メッセージ"
    },
    {
      "indent": 6,
      "text": "struct   ip6_mh_home_test_init {\n   uint8_t    ip6mhhti_proto;\n   uint8_t    ip6mhhti_hdrlen;\n   uint8_t    ip6mhhti_type;\n   uint8_t    ip6mhhti_reserved;\n   uint16_t   ip6mhhti_cksum;\n   uint16_t   ip6mhhti_reserved2;\n   uint32_t   ip6mhhti_cookie[2]; /* 64 bit Cookie by MN */\n   /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.4. Care-of Address Test Init (CoTI) Message",
      "section_title": true,
      "ja": "4.1.4. アドレステストINIT（COTI）メッセージ"
    },
    {
      "indent": 6,
      "text": "struct   ip6_mh_careof_test_init {\n   uint8_t    ip6mhcti_proto;\n   uint8_t    ip6mhcti_hdrlen;\n   uint8_t    ip6mhcti_type;\n   uint8_t    ip6mhcti_reserved;\n   uint16_t   ip6mhcti_cksum;\n   uint16_t   ip6mhcti_reserved2;\n   uint32_t   ip6mhcti_cookie[2]; /* 64 bit Cookie by MN */\n   /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.5. Home Address Test (HOT) Message",
      "section_title": true,
      "ja": "4.1.5. ホームアドレステスト（ホット）メッセージ"
    },
    {
      "indent": 6,
      "text": " struct  ip6_mh_home_test {\n    uint8_t    ip6mhht_proto;\n    uint8_t    ip6mhht_hdrlen;\n    uint8_t    ip6mhht_type;\n    uint8_t    ip6mhht_reserved;\n    uint16_t   ip6mhht_cksum;\n    uint16_t   ip6mhht_nonce_index;\n    uint32_t   ip6mhht_cookie[2];    /* Cookie from HOTI msg */\n    uint32_t   ip6mhht_keygen[2];  /* 64 Bit Key by CN */\n    /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.6. Care Of Address Test (COT) Message",
      "section_title": true,
      "ja": "4.1.6. アドレステスト（COT）メッセージのケア"
    },
    {
      "indent": 6,
      "text": "struct  ip6_mh_careof_test {\n   uint8_t    ip6mhct_proto;\n   uint8_t    ip6mhct_hdrlen;\n   uint8_t    ip6mhct_type;\n   uint8_t    ip6mhct_reserved;\n   uint16_t   ip6mhct_cksum;\n   uint16_t   ip6mhct_nonce_index;\n   uint32_t   ip6mhct_cookie[2]; /* Cookie from COTI message */\n   uint32_t   ip6mhct_keygen[2];  /* 64bit key by CN */\n   /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.7. Binding Update Mobility Message",
      "section_title": true,
      "ja": "4.1.7. バインディングアップデートモビリティメッセージ"
    },
    {
      "indent": 6,
      "text": "struct ip6_mh_binding_update {\n    uint8_t     ip6mhbu_proto;\n    uint8_t     ip6mhbu_hdrlen;\n    uint8_t     ip6mhbu_type;\n    uint8_t     ip6mhbu_reserved;\n    uint16_t    ip6mhbu_cksum;\n    uint16_t    ip6mhbu_seqno;      /* Sequence Number */\n    uint16_t    ip6mhbu_flags;\n    uint16_t    ip6mhbu_lifetime; /* Time in unit of 4 sec */\n    /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Binding Update Flags, in network byte-order */\n#define IP6_MH_BU_ACK    0x8000  /* Request a binding ack */\n#define IP6_MH_BU_HOME   0x4000  /* Home Registration */\n#define IP6_MH_BU_LLOCAL 0x2000  /* Link-local compatibility */\n#define IP6_MH_BU_KEYM   0x1000  /* Key management mobility  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.8. Binding Acknowledgement Mobility Message",
      "section_title": true,
      "ja": "4.1.8. 拘束力のある確認モビリティメッセージ"
    },
    {
      "indent": 6,
      "text": "struct  ip6_mh_binding_ack {\n   uint8_t   ip6mhba_proto;\n   uint8_t   ip6mhba_hdrlen;\n   uint8_t   ip6mhba_type;\n   uint8_t   ip6mhba_reserved;\n   uint16_t  ip6mhba_cksum;\n   uint8_t   ip6mhba_status;    /* Status code */\n   uint8_t   ip6mhba_flags;\n   uint16_t  ip6mhba_seqno;\n   uint16_t  ip6mhba_lifetime;\n   /* Followed by optional Mobility Options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Binding Acknowledgement Flags */\n#define IP6_MH_BA_KEYM       0x80  /* Key management mobility */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.9. Binding Error Mobility Message",
      "section_title": true,
      "ja": "4.1.9. バインディングエラーモビリティメッセージ"
    },
    {
      "indent": 7,
      "text": "struct   ip6_mh_binding_error {\n   uint8_t   ip6mhbe_proto;\n   uint8_t   ip6mhbe_hdrlen;\n   uint8_t   ip6mhbe_type;\n   uint8_t   ip6mhbe_reserved;\n   uint16_t  ip6mhbe_cksum;\n   uint8_t   ip6mhbe_status;  /* Error Status */\n   uint8_t   ip6mhbe_reserved2;\n   struct in6_addr ip6mhbe_homeaddr;\n   /* Followed by optional Mobility Options */\n };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.10. Mobility Option TLV data structure",
      "section_title": true,
      "ja": "4.1.10. モビリティオプションTLVデータ構造"
    },
    {
      "indent": 6,
      "text": "struct   ip6_mh_opt {\n   uint8_t    ip6mhopt_type;   /* Option Type */\n   uint8_t    ip6mhopt_len;    /* Option Length */\n   /* Followed by variable length Option Data in bytes */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.11. Mobility Option Data Structures",
      "section_title": true,
      "ja": "4.1.11. モビリティオプションデータ構造"
    },
    {
      "indent": 0,
      "text": "4.1.11.1. Binding Refresh Advice",
      "section_title": true,
      "ja": "4.1.11.1. バインディングリフレッシュアドバイス"
    },
    {
      "indent": 6,
      "text": "struct ip6_mh_opt_refresh_advice {\n    uint8_t  ip6mora_type;\n    uint8_t  ip6mora_len;\n    uint16_t ip6mora_interval; /* Refresh interval in 4 sec */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.11.2. Alternate Care-of Address",
      "section_title": true,
      "ja": "4.1.11.2. 代替の住所"
    },
    {
      "indent": 6,
      "text": "struct ip6_mh_opt_altcoa {\n    uint8_t ip6moa_type;\n    uint8_t ip6moa_len;\n    struct in6_addr ip6moa_addr; /* Alternate CoA */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.11.3. Nonce Indices",
      "section_title": true,
      "ja": "4.1.11.3. ノンセインデックス"
    },
    {
      "indent": 6,
      "text": "struct ip6_mh_opt_nonce_index {\n    uint8_t ip6moni_type;\n    uint8_t ip6moni_len;\n    uint16_t ip6moni_home_nonce;\n    uint16_t ip6moni_coa_nonce;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.11.4. Binding Authorization Data",
      "section_title": true,
      "ja": "4.1.11.4. 拘束力のある承認データ"
    },
    {
      "indent": 6,
      "text": "struct ip6_mh_opt_auth_data {\n    uint8_t ip6moad_type;\n    uint8_t ip6moad_len;\n    uint8_t ip6moad_data[12];\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.2. Mobility Header Constants",
      "section_title": true,
      "ja": "4.2. モビリティヘッダー定数"
    },
    {
      "indent": 3,
      "text": "IPv6 Next Header Value for Mobility:",
      "ja": "IPv6モビリティの次のヘッダー値："
    },
    {
      "indent": 6,
      "text": "<netinet/in.h>",
      "ja": "<netinet/in.h>"
    },
    {
      "indent": 6,
      "text": "#define IPPROTO_MH       135 /* IPv6 Mobility Header: IANA */\n      Mobility Header Message Types:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "<netinet/ip6mh.h>",
      "ja": "<netinet/ip6mh.h>"
    },
    {
      "indent": 6,
      "text": "#define IP6_MH_TYPE_BRR       0   /* Binding Refresh Request */\n#define IP6_MH_TYPE_HOTI      1   /* HOTI Message   */\n#define IP6_MH_TYPE_COTI      2   /* COTI Message  */\n#define IP6_MH_TYPE_HOT       3   /* HOT Message   */\n#define IP6_MH_TYPE_COT       4   /* COT Message  */\n#define IP6_MH_TYPE_BU        5   /* Binding Update */\n#define IP6_MH_TYPE_BACK      6   /* Binding ACK */\n#define IP6_MH_TYPE_BERROR    7   /* Binding Error */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mobility Header Message Option Types:",
      "ja": "モビリティヘッダーメッセージオプションタイプ："
    },
    {
      "indent": 3,
      "text": "<netinet/ip6mh.h>",
      "ja": "<netinet/ip6mh.h>"
    },
    {
      "indent": 6,
      "text": "#define  IP6_MHOPT_PAD1       0x00  /* PAD1 */\n#define  IP6_MHOPT_PADN       0x01  /* PADN */\n#define  IP6_MHOPT_BREFRESH   0x02  /* Binding Refresh */\n#define  IP6_MHOPT_ALTCOA     0x03  /* Alternate COA */\n#define  IP6_MHOPT_NONCEID    0x04  /* Nonce Index */\n#define  IP6_MHOPT_BAUTH      0x05  /* Binding Auth Data */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Status values accompanied with Mobility Binding Acknowledgement:",
      "ja": "モビリティバインディングの承認を伴うステータス値："
    },
    {
      "indent": 3,
      "text": "<netinet/ip6mh.h>",
      "ja": "<netinet/ip6mh.h>"
    },
    {
      "indent": 6,
      "text": "#define IP6_MH_BAS_ACCEPTED          0   /* BU accepted */\n#define IP6_MH_BAS_PRFX_DISCOV       1   /* Accepted, but prefix\n                                            discovery Required */\n#define IP6_MH_BAS_UNSPECIFIED       128 /* Reason unspecified */\n#define IP6_MH_BAS_PROHIBIT          129 /* Administratively\n                                            prohibited */\n#define IP6_MH_BAS_INSUFFICIENT      130 /* Insufficient\n                                            resources */\n#define IP6_MH_BAS_HA_NOT_SUPPORTED  131 /* HA registration not\n                                            supported */\n#define IP6_MH_BAS_NOT_HOME_SUBNET   132  /* Not Home subnet */\n#define IP6_MH_BAS_NOT_HA            133  /* Not HA for this\n                                             mobile node */\n#define IP6_MH_BAS_DAD_FAILED        134  /* DAD failed */\n#define IP6_MH_BAS_SEQNO_BAD         135  /* Sequence number out\n                                             of range */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define IP6_MH_BAS_HOME_NI_EXPIRED   136  /* Expired Home nonce\n                                             index */\n#define IP6_MH_BAS_COA_NI_EXPIRED    137  /* Expired Care-of\n                                             nonce index */\n#define IP6_MH_BAS_NI_EXPIRED        138  /* Expired Nonce\n                                             Indices */\n#define IP6_MH_BAS_REG_NOT_ALLOWED   139  /* Registration type\n                                             change disallowed */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Status values for the Binding Error mobility messages:",
      "ja": "バインディングエラーモビリティメッセージのステータス値："
    },
    {
      "indent": 3,
      "text": "<netinet/ip6mh.h>",
      "ja": "<netinet/ip6mh.h>"
    },
    {
      "indent": 6,
      "text": "#define IP6_MH_BES_UNKNOWN_HAO    1 /* Unknown binding for HOA */\n#define IP6_MH_BES_UNKNOWN_MH     2 /* Unknown MH Type */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3. IPv6 Home Address Destination Option",
      "section_title": true,
      "ja": "4.3. IPv6ホームアドレス宛先オプション"
    },
    {
      "indent": 6,
      "text": "Due to alignment issues in the compiler, and the alignment requirements for this option, the included IPv6 address must be specified as an array of 16 octets.",
      "ja": "コンパイラのアラインメントの問題と、このオプションのアラインメント要件により、付属のIPv6アドレスは16オクテットの配列として指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>",
      "ja": "<netinet/ip6.h>"
    },
    {
      "indent": 6,
      "text": "/* Home Address Destination Option */\nstruct ip6_opt_home_address {\n     uint8_t           ip6oha_type;\n     uint8_t           ip6oha_len;\n     uint8_t           ip6oha_addr[16];   /* Home Address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Option Type Definition:",
      "ja": "オプションタイプ定義："
    },
    {
      "indent": 3,
      "text": "#define IP6OPT_HOME_ADDRESS        0xc9    /* 11 0 01001 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.4. Type 2 Routing Header",
      "section_title": true,
      "ja": "4.4. タイプ2ルーティングヘッダー"
    },
    {
      "indent": 6,
      "text": "<netinet/ip6.h>",
      "ja": "<netinet/ip6.h>"
    },
    {
      "indent": 6,
      "text": "/* Type 2 Routing header for Mobile IPv6 */\nstruct ip6_rthdr2 {\n     uint8_t  ip6r2_nxt;       /* next header */\n     uint8_t  ip6r2_len;       /* length : always 2 */\n     uint8_t  ip6r2_type;      /* always 2 */\n     uint8_t  ip6r2_segleft;   /* segments left: always 1 */\n     uint32_t ip6r2_reserved;  /* reserved field */\n     struct in6_addr ip6r2_homeaddr;  /* Home Address */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.5. New ICMP Messages for Mobile IPv6",
      "section_title": true,
      "ja": "4.5. モバイルIPv6用の新しいICMPメッセージ"
    },
    {
      "indent": 3,
      "text": "ICMP message types and definitions for Mobile IPv6 are defined in <netinet/icmp6.h>.",
      "ja": "モバイルIPv6のICMPメッセージタイプと定義は、<NetInet/ICMP6.H>で定義されています。"
    },
    {
      "indent": 6,
      "text": "#define MIP6_HA_DISCOVERY_REQUEST    144\n#define MIP6_HA_DISCOVERY_REPLY      145\n#define MIP6_PREFIX_SOLICIT          146\n#define MIP6_PREFIX_ADVERT           147",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following data structures can be used for the ICMP message types discussed in Sections 6.5 through 6.8 in the base Mobile IPv6 [2] specification.",
      "ja": "以下のデータ構造は、ベースモバイルIPv6 [2]仕様のセクション6.5〜6.8で説明したICMPメッセージタイプに使用できます。"
    },
    {
      "indent": 6,
      "text": "struct mip6_dhaad_req {    /* Dynamic HA Address Discovery */\n       struct  icmp6_hdr   mip6_dhreq_hdr;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define mip6_dhreq_type mip6_dhreq_hdr.icmp6_type #define mip6_dhreq_code mip6_dhreq_hdr.icmp6_code #define mip6_dhreq_cksum mip6_dhreq_hdr.icmp6_cksum #define mip6_dhreq_id mip6_dhreq_hdr.icmp6_data16[0] #define mip6_dhreq_reserved mip6_dhreq_hdr.icmp6_data16[1]",
      "ja": "#define mip6_dhreq_type mip6_dhreq_hdr.icmp6_type #define mip6_dhreq_code mip6_dhreq_hdr.icmp6_code #define mip6_dhreq_ckksum mip66_dhr.imp6_def6_def6_def6_def6def6_dhdhreq_dhdhreq_dhdhdhreq_dhdhreq_dhdhreq_dhreq_dhdhp6_def6def6_dhedp6_def6_def6_def6_def6_def6_def6_defcum _dhreq_hdr.icmp6_data16 [0] #define mip6_dhreq_reserved mip6_dhreq_hdr.icmp6_data16 [1]"
    },
    {
      "indent": 6,
      "text": "struct mip6_dhaad_rep {    /* HA Address Discovery Reply */\n       struct icmp6_hdr   mip6_dhrep_hdr;\n       /* Followed by Home Agent IPv6 addresses */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define mip6_dhrep_type mip6_dhrep_hdr.icmp6_type #define mip6_dhrep_code mip6_dhrep_hdr.icmp6_code #define mip6_dhrep_cksum mip6_dhrep_hdr.icmp6_cksum #define mip6_dhrep_id mip6_dhrep_hdr.icmp6_data16[0] #define mip6_dhrep_reserved mip6_dhrep_hdr.icmp6_data16[1]",
      "ja": "#define mip6_dhrep_type mip6_dhrep_hdr.icmp6_type #define mip6_dhrep_code mip6_dhrep_hdr.icmp6_code #define mip6_dhrep_cksum mip6_dhrep_hdr.icmp6_cksum #define mip6_dhrep_id mip6_dhrep_hdr.icmp6_data16[0] #define mip6_dhrep_reserved mip6_dhrep_hdr.icmp6_data16[1]"
    },
    {
      "indent": 6,
      "text": "struct mip6_prefix_solicit {   /* Mobile Prefix Solicitation */\n       struct icmp6_hdr     mip6_ps_hdr;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define  mip6_ps_type          mip6_ps_hdr.icmp6_type\n#define  mip6_ps_code          mip6_ps_hdr.icmp6_code\n#define  mip6_ps_cksum         mip6_ps_hdr.icmp6_cksum\n#define  mip6_ps_id            mip6_ps_hdr.icmp6_data16[0]\n#define  mip6_ps_reserved      mip6_ps_hdr.icmp6_data16[1]\n      struct mip6_prefix_advert {  /* Mobile Prefix Advertisements */\n       struct  icmp6_hdr   mip6_pa_hdr;\n        /* Followed by one or more PI options */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "#define  mip6_pa_type            mip6_pa_hdr.icmp6_type\n#define  mip6_pa_code            mip6_pa_hdr.icmp6_code\n#define  mip6_pa_cksum           mip6_pa_hdr.icmp6_cksum\n#define  mip6_pa_id              mip6_pa_hdr.icmp6_data16[0]\n#define  mip6_pa_flags_reserved  mip6_pa_hdr.icmp6_data16[1]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "/* Mobile Prefix Advertisement Flags in network-byte order */\n #define  MIP6_PA_FLAG_MANAGED    0x8000\n #define  MIP6_PA_FLAG_OTHER      0x4000",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Prefix options are defined in IPv6 Advanced Socket API [1]. The Mobile IPv6 Base specification [2] describes the modified behavior in the 'Modifications to IPv6 Neighbor Discovery' section. Prefix Options for Mobile IP are defined in the following section.",
      "ja": "プレフィックスオプションは、IPv6 Advanced Socket API [1]で定義されています。モバイルIPv6ベース仕様[2]は、「IPv6 Neighbor Discoveryへの変更」セクションの変更された動作について説明しています。モバイルIPのプレフィックスオプションは、次のセクションで定義されています。"
    },
    {
      "indent": 0,
      "text": "4.6. IPv6 Neighbor Discovery Changes",
      "section_title": true,
      "ja": "4.6. "
    },
    {
      "indent": 3,
      "text": "IPv6 Neighbor Discovery changes are also defined in <netinet/icmp6.h>.",
      "ja": "IPv6ネイバーディスカバリーの変更は、<netinet/icmp6.h>でも定義されています。"
    },
    {
      "indent": 6,
      "text": "New 'Home Agent' flag in router advertisement:  #define\nND_RA_FLAG_HOMEAGENT   0x20  /* Home Agent flag in RA */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "New Router flag with prefix information of the home agent:\n#define  ND_OPT_PI_FLAG_ROUTER  0x20  /* Router flag in PI */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As per the Mobile IPv6 specification [2], Section 7.2, a Home Agent MUST include at least one prefix option with the Router Address (R) bit set. Advanced Socket API [1] defines data structure for prefix option as follows:",
      "ja": "モバイルIPv6仕様[2]、セクション7.2に従って、ホームエージェントには、ルーターアドレス（R）ビットセットに少なくとも1つのプレフィックスオプションを含める必要があります。Advanced Socket API [1]は、プレフィックスオプションのデータ構造を次のように定義します。"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_prefix_info {    /* prefix information */\n     uint8_t   nd_opt_pi_type;\n     uint8_t   nd_opt_pi_len;\n     uint8_t   nd_opt_pi_prefix_len;\n     uint8_t   nd_opt_pi_flags_reserved;\n     uint32_t  nd_opt_pi_valid_time;\n     uint32_t  nd_opt_pi_preferred_time;\n     uint32_t  nd_opt_pi_reserved2;\n     struct in6_addr  nd_opt_pi_prefix;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "New advertisement interval option and home agent information options are defined in Mobile IPv6 [2] base specification.",
      "ja": "新しい広告間隔オプションとホームエージェント情報オプションは、モバイルIPv6 [2]ベース仕様で定義されています。"
    },
    {
      "indent": 6,
      "text": "struct nd_opt_adv_interval { /* Advertisement interval option */\n     uint8_t        nd_opt_ai_type;\n     uint8_t        nd_opt_ai_len;\n     uint16_t       nd_opt_ai_reserved;\n     uint32_t       nd_opt_ai_interval;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The option types for the new Mobile IPv6 specific options:",
      "ja": "新しいモバイルIPv6固有のオプションのオプションタイプ："
    },
    {
      "indent": 6,
      "text": "#define  ND_OPT_ADV_INTERVAL    7     /* Adv Interval Option  */\n#define  ND_OPT_HA_INFORMATION  8     /* HA Information option */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "struct nd_opt_homeagent_info {  /* Home Agent information */\n   uint8_t        nd_opt_hai_type;\n   uint8_t        nd_opt_hai_len;\n   uint16_t       nd_opt_hai_reserved;\n   uint16_t       nd_opt_hai_preference;\n   uint16_t       nd_opt_hai_lifetime;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5. Access to Home Address Destination Option and Routing Headers",
      "section_title": true,
      "ja": "5. ホームアドレスの宛先オプションとルーティングヘッダーへのアクセス"
    },
    {
      "indent": 3,
      "text": "Applications that need to be able to access Home Address destination option and Type 2 Routing Header information can do so by setting the appropriate setsockopt option and using ancillary data objects. The order of extension headers is defined in Mobile IPv6 [2] when an IPv6 packet with a Home Address Destination Option is sent with other possible extension headers. Section 5.3 elaborates on the extension header order when all possible cases are present.",
      "ja": "適切なSetSockoptオプションを設定し、補助データオブジェクトを使用することにより、ホームアドレスの宛先オプションとタイプ2のルーティングヘッダー情報にアクセスできる必要があるアプリケーションは、これを行うことができます。拡張ヘッダーの順序は、モバイルIPv6 [2]で定義されます。ホームアドレスの宛先オプションを備えたIPv6パケットが他の可能な拡張ヘッダーとともに送信されます。セクション5.3は、可能なすべてのケースが存在する場合、拡張ヘッダー順序で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "This document does not recommend that the user-level program set the Home Address destination option or Type 2 Routing Header option; however, for clarity it defines the order of extension headers. See Section 2 of this document for appropriate usage of sending and receiving of Home Address destination options and Type 2 Routing Header extension headers.",
      "ja": "このドキュメントでは、ユーザーレベルのプログラムがホームアドレスの宛先オプションまたはタイプ2ルーティングヘッダーオプションを設定することをお勧めしません。ただし、明確にするために、拡張ヘッダーの順序を定義します。このドキュメントのセクション2を参照して、ホームアドレスの目的地オプションとタイプ2ルーティングヘッダー拡張ヘッダーの送信と受信の適切な使用法を参照してください。"
    },
    {
      "indent": 3,
      "text": "This document defines a new socket option, IPV6_MIPDSTOPTS for sending Home Address destination options. In order to receive a Home Address destination option or Type 2 Route Header, applications must call setsockopt() to turn on the corresponding flag as described in IPv6 Advanced Socket API [1] ( for brevity, error checking is not performed in the examples):",
      "ja": "このドキュメントでは、新しいソケットオプションであるIPv6_MipdStoptsを定義して、住所アドレスの宛先オプションを送信します。ホームアドレスの宛先オプションまたはタイプ2ルートヘッダーを受信するには、アプリケーションがSetSockopt（）を呼び出して、IPv6 Advanced Socket API [1]で説明されている対応するフラグをオンにする必要があります（簡潔にするために、例ではエラーチェックは実行されません）："
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "int on = 1;"
    },
    {
      "indent": 6,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_RECVRTHDR,    &on, sizeof(on));\nsetsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS,\n             &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When any of these options are enabled, the corresponding data is returned as control information by recvmsg(), as one or more ancillary data objects. Receiving the above information for TCP applications is not defined in this document (see Section 4.1 of Advanced Sockets API for IPv6 [1]).",
      "ja": "これらのオプションのいずれかが有効になっている場合、対応するデータは、1つ以上の補助データオブジェクトとして、Recvmsg（）による制御情報として返されます。TCPアプリケーションの上記の情報を受信することは、このドキュメントでは定義されていません（IPv6 [1]の高度なソケットAPIのセクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Note that if the IP implementation on the host does not implement the handling of Type 2 Routing Headers or Home Address options, per RFC 2460 [3] the IP stack is required to drop the packet. Thus, receiving Home Address destination option and Type 2 Routing Header at the application layer requires implementation of respective extension headers at the IP layer in the kernel, as defined in RFC3775 [2].",
      "ja": "ホストのIP実装がタイプ2ルーティングヘッダーまたはホームアドレスオプションの処理を実装していない場合、RFC 2460 [3]ごとにパケットをドロップするにはIPスタックが必要であることに注意してください。したがって、アプリケーションレイヤーでホームアドレスの宛先オプションとタイプ2ルーティングヘッダーを受信するには、RFC3775 [2]で定義されているように、カーネルのIPレイヤーでそれぞれの拡張ヘッダーを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "For receiving the Home Address destination option header, the Mobile IPv6 implementation SHOULD follow the initial processing rules of the Home Address destination option (Section 9.3.1 of Mobile IPv6 [2]) before passing the information to the API level. This includes initial processing of IPSec authentication data in a packet when it exists. Each Destination options header is returned as one ancillary data object described by a cmsghdr structure with cmsg_level set to IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.",
      "ja": "ホームアドレスの宛先オプションヘッダーを受信するには、モバイルIPv6の実装は、情報をAPIレベルに渡す前に、ホームアドレス宛先オプション（モバイルIPv6 [2]のセクション9.3.1）の初期処理ルールに従う必要があります。これには、IPSEC認証データが存在するときのIPSEC認証データの初期処理が含まれます。各宛先オプションヘッダーは、CMSG_LEVELがIPPROTO_IPV6に設定されたCMSGHDR構造とIPv6_DSTOPTSに設定されたCMSG_TYPEを使用して、CMSGHDR構造によって記述された1つの補助データオブジェクトとして返されます。"
    },
    {
      "indent": 3,
      "text": "For sending the Home Address destination option, ancillary data can be used to specify the option content for a single datagram. This applies only to datagram and raw sockets, not to TCP sockets. The Advanced API [1] document restricts one IPV6_xxx ancillary data object for a particular extension header in the control buffer. Thus, there would be a single ancillary data object for the Home address destination option in an ancillary data buffer. If multiple destination options are present, then the header order should be in compliance with Section 6.3 and 9.3.2 of the Mobile IPv6 [2] base specification.",
      "ja": "ホームアドレスの宛先オプションを送信するには、補助データを使用して、単一のデータグラムのオプションコンテンツを指定できます。これは、TCPソケットではなく、データグラムと生のソケットにのみ適用されます。Advanced API [1]ドキュメントは、コントロールバッファーの特定の拡張ヘッダーのIPv6_xxx補助データオブジェクトを1つ制限します。したがって、補助データバッファにホームアドレス宛先オプションには、単一の補助データオブジェクトがあります。複数の宛先オプションが存在する場合、ヘッダー順序は、モバイルIPv6 [2]ベース仕様のセクション6.3および9.3.2に準拠する必要があります。"
    },
    {
      "indent": 3,
      "text": "For TCP data packets with the Home Address destination option, the \"sticky\" option may be used for all transmitted packets. The application can remove the sticky Home Destination option header by calling setsockopt() for IPV6_MIPDSTOPTS with a zero option length.",
      "ja": "Home Address Destinationオプションを備えたTCPデータパケットの場合、すべての送信されたパケットに「粘着性」オプションを使用できます。アプリケーションは、オプションの長さがゼロのIPv6_mipdstoptsのSetSockopt（）を呼び出すことにより、Sticky Home Destinationオプションヘッダーを削除できます。"
    },
    {
      "indent": 3,
      "text": "Note that Section 2 of this document does not encourage setting the Home Address destination option at the user level. A Mobile IPv6 implementation should set and process the Home Address destination option and Routing Header Type 2 at the kernel level. The setting of Routing Header Type 2 and the Home Address destination option are described in this document for completeness and flexibility to use them in the future, if there is a need.",
      "ja": "このドキュメントのセクション2では、ユーザーレベルでホームアドレスの宛先オプションを設定することは奨励されていないことに注意してください。モバイルIPv6の実装では、ホームアドレスの宛先オプションを設定および処理し、カーネルレベルでヘッダータイプ2をルーティングする必要があります。ルーティングヘッダータイプ2とホームアドレスの宛先オプションの設定については、このドキュメントで説明されており、必要に応じて将来使用するための完全性と柔軟性について説明されています。"
    },
    {
      "indent": 3,
      "text": "The following socket option parameters and cmsghdr fields may be used for sending (although not a recommended usage):",
      "ja": "次のソケットオプションパラメーターとCMSGHDRフィールドは、送信に使用できます（推奨される使用法ではありませんが）："
    },
    {
      "indent": 6,
      "text": "opt level/    optname/          optval/\ncmsg_level    cmsg_type         cmsg_data[]\n------------  ------------      ------------------------\nIPPROTO_IPV6  IPV6_MIPDSTOPTS      ip6_dest structure\nIPPROTO_IPV6  IPV6_RTHDR           ip6_rthdr structure",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Some IPv6 implementations may support \"sticky\" options [1] for the IPv6 destination option for datagram and RAW sockets.",
      "ja": "一部のIPv6実装では、データグラムと生ソケットのIPv6宛先オプションの「粘着性」オプション[1]をサポートする場合があります。"
    },
    {
      "indent": 3,
      "text": "Behavior of Legacy IPv6 Socket Applications:",
      "ja": "レガシーIPv6ソケットアプリケーションの動作："
    },
    {
      "indent": 3,
      "text": "Legacy IPv6 applications/implementations using the Advanced Socket API [1] mechanisms, upon receiving Home Address destination options or Routing headers(Type 2), will discard the packet as per Sections 4.2 and 4.4 of IPV6 Protocol [3] specification, respectively; otherwise, they should properly handle the Home Address destination option and the Routing Header Type 2 specified in this document.",
      "ja": "LEGACY IPv6アプリケーション/実装は、高度なソケットAPI [1]メカニズムを使用して、ホームアドレスの目的地オプションまたはルーティングヘッダー（タイプ2）を受信すると、IPv6プロトコル[3]仕様のセクション4.2および4.4に従ってパケットを破棄します。それ以外の場合は、このドキュメントで指定されたホームアドレスの宛先オプションとルーティングヘッダータイプ2を適切に処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "5.1. Routing Header Access Functions",
      "section_title": true,
      "ja": "5.1. ルーティングヘッダーアクセス機能"
    },
    {
      "indent": 3,
      "text": "IPV6 Protocol [3] defines a Routing header extension header for Type 0. Thus, in order to access the IPv6 Routing header Type 2 extension header, one MUST use type = 2 and segment = 1. The following existing functions defined in Advanced API for IPv6 Sockets [1] are supported for Mobile IPv6 applications for sending and receiving Routing Header Type 2 headers:",
      "ja": "IPv6プロトコル[3]は、タイプ0のルーティングヘッダー拡張ヘッダーを定義します。したがって、IPv6ルーティングヘッダータイプ2拡張ヘッダーにアクセスするには、タイプ= 2およびセグメント= 1を使用する必要があります。IPv6ソケット[1]は、ルーティングヘッダータイプ2ヘッダーを送信および受信するためのモバイルIPv6アプリケーションでサポートされています。"
    },
    {
      "indent": 3,
      "text": "For Sending:",
      "ja": "発送用："
    },
    {
      "indent": 5,
      "text": "size_t inet6_rth_space(int type, int segments);\nvoid *inet6_rth_init(void *bp, int bp_len, int type, int segments);\nint inet6_rth_add(void *bp, const struct in6_addr *addr);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For Receiving:",
      "ja": "受信のため："
    },
    {
      "indent": 6,
      "text": "int inet6_rth_segments(const void *bp);\nstruct in6_addr *inet6_rth_getaddr(const void *bp, int index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "NOTE: Reversing operation is not possible using the Route Header Type 2 extension header. Thus, inet6_rth_reverse() is not used.",
      "ja": "注：ルートヘッダータイプ2拡張ヘッダーを使用して、逆転操作は不可能です。したがって、inet6_rth_reverse（）は使用されません。"
    },
    {
      "indent": 3,
      "text": "Detailed descriptions and examples of accessing an IPv6 Routing Header are discussed in the Advanced Sockets API for IPv6 [1]. However, Section 7 of Advanced API for IPv6 Sockets [1] indicates that multiple types of routing headers can be received as multiple ancillary data objects to the application (with cmsg_type set to IPV6_RTHDR). Currently, there are no API functions defined to return the routing header type. However, this document does not define a helper function, since it is easy to access the Routing Header Type field just as easily as the ip6r_segleft field. An excerpt of a code sample is provided for extracting the type of the received routing header:",
      "ja": "IPv6ルーティングヘッダーへのアクセスの詳細な説明と例については、IPv6の高度なソケットAPIで説明します[1]。ただし、IPv6ソケット[1]のAdvanced APIのセクション7は、アプリケーションの複数の補助データオブジェクトとして複数のタイプのルーティングヘッダーを受信できることを示しています（CMSG_TypeがIPv6_rthdrに設定されています）。現在、ルーティングヘッダータイプを返すために定義されたAPI関数はありません。ただし、このドキュメントは、IP6r_Segleftフィールドと同じくらい簡単にルーティングヘッダータイプフィールドに簡単にアクセスできるため、ヘルパー機能を定義しません。受信したルーティングヘッダーのタイプを抽出するためのコードサンプルの抜粋が提供されます。"
    },
    {
      "indent": 6,
      "text": "if (msg.msg_controllen != 0 &&\n    cmsgptr->cmsg_level == IPPROTO_IPV6 &&\n    cmsgptr->cmsg_type == IPV6_RTHDR) {\n        struct in6_addr *in6;\n        char asciiname[INET6_ADDRSTRLEN];\n        struct ip6_rthdr *rthdr;\n        int    segments, route_type;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        rthdr = (struct ip6_rthdr *)extptr;\n        segments = inet6_rth_segments(extptr);\n        printf(\"route (%d segments, %d left): \",\n            segments, rthdr->ip6r_segleft);\n        route_type = rthdr->ip6r_type;\n        if (route_type == 2) {\n                printf (\"Routing header Type 2 present\\n\");\n        }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "5.2. Content of Type 2 Routing Header",
      "section_title": true,
      "ja": "5.2. タイプ2ルーティングヘッダーの内容"
    },
    {
      "indent": 3,
      "text": "It is recommended that no portable applications send Type 2 Routing Header ancillary data from the application layer, since many implementations take care of that at the kernel layer and may not support the API for sending Type 2 Routing Header.",
      "ja": "多くの実装がカーネルレイヤーでそれを処理し、タイプ2ルーティングヘッダーを送信するためのAPIをサポートしない可能性があるため、アプリケーションレイヤーからタイプ2ルーティングヘッダーの補助データを送信することはできません。"
    },
    {
      "indent": 3,
      "text": "Mobile IPv6 [2] defines the Type 2 Routing Header to allow the packet to be routed directly from a correspondent to the mobile node's care-of address. The mobile node's care-of address is inserted into the IPv6 Destination Address field. Once the packet arrives at the care-of address, the mobile node retrieves its home address from the routing header, and this is used as the final destination address for the received IPv6 packet.",
      "ja": "モバイルIPv6 [2]は、タイプ2ルーティングヘッダーを定義して、パケットをモバイルノードのケアオブアドレスに直接ルーティングできるようにします。モバイルノードのケアアドレスは、IPv6宛先アドレスフィールドに挿入されます。パケットがCare of Addressに到着すると、モバイルノードはルーティングヘッダーから自宅の住所を取得し、これは受信したIPv6パケットの最終的な宛先アドレスとして使用されます。"
    },
    {
      "indent": 3,
      "text": "For user-level applications that receive Type 2 Routing Header, inet6_rth_getaddr() returns the care-of address or on-the-wire destination address of the received packet. This complies with the existing Routing header Type=0 processing for IPv6 [1].",
      "ja": "タイプ2ルーティングヘッダーを受信するユーザーレベルのアプリケーションの場合、INET6_RTH_GETADDR（）は、受信したパケットのケアアドレスまたはオンザワイヤの宛先アドレスを返します。これは、IPv6 [1]の既存のルーティングヘッダータイプ= 0処理に準拠しています。"
    },
    {
      "indent": 3,
      "text": "Thus, on the receive side, the socket application will always receive data packets at its original home address. The implementations are responsible for processing the Type 2 Routing Header packet as per Mobile IPv6 RFC [2] before passing the Type 2 Routing Header information to the Socket API.",
      "ja": "したがって、受信側では、ソケットアプリケーションは常に元のホームアドレスでデータパケットを受信します。実装は、タイプ2ルーティングヘッダー情報をソケットAPIに渡す前に、モバイルIPv6 RFC [2]に従って、タイプ2ルーティングヘッダーパケットを処理する責任があります。"
    },
    {
      "indent": 3,
      "text": "If a pure IPv6 [3] system receives the Routing Header Type 2 packets, it will follow the process described in Section 4.4 of the IPv6 [3] base specification.",
      "ja": "純粋なIPv6 [3]システムがルーティングヘッダータイプ2パケットを受信すると、IPv6 [3]ベース仕様のセクション4.4で説明されているプロセスに従います。"
    },
    {
      "indent": 0,
      "text": "5.3. Order of Extension Headers for Home Address Destination Options",
      "section_title": true,
      "ja": "5.3. ホームアドレスの目的地オプションの拡張ヘッダーの順序"
    },
    {
      "indent": 3,
      "text": "Section 6.3 of Mobile IPV6 [2] defines the extension header order for the Home address destination option.",
      "ja": "モバイルIPv6 [2]のセクション6.3は、ホームアドレス宛先オプションの拡張ヘッダー順序を定義しています。"
    },
    {
      "indent": 6,
      "text": "Routing Header Home Address Destination Option Fragment Header AH/ESP Header",
      "ja": "ルーティングヘッダーホームアドレス宛先オプションフラグメントヘッダーAH/ESPヘッダー"
    },
    {
      "indent": 3,
      "text": "IPv6 [3] specifies that the destination header can be either before the Routing header or after the AH/ESP header if they are all present.",
      "ja": "IPv6 [3]は、宛先ヘッダーがルーティングヘッダーの前に、またはAH/ESPヘッダーがすべて存在する場合は、AH/ESPヘッダーの後にできることを指定します。"
    },
    {
      "indent": 3,
      "text": "Thus, when the Home Address destination option is present along with other extension headers, the order will be:",
      "ja": "したがって、ホームアドレスの宛先オプションが他の拡張ヘッダーとともに存在する場合、注文は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "Hop-by-Hop Options header Destination Options header Routing header Destination Options [Home Address Option] Fragment header Authentication header Encapsulating Security Payload header Destination Options header upper-layer header",
      "ja": "ホップバイホップオプションヘッダー宛先オプションヘッダールーティングヘッダー宛先オプション[ホームアドレスオプション]フラグメントヘッダー認証ヘッダーセキュリティペイロードヘッダー宛先オプションヘッダーアッパーレイヤーヘッダー"
    },
    {
      "indent": 3,
      "text": "Any user-level implementation or application that sends the Home address destination option through ancillary data objects should follow the order extension header defined in this document when using IPV6_MIPDSTOPTS socket options.",
      "ja": "IPv6_mipdstoptsソケットオプションを使用する場合、補助データオブジェクトを補助データオブジェクトを介してホームアドレスの宛先オプションを送信するアプリケーションまたはアプリケーションは、このドキュメントで定義されている注文ヘッダーに従う必要があります。"
    },
    {
      "indent": 0,
      "text": "5.4. Home Address Destination Option Access Functions",
      "section_title": true,
      "ja": "5.4. ホームアドレスの宛先オプションアクセス機能"
    },
    {
      "indent": 3,
      "text": "The application must enable the IPV6_RECVDSTOPTS socket option in order to receive the Home Address destination option (error checking is not performed in the example for brevity):",
      "ja": "このアプリケーションは、ホームアドレスの宛先オプションを受信するために、IPv6_RecvdStoptsソケットオプションを有効にする必要があります（Brevityの例ではエラーチェックは実行されません）："
    },
    {
      "indent": 6,
      "text": "int on = 1;",
      "ja": "int on = 1;"
    },
    {
      "indent": 6,
      "text": "setsockopt(fd, IPPROTO_IPV6, IPV6_RECVDSTOPTS, &on, sizeof(on));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Each Destination option header is returned as one ancillary data object described by a cmsghdr structure, with cmsg_level set to IPPROTO_IPV6 and cmsg_type set to IPV6_DSTOPTS.",
      "ja": "各宛先オプションヘッダーは、CMSGHDR構造によって記述された1つの補助データオブジェクトとして返され、CMSG_LEVELはIPPROTO_IPV6に設定され、CMSG_TYPEはIPv6_DSTOPTSに設定されています。"
    },
    {
      "indent": 3,
      "text": "The received side Home Address destination option is further processed by calling the inet6_opt_next(), inet6_opt_find(), and inet6_opt_get_value() functions as defined in Advanced API for IPv6 sockets [1].",
      "ja": "受信したサイドホームアドレスの宛先オプションは、IPv6ソケットのAdvanced APIで定義されているINET6_OPT_NEXT（）、INET6_OPT_FIND（）、およびINET6_OPT_GET_VALUE（）を呼び出すことにより、さらに処理されます[1]。"
    },
    {
      "indent": 3,
      "text": "This document assumes that portable Mobile IPv6 applications will not send a Home Address Destination Option from the application level, as the Mobile IPv6 implementation underneath takes care of sending the Home Address option and the routing header type 2 at the kernel. However, some embedded software implementations may implement the IPv6 packet processing/sending at the user-level; those implementations may choose to provide the API support for sending a home-address option at the application layer. In this case, the Home Address destination options are normally constructed by using the inet6_opt_init(), inet6_opt_append(), inet6_opt_finish(), and inet6_opt_set_val() functions, described in Section 10 of the Advanced sockets API for IPv6 [1].",
      "ja": "このドキュメントでは、ポータブルモバイルIPv6アプリケーションは、下のモバイルIPv6実装が自宅アドレスオプションとルーティングヘッダータイプ2をカーネルに送信するために、アプリケーションレベルからホームアドレスの宛先オプションを送信しないことを前提としています。ただし、一部の組み込みソフトウェア実装では、ユーザーレベルでIPv6パケット処理/送信を実装する場合があります。これらの実装は、アプリケーションレイヤーでホームアドレスオプションを送信するためのAPIサポートを提供することを選択できます。この場合、ホームアドレスの目的地オプションは、通常、IPv6の高度なソケットAPIのセクション10で説明されているINET6_OPT_INIT（）、INET6_OPT_APPEND（）、INET6_OPT_FINISH（）、およびINET6_OPT_SET_VAL（）関数を使用して構築されます。"
    },
    {
      "indent": 0,
      "text": "5.5. Content of Home Address Destination Option",
      "section_title": true,
      "ja": "5.5. ホームアドレスの宛先オプションのコンテンツ"
    },
    {
      "indent": 3,
      "text": "The received ancillary data object for the Home Address destination option SHOULD contain the care-of address of the mobile node. It is assumed that the initial processing of the Home Address destination option will verify the validity of the home address, as described in Sections 6.3 and 9.5 of the Mobile IPv6 Specification [2], and swap the source address of the packet (COA) with the contents of Home Address destination option.",
      "ja": "ホームアドレスの宛先オプションの受信した補助データオブジェクトには、モバイルノードのケアアドレスを含める必要があります。モバイルIPv6仕様[2]のセクション6.3および9.5で説明されているように、ホームアドレスの宛先オプションの初期処理は、ホームアドレスの有効性を検証し、パケット（COA）のソースアドレスを交換します。ホームアドレス宛先オプションの内容。"
    },
    {
      "indent": 3,
      "text": "Note that whether or not these new APIs are used, the sender's home address is contained in the source address (which is passed to the application using the socket-level functions recvfrom(), recvmsg(), accept(), and getpeername()). This is necessary for:",
      "ja": "これらの新しいAPIが使用されるかどうかにかかわらず、送信者のホームアドレスはソースアドレスに含まれていることに注意してください（これはソケットレベルの機能を使用してアプリケーションに渡されますrecvfrom（）、recvmsg（）、accept（）、およびgetPeername（）（））。これは必要です："
    },
    {
      "indent": 6,
      "text": "maintaining consistency between simple user-level applications running between mobile nodes and the diagnostic applications on the home agent or correspondent node that use this API;",
      "ja": "このAPIを使用するホームエージェントまたは特派員ノードのモバイルノードと診断アプリケーション間で実行されている単純なユーザーレベルアプリケーション間の一貫性を維持します。"
    },
    {
      "indent": 6,
      "text": "obtaining the COA address of the mobile node when the Home Address destination option is used; and",
      "ja": "ホームアドレスの宛先オプションが使用されているときに、モバイルノードのCOAアドレスを取得します。と"
    },
    {
      "indent": 6,
      "text": "maintaining consistency of existing IPv6 Socket APIs and processing of the Home Address destination option.",
      "ja": "既存のIPv6ソケットAPIの一貫性と、ホームアドレスの宛先オプションの処理を維持します。"
    },
    {
      "indent": 3,
      "text": "If an implementation supports send-side Home Address destination API, then it must follow the same rule for data content as specified in Mobile IPv6 RFC [2] for sending a home-address option. Thus, the home-address option will contain the home address, and the implementation will use the care-of address as the source address of the outgoing packet. If the implementation uses IPSec, then it should use the content of Home Address destination option as the source address of the packet for security association. Note that regular user applications must not set the home address destination option.",
      "ja": "実装が送信側のホームアドレス宛先APIをサポートする場合、ホームアドレスオプションを送信するために、モバイルIPv6 RFC [2]で指定されたデータコンテンツの同じルールに従う必要があります。したがって、ホームアドレスオプションにはホームアドレスが含まれ、実装は発信パケットのソースアドレスとしてケアオブアドレスを使用します。実装がIPSECを使用する場合、セキュリティ協会のパケットのソースアドレスとして、Home Address Destinationオプションのコンテンツを使用する必要があります。通常のユーザーアプリケーションは、ホームアドレスの宛先オプションを設定してはならないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "6. Mobility Protocol Headers",
      "section_title": true,
      "ja": "6. モビリティプロトコルヘッダー"
    },
    {
      "indent": 3,
      "text": "Mobile IPv6 [2] defines a new IPv6 protocol header to carry mobility messages between Mobile Nodes, Home Agents and Correspondent Nodes. These protocol headers carry Mobile IPv6 Binding messages as well as Return Routability [2] messages. Currently the specification [2] does not allow transport packets (piggybacking) along with the mobility messages. Thus the mobility protocol header can be accessed through an IPv6 RAW socket. An IPv6 RAW socket that is opened for protocol IPPROTO_MH should always be able to see all the MH (Mobility Header) packets. It is possible that future applications may implement part of Mobile IPv6 signal processing at the application level. Having a RAW socket interface may also enable an application to execute the Return Routability protocol or other future authentication protocol involving the mobility header at the user-level.",
      "ja": "モバイルIPv6 [2]は、モバイルノード、ホームエージェント、特派員ノード間でモビリティメッセージを伝達する新しいIPv6プロトコルヘッダーを定義します。これらのプロトコルヘッダーには、モバイルIPv6バインディングメッセージとReturn Reautability [2]メッセージが含まれます。現在、仕様[2]は、モビリティメッセージとともにトランスポートパケット（ピギーバック）を許可していません。したがって、Mobility Protocol Headerには、IPv6 Raw Socketを介してアクセスできます。プロトコルIPProto_MH用に開かれたIPv6 RAWソケットは、常にすべてのMH（モビリティヘッダー）パケットを見ることができるはずです。将来のアプリケーションがアプリケーションレベルでモバイルIPv6信号処理の一部を実装する可能性があります。生のソケットインターフェイスを持つことにより、アプリケーションがユーザーレベルでモビリティヘッダーを含むリターンルー上のプロトコルまたはその他の将来の認証プロトコルを実行することもできます。"
    },
    {
      "indent": 0,
      "text": "6.1. Receiving and Sending Mobility Header Messages",
      "section_title": true,
      "ja": "6.1. モビリティヘッダーメッセージの受信と送信"
    },
    {
      "indent": 3,
      "text": "This specification recommends that the IPv6 RAW sockets mechanism send and receive Mobility Header (MH) packets. The behavior is similar to ICMPV6 processing, where the kernel passes a copy of the mobility header packet to the receiving socket. Depending on the implementation, the kernel may process the mobility header in addition to passing the mobility header to the application. In order to comply with the restriction in the Advanced Sockets API for IPv6 [1], applications should set the IPV6_CHECKSUM socket option with IPPROTO_MH protocol RAW Sockets. A Mobile IPv6 implementation that supports the Mobile IPv6 API must implement Mobility Header API checksum calculations by default at the kernel for both incoming and outbound paths. A Mobile IPv6 implementation must not return error on the IPV6_CHECKSUM socket option setting, even if the socket option is a NO-OP function for that implementation because it verifies the checksum at the kernel level. The Mobility Header checksum procedure is described in the Mobile IPv6 Protocol [2] specification. Again, for application portability it is recommended that the applications set the IPV6_CHECKSUM socket option along with the RAW sockets for IPPROTO_MH protocol.",
      "ja": "この仕様では、IPv6 Raw Socketsメカニズムがモビリティヘッダー（MH）パケットを送信および受信することを推奨しています。動作はICMPV6処理に似ており、カーネルはモビリティヘッダーパケットのコピーを受信ソケットに渡します。実装に応じて、カーネルはモビリティヘッダーをアプリケーションに渡すことに加えて、モビリティヘッダーを処理できます。IPv6 [1]のAdvanced Sockets APIの制限に準拠するために、アプリケーションはIPPROTO_MHプロトコルRAWソケットを使用してIPv6_Checksumソケットオプションを設定する必要があります。モバイルIPv6 APIをサポートするモバイルIPv6実装では、受信パスとアウトバウンドパスの両方でカーネルでデフォルトでモビリティヘッダーAPIチェックサム計算を実装する必要があります。モバイルIPv6の実装は、ソケットオプションがカーネルレベルでチェックサムを検証するため、ソケットオプションがその実装のノーオプ関数である場合でも、IPv6_Checksumソケットオプション設定のエラーを返してはなりません。モビリティヘッダーチェックサム手順は、モバイルIPv6プロトコル[2]仕様で説明されています。繰り返しになりますが、アプリケーションの移植性のために、アプリケーションはIPV6_ChecksumソケットオプションをIPProto_MHプロトコル用の生のソケットとともに設定することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "As an example, a program that wants to send or receive a mobility header protocol(MH) could open a socket as follows (for brevity, the error checking is not performed in the example below):",
      "ja": "例として、モビリティヘッダープロトコル（MH）を送信または受信したいプログラムは、次のようにソケットを開くことができます（簡潔にするために、以下の例ではエラーチェックは実行されません）："
    },
    {
      "indent": 6,
      "text": "fd = socket(AF_INET6, SOCK_RAW, IPPROTO_MH);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "int offset = 4;\nsetsockopt(fd, IPPROTO_IPV6, IPV6_CHECKSUM, &offset,\n     sizeof(offset));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For example, if an implementation likes to handle HOTI/HOT and COTI/ COT message processing, it can do so by using IPv6 RAW Sockets for IPPROTO_MH at the application layer. The same application may also set the IPV6_RECVDSTOPTS socket option for receiving Home Address destination option in a binding update [2] from the mobile node.",
      "ja": "たとえば、実装がHOTI/ HOTおよびCOTI/ COTメッセージ処理を処理することを好む場合、アプリケーションレイヤーでIPPROTO_MHにIPv6 RAWソケットを使用することでそうすることができます。同じアプリケーションは、モバイルノードからバインディングアップデート[2]でホームアドレスの宛先オプションを受信するためのIPv6_RecVDStoptsソケットオプションを設定することもできます。"
    },
    {
      "indent": 3,
      "text": "IPv6 RAW sockets are described in Section 3 of the IPv6 Advanced Socket API [1] specification. All data sent and received via raw sockets must be in network byte order. The data structures that are defined in this document are in network byte order, and they are believed to be supported by most compilers to hold packet formats directly for transmission on the wire.",
      "ja": "IPv6 RAWソケットは、IPv6 Advanced Socket API [1]仕様のセクション3で説明されています。生のソケットを介して送信および受信されたすべてのデータは、ネットワークバイトの順序でなければなりません。このドキュメントで定義されているデータ構造はネットワークバイトの順序であり、ほとんどのコンパイラによってサポートされていると考えられており、ワイヤー上の送信のためにパケット形式を直接保持しています。"
    },
    {
      "indent": 3,
      "text": "The usual send/recv functions for datagram should be used for the Mobile IPv6 RAW sockets in order to send and receive data, respectively.",
      "ja": "データグラムの通常の送信/RECV関数は、データをそれぞれ送信および受信するために、モバイルIPv6生ソケットに使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Protocols File",
      "section_title": true,
      "ja": "7. プロトコルファイル"
    },
    {
      "indent": 3,
      "text": "Many hosts provide the file /etc/protocols, which contains the names of the various IP protocols and their protocol numbers. The protocol numbers are obtained through function getprotoXXX() functions.",
      "ja": "多くのホストは、さまざまなIPプロトコルの名前とそのプロトコル番号を含むファイル /etc /プロトコルを提供します。プロトコル番号は、関数getProtoxxx（）関数を介して取得されます。"
    },
    {
      "indent": 3,
      "text": "The following addition should be made to the /etc/protocols file, in addition to what is defined in Section 2.4 of the Advanced Sockets API for IPv6 [1].",
      "ja": "IPv6 [1]の高度なソケットAPIのセクション2.4で定義されているものに加えて、以下の追加を /etc /プロトコルファイルに加えてください。"
    },
    {
      "indent": 3,
      "text": "The protocol number for Mobility Header: (http://www.iana.org/assignments/protocol-numbers)",
      "ja": "モビリティヘッダーのプロトコル番号：（http://www.iana.org/assignments/protocol-numbers）"
    },
    {
      "indent": 6,
      "text": "ipv6-mh 135 # Mobility Protocol Header",
      "ja": "IPv6-MH 135＃モビリティプロトコルヘッダー"
    },
    {
      "indent": 0,
      "text": "8. IPv4-Mapped IPv6 Addresses",
      "section_title": true,
      "ja": "8. IPv4マップIPv6アドレス"
    },
    {
      "indent": 3,
      "text": "The various socket options and ancillary data specifications defined in this document apply only to true IPv6 sockets. It is possible to create an IPv6 socket that actually sends and receives IPv4 packets, using IPv4-mapped IPv6 addresses, but the mapping of the options defined in this document to an IPv4 datagram is beyond the scope of this document. The above statement is in compliance with Section 13 of the IPv6 Socket API [1].",
      "ja": "このドキュメントで定義されているさまざまなソケットオプションと補助データ仕様は、真のIPv6ソケットにのみ適用されます。IPv4-Mapped IPv6アドレスを使用して、IPv4パケットを実際に送信および受信するIPv6ソケットを作成することができますが、このドキュメントで定義されているオプションのマッピングは、IPv4データグラムにこのドキュメントの範囲を超えています。上記のステートメントは、IPv6ソケットAPI [1]のセクション13に準拠しています。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The setting of the Home Address Destination option and Route Header Type 2 IPV6_RTHDR socket option may not be allowed at the application level in order to prevent denial-of-service attacks or man-in-the-middle attacks by hackers. Sending and receiving of mobility header messages are possible by IPv6 RAW sockets. Thus, it is assumed that this operation is only possible by privileged users. However, this API does not prevent the existing security threat from a hacker sending a bogus mobility header or other IPv6 packets using the Home Address option and Type 2 Routing Header extensions.",
      "ja": "ホームアドレスの宛先オプションとルートヘッダータイプ2 IPv6_RTHDRソケットオプションの設定は、ハッカーによるサービス拒否攻撃または中間攻撃を防ぐために、アプリケーションレベルで許可されない場合があります。IPv6 RAWソケットでは、モビリティヘッダーメッセージの送信と受信が可能です。したがって、この操作は特権ユーザーによってのみ可能であると想定されています。ただし、このAPIは、ホームアドレスオプションとタイプ2ルーティングヘッダー拡張機能を使用して、偽のモビリティヘッダーまたは他のIPv6パケットを送信するハッカーから既存のセキュリティ脅威を妨げません。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document does not define a new protocol. However, it uses the Mobility Header Protocol for IPv6 to define an API for the /etc/protocols file. (ref: http://www.iana.org/assignments/protocol-numbers)",
      "ja": "このドキュメントは、新しいプロトコルを定義しません。ただし、IPv6のMobility Headerプロトコルを使用して、 /etc /ProtocolsファイルのAPIを定義します。（ref：http：//www.iana.org/assignments/protocol-numbers）"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Brian Haley for the thorough review of this document and many helpful comments. Keiichi Shima, Alexandru Petrescu, Ryuji Wakikawa, Vijay Devarapalli, Jim Bound, Suvidh Mathur, Karen Nielsen, Mark Borst, Vladislav Yasevich, and other mobile-ip working group members provided valuable input. Antti Tuominen suggested the routing header type function for this API document. During IESG review, Bill Fenner suggested accessing the routing header type directly for being consistent with RFC3542. A new socket option for Home Address Destination Option is added per Bill Fenner's suggestion for clarity of extension header orders. Thanks to Thomas Narten and Jari Arkko for the review of this document.",
      "ja": "この文書の徹底的なレビューと多くの有用なコメントを提供してくれたブライアンヘイリーに感謝します。清水、アレクサンドル・ペトレシュ、ワキカワ、ヴィジェイ・デヴァラパリ、ジム・バウンド、スヴィド・マトゥール、カレン・ニールセン、マーク・ボースト、ウラジスラフ・ヤセビッチ、およびその他のモバイルIPワーキンググループのメンバーが貴重な投入を提供しました。Antti Tuominenは、このAPIドキュメントのルーティングヘッダータイプ関数を提案しました。IESGレビュー中、ビルフェナーは、RFC3542と一致するためにルーティングヘッダータイプに直接アクセスすることを提案しました。拡張ヘッダー注文の明確性に関するBill Fennerの提案に従って、ホームアドレスの宛先オプションの新しいソケットオプションが追加されます。この文書のレビューをしてくれたThomas NartenとJari Arkkoに感謝します。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Stevens, W., Thomas, M., Nordmark, E., and T. Jinmei, \"Advanced Sockets Application Program Interface (API) for IPv6\", RFC 3542, May 2003.",
      "ja": "[1] Stevens、W.、Thomas、M.、Nordmark、E。、およびT. Jinmei、「IPv6用Advanced Socketsアプリケーションプログラムインターフェイス（API）」、RFC 3542、2003年5月。"
    },
    {
      "indent": 3,
      "text": "[2] Johnson, D., Perkins, C., and J. Arkko, \"Mobility Support in IPv6\", RFC 3775, June 2004.",
      "ja": "[2] Johnson、D.、Perkins、C。、およびJ. Arkko、「IPv6のモビリティサポート」、RFC 3775、2004年6月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[3] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[3] Deering、S。and R. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[4] Devarapalli, V., Wakikawa, R., Petrescu, A., and P. Thubert, \"Network Mobility (NEMO) Basic Support Protocol\", RFC 3963, January 2005.",
      "ja": "[4] Devarapalli、V.、Wakikawa、R.、Petrescu、A。、およびP. Thubert、「Network Mobility（NEMO）Basic Support Protocol」、RFC 3963、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[5] Nordmark, E., \"IPv6 Socket API for source address selection\", Work in Progress, July 2005.",
      "ja": "[5] Nordmark、E。、「ソースアドレスの選択のためのIPv6ソケットAPI」、2005年7月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[6] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[6] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6用の基本ソケットインターフェイス拡張」、RFC 3493、2003年2月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Samita Chakrabarti",
      "ja": "サミタ・チャクラバルティ"
    },
    {
      "indent": 3,
      "text": "EMail: samitac2@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Erik Nordmark Sun Microsystems 17 Network Circle Menlo Park, CA 94025 USA",
      "ja": "Erik Nordmark Sun Microsystems 17 Network Circle Menlo Park、CA 94025 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 650 786 2921\nEMail: erik.nordmark@sun.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2006).",
      "ja": "Copyright（c）The Internet Society（2006）。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78に含まれる権利、ライセンス、および制限の対象となり、そこに記載されている場合を除き、著者はすべての権利を保持しています。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "このドキュメントとここに含まれる情報は、「現状のまま」に基づいて提供されています。また、貢献者、彼/彼女が代表する組織（もしあれば）が後援する組織、インターネット協会とインターネット工学タスクフォースは、すべての保証、明示的または明示的、またはすべての保証を否認します。本書の情報の使用が、商品性または特定の目的に対する適合性の権利または黙示的な保証を侵害しないという保証を含むがこれらに限定されないことを含む。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the procedures with respect to rights in RFC documents can be found in BCP 78 and BCP 79.",
      "ja": "IETFは、知的財産権またはその他の権利の有効性または範囲に関して、この文書に記載されている技術の実装または使用、またはそのような権利に基づくライセンスがどの程度であるかについての使用に関連すると主張する可能性があるという立場はありません。利用可能になります。また、そのような権利を特定するために独立した努力をしたことも表明していません。RFCドキュメントの権利に関する手順に関する情報は、BCP 78およびBCP 79に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF事務局に行われたIPR開示のコピーと、利用可能にするライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような独自の権利の使用のための一般的なライセンスまたは許可を取得しようとする試みの結果を取得できます。http://www.ietf.org/iprのIETFオンラインIPRリポジトリから。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETFは、関心のある当事者に、著作権、特許、または特許出願、またはこの基準を実装するために必要な技術をカバーする可能性のあるその他の独自の権利を注意深く招待するよう招待しています。ietf-ipr@ietf.orgのIETFへの情報をお問い合わせください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is provided by the IETF Administrative Support Activity (IASA).",
      "ja": "RFCエディター機能の資金は、IETF管理サポートアクティビティ（IASA）によって提供されます。"
    }
  ]
}