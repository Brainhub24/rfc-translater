{
  "title": {
    "text": "RFC 3951 - Internet Low Bit Rate Codec (iLBC)",
    "ja": "RFC 3951 - インターネット低ビット レート コーデック (iLBC)"
  },
  "number": 3951,
  "created_at": "2023-08-29 11:17:47.850307+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        S. Andersen\nRequest for Comments: 3951                            Aalborg University\nCategory: Experimental                                          A. Duric\n                                                                   Telio\n                                                               H. Astrom\n                                                                R. Hagen\n                                                               W. Kleijn\n                                                               J. Linden\n                                                         Global IP Sound\n                                                           December 2004",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Internet Low Bit Rate Codec (iLBC)",
      "ja": "インターネット低ビット レート コーデック (iLBC)"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This memo defines an Experimental Protocol for the Internet community. It does not specify an Internet standard of any kind. Discussion and suggestions for improvement are requested. Distribution of this memo is unlimited.",
      "ja": "このメモは、インターネット コミュニティ向けの実験プロトコルを定義します。いかなる種類のインターネット標準も指定しません。改善のための議論と提案が求められます。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004).",
      "ja": "著作権 (C) インターネット協会 (2004)。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document specifies a speech codec suitable for robust voice communication over IP. The codec is developed by Global IP Sound (GIPS). It is designed for narrow band speech and results in a payload bit rate of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s for 20 ms frames. The codec enables graceful speech quality degradation in the case of lost frames, which occurs in connection with lost or delayed IP packets.",
      "ja": "この文書では、IP 上の堅牢な音声通信に適した音声コーデックを指定します。コーデックは Global IP Sound (GIPS) によって開発されました。狭帯域音声用に設計されており、ペイロード ビット レートは 30 ms フレームで 13.33 kbit/s、20 ms フレームで 15.20 kbit/s になります。このコーデックにより、IP パケットの損失または遅延に関連して発生するフレーム損失の場合に、音声品質を適切に低下させることができます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Outline of the Codec . . . . . . . . . . . . . . . . . . . . .  5\n    2.1.  Encoder. . . . . . . . . . . . . . . . . . . . . . . . .  5\n    2.2.  Decoder. . . . . . . . . . . . . . . . . . . . . . . . .  7\n3.  Encoder Principles . . . . . . . . . . . . . . . . . . . . . .  7\n    3.1.  Pre-processing . . . . . . . . . . . . . . . . . . . . .  9\n    3.2.  LPC Analysis and Quantization. . . . . . . . . . . . . .  9\n          3.2.1.  Computation of Autocorrelation Coefficients. . . 10\n          3.2.2.  Computation of LPC Coefficients. . . . . . . . . 11\n          3.2.3.  Computation of LSF Coefficients from LPC\n                  Coefficients . . . . . . . . . . . . . . . . . . 11\n          3.2.4.  Quantization of LSF Coefficients . . . . . . . . 12\n          3.2.5.  Stability Check of LSF Coefficients. . . . . . . 13\n          3.2.6.  Interpolation of LSF Coefficients. . . . . . . . 13\n          3.2.7.  LPC Analysis and Quantization for 20 ms Frames . 14\n    3.3.  Calculation of the Residual. . . . . . . . . . . . . . . 15\n    3.4.  Perceptual Weighting Filter. . . . . . . . . . . . . . . 15\n    3.5.  Start State Encoder. . . . . . . . . . . . . . . . . . . 15\n          3.5.1.  Start State Estimation . . . . . . . . . . . . . 16\n          3.5.2.  All-Pass Filtering and Scale Quantization. . . . 17\n          3.5.3.  Scalar Quantization. . . . . . . . . . . . . . . 18\n    3.6.  Encoding the Remaining Samples . . . . . . . . . . . . . 19\n          3.6.1.  Codebook Memory. . . . . . . . . . . . . . . . . 20\n          3.6.2.  Perceptual Weighting of Codebook Memory\n                  and Target . . . . . . . . . . . . . . . . . . . 22\n          3.6.3.  Codebook Creation. . . . . . . . . . . . . . . . 23\n                  3.6.3.1. Creation of a Base Codebook . . . . . . 23\n                  3.6.3.2. Codebook Expansion. . . . . . . . . . . 24\n                  3.6.3.3. Codebook Augmentation . . . . . . . . . 24\n          3.6.4.  Codebook Search. . . . . . . . . . . . . . . . . 26\n                  3.6.4.1. Codebook Search at Each Stage . . . . . 26\n                  3.6.4.2. Gain Quantization at Each Stage . . . . 27\n                  3.6.4.3. Preparation of Target for Next Stage. . 28\n    3.7.  Gain Correction Encoding . . . . . . . . . . . . . . . . 28\n    3.8.  Bitstream Definition . . . . . . . . . . . . . . . . . . 29\n4.  Decoder Principles . . . . . . . . . . . . . . . . . . . . . . 32\n    4.1.  LPC Filter Reconstruction. . . . . . . . . . . . . . . . 33\n    4.2.  Start State Reconstruction . . . . . . . . . . . . . . . 33\n    4.3.  Excitation Decoding Loop . . . . . . . . . . . . . . . . 34\n    4.4.  Multistage Adaptive Codebook Decoding. . . . . . . . . . 35\n          4.4.1.  Construction of the Decoded Excitation Signal. . 35\n    4.5.  Packet Loss Concealment. . . . . . . . . . . . . . . . . 35\n          4.5.1.  Block Received Correctly and Previous Block\n                  Also Received. . . . . . . . . . . . . . . . . . 35\n          4.5.2.  Block Not Received . . . . . . . . . . . . . . . 36\n             4.5.3.  Block Received Correctly When Previous Block\n                  Not Received . . . . . . . . . . . . . . . . . . 36\n    4.6.  Enhancement. . . . . . . . . . . . . . . . . . . . . . . 37\n          4.6.1.  Estimating the Pitch . . . . . . . . . . . . . . 39\n          4.6.2.  Determination of the Pitch-Synchronous\n                  Sequences. . . . . . . . . . . . . . . . . . . . 39\n          4.6.3.  Calculation of the Smoothed Excitation . . . . . 41\n          4.6.4.  Enhancer Criterion . . . . . . . . . . . . . . . 41\n          4.6.5.  Enhancing the Excitation . . . . . . . . . . . . 42\n    4.7.  Synthesis Filtering. . . . . . . . . . . . . . . . . . . 43\n    4.8.  Post Filtering . . . . . . . . . . . . . . . . . . . . . 43\n5.  Security Considerations. . . . . . . . . . . . . . . . . . . . 43\n6.  Evaluation of the iLBC Implementations . . . . . . . . . . . . 43\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n    7.1.  Normative References . . . . . . . . . . . . . . . . . . 43\n    7.2.  Informative References . . . . . . . . . . . . . . . . . 44\n8.  ACKNOWLEDGEMENTS . . . . . . . . . . . . . . . . . . . . . . . 44\nAPPENDIX A: Reference Implementation . . . . . . . . . . . . . . . 45\n    A.1.  iLBC_test.c. . . . . . . . . . . . . . . . . . . . . . . 46\n    A.2   iLBC_encode.h. . . . . . . . . . . . . . . . . . . . . . 52\n    A.3.  iLBC_encode.c. . . . . . . . . . . . . . . . . . . . . . 53\n    A.4.  iLBC_decode.h. . . . . . . . . . . . . . . . . . . . . . 63\n    A.5.  iLBC_decode.c. . . . . . . . . . . . . . . . . . . . . . 64\n    A.6.  iLBC_define.h. . . . . . . . . . . . . . . . . . . . . . 76\n    A.7.  constants.h. . . . . . . . . . . . . . . . . . . . . . . 80\n    A.8.  constants.c. . . . . . . . . . . . . . . . . . . . . . . 82\n    A.9.  anaFilter.h. . . . . . . . . . . . . . . . . . . . . . . 96\n    A.10. anaFilter.c. . . . . . . . . . . . . . . . . . . . . . . 97\n    A.11. createCB.h . . . . . . . . . . . . . . . . . . . . . . . 98\n    A.12. createCB.c . . . . . . . . . . . . . . . . . . . . . . . 99\n    A.13. doCPLC.h . . . . . . . . . . . . . . . . . . . . . . . .104\n    A.14. doCPLC.c . . . . . . . . . . . . . . . . . . . . . . . .104\n    A.15. enhancer.h . . . . . . . . . . . . . . . . . . . . . . .109\n    A.16. enhancer.c . . . . . . . . . . . . . . . . . . . . . . .110\n    A.17. filter.h . . . . . . . . . . . . . . . . . . . . . . . .123\n    A.18. filter.c . . . . . . . . . . . . . . . . . . . . . . . .125\n    A.19. FrameClassify.h. . . . . . . . . . . . . . . . . . . . .128\n    A.20. FrameClassify.c. . . . . . . . . . . . . . . . . . . . .129\n    A.21. gainquant.h. . . . . . . . . . . . . . . . . . . . . . .131\n    A.22. gainquant.c. . . . . . . . . . . . . . . . . . . . . . .131\n    A.23. getCBvec.h . . . . . . . . . . . . . . . . . . . . . . .134\n    A.24. getCBvec.c . . . . . . . . . . . . . . . . . . . . . . .134\n    A.25. helpfun.h. . . . . . . . . . . . . . . . . . . . . . . .138\n    A.26. helpfun.c. . . . . . . . . . . . . . . . . . . . . . . .140\n    A.27. hpInput.h. . . . . . . . . . . . . . . . . . . . . . . .146\n    A.28. hpInput.c. . . . . . . . . . . . . . . . . . . . . . . .146\n    A.29. hpOutput.h . . . . . . . . . . . . . . . . . . . . . . .148\n    A.30. hpOutput.c . . . . . . . . . . . . . . . . . . . . . . .148\n       A.31. iCBConstruct.h . . . . . . . . . . . . . . . . . . . . .149\n    A.32. iCBConstruct.c . . . . . . . . . . . . . . . . . . . . .150\n    A.33. iCBSearch.h. . . . . . . . . . . . . . . . . . . . . . .152\n    A.34. iCBSearch.c. . . . . . . . . . . . . . . . . . . . . . .153\n    A.35. LPCdecode.h. . . . . . . . . . . . . . . . . . . . . . .163\n    A.36. LPCdecode.c. . . . . . . . . . . . . . . . . . . . . . .164\n    A.37. LPCencode.h. . . . . . . . . . . . . . . . . . . . . . .167\n    A.38. LPCencode.c. . . . . . . . . . . . . . . . . . . . . . .167\n    A.39. lsf.h. . . . . . . . . . . . . . . . . . . . . . . . . .172\n    A.40. lsf.c. . . . . . . . . . . . . . . . . . . . . . . . . .172\n    A.41. packing.h. . . . . . . . . . . . . . . . . . . . . . . .178\n    A.42. packing.c. . . . . . . . . . . . . . . . . . . . . . . .179\n    A.43. StateConstructW.h. . . . . . . . . . . . . . . . . . . .182\n    A.44. StateConstructW.c. . . . . . . . . . . . . . . . . . . .183\n    A.45. StateSearchW.h . . . . . . . . . . . . . . . . . . . . .185\n    A.46. StateSearchW.c . . . . . . . . . . . . . . . . . . . . .186\n    A.47. syntFilter.h . . . . . . . . . . . . . . . . . . . . . .190\n    A.48. syntFilter.c . . . . . . . . . . . . . . . . . . . . . .190\nAuthors' Addresses . . . . . . . . . . . . . . . . . . . . . . . .192\nFull Copyright Statement . . . . . . . . . . . . . . . . . . . . .194",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document contains the description of an algorithm for the coding of speech signals sampled at 8 kHz. The algorithm, called iLBC, uses a block-independent linear-predictive coding (LPC) algorithm and has support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms at 13.33 kbit/s. When the codec operates at block lengths of 20 ms, it produces 304 bits per block, which SHOULD be packetized as in [1]. Similarly, for block lengths of 30 ms it produces 400 bits per block, which SHOULD be packetized as in [1]. The two modes for the different frame sizes operate in a very similar way. When they differ it is explicitly stated in the text, usually with the notation x/y, where x refers to the 20 ms mode and y refers to the 30 ms mode.",
      "ja": "この文書には、8 kHz でサンプリングされた音声信号を符号化するためのアルゴリズムの説明が含まれています。iLBC と呼ばれるこのアルゴリズムは、ブロック独立線形予測符号化 (LPC) アルゴリズムを使用し、2 つの基本フレーム長 (15.2 kbit/s で 20 ms と 13.33 kbit/s で 30 ms) をサポートします。コーデックが 20 ミリ秒のブロック長で動作する場合、ブロックあたり 304 ビットが生成され、[1] のようにパケット化する必要があります (SHOULD)。同様に、ブロック長が 30 ミリ秒の場合、ブロックあたり 400 ビットが生成され、[1] のようにパケット化する必要があります。異なるフレーム サイズの 2 つのモードは、非常に似た方法で動作します。異なる場合は、通常は x/y という表記で本文に明示的に記載されます。x は 20 ms モードを指し、y は 30 ms モードを指します。"
    },
    {
      "indent": 3,
      "text": "The described algorithm results in a speech coding system with a controlled response to packet losses similar to what is known from pulse code modulation (PCM) with packet loss concealment (PLC), such as the ITU-T G.711 standard [4], which operates at a fixed bit rate of 64 kbit/s. At the same time, the described algorithm enables fixed bit rate coding with a quality-versus-bit rate tradeoff close to state-of-the-art. A suitable RTP payload format for the iLBC codec is specified in [1].",
      "ja": "説明されているアルゴリズムにより、ITU-T G.711 標準 [4] などのパケット損失隠蔽 (PLC) を備えたパルス符号変調 (PCM) で知られているものと同様に、パケット損失に対する制御された応答を備えた音声符号化システムが実現されます。64 kbit/s の固定ビット レートで動作します。同時に、説明したアルゴリズムにより、品質とビット レートのトレードオフが最先端に近い固定ビット レート コーディングが可能になります。iLBC コーデックに適した RTP ペイロード形式は、[1] で指定されています。"
    },
    {
      "indent": 3,
      "text": "Some of the applications for which this coder is suitable are real time communications such as telephony and videoconferencing, streaming audio, archival, and messaging.",
      "ja": "このコーダーが適しているアプリケーションには、電話やビデオ会議、ストリーミング オーディオ、アーカイブ、メッセージングなどのリアルタイム通信があります。"
    },
    {
      "indent": 3,
      "text": "Cable Television Laboratories (CableLabs(R)) has adopted iLBC as a mandatory PacketCable(TM) audio codec standard for VoIP over Cable applications [3].",
      "ja": "Cable Television Laboratories (CableLabs(R)) は、VoIP over Cable アプリケーションの必須 PacketCable(TM) オーディオ コーデック標準として iLBC を採用しました [3]。"
    },
    {
      "indent": 3,
      "text": "This document is organized as follows. Section 2 gives a brief outline of the codec. The specific encoder and decoder algorithms are explained in sections 3 and 4, respectively. Appendix A provides a c-code reference implementation.",
      "ja": "この文書は次のように構成されています。セクション 2 では、コーデックの概要を説明します。具体的なエンコーダとデコーダのアルゴリズムについては、それぞれセクション 3 とセクション 4 で説明します。付録 A では、C コードのリファレンス実装を提供します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [2].",
      "ja": "この文書のキーワード「しなければならない」、「してはならない」、「必須」、「しなければならない」、「してはならない」、「すべきである」、「すべきではない」、「推奨」、「してもよい」、「任意」は次のとおりです。BCP 14、RFC 2119 [2] に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Outline of the Codec",
      "section_title": true,
      "ja": "2. コーデックの概要"
    },
    {
      "indent": 3,
      "text": "The codec consists of an encoder and a decoder as described in sections 2.1 and 2.2, respectively.",
      "ja": "コーデックは、セクション 2.1 と 2.2 でそれぞれ説明されているエンコーダとデコーダで構成されます。"
    },
    {
      "indent": 3,
      "text": "The essence of the codec is LPC and block-based coding of the LPC residual signal. For each 160/240 (20 ms/30 ms) sample block, the following major steps are performed: A set of LPC filters are computed, and the speech signal is filtered through them to produce the residual signal. The codec uses scalar quantization of the dominant part, in terms of energy, of the residual signal for the block. The dominant state is of length 57/58 (20 ms/30 ms) samples and forms a start state for dynamic codebooks constructed from the already coded parts of the residual signal. These dynamic codebooks are used to code the remaining parts of the residual signal. By this method, coding independence between blocks is achieved, resulting in elimination of propagation of perceptual degradations due to packet loss. The method facilitates high-quality packet loss concealment (PLC).",
      "ja": "コーデックの本質は、LPC および LPC 残差信号のブロックベースのコーディングです。160/240 (20 ms/30 ms) サンプル ブロックごとに、次の主要な手順が実行されます。一連の LPC フィルターが計算され、音声信号がそれらを通じてフィルターされて残差信号が生成されます。コーデックは、ブロックの残差信号のエネルギーの観点から支配的な部分のスカラー量子化を使用します。ドミナント状態は長さ 57/58 (20 ms/30 ms) サンプルであり、残差信号の既に符号化された部分から構築された動的コードブックの開始状態を形成します。これらの動的コードブックは、残差信号の残りの部分をコーディングするために使用されます。この方法により、ブロック間の符号化の独立性が達成され、パケット損失による知覚劣化の伝播が排除されます。この方法により、高品質のパケット損失隠蔽 (PLC) が容易になります。"
    },
    {
      "indent": 0,
      "text": "2.1. Encoder",
      "section_title": true,
      "ja": "2.1. エンコーダ"
    },
    {
      "indent": 3,
      "text": "The input to the encoder SHOULD be 16 bit uniform PCM sampled at 8 kHz. It SHOULD be partitioned into blocks of BLOCKL=160/240 samples for the 20/30 ms frame size. Each block is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each. For 30 ms frame size, the encoder performs two LPC_FILTERORDER=10 linear-predictive coding (LPC) analyses. The first analysis applies a smooth window centered over the second sub-block and extending to the middle of the fifth sub-block. The second LPC analysis applies a smooth asymmetric window centered over the fifth sub-block and extending to the end of the sixth sub-block. For 20 ms frame size, one LPC_FILTERORDER=10 linear-predictive coding (LPC) analysis is performed with a smooth window centered over the third sub-frame.",
      "ja": "エンコーダへの入力は、8 kHz でサンプリングされた 16 ビット均一 PCM である必要があります。20/30 ミリ秒のフレーム サイズに対して、BLOCKL=160/240 サンプルのブロックに分割されるべきです (SHOULD)。各ブロックは、それぞれ SUBL=40 サンプルの NSUB=4/6 の連続したサブブロックに分割されます。30 ミリ秒のフレーム サイズの場合、エンコーダは 2 つの LPC_FILTERORDER=10 線形予測コーディング (LPC) 分析を実行します。最初の分析では、2 番目のサブブロックを中心とし、5 番目のサブブロックの中央まで拡張するスムーズ ウィンドウを適用します。2 番目の LPC 分析は、5 番目のサブブロックを中心にして 6 番目のサブブロックの終わりまで広がる滑らかな非対称ウィンドウを適用します。20 ms フレーム サイズの場合、1 回の LPC_FILTERORDER=10 線形予測コーディング (LPC) 分析が、3 番目のサブフレームの中央にあるスムーズ ウィンドウで実行されます。"
    },
    {
      "indent": 3,
      "text": "For each of the LPC analyses, a set of line-spectral frequencies (LSFs) are obtained, quantized, and interpolated to obtain LSF coefficients for each sub-block. Subsequently, the LPC residual is computed by using the quantized and interpolated LPC analysis filters.",
      "ja": "各 LPC 解析では、線スペクトル周波数 (LSF) のセットが取得、量子化、補間されて、各サブブロックの LSF 係数が取得されます。続いて、量子化および補間された LPC 分析フィルターを使用して、LPC 残差が計算されます。"
    },
    {
      "indent": 3,
      "text": "The two consecutive sub-blocks of the residual exhibiting the maximal weighted energy are identified. Within these two sub-blocks, the start state (segment) is selected from two choices: the first 57/58 samples or the last 57/58 samples of the two consecutive sub-blocks. The selected segment is the one of higher energy. The start state is encoded with scalar quantization.",
      "ja": "最大の重み付けされたエネルギーを示す残差の 2 つの連続するサブブロックが識別されます。これら 2 つのサブブロック内で、開始状態 (セグメント) は 2 つの選択肢から選択されます: 2 つの連続するサブブロックの最初の 57/58 サンプルまたは最後の 57/58 サンプルです。選択されたセグメントは、より高いエネルギーのセグメントです。開始状態はスカラー量子化でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "A dynamic codebook encoding procedure is used to encode 1) the 23/22 (20 ms/30 ms) remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the two sub-blocks containing the start state or a 40-sample sub-block. This target can consist of samples indexed forward in time or backward in time, depending on the location of the start state.",
      "ja": "動的コードブック符号化手順を使用して、1) 開始状態を含む 2 つのサブブロック内の残りの 23/22 (20 ミリ秒/30 ミリ秒) サンプルを符号化します。2) 開始状態の後のサブブロック。3) 開始状態の前のサブブロック。したがって、符号化ターゲットは、開始状態を含む 2 つのサブブロックの残りの 23/22 サンプル、または 40 サンプルのサブブロックのいずれかになります。このターゲットは、開始状態の位置に応じて、時間的に前方または時間的に後方にインデックス付けされたサンプルで構成されます。"
    },
    {
      "indent": 3,
      "text": "The codebook coding is based on an adaptive codebook built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as the target vector, ending at the sample instant prior to the first sample instant represented in the target vector. The codebook is used in CB_NSTAGES=3 stages in a successive refinement approach, and the resulting three code vector gains are encoded with 5-, 4-, and 3-bit scalar quantization, respectively.",
      "ja": "コードブックのコーディングは、ブロックの既にエンコードされた部分からデコードされた LPC 励振サンプルを含むコードブック メモリから構築された適応コードブックに基づいています。これらのサンプルは、ターゲット ベクトルと同じ時間方向にインデックス付けされ、ターゲット ベクトルで表される最初のサンプル瞬間より前のサンプル瞬間で終了します。コードブックは、逐次リファインメント手法の CB_NSTAGES=3 ステージで使用され、結果として得られる 3 つのコード ベクトル ゲインは、それぞれ 5、4、および 3 ビットのスカラー量子化でエンコードされます。"
    },
    {
      "indent": 3,
      "text": "The codebook search method employs noise shaping derived from the LPC filters, and the main decision criterion is to minimize the squared error between the target vector and the code vectors. Each code vector in this codebook comes from one of CB_EXPAND=2 codebook sections. The first section is filled with delayed, already encoded residual vectors. The code vectors of the second codebook section are constructed by predefined linear combinations of vectors in the first section of the codebook.",
      "ja": "コードブック検索方法では、LPC フィルターから得られるノイズ シェーピングが使用され、主な決定基準は、ターゲット ベクトルとコード ベクトル間の二乗誤差を最小限に抑えることです。このコードブックの各コード ベクトルは、CB_EXPAND=2 コードブック セクションの 1 つから取得されます。最初のセクションは、遅延された、すでにエンコードされた残差ベクトルで埋められています。コードブックの 2 番目のセクションのコード ベクトルは、コードブックの最初のセクションのベクトルの事前定義された線形結合によって構築されます。"
    },
    {
      "indent": 3,
      "text": "As codebook encoding with squared-error matching is known to produce a coded signal of less power than does the scalar quantized start state signal, a gain re-scaling method is implemented by a refined search for a better set of codebook gains in terms of power matching after encoding. This is done by searching for a higher value of the gain factor for the first stage codebook, as the subsequent stage codebook gains are scaled by the first stage gain.",
      "ja": "二乗誤差マッチングを使用したコードブック符号化は、スカラー量子化された開始状態信号よりも低い電力の符号化信号を生成することが知られているため、電力の観点からより適切なコードブック ゲインのセットを絞り込んだ検索によってゲイン再スケーリング方法が実装されます。エンコード後のマッチング。これは、後続ステージのコードブックのゲインが第 1 ステージのゲインによって調整されるため、第 1 ステージのコードブックのゲイン係数のより高い値を検索することによって行われます。"
    },
    {
      "indent": 0,
      "text": "2.2. Decoder",
      "section_title": true,
      "ja": "2.2. デコーダ"
    },
    {
      "indent": 3,
      "text": "Typically for packet communications, a jitter buffer placed at the receiving end decides whether the packet containing an encoded signal block has been received or lost. This logic is not part of the codec described here. For each encoded signal block received the decoder performs a decoding. For each lost signal block, the decoder performs a PLC operation.",
      "ja": "通常、パケット通信の場合、受信側に配置されたジッター バッファーによって、符号化された信号ブロックを含むパケットが受信されたか失われたかが決まります。このロジックは、ここで説明するコーデックの一部ではありません。受信した符号化された信号ブロックごとに、デコーダは復号化を実行します。失われた信号ブロックごとに、デコーダは PLC 操作を実行します。"
    },
    {
      "indent": 3,
      "text": "The decoding for each block starts by decoding and interpolating the LPC coefficients. Subsequently the start state is decoded.",
      "ja": "各ブロックの復号化は、LPC 係数の復号化と補間から始まります。その後、開始状態がデコードされます。"
    },
    {
      "indent": 3,
      "text": "For codebook-encoded segments, each segment is decoded by constructing the three code vectors given by the received codebook indices in the same way that the code vectors were constructed in the encoder. The three gain factors are also decoded and the resulting decoded signal is given by the sum of the three codebook vectors scaled with respective gain.",
      "ja": "コードブックでエンコードされたセグメントの場合、各セグメントは、エンコーダでコード ベクトルが構築されたのと同じ方法で、受信したコードブック インデックスによって指定された 3 つのコード ベクトルを構築することによってデコードされます。3 つのゲイン係数もデコードされ、結果としてデコードされた信号は、それぞれのゲインでスケーリングされた 3 つのコードブック ベクトルの合計によって得られます。"
    },
    {
      "indent": 3,
      "text": "An enhancement algorithm is applied to the reconstructed excitation signal. This enhancement augments the periodicity of voiced speech regions. The enhancement is optimized under the constraint that the modification signal (defined as the difference between the enhanced excitation and the excitation signal prior to enhancement) has a short-time energy that does not exceed a preset fraction of the short-time energy of the excitation signal prior to enhancement.",
      "ja": "再構築された励起信号に強化アルゴリズムが適用されます。この拡張により、有声音声領域の周期性が強化されます。強化は、修正信号 (強化された励起と強化前の励起信号の差として定義される) の短時間エネルギーが励起の短時間エネルギーの事前設定された部分を超えないという制約の下で最適化されます。強化前の信号。"
    },
    {
      "indent": 3,
      "text": "A packet loss concealment (PLC) operation is easily embedded in the decoder. The PLC operation can, e.g., be based on repeating LPC filters and obtaining the LPC residual signal by using a long-term prediction estimate from previous residual blocks.",
      "ja": "パケット損失隠蔽 (PLC) 操作はデコーダに簡単に埋め込まれます。ＰＬＣ動作は、例えば、ＬＰＣフィルタを繰り返し、以前の残差ブロックからの長期予測推定を使用することによってＬＰＣ残差信号を取得することに基づくことができる。"
    },
    {
      "indent": 0,
      "text": "3. Encoder Principles",
      "section_title": true,
      "ja": "3. エンコーダの原理"
    },
    {
      "indent": 3,
      "text": "The following block diagram is an overview of all the components of the iLBC encoding procedure. The description of the blocks contains references to the section where that particular procedure is further described.",
      "ja": "次のブロック図は、iLBC エンコード手順のすべてのコンポーネントの概要です。ブロックの説明には、その特定の手順がさらに説明されているセクションへの参照が含まれています。"
    },
    {
      "indent": 3,
      "text": "          +-----------+    +---------+    +---------+\nspeech -> | 1. Pre P  | -> | 2. LPC  | -> | 3. Ana  | ->\n          +-----------+    +---------+    +---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "   +---------------+   +--------------+\n-> | 4. Start Sel  | ->| 5. Scalar Qu | ->\n   +---------------+   +--------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "      +--------------+    +---------------+\n   -> |6. CB Search  | -> | 7. Packetize  | -> payload\n   |  +--------------+ |  +---------------+\n   ----<---------<------\nsub-frame 0..2/4 (20 ms/30 ms)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.1. Flow chart of the iLBC encoder",
      "ja": "図3.1。iLBCエンコーダのフローチャート"
    },
    {
      "indent": 3,
      "text": "1. Pre-process speech with a HP filter, if needed (section 3.1).",
      "ja": "1. 必要に応じて、HP フィルターを使用して音声を前処理します (セクション 3.1)。"
    },
    {
      "indent": 3,
      "text": "2. Compute LPC parameters, quantize, and interpolate (section 3.2).",
      "ja": "2. LPC パラメータを計算し、量子化し、補間します (セクション 3.2)。"
    },
    {
      "indent": 3,
      "text": "3. Use analysis filters on speech to compute residual (section 3.3).",
      "ja": "3. 音声の分析フィルターを使用して残差を計算します (セクション 3.3)。"
    },
    {
      "indent": 3,
      "text": "4. Select position of 57/58-sample start state (section 3.5).",
      "ja": "4. 57/58 サンプル開始ステートの位置を選択します (3.5 節)。"
    },
    {
      "indent": 3,
      "text": "5. Quantize the 57/58-sample start state with scalar quantization (section 3.5).",
      "ja": "5. スカラー量子化を使用して 57/58 サンプルの開始状態を量子化します (セクション 3.5)。"
    },
    {
      "indent": 3,
      "text": "6. Search the codebook for each sub-frame. Start with 23/22 sample block, then encode sub-blocks forward in time, and then encode sub-blocks backward in time. For each block, the steps in Figure 3.4 are performed (section 3.6).",
      "ja": "6. 各サブフレームのコードブックを検索します。23/22 サンプル ブロックから開始し、次にサブブロックを時間的に順方向にエンコードし、次にサブブロックを時間的に逆方向にエンコードします。各ブロックに対して、図 3.4 の手順が実行されます (セクション 3.6)。"
    },
    {
      "indent": 3,
      "text": "7. Packetize the bits into the payload specified in Table 3.2.",
      "ja": "7. ビットを表 3.2 で指定されたペイロードにパケット化します。"
    },
    {
      "indent": 3,
      "text": "The input to the encoder SHOULD be 16-bit uniform PCM sampled at 8 kHz. Also it SHOULD be partitioned into blocks of BLOCKL=160/240 samples. Each block input to the encoder is divided into NSUB=4/6 consecutive sub-blocks of SUBL=40 samples each.",
      "ja": "エンコーダへの入力は、8 kHz でサンプリングされた 16 ビット均一 PCM である必要があります。また、BLOCKL=160/240 サンプルのブロックに分割する必要があります (SHOULD)。エンコーダへの各ブロック入力は、それぞれ SUBL=40 サンプルの NSUB=4/6 の連続したサブブロックに分割されます。"
    },
    {
      "indent": 13,
      "text": "0        39        79       119       159\n+---------------------------------------+\n|    1    |    2    |    3    |    4    |\n+---------------------------------------+\n               20 ms frame",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "0        39        79       119       159       199       239\n+-----------------------------------------------------------+\n|    1    |    2    |    3    |    4    |    5    |    6    |\n+-----------------------------------------------------------+\n                               30 ms frame\nFigure 3.2. One input block to the encoder for 20 ms (with four sub-\nframes) and 30 ms (with six sub-frames).",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.1. Pre-processing",
      "section_title": true,
      "ja": "3.1. 前処理"
    },
    {
      "indent": 3,
      "text": "In some applications, the recorded speech signal contains DC level and/or 50/60 Hz noise. If these components have not been removed prior to the encoder call, they should be removed by a high-pass filter. A reference implementation of this, using a filter with a cutoff frequency of 90 Hz, can be found in Appendix A.28.",
      "ja": "アプリケーションによっては、録音された音声信号に DC レベルや 50/60 Hz ノイズが含まれる場合があります。これらのコンポーネントがエンコーダ呼び出しの前に削除されていない場合は、ハイパス フィルターによって削除する必要があります。カットオフ周波数 90 Hz のフィルターを使用したこのリファレンス実装は、付録 A.28 にあります。"
    },
    {
      "indent": 0,
      "text": "3.2. LPC Analysis and Quantization",
      "section_title": true,
      "ja": "3.2. LPC 分析と量子化"
    },
    {
      "indent": 3,
      "text": "The input to the LPC analysis module is a possibly high-pass filtered speech buffer, speech_hp, that contains 240/300 (LPC_LOOKBACK + BLOCKL = 80/60 + 160/240 = 240/300) speech samples, where samples 0 through 79/59 are from the previous block and samples 80/60 through 239/299 are from the current block. No look-ahead into the next block is used. For the very first block processed, the look-back samples are assumed to be zeros.",
      "ja": "LPC 分析モジュールへの入力は、おそらくハイパス フィルター処理された音声バッファー speech_hp で、これには 240/300 (LPC_LOOKBACK BLOCKL = 80/60 160/240 = 240/300) 音声サンプルが含まれます。サンプル 0 ～ 79/59 は次のとおりです。前のブロックからのものであり、サンプル 80/60 から 239/299 は現在のブロックからのものです。次のブロックへの先読みは使用されません。処理される最初のブロックでは、ルックバック サンプルはゼロであると想定されます。"
    },
    {
      "indent": 3,
      "text": "For each input block, the LPC analysis calculates one/two set(s) of LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation method and the Levinson-Durbin recursion. These coefficients are converted to the Line Spectrum Frequency representation. In the 20 ms case, the single lsf set represents the spectral characteristics as measured at the center of the third sub-block. For 30 ms frames, the first set, lsf1, represents the spectral properties of the input signal at the center of the second sub-block, and the other set, lsf2, represents the spectral characteristics as measured at the center of the fifth sub-block. The details of the computation for 30 ms frames are described in sections 3.2.1 through 3.2.6. Section 3.2.7 explains how the LPC Analysis and Quantization differs for 20 ms frames.",
      "ja": "各入力ブロックについて、LPC 分析は、自己相関法とレビンソン・ダービン再帰を使用して、LPC_FILTERORDER=10 個の LPC フィルター係数の 1 つまたは 2 つのセットを計算します。これらの係数は線スペクトル周波数表現に変換されます。20 ms の場合、単一の lsf セットは 3 番目のサブブロックの中心で測定されたスペクトル特性を表します。30 ms フレームの場合、最初のセット lsf1 は 2 番目のサブブロックの中心での入力信号のスペクトル特性を表し、もう 1 つのセット lsf2 は 5 番目のサブブロックの中心で測定されたスペクトル特性を表します。ブロック。30 ms フレームの計算の詳細については、セクション 3.2.1 ～ 3.2.6 で説明します。セクション 3.2.7 では、20 ms フレームの LPC 分析と量子化がどのように異なるかを説明します。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Computation of Autocorrelation Coefficients",
      "section_title": true,
      "ja": "3.2.1. 自己相関係数の計算"
    },
    {
      "indent": 3,
      "text": "The first step in the LPC analysis procedure is to calculate autocorrelation coefficients by using windowed speech samples. This windowing is the only difference in the LPC analysis procedure for the two sets of coefficients. For the first set, a 240-sample-long standard symmetric Hanning window is applied to samples 0 through 239 of the input data. The first window, lpc_winTbl, is defined as",
      "ja": "LPC 分析手順の最初のステップは、ウィンドウ化された音声サンプルを使用して自己相関係数を計算することです。このウィンドウ処理が、2 つの係数セットに対する LPC 分析手順の唯一の違いです。最初のセットでは、240 サンプル長の標準対称ハニング ウィンドウが入力データのサンプル 0 ～ 239 に適用されます。最初のウィンドウ lpc_winTbl は次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "lpc_winTbl[i]= 0.5 * (1.0 - cos((2*PI*(i+1))/(BLOCKL+1)));\n         i=0,...,119\nlpc_winTbl[i] = winTbl[BLOCKL - i - 1]; i=120,...,239",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The windowed speech speech_hp_win1 is then obtained by multiplying the first 240 samples of the input speech buffer with the window coefficients:",
      "ja": "次に、ウィンドウ化された音声 speech_hp_win1 は、入力音声バッファの最初の 240 サンプルにウィンドウ係数を乗算して取得されます。"
    },
    {
      "indent": 6,
      "text": "speech_hp_win1[i] = speech_hp[i] * lpc_winTbl[i];\n         i=0,...,BLOCKL-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "From these 240 windowed speech samples, 11 (LPC_FILTERORDER + 1) autocorrelation coefficients, acf1, are calculated:",
      "ja": "これらの 240 のウィンドウ処理された音声サンプルから、11 (LPC_FILTERORDER 1) の自己相関係数 acf1 が計算されます。"
    },
    {
      "indent": 6,
      "text": "acf1[lag] += speech_hp_win1[n] * speech_hp_win1[n + lag];\n         lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In order to make the analysis more robust against numerical precision problems, a spectral smoothing procedure is applied by windowing the autocorrelation coefficients before the LPC coefficients are computed. Also, a white noise floor is added to the autocorrelation function by multiplying coefficient zero by 1.0001 (40dB below the energy of the windowed speech signal). These two steps are implemented by multiplying the autocorrelation coefficients with the following window:",
      "ja": "数値精度の問題に対して解析をより堅牢にするために、LPC 係数が計算される前に自己相関係数をウィンドウ処理することによってスペクトル平滑化手順が適用されます。また、ホワイト ノイズ フロアは、係数ゼロに 1.0001 (ウィンドウ処理された音声信号のエネルギーより 40dB 低い) を乗算することによって自己相関関数に追加されます。これら 2 つのステップは、次のウィンドウで自己相関係数を乗算することによって実装されます。"
    },
    {
      "indent": 6,
      "text": "lpc_lagwinTbl[0] = 1.0001;\nlpc_lagwinTbl[i] = exp(-0.5 * ((2 * PI * 60.0 * i) /FS)^2);\n         i=1,...,LPC_FILTERORDER\n         where FS=8000 is the sampling frequency",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Then, the windowed acf function acf1_win is obtained by",
      "ja": "次に、ウィンドウ化された ACF 関数 acf1_win は次のように取得されます。"
    },
    {
      "indent": 6,
      "text": "acf1_win[i] = acf1[i] * lpc_lagwinTbl[i];\n         i=0,...,LPC_FILTERORDER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second set of autocorrelation coefficients, acf2_win, are obtained in a similar manner. The window, lpc_asymwinTbl, is applied to samples 60 through 299, i.e., the entire current block. The window consists of two segments, the first (samples 0 to 219) being half a Hanning window with length 440 and the second a quarter of a cycle of a cosine wave. By using this asymmetric window, an LPC analysis centered in the fifth sub-block is obtained without the need for any look-ahead, which would add delay. The asymmetric window is defined as",
      "ja": "2 番目の自己相関係数セット acf2_win も同様の方法で取得されます。ウィンドウ lpc_asymwinTbl は、サンプル 60 から 299、つまり現在のブロック全体に適用されます。ウィンドウは 2 つのセグメントで構成され、最初のセグメント (サンプル 0 ～ 219) は長さ 440 のハニング ウィンドウの半分であり、2 番目のセグメントは余弦波の 4 分の 1 サイクルです。この非対称ウィンドウを使用することにより、遅延を追加する先読みを必要とせずに、5 番目のサブブロックを中心とする LPC 分析が得られます。非対称ウィンドウは次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "lpc_asymwinTbl[i] = (sin(PI * (i + 1) / 441))^2; i=0,...,219",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "lpc_asymwinTbl[i] = cos((i - 220) * PI / 40); i=220,...,239",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and the windowed speech is computed by",
      "ja": "ウィンドウ化された音声は次のように計算されます。"
    },
    {
      "indent": 6,
      "text": "speech_hp_win2[i] = speech_hp[i + LPC_LOOKBACK] *\n         lpc_asymwinTbl[i];  i=0,....BLOCKL-1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The windowed autocorrelation coefficients are then obtained in exactly the same way as for the first analysis instance.",
      "ja": "その後、最初の分析インスタンスの場合とまったく同じ方法で、ウィンドウ処理された自己相関係数が取得されます。"
    },
    {
      "indent": 3,
      "text": "The generation of the windows lpc_winTbl, lpc_asymwinTbl, and lpc_lagwinTbl are typically done in advance, and the arrays are stored in ROM rather than repeating the calculation for every block.",
      "ja": "ウィンドウ lpc_winTbl、lpc_asymwinTbl、および lpc_lagwinTbl の生成は通常、事前に行われ、ブロックごとに計算を繰り返すのではなく、配列が ROM に保存されます。"
    },
    {
      "indent": 0,
      "text": "3.2.2. Computation of LPC Coefficients",
      "section_title": true,
      "ja": "3.2.2. LPC 係数の計算"
    },
    {
      "indent": 3,
      "text": "From the 2 x 11 smoothed autocorrelation coefficients, acf1_win and acf2_win, the 2 x 11 LPC coefficients, lp1 and lp2, are calculated in the same way for both analysis locations by using the well known Levinson-Durbin recursion. The first LPC coefficient is always 1.0, resulting in ten unique coefficients.",
      "ja": "2 x 11 の平滑化自己相関係数 acf1_win および acf2_win から、2 x 11 LPC 係数 lp1 および lp2 は、よく知られているレビンソン・ダービン再帰法を使用して、両方の分析位置で同じ方法で計算されます。最初の LPC 係数は常に 1.0 であり、結果として 10 個の一意の係数が得られます。"
    },
    {
      "indent": 3,
      "text": "After determining the LPC coefficients, a bandwidth expansion procedure is applied to smooth the spectral peaks in the short-term spectrum. The bandwidth addition is obtained by the following modification of the LPC coefficients:",
      "ja": "LPC 係数を決定した後、帯域幅拡張手順を適用して、短期スペクトルのスペクトル ピークを平滑化します。帯域幅の追加は、LPC 係数を次のように変更することで得られます。"
    },
    {
      "indent": 6,
      "text": "lp1_bw[i] = lp1[i] * chirp^i; i=0,...,LPC_FILTERORDER\nlp2_bw[i] = lp2[i] * chirp^i; i=0,...,LPC_FILTERORDER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where \"chirp\" is a real number between 0 and 1. It is RECOMMENDED to use a value of 0.9.",
      "ja": "ここで、「chirp」は 0 ～ 1 の間の実数です。値 0.9 を使用することが推奨されます。"
    },
    {
      "indent": 0,
      "text": "3.2.3. Computation of LSF Coefficients from LPC Coefficients",
      "section_title": true,
      "ja": "3.2.3. LPC 係数からの LSF 係数の計算"
    },
    {
      "indent": 3,
      "text": "Thus far, two sets of LPC coefficients that represent the short-term spectral characteristics of the speech signal for two different time locations within the current block have been determined. These coefficients SHOULD be quantized and interpolated. Before this is done, it is advantageous to convert the LPC parameters into another type of representation called Line Spectral Frequencies (LSF). The LSF parameters are used because they are better suited for quantization and interpolation than the regular LPC coefficients. Many computationally efficient methods for calculating the LSFs from the LPC coefficients have been proposed in the literature. The detailed implementation of one applicable method can be found in Appendix A.26. The two arrays of LSF coefficients obtained, lsf1 and lsf2, are of dimension 10 (LPC_FILTERORDER).",
      "ja": "これまでのところ、現在のブロック内の 2 つの異なる時間位置における音声信号の短期スペクトル特性を表す 2 組の LPC 係数が決定されています。これらの係数は量子化され、補間されるべきです(SHOULD)。これを行う前に、LPC パラメータを線スペクトル周波数 (LSF) と呼ばれる別のタイプの表現に変換すると有利です。LSF パラメータが使用されるのは、通常の LPC 係数よりも量子化と補間に適しているためです。LPC 係数から LSF を計算するための計算効率の高い方法が文献で多数提案されています。適用可能な 1 つのメソッドの詳細な実装については、付録 A.26 を参照してください。取得された LSF 係数の 2 つの配列 lsf1 と lsf2 は、次元 10 (LPC_FILTERORDER) です。"
    },
    {
      "indent": 0,
      "text": "3.2.4. Quantization of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.4. LSF 係数の量子化"
    },
    {
      "indent": 3,
      "text": "Because the LPC filters defined by the two sets of LSFs are also needed in the decoder, the LSF parameters need to be quantized and transmitted as side information. The total number of bits required to represent the quantization of the two LSF representations for one block of speech is 40, with 20 bits used for each of lsf1 and lsf2.",
      "ja": "2 つの LSF セットによって定義された LPC フィルターもデコーダで必要となるため、LSF パラメータを量子化し、サイド情報として送信する必要があります。1 つの音声ブロックの 2 つの LSF 表現の量子化を表すのに必要なビットの総数は 40 で、lsf1 と lsf2 のそれぞれに 20 ビットが使用されます。"
    },
    {
      "indent": 3,
      "text": "For computational and storage reasons, the LSF vectors are quantized using three-split vector quantization (VQ). That is, the LSF vectors are split into three sub-vectors that are each quantized with a regular VQ. The quantized versions of lsf1 and lsf2, qlsf1 and qlsf2, are obtained by using the same memoryless split VQ. The length of each of these two LSF vectors is 10, and they are split into three sub-vectors containing 3, 3, and 4 values, respectively.",
      "ja": "計算およびストレージ上の理由から、LSF ベクトルは 3 分割ベクトル量子化 (VQ) を使用して量子化されます。つまり、LSF ベクトルは 3 つのサブベクトルに分割され、それぞれが通常の VQ で量子化されます。lsf1 と lsf2 の量子化バージョン、qlsf1 と qlsf2 は、同じメモリレス分割 VQ を使用して取得されます。これら 2 つの LSF ベクトルの長さはそれぞれ 10 で、それぞれ 3、3、および 4 の値を含む 3 つのサブベクトルに分割されます。"
    },
    {
      "indent": 3,
      "text": "For each of the sub-vectors, a separate codebook of quantized values has been designed with a standard VQ training method for a large database containing speech from a large number of speakers recorded under various conditions. The size of each of the three codebooks associated with the split definitions above is",
      "ja": "サブベクトルごとに、量子化値の個別のコードブックが、さまざまな条件下で録音された多数の話者からの音声を含む大規模なデータベース用の標準 VQ トレーニング方法を使用して設計されています。上記の分割定義に関連付けられた 3 つのコードブックのそれぞれのサイズは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The actual values of the vector quantization codebook that must be used can be found in the reference code of Appendix A. Both sets of LSF coefficients, lsf1 and lsf2, are quantized with a standard memoryless split vector quantization (VQ) structure using the squared error criterion in the LSF domain. The split VQ quantization consists of the following steps:",
      "ja": "使用する必要があるベクトル量子化コードブックの実際の値は、付録 A のリファレンス コードに記載されています。LSF 係数のセット、lsf1 と lsf2 は両方とも、二乗誤差を使用する標準のメモリレス分割ベクトル量子化 (VQ) 構造で量子化されます。LSF ドメインの基準。分割 VQ 量子化は次の手順で構成されます。"
    },
    {
      "indent": 3,
      "text": "1) Quantize the first three LSF coefficients (1 - 3) with a VQ codebook of size 64. 2) Quantize the next three LSF coefficients 4 - 6 with VQ a codebook of size 128. 3) Quantize the last four LSF coefficients (7 - 10) with a VQ codebook of size 128.",
      "ja": "1) 最初の 3 つの LSF 係数 (1 ～ 3) をサイズ 64 の VQ コードブックで量子化します。 2) 次の 3 つの LSF 係数 4 ～ 6 を、サイズ 128 の VQ コードブックで量子化します。 3) 最後の 4 つの LSF 係数 (7 ～ 10) を量子化します。) サイズ 128 の VQ コードブックを使用します。"
    },
    {
      "indent": 3,
      "text": "This procedure, repeated for lsf1 and lsf2, gives six quantization indices and the quantized sets of LSF coefficients qlsf1 and qlsf2. Each set of three indices is encoded with 6 + 7 + 7 = 20 bits. The total number of bits used for LSF quantization in a block is thus 40 bits.",
      "ja": "この手順を lsf1 と lsf2 に対して繰り返すと、6 つの量子化インデックスと量子化された LSF 係数のセット qlsf1 と qlsf2 が得られます。3 つのインデックスの各セットは 6 7 7 = 20 ビットでエンコードされます。したがって、ブロック内の LSF 量子化に使用されるビットの総数は 40 ビットになります。"
    },
    {
      "indent": 0,
      "text": "3.2.5. Stability Check of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.5. LSF 係数の安定性チェック"
    },
    {
      "indent": 3,
      "text": "The LSF representation of the LPC filter has the convenient property that the coefficients are ordered by increasing value, i.e., lsf(n-1) < lsf(n), 0 < n < 10, if the corresponding synthesis filter is stable. As we are employing a split VQ scheme, it is possible that at the split boundaries the LSF coefficients are not ordered correctly and hence that the corresponding LP filter is unstable. To ensure that the filter used is stable, a stability check is performed for the quantized LSF vectors. If it turns out that the coefficients are not ordered appropriately (with a safety margin of 50 Hz to ensure that formant peaks are not too narrow), they will be moved apart. The detailed method for this can be found in Appendix A.40. The same procedure is performed in the decoder. This ensures that exactly the same LSF representations are used in both encoder and decoder.",
      "ja": "LPC フィルターの LSF 表現には、対応する合成フィルターが安定している場合、係数が値の増加順に並べられるという便利な特性があります (つまり、lsf(n-1) < lsf(n)、0 < n < 10)。分割 VQ スキームを採用しているため、分割境界で LSF 係数が正しく順序付けされておらず、対応する LP フィルターが不安定になる可能性があります。使用されるフィルターが安定していることを確認するために、量子化された LSF ベクトルに対して安定性チェックが実行されます。係数が適切に順序付けされていないことが判明した場合 (フォルマントのピークが狭すぎないように 50 Hz の安全マージンを設けます)、係数は離されます。この詳細な方法については、付録 A.40 を参照してください。同じ手順がデコーダでも実行されます。これにより、エンコーダとデコーダの両方でまったく同じ LSF 表現が使用されることが保証されます。"
    },
    {
      "indent": 0,
      "text": "3.2.6. Interpolation of LSF Coefficients",
      "section_title": true,
      "ja": "3.2.6. LSF 係数の補間"
    },
    {
      "indent": 3,
      "text": "From the two sets of LSF coefficients that are computed for each block of speech, different LSFs are obtained for each sub-block by means of interpolation. This procedure is performed for the original LSFs (lsf1 and lsf2), as well as the quantized versions qlsf1 and qlsf2, as both versions are used in the encoder. Here follows a brief summary of the interpolation scheme; the details are found in the c-code of Appendix A. In the first sub-block, the average of the second LSF vector from the previous block and the first LSF vector in the current block is used. For sub-blocks two through five, the LSFs used are obtained by linear interpolation from lsf1 (and qlsf1) to lsf2 (and qlsf2), with lsf1 used in sub-block two and lsf2 in sub-block five. In the last sub-block, lsf2 is used. For the very first block it is assumed that the last LSF vector of the previous block is equal to a predefined vector, lsfmeanTbl, obtained by calculating the mean LSF vector of the LSF design database.",
      "ja": "音声のブロックごとに計算された 2 つの LSF 係数セットから、補間によってサブブロックごとに異なる LSF が取得されます。この手順は、元の LSF (lsf1 および lsf2) だけでなく、量子化バージョン qlsf1 および qlsf2 に対しても実行されます。これは、両方のバージョンがエンコーダーで使用されるためです。以下に補間スキームの簡単な概要を示します。詳細は付録 A の C コードを参照してください。最初のサブブロックでは、前のブロックの 2 番目の LSF ベクトルと現在のブロックの最初の LSF ベクトルの平均が使用されます。サブブロック 2 ～ 5 では、使用される LSF は lsf1 (および qlsf1) から lsf2 (および qlsf2) への線形補間によって取得されます。lsf1 はサブブロック 2 で使用され、lsf2 はサブブロック 5 で使用されます。最後のサブブロックでは、lsf2 が使用されます。一番最初のブロックでは、前のブロックの最後の LSF ベクトルが、LSF 設計データベースの平均 LSF ベクトルを計算することによって得られる事前定義ベクトル lsfmeanTbl に等しいと想定されます。"
    },
    {
      "indent": 3,
      "text": "lsfmeanTbl[LPC_FILTERORDER] = {0.281738, 0.445801, 0.663330,\n               0.962524, 1.251831, 1.533081, 1.850586, 2.137817,\n               2.481445, 2.777344}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The interpolation method is standard linear interpolation in the LSF domain. The interpolated LSF values are converted to LPC coefficients for each sub-block. The unquantized and quantized LPC coefficients form two sets of filters respectively. The unquantized analysis filter for sub-block k is defined as follows",
      "ja": "補間方法は、LSF ドメインの標準的な線形補間です。補間された LSF 値は、サブブロックごとに LPC 係数に変換されます。量子化されていない LPC 係数と量子化された LPC 係数は、それぞれ 2 組のフィルターを形成します。サブブロック k の非量子化分析フィルターは次のように定義されます。"
    },
    {
      "indent": 6,
      "text": "          ___\n          \\\nAk(z)= 1 + > ak(i)*z^(-i)\n          /__\n       i=1...LPC_FILTERORDER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The quantized analysis filter for sub-block k is defined as follows\n              ___\n              \\\n   A~k(z)= 1 + > a~k(i)*z^(-i)\n              /__\n          i=1...LPC_FILTERORDER",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A reference implementation of the lsf encoding is given in Appendix A.38. A reference implementation of the corresponding decoding can be found in Appendix A.36.",
      "ja": "lsf エンコーディングのリファレンス実装は、付録 A.38 に記載されています。対応するデコードのリファレンス実装は、付録 A.36 にあります。"
    },
    {
      "indent": 0,
      "text": "3.2.7. LPC Analysis and Quantization for 20 ms Frames",
      "section_title": true,
      "ja": "3.2.7. 20 ms フレームの LPC 分析と量子化"
    },
    {
      "indent": 3,
      "text": "As previously stated, the codec only calculates one set of LPC parameters for the 20 ms frame size as opposed to two sets for 30 ms frames. A single set of autocorrelation coefficients is calculated on the LPC_LOOKBACK + BLOCKL = 80 + 160 = 240 samples. These samples are windowed with the asymmetric window lpc_asymwinTbl, centered over the third sub-frame, to form speech_hp_win. Autocorrelation coefficients, acf, are calculated on the 240 samples in speech_hp_win and then windowed exactly as in section 3.2.1 (resulting in acf_win).",
      "ja": "前述したように、コーデックは、30 ms フレームの場合は 2 セットの LPC パラメータを計算するのに対し、20 ms フレーム サイズでは 1 セットの LPC パラメータのみを計算します。自己相関係数の単一セットは、LPC_LOOKBACK BLOCKL = 80 160 = 240 サンプルで計算されます。これらのサンプルは、3 番目のサブフレームを中心とする非対称ウィンドウ lpc_asymwinTbl でウィンドウ処理され、speech_hp_win を形成します。自己相関係数 acf は speech_hp_win の 240 サンプルで計算され、セクション 3.2.1 とまったく同じようにウィンドウ処理されます (結果として acf_win が得られます)。"
    },
    {
      "indent": 3,
      "text": "This single set of windowed autocorrelation coefficients is used to calculate LPC coefficients, LSF coefficients, and quantized LSF coefficients in exactly the same manner as in sections 3.2.3 through 3.2.4. As for the 30 ms frame size, the ten LSF coefficients are divided into three sub-vectors of size 3, 3, and 4 and quantized by using the same scheme and codebook as in section 3.2.4 to finally get 3 quantization indices. The quantized LSF coefficients are stabilized with the algorithm described in section 3.2.5.",
      "ja": "このウィンドウ処理された自己相関係数の単一セットは、セクション 3.2.3 から 3.2.4 とまったく同じ方法で、LPC 係数、LSF 係数、および量子化 LSF 係数を計算するために使用されます。30 ms のフレーム サイズに関しては、10 個の LSF 係数がサイズ 3、3、および 4 の 3 つのサブベクトルに分割され、セクション 3.2.4 と同じスキームとコードブックを使用して量子化され、最終的に 3 つの量子化インデックスが得られます。量子化された LSF 係数は、セクション 3.2.5 で説明されているアルゴリズムで安定化されます。"
    },
    {
      "indent": 3,
      "text": "From the set of LSF coefficients computed for this block and those from the previous block, different LSFs are obtained for each sub-block by means of interpolation. The interpolation is done linearly in the LSF domain over the four sub-blocks, so that the n-th sub- frame uses the weight (4-n)/4 for the LSF from old frame and the weight n/4 of the LSF from the current frame. For the very first block the mean LSF, lsfmeanTbl, is used as the LSF from the previous block. Similarly as seen in section 3.2.6, both unquantized, A(z), and quantized, A~(z), analysis filters are calculated for each of the four sub-blocks.",
      "ja": "このブロックに対して計算された LSF 係数のセットと前のブロックからの LSF 係数のセットから、補間によってサブブロックごとに異なる LSF が取得されます。補間は 4 つのサブブロックにわたる LSF ドメインで線形に行われるため、n 番目のサブフレームでは古いフレームからの LSF の重み (4-n)/4 と LSF の重み n/4 が使用されます。現在のフレームから。一番最初のブロックでは、平均 LSF lsfmeanTbl が前のブロックの LSF として使用されます。同様に、セクション 3.2.6 で見られるように、非量子化 A(z) と量子化 A~(z) の両方の分析フィルターが 4 つのサブブロックのそれぞれに対して計算されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Calculation of the Residual",
      "section_title": true,
      "ja": "3.3. 残差の計算"
    },
    {
      "indent": 3,
      "text": "The block of speech samples is filtered by the quantized and interpolated LPC analysis filters to yield the residual signal. In particular, the corresponding LPC analysis filter for each 40 sample sub-block is used to filter the speech samples for the same sub-block. The filter memory at the end of each sub-block is carried over to the LPC filter of the next sub-block. The signal at the output of each LP analysis filter constitutes the residual signal for the corresponding sub-block.",
      "ja": "音声サンプルのブロックは、量子化および補間された LPC 分析フィルターによってフィルター処理され、残差信号が生成されます。特に、各 40 サンプル サブブロックの対応する LPC 分析フィルターは、同じサブブロックの音声サンプルをフィルター処理するために使用されます。各サブブロックの終わりにあるフィルター メモリは、次のサブブロックの LPC フィルターに引き継がれます。各 LP 分析フィルターの出力における信号は、対応するサブブロックの残差信号を構成します。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the LPC analysis filters is given in Appendix A.10.",
      "ja": "LPC 分析フィルターのリファレンス実装は、付録 A.10 に記載されています。"
    },
    {
      "indent": 0,
      "text": "3.4. Perceptual Weighting Filter",
      "section_title": true,
      "ja": "3.4. 知覚重み付けフィルター"
    },
    {
      "indent": 3,
      "text": "In principle any good design of a perceptual weighting filter can be applied in the encoder without compromising this codec definition. However, it is RECOMMENDED to use the perceptual weighting filter Wk for sub-block k specified below:",
      "ja": "原理的には、知覚的重み付けフィルタの優れた設計は、このコーデックの定義を損なうことなくエンコーダに適用できます。ただし、以下に指定されるサブブロック k に対して知覚重み付けフィルター Wk を使用することが推奨されます。"
    },
    {
      "indent": 6,
      "text": "Wk(z)=1/Ak(z/LPC_CHIRP_WEIGHTDENUM), where\n                         LPC_CHIRP_WEIGHTDENUM = 0.4222",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This is a simple design with low complexity that is applied in the LPC residual domain. Here Ak(z) is the filter obtained for sub-block k from unquantized but interpolated LSF coefficients.",
      "ja": "これは、LPC 残差ドメインに適用される、複雑さの低い単純な設計です。ここで、Ak(z) は、量子化されていないが補間された LSF 係数からサブブロック k に対して取得されたフィルターです。"
    },
    {
      "indent": 0,
      "text": "3.5. Start State Encoder",
      "section_title": true,
      "ja": "3.5. 開始状態エンコーダー"
    },
    {
      "indent": 3,
      "text": "The start state is quantized by using a common 6-bit scalar quantizer for the block and a 3-bit scalar quantizer operating on scaled samples in the weighted speech domain. In the following we describe the state encoding in greater detail.",
      "ja": "開始状態は、ブロック用の共通の 6 ビット スカラー量子化器と、重み付き音声ドメインのスケーリングされたサンプルで動作する 3 ビット スカラー量子化器を使用して量子化されます。以下では、状態エンコーディングについて詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "3.5.1. Start State Estimation",
      "section_title": true,
      "ja": "3.5.1. 状態推定の開始"
    },
    {
      "indent": 3,
      "text": "The two sub-blocks containing the start state are determined by finding the two consecutive sub-blocks in the block having the highest power. Advantageously, down-weighting is used in the beginning and end of the sub-frames, i.e., the following measure is computed (NSUB=4/6 for 20/30 ms frame size):",
      "ja": "開始状態を含む 2 つのサブブロックは、ブロック内で最も高い電力を持つ 2 つの連続するサブブロックを見つけることによって決定されます。有利なことに、ダウン重み付けはサブフレームの最初と最後で使用されます。つまり、次の尺度が計算されます（20/30 ms フレーム サイズでは NSUB=4/6）。"
    },
    {
      "indent": 6,
      "text": "nsub=1,...,NSUB-1\nssqn[nsub] = 0.0;\nfor (i=(nsub-1)*SUBL; i<(nsub-1)*SUBL+5; i++)\n         ssqn[nsub] += sampEn_win[i-(nsub-1)*SUBL]*\n                           residual[i]*residual[i];\nfor (i=(nsub-1)*SUBL+5; i<(nsub+1)*SUBL-5; i++)\n         ssqn[nsub] += residual[i]*residual[i];\nfor (i=(nsub+1)*SUBL-5; i<(nsub+1)*SUBL; i++)\n         ssqn[nsub] += sampEn_win[(nsub+1)*SUBL-i-1]*\n                           residual[i]*residual[i];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where sampEn_win[5]={1/6, 2/6, 3/6, 4/6, 5/6}; MAY be used. The sub-frame number corresponding to the maximum value of ssqEn_win[nsub-1]*ssqn[nsub] is selected as the start state indicator. A weighting of ssqEn_win[]={0.8,0.9,1.0,0.9,0.8} for 30 ms frames and ssqEn_win[]={0.9,1.0,0.9} for 20 ms frames; MAY advantageously be used to bias the start state towards the middle of the frame.",
      "ja": "ここで、sampEn_win[5]={1/6、2/6、3/6、4/6、5/6};使用してもよい。ssqEn_win[nsub-1]*ssqn[nsub]の最大値に対応するサブフレーム番号が開始状態指示子として選択される。30 ミリ秒フレームの場合は ssqEn_win[]={0.8,0.9,1.0,0.9,0.8}、20 ミリ秒フレームの場合は ssqEn_win[]={0.9,1.0,0.9} の重み付け。開始状態をフレームの中央に向けてバイアスするために使用すると有利になる可能性があります。"
    },
    {
      "indent": 3,
      "text": "For 20 ms frames there are three possible positions for the two-sub-block length maximum power segment; the start state position is encoded with 2 bits. The start state position, start, MUST be encoded as",
      "ja": "20 ms フレームの場合、2 サブブロック長の最大パワー セグメントには 3 つの可能な位置があります。開始状態の位置は 2 ビットでエンコードされます。開始状態の位置 start は、次のようにエンコードされなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "start=1: start state in sub-frame 0 and 1\nstart=2: start state in sub-frame 1 and 2\nstart=3: start state in sub-frame 2 and 3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For 30 ms frames there are five possible positions of the two-sub-block length maximum power segment, the start state position is encoded with 3 bits. The start state position, start, MUST be encoded as",
      "ja": "30 ms フレームの場合、2 サブブロック長の最大パワー セグメントの可能な位置は 5 つあり、開始状態の位置は 3 ビットでエンコードされます。開始状態の位置 start は、次のようにエンコードされなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "start=1: start state in sub-frame 0 and 1\nstart=2: start state in sub-frame 1 and 2\nstart=3: start state in sub-frame 2 and 3\nstart=4: start state in sub-frame 3 and 4\nstart=5: start state in sub-frame 4 and 5",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Hence, in both cases, index 0 is not used. In order to shorten the start state for bit rate efficiency, the start state is brought down to STATE_SHORT_LEN=57 samples for 20 ms frames and STATE_SHORT_LEN=58 samples for 30 ms frames. The power of the first 23/22 and last 23/22 samples of the two sub-frame blocks identified above is computed as the sum of the squared signal sample values, and the 23/22-sample segment with the lowest power is excluded from the start state. One bit is transmitted to indicate which of the two possible 57/58 sample segments is used. The start state position within the two sub-frames determined above, state_first, MUST be encoded as",
      "ja": "したがって、どちらの場合もインデックス 0 は使用されません。ビット レート効率を高めるために開始状態を短縮するために、開始状態は 20 ms フレームの場合は STATE_SHORT_LEN=57 サンプル、30 ms フレームの場合は STATE_SHORT_LEN=58 サンプルに引き下げられます。上記で識別された 2 つのサブフレーム ブロックの最初の 23/22 サンプルと最後の 23/22 サンプルのパワーは、二乗信号サンプル値の合計として計算され、最も低いパワーを持つ 23/22 サンプル セグメントは除外されます。開始状態。1 ビットが送信され、2 つの可能な 57/58 サンプル セグメントのどれが使用されるかを示します。上記で決定された 2 つのサブフレーム内の開始状態位置、state_first は、次のようにエンコードされなければなりません (MUST)。"
    },
    {
      "indent": 6,
      "text": "state_first=1: start state is first STATE_SHORT_LEN samples\nstate_first=0: start state is last STATE_SHORT_LEN samples",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5.2. All-Pass Filtering and Scale Quantization",
      "section_title": true,
      "ja": "3.5.2. オールパスフィルタリングとスケール量子化"
    },
    {
      "indent": 3,
      "text": "The block of residual samples in the start state is first filtered by an all-pass filter with the quantized LPC coefficients as denominator and reversed quantized LPC coefficients as numerator. The purpose of this phase-dispersion filter is to get a more even distribution of the sample values in the residual signal. The filtering is performed by circular convolution, where the initial filter memory is set to zero.",
      "ja": "開始状態の残差サンプルのブロックは、まず、分母として量子化 LPC 係数、分子として逆量子化 LPC 係数を使用するオールパス フィルターによってフィルター処理されます。この位相分散フィルターの目的は、残差信号内のサンプル値のより均一な分布を取得することです。フィルタリングは循環畳み込みによって実行され、初期フィルタ メモリはゼロに設定されます。"
    },
    {
      "indent": 6,
      "text": "res(0..(STATE_SHORT_LEN-1))   = uncoded start state residual\nres((STATE_SHORT_LEN)..(2*STATE_SHORT_LEN-1)) = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Pk(z) = A~rk(z)/A~k(z), where\n                             ___\n                             \\\nA~rk(z)= z^(-LPC_FILTERORDER)+>a~k(i+1)*z^(i-(LPC_FILTERORDER-1))\n                             /__\n                         i=0...(LPC_FILTERORDER-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "and A~k(z) is taken from the block where the start state begins",
      "ja": "A~k(z) は開始状態が始まるブロックから取得されます。"
    },
    {
      "indent": 6,
      "text": "res -> Pk(z) -> filtered",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ccres(k) = filtered(k) + filtered(k+STATE_SHORT_LEN),\n                                  k=0..(STATE_SHORT_LEN-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The all-pass filtered block is searched for its largest magnitude sample. The 10-logarithm of this magnitude is quantized with a 6-bit quantizer, state_frgqTbl, by finding the nearest representation.",
      "ja": "オールパス フィルター処理されたブロックで最大の大きさのサンプルが検索されます。この大きさの 10 対数は、最も近い表現を見つけることによって 6 ビット量子化器 state_frgqTbl で量子化されます。"
    },
    {
      "indent": 3,
      "text": "This results in an index, idxForMax, corresponding to a quantized value, qmax. The all-pass filtered residual samples in the block are then multiplied with a scaling factor scal=4.5/(10^qmax) to yield normalized samples.",
      "ja": "これにより、量子化値 qmax に対応するインデックス idxForMax が生成されます。次に、ブロック内のオールパス フィルター処理された残差サンプルにスケーリング係数 scal=4.5/(10^qmax) を乗算して、正規化されたサンプルを生成します。"
    },
    {
      "indent": 3,
      "text": "state_frgqTbl[64] = {1.000085, 1.071695, 1.140395, 1.206868,\n               1.277188, 1.351503, 1.429380, 1.500727, 1.569049,\n               1.639599, 1.707071, 1.781531, 1.840799, 1.901550,\n               1.956695, 2.006750, 2.055474, 2.102787, 2.142819,\n               2.183592, 2.217962, 2.257177, 2.295739, 2.332967,\n               2.369248, 2.402792, 2.435080, 2.468598, 2.503394,\n               2.539284, 2.572944, 2.605036, 2.636331, 2.668939,\n               2.698780, 2.729101, 2.759786, 2.789834, 2.818679,\n               2.848074, 2.877470, 2.906899, 2.936655, 2.967804,\n               3.000115, 3.033367, 3.066355, 3.104231, 3.141499,\n               3.183012, 3.222952, 3.265433, 3.308441, 3.350823,\n               3.395275, 3.442793, 3.490801, 3.542514, 3.604064,\n               3.666050, 3.740994, 3.830749, 3.938770, 4.101764}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.5.3. Scalar Quantization",
      "section_title": true,
      "ja": "3.5.3. スカラー量子化"
    },
    {
      "indent": 3,
      "text": "The normalized samples are quantized in the perceptually weighted speech domain by a sample-by-sample scalar DPCM quantization as depicted in Figure 3.3. Each sample in the block is filtered by a weighting filter Wk(z), specified in section 3.4, to form a weighted speech sample x[n]. The target sample d[n] is formed by subtracting a predicted sample y[n], where the prediction filter is given by",
      "ja": "正規化されたサンプルは、図 3.3 に示すように、サンプルごとのスカラー DPCM 量子化によって、知覚的に重み付けされた音声ドメインで量子化されます。ブロック内の各サンプルは、セクション 3.4 で指定された重み付けフィルター Wk(z) によってフィルター処理され、重み付けされた音声サンプル x[n] が形成されます。ターゲット サンプル d[n] は、予測サンプル y[n] を減算することによって形成されます。ここで、予測フィルターは次の式で与えられます。"
    },
    {
      "indent": 11,
      "text": "Pk(z) = 1 - 1 / Wk(z).",
      "ja": "Pk(z) = 1 - 1 / Wk(z)。"
    },
    {
      "indent": 3,
      "text": "            +-------+  x[n] +    d[n] +-----------+ u[n]\nresidual -->| Wk(z) |-------->(+)---->| Quantizer |------> quantized\n            +-------+       - /|\\     +-----------+    |   residual\n                               |                      \\|/\n                          y[n] +--------------------->(+)\n                               |                       |\n                               |        +------+       |\n                               +--------| Pk(z)|<------+\n                                        +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.3. Quantization of start state samples by DPCM in weighted speech domain.",
      "ja": "図3.3。加重音声ドメインにおける DPCM による開始状態サンプルの量子化。"
    },
    {
      "indent": 3,
      "text": "The coded state sample u[n] is obtained by quantizing d[n] with a 3- bit quantizer with quantization table state_sq3Tbl.",
      "ja": "コード化された状態サンプル u[n] は、量子化テーブル state_sq3Tbl を備えた 3 ビット量子化器で d[n] を量子化することによって取得されます。"
    },
    {
      "indent": 3,
      "text": "state_sq3Tbl[8] = {-3.719849, -2.177490, -1.130005, -0.309692,\n               0.444214, 1.329712, 2.436279, 3.983887}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The quantized samples are transformed back to the residual domain by 1) scaling with 1/scal; 2) time-reversing the scaled samples; 3) filtering the time-reversed samples by the same all-pass filter, as in section 3.5.2, by using circular convolution; and 4) time-reversing the filtered samples. (More detail is in section 4.2.)",
      "ja": "量子化されたサンプルは、1) 1/scal でスケーリングすることによって、残差ドメインに変換されます。２）スケーリングされたサンプルを時間反転する。3) 循環畳み込みを使用して、セクション 3.5.2 と同じオールパス フィルターで時間反転したサンプルをフィルター処理します。4) フィルタリングされたサンプルを時間反転します。(詳細についてはセクション 4.2 を参照してください。)"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the start-state encoding can be found in Appendix A.46.",
      "ja": "開始状態エンコーディングの参照実装は、付録 A.46 にあります。"
    },
    {
      "indent": 0,
      "text": "3.6. Encoding the Remaining Samples",
      "section_title": true,
      "ja": "3.6. 残りのサンプルのエンコード"
    },
    {
      "indent": 3,
      "text": "A dynamic codebook is used to encode 1) the 23/22 remaining samples in the two sub-blocks containing the start state; 2) the sub-blocks after the start state in time; and 3) the sub-blocks before the start state in time. Thus, the encoding target can be either the 23/22 samples remaining of the 2 sub-blocks containing the start state, or a 40-sample sub-block. This target can consist of samples that are indexed forward in time or backward in time, depending on the location of the start state. The length of the target is denoted by lTarget.",
      "ja": "動的コードブックは、1) 開始状態を含む 2 つのサブブロック内の残りの 23/22 サンプルをエンコードするために使用されます。2) 開始状態の後のサブブロック。3) 開始状態の前のサブブロック。したがって、符号化ターゲットは、開始状態を含む 2 つのサブブロックの残りの 23/22 サンプル、または 40 サンプルのサブブロックのいずれかになります。このターゲットは、開始状態の位置に応じて、時間的に順方向または時間的に逆方向にインデックス付けされたサンプルで構成されます。ターゲットの長さは lTarget で示されます。"
    },
    {
      "indent": 3,
      "text": "The coding is based on an adaptive codebook that is built from a codebook memory that contains decoded LPC excitation samples from the already encoded part of the block. These samples are indexed in the same time direction as is the target vector and end at the sample instant prior to the first sample instant represented in the target vector. The codebook memory has length lMem, which is equal to CB_MEML=147 for the two/four 40-sample sub-blocks and 85 for the 23/22-sample sub-block.",
      "ja": "コーディングは、ブロックの既にエンコードされた部分からデコードされた LPC 励振サンプルを含むコードブック メモリから構築される適応コードブックに基づいています。これらのサンプルは、ターゲット ベクトルと同じ時間方向にインデックス付けされ、ターゲット ベクトルで表される最初のサンプル瞬間より前のサンプル瞬間で終了します。コードブックメモリの長さはlMemであり、これは2/4の40サンプルサブブロックではCB_MEML=147、23/22サンプルサブブロックでは85に等しい。"
    },
    {
      "indent": 3,
      "text": "The following figure shows an overview of the encoding procedure.",
      "ja": "エンコード手順の概要を次の図に示します。"
    },
    {
      "indent": 6,
      "text": "   +------------+    +---------------+    +-------------+\n-> | 1. Decode  | -> | 2. Mem setup  | -> | 3. Perc. W. | ->\n   +------------+    +---------------+    +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "   +------------+    +-----------------+\n-> | 4. Search  | -> | 5. Upd. Target  | ------------------>\n | +------------+    +------------------ |\n ----<-------------<-----------<----------\n               stage=0..2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "   +----------------+\n-> | 6. Recalc G[0] | ---------------> gains and CB indices\n   +----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.4. Flow chart of the codebook search in the iLBC encoder.",
      "ja": "図3.4。iLBC エンコーダでのコードブック検索のフローチャート。"
    },
    {
      "indent": 3,
      "text": "1. Decode the part of the residual that has been encoded so far, using the codebook without perceptual weighting.",
      "ja": "1. 知覚的重み付けを行わずにコードブックを使用して、これまでにエンコードされた残差の部分をデコードします。"
    },
    {
      "indent": 3,
      "text": "2. Set up the memory by taking data from the decoded residual. This memory is used to construct codebooks. For blocks preceding the start state, both the decoded residual and the target are time reversed (section 3.6.1). 3. Filter the memory + target with the perceptual weighting filter (section 3.6.2).",
      "ja": "2. デコードされた残差からデータを取得してメモリをセットアップします。このメモリはコードブックの構築に使用されます。開始状態に先行するブロックでは、デコードされた残差とターゲットの両方が時間反転されます (セクション 3.6.1)。3. 知覚重み付けフィルタを使用してメモリターゲットをフィルタリングします (セクション 3.6.2)。"
    },
    {
      "indent": 3,
      "text": "4. Search for the best match between the target and the codebook vector. Compute the optimal gain for this match and quantize that gain (section 3.6.4).",
      "ja": "4. ターゲットとコードブック ベクトルの間で最も一致するものを検索します。この一致に対する最適なゲインを計算し、そのゲインを量子化します (セクション 3.6.4)。"
    },
    {
      "indent": 3,
      "text": "5. Update the perceptually weighted target by subtracting the contribution from the selected codebook vector from the perceptually weighted memory (quantized gain times selected vector). Repeat 4 and 5 for the two additional stages.",
      "ja": "5. 知覚的に重み付けされたメモリから選択されたコードブック ベクトルからの寄与を減算することにより、知覚的に重み付けされたターゲットを更新します (量子化ゲインと選択したベクトルの積)。追加の 2 つのステージに対して 4 と 5 を繰り返します。"
    },
    {
      "indent": 3,
      "text": "6. Calculate the energy loss due to encoding of the residual. If needed, compensate for this loss by an upscaling and requantization of the gain for the first stage (section 3.7).",
      "ja": "6. 残差のエンコードによるエネルギー損失を計算します。必要に応じて、最初のステージのゲインのアップスケーリングと再量子化によってこの損失を補償します (セクション 3.7)。"
    },
    {
      "indent": 3,
      "text": "The following sections provide an in-depth description of the different blocks of Figure 3.4.",
      "ja": "次のセクションでは、図 3.4 のさまざまなブロックについて詳しく説明します。"
    },
    {
      "indent": 0,
      "text": "3.6.1. Codebook Memory",
      "section_title": true,
      "ja": "3.6.1. コードブックメモリ"
    },
    {
      "indent": 3,
      "text": "The codebook memory is based on the already encoded sub-blocks, so the available data for encoding increases for each new sub-block that has been encoded. Until enough sub-blocks have been encoded to fill the codebook memory with data, it is padded with zeros. The following figure shows an example of the order in which the sub-blocks are encoded for the 30 ms frame size if the start state is located in the last 58 samples of sub-block 2 and 3.",
      "ja": "コードブック メモリは、すでにエンコードされたサブブロックに基づいているため、エンコードに利用できるデータは、エンコードされた新しいサブブロックごとに増加します。コードブック メモリをデータで埋めるのに十分なサブブロックがエンコードされるまで、コードブック メモリにはゼロが埋め込まれます。次の図は、開始状態がサブブロック 2 と 3 の最後の 58 サンプルにある場合に、30 ミリ秒のフレーム サイズでサブブロックがエンコードされる順序の例を示しています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------------------------+\n|  5     | 1  |///|////////|    2   |    3   |    4   |\n+-----------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.5. The order from 1 to 5 in which the sub-blocks are encoded. The slashed area is the start state.",
      "ja": "図3.5。サブブロックがエンコードされる 1 から 5 の順序。斜線部分が開始状態です。"
    },
    {
      "indent": 3,
      "text": "The first target sub-block to be encoded is number 1, and the corresponding codebook memory is shown in the following figure. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed; thus, after the block has been time reversed the search algorithm can be reused. As only the start state has been encoded so far, the last samples of the codebook memory are padded with zeros.",
      "ja": "符号化される最初のターゲット サブブロックは番号 1 であり、対応するコードブック メモリを次の図に示します。ターゲット ベクトルが開始状態よりも時間的に前に来ると、コードブック メモリとターゲット ベクトルの時間が逆転します。したがって、ブロックが時間反転された後、検索アルゴリズムを再利用できます。これまでは開始状態のみがエンコードされているため、コードブック メモリの最後のサンプルにはゼロが埋め込まれます。"
    },
    {
      "indent": 3,
      "text": "+-------------------------\n|zeros|\\\\\\\\\\\\\\\\|\\\\\\\\|  1 |\n+-------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.6. The codebook memory, length lMem=85 samples, and the target vector 1, length 22 samples.",
      "ja": "図3.6。コードブック メモリ、長さ lMem=85 サンプル、およびターゲット ベクトル 1、長さ 22 サンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 2 by using the memory that now has increased since sub-block 1 has been encoded. The following figure shows the codebook memory for encoding of sub-block 2.",
      "ja": "次のステップは、サブブロック 1 がエンコードされてから増加したメモリを使用して、サブブロック 2 をエンコードすることです。次の図は、サブブロック 2 の符号化のためのコードブック メモリを示しています。"
    },
    {
      "indent": 3,
      "text": "+-----------------------------------\n| zeros | 1  |///|////////|    2   |\n+-----------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.7. The codebook memory, length lMem=147 samples, and the target vector 2, length 40 samples.",
      "ja": "図3.7。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 2、長さ 40 サンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 3 by using the memory which has been increased yet again since sub-blocks 1 and 2 have been encoded, but the sub-block still has to be padded with a few zeros. The following figure shows the codebook memory for encoding of sub-block 3.",
      "ja": "次のステップは、サブブロック 1 と 2 がエンコードされてからさらに増加したメモリを使用してサブブロック 3 をエンコードすることですが、サブブロックにはまだいくつかのゼロを埋め込む必要があります。次の図は、サブブロック 3 の符号化のためのコードブック メモリを示しています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------------\n|zeros| 1  |///|////////|    2   |   3    |\n+------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.8. The codebook memory, length lMem=147 samples, and the target vector 3, length 40 samples.",
      "ja": "図3.8。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 3、長さ 40 サンプル。"
    },
    {
      "indent": 3,
      "text": "The next step is to encode sub-block 4 by using the memory which now has increased yet again since sub-blocks 1, 2, and 3 have been encoded. This time, the memory does not have to be padded with zeros. The following figure shows the codebook memory for encoding of sub-block 4.",
      "ja": "次のステップは、サブブロック 1、2、および 3 が符号化されてからさらに増加したメモリを使用して、サブブロック 4 を符号化することです。今回は、メモリにゼロを埋め込む必要はありません。次の図は、サブブロック 4 の符号化のためのコードブック メモリを示しています。"
    },
    {
      "indent": 3,
      "text": "+------------------------------------------\n|1|///|////////|    2   |   3    |   4    |\n+------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.9. The codebook memory, length lMem=147 samples, and the target vector 4, length 40 samples.",
      "ja": "図3.9。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 4、長さ 40 サンプル。"
    },
    {
      "indent": 3,
      "text": "The final target sub-block to be encoded is number 5, and the following figure shows the corresponding codebook memory. As the target vector comes before the start state in time, the codebook memory and target vector are time reversed.",
      "ja": "エンコードされる最終ターゲット サブブロックは 5 番で、次の図は対応するコードブック メモリを示しています。ターゲット ベクトルが開始状態よりも時間的に前に来ると、コードブック メモリとターゲット ベクトルの時間が逆転します。"
    },
    {
      "indent": 3,
      "text": "+-------------------------------------------\n|  3  |   2    |\\\\\\\\\\\\\\\\|\\\\\\\\|  1 |   5    |\n+-------------------------------------------",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.10. The codebook memory, length lMem=147 samples, and the target vector 5, length 40 samples.",
      "ja": "図3.10。コードブック メモリ、長さ lMem=147 サンプル、およびターゲット ベクトル 5、長さ 40 サンプル。"
    },
    {
      "indent": 3,
      "text": "For the case of 20 ms frames, the encoding procedure looks almost exactly the same. The only difference is that the size of the start state is 57 samples and that there are only three sub-blocks to be encoded. The encoding order is the same as above, starting with the 23-sample target and then encoding the two remaining 40-sample sub-blocks, first going forward in time and then going backward in time relative to the start state.",
      "ja": "20 ms フレームの場合、エンコード手順はほぼ同じになります。唯一の違いは、開始状態のサイズが 57 サンプルであり、エンコードされるサブブロックが 3 つだけであることです。エンコード順序は上記と同じで、23 サンプルのターゲットから開始して、残りの 2 つの 40 サンプルのサブブロックをエンコードします。最初は時間的に順方向に進み、次に開始状態に対して時間的に逆方向に進みます。"
    },
    {
      "indent": 0,
      "text": "3.6.2. Perceptual Weighting of Codebook Memory and Target",
      "section_title": true,
      "ja": "3.6.2. コードブックメモリとターゲットの知覚的重み付け"
    },
    {
      "indent": 3,
      "text": "To provide a perceptual weighting of the coding error, a concatenation of the codebook memory and the target to be coded is all-pole filtered with the perceptual weighting filter specified in section 3.4. The filter state of the weighting filter is set to zero.",
      "ja": "符号化エラーの知覚的重み付けを提供するために、コードブック メモリと符号化対象のターゲットの連結が、セクション 3.4 で指定された知覚的重み付けフィルタで全極フィルタリングされます。重み付けフィルタのフィルタ状態はゼロに設定されます。"
    },
    {
      "indent": 6,
      "text": "in(0..(lMem-1))            = unweighted codebook memory\nin(lMem..(lMem+lTarget-1)) = unweighted target signal",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "in -> Wk(z) -> filtered,\n    where Wk(z) is taken from the sub-block of the target",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "weighted codebook memory = filtered(0..(lMem-1))\nweighted target signal = filtered(lMem..(lMem+lTarget-1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The codebook search is done with the weighted codebook memory and the weighted target, whereas the decoding and the codebook memory update uses the unweighted codebook memory.",
      "ja": "コードブックの検索は重み付けされたコードブック メモリと重み付けされたターゲットを使用して実行されますが、デコードとコードブック メモリの更新は重み付けされていないコードブック メモリを使用します。"
    },
    {
      "indent": 0,
      "text": "3.6.3. Codebook Creation",
      "section_title": true,
      "ja": "3.6.3. コードブックの作成"
    },
    {
      "indent": 3,
      "text": "The codebook for the search is created from the perceptually weighted codebook memory. It consists of two sections, where the first is referred to as the base codebook and the second as the expanded codebook, as it is created by linear combinations of the first. Each of these two sections also has a subsection referred to as the augmented codebook. The augmented codebook is only created and used for the coding of the 40-sample sub-blocks and not for the 23/22- sample sub-block case. The codebook size used for the different sub-blocks and different stages are summarized in the table below.",
      "ja": "検索用のコードブックは、知覚的に重み付けされたコードブック メモリから作成されます。これは 2 つのセクションで構成されており、最初のセクションは基本コードブックと呼ばれ、2 番目のセクションは最初のコードブックの線形結合によって作成されるため、拡張コードブックと呼ばれます。これら 2 つのセクションにはそれぞれ、拡張コードブックと呼ばれるサブセクションもあります。拡張コードブックは、40 サンプルのサブブロックのコーディングにのみ作成および使用され、23/22 サンプルのサブブロックの場合には使用されません。さまざまなサブブロックおよびさまざまなステージに使用されるコードブックのサイズを以下の表にまとめます。"
    },
    {
      "indent": 3,
      "text": "                           Stage\n                     1               2 & 3\n        --------------------------------------------\n             22     128  (64+0)*2     128 (64+0)*2\nSub-    1:st 40     256  (108+20)*2   128 (44+20)*2\nBlocks  2:nd 40     256  (108+20)*2   256 (108+20)*2\n        3:rd 40     256  (108+20)*2   256 (108+20)*2\n        4:th 40     256  (108+20)*2   256 (108+20)*2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 3.1. Codebook sizes for the 30 ms mode.",
      "ja": "表3.1。30 ms モードのコードブック サイズ。"
    },
    {
      "indent": 3,
      "text": "Table 3.1 shows the codebook size for the different sub-blocks and stages for 30 ms frames. Inside the parentheses it shows how the number of codebook vectors is distributed, within the two sections, between the base/expanded codebook and the augmented base/expanded codebook. It should be interpreted in the following way: (base/expanded cb + augmented base/expanded cb). The total number of codebook vectors for a specific sub-block and stage is given by the following formula:",
      "ja": "表 3.1 は、30 ms フレームのさまざまなサブブロックとステージのコードブック サイズを示しています。括弧内は、2 つのセクション内で、基本/拡張コードブックと拡張基本/拡張コードブックの間でコードブック ベクトルの数がどのように配分されるかを示しています。これは次のように解釈する必要があります: (ベース/拡張 CB 拡張ベース/拡張 CB)。特定のサブブロックおよびステージのコードブック ベクトルの総数は、次の式で求められます。"
    },
    {
      "indent": 3,
      "text": "Tot. cb vectors = base cb + aug. base cb + exp. cb + aug. exp. cb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The corresponding values to Figure 3.1 for 20 ms frames are only slightly modified. The short sub-block is 23 instead of 22 samples, and the 3:rd and 4:th sub-frame are not present.",
      "ja": "20 ms フレームの図 3.1 に対応する値は、わずかに変更されているだけです。短いサブブロックは 22 サンプルではなく 23 サンプルであり、3 番目と 4 番目のサブフレームは存在しません。"
    },
    {
      "indent": 0,
      "text": "3.6.3.1. Creation of a Base Codebook",
      "section_title": true,
      "ja": "3.6.3.1. 基本コードブックの作成"
    },
    {
      "indent": 3,
      "text": "The base codebook is given by the perceptually weighted codebook memory that is mentioned in section 3.5.3. The different codebook vectors are given by sliding a window of length 23/22 or 40, given by variable lTarget, over the lMem-long perceptually weighted codebook memory. The indices are ordered so that the codebook vector containing sample (lMem-lTarget-n) to (lMem-n-1) of the codebook memory vector has index n, where n=0..lMem-lTarget. Thus the total number of base codebook vectors is lMem-lTarget+1, and the indices are ordered from sample delay lTarget (23/22 or 40) to lMem+1 (86 or 148).",
      "ja": "基本コードブックは、セクション 3.5.3 で説明されている知覚的に重み付けされたコードブック メモリによって与えられます。異なるコードブック ベクトルは、変数 lTarget で指定される長さ 23/22 または 40 のウィンドウを、lMem の長さの知覚的に重み付けされたコードブック メモリ上でスライドさせることによって指定されます。インデックスは、コードブック メモリ ベクトルのサンプル (lMem-lTarget-n) から (lMem-n-1) を含むコードブック ベクトルがインデックス n を持つように順序付けされます (n=0..lMem-lTarget)。したがって、基本コードブック ベクトルの総数は lMem - lTarget 1 であり、インデックスはサンプル遅延 lTarget (23/22 または 40) から lMem 1 (86 または 148) までの順序になります。"
    },
    {
      "indent": 0,
      "text": "3.6.3.2. Codebook Expansion",
      "section_title": true,
      "ja": "3.6.3.2. コードブックの拡張"
    },
    {
      "indent": 3,
      "text": "The base codebook is expanded by a factor of 2, creating an additional section in the codebook. This new section is obtained by filtering the base codebook, base_cb, with a FIR filter with filter length CB_FILTERLEN=8. The construction of the expanded codebook compensates for the delay of four samples introduced by the FIR filter.",
      "ja": "基本コードブックは 2 倍に拡張され、コードブックに追加セクションが作成されます。この新しいセクションは、フィルタ長 CB_FILTERLEN=8 の FIR フィルタを使用してベース コードブック、base_cb をフィルタリングすることによって取得されます。拡張されたコードブックの構築により、FIR フィルターによって導入された 4 つのサンプルの遅延が補償されます。"
    },
    {
      "indent": 3,
      "text": "cbfiltersTbl[CB_FILTERLEN]={-0.033691, 0.083740, -0.144043,\n               0.713379, 0.806152, -0.184326,\n               0.108887, -0.034180};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "             ___\n             \\\nexp_cb(k)=  + > cbfiltersTbl(i)*x(k-i+4)\n             /__\n       i=0...(LPC_FILTERORDER-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "where x(j) = base_cb(j) for j=0..lMem-1 and 0 otherwise",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The individual codebook vectors of the new filtered codebook, exp_cb, and their indices are obtained in the same fashion as described above for the base codebook.",
      "ja": "新しいフィルタリングされたコードブックの個々のコードブック ベクトル exp_cb とそのインデックスは、ベース コードブックについて上で説明したのと同じ方法で取得されます。"
    },
    {
      "indent": 0,
      "text": "3.6.3.3. Codebook Augmentation",
      "section_title": true,
      "ja": "3.6.3.3. コードブックの拡張"
    },
    {
      "indent": 3,
      "text": "For cases where encoding entire sub-blocks, i.e., cbveclen=40, the base and expanded codebooks are augmented to increase codebook richness. The codebooks are augmented by vectors produced by interpolation of segments. The base and expanded codebook, constructed above, consists of vectors corresponding to sample delays in the range from cbveclen to lMem. The codebook augmentation attempts to augment these codebooks with vectors corresponding to sample delays from 20 to 39. However, not all of these samples are present in the base codebook and expanded codebook, respectively. Therefore, the augmentation vectors are constructed as linear combinations between samples corresponding to sample delays in the range 20 to 39. The general idea of this procedure is presented in the following figures and text. The procedure is performed for both the base codebook and the expanded codebook.",
      "ja": "サブブロック全体をエンコードする場合、つまり cbveclen=40 の場合、基本コードブックと拡張コードブックが拡張されてコードブックの豊富さが向上します。コードブックは、セグメントの補間によって生成されたベクトルによって拡張されます。上記で構築された基本コードブックと拡張コードブックは、cbveclen から lMem までの範囲のサンプル遅延に対応するベクトルで構成されています。コードブックの拡張では、20 ～ 39 のサンプル遅延に対応するベクトルでこれらのコードブックを拡張しようとします。ただし、これらのサンプルのすべてがそれぞれ基本コードブックと拡張コードブックに存在するわけではありません。したがって、拡張ベクトルは、20 ～ 39 の範囲のサンプル遅延に対応するサンプル間の線形結合として構築されます。この手順の一般的な概念は、次の図と本文に示されています。この手順は、基本コードブックと拡張コードブックの両方に対して実行されます。"
    },
    {
      "indent": 4,
      "text": "   - - ------------------------|\ncodebook memory                |\n   - - ------------------------|\n              |-5-|---15---|-5-|\n              pi  pp       po",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "|        |                       Codebook vector\n|---15---|-5-|-----20-----|   <- corresponding to\n    i     ii      iii            sample delay 20",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.11. Generation of the first augmented codebook.",
      "ja": "図3.11。最初の拡張コードブックの生成。"
    },
    {
      "indent": 3,
      "text": "Figure 3.11 shows the codebook memory with pointers pi, pp, and po, where pi points to sample 25, pp to sample 20, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 20 is drawn. Segment i consists of fifteen samples from pointer pp and forward in time. Segment ii consists of five interpolated samples from pi and forward and from po and forward. The samples are linearly interpolated with weights [0.0, 0.2, 0.4, 0.6, 0.8] for pi and weights [1.0, 0.8, 0.6, 0.4, 0.2] for po. Segment iii consists of twenty samples from pp and forward. The augmented codebook vector corresponding to sample delay 21 is produced by moving pointers pp and pi one sample backward in time. This gives us the following figure.",
      "ja": "図 3.11 は、ポインタ pi、pp、po を持つコードブック メモリを示しています。ここで、pi はサンプル 25、pp はサンプル 20、po はサンプル 5 を指します。コードブック メモリの下には、サンプル遅延 20 に対応する拡張コードブック ベクトルが描画されます。セグメント i は、ポインター pp 以降の 15 個のサンプルで構成されます。セグメント ii は、pi 以降および po 以降の 5 つの補間サンプルで構成されます。サンプルは、pi の重み [0.0、0.2、0.4、0.6、0.8]、po の重み [1.0、0.8、0.6、0.4、0.2] で線形補間されます。セグメント iii は、pp 以降の 20 個のサンプルで構成されます。サンプル遅延 21 に対応する拡張コードブック ベクトルは、ポインタ pp および pi を時間的に 1 サンプル後方に移動することによって生成されます。これにより、次の図が得られます。"
    },
    {
      "indent": 4,
      "text": "   - - ------------------------|\ncodebook memory                |\n   - - ------------------------|\n              |-5-|---16---|-5-|\n              pi  pp       po",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "|        |                       Codebook vector\n|---16---|-5-|-----19-----|   <- corresponding to\n    i     ii      iii            sample delay 21",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 3.12. Generation of the second augmented codebook.",
      "ja": "図3.122 番目の拡張コードブックの生成。"
    },
    {
      "indent": 3,
      "text": "Figure 3.12 shows the codebook memory with pointers pi, pp and po where pi points to sample 26, pp to sample 21, and po to sample 5. Below the codebook memory, the augmented codebook vector corresponding to sample delay 21 is drawn. Segment i now consists of sixteen samples from pp and forward. Segment ii consists of five interpolated samples from pi and forward and from po and forward, and the interpolation weights are the same throughout the procedure. Segment iii consists of nineteen samples from pp and forward. The same procedure of moving the two pointers is continued until the last augmented vector corresponding to sample delay 39 has been created. This gives a total of twenty new codebook vectors to each of the two sections. Thus the total number of codebook vectors for each of the two sections, when including the augmented codebook, becomes lMem-SUBL+1+SUBL/2. This is provided that augmentation is evoked, i.e., that lTarget=SUBL.",
      "ja": "図 3.12 は、ポインタ pi、pp、po を持つコードブック メモリを示しています。ここで、pi はサンプル 26、pp はサンプル 21、po はサンプル 5 を指します。コードブック メモリの下には、サンプル遅延 21 に対応する拡張コードブック ベクトルが描画されます。セグメント i は、pp 以降の 16 個のサンプルで構成されています。セグメント ii は、pi 以降および po 以降の 5 つの補間サンプルで構成され、補間重みは手順全体を通じて同じです。セグメント iii は、pp 以降の 19 個のサンプルで構成されます。２つのポインタを移動する同じ手順は、サンプル遅延３９に対応する最後の拡張ベクトルが作成されるまで継続される。これにより、合計 20 個の新しいコードブック ベクトルが 2 つのセクションのそれぞれに与えられます。したがって、拡張コードブックを含む場合、2 つのセクションのそれぞれのコードブック ベクトルの総数は、lMem-SUBL 1 SUBL/2 になります。これは、拡張が呼び出される場合、つまり lTarget=SUBL が条件となります。"
    },
    {
      "indent": 0,
      "text": "3.6.4. Codebook Search",
      "section_title": true,
      "ja": "3.6.4. コードブックの検索"
    },
    {
      "indent": 3,
      "text": "The codebook search uses the codebooks described in the sections above to find the best match of the perceptually weighted target, see section 3.6.2. The search method is a multi-stage gain-shape matching performed as follows. At each stage the best shape vector is identified, then the gain is calculated and quantized, and finally the target is updated in preparation for the next codebook search stage. The number of stages is CB_NSTAGES=3.",
      "ja": "コードブック検索では、上のセクションで説明したコードブックを使用して、知覚的に重み付けされたターゲットの最適な一致を見つけます。セクション 3.6.2 を参照してください。探索方法は次のように多段階のゲイン形状マッチングを行います。各ステージで最適な形状ベクトルが特定され、ゲインが計算されて量子化され、最後に次のコードブック検索ステージに備えてターゲットが更新されます。ステージ数はCB_NSTAGES=3です。"
    },
    {
      "indent": 3,
      "text": "If the target is the 23/22-sample vector the codebooks are indexed so that the base codebook is followed by the expanded codebook. If the target is 40 samples the order is as follows: base codebook, augmented base codebook, expanded codebook, and augmented expanded codebook. The size of each codebook section and its corresponding augmented section is given by Table 3.1 in section 3.6.3.",
      "ja": "ターゲットが 23/22 サンプル ベクトルの場合、基本コードブックの後に拡張コードブックが続くようにコードブックにインデックスが付けられます。ターゲットが 40 サンプルの場合、順序は基本コードブック、拡張基本コードブック、拡張コードブック、拡張拡張コードブックになります。各コードブック セクションとそれに対応する拡張セクションのサイズは、セクション 3.6.3 の表 3.1 に示されています。"
    },
    {
      "indent": 3,
      "text": "For example, when the second 40-sample sub-block is coded, indices 0 - 107 correspond to the base codebook, 108 - 127 correspond to the augmented base codebook, 128 - 235 correspond to the expanded codebook, and indices 236 - 255 correspond to the augmented expanded codebook. The indices are divided in the same fashion for all stages in the example. Only in the case of coding the first 40-sample sub-block is there a difference between stages (see Table 3.1).",
      "ja": "たとえば、2 番目の 40 サンプルのサブブロックが符号化される場合、インデックス 0 ～ 107 は基本コードブックに対応し、108 ～ 127 は拡張基本コードブックに対応し、128 ～ 235 は拡張コードブックに対応し、インデックス 236 ～ 255 は拡張コードブックに対応します。拡張された拡張コードブックに。この例では、インデックスはすべてのステージで同じ方法で分割されています。最初の 40 サンプルのサブブロックを符号化する場合にのみ、ステージ間に違いがあります (表 3.1 を参照)。"
    },
    {
      "indent": 0,
      "text": "3.6.4.1. Codebook Search at Each Stage",
      "section_title": true,
      "ja": "3.6.4.1. 各段階でのコードブック検索"
    },
    {
      "indent": 3,
      "text": "The codebooks are searched to find the best match to the target at each stage. When the best match is found, the target is updated and the next-stage search is started. The three chosen codebook vectors and their corresponding gains constitute the encoded sub-block. The best match is decided by the following three criteria:",
      "ja": "コードブックは、各段階でターゲットに最もよく一致するものを見つけるために検索されます。最適な一致が見つかると、ターゲットが更新され、次の段階の検索が開始されます。選択された 3 つのコードブック ベクトルとそれらに対応するゲインは、符号化されたサブブロックを構成します。最適な一致は、次の 3 つの基準によって決定されます。"
    },
    {
      "indent": 3,
      "text": "1. Compute the measure",
      "ja": "1. メジャーを計算する"
    },
    {
      "indent": 6,
      "text": "(target*cbvec)^2 / ||cbvec||^2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "for all codebook vectors, cbvec, and choose the codebook vector maximizing the measure. The expression (target*cbvec) is the dot product between the target vector to be coded and the codebook vector for which we compute the measure. The norm, ||x||, is defined as the square root of (x*x).",
      "ja": "すべてのコードブック ベクトルに対して cbvec を使用し、尺度を最大化するコードブック ベクトルを選択します。式 (target*cbvec) は、コード化されるターゲット ベクトルと測定値を計算するコードブック ベクトルの間のドット積です。ノルム ||x|| は (x*x) の平方根として定義されます。"
    },
    {
      "indent": 3,
      "text": "2. The absolute value of the gain, corresponding to the chosen codebook vector, cbvec, must be smaller than a fixed limit, CB_MAXGAIN=1.3:",
      "ja": "2. 選択したコードブック ベクトル cbvec に対応するゲインの絶対値は、固定制限 CB_MAXGAIN=1.3 より小さくなければなりません。"
    },
    {
      "indent": 12,
      "text": "|gain| < CB_MAXGAIN",
      "ja": "|ゲイン|< CB_MAXGAIN"
    },
    {
      "indent": 6,
      "text": "where the gain is computed in the following way:",
      "ja": "ここで、ゲインは次の方法で計算されます。"
    },
    {
      "indent": 12,
      "text": "gain = (target*cbvec) / ||cbvec||^2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "3. For the first stage, the dot product of the chosen codebook vector and target must be positive:",
      "ja": "3. 最初の段階では、選択したコードブック ベクトルとターゲットのドット積が正である必要があります。"
    },
    {
      "indent": 6,
      "text": "target*cbvec > 0",
      "ja": "ターゲット*cbvec > 0"
    },
    {
      "indent": 3,
      "text": "In practice the above criteria are used in a sequential search through all codebook vectors. The best match is found by registering a new max measure and index whenever the previously registered max measure is surpassed and all other criteria are fulfilled. If none of the codebook vectors fulfill (2) and (3), the first codebook vector is selected.",
      "ja": "実際には、上記の基準は、すべてのコードブック ベクトルの順次検索に使用されます。以前に登録された最大メジャーを超え、他のすべての基準が満たされるたびに、新しい最大メジャーとインデックスを登録することによって、最良の一致が見つかります。(2) と (3) を満たすコードブック ベクトルがない場合は、最初のコードブック ベクトルが選択されます。"
    },
    {
      "indent": 0,
      "text": "3.6.4.2. Gain Quantization at Each Stage",
      "section_title": true,
      "ja": "3.6.4.2. 各段階でのゲイン量子化"
    },
    {
      "indent": 3,
      "text": "The gain follows as a result of the computation",
      "ja": "計算の結果としてゲインが得られます"
    },
    {
      "indent": 6,
      "text": "gain = (target*cbvec) / ||cbvec||^2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "for the optimal codebook vector found by the procedure in section 3.6.4.1.",
      "ja": "セクション 3.6.4.1 の手順で見つかった最適なコードブック ベクトル。"
    },
    {
      "indent": 3,
      "text": "The three stages quantize the gain, using 5, 4, and 3 bits, respectively. In the first stage, the gain is limited to positive values. This gain is quantized by finding the nearest value in the quantization table gain_sq5Tbl.",
      "ja": "3 つのステージでは、それぞれ 5、4、3 ビットを使用してゲインを量子化します。最初の段階では、ゲインは正の値に制限されます。このゲインは、量子化テーブル Gain_sq5Tbl で最も近い値を見つけることによって量子化されます。"
    },
    {
      "indent": 3,
      "text": "gain_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012, 0.487488, 0.525024, 0.562500, 0.599976, 0.637512, 0.674988, 0.712524, 0.750000, 0.787476, 0.825012, 0.862488, 0.900024, 0.937500, 0.974976, 1.012512, 1.049988, 1.087524, 1.125000, 1.162476, 1.200012}",
      "ja": "ゲイン_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500, 0.224976, 0.262512, 0.299988, 0.337524, 0.375000, 0.412476, 0.450012、0.487488、0.525024、0.562500、0.599976、0.637512、0.674988、0.712524、0.750000、0.787476、0.825012、0.862488、0.900024、0.937500、0.974976、1.012512、1.049988、1.087524、1.125000、1.162476、1.200012}"
    },
    {
      "indent": 3,
      "text": "The gains of the subsequent two stages can be either positive or negative. The gains are quantized by using a quantization table times a scale factor. The second stage uses the table gain_sq4Tbl, and the third stage uses gain_sq3Tbl. The scale factor equates 0.1 or the absolute value of the quantized gain representation value obtained in the previous stage, whichever is larger. Again, the resulting gain index is the index to the nearest value of the quantization table times the scale factor.",
      "ja": "後続の 2 つのステージのゲインは、正または負のいずれかになります。ゲインは、量子化テーブルにスケール係数を掛けたものを使用して量子化されます。2 番目のステージではテーブル Gain_sq4Tbl が使用され、3 番目のステージでは Gain_sq3Tbl が使用されます。スケールファクタは、0.1 または前段で得られた量子化ゲイン表現値の絶対値のいずれか大きい方に相当します。繰り返しますが、結果として得られるゲイン インデックスは、量子化テーブルの最も近い値のインデックスにスケール ファクターを掛けたものになります。"
    },
    {
      "indent": 8,
      "text": "gainQ = scaleFact * gain_sqXTbl[index]",
      "ja": "ゲインQ = スケールファクト * ゲイン_sqXTbl[インデックス]"
    },
    {
      "indent": 3,
      "text": "gain_sq4Tbl[16]={-1.049988, -0.900024, -0.750000, -0.599976,\n               -0.450012, -0.299988, -0.150024, 0.000000, 0.150024,\n               0.299988, 0.450012, 0.599976, 0.750000, 0.900024,\n               1.049988, 1.200012}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "gain_sq3Tbl[8]={-1.000000, -0.659973, -0.330017,0.000000,\n               0.250000, 0.500000, 0.750000, 1.00000}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.6.4.3. Preparation of Target for Next Stage",
      "section_title": true,
      "ja": "3.6.4.3. 次のステージに向けた目標の準備"
    },
    {
      "indent": 3,
      "text": "Before performing the search for the next stage, the perceptually weighted target vector is updated by subtracting from it the selected codebook vector (from the perceptually weighted codebook) times the corresponding quantized gain.",
      "ja": "次のステージの検索を実行する前に、知覚的に重み付けされたターゲット ベクトルから、(知覚的に重み付けされたコードブックからの) 選択されたコードブック ベクトルと対応する量子化ゲインの積を減算することによって、知覚的に重み付けされたターゲット ベクトルが更新されます。"
    },
    {
      "indent": 6,
      "text": "target[i] = target[i] - gainQ * selected_vec[i];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A reference implementation of the codebook encoding is found in Appendix A.34.",
      "ja": "コードブックエンコーディングの参照実装は、付録 A.34 にあります。"
    },
    {
      "indent": 0,
      "text": "3.7. Gain Correction Encoding",
      "section_title": true,
      "ja": "3.7. ゲイン補正エンコーディング"
    },
    {
      "indent": 3,
      "text": "The start state is quantized in a relatively model independent manner using 3 bits per sample. In contrast, the remaining parts of the block are encoded by using an adaptive codebook. This codebook will produce high matching accuracy whenever there is a high correlation between the target and the best codebook vector. For unvoiced speech segments and background noises, this is not necessarily so, which, due to the nature of the squared error criterion, results in a coded signal with less power than the target signal. As the coded start state has good power matching to the target, the result is a power fluctuation within the encoded frame. Perceptually, the main problem with this is that the time envelope of the signal energy becomes unsteady. To overcome this problem, the gains for the codebooks are re-scaled after the codebook encoding by searching for a new gain factor for the first stage codebook that provides better power matching.",
      "ja": "開始状態は、サンプルあたり 3 ビットを使用して、比較的モデルに依存しない方法で量子化されます。対照的に、ブロックの残りの部分は適応コードブックを使用してエンコードされます。このコードブックは、ターゲットと最適なコードブック ベクトルの間に高い相関がある場合に、高いマッチング精度を生成します。無声音声セグメントや背景雑音の場合、これは必ずしもそうではありません。二乗誤差基準の性質により、コード化された信号のパワーがターゲット信号よりも低くなります。符号化された開始状態のパワーはターゲットと良好に一致しているため、結果として、符号化されたフレーム内でパワーが変動します。知覚的には、これに関する主な問題は、信号エネルギーの時間エンベロープが不安定になることです。この問題を解決するために、コードブックのゲインは、より優れた電力マッチングを提供する第 1 段階のコードブックの新しいゲイン係数を検索することによって、コードブックのエンコード後に再スケーリングされます。"
    },
    {
      "indent": 3,
      "text": "First, the energy for the target signal, tene, is computed along with the energy for the coded signal, cene, given by the addition of the three gain scaled codebook vectors. Because the gains of the second and third stage scale with the gain of the first stage, when the first stage gain is changed from gain[0] to gain_sq5Tbl[i] the energy of the coded signal changes from cene to",
      "ja": "まず、ターゲット信号のエネルギー tene が、3 つのゲイン スケーリング コードブック ベクトルの加算によって得られるコード化信号 cene のエネルギーとともに計算されます。2 番目と 3 番目のステージのゲインは 1 番目のステージのゲインに合わせて調整されるため、最初のステージのゲインが Gain[0] から Gain_sq5Tbl[i] に変更されると、コード化された信号のエネルギーは cene から cene に変化します。"
    },
    {
      "indent": 6,
      "text": "cene*(gain_sq5Tbl[i]*gain_sq5Tbl[i])/(gain[0]*gain[0])",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where gain[0] is the gain for the first stage found in the original codebook search. A refined search is performed by testing the gain indices i=0 to 31, and as long as the new codebook energy as given above is less than tene, the gain index for stage 1 is increased. A restriction is applied so that the new gain value for stage 1 cannot be more than two times higher than the original value found in the codebook search. Note that by using this method we do not change the shape of the encoded vector, only the gain or amplitude.",
      "ja": "ここで、gain[0] は、元のコードブック検索で見つかった最初のステージのゲインです。洗練された検索は、ゲイン インデックス i=0 ～ 31 をテストすることによって実行され、上記の新しいコードブック エネルギーが 10 未満である限り、ステージ 1 のゲイン インデックスは増加します。ステージ 1 の新しいゲイン値が、コードブック検索で見つかった元の値の 2 倍を超えてはいけないという制限が適用されます。この方法を使用すると、エンコードされたベクトルの形状は変更されず、ゲインまたは振幅のみが変更されることに注意してください。"
    },
    {
      "indent": 0,
      "text": "3.8. Bitstream Definition",
      "section_title": true,
      "ja": "3.8. ビットストリームの定義"
    },
    {
      "indent": 3,
      "text": "The total number of bits used to describe one frame of 20 ms speech is 304, which fits in 38 bytes and results in a bit rate of 15.20 kbit/s. For the case of a frame length of 30 ms speech, the total number of bits used is 400, which fits in 50 bytes and results in a bit rate of 13.33 kbit/s. In the bitstream definition, the bits are distributed into three classes according to their bit error or loss sensitivity. The most sensitive bits (class 1) are placed first in the bitstream for each frame. The less sensitive bits (class 2) are placed after the class 1 bits. The least sensitive bits (class 3) are placed at the end of the bitstream for each frame.",
      "ja": "20 ミリ秒の音声の 1 フレームを記述するために使用されるビットの総数は 304 で、これは 38 バイトに収まり、ビット レートは 15.20 kbit/s になります。フレーム長が 30 ms の音声の場合、使用されるビットの総数は 400 で、50 バイトに収まり、ビット レートは 13.33 kbit/s になります。ビットストリーム定義では、ビットはビットエラーまたは損失感度に応じて 3 つのクラスに分類されます。最も機密性の高いビット (クラス 1) が各フレームのビットストリームの最初に配置されます。機密性の低いビット (クラス 2) は、クラス 1 ビットの後に配置されます。最も機密性の低いビット (クラス 3) は、各フレームのビットストリームの最後に配置されます。"
    },
    {
      "indent": 3,
      "text": "In the 20/30 ms frame length cases for each class, the following hold true: The class 1 bits occupy a total of 6/8 bytes (48/64 bits), the class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3 bits occupy 24/30 bytes (191/239 bits). This distribution of the bits enables the use of uneven level protection (ULP) as is exploited in the payload format definition for iLBC [1]. The detailed bit allocation is shown in the table below. When a quantization index is distributed between more classes, the more significant bits belong to the lowest class.",
      "ja": "各クラスのフレーム長が 20/30 ミリ秒の場合、次のことが当てはまります。クラス 1 ビットは合計 6/8 バイト (48/64 ビット) を占有し、クラス 2 ビットは 8/12 バイト (64/96 ビット) を占有します。ビット）、クラス 3 ビットは 24/30 バイト（191/239 ビット）を占有します。このビットの分配により、iLBC [1] のペイロード フォーマット定義で活用されているような、不均等レベル保護 (ULP) の使用が可能になります。詳細なビット割り当てを次の表に示します。量子化インデックスがより多くのクラスに分散される場合、より重要なビットは最下位のクラスに属します。"
    },
    {
      "indent": 3,
      "text": "Bitstream structure:",
      "ja": "ビットストリーム構造:"
    },
    {
      "indent": 3,
      "text": "------------------------------------------------------------------+\nParameter                         |       Bits Class <1,2,3>      |\n                                  |  20 ms frame  |  30 ms frame  |\n----------------------------------+---------------+---------------+\n                         Split 1  |   6 <6,0,0>   |   6 <6,0,0>   |\n                LSF 1    Split 2  |   7 <7,0,0>   |   7 <7,0,0>   |\nLSF                      Split 3  |   7 <7,0,0>   |   7 <7,0,0>   |\n                ------------------+---------------+---------------+\n                         Split 1  | NA (Not Appl.)|   6 <6,0,0>   |\n                LSF 2    Split 2  |      NA       |   7 <7,0,0>   |\n                         Split 3  |      NA       |   7 <7,0,0>   |\n                ------------------+---------------+---------------+\n                Sum               |  20 <20,0,0>  |  40 <40,0,0>  |\n----------------------------------+---------------+---------------+\nBlock Class                       |   2 <2,0,0>   |   3 <3,0,0>   |\n----------------------------------+---------------+---------------+\nPosition 22 sample segment        |   1 <1,0,0>   |   1 <1,0,0>   |\n----------------------------------+---------------+---------------+\nScale Factor State Coder          |   6 <6,0,0>   |   6 <6,0,0>   |\n----------------------------------+---------------+---------------+\n                Sample 0          |   3 <0,1,2>   |   3 <0,1,2>   |\nQuantized       Sample 1          |   3 <0,1,2>   |   3 <0,1,2>   |\nResidual           :              |   :    :      |   :    :      |\nState              :              |   :    :      |   :    :      |\nSamples            :              |   :    :      |   :    :      |\n                Sample 56         |   3 <0,1,2>   |   3 <0,1,2>   |\n                Sample 57         |      NA       |   3 <0,1,2>   |\n                ------------------+---------------+---------------+\n                Sum               | 171 <0,57,114>| 174 <0,58,116>|\n----------------------------------+---------------+---------------+\n                         Stage 1  |   7 <6,0,1>   |   7 <4,2,1>   |\nCB for 22/23             Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\nsample block             Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n                ------------------+---------------+---------------+\n                Sum               |  21 <6,0,15>  |  21 <4,2,15>  |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   5 <2,0,3>   |   5 <1,1,3>   |\nGain for 22/23           Stage 2  |   4 <1,1,2>   |   4 <1,1,2>   |\nsample block             Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                Sum               |  12 <3,1,8>   |  12 <2,2,8>   |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   8 <7,0,1>   |   8 <6,1,1>   |\n            sub-block 1  Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\n                         Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n                ------------------+---------------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                         Stage 1  |   8 <0,0,8>   |   8 <0,7,1>   |\n            sub-block 2  Stage 2  |   8 <0,0,8>   |   8 <0,0,8>   |\nIndices                  Stage 3  |   8 <0,0,8>   |   8 <0,0,8>   |\nfor CB          ------------------+---------------+---------------+\nsub-blocks               Stage 1  |      NA       |   8 <0,7,1>   |\n            sub-block 3  Stage 2  |      NA       |   8 <0,0,8>   |\n                         Stage 3  |      NA       |   8 <0,0,8>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |      NA       |   8 <0,7,1>   |\n            sub-block 4  Stage 2  |      NA       |   8 <0,0,8>   |\n                         Stage 3  |      NA       |   8 <0,0,8>   |\n                ------------------+---------------+---------------+\n                Sum               |  46 <7,0,39>  |  94 <6,22,66> |\n----------------------------------+---------------+---------------+\n                         Stage 1  |   5 <1,2,2>   |   5 <1,2,2>   |\n            sub-block 1  Stage 2  |   4 <1,1,2>   |   4 <1,2,1>   |\n                         Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |   5 <1,1,3>   |   5 <0,2,3>   |\n            sub-block 2  Stage 2  |   4 <0,2,2>   |   4 <0,2,2>   |\n                         Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\nGains for       ------------------+---------------+---------------+\nsub-blocks               Stage 1  |      NA       |   5 <0,1,4>   |\n            sub-block 3  Stage 2  |      NA       |   4 <0,1,3>   |\n                         Stage 3  |      NA       |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                         Stage 1  |      NA       |   5 <0,1,4>   |\n            sub-block 4  Stage 2  |      NA       |   4 <0,1,3>   |\n                         Stage 3  |      NA       |   3 <0,0,3>   |\n                ------------------+---------------+---------------+\n                Sum               |  24 <3,6,15>  |  48 <2,12,34> |\n----------------------------------+---------------+---------------+\nEmpty frame indicator             |   1 <0,0,1>   |   1 <0,0,1>   |\n-------------------------------------------------------------------\nSUM                                 304 <48,64,192> 400 <64,96,240>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Table 3.2. The bitstream definition for iLBC for both the 20 ms frame size mode and the 30 ms frame size mode.",
      "ja": "表3.220 ms フレーム サイズ モードと 30 ms フレーム サイズ モードの両方の iLBC のビットストリーム定義。"
    },
    {
      "indent": 3,
      "text": "When packetized into the payload, the bits MUST be sorted as follows: All the class 1 bits in the order (from top to bottom) as specified in the table, all the class 2 bits (from top to bottom), and all the class 3 bits in the same sequential order. The last bit, the empty frame indicator, SHOULD be set to zero by the encoder. If this bit is set to 1 the decoder SHOULD treat the data as a lost frame. For example, this bit can be set to 1 to indicate lost frame for file storage format, as in [1].",
      "ja": "ペイロードにパケット化されるとき、ビットは次のようにソートされなければなりません。表で指定されている順序で (上から下へ) クラス 1 のすべてのビット、(上から下へ) クラス 2 のすべてのビット、およびクラスのすべてのビット同じ順序の 3 ビット。最後のビットである空フレームインジケーターは、エンコーダーによってゼロに設定されるべきです(SHOULD)。このビットが 1 に設定されている場合、デコーダはデータを失われたフレームとして扱うべきです(SHOULD)。たとえば、[1] のように、このビットを 1 に設定すると、ファイル ストレージ フォーマットのフレームが失われたことを示すことができます。"
    },
    {
      "indent": 0,
      "text": "4. Decoder Principles",
      "section_title": true,
      "ja": "4. デコーダの原理"
    },
    {
      "indent": 3,
      "text": "This section describes the principles of each component of the decoder algorithm.",
      "ja": "このセクションでは、デコーダ アルゴリズムの各コンポーネントの原理について説明します。"
    },
    {
      "indent": 3,
      "text": "           +-------------+    +--------+    +---------------+\npayload -> | 1. Get para | -> | 2. LPC | -> | 3. Sc Dequant | ->\n           +-------------+    +--------+    +---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "   +-------------+    +------------------+\n-> | 4. Mem setup| -> | 5. Construct res |------->\n|  +-------------+    +-------------------   |\n---------<-----------<-----------<------------\n          Sub-frame 0...2/4 (20 ms/30 ms)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "   +----------------+    +----------+\n-> | 6. Enhance res | -> | 7. Synth | ------------>\n   +----------------+    +----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "   +-----------------+\n-> | 8. Post Process | ----------------> decoded speech\n   +-----------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4.1. Flow chart of the iLBC decoder. If a frame was lost, steps 1 to 5 SHOULD be replaced by a PLC algorithm.",
      "ja": "図4.1。iLBC デコーダのフローチャート。フレームが失われた場合は、ステップ 1 ～ 5 を PLC アルゴリズムに置き換えるべきです (SHOULD)。"
    },
    {
      "indent": 3,
      "text": "1. Extract the parameters from the bitstream.",
      "ja": "1. ビットストリームからパラメータを抽出します。"
    },
    {
      "indent": 3,
      "text": "2. Decode the LPC and interpolate (section 4.1).",
      "ja": "2. LPC をデコードして補間します (セクション 4.1)。"
    },
    {
      "indent": 3,
      "text": "3. Construct the 57/58-sample start state (section 4.2).",
      "ja": "3. 57/58 サンプルの開始状態を構築します (セクション 4.2)。"
    },
    {
      "indent": 3,
      "text": "4. Set up the memory by using data from the decoded residual. This memory is used for codebook construction. For blocks preceding the start state, both the decoded residual and the target are time reversed. Sub-frames are decoded in the same order as they were encoded.",
      "ja": "4. デコードされた残差からのデータを使用してメモリをセットアップします。このメモリはコードブックの構築に使用されます。開始状態に先行するブロックの場合、デコードされた残差とターゲットの両方が時間反転されます。サブフレームは、エンコードされたときと同じ順序でデコードされます。"
    },
    {
      "indent": 3,
      "text": "5. Construct the residuals of this sub-frame (gain[0]*cbvec[0] + gain[1]*cbvec[1] + gain[2]*cbvec[2]). Repeat 4 and 5 until the residual of all sub-blocks has been constructed.",
      "ja": "5. このサブフレームの残差を構築します (gain[0]*cbvec[0]、gain[1]*cbvec[1]、gain[2]*cbvec[2])。すべてのサブブロックの残差が構築されるまで、4 と 5 を繰り返します。"
    },
    {
      "indent": 3,
      "text": "6. Enhance the residual with the post filter (section 4.6).",
      "ja": "6. ポストフィルターを使用して残差を強調します (セクション 4.6)。"
    },
    {
      "indent": 3,
      "text": "7. Synthesis of the residual (section 4.7).",
      "ja": "7. 残差の合成 (セクション 4.7)。"
    },
    {
      "indent": 3,
      "text": "8. Post process with HP filter, if desired (section 4.8).",
      "ja": "8. 必要に応じて、HP フィルターを使用した後処理を行います (セクション 4.8)。"
    },
    {
      "indent": 0,
      "text": "4.1. LPC Filter Reconstruction",
      "section_title": true,
      "ja": "4.1. LPC フィルターの再構築"
    },
    {
      "indent": 3,
      "text": "The decoding of the LP filter parameters is very straightforward. For a set of three/six indices, the corresponding LSF vector(s) are found by simple table lookup. For each of the LSF vectors, the three split vectors are concatenated to obtain qlsf1 and qlsf2, respectively (in the 20 ms mode only one LSF vector, qlsf, is constructed). The next step is the stability check described in section 3.2.5 followed by the interpolation scheme described in section 3.2.6 (3.2.7 for 20 ms frames). The only difference is that only the quantized LSFs are known at the decoder, and hence the unquantized LSFs are not processed.",
      "ja": "LP フィルター パラメーターのデコードは非常に簡単です。3 つまたは 6 つのインデックスのセットの場合、対応する LSF ベクトルは単純なテーブル検索によって見つかります。各 LSF ベクトルについて、3 つの分割ベクトルが連結されて、それぞれ qlsf1 と qlsf2 が得られます (20 ms モードでは、1 つの LSF ベクトル qlsf のみが構築されます)。次のステップは、セクション 3.2.5 で説明されている安定性チェックであり、その後、セクション 3.2.6 (20 ms フレームの場合は 3.2.7) で説明されている補間スキームが続きます。唯一の違いは、量子化された LSF のみがデコーダで認識されるため、量子化されていない LSF は処理されないことです。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the LPC filter reconstruction is given in Appendix A.36.",
      "ja": "LPC フィルタ再構成の参照実装は、付録 A.36 に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.2. Start State Reconstruction",
      "section_title": true,
      "ja": "4.2. 状態の再構築を開始する"
    },
    {
      "indent": 3,
      "text": "The scalar encoded STATE_SHORT_LEN=58 (STATE_SHORT_LEN=57 in the 20 ms mode) state samples are reconstructed by 1) forming a set of samples (by table lookup) from the index stream idxVec[n], 2) multiplying the set with 1/scal=(10^qmax)/4.5, 3) time reversing the 57/58 samples, 4) filtering the time reversed block with the dispersion (all-pass) filter used in the encoder (as described in section 3.5.2); this compensates for the phase distortion of the earlier filter operation, and 5 reversing the 57/58 samples from the previous step.",
      "ja": "スカラー エンコードされた STATE_SHORT_LEN=58 (20 ミリ秒モードでは STATE_SHORT_LEN=57) 状態サンプルは、1) インデックス ストリーム idxVec[n] から (テーブル ルックアップによって) サンプルのセットを形成し、2) セットに 1/ を乗算することによって再構築されます。scal=(10^qmax)/4.5、3) 57/58 サンプルの時間を反転、4) エンコーダで使用される分散 (オールパス) フィルターで時間反転ブロックをフィルター処理 (セクション 3.5.2 で説明)。これにより、前のフィルタ操作の位相歪みが補償され、前のステップからの 57/58 サンプルが反転されます。"
    },
    {
      "indent": 3,
      "text": "in(0..(STATE_SHORT_LEN-1)) = time reversed samples from table look-up, idxVecDec((STATE_SHORT_LEN-1)..0)",
      "ja": "in(0..(STATE_SHORT_LEN-1)) = テーブルルックアップからの時間反転サンプル、idxVecDec((STATE_SHORT_LEN-1)..0)"
    },
    {
      "indent": 3,
      "text": "in(STATE_SHORT_LEN..(2*STATE_SHORT_LEN-1)) = 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pk(z) = A~rk(z)/A~k(z), where\n                               ___\n                               \\\nA~rk(z)= z^(-LPC_FILTERORDER) + > a~ki*z^(i-(LPC_FILTERORDER-1))\n                               /__\n                           i=0...(LPC_FILTERORDER-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and A~k(z) is taken from the block where the start state begins",
      "ja": "A~k(z) は開始状態が始まるブロックから取得されます。"
    },
    {
      "indent": 3,
      "text": "in -> Pk(z) -> filtered",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "out(k) = filtered(STATE_SHORT_LEN-1-k) +\n                        filtered(2*STATE_SHORT_LEN-1-k),\n                                      k=0..(STATE_SHORT_LEN-1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The remaining 23/22 samples in the state are reconstructed by the same adaptive codebook technique described in section 4.3. The location bit determines whether these are the first or the last 23/22 samples of the 80-sample state vector. If the remaining 23/22 samples are the first samples, then the scalar encoded STATE_SHORT_LEN state samples are time-reversed before initialization of the adaptive codebook memory vector.",
      "ja": "状態内の残りの 23/22 サンプルは、セクション 4.3 で説明されているのと同じ適応コードブック手法によって再構築されます。位置ビットは、これらが 80 サンプルの状態ベクトルの最初の 23/22 サンプルであるか最後の 23/22 サンプルであるかを決定します。残りの 23/22 サンプルが最初のサンプルである場合、スカラー エンコードされた STATE_SHORT_LEN 状態サンプルは、適応コードブック メモリ ベクトルの初期化前に時間反転されます。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the start state reconstruction is given in Appendix A.44.",
      "ja": "開始状態再構築の参照実装は、付録 A.44 に記載されています。"
    },
    {
      "indent": 0,
      "text": "4.3. Excitation Decoding Loop",
      "section_title": true,
      "ja": "4.3. 励起デコードループ"
    },
    {
      "indent": 3,
      "text": "The decoding of the LPC excitation vector proceeds in the same order in which the residual was encoded at the encoder. That is, after the decoding of the entire 80-sample state vector, the forward sub-blocks (corresponding to samples occurring after the state vector samples) are decoded, and then the backward sub-blocks (corresponding to samples occurring before the state vector) are decoded, resulting in a fully decoded block of excitation signal samples.",
      "ja": "LPC 励起ベクトルの復号化は、残差がエンコーダで符号化されたのと同じ順序で進行します。つまり、80 サンプルの状態ベクトル全体を復号した後、前方サブブロック (状態ベクトル サンプルの後に発生するサンプルに対応) が復号され、次に後方サブブロック (状態ベクトルの前に発生するサンプルに対応) が復号されます。) がデコードされ、励起信号サンプルの完全にデコードされたブロックが得られます。"
    },
    {
      "indent": 3,
      "text": "In particular, each sub-block is decoded by using the multistage adaptive codebook decoding module described in section 4.4. This module relies upon an adaptive codebook memory constructed before each run of the adaptive codebook decoding. The construction of the adaptive codebook memory in the decoder is identical to the method outlined in section 3.6.3, except that it is done on the codebook memory without perceptual weighting.",
      "ja": "特に、各サブブロックは、セクション 4.4 で説明されている多段階適応コードブック復号モジュールを使用して復号されます。このモジュールは、適応コードブック復号化の各実行前に構築された適応コードブック メモリに依存します。デコーダ内の適応コードブック メモリの構築は、知覚的重み付けを行わずにコードブック メモリ上で行われることを除いて、セクション 3.6.3 で概説した方法と同じです。"
    },
    {
      "indent": 3,
      "text": "For the initial forward sub-block, the last STATE_LEN=80 samples of the length CB_LMEM=147 adaptive codebook memory are filled with the samples of the state vector. For subsequent forward sub-blocks, the first SUBL=40 samples of the adaptive codebook memory are discarded, the remaining samples are shifted by SUBL samples toward the beginning of the vector, and the newly decoded SUBL=40 samples are placed at the end of the adaptive codebook memory. For backward sub-blocks, the construction is similar, except that every vector of samples involved is first time reversed.",
      "ja": "最初の前方サブブロックでは、長さ CB_LMEM=147 の適応コードブック メモリの最後の STATE_LEN=80 サンプルが状態ベクトルのサンプルで満たされます。後続の前方サブブロックでは、適応コードブック メモリの最初の SUBL=40 サンプルが破棄され、残りのサンプルがベクトルの先頭に向かって SUBL サンプルずつシフトされ、新しくデコードされた SUBL=40 サンプルがベクトルの最後に配置されます。適応コードブックメモリ。逆方向サブブロックの場合、関係するサンプルのすべてのベクトルが最初に反転されることを除いて、構築は同様です。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the excitation decoding loop is found in Appendix A.5.",
      "ja": "励起復号化ループの参照実装は付録 A.5 にあります。"
    },
    {
      "indent": 0,
      "text": "4.4. Multistage Adaptive Codebook Decoding",
      "section_title": true,
      "ja": "4.4. 多段階適応コードブック復号化"
    },
    {
      "indent": 3,
      "text": "The Multistage Adaptive Codebook Decoding module is used at both the sender (encoder) and the receiver (decoder) ends to produce a synthetic signal in the residual domain that is eventually used to produce synthetic speech. The module takes the index values used to construct vectors that are scaled and summed together to produce a synthetic signal that is the output of the module.",
      "ja": "マルチステージ適応コードブック復号モジュールは、送信側 (エンコーダー) と受信側 (デコーダー) の両方で使用され、最終的に合成音声の生成に使用される残差領域で合成信号を生成します。モジュールは、スケーリングおよび合計されてモジュールの出力である合成信号を生成するベクトルを構築するために使用されるインデックス値を取得します。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Construction of the Decoded Excitation Signal",
      "section_title": true,
      "ja": "4.4.1. デコードされた励起信号の構築"
    },
    {
      "indent": 3,
      "text": "The unpacked index values provided at the input to the module are references to extended codebooks, which are constructed as described in section 3.6.3, except that they are based on the codebook memory without the perceptual weighting. The unpacked three indices are used to look up three codebook vectors. The unpacked three gain indices are used to decode the corresponding 3 gains. In this decoding, the successive rescaling, as described in section 3.6.4.2, is applied.",
      "ja": "モジュールへの入力で提供されるアンパックされたインデックス値は拡張コードブックへの参照であり、知覚的重み付けのないコードブック メモリに基づいている点を除き、セクション 3.6.3 で説明したように構築されます。アンパックされた 3 つのインデックスは、3 つのコードブック ベクトルを検索するために使用されます。アンパックされた 3 つのゲイン インデックスは、対応する 3 つのゲインをデコードするために使用されます。このデコードでは、セクション 3.6.4.2 で説明されているように、逐次再スケーリングが適用されます。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the adaptive codebook decoding is listed in Appendix A.32.",
      "ja": "適応コードブック復号化の参照実装は、付録 A.32 にリストされています。"
    },
    {
      "indent": 0,
      "text": "4.5. Packet Loss Concealment",
      "section_title": true,
      "ja": "4.5. パケットロスの隠蔽"
    },
    {
      "indent": 3,
      "text": "If packet loss occurs, the decoder receives a signal saying that information regarding a block is lost. For such blocks it is RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create a decoded signal that masks the effect of that packet loss. In the following we will describe an example of a PLC unit that can be used with the iLBC codec. As the PLC unit is used only at the decoder, the PLC unit does not affect interoperability between implementations. Other PLC implementations MAY therefore be used.",
      "ja": "パケット損失が発生すると、デコーダはブロックに関する情報が失われたことを示す信号を受信します。このようなブロックの場合、パケット損失隠蔽 (PLC) ユニットを使用して、パケット損失の影響をマスクするデコードされた信号を作成することが推奨されます。以下に、iLBC コーデックで使用できる PLC ユニットの例を説明します。PLC ユニットはデコーダでのみ使用されるため、PLC ユニットは実装間の相互運用性に影響を与えません。したがって、他の PLC 実装を使用してもよい(MAY)。"
    },
    {
      "indent": 3,
      "text": "The PLC described operates on the LP filters and the excitation signals and is based on the following principles:",
      "ja": "説明した PLC は LP フィルターと励起信号で動作し、次の原理に基づいています。"
    },
    {
      "indent": 0,
      "text": "4.5.1. Block Received Correctly and Previous Block Also Received",
      "section_title": true,
      "ja": "4.5.1. ブロックは正しく受信され、前のブロックも受信されました"
    },
    {
      "indent": 3,
      "text": "If the block is received correctly, the PLC only records state information of the current block that can be used in case the next block is lost. The LP filter coefficients for each sub-block and the entire decoded excitation signal are all saved in the decoder state structure. All of this information will be needed if the following block is lost.",
      "ja": "ブロックが正しく受信された場合、PLC は、次のブロックが失われた場合に使用できる現在のブロックの状態情報のみを記録します。各サブブロックの LP フィルター係数と復号化された励振信号全体は、すべてデコーダー状態構造に保存されます。次のブロックが失われた場合、この情報はすべて必要になります。"
    },
    {
      "indent": 0,
      "text": "4.5.2. Block Not Received",
      "section_title": true,
      "ja": "4.5.2. ブロックが受信されませんでした"
    },
    {
      "indent": 3,
      "text": "If the block is not received, the block substitution is based on a pitch-synchronous repetition of the excitation signal, which is filtered by the last LP filter of the previous block. The previous block's information is stored in the decoder state structure.",
      "ja": "ブロックが受信されない場合、ブロック置換は、前のブロックの最後の LP フィルターによってフィルター処理された励起信号のピッチ同期繰り返しに基づいて行われます。前のブロックの情報はデコーダ状態構造体に保存されます。"
    },
    {
      "indent": 3,
      "text": "A correlation analysis is performed on the previous block's excitation signal in order to detect the amount of pitch periodicity and a pitch value. The correlation measure is also used to decide on the voicing level (the degree to which the previous block's excitation was a voiced or roughly periodic signal). The excitation in the previous block is used to create an excitation for the block to be substituted, such that the pitch of the previous block is maintained. Therefore, the new excitation is constructed in a pitch-synchronous manner. In order to avoid a buzzy-sounding substituted block, a random excitation is mixed with the new pitch periodic excitation, and the relative use of the two components is computed from the correlation measure (voicing level).",
      "ja": "ピッチ周期性の量とピッチ値を検出するために、前のブロックの励起信号に対して相関分析が実行されます。相関測定は、有声レベル (前のブロックの励起が有声信号またはほぼ周期的な信号であった程度) を決定するためにも使用されます。前のブロックの励振は、前のブロックのピッチが維持されるように、置換されるブロックの励振を作成するために使用されます。したがって、新しい励振はピッチ同期方式で構築されます。ブンジーなサウンドの置換ブロックを回避するために、ランダムな励振が新しいピッチ周期的な励振と混合され、2 つの成分の相対的な使用が相関尺度 (有声レベル) から計算されます。"
    },
    {
      "indent": 3,
      "text": "For the block to be substituted, the newly constructed excitation signal is then passed through the LP filter to produce the speech that will be substituted for the lost block.",
      "ja": "ブロックを置き換えるために、新しく構築された励起信号が LP フィルターを通過して、失われたブロックの代わりとなる音声が生成されます。"
    },
    {
      "indent": 3,
      "text": "For several consecutive lost blocks, the packet loss concealment continues in a similar manner. The correlation measure of the last block received is still used along with the same pitch value. The LP filters of the last block received are also used again. The energy of the substituted excitation for consecutive lost blocks is decreased, leading to a dampened excitation, and therefore to dampened speech.",
      "ja": "いくつかの連続した失われたブロックについて、パケット損失の隠蔽は同様の方法で継続されます。最後に受信したブロックの相関尺度は、同じピッチ値とともに引き続き使用されます。最後に受信したブロックの LP フィルターも再度使用されます。連続的に失われたブロックの代替励起のエネルギーは減少し、励起の減衰につながり、したがって音声の減衰につながります。"
    },
    {
      "indent": 0,
      "text": "4.5.3. Block Received Correctly When Previous Block Not Received",
      "section_title": true,
      "ja": "4.5.3. 前のブロックが受信されなかった場合でもブロックは正しく受信されました"
    },
    {
      "indent": 3,
      "text": "For the case in which a block is received correctly when the previous block was not, the correctly received block's directly decoded speech (based solely on the received block) is not used as the actual output. The reason for this is that the directly decoded speech does not necessarily smoothly merge into the synthetic speech generated for the previous lost block. If the two signals are not smoothly merged, an audible discontinuity is accidentally produced. Therefore, a correlation analysis between the two blocks of excitation signal (the excitation of the previous concealed block and that of the current received block) is performed to find the best phase match. Then a simple overlap-add procedure is performed to merge the previous excitation smoothly into the current block's excitation.",
      "ja": "前のブロックが正しく受信されなかったときにブロックが正しく受信された場合、正しく受信されたブロックの直接デコードされた音声 (受信ブロックのみに基づく) は実際の出力として使用されません。その理由は、直接デコードされた音声が、以前の失われたブロックに対して生成された合成音声に必ずしもスムーズにマージするとは限らないためです。2 つの信号がスムーズにマージされないと、誤って聞こえる不連続性が発生します。したがって、励起信号の 2 つのブロック (前の隠蔽されたブロックの励起と現在の受信ブロックの励起) 間の相関分析が実行され、最良の位相一致が見つかります。次に、単純なオーバーラップ加算手順が実行され、前の励起が現在のブロックの励起にスムーズにマージされます。"
    },
    {
      "indent": 3,
      "text": "The exact implementation of the packet loss concealment does not influence interoperability of the codec.",
      "ja": "パケット損失隠蔽の正確な実装は、コーデックの相互運用性に影響しません。"
    },
    {
      "indent": 3,
      "text": "A reference implementation of the packet loss concealment is suggested in Appendix A.14. Exact compliance with this suggested algorithm is not needed for a reference implementation to be fully compatible with the overall codec specification.",
      "ja": "パケット損失隠蔽のリファレンス実装は、付録 A.14 で提案されています。リファレンス実装がコーデック仕様全体と完全に互換性を持つためには、この推奨アルゴリズムに厳密に準拠する必要はありません。"
    },
    {
      "indent": 0,
      "text": "4.6. Enhancement",
      "section_title": true,
      "ja": "4.6. 強化"
    },
    {
      "indent": 3,
      "text": "The decoder contains an enhancement unit that operates on the reconstructed excitation signal. The enhancement unit increases the perceptual quality of the reconstructed signal by reducing the speech-correlated noise in the voiced speech segments. Compared to traditional postfilters, the enhancer has an advantage in that it can only modify the excitation signal slightly. This means that there is no risk of over enhancement. The enhancer works very similarly for both the 20 ms frame size mode and the 30 ms frame size mode.",
      "ja": "デコーダには、再構成された励起信号に作用する拡張ユニットが含まれています。強化ユニットは、有声音声セグメント内の音声相関ノイズを低減することにより、再構成された信号の知覚品質を向上させます。従来のポストフィルターと比較して、エンハンサーには励起信号をわずかに変更するだけであるという利点があります。これは、過剰な強化のリスクがないことを意味します。エンハンサーは、20 ms フレーム サイズ モードと 30 ms フレーム サイズ モードの両方で非常に同様に機能します。"
    },
    {
      "indent": 3,
      "text": "For the mode with 20 ms frame size, the enhancer uses a memory of six 80-sample excitation blocks prior in time plus the two new 80-sample excitation blocks. For each block of 160 new unenhanced excitation samples, 160 enhanced excitation samples are produced. The enhanced excitation is 40-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.",
      "ja": "20 ms フレーム サイズのモードの場合、エンハンサーは、時間的に前の 6 つの 80 サンプル励起ブロックのメモリと、2 つの新しい 80 サンプル励起ブロックのメモリを使用します。160 個の新しい非強化励起サンプルのブロックごとに、160 個の強化励起サンプルが生成されます。エンハンサー アルゴリズムが先読みを使用するため、強化された励起は、強化されていない励起と比較して 40 サンプル遅延します。"
    },
    {
      "indent": 3,
      "text": "For the mode with 30 ms frame size, the enhancer uses a memory of five 80-sample excitation blocks prior in time plus the three new 80-sample excitation blocks. For each block of 240 new unenhanced excitation samples, 240 enhanced excitation samples are produced. The enhanced excitation is 80-sample delayed compared to the unenhanced excitation, as the enhancer algorithm uses lookahead.",
      "ja": "フレーム サイズが 30 ms のモードの場合、エンハンサーは、時間的に前の 5 つの 80 サンプル励起ブロックと、3 つの新しい 80 サンプル励起ブロックのメモリを使用します。240 個の新しい非強化励起サンプルのブロックごとに、240 個の強化励起サンプルが生成されます。エンハンサー アルゴリズムが先読みを使用するため、強化された励起は、強化されていない励起と比較して 80 サンプル遅延します。"
    },
    {
      "indent": 3,
      "text": "Outline of Enhancer",
      "ja": "エンハンサーの概要"
    },
    {
      "indent": 3,
      "text": "The speech enhancement unit operates on sub-blocks of 80 samples, which means that there are two/three 80 sample sub-blocks per frame. Each of these two/three sub-blocks is enhanced separately, but in an analogous manner.",
      "ja": "音声強調ユニットは 80 サンプルのサブブロックで動作します。これは、フレームごとに 2 つまたは 3 つの 80 サンプルのサブブロックがあることを意味します。これら 2 つまたは 3 つのサブブロックはそれぞれ個別に強化されますが、同様の方法で強化されます。"
    },
    {
      "indent": 3,
      "text": "unenhanced residual\n        |\n        |   +---------------+    +--------------+\n        +-> | 1. Pitch Est  | -> | 2. Find PSSQ | -------->\n            +---------------+  | +--------------+\n                               +-----<-------<------<--+\n            +------------+         enh block 0..1/2    |\n         -> | 3. Smooth  |                             |\n            +------------+                             |\n              \\                                        |\n              /\\                                       |\n             /  \\   Already                            |\n            / 4. \\----------->----------->-----------+ |\n            \\Crit/ Fulfilled                         | |\n             \\? /                                    v |\n              \\/                                     | |\n               \\  +-----------------+    +---------+ | |\n           Not +->| 5. Use Constr.  | -> | 6. Mix  | ----->\n        Fulfilled +-----------------+    +---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "---------------> enhanced residual",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4.2. Flow chart of the enhancer.",
      "ja": "図4.2。エンハンサーのフローチャート。"
    },
    {
      "indent": 3,
      "text": "1. Pitch estimation of each of the two/three new 80-sample blocks.",
      "ja": "1. 2 つまたは 3 つの新しい 80 サンプル ブロックのそれぞれのピッチ推定。"
    },
    {
      "indent": 3,
      "text": "2. Find the pitch-period-synchronous sequence n (for block k) by a search around the estimated pitch value. Do this for n=1,2,3, -1,-2,-3.",
      "ja": "2. 推定されたピッチ値の周囲を探索することによって、ピッチ周期同期シーケンス n (ブロック k の場合) を見つけます。これを n=1,2,3, -1,-2,-3 に対して行います。"
    },
    {
      "indent": 3,
      "text": "3. Calculate the smoothed residual generated by the six pitch-period-synchronous sequences from prior step.",
      "ja": "3. 前のステップからの 6 つのピッチ周期同期シーケンスによって生成された平滑化された残差を計算します。"
    },
    {
      "indent": 3,
      "text": "4. Check if the smoothed residual satisfies the criterion (section 4.6.4).",
      "ja": "4. 平滑化された残差が基準 (セクション 4.6.4) を満たしているかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "5. Use constraint to calculate mixing factor (section 4.6.5).",
      "ja": "5. 制約を使用して混合係数を計算します (セクション 4.6.5)。"
    },
    {
      "indent": 3,
      "text": "6. Mix smoothed signal with unenhanced residual (pssq(n) n=0).",
      "ja": "6. 平滑化された信号と強化されていない残差を混合します (pssq(n) n=0)。"
    },
    {
      "indent": 3,
      "text": "The main idea of the enhancer is to find three 80 sample blocks before and three 80-sample blocks after the analyzed unenhanced sub-block and to use these to improve the quality of the excitation in that sub-block. The six blocks are chosen so that they have the highest possible correlation with the unenhanced sub-block that is being enhanced. In other words, the six blocks are pitch-period-synchronous sequences to the unenhanced sub-block.",
      "ja": "エンハンサーの主なアイデアは、分析された非エンハンス サブブロックの前に 3 つの 80 サンプル ブロックとその後に 3 つの 80 サンプル ブロックを見つけ、これらを使用してそのサブブロックの励起の品質を向上させることです。6 つのブロックは、強化されている未強化のサブブロックとの相関が最も高くなるように選択されます。換言すれば、６つのブロックは、非強化サブブロックに対するピッチ周期同期シーケンスである。"
    },
    {
      "indent": 3,
      "text": "A linear combination of the six pitch-period-synchronous sequences is calculated that approximates the sub-block. If the squared error between the approximation and the unenhanced sub-block is small enough, the enhanced residual is set equal to this approximation. For the cases when the squared error criterion is not fulfilled, a linear combination of the approximation and the unenhanced residual forms the enhanced residual.",
      "ja": "サブブロックを近似する 6 つのピッチ周期同期シーケンスの線形結合が計算されます。近似値と非強化サブブロック間の二乗誤差が十分に小さい場合、強化された残差はこの近似値に等しく設定されます。二乗誤差基準が満たされない場合、近似と非強化残差の線形結合により強化残差が形成されます。"
    },
    {
      "indent": 0,
      "text": "4.6.1. Estimating the Pitch",
      "section_title": true,
      "ja": "4.6.1. ピッチの推定"
    },
    {
      "indent": 3,
      "text": "Pitch estimates are needed to determine the locations of the pitch-period-synchronous sequences in a complexity-efficient way. For each of the new two/three sub-blocks, a pitch estimate is calculated by finding the maximum correlation in the range from lag 20 to lag 120. These pitch estimates are used to narrow down the search for the best possible pitch-period-synchronous sequences.",
      "ja": "ピッチ推定は、複雑さを効率的に行う方法でピッチ周期同期シーケンスの位置を決定するために必要である。新しい 2 つまたは 3 つのサブブロックのそれぞれについて、ラグ 20 からラグ 120 までの範囲で最大の相関を見つけることによってピッチ推定値が計算されます。これらのピッチ推定値は、可能な限り最良のピッチ周期の検索を絞り込むために使用されます。同期シーケンス。"
    },
    {
      "indent": 0,
      "text": "4.6.2. Determination of the Pitch-Synchronous Sequences",
      "section_title": true,
      "ja": "4.6.2. ピッチ同期シーケンスの決定"
    },
    {
      "indent": 3,
      "text": "Upon receiving the pitch estimates from the prior step, the enhancer analyzes and enhances one 80-sample sub-block at a time. The pitch-period-synchronous-sequences pssq(n) can be viewed as vectors of length 80 samples each shifted n*lag samples from the current sub-block. The six pitch-period-synchronous-sequences, pssq(-3) to pssq(-1) and pssq(1) to pssq(3), are found one at a time by the steps below:",
      "ja": "前のステップからピッチ推定を受け取ると、エンハンサーは一度に 1 つの 80 サンプルのサブブロックを分析してエンハンスします。ピッチ周期同期シーケンス pssq(n) は、それぞれが現在のサブブロックから n*lag サンプルだけシフトされた長さ 80 サンプルのベクトルとして見ることができます。6 つのピッチ周期同期シーケンス pssq(-3) から pssq(-1) および pssq(1) から pssq(3) は、以下の手順で一度に 1 つずつ見つかります。"
    },
    {
      "indent": 3,
      "text": "1) Calculate the estimate of the position of the pssq(n). For pssq(n) in front of pssq(0) (n > 0), the location of the pssq(n) is estimated by moving one pitch estimate forward in time from the exact location of pssq(n-1). Similarly, pssq(n) behind pssq(0) (n < 0) is estimated by moving one pitch estimate backward in time from the exact location of pssq(n+1). If the estimated pssq(n) vector location is totally within the enhancer memory (Figure 4.3), steps 2, 3, and 4 are performed, otherwise the pssq(n) is set to zeros.",
      "ja": "1) pssq(n) の位置の推定値を計算します。pssq(0) の前にある pssq(n) (n > 0) の場合、pssq(n) の位置は、pssq(n-1) の正確な位置から時間的に 1 ピッチ推定値を前方に移動することによって推定されます。同様に、pssq(0) の後ろの pssq(n) (n < 0) は、pssq(n 1) の正確な位置から時間的に 1 ピッチ推定値を後方に移動することによって推定されます。推定された pssq(n) ベクトルの位置が完全にエンハンサー メモリ内にある場合 (図 4.3)、ステップ 2、3、および 4 が実行されます。それ以外の場合、pssq(n) は 0 に設定されます。"
    },
    {
      "indent": 3,
      "text": "2) Compute the correlation between the unenhanced excitation and vectors around the estimated location interval of pssq(n). The correlation is calculated in the interval estimated location +/- 2 samples. This results in five correlation values.",
      "ja": "2) 強化されていない励起と、pssq(n) の推定位置間隔の周囲のベクトルとの間の相関を計算します。相関は、推定位置 /- 2 サンプルの間隔で計算されます。これにより、5 つの相関値が得られます。"
    },
    {
      "indent": 3,
      "text": "3) The five correlation values are upsampled by a factor of 4, by using four simple upsampling filters (MA filters with coefficients upsFilter1.. upsFilter4). Within these the maximum value is found, which specifies the best pitch-period with a resolution of a quarter of a sample.",
      "ja": "3) 5 つの相関値は、4 つの単純なアップサンプリング フィルター (係数 upsFilter1.. upsFilter4 を持つ MA フィルター) を使用して、係数 4 でアップサンプリングされます。これらの中で最大値が見つかり、これはサンプルの 4 分の 1 の解像度で最適なピッチ周期を指定します。"
    },
    {
      "indent": 6,
      "text": "upsFilter1[7]={0.000000 0.000000 0.000000 1.000000\n       0.000000 0.000000 0.000000}\nupsFilter2[7]={0.015625 -0.076904 0.288330 0.862061\n      -0.106445 0.018799 -0.015625}\nupsFilter3[7]={0.023682 -0.124268 0.601563 0.601563\n      -0.124268 0.023682 -0.023682}\nupsFilter4[7]={0.018799 -0.106445 0.862061 0.288330\n      -0.076904 0.015625 -0.018799}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4) Generate the pssq(n) vector by upsampling of the excitation memory and extracting the sequence that corresponds to the lag delay that was calculated in prior step.",
      "ja": "4) 励起メモリをアップサンプリングし、前のステップで計算された遅れ遅延に対応するシーケンスを抽出することにより、pssq(n) ベクトルを生成します。"
    },
    {
      "indent": 3,
      "text": "With the steps above, all the pssq(n) can be found in an iterative manner, first moving backward in time from pssq(0) and then forward in time from pssq(0).",
      "ja": "上記の手順により、最初に pssq(0) から時間的に後方に移動し、次に pssq(0) から時間的に順方向に移動して、すべての pssq(n) を反復的に見つけることができます。"
    },
    {
      "indent": 3,
      "text": "0              159             319             479             639\n+---------------------------------------------------------------+\n|  -5   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |\n+---------------------------------------------------------------+\n                                            |pssq 0 |\n                                       |pssq -1| |pssq 1 |\n                                    |pssq -2|       |pssq 2 |\n                                 |pssq -3|             |pssq 3 |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4.3. Enhancement for 20 ms frame size.",
      "ja": "図4.3。20 ms フレーム サイズの拡張。"
    },
    {
      "indent": 3,
      "text": "Figure 4.3 depicts pitch-period-synchronous sequences in the enhancement of the first 80 sample block in the 20 ms frame size mode. The unenhanced signal input is stored in the last two sub-blocks (1 - 2), and the six other sub-blocks contain unenhanced residual prior-in-time. We perform the enhancement algorithm on two blocks of 80 samples, where the first of the two blocks consists of the last 40 samples of sub-block 0 and the first 40 samples of sub-block 1. The second 80-sample block consists of the last 40 samples of sub-block 1 and the first 40 samples of sub-block 2.",
      "ja": "図 4.3 は、20 ms フレーム サイズ モードでの最初の 80 サンプル ブロックのエンハンスメントにおけるピッチ周期同期シーケンスを示しています。強化されていない信号入力は最後の 2 つのサブブロック (1 ～ 2) に格納され、他の 6 つのサブブロックには強化されていない残差の時間前が含まれます。80 サンプルの 2 つのブロックに対して拡張アルゴリズムを実行します。2 つのブロックのうち最初のブロックは、サブブロック 0 の最後の 40 サンプルとサブブロック 1 の最初の 40 サンプルで構成されます。2 番目の 80 サンプル ブロックは、サブブロック 1 の最後の 40 サンプルとサブブロック 2 の最初の 40 サンプル。"
    },
    {
      "indent": 3,
      "text": "0              159             319             479             639\n+---------------------------------------------------------------+\n|  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |   3   |\n+---------------------------------------------------------------+\n                                |pssq 0 |\n                           |pssq -1| |pssq 1 |\n                        |pssq -2|       |pssq 2 |\n                     |pssq -3|             |pssq 3 |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Figure 4.4. Enhancement for 30 ms frame size.",
      "ja": "図4.4。30 ms フレーム サイズの拡張。"
    },
    {
      "indent": 3,
      "text": "Figure 4.4 depicts pitch-period-synchronous sequences in the enhancement of the first 80-sample block in the 30 ms frame size mode. The unenhanced signal input is stored in the last three sub-blocks (1 - 3). The five other sub-blocks contain unenhanced residual prior-in-time. The enhancement algorithm is performed on the three 80 sample sub-blocks 0, 1, and 2.",
      "ja": "図 4.4 は、30 ms フレーム サイズ モードでの最初の 80 サンプル ブロックのエンハンスメントにおけるピッチ周期同期シーケンスを示しています。強化されていない信号入力は、最後の 3 つのサブブロック (1 ～ 3) に保存されます。他の 5 つのサブブロックには、拡張されていない残差事前時間情報が含まれています。エンハンスメント アルゴリズムは、3 つの 80 サンプル サブブロック 0、1、2 に対して実行されます。"
    },
    {
      "indent": 0,
      "text": "4.6.3. Calculation of the Smoothed Excitation",
      "section_title": true,
      "ja": "4.6.3. 平滑化励振の計算"
    },
    {
      "indent": 3,
      "text": "A linear combination of the six pssq(n) (n!=0) form a smoothed approximation, z, of pssq(0). Most of the weight is put on the sequences that are close to pssq(0), as these are likely to be most similar to pssq(0). The smoothed vector is also rescaled so that the energy of z is the same as the energy of pssq(0).",
      "ja": "6 つの pssq(n) (n!=0) の線形結合により、pssq(0) の平滑化された近似 z が形成されます。pssq(0) に最も似ている可能性が高いため、pssq(0) に近いシーケンスに重みの大部分が置かれます。平滑化されたベクトルも、z のエネルギーが pssq(0) のエネルギーと同じになるように再スケーリングされます。"
    },
    {
      "indent": 3,
      "text": "   ___\n   \\\ny = > pssq(i) * pssq_weight(i)\n   /__\ni=-3,-2,-1,1,2,3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "pssq_weight(i) = 0.5*(1-cos(2*pi*(i+4)/(2*3+2)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "z = C * y, where C = ||pssq(0)||/||y||",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.4. Enhancer Criterion",
      "section_title": true,
      "ja": "4.6.4. エンハンサー基準"
    },
    {
      "indent": 3,
      "text": "The criterion of the enhancer is that the enhanced excitation is not allowed to differ much from the unenhanced excitation. This criterion is checked for each 80-sample sub-block.",
      "ja": "エンハンサーの基準は、強化された励起が強化されていない励起と大きく異なることが許容されないことです。この基準は、80 サンプルのサブブロックごとにチェックされます。"
    },
    {
      "indent": 3,
      "text": "e < (b * ||pssq(0)||^2), where b=0.05 and   (Constraint 1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "e = (pssq(0)-z)*(pssq(0)-z), and \"*\" means the dot product",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.5. Enhancing the excitation",
      "section_title": true,
      "ja": "4.6.5. 興奮を高める"
    },
    {
      "indent": 3,
      "text": "From the criterion in the previous section, it is clear that the excitation is not allowed to change much. The purpose of this constraint is to prevent the creation of an enhanced signal significantly different from the original signal. This also means that the constraint limits the numerical size of the errors that the enhancement procedure can make. That is especially important in unvoiced segments and background noise segments for which increased periodicity could lead to lower perceived quality.",
      "ja": "前のセクションの基準から、励起はあまり変更できないことが明らかです。この制約の目的は、元の信号とは大きく異なる強化された信号の作成を防ぐことです。これは、制約によって、拡張手順で発生する可能性のあるエラーの数値サイズが制限されることも意味します。これは、周期性の増加が知覚品質の低下につながる可能性がある無声セグメントや背景雑音セグメントでは特に重要です。"
    },
    {
      "indent": 3,
      "text": "When the constraint in the prior section is not met, the enhanced residual is instead calculated through a constrained optimization by using the Lagrange multiplier technique. The new constraint is that",
      "ja": "前のセクションの制約が満たされない場合、強化された残差は代わりに、ラグランジュ乗算手法を使用した制約付き最適化を通じて計算されます。新しい制約は、"
    },
    {
      "indent": 6,
      "text": "e = (b * ||pssq(0)||^2)                     (Constraint 2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "We distinguish two solution regions for the optimization: 1) the region where the first constraint is fulfilled and 2) the region where the first constraint is not fulfilled and the second constraint must be used.",
      "ja": "最適化のために 2 つのソリューション領域を区別します。1) 最初の制約が満たされる領域、2) 最初の制約が満たされず 2 番目の制約が使用されなければならない領域です。"
    },
    {
      "indent": 3,
      "text": "In the first case, where the second constraint is not needed, the optimized re-estimated vector is simply z, the energy-scaled version of y.",
      "ja": "2 番目の制約が必要ない最初のケースでは、最適化された再推定ベクトルは単に z (y のエネルギースケール版) になります。"
    },
    {
      "indent": 3,
      "text": "In the second case, where the second constraint is activated and becomes an equality constraint, we have",
      "ja": "2 番目のケースでは、2 番目の制約がアクティブ化され、等価制約になります。"
    },
    {
      "indent": 6,
      "text": "z= A*y + B*pssq(0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "ただし"
    },
    {
      "indent": 6,
      "text": "A = sqrt((b-b^2/4)*(w00*w00)/ (w11*w00 + w10*w10)) and",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "w11 = pssq(0)*pssq(0)\nw00 = y*y\nw10 = y*pssq(0)    (* symbolizes the dot product)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "and",
      "ja": "そしてと及びアンド並びに且つ兼又共それですると亦だからそれからはたまた"
    },
    {
      "indent": 6,
      "text": "B = 1 - b/2 - A * w10/w00",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Appendix A.16 contains a listing of a reference implementation for the enhancement method.",
      "ja": "付録 A.16 には、拡張メソッドの参照実装のリストが含まれています。"
    },
    {
      "indent": 0,
      "text": "4.7. Synthesis Filtering",
      "section_title": true,
      "ja": "4.7. 合成フィルタリング"
    },
    {
      "indent": 3,
      "text": "Upon decoding or PLC of the LP excitation block, the decoded speech block is obtained by running the decoded LP synthesis filter, 1/A~k(z), over the block. The synthesis filters have to be shifted to compensate for the delay in the enhancer. For 20 ms frame size mode, they SHOULD be shifted one 40-sample sub-block, and for 30 ms frame size mode, they SHOULD be shifted two 40-sample sub-blocks. The LP coefficients SHOULD be changed at the first sample of every sub-block while keeping the filter state. For PLC blocks, one solution is to apply the last LP coefficients of the last decoded speech block for all sub-blocks.",
      "ja": "LP 励起ブロックの復号化または PLC の際、復号化された音声ブロックは、ブロックに対して復号化された LP 合成フィルター 1/A~k(z) を実行することによって取得されます。エンハンサーの遅延を補償するには、合成フィルターをシフトする必要があります。20 ms フレーム サイズ モードの場合は 40 サンプル サブブロック 1 つシフトする必要があり、30 ms フレーム サイズ モードの場合は 40 サンプル サブブロック 2 つシフトする必要があります。LP 係数は、フィルタの状態を維持しながら、すべてのサブブロックの最初のサンプルで変更されるべきです (SHOULD)。PLC ブロックの場合、解決策の 1 つは、最後に復号された音声ブロックの最後の LP 係数をすべてのサブブロックに適用することです。"
    },
    {
      "indent": 3,
      "text": "The reference implementation for the synthesis filtering can be found in Appendix A.48.",
      "ja": "合成フィルタリングのリファレンス実装は、付録 A.48 にあります。"
    },
    {
      "indent": 0,
      "text": "4.8. Post Filtering",
      "section_title": true,
      "ja": "4.8. ポストフィルタリング"
    },
    {
      "indent": 3,
      "text": "If desired, the decoded block can be filtered by a high-pass filter. This removes the low frequencies of the decoded signal. A reference implementation of this, with cutoff at 65 Hz, is shown in Appendix A.30.",
      "ja": "必要に応じて、デコードされたブロックをハイパス フィルターでフィルター処理できます。これにより、デコードされた信号の低周波数が除去されます。65 Hz でカットオフするこのリファレンス実装を付録 A.30 に示します。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This algorithm for the coding of speech signals is not subject to any known security consideration; however, its RTP payload format [1] is subject to several considerations, which are addressed there. Confidentiality of the media streams is achieved by encryption; therefore external mechanisms, such as SRTP [5], MAY be used for that purpose.",
      "ja": "音声信号を符号化するためのこのアルゴリズムは、既知のセキュリティに関する考慮事項の対象にはなりません。ただし、その RTP ペイロード形式 [1] にはいくつかの考慮事項があり、そこで説明されています。メディア ストリームの機密性は暗号化によって実現されます。したがって、SRTP [5] などの外部メカニズムをその目的に使用してもよい(MAY)。"
    },
    {
      "indent": 0,
      "text": "6. Evaluation of the iLBC Implementations",
      "section_title": true,
      "ja": "6. iLBC 実装の評価"
    },
    {
      "indent": 3,
      "text": "It is possible and suggested to evaluate certain iLBC implementation by utilizing methodology and tools available at http://www.ilbcfreeware.org/evaluation.html",
      "ja": "http://www.ilbcfreeware.org/evaluation.html で入手可能な方法論とツールを利用して、特定の iLBC 実装を評価することが可能であり、推奨されています。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[1] Duric, A. and S. Andersen, \"Real-time Transport Protocol (RTP) Payload Format for internet Low Bit Rate Codec (iLBC) Speech\", RFC 3952, December 2004.",
      "ja": "[1] Duric, A. および S. Andersen、「インターネット低ビット レート コーデック (iLBC) 音声用のリアルタイム トランスポート プロトコル (RTP) ペイロード フォーマット」、RFC 3952、2004 年 12 月。"
    },
    {
      "indent": 3,
      "text": "[2] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[2] Bradner, S.、「要件レベルを示すために RFC で使用するキーワード」、BCP 14、RFC 2119、1997 年 3 月。"
    },
    {
      "indent": 3,
      "text": "[3] PacketCable(TM) Audio/Video Codecs Specification, Cable Television Laboratories, Inc.",
      "ja": "[3] PacketCable(TM) オーディオ/ビデオ コーデック仕様、Cable Television Laboratories, Inc."
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[4] ITU-T Recommendation G.711, available online from the ITU bookstore at http://www.itu.int.",
      "ja": "[4] ITU-T 勧告 G.711。ITU ブックストア http://www.itu.int からオンラインで入手できます。"
    },
    {
      "indent": 3,
      "text": "[5] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norman, \"The Secure Real Time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[5] Baugher, M.、McGrew, D.、Naslund, M.、Carrara, E.、および K. Norman、「セキュア リアルタイム トランスポート プロトコル (SRTP)」、RFC 3711、2004 年 3 月。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgements",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "This extensive work, besides listed authors, has the following authors, who could not have been listed among \"official\" authors (due to IESG restrictions in the number of authors who can be listed):",
      "ja": "この広範な著作には、リストされている著者以外に、(IESG によるリスト可能な著者数の制限のため) 「公式」著者としてリストされることができなかった以下の著者が含まれています。"
    },
    {
      "indent": 6,
      "text": "Manohar N. Murthi (Department of Electrical and Computer Engineering, University of Miami), Fredrik Galschiodt, Julian Spittka, and Jan Skoglund (Global IP Sound).",
      "ja": "Manohar N. Murthi (マイアミ大学電気・コンピュータ工学科)、Fredrik Galschiodt、Julian Spittka、Jan Skoglund (Global IP Sound)。"
    },
    {
      "indent": 3,
      "text": "The authors are deeply indebted to the following people and thank them sincerely:",
      "ja": "著者らは以下の方々に深く感謝し、心から感謝いたします。"
    },
    {
      "indent": 6,
      "text": "Henry Sinnreich, Patrik Faltstrom, Alan Johnston, and Jean-Francois Mule for great support of the iLBC initiative and for valuable feedback and comments.",
      "ja": "Henry Sinnreich、Patrik Faltstrom、Alan Johnston、Jean-Francois Mule の皆様には、iLBC イニシアチブへの多大なご支援と、貴重なフィードバックとコメントをいただきました。"
    },
    {
      "indent": 6,
      "text": "Peter Vary, Frank Mertz, and Christoph Erdmann (RWTH Aachen); Vladimir Cuperman (Niftybox LLC); Thomas Eriksson (Chalmers Univ of Tech), and Gernot Kubin (TU Graz), for thorough review of the iLBC document and their valuable feedback and remarks.",
      "ja": "Peter Vary、Frank Mertz、Christoph Erdmann (アーヘン工科大学)。ウラジミール・クペルマン (Niftybox LLC);Thomas Eriksson (Chalmers 工科大学) と Gernot Kubin (グラーツ工科大学) には、iLBC 文書を徹底的にレビューしていただき、貴重なフィードバックとコメントをいただきました。"
    },
    {
      "indent": 0,
      "text": "APPENDIX A. Reference Implementation",
      "ja": "付録 A. リファレンス実装"
    },
    {
      "indent": 3,
      "text": "This appendix contains the complete c-code for a reference implementation of encoder and decoder for the specified codec.",
      "ja": "この付録には、指定されたコーデックのエンコーダおよびデコーダのリファレンス実装の完全な C コードが含まれています。"
    },
    {
      "indent": 3,
      "text": "The c-code consists of the following files with highest-level functions:",
      "ja": "C コードは、最高レベルの関数を含む次のファイルで構成されます。"
    },
    {
      "indent": 9,
      "text": "iLBC_test.c: main function for evaluation purpose iLBC_encode.h: encoder header iLBC_encode.c: encoder function iLBC_decode.h: decoder header iLBC_decode.c: decoder function",
      "ja": "iLBC_test.c: 評価用メイン関数 iLBC_encode.h: エンコーダヘッダ iLBC_encode.c: エンコーダ関数 iLBC_decode.h: デコーダヘッダ iLBC_decode.c: デコーダ関数"
    },
    {
      "indent": 3,
      "text": "The following files contain global defines and constants:",
      "ja": "次のファイルには、グローバル定義と定数が含まれています。"
    },
    {
      "indent": 9,
      "text": "iLBC_define.h: global defines constants.h: global constants header constants.c: global constants memory allocations",
      "ja": "iLBC_define.h: グローバル定義 constants.h: グローバル定数ヘッダー constants.c: グローバル定数のメモリ割り当て"
    },
    {
      "indent": 3,
      "text": "The following files contain subroutines:",
      "ja": "次のファイルにはサブルーチンが含まれています。"
    },
    {
      "indent": 9,
      "text": "anaFilter.h: lpc analysis filter header anaFilter.c: lpc analysis filter function createCB.h: codebook construction header createCB.c: codebook construction function doCPLC.h: packet loss concealment header doCPLC.c: packet loss concealment function enhancer.h: signal enhancement header enhancer.c: signal enhancement function filter.h: general filter header filter.c: general filter functions FrameClassify.h: start state classification header FrameClassify.c: start state classification function gainquant.h: gain quantization header gainquant.c: gain quantization function getCBvec.h: codebook vector construction header getCBvec.c: codebook vector construction function helpfun.h: general purpose header helpfun.c: general purpose functions hpInput.h: input high pass filter header hpInput.c: input high pass filter function hpOutput.h: output high pass filter header hpOutput.c: output high pass filter function iCBConstruct.h: excitation decoding header iCBConstruct.c: excitation decoding function iCBSearch.h: excitation encoding header iCBSearch.c: excitation encoding function LPCdecode.h: lpc decoding header LPCdecode.c: lpc decoding function LPCencode.h: lpc encoding header LPCencode.c: lpc encoding function lsf.h: line spectral frequencies header lsf.c: line spectral frequencies functions packing.h: bitstream packetization header packing.c: bitstream packetization functions StateConstructW.h: state decoding header StateConstructW.c: state decoding functions StateSearchW.h: state encoding header StateSearchW.c: state encoding function syntFilter.h: lpc synthesis filter header syntFilter.c: lpc synthesis filter function",
      "ja": "anaFilter.h: lpc 分析フィルターヘッダー anaFilter.c: lpc 分析フィルター関数 createCB.h: コードブック構築ヘッダー createCB.c: コードブック構築関数 doCPLC.h: パケット損失隠蔽ヘッダー doCPLC.c: パケット損失隠蔽関数Enhancer.h:信号強調ヘッダー extender.c: 信号強調関数 filter.h: 一般的なフィルター ヘッダー filter.c: 一般的なフィルター関数 FrameClassify.h: 開始状態分類ヘッダー FrameClassify.c: 開始状態分類関数 Gainquant.h: ゲイン量子化ヘッダー Gainquant.c: ゲイン量子化関数 getCBvec.h: コードブック ベクトル構築ヘッダ getCBvec.c: コードブック ベクトル構築関数 helpfun.h: 汎用ヘッダ helpfun.c: 汎用関数 hpInput.h: 入力ハイパス フィルタ ヘッダ hpInput.c: 入力ハイパスフィルタ関数 hpOutput.h: 出力ハイパス フィルタ ヘッダ hpOutput.c: 出力ハイパス フィルタ関数 iCBConstruct.h: 励振デコード ヘッダ iCBConstruct.c: 励振デコード関数 iCBSearch.h: 励振エンコード ヘッダ iCBSearch.c: 励振エンコード関数 LPCdecode。h: lpc デコード ヘッダー LPCdecode.c: lpc デコード関数 LPCencode.h: lpc エンコード ヘッダー LPCencode.c: lpc エンコード関数 lsf.h: 線スペクトル周波数ヘッダー lsf.c: 線スペクトル周波数関数Packing.h: ビットストリーム パケット化ヘッダー パッキング.c: ビットストリーム パケット化関数 StateConstructW.h: 状態デコード ヘッダー StateConstructW.c: 状態デコード関数 StateSearchW.h: 状態エンコード ヘッダー StateSearchW.c: 状態エンコード関数 syntFilter.h: lpc 合成フィルター ヘッダー syntFilter.c: lpc 合成フィルター関数"
    },
    {
      "indent": 3,
      "text": "The implementation is portable and should work on many different platforms. However, it is not difficult to optimize the implementation on particular platforms, an exercise left to the reader.",
      "ja": "この実装は移植可能であり、さまざまなプラットフォームで動作するはずです。ただし、特定のプラットフォームでの実装を最適化することは難しくありません。これは読者に任せてください。"
    },
    {
      "indent": 0,
      "text": "A.1. iLBC_test.c",
      "section_title": true,
      "ja": "A.1. iLBC_test.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_test.c",
      "ja": "iLBC_test.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include \"iLBC_define.h\"\n#include \"iLBC_encode.h\"\n#include \"iLBC_decode.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Runtime statistics */\n#include <time.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define ILBCNOOFWORDS_MAX (NO_OF_BYTES_30MS/2)",
      "ja": "#define ILBCNOOFWORDS_MAX (NO_OF_BYTES_30MS/2)"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Encoder interface function",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "*---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "short encode(   /* (o) Number of bytes encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                                /* (i/o) Encoder instance */\n    short *encoded_data,    /* (o) The encoded bytes */\n    short *data                 /* (i) The signal block to encode*/\n){\n    float block[BLOCKL_MAX];\n    int k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* convert signal to float */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (k=0; k<iLBCenc_inst->blockl; k++)\n    block[k] = (float)data[k];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* do the actual encoding */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC_encode((unsigned char *)encoded_data, block, iLBCenc_inst);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return (iLBCenc_inst->no_of_bytes); }",
      "ja": "return (iLBCenc_inst->no_of_bytes);}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Decoder interface function\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "short decode(       /* (o) Number of decoded samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    short *decoded_data,        /* (o) Decoded signal block*/\n    short *encoded_data,        /* (i) Encoded bytes */\n    short mode                       /* (i) 0=PL, 1=Normal */\n){\n    int k;\n    float decblock[BLOCKL_MAX], dtmp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* check if mode is valid */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mode<0 || mode>1) {\n    printf(\"\\nERROR - Wrong mode - 0, 1 allowed\\n\"); exit(3);}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* do actual decoding of block */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC_decode(decblock, (unsigned char *)encoded_data, iLBCdec_inst, mode);",
      "ja": "iLBC_decode(decblock, (unsigned char *)encoded_data, iLBCdec_inst, mode);"
    },
    {
      "indent": 7,
      "text": "/* convert to short */\n       for (k=0; k<iLBCdec_inst->blockl; k++){\n    dtmp=decblock[k];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (dtmp<MIN_SAMPLE)\n        dtmp=MIN_SAMPLE;\n    else if (dtmp>MAX_SAMPLE)\n        dtmp=MAX_SAMPLE;\n    decoded_data[k] = (short) dtmp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return (iLBCdec_inst->blockl); }",
      "ja": "return (iLBCdec_inst->blockl);}"
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  Main program to test iLBC encoding and decoding\n *\n *  Usage:\n *    exefile_name.exe <infile> <bytefile> <outfile> <channel>\n *\n *    <infile>   : Input file, speech for encoder (16-bit pcm file)\n *    <bytefile> : Bit stream output from the encoder\n *    <outfile>  : Output file, decoded speech (16-bit pcm file)\n *    <channel>  : Bit error file, optional (16-bit)\n *                     1 - Packet received correctly\n *                     0 - Packet Lost\n *\n *--------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int main(int argc, char* argv[]) {",
      "ja": "int main(int argc, char* argv[]) {"
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "float starttime;\nfloat runtime;\nfloat outtime;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "FILE *ifileid,*efileid,*ofileid, *cfileid;\nshort data[BLOCKL_MAX];\nshort encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];\nint len;\nshort pli, mode;\nint blockcount = 0;\nint packetlosscount = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Create structs */\niLBC_Enc_Inst_t Enc_Inst;\niLBC_Dec_Inst_t Dec_Inst;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* get arguments and open files */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ((argc!=5) && (argc!=6)) {\n    fprintf(stderr,\n    \"\\n*-----------------------------------------------*\\n\");\n    fprintf(stderr,\n    \"   %s <20,30> input encoded decoded (channel)\\n\\n\",\n        argv[0]);\n    fprintf(stderr,\n    \"   mode    : Frame size for the encoding/decoding\\n\");\n    fprintf(stderr,\n    \"                 20 - 20 ms\\n\");\n    fprintf(stderr,\n    \"                 30 - 30 ms\\n\");\n    fprintf(stderr,\n    \"   input   : Speech for encoder (16-bit pcm file)\\n\");\n    fprintf(stderr,\n    \"   encoded : Encoded bit stream\\n\");\n    fprintf(stderr,\n    \"   decoded : Decoded speech (16-bit pcm file)\\n\");\n    fprintf(stderr,\n    \"   channel : Packet loss pattern, optional (16-bit)\\n\");\n    fprintf(stderr,\n    \"                  1 - Packet received correctly\\n\");\n    fprintf(stderr,\n    \"                  0 - Packet Lost\\n\");\n    fprintf(stderr,\n    \"*-----------------------------------------------*\\n\\n\");\n    exit(1);\n}\nmode=atoi(argv[1]);\nif (mode != 20 && mode != 30) {\n    fprintf(stderr,\"Wrong mode %s, must be 20, or 30\\n\",\n        argv[1]);\n    exit(2);\n}\nif ( (ifileid=fopen(argv[2],\"rb\")) == NULL) {\n    fprintf(stderr,\"Cannot open input file %s\\n\", argv[2]);\n    exit(2);}\nif ( (efileid=fopen(argv[3],\"wb\")) == NULL) {\n    fprintf(stderr, \"Cannot open encoded file %s\\n\",\n        argv[3]); exit(1);}\nif ( (ofileid=fopen(argv[4],\"wb\")) == NULL) {\n    fprintf(stderr, \"Cannot open decoded file %s\\n\",\n        argv[4]); exit(1);}\nif (argc==6) {\n    if( (cfileid=fopen(argv[5],\"rb\")) == NULL) {\n        fprintf(stderr, \"Cannot open channel file %s\\n\",",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            argv[5]);\n        exit(1);\n    }\n} else {\n    cfileid=NULL;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* print info */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "fprintf(stderr, \"\\n\");\nfprintf(stderr,\n    \"*---------------------------------------------------*\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*      iLBC test program                            *\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*                                                   *\\n\");\nfprintf(stderr,\n    \"*---------------------------------------------------*\\n\");\nfprintf(stderr,\"\\nMode           : %2d ms\\n\", mode);\nfprintf(stderr,\"Input file     : %s\\n\", argv[2]);\nfprintf(stderr,\"Encoded file   : %s\\n\", argv[3]);\nfprintf(stderr,\"Output file    : %s\\n\", argv[4]);\nif (argc==6) {\n    fprintf(stderr,\"Channel file   : %s\\n\", argv[5]);\n}\nfprintf(stderr,\"\\n\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Initialization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "initEncode(&Enc_Inst, mode);\ninitDecode(&Dec_Inst, mode, 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "starttime=clock()/(float)CLOCKS_PER_SEC;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* loop over input blocks */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==\n        Enc_Inst.blockl) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "blockcount++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* encoding */\n           fprintf(stderr, \"--- Encoding block %i --- \",blockcount);\nlen=encode(&Enc_Inst, encoded_data, data);\nfprintf(stderr, \"\\r\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* write byte file */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "fwrite(encoded_data, sizeof(unsigned char), len, efileid);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* get channel data if provided */\nif (argc==6) {\n    if (fread(&pli, sizeof(short), 1, cfileid)) {\n        if ((pli!=0)&&(pli!=1)) {\n            fprintf(stderr, \"Error in channel file\\n\");\n            exit(0);\n        }\n        if (pli==0) {\n            /* Packet loss -> remove info from frame */\n            memset(encoded_data, 0,\n                sizeof(short)*ILBCNOOFWORDS_MAX);\n            packetlosscount++;\n        }\n    } else {\n        fprintf(stderr, \"Error. Channel file too short\\n\");\n        exit(0);\n    }\n} else {\n    pli=1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* decoding */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "fprintf(stderr, \"--- Decoding block %i --- \",blockcount);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "len=decode(&Dec_Inst, decoded_data, encoded_data, pli);\nfprintf(stderr, \"\\r\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* write output file */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    fwrite(decoded_data,sizeof(short),len,ofileid);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Runtime statistics */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);\nouttime = (float)((float)blockcount*(float)mode/1000.0);\nprintf(\"\\n\\nLength of speech file: %.1f s\\n\", outtime);\nprintf(\"Packet loss          : %.1f%%\\n\",\n    100.0*(float)packetlosscount/(float)blockcount);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "printf(\"Time to run iLBC     :\");\nprintf(\" %.1f s (%.1f %% of realtime)\\n\\n\", runtime,\n    (100*runtime/outtime));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* close files */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    fclose(ifileid);  fclose(efileid); fclose(ofileid);\n    if (argc==6) {\n        fclose(cfileid);\n    }\n    return(0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.2. iLBC_encode.h",
      "section_title": true,
      "ja": "A.2. iLBC_エンコード.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_encode.h",
      "ja": "iLBC_エンコード.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCENCODE_H #define __iLBC_ILBCENCODE_H",
      "ja": "#ifndef __iLBC_ILBCENCODE_H #define __iLBC_ILBCENCODE_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "short initEncode(                   /* (o) Number of bytes\n                                           encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */\n    int mode                    /* (i) frame size mode */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iLBC_encode(",
      "ja": "void iLBC_encode("
    },
    {
      "indent": 3,
      "text": "    unsigned char *bytes,           /* (o) encoded data bits iLBC */\n    float *block,                   /* (o) speech vector to\n                                           encode */\n    iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder\n                                           state */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.3. iLBC_encode.c",
      "section_title": true,
      "ja": "A.3. iLBC_エンコード.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_encode.c",
      "ja": "iLBC_エンコード.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <stdlib.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"LPCencode.h\" #include \"FrameClassify.h\" #include \"StateSearchW.h\" #include \"StateConstructW.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"iCBSearch.h\" #include \"iCBConstruct.h\" #include \"hpInput.h\" #include \"anaFilter.h\" #include \"syntFilter.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"LPCencode.h\" #include \"FrameClassify.h\" #include \"StateSearchW.h\" #include \"StateConstructW.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"iCBSearch.h\" #include \"iCBConstruct.h\" #include \"hpInput.h\" #include \"anaFilter.h\" #include \"syntFilter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Initiation of encoder instance.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "short initEncode(                   /* (o) Number of bytes\n                                           encoded */\n    iLBC_Enc_Inst_t *iLBCenc_inst,  /* (i/o) Encoder instance */\n    int mode                    /* (i) frame size mode */\n){\n    iLBCenc_inst->mode = mode;\n    if (mode==30) {\n        iLBCenc_inst->blockl = BLOCKL_30MS;\n        iLBCenc_inst->nsub = NSUB_30MS;\n        iLBCenc_inst->nasub = NASUB_30MS;\n        iLBCenc_inst->lpc_n = LPC_N_30MS;\n        iLBCenc_inst->no_of_bytes = NO_OF_BYTES_30MS;\n        iLBCenc_inst->no_of_words = NO_OF_WORDS_30MS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    iLBCenc_inst->state_short_len=STATE_SHORT_LEN_30MS;\n    /* ULP init */\n    iLBCenc_inst->ULP_inst=&ULP_30msTbl;\n}\nelse if (mode==20) {\n    iLBCenc_inst->blockl = BLOCKL_20MS;\n    iLBCenc_inst->nsub = NSUB_20MS;\n    iLBCenc_inst->nasub = NASUB_20MS;\n    iLBCenc_inst->lpc_n = LPC_N_20MS;\n    iLBCenc_inst->no_of_bytes = NO_OF_BYTES_20MS;\n    iLBCenc_inst->no_of_words = NO_OF_WORDS_20MS;\n    iLBCenc_inst->state_short_len=STATE_SHORT_LEN_20MS;\n    /* ULP init */\n    iLBCenc_inst->ULP_inst=&ULP_20msTbl;\n}\nelse {\n    exit(2);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset((*iLBCenc_inst).anaMem, 0,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCenc_inst).lsfold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCenc_inst).lsfdeqold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));\nmemset((*iLBCenc_inst).lpc_buffer, 0,\n    (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));\nmemset((*iLBCenc_inst).hpimem, 0, 4*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return (iLBCenc_inst->no_of_bytes); }",
      "ja": "return (iLBCenc_inst->no_of_bytes);}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  main encoder function\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iLBC_encode(\n    unsigned char *bytes,           /* (o) encoded data bits iLBC */\n    float *block,                   /* (o) speech vector to\n                                           encode */\n    iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the general encoder\n                                           state */\n){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "float data[BLOCKL_MAX]; float residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];",
      "ja": "浮動小数点データ[BLOCKL_MAX];float 残差[BLOCKL_MAX]、reverseResidual[BLOCKL_MAX];"
    },
    {
      "indent": 7,
      "text": "int start, idxForMax, idxVec[STATE_LEN];",
      "ja": "int start、idxForMax、idxVec[STATE_LEN];"
    },
    {
      "indent": 7,
      "text": "float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\nint n, k, meml_gotten, Nfor, Nback, i, pos;\nint gain_index[CB_NSTAGES*NASUB_MAX],\n    extra_gain_index[CB_NSTAGES];\nint cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];\nint lsf_i[LSF_NSPLIT*LPC_N_MAX];\nunsigned char *pbytes;\nint diff, start_pos, state_first;\nfloat en1, en2;\nint index, ulp, firstpart;\nint subcount, subframe;\nfloat weightState[LPC_FILTERORDER];\nfloat syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\nfloat weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\nfloat decresidual[BLOCKL_MAX];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* high pass filtering of input signal if such is not done\n       prior to calling this function */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "hpInput(block, iLBCenc_inst->blockl,\n            data, (*iLBCenc_inst).hpimem);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* otherwise simply copy */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/*memcpy(data,block,iLBCenc_inst->blockl*sizeof(float));*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* LPC of hp filtered input data */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "LPCencode(syntdenum, weightdenum, lsf_i, data, iLBCenc_inst);",
      "ja": "LPCencode(syntdenum、weightdenum、lsf_i、データ、iLBCenc_inst);"
    },
    {
      "indent": 7,
      "text": "/* inverse filter to get residual */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (n=0; n<iLBCenc_inst->nsub; n++) {\n    anaFilter(&data[n*SUBL], &syntdenum[n*(LPC_FILTERORDER+1)],\n        SUBL, &residual[n*SUBL], iLBCenc_inst->anaMem);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* find state location */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "start = FrameClassify(iLBCenc_inst, residual);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* check if state should be in first or last part of the\ntwo subframes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "diff = STATE_LEN - iLBCenc_inst->state_short_len;\nen1 = 0;\nindex = (start-1)*SUBL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = 0; i < iLBCenc_inst->state_short_len; i++) {\n    en1 += residual[index+i]*residual[index+i];\n}\nen2 = 0;\nindex = (start-1)*SUBL+diff;\nfor (i = 0; i < iLBCenc_inst->state_short_len; i++) {\n    en2 += residual[index+i]*residual[index+i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (en1 > en2) {\n    state_first = 1;\n    start_pos = (start-1)*SUBL;\n} else {\n    state_first = 0;\n    start_pos = (start-1)*SUBL + diff;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* scalar quantization of state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "StateSearchW(iLBCenc_inst, &residual[start_pos],\n    &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n    &weightdenum[(start-1)*(LPC_FILTERORDER+1)], &idxForMax,\n    idxVec, iLBCenc_inst->state_short_len, state_first);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "StateConstructW(idxForMax, idxVec,\n    &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n    &decresidual[start_pos], iLBCenc_inst->state_short_len);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* predictive quantization in state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (state_first) { /* put adaptive part in the end */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memset(mem, 0,\n    (CB_MEML-iLBCenc_inst->state_short_len)*sizeof(float));\nmemcpy(mem+CB_MEML-iLBCenc_inst->state_short_len,\n    decresidual+start_pos,\n    iLBCenc_inst->state_short_len*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* encode sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, &residual[start_pos+iLBCenc_inst->state_short_len], mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES,",
      "ja": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, &residual[start_pos iLBCenc_inst->state_short_len], mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES,"
    },
    {
      "indent": 15,
      "text": "&weightdenum[start*(LPC_FILTERORDER+1)], weightState, 0);",
      "ja": "&weightdenum[start*(LPC_FILTERORDER 1)],weightState, 0);"
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBConstruct( &decresidual[start_pos+iLBCenc_inst->state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct( &decresidual[start_pos iLBCenc_inst->state_short_len], extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);"
    },
    {
      "indent": 7,
      "text": "}\nelse { /* put adaptive part in the beginning */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* create reversed vectors for prediction */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) {\n    reverseResidual[k] = residual[(start+1)*SUBL-1\n        -(k+iLBCenc_inst->state_short_len)];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "meml_gotten = iLBCenc_inst->state_short_len;\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[start_pos + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* encode sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES, &weightdenum[(start-1)*(LPC_FILTERORDER+1)], weightState, 0);",
      "ja": "iCBSearch(iLBCenc_inst, extra_cb_index, extra_gain_index, reverseResidual, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES, &weightdenum[(start-1)*(LPC_FILTERORDER 1)],weightState, 0);"
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) {\n    decresidual[start_pos-1-k] = reverseDecresidual[k];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* counter for predicted sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "subcount=0;",
      "ja": "サブカウント=0;"
    },
    {
      "indent": 7,
      "text": "/* forward prediction of sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Nfor = iLBCenc_inst->nsub-start-1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ( Nfor > 0 ) {",
      "ja": "if ( Nfor > 0 ) {"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));\nmemcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,\n    STATE_LEN*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nfor; subframe++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* encode sub-frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,\n    gain_index+subcount*CB_NSTAGES,\n    &residual[(start+1+subframe)*SUBL],\n    mem+CB_MEML-memLfTbl[subcount],\n    memLfTbl[subcount], SUBL, CB_NSTAGES,\n    &weightdenum[(start+1+subframe)*\n                (LPC_FILTERORDER+1)],\n    weightState, subcount+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&decresidual[(start+1+subframe)*SUBL],\n    cb_index+subcount*CB_NSTAGES,\n    gain_index+subcount*CB_NSTAGES,\n    mem+CB_MEML-memLfTbl[subcount],\n    memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,",
      "ja": "memcpy(mem, mem SUBL, (CB_MEML-SUBL)*sizeof(float));memcpy(mem CB_MEML-SUBL,"
    },
    {
      "indent": 15,
      "text": "    &decresidual[(start+1+subframe)*SUBL],\n    SUBL*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        subcount++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* backward prediction of sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Nback = start-1;",
      "ja": "Nback = 開始-1;"
    },
    {
      "indent": 7,
      "text": "if ( Nback > 0 ) {",
      "ja": "if ( Nback > 0 ) {"
    },
    {
      "indent": 11,
      "text": "/* create reverse order vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (n=0; n<Nback; n++) {\n    for (k=0; k<SUBL; k++) {\n        reverseResidual[n*SUBL+k] =\n            residual[(start-1)*SUBL-1-n*SUBL-k];\n        reverseDecresidual[n*SUBL+k] =\n            decresidual[(start-1)*SUBL-1-n*SUBL-k];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "meml_gotten = SUBL*(iLBCenc_inst->nsub+1-start);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ( meml_gotten > CB_MEML ) {\n    meml_gotten=CB_MEML;\n}\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nback; subframe++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* encode sub-frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBSearch(iLBCenc_inst, cb_index+subcount*CB_NSTAGES,",
      "ja": "iCBSearch(iLBCenc_inst, cb_index サブカウント *CB_NSTAGES,"
    },
    {
      "indent": 19,
      "text": "gain_index+subcount*CB_NSTAGES,\n&reverseResidual[subframe*SUBL],\nmem+CB_MEML-memLfTbl[subcount],\nmemLfTbl[subcount], SUBL, CB_NSTAGES,\n&weightdenum[(start-2-subframe)*\n            (LPC_FILTERORDER+1)],\nweightState, subcount+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&reverseDecresidual[subframe*SUBL],\n    cb_index+subcount*CB_NSTAGES,\n    gain_index+subcount*CB_NSTAGES,\n    mem+CB_MEML-memLfTbl[subcount],\n    memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\nmemcpy(mem+CB_MEML-SUBL,\n    &reverseDecresidual[subframe*SUBL],\n    SUBL*sizeof(float));\nmemset(weightState, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "subcount++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (i=0; i<SUBL*Nback; i++) {\n        decresidual[SUBL*Nback - i - 1] =\n            reverseDecresidual[i];\n    }\n}\n/* end encoding part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* adjust index */\nindex_conv_enc(cb_index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* pack bytes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pbytes=bytes;\npos=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* loop over the 3 ULP classes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (ulp=0; ulp<3; ulp++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* LSF */\nfor (k=0; k<LSF_NSPLIT*iLBCenc_inst->lpc_n; k++) {\n    packsplit(&lsf_i[k], &firstpart, &lsf_i[k],\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp],\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp]+\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->lsf_bits[k][ulp], &pos);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Start block info */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "packsplit(&start, &firstpart, &start,\n    iLBCenc_inst->ULP_inst->start_bits[ulp],\n    iLBCenc_inst->ULP_inst->start_bits[ulp]+\n    iLBCenc_inst->ULP_inst->start_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->start_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->start_bits[ulp], &pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "packsplit(&state_first, &firstpart, &state_first,\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp],\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp]+\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->startfirst_bits[ulp], &pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "packsplit(&idxForMax, &firstpart, &idxForMax,\n    iLBCenc_inst->ULP_inst->scale_bits[ulp],\n    iLBCenc_inst->ULP_inst->scale_bits[ulp]+\n    iLBCenc_inst->ULP_inst->scale_bits[ulp+1]+\n    iLBCenc_inst->ULP_inst->scale_bits[ulp+2]);\ndopack( &pbytes, firstpart,\n    iLBCenc_inst->ULP_inst->scale_bits[ulp], &pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0; k<iLBCenc_inst->state_short_len; k++) {\n    packsplit(idxVec+k, &firstpart, idxVec+k,\n        iLBCenc_inst->ULP_inst->state_bits[ulp],\n        iLBCenc_inst->ULP_inst->state_bits[ulp]+\n        iLBCenc_inst->ULP_inst->state_bits[ulp+1]+\n        iLBCenc_inst->ULP_inst->state_bits[ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->state_bits[ulp], &pos);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* 23/22 (20ms/30ms) sample block */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0;k<CB_NSTAGES;k++) {\n    packsplit(extra_cb_index+k, &firstpart,\n        extra_cb_index+k,\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp]+\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n        &pos);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0;k<CB_NSTAGES;k++) {\n    packsplit(extra_gain_index+k, &firstpart,\n        extra_gain_index+k,\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp]+\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+1]+\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+2]);\n    dopack( &pbytes, firstpart,\n        iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n        &pos);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* The two/four (20ms/30ms) 40 sample sub-blocks */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (i=0; i<iLBCenc_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        packsplit(cb_index+i*CB_NSTAGES+k, &firstpart,\n            cb_index+i*CB_NSTAGES+k,\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp]+\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+1]+\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+2]);\n        dopack( &pbytes, firstpart,\n            iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n            &pos);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (i=0; i<iLBCenc_inst->nasub; i++) {\n        for (k=0; k<CB_NSTAGES; k++) {\n            packsplit(gain_index+i*CB_NSTAGES+k, &firstpart,\n                gain_index+i*CB_NSTAGES+k,\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp]+\n                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+1]+\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+2]);\n            dopack( &pbytes, firstpart,\n                iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n                &pos);\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /* set the last bit to zero (otherwise the decoder\n       will treat it as a lost frame) */\n    dopack( &pbytes, 0, 1, &pos);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.4. iLBC_decode.h",
      "section_title": true,
      "ja": "A.4. iLBC_デコード.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_decode.h",
      "ja": "iLBC_デコード.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCDECODE_H #define __iLBC_ILBCDECODE_H",
      "ja": "#ifndef __iLBC_ILBCDECODE_H #define __iLBC_ILBCDECODE_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "short initDecode(                   /* (o) Number of decoded\n                                           samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    int mode,                       /* (i) frame size mode */\n    int use_enhancer                /* (i) 1 to use enhancer\n                                           0 to run without\n                                             enhancer */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iLBC_decode(\n    float *decblock,            /* (o) decoded signal block */\n    unsigned char *bytes,           /* (i) encoded signal bits */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    int mode                    /* (i) 0: bad packet, PLC,\n                                           1: normal */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ");",
      "ja": ");"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.5. iLBC_decode.c",
      "section_title": true,
      "ja": "A.5. iLBC_デコード.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_decode.c",
      "ja": "iLBC_デコード.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <stdlib.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"StateConstructW.h\" #include \"LPCdecode.h\" #include \"iCBConstruct.h\" #include \"doCPLC.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"string.h\" #include \"enhancer.h\" #include \"hpOutput.h\" #include \"syntFilter.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"StateConstructW.h\" #include \"LPCdecode.h\" #include \"iCBConstruct.h\" #include \"doCPLC.h\" #include \"helpfun.h\" #include \"constants.h\" #include \"packing.h\" #include \"string.h\" #include \"enhancer.h\" #include \"hpOutput.h\" #include \"syntFilter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Initiation of decoder instance.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "short initDecode(                   /* (o) Number of decoded\n                                           samples */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) Decoder instance */\n    int mode,                       /* (i) frame size mode */\n    int use_enhancer                /* (i) 1 to use enhancer\n                                           0 to run without\n                                             enhancer */\n){\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->mode = mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mode==30) {\n    iLBCdec_inst->blockl = BLOCKL_30MS;\n    iLBCdec_inst->nsub = NSUB_30MS;\n    iLBCdec_inst->nasub = NASUB_30MS;\n    iLBCdec_inst->lpc_n = LPC_N_30MS;\n    iLBCdec_inst->no_of_bytes = NO_OF_BYTES_30MS;\n    iLBCdec_inst->no_of_words = NO_OF_WORDS_30MS;\n    iLBCdec_inst->state_short_len=STATE_SHORT_LEN_30MS;\n    /* ULP init */\n    iLBCdec_inst->ULP_inst=&ULP_30msTbl;\n}\nelse if (mode==20) {\n    iLBCdec_inst->blockl = BLOCKL_20MS;\n    iLBCdec_inst->nsub = NSUB_20MS;\n    iLBCdec_inst->nasub = NASUB_20MS;\n    iLBCdec_inst->lpc_n = LPC_N_20MS;\n    iLBCdec_inst->no_of_bytes = NO_OF_BYTES_20MS;\n    iLBCdec_inst->no_of_words = NO_OF_WORDS_20MS;\n    iLBCdec_inst->state_short_len=STATE_SHORT_LEN_20MS;\n    /* ULP init */\n    iLBCdec_inst->ULP_inst=&ULP_20msTbl;\n}\nelse {\n    exit(2);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->syntMem, 0,\n    LPC_FILTERORDER*sizeof(float));\nmemcpy((*iLBCdec_inst).lsfdeqold, lsfmeanTbl,\n    LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->old_syntdenum, 0,\n    ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));\nfor (i=0; i<NSUB_MAX; i++)\n    iLBCdec_inst->old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->last_lag = 20;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prevLag = 120;\niLBCdec_inst->per = 0.0;\niLBCdec_inst->consPLICount = 0;\niLBCdec_inst->prevPLI = 0;\niLBCdec_inst->prevLpc[0] = 1.0;\nmemset(iLBCdec_inst->prevLpc+1,0,\n    LPC_FILTERORDER*sizeof(float));\nmemset(iLBCdec_inst->prevResidual, 0, BLOCKL_MAX*sizeof(float));\niLBCdec_inst->seed=777;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(iLBCdec_inst->hpomem, 0, 4*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->use_enhancer = use_enhancer;\nmemset(iLBCdec_inst->enh_buf, 0, ENH_BUFL*sizeof(float));\nfor (i=0;i<ENH_NBLOCKS_TOT;i++)\n    iLBCdec_inst->enh_period[i]=(float)40.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prev_enh_pl = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return (iLBCdec_inst->blockl); }",
      "ja": "return (iLBCdec_inst->blockl);}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  frame residual decoder function (subrutine to iLBC_decode)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void Decode(\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    float *decresidual,             /* (o) decoded residual frame */\n    int start,                      /* (i) location of start\n                                           state */\n    int idxForMax,                  /* (i) codebook index for the\n                                           maximum value */\n    int *idxVec,                /* (i) codebook indexes for the\n                                           samples  in the start\n                                           state */\n    float *syntdenum,               /* (i) the decoded synthesis\n                                           filter coefficients */\n    int *cb_index,                  /* (i) the indexes for the\n                                           adaptive codebook */\n    int *gain_index,            /* (i) the indexes for the\n                                           corresponding gains */\n    int *extra_cb_index,        /* (i) the indexes for the\n                                           adaptive codebook part\n                                           of start state */\n    int *extra_gain_index,          /* (i) the indexes for the\n                                           corresponding gains */\n    int state_first                 /* (i) 1 if non adaptive part\n                                           of start state comes\n                                           first 0 if that part\n                                           comes last */\n){\n    float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\n    int k, meml_gotten, Nfor, Nback, i;\n    int diff, start_pos;\n    int subcount, subframe;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "diff = STATE_LEN - iLBCdec_inst->state_short_len;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (state_first == 1) {\n    start_pos = (start-1)*SUBL;\n} else {\n    start_pos = (start-1)*SUBL + diff;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* decode scalar part of start state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "StateConstructW(idxForMax, idxVec,\n    &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n    &decresidual[start_pos], iLBCdec_inst->state_short_len);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (state_first) { /* put adaptive part in the end */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memset(mem, 0,\n    (CB_MEML-iLBCdec_inst->state_short_len)*sizeof(float));\nmemcpy(mem+CB_MEML-iLBCdec_inst->state_short_len,\n    decresidual+start_pos,\n    iLBCdec_inst->state_short_len*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBConstruct( &decresidual[start_pos+iLBCdec_inst->state_short_len], extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct( &decresidual[start_pos iLBCdec_inst->state_short_len], extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);"
    },
    {
      "indent": 7,
      "text": "}\nelse {/* put adaptive part in the beginning */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* create reversed vectors for prediction */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0; k<diff; k++) {\n    reverseDecresidual[k] =\n        decresidual[(start+1)*SUBL-1-\n                (k+iLBCdec_inst->state_short_len)];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "meml_gotten = iLBCdec_inst->state_short_len;\nfor (k=0; k<meml_gotten; k++){\n    mem[CB_MEML-1-k] = decresidual[start_pos + k];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);",
      "ja": "iCBConstruct(reverseDecresidual, extra_cb_index, extra_gain_index, mem CB_MEML-stMemLTbl, stMemLTbl, diff, CB_NSTAGES);"
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (k=0; k<diff; k++) {\n        decresidual[start_pos-1-k] = reverseDecresidual[k];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* counter for predicted sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "subcount=0;",
      "ja": "サブカウント=0;"
    },
    {
      "indent": 7,
      "text": "/* forward prediction of sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Nfor = iLBCdec_inst->nsub-start-1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ( Nfor > 0 ){",
      "ja": "if ( Nfor > 0 ){"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));\nmemcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,\n    STATE_LEN*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over sub-frames to encode */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nfor; subframe++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&decresidual[(start+1+subframe)*SUBL],\n    cb_index+subcount*CB_NSTAGES,\n    gain_index+subcount*CB_NSTAGES,\n    mem+CB_MEML-memLfTbl[subcount],\n    memLfTbl[subcount], SUBL, CB_NSTAGES);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float)); memcpy(mem+CB_MEML-SUBL,",
      "ja": "memcpy(mem, mem SUBL, (CB_MEML-SUBL)*sizeof(float));memcpy(mem CB_MEML-SUBL,"
    },
    {
      "indent": 19,
      "text": "&decresidual[(start+1+subframe)*SUBL],\nSUBL*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "subcount++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* backward prediction of sub-frames */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Nback = start-1;",
      "ja": "Nback = 開始-1;"
    },
    {
      "indent": 7,
      "text": "if ( Nback > 0 ) {",
      "ja": "if ( Nback > 0 ) {"
    },
    {
      "indent": 11,
      "text": "/* setup memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "meml_gotten = SUBL*(iLBCdec_inst->nsub+1-start);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ( meml_gotten > CB_MEML ) {\n    meml_gotten=CB_MEML;\n}\nfor (k=0; k<meml_gotten; k++) {\n    mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL + k];\n}\nmemset(mem, 0, (CB_MEML-k)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over subframes to decode */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (subframe=0; subframe<Nback; subframe++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* construct decoded vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iCBConstruct(&reverseDecresidual[subframe*SUBL],\n    cb_index+subcount*CB_NSTAGES,\n    gain_index+subcount*CB_NSTAGES,\n    mem+CB_MEML-memLfTbl[subcount], memLfTbl[subcount],\n    SUBL, CB_NSTAGES);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\nmemcpy(mem+CB_MEML-SUBL,\n    &reverseDecresidual[subframe*SUBL],\n    SUBL*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    subcount++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* get decoded residual from reversed vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        for (i=0; i<SUBL*Nback; i++)\n            decresidual[SUBL*Nback - i - 1] =\n            reverseDecresidual[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  main decoder function\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iLBC_decode(\n    float *decblock,            /* (o) decoded signal block */\n    unsigned char *bytes,           /* (i) encoded signal bits */\n    iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n                                             structure */\n    int mode                    /* (i) 0: bad packet, PLC,\n                                           1: normal */\n){\n    float data[BLOCKL_MAX];\n    float lsfdeq[LPC_FILTERORDER*LPC_N_MAX];\n    float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER + 1];\n    float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];\n    int k, i, start, idxForMax, pos, lastpart, ulp;\n    int lag, ilag;\n    float cc, maxcc;\n    int idxVec[STATE_LEN];\n    int check;\n    int gain_index[NASUB_MAX*CB_NSTAGES],\n        extra_gain_index[CB_NSTAGES];\n    int cb_index[CB_NSTAGES*NASUB_MAX], extra_cb_index[CB_NSTAGES];\n    int lsf_i[LSF_NSPLIT*LPC_N_MAX];\n    int state_first;\n    int last_bit;\n    unsigned char *pbytes;\n    float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];\n    int order_plus_one;\n    float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\n    float decresidual[BLOCKL_MAX];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (mode>0) { /* the data are good */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* decode data */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "pbytes=bytes;\npos=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Set everything to zero before decoding */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (k=0; k<LSF_NSPLIT*LPC_N_MAX; k++) {\n    lsf_i[k]=0;\n}\nstart=0;\nstate_first=0;\nidxForMax=0;\nfor (k=0; k<iLBCdec_inst->state_short_len; k++) {\n    idxVec[k]=0;\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    extra_cb_index[k]=0;\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    extra_gain_index[k]=0;\n}\nfor (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        cb_index[i*CB_NSTAGES+k]=0;\n    }\n}\nfor (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        gain_index[i*CB_NSTAGES+k]=0;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over ULP classes */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (ulp=0; ulp<3; ulp++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* LSF */\nfor (k=0; k<LSF_NSPLIT*iLBCdec_inst->lpc_n; k++){\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->lsf_bits[k][ulp], &pos);\n    packcombine(&lsf_i[k], lastpart,\n        iLBCdec_inst->ULP_inst->lsf_bits[k][ulp]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Start block info */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,\n    iLBCdec_inst->ULP_inst->start_bits[ulp], &pos);\npackcombine(&start, lastpart,\n    iLBCdec_inst->ULP_inst->start_bits[ulp]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,",
      "ja": "unpack( &pbytes, &lastpart,"
    },
    {
      "indent": 15,
      "text": "    iLBCdec_inst->ULP_inst->startfirst_bits[ulp], &pos);\npackcombine(&state_first, lastpart,\n    iLBCdec_inst->ULP_inst->startfirst_bits[ulp]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "unpack( &pbytes, &lastpart,\n    iLBCdec_inst->ULP_inst->scale_bits[ulp], &pos);\npackcombine(&idxForMax, lastpart,\n    iLBCdec_inst->ULP_inst->scale_bits[ulp]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (k=0; k<iLBCdec_inst->state_short_len; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->state_bits[ulp], &pos);\n    packcombine(idxVec+k, lastpart,\n        iLBCdec_inst->ULP_inst->state_bits[ulp]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* 23/22 (20ms/30ms) sample block */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (k=0; k<CB_NSTAGES; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp],\n        &pos);\n    packcombine(extra_cb_index+k, lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp]);\n}\nfor (k=0; k<CB_NSTAGES; k++) {\n    unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp],\n        &pos);\n    packcombine(extra_gain_index+k, lastpart,\n        iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* The two/four (20ms/30ms) 40 sample sub-blocks */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (i=0; i<iLBCdec_inst->nasub; i++) {\n    for (k=0; k<CB_NSTAGES; k++) {\n        unpack( &pbytes, &lastpart,\n        iLBCdec_inst->ULP_inst->cb_index[i][k][ulp],\n            &pos);\n        packcombine(cb_index+i*CB_NSTAGES+k, lastpart,\n        iLBCdec_inst->ULP_inst->cb_index[i][k][ulp]);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    for (i=0; i<iLBCdec_inst->nasub; i++) {\n        for (k=0; k<CB_NSTAGES; k++) {\n            unpack( &pbytes, &lastpart,\n                       iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp],\n                &pos);\n            packcombine(gain_index+i*CB_NSTAGES+k, lastpart,\n                iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp]);\n        }\n    }\n}\n/* Extract last bit. If it is 1 this indicates an\n   empty/lost frame */\nunpack( &pbytes, &last_bit, 1, &pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Check for bit errors or empty/lost frames */\nif (start<1)\n    mode = 0;\nif (iLBCdec_inst->mode==20 && start>3)\n    mode = 0;\nif (iLBCdec_inst->mode==30 && start>5)\n    mode = 0;\nif (last_bit==1)\n    mode = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (mode==1) { /* No bit errors was detected,\n                  continue decoding */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* adjust index */\nindex_conv_dec(cb_index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* decode the lsf */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "SimplelsfDEQ(lsfdeq, lsf_i, iLBCdec_inst->lpc_n);\ncheck=LSF_check(lsfdeq, LPC_FILTERORDER,\n    iLBCdec_inst->lpc_n);\nDecoderInterpolateLSF(syntdenum, weightdenum,\n    lsfdeq, LPC_FILTERORDER, iLBCdec_inst);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Decode(iLBCdec_inst, decresidual, start, idxForMax, idxVec, syntdenum, cb_index, gain_index, extra_cb_index, extra_gain_index, state_first);",
      "ja": "Decode(iLBCdec_inst、decresidual、start、idxForMax、idxVec、syntdenum、cb_index、gain_index、extra_cb_index、extra_gain_index、state_first);"
    },
    {
      "indent": 15,
      "text": "/* preparing the plc for a future loss! */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "doThePLC(PLCresidual, PLClpc, 0, decresidual,\n    syntdenum +\n    (LPC_FILTERORDER + 1)*(iLBCdec_inst->nsub - 1),\n    (*iLBCdec_inst).last_lag, iLBCdec_inst);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    memcpy(decresidual, PLCresidual,\n        iLBCdec_inst->blockl*sizeof(float));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "if (mode == 0) {\n    /* the data is bad (either a PLC call\n     * was made or a severe bit error was detected)\n     */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* packet loss conceal */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memset(zeros, 0, BLOCKL_MAX*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "one[0] = 1;\nmemset(one+1, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "start=0;",
      "ja": "開始=0;"
    },
    {
      "indent": 11,
      "text": "doThePLC(PLCresidual, PLClpc, 1, zeros, one,\n    (*iLBCdec_inst).last_lag, iLBCdec_inst);\nmemcpy(decresidual, PLCresidual,\n    iLBCdec_inst->blockl*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    order_plus_one = LPC_FILTERORDER + 1;\n    for (i = 0; i < iLBCdec_inst->nsub; i++) {\n        memcpy(syntdenum+(i*order_plus_one), PLClpc,\n            order_plus_one*sizeof(float));\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->use_enhancer == 1) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* post filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->last_lag =\n    enhancerInterface(data, decresidual, iLBCdec_inst);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* synthesis filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (iLBCdec_inst->mode==20) {\n    /* Enhancer has 40 samples delay */\n    i=0;\n    syntFilter(data + i*SUBL,\n        iLBCdec_inst->old_syntdenum +\n        (i+iLBCdec_inst->nsub-1)*(LPC_FILTERORDER+1),\n        SUBL, iLBCdec_inst->syntMem);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    for (i=1; i < iLBCdec_inst->nsub; i++) {\n        syntFilter(data + i*SUBL,\n            syntdenum + (i-1)*(LPC_FILTERORDER+1),\n            SUBL, iLBCdec_inst->syntMem);\n    }\n} else if (iLBCdec_inst->mode==30) {\n    /* Enhancer has 80 samples delay */\n    for (i=0; i < 2; i++) {\n        syntFilter(data + i*SUBL,\n            iLBCdec_inst->old_syntdenum +\n            (i+iLBCdec_inst->nsub-2)*(LPC_FILTERORDER+1),\n            SUBL, iLBCdec_inst->syntMem);\n    }\n    for (i=2; i < iLBCdec_inst->nsub; i++) {\n        syntFilter(data + i*SUBL,\n            syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,\n            iLBCdec_inst->syntMem);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "} else {",
      "ja": "} それ以外 {"
    },
    {
      "indent": 11,
      "text": "/* Find last lag */\nlag = 20;\nmaxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],\n    &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (ilag=21; ilag<120; ilag++) {\n    cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],\n        &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],\n        ENH_BLOCKL);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}\niLBCdec_inst->last_lag = lag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* copy data and run synthesis filter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memcpy(data, decresidual,\n    iLBCdec_inst->blockl*sizeof(float));\nfor (i=0; i < iLBCdec_inst->nsub; i++) {\n    syntFilter(data + i*SUBL,\n        syntdenum + i*(LPC_FILTERORDER+1), SUBL,\n        iLBCdec_inst->syntMem);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* high pass filtering on output if desired, otherwise\n   copy to out */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "hpOutput(data, iLBCdec_inst->blockl,\n            decblock,iLBCdec_inst->hpomem);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* memcpy(decblock,data,iLBCdec_inst->blockl*sizeof(float));*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memcpy(iLBCdec_inst->old_syntdenum, syntdenum,",
      "ja": "memcpy(iLBCdec_inst->old_syntdenum, syntdenum,"
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->nsub*(LPC_FILTERORDER+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBCdec_inst->prev_enh_pl=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (mode==0) { /* PLC was used */\n        iLBCdec_inst->prev_enh_pl=1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.6. iLBC_define.h",
      "section_title": true,
      "ja": "A.6. iLBC_define.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iLBC_define.h",
      "ja": "iLBC_define.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ILBCDEFINE_H #define __iLBC_ILBCDEFINE_H",
      "ja": "#ifndef __iLBC_ILBCDEFINE_H #define __iLBC_ILBCDEFINE_H"
    },
    {
      "indent": 3,
      "text": "/* general codec settings */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define FS                      (float)8000.0\n#define BLOCKL_20MS             160\n#define BLOCKL_30MS             240\n#define BLOCKL_MAX              240\n#define NSUB_20MS               4\n#define NSUB_30MS               6\n#define NSUB_MAX            6\n#define NASUB_20MS              2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define NASUB_30MS              4\n#define NASUB_MAX               4\n#define SUBL                40\n#define STATE_LEN               80\n#define STATE_SHORT_LEN_30MS    58\n#define STATE_SHORT_LEN_20MS    57",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* LPC settings */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define LPC_FILTERORDER         10\n#define LPC_CHIRP_SYNTDENUM     (float)0.9025\n#define LPC_CHIRP_WEIGHTDENUM   (float)0.4222\n#define LPC_LOOKBACK        60\n#define LPC_N_20MS              1\n#define LPC_N_30MS              2\n#define LPC_N_MAX               2\n#define LPC_ASYMDIFF        20\n#define LPC_BW                  (float)60.0\n#define LPC_WN                  (float)1.0001\n#define LSF_NSPLIT              3\n#define LSF_NUMBER_OF_STEPS     4\n#define LPC_HALFORDER           (LPC_FILTERORDER/2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* cb settings */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define CB_NSTAGES              3\n#define CB_EXPAND               2\n#define CB_MEML                 147\n#define CB_FILTERLEN        2*4\n#define CB_HALFFILTERLEN    4\n#define CB_RESRANGE             34\n#define CB_MAXGAIN              (float)1.3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* enhancer */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define ENH_BLOCKL              80  /* block length */\n#define ENH_BLOCKL_HALF         (ENH_BLOCKL/2)\n#define ENH_HL                  3   /* 2*ENH_HL+1 is number blocks\n                                       in said second sequence */\n#define ENH_SLOP            2   /* max difference estimated and\n                                       correct pitch period */\n#define ENH_PLOCSL              20  /* pitch-estimates and pitch-\n                                       locations buffer length */\n#define ENH_OVERHANG        2\n#define ENH_UPS0            4   /* upsampling rate */\n#define ENH_FL0                 3   /* 2*FLO+1 is the length of\n                                       each filter */\n#define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define ENH_CORRDIM             (2*ENH_SLOP+1)\n#define ENH_NBLOCKS             (BLOCKL_MAX/ENH_BLOCKL)\n#define ENH_NBLOCKS_EXTRA       5\n#define ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +\n                                       ENH_NBLOCKS_EXTRA */\n#define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL\n#define ENH_ALPHA0              (float)0.05",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Down sampling */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define FILTERORDER_DS          7\n#define DELAY_DS            3\n#define FACTOR_DS               2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* bit stream defs */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define NO_OF_BYTES_20MS    38\n#define NO_OF_BYTES_30MS    50\n#define NO_OF_WORDS_20MS    19\n#define NO_OF_WORDS_30MS    25\n#define STATE_BITS              3\n#define BYTE_LEN            8\n#define ULP_CLASSES             3",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* help parameters */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#define FLOAT_MAX (float)1.0e37 #define EPS (float)2.220446049250313e-016 #define PI (float)3.14159265358979323846 #define MIN_SAMPLE -32768 #define MAX_SAMPLE 32767 #define TWO_PI (float)6.283185307 #define PI2 (float)0.159154943",
      "ja": "#define FLOAT_MAX (float)1.0e37 #define EPS (float)2.220446049250313e-016 #define PI (float)3.14159265358979323846 #define MIN_SAMPLE -32768 #define MAX_SAMPLE 32767 #define TWO_PI (fフロート)6.283185307 #define PI2 (フロート)0.159154943"
    },
    {
      "indent": 3,
      "text": "/* type definition encoder instance */\ntypedef struct iLBC_ULP_Inst_t_ {\n    int lsf_bits[6][ULP_CLASSES+2];\n    int start_bits[ULP_CLASSES+2];\n    int startfirst_bits[ULP_CLASSES+2];\n    int scale_bits[ULP_CLASSES+2];\n    int state_bits[ULP_CLASSES+2];\n    int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];\n    int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];\n    int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n    int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n} iLBC_ULP_Inst_t;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* type definition encoder instance */\n   typedef struct iLBC_Enc_Inst_t_ {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* flag for frame size mode */\nint mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* basic parameters for different frame sizes */\nint blockl;\nint nsub;\nint nasub;\nint no_of_bytes, no_of_words;\nint lpc_n;\nint state_short_len;\nconst iLBC_ULP_Inst_t *ULP_inst;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* analysis filter state */\nfloat anaMem[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* old lsf parameters for interpolation */\nfloat lsfold[LPC_FILTERORDER];\nfloat lsfdeqold[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* signal buffer for LP analysis */\nfloat lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* state of input HP filter */\nfloat hpimem[4];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} iLBC_Enc_Inst_t;",
      "ja": "iLBC_Enc_Inst_t;"
    },
    {
      "indent": 3,
      "text": "/* type definition decoder instance */\ntypedef struct iLBC_Dec_Inst_t_ {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* flag for frame size mode */\nint mode;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* basic parameters for different frame sizes */\nint blockl;\nint nsub;\nint nasub;\nint no_of_bytes, no_of_words;\nint lpc_n;\nint state_short_len;\nconst iLBC_ULP_Inst_t *ULP_inst;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* synthesis filter state */\nfloat syntMem[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* old LSF for interpolation */\n       float lsfdeqold[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* pitch lag estimated in enhancer and used in PLC */\nint last_lag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* PLC state information */\nint prevLag, consPLICount, prevPLI, prev_enh_pl;\nfloat prevLpc[LPC_FILTERORDER+1];\nfloat prevResidual[NSUB_MAX*SUBL];\nfloat per;\nunsigned long seed;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* previous synthesis filter parameters */\nfloat old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* state of output HP filter */\nfloat hpomem[4];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* enhancer state information */\nint use_enhancer;\nfloat enh_buf[ENH_BUFL];\nfloat enh_period[ENH_NBLOCKS_TOT];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} iLBC_Dec_Inst_t;",
      "ja": "iLBC_Dec_Inst_t;"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.7. constants.h",
      "section_title": true,
      "ja": "A.7. 定数.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "constants.h",
      "ja": "定数.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_CONSTANTS_H #define __iLBC_CONSTANTS_H",
      "ja": "#ifndef __iLBC_CONSTANTS_H #define __iLBC_CONSTANTS_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/* ULP bit allocation */\n   extern const iLBC_ULP_Inst_t ULP_20msTbl;\nextern const iLBC_ULP_Inst_t ULP_30msTbl;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* high pass filters */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern float hpi_zero_coefsTbl[];\nextern float hpi_pole_coefsTbl[];\nextern float hpo_zero_coefsTbl[];\nextern float hpo_pole_coefsTbl[];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* low pass filters */\nextern float lpFilt_coefsTbl[];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* LPC analysis and quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern float lpc_winTbl[];\nextern float lpc_asymwinTbl[];\nextern float lpc_lagwinTbl[];\nextern float lsfCbTbl[];\nextern float lsfmeanTbl[];\nextern int   dim_lsfCbTbl[];\nextern int   size_lsfCbTbl[];\nextern float lsf_weightTbl_30ms[];\nextern float lsf_weightTbl_20ms[];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* state quantization tables */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern float state_sq3Tbl[]; extern float state_frgqTbl[];",
      "ja": "extern float state_sq3Tbl[];extern float state_frgqTbl[];"
    },
    {
      "indent": 3,
      "text": "/* gain quantization tables */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern float gain_sq3Tbl[];\nextern float gain_sq4Tbl[];\nextern float gain_sq5Tbl[];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* adaptive codebook definitions */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern int search_rangeTbl[5][CB_NSTAGES];\nextern int memLfTbl[];\nextern int stMemLTbl;\nextern float cbfiltersTbl[CB_FILTERLEN];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* enhancer definitions */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "extern float polyphaserTbl[]; extern float enh_plocsTbl[];",
      "ja": "extern float ポリフェイザーTbl[];extern float enh_plocsTbl[];"
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.8. constants.c",
      "section_title": true,
      "ja": "A.8. 定数.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "constants.c",
      "ja": "定数.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/* ULP bit allocation */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* 20 ms frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const iLBC_ULP_Inst_t ULP_20msTbl = {\n    /* LSF */\n    {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},\n        {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n    /* Start state location, gain and samples */\n    {2,0,0,0,0},\n    {1,0,0,0,0},\n    {6,0,0,0,0},\n    {0,1,2,0,0},\n    /* extra CB index and extra CB gain */\n    {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n    {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n    /* CB index and CB gain */\n    {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n        {{0,0,8,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},\n    {   {{1,2,2,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n        {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n        {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}}\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* 30 ms frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "const iLBC_ULP_Inst_t ULP_30msTbl = {\n    /* LSF */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},\n        {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},\n    /* Start state location, gain and samples */\n    {3,0,0,0,0},\n    {1,0,0,0,0},\n    {6,0,0,0,0},\n    {0,1,2,0,0},\n    /* extra CB index and extra CB gain */\n    {{4,2,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n    {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n    /* CB index and CB gain */\n    {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n        {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},\n    {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},\n        {{0,2,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},\n        {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},\n        {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* HP Filters */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float hpi_zero_coefsTbl[3] = {\n    (float)0.92727436, (float)-1.8544941, (float)0.92727436\n};\nfloat hpi_pole_coefsTbl[3] = {\n    (float)1.0, (float)-1.9059465, (float)0.9114024\n};\nfloat hpo_zero_coefsTbl[3] = {\n    (float)0.93980581, (float)-1.8795834, (float)0.93980581\n};\nfloat hpo_pole_coefsTbl[3] = {\n    (float)1.0, (float)-1.9330735, (float)0.93589199\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* LP Filter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float lpFilt_coefsTbl[FILTERORDER_DS]={ (float)-0.066650, (float)0.125000, (float)0.316650, (float)0.414063, (float)0.316650, (float)0.125000, (float)-0.066650 };",
      "ja": "float lpFilt_coefsTbl[FILTERORDER_DS]={ (float)-0.066650, (float)0.125000, (float)0.316650, (float)0.414063, (float)0.316650, (float)0.125000, (float)-0.066650 };"
    },
    {
      "indent": 3,
      "text": "/* State quantization tables */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float state_sq3Tbl[8] = {\n    (float)-3.719849, (float)-2.177490, (float)-1.130005,\n       (float)-0.309692, (float)0.444214, (float)1.329712,\n    (float)2.436279, (float)3.983887\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float state_frgqTbl[64] = {\n    (float)1.000085, (float)1.071695, (float)1.140395,\n    (float)1.206868, (float)1.277188, (float)1.351503,\n    (float)1.429380, (float)1.500727, (float)1.569049,\n    (float)1.639599, (float)1.707071, (float)1.781531,\n    (float)1.840799, (float)1.901550, (float)1.956695,\n    (float)2.006750, (float)2.055474, (float)2.102787,\n    (float)2.142819, (float)2.183592, (float)2.217962,\n    (float)2.257177, (float)2.295739, (float)2.332967,\n    (float)2.369248, (float)2.402792, (float)2.435080,\n    (float)2.468598, (float)2.503394, (float)2.539284,\n    (float)2.572944, (float)2.605036, (float)2.636331,\n    (float)2.668939, (float)2.698780, (float)2.729101,\n    (float)2.759786, (float)2.789834, (float)2.818679,\n    (float)2.848074, (float)2.877470, (float)2.906899,\n    (float)2.936655, (float)2.967804, (float)3.000115,\n    (float)3.033367, (float)3.066355, (float)3.104231,\n    (float)3.141499, (float)3.183012, (float)3.222952,\n    (float)3.265433, (float)3.308441, (float)3.350823,\n    (float)3.395275, (float)3.442793, (float)3.490801,\n    (float)3.542514, (float)3.604064, (float)3.666050,\n    (float)3.740994, (float)3.830749, (float)3.938770,\n    (float)4.101764\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* CB tables */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int search_rangeTbl[5][CB_NSTAGES]={{58,58,58}, {108,44,44},\n            {108,108,108}, {108,108,108}, {108,108,108}};\nint stMemLTbl=85;\nint memLfTbl[NASUB_MAX]={147,147,147,147};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* expansion filter(s) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float cbfiltersTbl[CB_FILTERLEN]={ (float)-0.034180, (float)0.108887, (float)-0.184326, (float)0.806152, (float)0.713379, (float)-0.144043, (float)0.083740, (float)-0.033691 };",
      "ja": "float cbfiltersTbl[CB_FILTERLEN]={ (float)-0.034180, (float)0.108887, (float)-0.184326, (float)0.806152, (float)0.713379, (float)-0.144043, (float)0.083740, (flo) at)-0.033691};"
    },
    {
      "indent": 3,
      "text": "/* Gain Quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float gain_sq3Tbl[8]={ (float)-1.000000, (float)-0.659973, (float)-0.330017, (float)0.000000, (float)0.250000, (float)0.500000, (float)0.750000, (float)1.00000};",
      "ja": "float Gain_sq3Tbl[8]={ (float)-1.000000, (float)-0.659973, (float)-0.330017, (float)0.000000, (float)0.250000, (float)0.500000, (float)0.750000, (float)1.0 0000};"
    },
    {
      "indent": 3,
      "text": "float gain_sq4Tbl[16]={ (float)-1.049988, (float)-0.900024, (float)-0.750000, (float)-0.599976, (float)-0.450012, (float)-0.299988, (float)-0.150024, (float)0.000000, (float)0.150024, (float)0.299988, (float)0.450012, (float)0.599976, (float)0.750000, (float)0.900024, (float)1.049988, (float)1.200012};",
      "ja": "float Gain_sq4Tbl[16]={ (float)-1.049988, (float)-0.900024, (float)-0.750000, (float)-0.599976, (float)-0.450012, (float)-0.299988, (float)-0.150024, (浮動小数点)0.000000、(浮動小数点)0.150024、(浮動小数点)0.299988、(浮動小数点)0.450012、(浮動小数点)0.599976、(浮動小数点)0.750000、(浮動小数点)0.900024、(浮動小数点)1.049988、(浮動小数点)1.200012 };"
    },
    {
      "indent": 3,
      "text": "float gain_sq5Tbl[32]={ (float)0.037476, (float)0.075012, (float)0.112488, (float)0.150024, (float)0.187500, (float)0.224976, (float)0.262512, (float)0.299988, (float)0.337524, (float)0.375000, (float)0.412476, (float)0.450012, (float)0.487488, (float)0.525024, (float)0.562500, (float)0.599976, (float)0.637512, (float)0.674988, (float)0.712524, (float)0.750000, (float)0.787476, (float)0.825012, (float)0.862488, (float)0.900024, (float)0.937500, (float)0.974976, (float)1.012512, (float)1.049988, (float)1.087524, (float)1.125000, (float)1.162476, (float)1.200012};",
      "ja": "float Gain_sq5Tbl[32]={ (浮動小数点)0.037476, (浮動小数点)0.075012, (浮動小数点)0.112488, (浮動小数点)0.150024, (浮動小数点)0.187500, (浮動小数点)0.224976, (浮動小数点)0.262512, (浮動小数点)0.299 988、(浮動小数点数)0.337524、（浮動小数点）0.375000、（浮動小数点）0.412476、（浮動小数点）0.450012、（浮動小数点）0.487488、（浮動小数点）0.525024、（浮動小数点）0.562500、（浮動小数点）0.599976、（浮動小数点）0.637512、 (浮動小数点)0.674988、(浮動小数点)0.712524、（浮動小数点）0.750000、（浮動小数点）0.787476、（浮動小数点）0.825012、（浮動小数点）0.862488、（浮動小数点）0.900024、（浮動小数点）0.937500、（浮動小数点）0.974976、（浮動小数点）1.012512、 (浮動小数点)1.049988、(浮動小数点)1.087524、(浮動小数点)1.125000、(浮動小数点)1.162476、(浮動小数点)1.200012};"
    },
    {
      "indent": 3,
      "text": "/* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */\nfloat polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={\n    (float)0.000000, (float)0.000000, (float)0.000000,\n(float)1.000000,\n        (float)0.000000, (float)0.000000, (float)0.000000,\n    (float)0.015625, (float)-0.076904, (float)0.288330,\n(float)0.862061,\n        (float)-0.106445, (float)0.018799, (float)-0.015625,\n    (float)0.023682, (float)-0.124268, (float)0.601563,\n(float)0.601563,\n        (float)-0.124268, (float)0.023682, (float)-0.023682,\n    (float)0.018799, (float)-0.106445, (float)0.862061,\n(float)0.288330,\n        (float)-0.076904, (float)0.015625, (float)-0.018799};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float enh_plocsTbl[ENH_NBLOCKS_TOT] = {(float)40.0, (float)120.0,\n            (float)200.0, (float)280.0, (float)360.0,\n            (float)440.0, (float)520.0, (float)600.0};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* LPC analysis and quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};\nint size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float lsfmeanTbl[LPC_FILTERORDER] = {\n    (float)0.281738, (float)0.445801, (float)0.663330,\n    (float)0.962524, (float)1.251831, (float)1.533081,\n    (float)1.850586, (float)2.137817, (float)2.481445,\n    (float)2.777344};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0), (float)1.0,\n(float)(2.0/3.0),\n    (float)(1.0/3.0), (float)0.0, (float)0.0};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0),\n    (float)(1.0/4.0), (float)(0.0)};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Hanning LPC window */\nfloat lpc_winTbl[BLOCKL_MAX]={\n    (float)0.000183, (float)0.000671, (float)0.001526,\n    (float)0.002716, (float)0.004242, (float)0.006104,\n    (float)0.008301, (float)0.010834, (float)0.013702,\n    (float)0.016907, (float)0.020416, (float)0.024261,\n    (float)0.028442, (float)0.032928, (float)0.037750,\n    (float)0.042877, (float)0.048309, (float)0.054047,\n    (float)0.060089, (float)0.066437, (float)0.073090,\n    (float)0.080017, (float)0.087219, (float)0.094727,\n    (float)0.102509, (float)0.110535, (float)0.118835,\n    (float)0.127411, (float)0.136230, (float)0.145294,\n    (float)0.154602, (float)0.164154, (float)0.173920,\n    (float)0.183899, (float)0.194122, (float)0.204529,\n    (float)0.215149, (float)0.225952, (float)0.236938,\n    (float)0.248108, (float)0.259460, (float)0.270966,\n    (float)0.282654, (float)0.294464, (float)0.306396,\n    (float)0.318481, (float)0.330688, (float)0.343018,\n    (float)0.355438, (float)0.367981, (float)0.380585,\n    (float)0.393280, (float)0.406067, (float)0.418884,\n    (float)0.431763, (float)0.444702, (float)0.457672,\n    (float)0.470673, (float)0.483704, (float)0.496735,\n    (float)0.509766, (float)0.522797, (float)0.535828,\n    (float)0.548798, (float)0.561768, (float)0.574677,\n    (float)0.587524, (float)0.600342, (float)0.613068,\n    (float)0.625732, (float)0.638306, (float)0.650787,\n    (float)0.663147, (float)0.675415, (float)0.687561,\n    (float)0.699585, (float)0.711487, (float)0.723206,\n    (float)0.734802, (float)0.746216, (float)0.757477,\n    (float)0.768585, (float)0.779480, (float)0.790192,\n    (float)0.800720, (float)0.811005, (float)0.821106,\n    (float)0.830994, (float)0.840668, (float)0.850067,\n    (float)0.859253, (float)0.868225, (float)0.876892,\n    (float)0.885345, (float)0.893524, (float)0.901428,\n    (float)0.909058, (float)0.916412, (float)0.923492,\n       (float)0.930267, (float)0.936768, (float)0.942963,\n    (float)0.948853, (float)0.954437, (float)0.959717,\n    (float)0.964691, (float)0.969360, (float)0.973694,\n    (float)0.977692, (float)0.981384, (float)0.984741,\n    (float)0.987762, (float)0.990479, (float)0.992828,\n    (float)0.994873, (float)0.996552, (float)0.997925,\n    (float)0.998932, (float)0.999603, (float)0.999969,\n    (float)0.999969, (float)0.999603, (float)0.998932,\n    (float)0.997925, (float)0.996552, (float)0.994873,\n    (float)0.992828, (float)0.990479, (float)0.987762,\n    (float)0.984741, (float)0.981384, (float)0.977692,\n    (float)0.973694, (float)0.969360, (float)0.964691,\n    (float)0.959717, (float)0.954437, (float)0.948853,\n    (float)0.942963, (float)0.936768, (float)0.930267,\n    (float)0.923492, (float)0.916412, (float)0.909058,\n    (float)0.901428, (float)0.893524, (float)0.885345,\n    (float)0.876892, (float)0.868225, (float)0.859253,\n    (float)0.850067, (float)0.840668, (float)0.830994,\n    (float)0.821106, (float)0.811005, (float)0.800720,\n    (float)0.790192, (float)0.779480, (float)0.768585,\n    (float)0.757477, (float)0.746216, (float)0.734802,\n    (float)0.723206, (float)0.711487, (float)0.699585,\n    (float)0.687561, (float)0.675415, (float)0.663147,\n    (float)0.650787, (float)0.638306, (float)0.625732,\n    (float)0.613068, (float)0.600342, (float)0.587524,\n    (float)0.574677, (float)0.561768, (float)0.548798,\n    (float)0.535828, (float)0.522797, (float)0.509766,\n    (float)0.496735, (float)0.483704, (float)0.470673,\n    (float)0.457672, (float)0.444702, (float)0.431763,\n    (float)0.418884, (float)0.406067, (float)0.393280,\n    (float)0.380585, (float)0.367981, (float)0.355438,\n    (float)0.343018, (float)0.330688, (float)0.318481,\n    (float)0.306396, (float)0.294464, (float)0.282654,\n    (float)0.270966, (float)0.259460, (float)0.248108,\n    (float)0.236938, (float)0.225952, (float)0.215149,\n    (float)0.204529, (float)0.194122, (float)0.183899,\n    (float)0.173920, (float)0.164154, (float)0.154602,\n    (float)0.145294, (float)0.136230, (float)0.127411,\n    (float)0.118835, (float)0.110535, (float)0.102509,\n    (float)0.094727, (float)0.087219, (float)0.080017,\n    (float)0.073090, (float)0.066437, (float)0.060089,\n    (float)0.054047, (float)0.048309, (float)0.042877,\n    (float)0.037750, (float)0.032928, (float)0.028442,\n    (float)0.024261, (float)0.020416, (float)0.016907,\n    (float)0.013702, (float)0.010834, (float)0.008301,\n    (float)0.006104, (float)0.004242, (float)0.002716,\n    (float)0.001526, (float)0.000671, (float)0.000183\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Asymmetric LPC window */\nfloat lpc_asymwinTbl[BLOCKL_MAX]={\n    (float)0.000061, (float)0.000214, (float)0.000458,\n    (float)0.000824, (float)0.001282, (float)0.001831,\n    (float)0.002472, (float)0.003235, (float)0.004120,\n    (float)0.005066, (float)0.006134, (float)0.007294,\n    (float)0.008545, (float)0.009918, (float)0.011383,\n    (float)0.012939, (float)0.014587, (float)0.016357,\n    (float)0.018219, (float)0.020172, (float)0.022217,\n    (float)0.024353, (float)0.026611, (float)0.028961,\n    (float)0.031372, (float)0.033905, (float)0.036530,\n    (float)0.039276, (float)0.042084, (float)0.044983,\n    (float)0.047974, (float)0.051086, (float)0.054260,\n    (float)0.057526, (float)0.060883, (float)0.064331,\n    (float)0.067871, (float)0.071503, (float)0.075226,\n    (float)0.079010, (float)0.082916, (float)0.086884,\n    (float)0.090942, (float)0.095062, (float)0.099304,\n    (float)0.103607, (float)0.107971, (float)0.112427,\n    (float)0.116974, (float)0.121582, (float)0.126282,\n    (float)0.131073, (float)0.135895, (float)0.140839,\n    (float)0.145813, (float)0.150879, (float)0.156006,\n    (float)0.161224, (float)0.166504, (float)0.171844,\n    (float)0.177246, (float)0.182709, (float)0.188263,\n    (float)0.193848, (float)0.199524, (float)0.205231,\n    (float)0.211029, (float)0.216858, (float)0.222778,\n    (float)0.228729, (float)0.234741, (float)0.240814,\n    (float)0.246918, (float)0.253082, (float)0.259308,\n    (float)0.265564, (float)0.271881, (float)0.278259,\n    (float)0.284668, (float)0.291107, (float)0.297607,\n    (float)0.304138, (float)0.310730, (float)0.317322,\n    (float)0.323975, (float)0.330658, (float)0.337372,\n    (float)0.344147, (float)0.350922, (float)0.357727,\n    (float)0.364594, (float)0.371460, (float)0.378357,\n    (float)0.385284, (float)0.392212, (float)0.399170,\n    (float)0.406158, (float)0.413177, (float)0.420197,\n    (float)0.427246, (float)0.434296, (float)0.441376,\n    (float)0.448456, (float)0.455536, (float)0.462646,\n    (float)0.469757, (float)0.476868, (float)0.483978,\n    (float)0.491089, (float)0.498230, (float)0.505341,\n    (float)0.512451, (float)0.519592, (float)0.526703,\n    (float)0.533813, (float)0.540924, (float)0.548004,\n    (float)0.555084, (float)0.562164, (float)0.569244,\n    (float)0.576294, (float)0.583313, (float)0.590332,\n    (float)0.597321, (float)0.604309, (float)0.611267,\n    (float)0.618195, (float)0.625092, (float)0.631989,\n    (float)0.638855, (float)0.645660, (float)0.652466,\n    (float)0.659241, (float)0.665985, (float)0.672668,\n    (float)0.679352, (float)0.685974, (float)0.692566,\n       (float)0.699127, (float)0.705658, (float)0.712128,\n    (float)0.718536, (float)0.724945, (float)0.731262,\n    (float)0.737549, (float)0.743805, (float)0.750000,\n    (float)0.756134, (float)0.762238, (float)0.768280,\n    (float)0.774261, (float)0.780182, (float)0.786072,\n    (float)0.791870, (float)0.797638, (float)0.803314,\n    (float)0.808960, (float)0.814514, (float)0.820038,\n    (float)0.825470, (float)0.830841, (float)0.836151,\n    (float)0.841400, (float)0.846558, (float)0.851654,\n    (float)0.856689, (float)0.861633, (float)0.866516,\n    (float)0.871338, (float)0.876068, (float)0.880737,\n    (float)0.885315, (float)0.889801, (float)0.894226,\n    (float)0.898560, (float)0.902832, (float)0.907013,\n    (float)0.911102, (float)0.915100, (float)0.919037,\n    (float)0.922882, (float)0.926636, (float)0.930328,\n    (float)0.933899, (float)0.937408, (float)0.940796,\n    (float)0.944122, (float)0.947357, (float)0.950470,\n    (float)0.953522, (float)0.956482, (float)0.959351,\n    (float)0.962097, (float)0.964783, (float)0.967377,\n    (float)0.969849, (float)0.972229, (float)0.974518,\n    (float)0.976715, (float)0.978821, (float)0.980835,\n    (float)0.982727, (float)0.984528, (float)0.986237,\n    (float)0.987854, (float)0.989380, (float)0.990784,\n    (float)0.992096, (float)0.993317, (float)0.994415,\n    (float)0.995422, (float)0.996338, (float)0.997162,\n    (float)0.997864, (float)0.998474, (float)0.998962,\n    (float)0.999390, (float)0.999695, (float)0.999878,\n    (float)0.999969, (float)0.999969, (float)0.996918,\n    (float)0.987701, (float)0.972382, (float)0.951050,\n    (float)0.923889, (float)0.891022, (float)0.852631,\n    (float)0.809021, (float)0.760406, (float)0.707092,\n    (float)0.649445, (float)0.587799, (float)0.522491,\n    (float)0.453979, (float)0.382690, (float)0.309021,\n    (float)0.233459, (float)0.156433, (float)0.078461\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* Lag window for LPC */\nfloat lpc_lagwinTbl[LPC_FILTERORDER + 1]={\n    (float)1.000100, (float)0.998890, (float)0.995569,\n        (float)0.990057, (float)0.982392,\n    (float)0.972623, (float)0.960816, (float)0.947047,\n        (float)0.931405, (float)0.913989, (float)0.894909};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/* LSF quantization*/\nfloat lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {\n(float)0.155396, (float)0.273193, (float)0.451172,\n(float)0.390503, (float)0.648071, (float)1.002075,\n(float)0.440186, (float)0.692261, (float)0.955688,\n   (float)0.343628, (float)0.642334, (float)1.071533,\n(float)0.318359, (float)0.491577, (float)0.670532,\n(float)0.193115, (float)0.375488, (float)0.725708,\n(float)0.364136, (float)0.510376, (float)0.658691,\n(float)0.297485, (float)0.527588, (float)0.842529,\n(float)0.227173, (float)0.365967, (float)0.563110,\n(float)0.244995, (float)0.396729, (float)0.636475,\n(float)0.169434, (float)0.300171, (float)0.520264,\n(float)0.312866, (float)0.464478, (float)0.643188,\n(float)0.248535, (float)0.429932, (float)0.626099,\n(float)0.236206, (float)0.491333, (float)0.817139,\n(float)0.334961, (float)0.625122, (float)0.895752,\n(float)0.343018, (float)0.518555, (float)0.698608,\n(float)0.372803, (float)0.659790, (float)0.945435,\n(float)0.176880, (float)0.316528, (float)0.581421,\n(float)0.416382, (float)0.625977, (float)0.805176,\n(float)0.303223, (float)0.568726, (float)0.915039,\n(float)0.203613, (float)0.351440, (float)0.588135,\n(float)0.221191, (float)0.375000, (float)0.614746,\n(float)0.199951, (float)0.323364, (float)0.476074,\n(float)0.300781, (float)0.433350, (float)0.566895,\n(float)0.226196, (float)0.354004, (float)0.507568,\n(float)0.300049, (float)0.508179, (float)0.711670,\n(float)0.312012, (float)0.492676, (float)0.763428,\n(float)0.329956, (float)0.541016, (float)0.795776,\n(float)0.373779, (float)0.604614, (float)0.928833,\n(float)0.210571, (float)0.452026, (float)0.755249,\n(float)0.271118, (float)0.473267, (float)0.662476,\n(float)0.285522, (float)0.436890, (float)0.634399,\n(float)0.246704, (float)0.565552, (float)0.859009,\n(float)0.270508, (float)0.406250, (float)0.553589,\n(float)0.361450, (float)0.578491, (float)0.813843,\n(float)0.342651, (float)0.482788, (float)0.622437,\n(float)0.340332, (float)0.549438, (float)0.743164,\n(float)0.200439, (float)0.336304, (float)0.540894,\n(float)0.407837, (float)0.644775, (float)0.895142,\n(float)0.294678, (float)0.454834, (float)0.699097,\n(float)0.193115, (float)0.344482, (float)0.643188,\n(float)0.275757, (float)0.420776, (float)0.598755,\n(float)0.380493, (float)0.608643, (float)0.861084,\n(float)0.222778, (float)0.426147, (float)0.676514,\n(float)0.407471, (float)0.700195, (float)1.053101,\n(float)0.218384, (float)0.377197, (float)0.669922,\n(float)0.313232, (float)0.454102, (float)0.600952,\n(float)0.347412, (float)0.571533, (float)0.874146,\n(float)0.238037, (float)0.405396, (float)0.729492,\n(float)0.223877, (float)0.412964, (float)0.822021,\n(float)0.395264, (float)0.582153, (float)0.743896,\n   (float)0.247925, (float)0.485596, (float)0.720581,\n(float)0.229126, (float)0.496582, (float)0.907715,\n(float)0.260132, (float)0.566895, (float)1.012695,\n(float)0.337402, (float)0.611572, (float)0.978149,\n(float)0.267822, (float)0.447632, (float)0.769287,\n(float)0.250610, (float)0.381714, (float)0.530029,\n(float)0.430054, (float)0.805054, (float)1.221924,\n(float)0.382568, (float)0.544067, (float)0.701660,\n(float)0.383545, (float)0.710327, (float)1.149170,\n(float)0.271362, (float)0.529053, (float)0.775513,\n(float)0.246826, (float)0.393555, (float)0.588623,\n(float)0.266846, (float)0.422119, (float)0.676758,\n(float)0.311523, (float)0.580688, (float)0.838623,\n(float)1.331177, (float)1.576782, (float)1.779541,\n(float)1.160034, (float)1.401978, (float)1.768188,\n(float)1.161865, (float)1.525146, (float)1.715332,\n(float)0.759521, (float)0.913940, (float)1.119873,\n(float)0.947144, (float)1.121338, (float)1.282471,\n(float)1.015015, (float)1.557007, (float)1.804932,\n(float)1.172974, (float)1.402100, (float)1.692627,\n(float)1.087524, (float)1.474243, (float)1.665405,\n(float)0.899536, (float)1.105225, (float)1.406250,\n(float)1.148438, (float)1.484741, (float)1.796265,\n(float)0.785645, (float)1.209839, (float)1.567749,\n(float)0.867798, (float)1.166504, (float)1.450684,\n(float)0.922485, (float)1.229858, (float)1.420898,\n(float)0.791260, (float)1.123291, (float)1.409546,\n(float)0.788940, (float)0.966064, (float)1.340332,\n(float)1.051147, (float)1.272827, (float)1.556641,\n(float)0.866821, (float)1.181152, (float)1.538818,\n(float)0.906738, (float)1.373535, (float)1.607910,\n(float)1.244751, (float)1.581421, (float)1.933838,\n(float)0.913940, (float)1.337280, (float)1.539673,\n(float)0.680542, (float)0.959229, (float)1.662720,\n(float)0.887207, (float)1.430542, (float)1.800781,\n(float)0.912598, (float)1.433594, (float)1.683960,\n(float)0.860474, (float)1.060303, (float)1.455322,\n(float)1.005127, (float)1.381104, (float)1.706909,\n(float)0.800781, (float)1.363892, (float)1.829102,\n(float)0.781860, (float)1.124390, (float)1.505981,\n(float)1.003662, (float)1.471436, (float)1.684692,\n(float)0.981323, (float)1.309570, (float)1.618042,\n(float)1.228760, (float)1.554321, (float)1.756470,\n(float)0.734375, (float)0.895752, (float)1.225586,\n(float)0.841797, (float)1.055664, (float)1.249268,\n(float)0.920166, (float)1.119385, (float)1.486206,\n(float)0.894409, (float)1.539063, (float)1.828979,\n(float)1.283691, (float)1.543335, (float)1.858276,\n   (float)0.676025, (float)0.933105, (float)1.490845,\n(float)0.821289, (float)1.491821, (float)1.739868,\n(float)0.923218, (float)1.144653, (float)1.580566,\n(float)1.057251, (float)1.345581, (float)1.635864,\n(float)0.888672, (float)1.074951, (float)1.353149,\n(float)0.942749, (float)1.195435, (float)1.505493,\n(float)1.492310, (float)1.788086, (float)2.039673,\n(float)1.070313, (float)1.634399, (float)1.860962,\n(float)1.253296, (float)1.488892, (float)1.686035,\n(float)0.647095, (float)0.864014, (float)1.401855,\n(float)0.866699, (float)1.254883, (float)1.453369,\n(float)1.063965, (float)1.532593, (float)1.731323,\n(float)1.167847, (float)1.521484, (float)1.884033,\n(float)0.956055, (float)1.502075, (float)1.745605,\n(float)0.928711, (float)1.288574, (float)1.479614,\n(float)1.088013, (float)1.380737, (float)1.570801,\n(float)0.905029, (float)1.186768, (float)1.371948,\n(float)1.057861, (float)1.421021, (float)1.617432,\n(float)1.108276, (float)1.312500, (float)1.501465,\n(float)0.979492, (float)1.416992, (float)1.624268,\n(float)1.276001, (float)1.661011, (float)2.007935,\n(float)0.993042, (float)1.168579, (float)1.331665,\n(float)0.778198, (float)0.944946, (float)1.235962,\n(float)1.223755, (float)1.491333, (float)1.815674,\n(float)0.852661, (float)1.350464, (float)1.722290,\n(float)1.134766, (float)1.593140, (float)1.787354,\n(float)1.051392, (float)1.339722, (float)1.531006,\n(float)0.803589, (float)1.271240, (float)1.652100,\n(float)0.755737, (float)1.143555, (float)1.639404,\n(float)0.700928, (float)0.837280, (float)1.130371,\n(float)0.942749, (float)1.197876, (float)1.669800,\n(float)0.993286, (float)1.378296, (float)1.566528,\n(float)0.801025, (float)1.095337, (float)1.298950,\n(float)0.739990, (float)1.032959, (float)1.383667,\n(float)0.845703, (float)1.072266, (float)1.543823,\n(float)0.915649, (float)1.072266, (float)1.224487,\n(float)1.021973, (float)1.226196, (float)1.481323,\n(float)0.999878, (float)1.204102, (float)1.555908,\n(float)0.722290, (float)0.913940, (float)1.340210,\n(float)0.673340, (float)0.835938, (float)1.259521,\n(float)0.832397, (float)1.208374, (float)1.394165,\n(float)0.962158, (float)1.576172, (float)1.912842,\n(float)1.166748, (float)1.370850, (float)1.556763,\n(float)0.946289, (float)1.138550, (float)1.400391,\n(float)1.035034, (float)1.218262, (float)1.386475,\n(float)1.393799, (float)1.717773, (float)2.000244,\n(float)0.972656, (float)1.260986, (float)1.760620,\n(float)1.028198, (float)1.288452, (float)1.484619,\n   (float)0.773560, (float)1.258057, (float)1.756714,\n(float)1.080322, (float)1.328003, (float)1.742676,\n(float)0.823975, (float)1.450806, (float)1.917725,\n(float)0.859009, (float)1.016602, (float)1.191895,\n(float)0.843994, (float)1.131104, (float)1.645020,\n(float)1.189697, (float)1.702759, (float)1.894409,\n(float)1.346680, (float)1.763184, (float)2.066040,\n(float)0.980469, (float)1.253784, (float)1.441650,\n(float)1.338135, (float)1.641968, (float)1.932739,\n(float)1.223267, (float)1.424194, (float)1.626465,\n(float)0.765747, (float)1.004150, (float)1.579102,\n(float)1.042847, (float)1.269165, (float)1.647461,\n(float)0.968750, (float)1.257568, (float)1.555786,\n(float)0.826294, (float)0.993408, (float)1.275146,\n(float)0.742310, (float)0.950439, (float)1.430542,\n(float)1.054321, (float)1.439819, (float)1.828003,\n(float)1.072998, (float)1.261719, (float)1.441895,\n(float)0.859375, (float)1.036377, (float)1.314819,\n(float)0.895752, (float)1.267212, (float)1.605591,\n(float)0.805420, (float)0.962891, (float)1.142334,\n(float)0.795654, (float)1.005493, (float)1.468506,\n(float)1.105347, (float)1.313843, (float)1.584839,\n(float)0.792236, (float)1.221802, (float)1.465698,\n(float)1.170532, (float)1.467651, (float)1.664063,\n(float)0.838257, (float)1.153198, (float)1.342163,\n(float)0.968018, (float)1.198242, (float)1.391235,\n(float)1.250122, (float)1.623535, (float)1.823608,\n(float)0.711670, (float)1.058350, (float)1.512085,\n(float)1.204834, (float)1.454468, (float)1.739136,\n(float)1.137451, (float)1.421753, (float)1.620117,\n(float)0.820435, (float)1.322754, (float)1.578247,\n(float)0.798706, (float)1.005005, (float)1.213867,\n(float)0.980713, (float)1.324951, (float)1.512939,\n(float)1.112305, (float)1.438843, (float)1.735596,\n(float)1.135498, (float)1.356689, (float)1.635742,\n(float)1.101318, (float)1.387451, (float)1.686523,\n(float)0.849854, (float)1.276978, (float)1.523438,\n(float)1.377930, (float)1.627563, (float)1.858154,\n(float)0.884888, (float)1.095459, (float)1.287476,\n(float)1.289795, (float)1.505859, (float)1.756592,\n(float)0.817505, (float)1.384155, (float)1.650513,\n(float)1.446655, (float)1.702148, (float)1.931885,\n(float)0.835815, (float)1.023071, (float)1.385376,\n(float)0.916626, (float)1.139038, (float)1.335327,\n(float)0.980103, (float)1.174072, (float)1.453735,\n(float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,\n(float)1.797119, (float)2.016846, (float)2.445679, (float)2.701904,\n(float)1.990356, (float)2.219116, (float)2.576416, (float)2.813477,\n   (float)1.849365, (float)2.190918, (float)2.611572, (float)2.835083,\n(float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,\n(float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,\n(float)2.028687, (float)2.247314, (float)2.542358, (float)2.875854,\n(float)1.736938, (float)1.922119, (float)2.185913, (float)2.743408,\n(float)1.521606, (float)1.870972, (float)2.526855, (float)2.786987,\n(float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,\n(float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,\n(float)1.746826, (float)2.057373, (float)2.320190, (float)2.800781,\n(float)1.734619, (float)1.940552, (float)2.306030, (float)2.826416,\n(float)1.786255, (float)2.204468, (float)2.457520, (float)2.795288,\n(float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,\n(float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,\n(float)1.784424, (float)2.124146, (float)2.381592, (float)2.645508,\n(float)1.888794, (float)2.135864, (float)2.418579, (float)2.861206,\n(float)2.301147, (float)2.531250, (float)2.724976, (float)2.913086,\n(float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,\n(float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,\n(float)1.429565, (float)1.858276, (float)2.582275, (float)2.845703,\n(float)1.622803, (float)1.897705, (float)2.367310, (float)2.621094,\n(float)1.581543, (float)1.960449, (float)2.515869, (float)2.736450,\n(float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,\n(float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,\n(float)1.911011, (float)2.220703, (float)2.461060, (float)2.740723,\n(float)1.581177, (float)1.860840, (float)2.516968, (float)2.874634,\n(float)1.870361, (float)2.098755, (float)2.432373, (float)2.656494,\n(float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,\n(float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,\n(float)1.407959, (float)1.768311, (float)2.343018, (float)2.668091,\n(float)2.168701, (float)2.394653, (float)2.604736, (float)2.829346,\n(float)1.636230, (float)1.865723, (float)2.329102, (float)2.824219,\n(float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,\n(float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,\n(float)2.164795, (float)2.410889, (float)2.673706, (float)2.903198,\n(float)2.071899, (float)2.331055, (float)2.645874, (float)2.907104,\n(float)2.026001, (float)2.311523, (float)2.594849, (float)2.863892,\n(float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,\n(float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,\n(float)2.238159, (float)2.452759, (float)2.652832, (float)2.868286,\n(float)1.897949, (float)2.101685, (float)2.524292, (float)2.880127,\n(float)1.856445, (float)2.074585, (float)2.541016, (float)2.791748,\n(float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,\n(float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,\n(float)1.568848, (float)1.786499, (float)2.194580, (float)2.768555,\n(float)1.953369, (float)2.164551, (float)2.486938, (float)2.874023,\n(float)1.388306, (float)1.725342, (float)2.384521, (float)2.771851,\n(float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,\n(float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307,\n   (float)1.882568, (float)2.332031, (float)2.598267, (float)2.827637,\n(float)1.683594, (float)2.088745, (float)2.361938, (float)2.608643,\n(float)1.874023, (float)2.182129, (float)2.536133, (float)2.766968,\n(float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,\n(float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,\n(float)1.926880, (float)2.184692, (float)2.442627, (float)2.663818,\n(float)2.123901, (float)2.337280, (float)2.553101, (float)2.777466,\n(float)1.588135, (float)1.911499, (float)2.212769, (float)2.543945,\n(float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,\n(float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,\n(float)2.199463, (float)2.474731, (float)2.718262, (float)2.919922,\n(float)1.960083, (float)2.175415, (float)2.608032, (float)2.888794,\n(float)1.953735, (float)2.185181, (float)2.428223, (float)2.809570,\n(float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,\n(float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,\n(float)1.824951, (float)2.267456, (float)2.514526, (float)2.747925,\n(float)1.994263, (float)2.229126, (float)2.475220, (float)2.833984,\n(float)1.746338, (float)2.011353, (float)2.588257, (float)2.826904,\n(float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,\n(float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,\n(float)1.758057, (float)2.131470, (float)2.636597, (float)2.891602,\n(float)2.071289, (float)2.299072, (float)2.550781, (float)2.814331,\n(float)1.839600, (float)2.094360, (float)2.496460, (float)2.723999,\n(float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,\n(float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,\n(float)1.992920, (float)2.351196, (float)2.654419, (float)2.889771,\n(float)2.012817, (float)2.262451, (float)2.643799, (float)2.903076,\n(float)2.025635, (float)2.254761, (float)2.508423, (float)2.784058,\n(float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,\n(float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,\n(float)1.845337, (float)2.055786, (float)2.348511, (float)2.822021,\n(float)1.679932, (float)1.926514, (float)2.499756, (float)2.835693,\n(float)1.722534, (float)1.946899, (float)2.448486, (float)2.728760,\n(float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,\n(float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,\n(float)1.791504, (float)2.113525, (float)2.469727, (float)2.784058,\n(float)1.977051, (float)2.215088, (float)2.497437, (float)2.726929,\n(float)1.800171, (float)2.106689, (float)2.357788, (float)2.738892,\n(float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,\n(float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,\n(float)1.916748, (float)2.225098, (float)2.542603, (float)2.857666,\n(float)1.761230, (float)1.976074, (float)2.507446, (float)2.884521,\n(float)2.053711, (float)2.367432, (float)2.608032, (float)2.837646,\n(float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,\n(float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,\n(float)1.801392, (float)2.128052, (float)2.399780, (float)2.822876,\n(float)1.853638, (float)2.066650, (float)2.429199, (float)2.751465,\n(float)1.956299, (float)2.163696, (float)2.394775, (float)2.734253,\n   (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,\n(float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,\n(float)2.120117, (float)2.443359, (float)2.733887, (float)2.941406,\n(float)1.506348, (float)1.766968, (float)2.400513, (float)2.851807,\n(float)1.664551, (float)1.981079, (float)2.375732, (float)2.774414,\n(float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,\n(float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,\n(float)1.769043, (float)2.136597, (float)2.563721, (float)2.774414,\n(float)1.810791, (float)2.049316, (float)2.373901, (float)2.613647,\n(float)1.788330, (float)2.005981, (float)2.359131, (float)2.723145,\n(float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,\n(float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,\n(float)1.584106, (float)1.965576, (float)2.299927, (float)2.715576,\n(float)1.894897, (float)2.249878, (float)2.655884, (float)2.897705,\n(float)1.720581, (float)1.995728, (float)2.299438, (float)2.557007,\n(float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,\n(float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,\n(float)1.447632, (float)2.045044, (float)2.555542, (float)2.744873,\n(float)1.502686, (float)2.156616, (float)2.653320, (float)2.846558,\n(float)1.711548, (float)1.944092, (float)2.282959, (float)2.685791,\n(float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,\n(float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,\n(float)1.498047, (float)1.711182, (float)2.223267, (float)2.755127,\n(float)1.808716, (float)1.997559, (float)2.256470, (float)2.758545,\n(float)2.088501, (float)2.402710, (float)2.667358, (float)2.890259,\n(float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,\n(float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,\n(float)1.786499, (float)2.041748, (float)2.290405, (float)2.650757,\n(float)1.938232, (float)2.264404, (float)2.529053, (float)2.796143\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.9. anaFilter.h",
      "section_title": true,
      "ja": "A.9. anaFilter.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "anaFilter.h",
      "ja": "anaFilter.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ANAFILTER_H #define __iLBC_ANAFILTER_H",
      "ja": "#ifndef __iLBC_ANAFILTER_H #define __iLBC_ANAFILTER_H"
    },
    {
      "indent": 3,
      "text": "void anaFilter(",
      "ja": "void anaFilter("
    },
    {
      "indent": 3,
      "text": "    float *In,  /* (i) Signal to be filtered */\n    float *a,   /* (i) LP parameters */\n    int len,/* (i) Length of signal */\n    float *Out, /* (o) Filtered signal */\n    float *mem  /* (i/o) Filter state */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.10. anaFilter.c",
      "section_title": true,
      "ja": "A.10. anaFilter.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "anaFilter.c",
      "ja": "anaFilter.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <string.h>\n#include \"iLBC_define.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  LP analysis filter.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void anaFilter(\n    float *In,  /* (i) Signal to be filtered */\n    float *a,   /* (i) LP parameters */\n    int len,/* (i) Length of signal */\n    float *Out, /* (o) Filtered signal */\n    float *mem  /* (i/o) Filter state */\n){\n    int i, j;\n    float *po, *pi, *pm, *pa;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "po = Out;",
      "ja": "po = アウト;"
    },
    {
      "indent": 7,
      "text": "/* Filter first part using memory from past */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    pi = &In[i];\n    pm = &mem[LPC_FILTERORDER-1];\n    pa = a;\n    *po=0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (j=0; j<=i; j++) {\n    *po+=(*pa++)*(*pi--);\n}\nfor (j=i+1; j<LPC_FILTERORDER+1; j++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        *po+=(*pa++)*(*pm--);\n    }\n    po++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Filter last part where the state is entirely\n   in the input vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=LPC_FILTERORDER; i<len; i++) {\n    pi = &In[i];\n    pa = a;\n    *po=0.0;\n    for (j=0; j<LPC_FILTERORDER+1; j++) {\n        *po+=(*pa++)*(*pi--);\n    }\n    po++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Update state vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    memcpy(mem, &In[len-LPC_FILTERORDER],\n        LPC_FILTERORDER*sizeof(float));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.11. createCB.h",
      "section_title": true,
      "ja": "A.11. createCB.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "createCB.h",
      "ja": "createCB.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_CREATECB_H #define __iLBC_CREATECB_H",
      "ja": "#ifndef __iLBC_CREATECB_H #define __iLBC_CREATECB_H"
    },
    {
      "indent": 3,
      "text": "void filteredCBvecs(\n    float *cbvectors,   /* (o) Codebook vector for the\n                               higher section */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    float *mem,         /* (i) Buffer to create codebook\n                               vectors from */\n    int lMem        /* (i) Length of buffer */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void searchAugmentedCB(\n    int low,        /* (i) Start index for the search */\n    int high,           /* (i) End index for the search */\n    int stage,          /* (i) Current stage */\n    int startIndex,     /* (i) CB index for the first\n                               augmented vector */\n    float *target,      /* (i) Target vector for encoding */\n    float *buffer,      /* (i) Pointer to the end of the\n                               buffer for augmented codebook\n                               construction */\n    float *max_measure, /* (i/o) Currently maximum measure */\n    int *best_index,/* (o) Currently the best index */\n    float *gain,    /* (o) Currently the best gain */\n    float *energy,      /* (o) Energy of augmented\n                               codebook vectors */\n    float *invenergy/* (o) Inv energy of aug codebook\n                               vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void createAugmentedVec(\n    int index,          /* (i) Index for the aug vector\n                               to be created */\n    float *buffer,      /* (i) Pointer to the end of the\n                               buffer for augmented codebook\n                               construction */\n    float *cbVec    /* (o) The construced codebook vector */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.12. createCB.c",
      "section_title": true,
      "ja": "A.12. createCB.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "createCB.c",
      "ja": "createCB.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"\n#include \"constants.h\"\n#include <string.h>\n#include <math.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct an additional codebook vector by filtering the\n *  initial codebook buffer. This vector is then used to expand\n *  the codebook with an additional section.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void filteredCBvecs(\n    float *cbvectors,   /* (o) Codebook vectors for the\n                               higher section */\n    float *mem,         /* (i) Buffer to create codebook\n                               vector from */\n    int lMem        /* (i) Length of buffer */\n){\n    int j, k;\n    float *pp, *pp1;\n    float tempbuff2[CB_MEML+CB_FILTERLEN];\n    float *pos;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Create codebook vector for higher section by filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    /* do filtering */\n    pos=cbvectors;\n    memset(pos, 0, lMem*sizeof(float));\n    for (k=0; k<lMem; k++) {\n        pp=&tempbuff2[k];\n        pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n        for (j=0;j<CB_FILTERLEN;j++) {\n            (*pos)+=(*pp++)*(*pp1--);\n        }\n        pos++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Search the augmented part of the codebook to find the best\n *  measure.\n *----------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void searchAugmentedCB(\n    int low,        /* (i) Start index for the search */\n    int high,           /* (i) End index for the search */\n    int stage,          /* (i) Current stage */\n    int startIndex,     /* (i) Codebook index for the first\n                               aug vector */\n    float *target,      /* (i) Target vector for encoding */\n    float *buffer,      /* (i) Pointer to the end of the buffer for\n                               augmented codebook construction */\n    float *max_measure, /* (i/o) Currently maximum measure */\n    int *best_index,/* (o) Currently the best index */\n    float *gain,    /* (o) Currently the best gain */\n    float *energy,      /* (o) Energy of augmented codebook\n                               vectors */\n    float *invenergy/* (o) Inv energy of augmented codebook\n                               vectors */\n) {\n    int icount, ilow, j, tmpIndex;\n    float *pp, *ppo, *ppi, *ppe, crossDot, alfa;\n    float weighted, measure, nrjRecursive;\n    float ftmp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Compute the energy for the first (low-5)\n   noninterpolated samples */\nnrjRecursive = (float) 0.0;\npp = buffer - low + 1;\nfor (j=0; j<(low-5); j++) {\n    nrjRecursive += ( (*pp)*(*pp) );\n    pp++;\n}\nppe = buffer - low;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (icount=low; icount<=high; icount++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Index of the codebook vector used for retrieving\n   energy values */\ntmpIndex = startIndex+icount-20;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "ilow = icount-4;",
      "ja": "ilow = icount-4;"
    },
    {
      "indent": 11,
      "text": "/* Update the energy recursively to save complexity */\nnrjRecursive = nrjRecursive + (*ppe)*(*ppe);\nppe--;\nenergy[tmpIndex] = nrjRecursive;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Compute cross dot product for the first (low-5)\n   samples */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "crossDot = (float) 0.0;\npp = buffer-icount;\nfor (j=0; j<ilow; j++) {\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* interpolation */\nalfa = (float) 0.2;\nppo = buffer-4;\nppi = buffer-icount-4;\nfor (j=ilow; j<icount; j++) {\n    weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n    ppo++;\n    ppi++;\n    energy[tmpIndex] += weighted*weighted;\n    crossDot += target[j]*weighted;\n    alfa += (float)0.2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Compute energy and cross dot product for the\n   remaining samples */\npp = buffer - icount;\nfor (j=icount; j<SUBL; j++) {\n    energy[tmpIndex] += (*pp)*(*pp);\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (energy[tmpIndex]>0.0) {\n    invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);\n} else {\n    invenergy[tmpIndex] = (float) 0.0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (stage==0) {\n    measure = (float)-10000000.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*invenergy[tmpIndex];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[tmpIndex];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[tmpIndex];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ((measure>*max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            *best_index = tmpIndex;\n            *max_measure = measure;\n            *gain = ftmp;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Recreate a specific codebook vector from the augmented part.\n *\n *----------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void createAugmentedVec(\n    int index,      /* (i) Index for the augmented vector\n                           to be created */\n    float *buffer,  /* (i) Pointer to the end of the buffer for\n                           augmented codebook construction */\n    float *cbVec/* (o) The construced codebook vector */\n) {\n    int ilow, j;\n    float *pp, *ppo, *ppi, alfa, alfa1, weighted;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ilow = index-5;",
      "ja": "ilow = インデックス-5;"
    },
    {
      "indent": 7,
      "text": "/* copy the first noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pp = buffer-index;\nmemcpy(cbVec,pp,sizeof(float)*index);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* interpolation */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "alfa1 = (float)0.2;\nalfa = 0.0;\nppo = buffer-5;\nppi = buffer-index-5;\nfor (j=ilow; j<index; j++) {\n    weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n    ppo++;\n    ppi++;\n    cbVec[j] = weighted;\n    alfa += alfa1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* copy the second noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pp = buffer - index;\nmemcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "A.13. doCPLC.h",
      "section_title": true,
      "ja": "A.13. doCPLC.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "doCPLC.h",
      "ja": "doCPLC.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_DOLPC_H #define __iLBC_DOLPC_H",
      "ja": "#ifndef __iLBC_DOLPC_H #define __iLBC_DOLPC_H"
    },
    {
      "indent": 3,
      "text": "void doThePLC(\n    float *PLCresidual, /* (o) concealed residual */\n    float *PLClpc,      /* (o) concealed LP parameters */\n    int PLI,        /* (i) packet loss indicator\n                               0 - no PL, 1 = PL */\n    float *decresidual, /* (i) decoded residual */\n    float *lpc,         /* (i) decoded LPC (only used for no PL) */\n    int inlag,          /* (i) pitch lag */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) decoder instance */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.14. doCPLC.c",
      "section_title": true,
      "ja": "A.14. doCPLC.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "doCPLC.c",
      "ja": "doCPLC.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>\n#include <stdio.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Compute cross correlation and pitch gain for pitch prediction\n *  of last subframe at given lag.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void compCorr(\n    float *cc,      /* (o) cross correlation coefficient */\n    float *gc,      /* (o) gain */\n    float *pm,\n    float *buffer,  /* (i) signal buffer */\n    int lag,    /* (i) pitch lag */\n    int bLen,       /* (i) length of buffer */\n    int sRange      /* (i) correlation search length */\n){\n    int i;\n    float ftmp1, ftmp2, ftmp3;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Guard against getting outside buffer */\nif ((bLen-sRange-lag)<0) {\n    sRange=bLen-lag;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ftmp1 = 0.0;\nftmp2 = 0.0;\nftmp3 = 0.0;\nfor (i=0; i<sRange; i++) {\n    ftmp1 += buffer[bLen-sRange+i] *\n        buffer[bLen-sRange+i-lag];\n    ftmp2 += buffer[bLen-sRange+i-lag] *\n            buffer[bLen-sRange+i-lag];\n    ftmp3 += buffer[bLen-sRange+i] *\n            buffer[bLen-sRange+i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (ftmp2 > 0.0) {\n        *cc = ftmp1*ftmp1/ftmp2;\n        *gc = (float)fabs(ftmp1/ftmp2);\n        *pm=(float)fabs(ftmp1)/\n            ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));\n    }\n    else {\n        *cc = 0.0;\n        *gc = 0.0;\n        *pm=0.0;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Packet loss concealment routine. Conceals a residual signal\n *  and LP parameters. If no packet loss, update state.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void doThePLC(\n    float *PLCresidual, /* (o) concealed residual */\n    float *PLClpc,      /* (o) concealed LP parameters */\n    int PLI,        /* (i) packet loss indicator\n                               0 - no PL, 1 = PL */\n    float *decresidual, /* (i) decoded residual */\n    float *lpc,         /* (i) decoded LPC (only used for no PL) */\n    int inlag,          /* (i) pitch lag */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) decoder instance */\n){\n    int lag=20, randlag;\n    float gain, maxcc;\n    float use_gain;\n    float gain_comp, maxcc_comp, per, max_per;\n    int i, pick, use_lag;\n    float ftmp, randvec[BLOCKL_MAX], pitchfact, energy;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Packet Loss */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (PLI == 1) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "iLBCdec_inst->consPLICount += 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* if previous frame not lost,\n   determine pitch pred. gain */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (iLBCdec_inst->prevPLI != 1) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Search around the previous lag to find the\n   best pitch period */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "lag=inlag-3;\ncompCorr(&maxcc, &gain, &max_per,\n    iLBCdec_inst->prevResidual,\n    lag, iLBCdec_inst->blockl, 60);\nfor (i=inlag-2;i<=inlag+3;i++) {\n    compCorr(&maxcc_comp, &gain_comp, &per,\n        iLBCdec_inst->prevResidual,\n        i, iLBCdec_inst->blockl, 60);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if (maxcc_comp>maxcc) {\n    maxcc=maxcc_comp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "        gain=gain_comp;\n        lag=i;\n        max_per=per;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 11,
      "text": "/* previous frame lost, use recorded lag and periodicity */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "else {\n    lag=iLBCdec_inst->prevLag;\n    max_per=iLBCdec_inst->per;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* downscaling */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "use_gain=1.0;\nif (iLBCdec_inst->consPLICount*iLBCdec_inst->blockl>320)\n    use_gain=(float)0.9;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>2*320)\n    use_gain=(float)0.7;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>3*320)\n    use_gain=(float)0.5;\nelse if (iLBCdec_inst->consPLICount*\n                iLBCdec_inst->blockl>4*320)\n    use_gain=(float)0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* mix noise and pitch repeatition */\nftmp=(float)sqrt(max_per);\nif (ftmp>(float)0.7)\n    pitchfact=(float)1.0;\nelse if (ftmp>(float)0.4)\n    pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);\nelse\n    pitchfact=0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* avoid repetition of same pitch cycle */\nuse_lag=lag;\nif (lag<80) {\n    use_lag=2*lag;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* compute concealed residual */\n           energy = 0.0;\nfor (i=0; i<iLBCdec_inst->blockl; i++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* noise component */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "iLBCdec_inst->seed=(iLBCdec_inst->seed*69069L+1) &\n    (0x80000000L-1);\nrandlag = 50 + ((signed long) iLBCdec_inst->seed)%70;\npick = i - randlag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (pick < 0) {\n    randvec[i] =\n        iLBCdec_inst->prevResidual[\n                    iLBCdec_inst->blockl+pick];\n} else {\n    randvec[i] =  randvec[pick];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* pitch repeatition component */\npick = i - use_lag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (pick < 0) {\n    PLCresidual[i] =\n        iLBCdec_inst->prevResidual[\n                    iLBCdec_inst->blockl+pick];\n} else {\n    PLCresidual[i] = PLCresidual[pick];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* mix random and periodicity component */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (i<80)\n    PLCresidual[i] = use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);\nelse if (i<160)\n    PLCresidual[i] = (float)0.95*use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);\nelse\n    PLCresidual[i] = (float)0.9*use_gain*(pitchfact *\n                PLCresidual[i] +\n                ((float)1.0 - pitchfact) * randvec[i]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    energy += PLCresidual[i] * PLCresidual[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* less than 30 dB, use only noise */\n           if (sqrt(energy/(float)iLBCdec_inst->blockl) < 30.0) {\n    gain=0.0;\n    for (i=0; i<iLBCdec_inst->blockl; i++) {\n        PLCresidual[i] = randvec[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* use old LPC */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memcpy(PLClpc,iLBCdec_inst->prevLpc,\n    (LPC_FILTERORDER+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* no packet loss, copy input */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "else {\n    memcpy(PLCresidual, decresidual,\n        iLBCdec_inst->blockl*sizeof(float));\n    memcpy(PLClpc, lpc, (LPC_FILTERORDER+1)*sizeof(float));\n    iLBCdec_inst->consPLICount = 0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* update state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (PLI) {\n    iLBCdec_inst->prevLag = lag;\n    iLBCdec_inst->per=max_per;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    iLBCdec_inst->prevPLI = PLI;\n    memcpy(iLBCdec_inst->prevLpc, PLClpc,\n        (LPC_FILTERORDER+1)*sizeof(float));\n    memcpy(iLBCdec_inst->prevResidual, PLCresidual,\n        iLBCdec_inst->blockl*sizeof(float));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.15. enhancer.h",
      "section_title": true,
      "ja": "A.15. エンハンサー.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "enhancer.h",
      "ja": "エンハンサー.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __ENHANCER_H #define __ENHANCER_H",
      "ja": "#ifndef __ENHANCER_H #define __ENHANCER_H"
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "float xCorrCoef(\n    float *target,      /* (i) first array */\n    float *regressor,   /* (i) second array */\n    int subl        /* (i) dimension arrays */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int enhancerInterface(\n    float *out,         /* (o) the enhanced recidual signal */\n    float *in,          /* (i) the recidual signal to enhance */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i/o) the decoder state structure */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.16. enhancer.c",
      "section_title": true,
      "ja": "A.16. エンハンサー.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "enhancer.c",
      "ja": "エンハンサー.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>\n#include \"iLBC_define.h\"\n#include \"constants.h\"\n#include \"filter.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * Find index in array such that the array element with said\n * index is the element of said array closest to \"value\"\n * according to the squared-error criterion\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void NearestNeighbor(",
      "ja": "void 最近隣("
    },
    {
      "indent": 3,
      "text": "    int   *index,   /* (o) index of array element closest\n                           to value */\n    float *array,   /* (i) data array */\n    float value,/* (i) value */\n    int arlength/* (i) dimension of data array */\n){\n    int i;\n    float bestcrit,crit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "crit=array[0]-value;\nbestcrit=crit*crit;\n*index=0;\nfor (i=1; i<arlength; i++) {\n    crit=array[i]-value;\n    crit=crit*crit;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if (crit<bestcrit) {\n            bestcrit=crit;\n            *index=i;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * compute cross correlation between sequences\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void mycorr1(\n    float* corr,    /* (o) correlation of seq1 and seq2 */\n    float* seq1,    /* (i) first sequence */\n    int dim1,           /* (i) dimension first seq1 */\n    const float *seq2,  /* (i) second sequence */\n    int dim2        /* (i) dimension seq2 */\n){\n    int i,j;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i=0; i<=dim1-dim2; i++) {\n        corr[i]=0.0;\n        for (j=0; j<dim2; j++) {\n            corr[i] += seq1[i+j] * seq2[j];\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * upsample finite array assuming zeros outside bounds\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void enh_upsample(\n    float* useq1,   /* (o) upsampled output sequence */\n    float* seq1,/* (i) unupsampled sequence */\n    int dim1,       /* (i) dimension seq1 */\n    int hfl         /* (i) polyphase filter length=2*hfl+1 */\n){\n    float *pu,*ps;\n    int i,j,k,q,filterlength,hfl2;\n    const float *polyp[ENH_UPS0]; /* pointers to\n                                     polyphase columns */\n    const float *pp;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* define pointers for filter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "filterlength=2*hfl+1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ( filterlength > dim1 ) {\n    hfl2=(int) (dim1/2);\n    for (j=0; j<ENH_UPS0; j++) {\n        polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;\n    }\n    hfl=hfl2;\n    filterlength=2*hfl+1;\n}\nelse {\n    for (j=0; j<ENH_UPS0; j++) {\n        polyp[j]=polyphaserTbl+j*filterlength;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* filtering: filter overhangs left side of sequence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pu=useq1;\nfor (i=hfl; i<filterlength; i++) {\n    for (j=0; j<ENH_UPS0; j++) {\n        *pu=0.0;\n        pp = polyp[j];\n        ps = seq1+i;\n        for (k=0; k<=i; k++) {\n            *pu += *ps-- * *pp++;\n        }\n        pu++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* filtering: simple convolution=inner products */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=filterlength; i<dim1; i++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (j=0;j<ENH_UPS0; j++){\n        *pu=0.0;\n        pp = polyp[j];\n        ps = seq1+i;\n        for (k=0; k<filterlength; k++) {\n            *pu += *ps-- * *pp++;\n        }\n        pu++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* filtering: filter overhangs right side of sequence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (q=1; q<=hfl; q++) {\n        for (j=0; j<ENH_UPS0; j++) {\n            *pu=0.0;\n            pp = polyp[j]+q;\n            ps = seq1+dim1-1;\n            for (k=0; k<filterlength-q; k++) {\n                *pu += *ps-- * *pp++;\n            }\n            pu++;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * find segment starting near idata+estSegPos that has highest\n * correlation with idata+centerStartPos through\n * idata+centerStartPos+ENH_BLOCKL-1 segment is found at a\n * resolution of ENH_UPSO times the original of the original\n * sampling rate\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void refiner(\n    float *seg,         /* (o) segment array */\n    float *updStartPos, /* (o) updated start point */\n    float* idata,       /* (i) original data buffer */\n    int idatal,         /* (i) dimension of idata */\n    int centerStartPos, /* (i) beginning center segment */\n    float estSegPos,/* (i) estimated beginning other segment */\n    float period    /* (i) estimated pitch period */\n){\n    int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;\n    int tloc,tloc2,i,st,en,fraction;\n    float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;\n    float corrVecUps[ENH_CORRDIM*ENH_UPS0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* defining array bounds */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "estSegPosRounded=(int)(estSegPos - 0.5);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "searchSegStartPos=estSegPosRounded-ENH_SLOP;",
      "ja": "searchSegStartPos=estSegPosRounded-ENH_SLOP;"
    },
    {
      "indent": 7,
      "text": "if (searchSegStartPos<0) {\n    searchSegStartPos=0;\n}\nsearchSegEndPos=estSegPosRounded+ENH_SLOP;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (searchSegEndPos+ENH_BLOCKL >= idatal) {\n    searchSegEndPos=idatal-ENH_BLOCKL-1;\n}\ncorrdim=searchSegEndPos-searchSegStartPos+1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* compute upsampled correlation (corr33) and find\n   location of max */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "mycorr1(corrVec,idata+searchSegStartPos,\n    corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);\nenh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);\ntloc=0; maxv=corrVecUps[0];\nfor (i=1; i<ENH_UPS0*corrdim; i++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (corrVecUps[i]>maxv) {\n        tloc=i;\n        maxv=corrVecUps[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* make vector can be upsampled without ever running outside\n   bounds */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "*updStartPos= (float)searchSegStartPos +\n    (float)tloc/(float)ENH_UPS0+(float)1.0;\ntloc2=(int)(tloc/ENH_UPS0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (tloc>tloc2*ENH_UPS0) {\n    tloc2++;\n}\nst=searchSegStartPos+tloc2-ENH_FL0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (st<0) {\n    memset(vect,0,-st*sizeof(float));\n    memcpy(&vect[-st],idata, (ENH_VECTL+st)*sizeof(float));\n}\nelse {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "en=st+ENH_VECTL;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (en>idatal) {\n        memcpy(vect, &idata[st],\n            (ENH_VECTL-(en-idatal))*sizeof(float));\n        memset(&vect[ENH_VECTL-(en-idatal)], 0,\n            (en-idatal)*sizeof(float));\n    }\n    else {\n        memcpy(vect, &idata[st], ENH_VECTL*sizeof(float));\n    }\n}\nfraction=tloc2*ENH_UPS0-tloc;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* compute the segment (this is actually a convolution) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction,\n        2*ENH_FL0+1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * find the smoothed output data\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void smath(\n    float *odata,   /* (o) smoothed output */\n    float *sseq,/* (i) said second sequence of waveforms */\n    int hl,         /* (i) 2*hl+1 is sseq dimension */\n    float alpha0/* (i) max smoothing energy fraction */\n){\n    int i,k;\n    float w00,w10,w11,A,B,C,*psseq,err,errs;\n    float surround[BLOCKL_MAX]; /* shape contributed by other than\n                                   current */\n    float wt[2*ENH_HL+1];       /* waveform weighting to get\n                                   surround shape */\n    float denom;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* create shape of contribution from all waveforms except the\n   current one */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=1; i<=2*hl+1; i++) {\n    wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));\n}\nwt[hl]=0.0; /* for clarity, not used */\nfor (i=0; i<ENH_BLOCKL; i++) {\n    surround[i]=sseq[i]*wt[0];\n}\n       for (k=1; k<hl; k++) {\n    psseq=sseq+k*ENH_BLOCKL;\n    for(i=0;i<ENH_BLOCKL; i++) {\n        surround[i]+=psseq[i]*wt[k];\n    }\n}\nfor (k=hl+1; k<=2*hl; k++) {\n    psseq=sseq+k*ENH_BLOCKL;\n    for(i=0;i<ENH_BLOCKL; i++) {\n        surround[i]+=psseq[i]*wt[k];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* compute some inner products */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "w00 = w10 = w11 = 0.0;\npsseq=sseq+hl*ENH_BLOCKL; /* current block  */\nfor (i=0; i<ENH_BLOCKL;i++) {\n    w00+=psseq[i]*psseq[i];\n    w11+=surround[i]*surround[i];\n    w10+=surround[i]*psseq[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (fabs(w11) < 1.0) {\n    w11=1.0;\n}\nC = (float)sqrt( w00/w11);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* first try enhancement without power-constraint */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "errs=0.0;\npsseq=sseq+hl*ENH_BLOCKL;\nfor (i=0; i<ENH_BLOCKL; i++) {\n    odata[i]=C*surround[i];\n    err=psseq[i]-odata[i];\n    errs+=err*err;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* if constraint violated by first try, add constraint */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (errs > alpha0 * w00) {\n    if ( w00 < 1) {\n        w00=1;\n    }\n    denom = (w11*w00-w10*w10)/(w00*w00);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (denom > 0.0001) { /* eliminates numerical problems\n                         for if smooth */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    A = (float)sqrt( (alpha0- alpha0*alpha0/4)/denom);\n    B = -alpha0/2 - A * w10/w00;\n    B = B+1;\n}\nelse { /* essentially no difference between cycles;\n          smoothing not needed */\n    A= 0.0;\n    B= 1.0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* create smoothed sequence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        psseq=sseq+hl*ENH_BLOCKL;\n        for (i=0; i<ENH_BLOCKL; i++) {\n            odata[i]=A*surround[i]+B*psseq[i];\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * get the pitch-synchronous sample sequence\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void getsseq(\n    float *sseq,    /* (o) the pitch-synchronous sequence */\n    float *idata,       /* (i) original data */\n    int idatal,         /* (i) dimension of data */\n    int centerStartPos, /* (i) where current block starts */\n    float *period,      /* (i) rough-pitch-period array */\n    float *plocs,       /* (i) where periods of period array\n                               are taken */\n    int periodl,    /* (i) dimension period array */\n    int hl              /* (i) 2*hl+1 is the number of sequences */\n){\n    int i,centerEndPos,q;\n    float blockStartPos[2*ENH_HL+1];\n    int lagBlock[2*ENH_HL+1];\n    float plocs2[ENH_PLOCSL];\n    float *psseq;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "centerEndPos=centerStartPos+ENH_BLOCKL-1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* present */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "NearestNeighbor(lagBlock+hl,plocs,\n    (float)0.5*(centerStartPos+centerEndPos),periodl);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "blockStartPos[hl]=(float)centerStartPos;",
      "ja": "blockStartPos[hl]=(float)centerStartPos;"
    },
    {
      "indent": 7,
      "text": "psseq=sseq+ENH_BLOCKL*hl;\nmemcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* past */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (q=hl-1; q>=0; q--) {\n    blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];\n    NearestNeighbor(lagBlock+q,plocs,\n        blockStartPos[q]+\n        ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (blockStartPos[q]-ENH_OVERHANG>=0) {\n        refiner(sseq+q*ENH_BLOCKL, blockStartPos+q, idata,\n            idatal, centerStartPos, blockStartPos[q],\n            period[lagBlock[q+1]]);\n    } else {\n        psseq=sseq+q*ENH_BLOCKL;\n        memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* future */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<periodl; i++) {\n    plocs2[i]=plocs[i]-period[i];\n}\nfor (q=hl+1; q<=2*hl; q++) {\n    NearestNeighbor(lagBlock+q,plocs2,\n        blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];\n        if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG<idatal) {\n            refiner(sseq+ENH_BLOCKL*q, blockStartPos+q, idata,\n                idatal, centerStartPos, blockStartPos[q],\n                period[lagBlock[q]]);\n        }\n        else {\n            psseq=sseq+q*ENH_BLOCKL;\n            memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * perform enhancement on idata+centerStartPos through\n * idata+centerStartPos+ENH_BLOCKL-1\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void enhancer(\n    float *odata,       /* (o) smoothed block, dimension blockl */\n    float *idata,       /* (i) data buffer used for enhancing */\n    int idatal,         /* (i) dimension idata */\n    int centerStartPos, /* (i) first sample current block\n                               within idata */\n    float alpha0,       /* (i) max correction-energy-fraction\n                              (in [0,1]) */\n    float *period,      /* (i) pitch period array */\n    float *plocs,       /* (i) locations where period array\n                               values valid */\n    int periodl         /* (i) dimension of period and plocs */\n){\n    float sseq[(2*ENH_HL+1)*ENH_BLOCKL];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* get said second sequence of segments */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "getsseq(sseq,idata,idatal,centerStartPos,period, plocs,periodl,ENH_HL);",
      "ja": "getseq(sseq,idata,idatal,centerStartPos,period,plocs,periodl,ENH_HL);"
    },
    {
      "indent": 7,
      "text": "/* compute the smoothed output from said second sequence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "smath(odata,sseq,ENH_HL,alpha0);",
      "ja": "smath(odata,sseq,ENH_HL,alpha0);"
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * cross correlation\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float xCorrCoef(\n    float *target,      /* (i) first array */\n    float *regressor,   /* (i) second array */\n    int subl        /* (i) dimension arrays */\n){\n    int i;\n    float ftmp1, ftmp2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ftmp1 = 0.0;\nftmp2 = 0.0;\nfor (i=0; i<subl; i++) {\n    ftmp1 += target[i]*regressor[i];\n    ftmp2 += regressor[i]*regressor[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (ftmp1 > 0.0) {\n        return (float)(ftmp1*ftmp1/ftmp2);\n    }\n       else {\n        return (float)0.0;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * interface for enhancer\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int enhancerInterface(\n    float *out,                     /* (o) enhanced signal */\n    float *in,                      /* (i) unenhanced signal */\n    iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */\n){\n    float *enh_buf, *enh_period;\n    int iblock, isample;\n    int lag=0, ilag, i, ioffset;\n    float cc, maxcc;\n    float ftmp1, ftmp2;\n    float *inPtr, *enh_bufPtr1, *enh_bufPtr2;\n    float plc_pred[ENH_BLOCKL];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];\nint inLen=ENH_NBLOCKS*ENH_BLOCKL+120;\nint start, plc_blockl, inlag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "enh_buf=iLBCdec_inst->enh_buf;\nenh_period=iLBCdec_inst->enh_period;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memmove(enh_buf, &enh_buf[iLBCdec_inst->blockl],\n    (ENH_BUFL-iLBCdec_inst->blockl)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memcpy(&enh_buf[ENH_BUFL-iLBCdec_inst->blockl], in,\n    iLBCdec_inst->blockl*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30)\n    plc_blockl=ENH_BLOCKL;\nelse\n    plc_blockl=40;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* when 20 ms frame, move processing one block */\nioffset=0;\nif (iLBCdec_inst->mode==20) ioffset=1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "i=3-ioffset;\nmemmove(enh_period, &enh_period[i],\n    (ENH_NBLOCKS_TOT-i)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Set state information to the 6 samples right before\n   the samples to be downsampled. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memcpy(lpState,\n    enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126,\n    6*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Down sample a factor 2 to save computations */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120,\n            lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL,\n            lpState, downsampled);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Estimate the pitch in the down sampled domain. */\nfor (iblock = 0; iblock<ENH_NBLOCKS-ioffset; iblock++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "lag = 10;\nmaxcc = xCorrCoef(downsampled+60+iblock*\n    ENH_BLOCKL_HALF, downsampled+60+iblock*\n    ENH_BLOCKL_HALF-lag, ENH_BLOCKL_HALF);\nfor (ilag=11; ilag<60; ilag++) {\n    cc = xCorrCoef(downsampled+60+iblock*\n        ENH_BLOCKL_HALF, downsampled+60+iblock*\n        ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Store the estimated lag in the non-downsampled domain */\nenh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset] = (float)lag*2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* PLC was performed on the previous packet */\nif (iLBCdec_inst->prev_enh_pl==1) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "lag = inlag-1;\nmaxcc = xCorrCoef(in, in+lag, plc_blockl);\nfor (ilag=inlag; ilag<=inlag+1; ilag++) {\n    cc = xCorrCoef(in, in+ilag, plc_blockl);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (cc > maxcc) {\n        maxcc = cc;\n        lag = ilag;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* compute new concealed residual for the old lookahead,\n   mix the forward PLC with a backward PLC from\n   the new frame */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "inPtr=&in[lag-1];",
      "ja": "intPtr=in[lag-1];"
    },
    {
      "indent": 11,
      "text": "enh_bufPtr1=&plc_pred[plc_blockl-1];",
      "ja": "enh_bufPtr1=&plc_pred[plc_blockl-1];"
    },
    {
      "indent": 11,
      "text": "if (lag>plc_blockl) {\n    start=plc_blockl;\n} else {\n    start=lag;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (isample = start; isample>0; isample--) {\n    *enh_bufPtr1-- = *inPtr--;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\nfor (isample = (plc_blockl-1-lag); isample>=0; isample--) {\n    *enh_bufPtr1-- = *enh_bufPtr2--;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* limit energy change */\nftmp2=0.0;\nftmp1=0.0;\nfor (i=0;i<plc_blockl;i++) {\n    ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i]*\n        enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i];\n    ftmp1+=plc_pred[i]*plc_pred[i];\n}\nftmp1=(float)sqrt(ftmp1/(float)plc_blockl);\nftmp2=(float)sqrt(ftmp2/(float)plc_blockl);\nif (ftmp1>(float)2.0*ftmp2 && ftmp1>0.0) {\n    for (i=0;i<plc_blockl-10;i++) {\n        plc_pred[i]*=(float)2.0*ftmp2/ftmp1;\n    }\n    for (i=plc_blockl-10;i<plc_blockl;i++) {\n        plc_pred[i]*=(float)(i-plc_blockl+10)*\n            ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+\n                       (float)2.0*ftmp2/ftmp1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\n    for (i=0; i<plc_blockl; i++) {\n        ftmp1 = (float) (i+1) / (float) (plc_blockl+1);\n        *enh_bufPtr1 *= ftmp1;\n        *enh_bufPtr1 += ((float)1.0-ftmp1)*\n                            plc_pred[plc_blockl-1-i];\n        enh_bufPtr1--;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==20) {\n    /* Enhancer with 40 samples delay */\n    for (iblock = 0; iblock<2; iblock++) {\n        enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n            ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,\n            ENH_ALPHA0, enh_period, enh_plocsTbl,\n                ENH_NBLOCKS_TOT);\n    }\n} else if (iLBCdec_inst->mode==30) {\n    /* Enhancer with 80 samples delay */\n    for (iblock = 0; iblock<3; iblock++) {\n        enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n            ENH_BUFL, (4+iblock)*ENH_BLOCKL,\n            ENH_ALPHA0, enh_period, enh_plocsTbl,\n                ENH_NBLOCKS_TOT);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return (lag*2); }",
      "ja": "リターン (ラグ*2);}"
    },
    {
      "indent": 0,
      "text": "A.17. filter.h",
      "section_title": true,
      "ja": "A.17. フィルター.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "filter.h",
      "ja": "フィルター.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_FILTER_H #define __iLBC_FILTER_H",
      "ja": "#ifndef __iLBC_FILTER_H #define __iLBC_FILTER_H"
    },
    {
      "indent": 3,
      "text": "void AllPoleFilter(\n    float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to\n                           InOut[-1] contain the state of the\n                           filter (delayed samples). InOut[0] to\n                           InOut[lengthInOut-1] contain the filter\n                           input, on en exit InOut[-orderCoef] to\n                           InOut[-1] is unchanged and InOut[0] to\n                           InOut[lengthInOut-1] contain filtered\n                           samples */\n    float *Coef,/* (i) filter coefficients, Coef[0] is assumed\n                           to be 1.0 */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef   /* (i) number of filter coefficients */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void AllZeroFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples */\n    float *Coef,/* (i) filter coefficients (Coef[0] is assumed\n                           to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain the filter state, on exit Out[0]\n                           to Out[lengthInOut-1] contain filtered\n                           samples */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void ZeroPoleFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain filter\n                           input samples In[-orderCoef] to In[-1]\n                           contain state of all-zero section */\n    float *ZeroCoef,/* (i) filter coefficients for all-zero\n                           section (ZeroCoef[0] is assumed to\n                           be 1.0) */\n    float *PoleCoef,/* (i) filter coefficients for all-pole section\n                           (ZeroCoef[0] is assumed to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain state of all-pole section. On\n                           exit Out[0] to Out[lengthInOut-1]\n                           contain filtered samples */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void DownSample (\n    float  *In,     /* (i) input samples */\n    float  *Coef,   /* (i) filter coefficients */\n    int lengthIn,   /* (i) number of input samples */\n    float  *state,  /* (i) filter state */\n    float  *Out     /* (o) downsampled output */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.18. filter.c",
      "section_title": true,
      "ja": "A.18. フィルター.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "filter.c",
      "ja": "フィルター.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  all-pole filter\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void AllPoleFilter(\n    float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to\n                           InOut[-1] contain the state of the\n                           filter (delayed samples). InOut[0] to\n                           InOut[lengthInOut-1] contain the filter\n                           input, on en exit InOut[-orderCoef] to\n                           InOut[-1] is unchanged and InOut[0] to\n                           InOut[lengthInOut-1] contain filtered\n                           samples */\n    float *Coef,/* (i) filter coefficients, Coef[0] is assumed\n                           to be 1.0 */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef   /* (i) number of filter coefficients */\n){\n    int n,k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for(n=0;n<lengthInOut;n++){\n    for(k=1;k<=orderCoef;k++){\n        *InOut -= Coef[k]*InOut[-k];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        }\n        InOut++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  all-zero filter\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void AllZeroFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples */\n    float *Coef,/* (i) filter coefficients (Coef[0] is assumed\n                           to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n    int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain the filter state, on exit Out[0]\n                           to Out[lengthInOut-1] contain filtered\n                           samples */\n){\n    int n,k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for(n=0;n<lengthInOut;n++){\n        *Out = Coef[0]*In[0];\n        for(k=1;k<=orderCoef;k++){\n            *Out += Coef[k]*In[-k];\n        }\n        Out++;\n        In++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  pole-zero filter\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void ZeroPoleFilter(\n    float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n                           filter input samples In[-orderCoef] to\n                           In[-1] contain state of all-zero\n                           section */\n    float *ZeroCoef,/* (i) filter coefficients for all-zero\n                           section (ZeroCoef[0] is assumed to\n                           be 1.0) */\n    float *PoleCoef,/* (i) filter coefficients for all-pole section\n                           (ZeroCoef[0] is assumed to be 1.0) */\n    int lengthInOut,/* (i) number of input/output samples */\n       int orderCoef,  /* (i) number of filter coefficients */\n    float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                           contain state of all-pole section. On\n                           exit Out[0] to Out[lengthInOut-1]\n                           contain filtered samples */\n){\n    AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);\n    AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n * downsample (LP filter and decimation)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void DownSample (\n    float  *In,     /* (i) input samples */\n    float  *Coef,   /* (i) filter coefficients */\n    int lengthIn,   /* (i) number of input samples */\n    float  *state,  /* (i) filter state */\n    float  *Out     /* (o) downsampled output */\n){\n    float   o;\n    float *Out_ptr = Out;\n    float *Coef_ptr, *In_ptr;\n    float *state_ptr;\n    int i, j, stop;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* LP filter and decimate at the same time */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i = DELAY_DS; i < lengthIn; i+=FACTOR_DS)\n{\n    Coef_ptr = &Coef[0];\n    In_ptr = &In[i];\n    state_ptr = &state[FILTERORDER_DS-2];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "o = (float)0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (j = 0; j < stop; j++)\n{\n    o += *Coef_ptr++ * (*In_ptr--);\n}\nfor (j = i + 1; j < FILTERORDER_DS; j++)\n{\n    o += *Coef_ptr++ * (*state_ptr--);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    *Out_ptr++ = o;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Get the last part (use zeros as input for the future) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=(lengthIn+FACTOR_DS); i<(lengthIn+DELAY_DS);\n        i+=FACTOR_DS) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "o=(float)0.0;",
      "ja": "o=(浮動小数点)0.0;"
    },
    {
      "indent": 3,
      "text": "        if (i<lengthIn) {\n            Coef_ptr = &Coef[0];\n            In_ptr = &In[i];\n            for (j=0; j<FILTERORDER_DS; j++) {\n                    o += *Coef_ptr++ * (*Out_ptr--);\n            }\n        } else {\n            Coef_ptr = &Coef[i-lengthIn];\n            In_ptr = &In[lengthIn-1];\n            for (j=0; j<FILTERORDER_DS-(i-lengthIn); j++) {\n                    o += *Coef_ptr++ * (*In_ptr--);\n            }\n        }\n        *Out_ptr++ = o;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.19. FrameClassify.h",
      "section_title": true,
      "ja": "A.19. FrameClassify.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "FrameClassify.h",
      "ja": "FrameClassify.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_FRAMECLASSIFY_H #define __iLBC_FRAMECLASSIFY_H",
      "ja": "#ifndef __iLBC_FRAMECLASSIFY_H #define __iLBC_FRAMECLASSIFY_H"
    },
    {
      "indent": 3,
      "text": "int FrameClassify(      /* index to the max-energy sub-frame */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i/o) the encoder state structure */\n    float *residual     /* (i) lpc residual signal */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.20. FrameClassify.c",
      "section_title": true,
      "ja": "A.20. FrameClassify.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "FrameClassify.c",
      "ja": "FrameClassify.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  Classification of subframes to localize start state\n *--------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int FrameClassify(      /* index to the max-energy sub-frame */\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i/o) the encoder state structure */\n    float *residual     /* (i) lpc residual signal */\n) {\n    float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;\n    int n, l, max_ssqEn_n;\n    const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,\n        (float)1.0,(float)0.9,(float)0.8};\n    const float sampEn_win[5]={(float)1.0/(float)6.0,\n        (float)2.0/(float)6.0, (float)3.0/(float)6.0,\n        (float)4.0/(float)6.0, (float)5.0/(float)6.0};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* init the front and back energies to zero */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(fssqEn, 0, NSUB_MAX*sizeof(float));\nmemset(bssqEn, 0, NSUB_MAX*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate front of first seqence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "n=0;\npp=residual;\nfor (l=0; l<5; l++) {\n    fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);\n    pp++;\n}\nfor (l=5; l<SUBL; l++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    fssqEn[n] += (*pp) * (*pp);\n    pp++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate front and back of all middle sequences */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (n=1; n<iLBCenc_inst->nsub-1; n++) {\n    pp=residual+n*SUBL;\n    for (l=0; l<5; l++) {\n        fssqEn[n] += sampEn_win[l] * (*pp) * (*pp);\n        bssqEn[n] += (*pp) * (*pp);\n        pp++;\n    }\n    for (l=5; l<SUBL-5; l++) {\n        fssqEn[n] += (*pp) * (*pp);\n        bssqEn[n] += (*pp) * (*pp);\n        pp++;\n    }\n    for (l=SUBL-5; l<SUBL; l++) {\n        fssqEn[n] += (*pp) * (*pp);\n        bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);\n        pp++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Calculate back of last seqence */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "n=iLBCenc_inst->nsub-1;\npp=residual+n*SUBL;\nfor (l=0; l<SUBL-5; l++) {\n    bssqEn[n] += (*pp) * (*pp);\n    pp++;\n}\nfor (l=SUBL-5; l<SUBL; l++) {\n    bssqEn[n] += sampEn_win[SUBL-l-1] * (*pp) * (*pp);\n    pp++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* find the index to the weighted 80 sample with\n   most energy */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==20) l=1;\nelse                        l=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];\nmax_ssqEn_n=1;\nfor (n=2; n<iLBCenc_inst->nsub; n++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    l++;\n    if ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] > max_ssqEn) {\n        max_ssqEn=(fssqEn[n-1]+bssqEn[n]) *\n                        ssqEn_win[l];\n        max_ssqEn_n=n;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return max_ssqEn_n; }",
      "ja": "max_ssqEn_n を返します。}"
    },
    {
      "indent": 0,
      "text": "A.21. gainquant.h",
      "section_title": true,
      "ja": "A.21. ゲインクォント.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "gainquant.h",
      "ja": "ゲインクォント.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_GAINQUANT_H #define __iLBC_GAINQUANT_H",
      "ja": "#ifndef __iLBC_GAINQUANT_H #define __iLBC_GAINQUANT_H"
    },
    {
      "indent": 3,
      "text": "float gainquant(/* (o) quantized gain value */\n    float in,       /* (i) gain value */\n    float maxIn,/* (i) maximum of gain value */\n    int cblen,      /* (i) number of quantization indices */\n    int *index      /* (o) quantization index */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float gaindequant(  /* (o) quantized gain value */\n    int index,      /* (i) quantization index */\n    float maxIn,/* (i) maximum of unquantized gain */\n    int cblen       /* (i) number of quantization indices */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.22. gainquant.c",
      "section_title": true,
      "ja": "A.22. ゲインクオント.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code gainquant.c",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード Gainquant.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <string.h>\n#include <math.h>\n#include \"constants.h\"\n#include \"filter.h\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  quantizer for the gain in the gain-shape coding of residual\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float gainquant(/* (o) quantized gain value */\n    float in,       /* (i) gain value */\n    float maxIn,/* (i) maximum of gain value */\n    int cblen,      /* (i) number of quantization indices */\n    int *index      /* (o) quantization index */\n){\n    int i, tindex;\n    float minmeasure,measure, *cb, scale;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* ensure a lower bound on the scaling factor */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "scale=maxIn;",
      "ja": "スケール=最大値;"
    },
    {
      "indent": 7,
      "text": "if (scale<0.1) {\n    scale=(float)0.1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* select the quantization table */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (cblen == 8) {\n    cb = gain_sq3Tbl;\n} else if (cblen == 16) {\n    cb = gain_sq4Tbl;\n} else  {\n    cb = gain_sq5Tbl;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* select the best index in the quantization table */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "minmeasure=10000000.0;\ntindex=0;\nfor (i=0; i<cblen; i++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "measure=(in-scale*cb[i])*(in-scale*cb[i]);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (measure<minmeasure) {\n        tindex=i;\n        minmeasure=measure;\n    }\n}\n*index=tindex;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* return the quantized value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return scale*cb[tindex]; }",
      "ja": "スケール*cb[tindex]を返します;}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  decoder for quantized gains in the gain-shape coding of\n *  residual\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "float gaindequant(  /* (o) quantized gain value */\n    int index,      /* (i) quantization index */\n    float maxIn,/* (i) maximum of unquantized gain */\n    int cblen       /* (i) number of quantization indices */\n){\n    float scale;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* obtain correct scale factor */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "scale=(float)fabs(maxIn);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (scale<0.1) {\n    scale=(float)0.1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* select the quantization table and return the decoded value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (cblen==8) {\n    return scale*gain_sq3Tbl[index];\n} else if (cblen==16) {\n    return scale*gain_sq4Tbl[index];\n}\nelse if (cblen==32) {\n    return scale*gain_sq5Tbl[index];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return 0.0; }",
      "ja": "0.0を返します。}"
    },
    {
      "indent": 0,
      "text": "A.23. getCBvec.h",
      "section_title": true,
      "ja": "A.23. getCBvec.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "getCBvec.h",
      "ja": "getCBvec.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_GETCBVEC_H #define __iLBC_GETCBVEC_H",
      "ja": "#ifndef __iLBC_GETCBVEC_H #define __iLBC_GETCBVEC_H"
    },
    {
      "indent": 3,
      "text": "void getCBvec(\n    float *cbvec,   /* (o) Constructed codebook vector */\n    float *mem,     /* (i) Codebook buffer */\n    int index,      /* (i) Codebook index */\n    int lMem,       /* (i) Length of codebook buffer */\n    int cbveclen/* (i) Codebook vector length */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.24. getCBvec.c",
      "section_title": true,
      "ja": "A.24. getCBvec.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "getCBvec.c",
      "ja": "getCBvec.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"\n#include \"constants.h\"\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct codebook vector for given index.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void getCBvec(",
      "ja": "void getCBvec("
    },
    {
      "indent": 3,
      "text": "    float *cbvec,   /* (o) Constructed codebook vector */\n    float *mem,     /* (i) Codebook buffer */\n    int index,      /* (i) Codebook index */\n    int lMem,       /* (i) Length of codebook buffer */\n    int cbveclen/* (i) Codebook vector length */\n){\n    int j, k, n, memInd, sFilt;\n    float tmpbuf[CB_MEML];\n    int base_size;\n    int ilow, ihigh;\n    float alfa, alfa1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Determine size of codebook sections */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "base_size=lMem-cbveclen+1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (cbveclen==SUBL) {\n    base_size+=cbveclen/2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* No filter -> First codebook section */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (index<lMem-cbveclen+1) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* first non-interpolated vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "k=index+cbveclen;\n/* get vector */\nmemcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "} else if (index < base_size) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "k=2*(index-(lMem-cbveclen+1))+cbveclen;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "ihigh=k/2;\nilow=ihigh-5;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Copy first noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* interpolation */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "alfa1=(float)0.2;\nalfa=0.0;\nfor (j=ilow; j<ihigh; j++) {\n    cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+\n        alfa*mem[lMem-k+j];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    alfa+=alfa1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Copy second noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "memcpy(cbvec+ihigh, mem+lMem-k+ihigh,\n    (cbveclen-ihigh)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* Higher codebook section based on filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "else {",
      "ja": "それ以外 {"
    },
    {
      "indent": 11,
      "text": "/* first non-interpolated vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (index-base_size<lMem-cbveclen+1) {\n    float tempbuff2[CB_MEML+CB_FILTERLEN+1];\n    float *pos;\n    float *pp, *pp1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memset(tempbuff2, 0,\n    CB_HALFFILTERLEN*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN], mem,\n    lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "k=index-base_size+cbveclen;\nsFilt=lMem-k;\nmemInd=sFilt+1-CB_HALFFILTERLEN;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    /* do filtering */\n    pos=cbvec;\n    memset(pos, 0, cbveclen*sizeof(float));\n    for (n=0; n<cbveclen; n++) {\n        pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN];\n        pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n        for (j=0; j<CB_FILTERLEN; j++) {\n            (*pos)+=(*pp++)*(*pp1--);\n        }\n        pos++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* interpolated vectors */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "else {",
      "ja": "それ以外 {"
    },
    {
      "indent": 15,
      "text": "float tempbuff2[CB_MEML+CB_FILTERLEN+1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "float *pos;\nfloat *pp, *pp1;\nint i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memset(tempbuff2, 0,\n    CB_HALFFILTERLEN*sizeof(float));\nmemcpy(&tempbuff2[CB_HALFFILTERLEN], mem,\n    lMem*sizeof(float));\nmemset(&tempbuff2[lMem+CB_HALFFILTERLEN], 0,\n    (CB_HALFFILTERLEN+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "k=2*(index-base_size-\n    (lMem-cbveclen+1))+cbveclen;\nsFilt=lMem-k;\nmemInd=sFilt+1-CB_HALFFILTERLEN;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* do filtering */\npos=&tmpbuf[sFilt];\nmemset(pos, 0, k*sizeof(float));\nfor (i=0; i<k; i++) {\n    pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN];\n    pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n    for (j=0; j<CB_FILTERLEN; j++) {\n        (*pos)+=(*pp++)*(*pp1--);\n    }\n    pos++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "ihigh=k/2;\nilow=ihigh-5;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Copy first noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "memcpy(cbvec, tmpbuf+lMem-k/2,\n    ilow*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* interpolation */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "alfa1=(float)0.2;\nalfa=0.0;\nfor (j=ilow; j<ihigh; j++) {\n    cbvec[j]=((float)1.0-alfa)*\n        tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];\n    alfa+=alfa1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Copy second noninterpolated part */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh,\n                (cbveclen-ihigh)*sizeof(float));\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.25. helpfun.h",
      "section_title": true,
      "ja": "A.25. ヘルプファン.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "helpfun.h",
      "ja": "ヘルプファン.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HELPFUN_H #define __iLBC_HELPFUN_H",
      "ja": "#ifndef __iLBC_HELPFUN_H #define __iLBC_HELPFUN_H"
    },
    {
      "indent": 3,
      "text": "void autocorr(\n    float *r,       /* (o) autocorrelation vector */\n    const float *x, /* (i) data vector */\n    int N,          /* (i) length of data vector */\n    int order       /* largest lag for calculated\n                       autocorrelations */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void window(\n    float *z,       /* (o) the windowed data */\n    const float *x, /* (i) the original data vector */\n    const float *y, /* (i) the window */\n    int N           /* (i) length of all vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void levdurb(\n    float *a,       /* (o) lpc coefficient vector starting\n                           with 1.0 */\n    float *k,       /* (o) reflection coefficients */\n    float *r,       /* (i) autocorrelation vector */\n    int order       /* (i) order of lpc filter */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void interpolate(",
      "ja": "void 補間("
    },
    {
      "indent": 3,
      "text": "    float *out,     /* (o) the interpolated vector */\n    float *in1,     /* (i) the first vector for the\n                           interpolation */\n    float *in2,     /* (i) the second vector for the\n                           interpolation */\n    float coef,     /* (i) interpolation weights */\n    int length      /* (i) length of all vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void bwexpand(\n    float *out,     /* (o) the bandwidth expanded lpc\n                           coefficients */\n    float *in,      /* (i) the lpc coefficients before bandwidth\n                           expansion */\n    float coef,     /* (i) the bandwidth expansion factor */\n    int length      /* (i) the length of lpc coefficient vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vq(\n    float *Xq,      /* (o) the quantized vector */\n    int *index,     /* (o) the quantization index */\n    const float *CB,/* (i) the vector quantization codebook */\n    float *X,       /* (i) the vector to quantize */\n    int n_cb,       /* (i) the number of vectors in the codebook */\n    int dim         /* (i) the dimension of all vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SplitVQ(\n    float *qX,      /* (o) the quantized vector */\n    int *index,     /* (o) a vector of indexes for all vector\n                           codebooks in the split */\n    float *X,       /* (i) the vector to quantize */\n    const float *CB,/* (i) the quantizer codebook */\n    int nsplit,     /* the number of vector splits */\n    const int *dim, /* the dimension of X and qX */\n    const int *cbsize /* the number of vectors in the codebook */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void sort_sq(\n    float *xq,      /* (o) the quantized value */\n    int *index,     /* (o) the quantization index */\n    float x,    /* (i) the value to quantize */\n    const float *cb,/* (i) the quantization codebook */\n    int cb_size     /* (i) the size of the quantization codebook */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int LSF_check(      /* (o) 1 for stable lsf vectors and 0 for",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "                           nonstable ones */\n    float *lsf,     /* (i) a table of lsf vectors */\n    int dim,    /* (i) the dimension of each lsf vector */\n    int NoAn    /* (i) the number of lsf vectors in the\n                           table */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.26. helpfun.c",
      "section_title": true,
      "ja": "A.26. ヘルプファン.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "helpfun.c",
      "ja": "ヘルプファン.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  calculation of auto correlation\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void autocorr(\n    float *r,       /* (o) autocorrelation vector */\n    const float *x, /* (i) data vector */\n    int N,          /* (i) length of data vector */\n    int order       /* largest lag for calculated\n                       autocorrelations */\n){\n    int     lag, n;\n    float   sum;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (lag = 0; lag <= order; lag++) {\n    sum = 0;\n    for (n = 0; n < N - lag; n++) {\n        sum += x[n] * x[n+lag];\n    }\n    r[lag] = sum;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  window multiplication\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void window(\n    float *z,       /* (o) the windowed data */\n    const float *x, /* (i) the original data vector */\n    const float *y, /* (i) the window */\n    int N           /* (i) length of all vectors */\n){\n    int     i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i < N; i++) {\n        z[i] = x[i] * y[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  levinson-durbin solution for lpc coefficients\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void levdurb(\n    float *a,       /* (o) lpc coefficient vector starting\n                           with 1.0 */\n    float *k,       /* (o) reflection coefficients */\n    float *r,       /* (i) autocorrelation vector */\n    int order       /* (i) order of lpc filter */\n){\n    float  sum, alpha;\n    int     m, m_h, i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a[0] = 1.0;",
      "ja": "a[0] = 1.0;"
    },
    {
      "indent": 3,
      "text": "    if (r[0] < EPS) { /* if r[0] <= 0, set LPC coeff. to zero */\n        for (i = 0; i < order; i++) {\n            k[i] = 0;\n            a[i+1] = 0;\n        }\n    } else {\n        a[1] = k[0] = -r[1]/r[0];\n        alpha = r[0] + r[1] * k[0];\n        for (m = 1; m < order; m++){\n            sum = r[m + 1];\n            for (i = 0; i < m; i++){\n                sum += a[i+1] * r[m - i];\n            }\n               k[m] = -sum / alpha;\n            alpha += k[m] * sum;\n            m_h = (m + 1) >> 1;\n            for (i = 0; i < m_h; i++){\n                sum = a[i+1] + k[m] * a[m - i];\n                a[m - i] += k[m] * a[i+1];\n                a[i+1] = sum;\n            }\n            a[m+1] = k[m];\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  interpolation between vectors\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void interpolate(\n    float *out,      /* (o) the interpolated vector */\n    float *in1,     /* (i) the first vector for the\n                           interpolation */\n    float *in2,     /* (i) the second vector for the\n                           interpolation */\n    float coef,      /* (i) interpolation weights */\n    int length      /* (i) length of all vectors */\n){\n    int i;\n    float invcoef;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    invcoef = (float)1.0 - coef;\n    for (i = 0; i < length; i++) {\n        out[i] = coef * in1[i] + invcoef * in2[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc bandwidth expansion\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void bwexpand(\n    float *out,      /* (o) the bandwidth expanded lpc\n                           coefficients */\n    float *in,      /* (i) the lpc coefficients before bandwidth\n                           expansion */\n    float coef,     /* (i) the bandwidth expansion factor */\n    int length      /* (i) the length of lpc coefficient vectors */\n){\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "float chirp;",
      "ja": "フロートチャープ。"
    },
    {
      "indent": 7,
      "text": "chirp = coef;",
      "ja": "チャープ = 係数;"
    },
    {
      "indent": 3,
      "text": "    out[0] = in[0];\n    for (i = 1; i < length; i++) {\n        out[i] = chirp * in[i];\n        chirp *= coef;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  vector quantization\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void vq(\n    float *Xq,      /* (o) the quantized vector */\n    int *index,     /* (o) the quantization index */\n    const float *CB,/* (i) the vector quantization codebook */\n    float *X,       /* (i) the vector to quantize */\n    int n_cb,       /* (i) the number of vectors in the codebook */\n    int dim         /* (i) the dimension of all vectors */\n){\n    int     i, j;\n    int     pos, minindex;\n    float   dist, tmp, mindist;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pos = 0;\nmindist = FLOAT_MAX;\nminindex = 0;\nfor (j = 0; j < n_cb; j++) {\n    dist = X[0] - CB[pos];\n    dist *= dist;\n    for (i = 1; i < dim; i++) {\n        tmp = X[i] - CB[pos + i];\n        dist += tmp*tmp;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (dist < mindist) {\n        mindist = dist;\n        minindex = j;\n    }\n    pos += dim;\n}\nfor (i = 0; i < dim; i++) {\n    Xq[i] = CB[minindex*dim + i];\n}\n*index = minindex;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  split vector quantization\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SplitVQ(\n    float *qX,      /* (o) the quantized vector */\n    int *index,     /* (o) a vector of indexes for all vector\n                           codebooks in the split */\n    float *X,       /* (i) the vector to quantize */\n    const float *CB,/* (i) the quantizer codebook */\n    int nsplit,     /* the number of vector splits */\n    const int *dim, /* the dimension of X and qX */\n    const int *cbsize /* the number of vectors in the codebook */\n){\n    int    cb_pos, X_pos, i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    cb_pos = 0;\n    X_pos= 0;\n    for (i = 0; i < nsplit; i++) {\n        vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,\n            cbsize[i], dim[i]);\n        X_pos += dim[i];\n        cb_pos += dim[i] * cbsize[i];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  scalar quantization\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void sort_sq(\n    float *xq,      /* (o) the quantized value */\n    int *index,     /* (o) the quantization index */\n    float x,    /* (i) the value to quantize */\n    const float *cb,/* (i) the quantization codebook */\n    int cb_size      /* (i) the size of the quantization codebook */\n){\n    int i;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (x <= cb[0]) {\n    *index = 0;\n    *xq = cb[0];\n} else {\n    i = 0;\n    while ((x > cb[i]) && i < cb_size - 1) {\n        i++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 3,
      "text": "        if (x > ((cb[i] + cb[i - 1])/2)) {\n            *index = i;\n            *xq = cb[i];\n        } else {\n            *index = i - 1;\n            *xq = cb[i - 1];\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  check for stability of lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for\n                           nonstable ones */\n    float *lsf,     /* (i) a table of lsf vectors */\n    int dim,    /* (i) the dimension of each lsf vector */\n    int NoAn    /* (i) the number of lsf vectors in the\n                           table */\n){\n    int k,n,m, Nit=2, change=0,pos;\n    float tmp;\n    static float eps=(float)0.039; /* 50 Hz */\n    static float eps2=(float)0.0195;\n    static float maxlsf=(float)3.14; /* 4000 Hz */\n    static float minlsf=(float)0.01; /* 0 Hz */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* LSF separation check*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (n=0; n<Nit; n++) { /* Run through a couple of times */\n    for (m=0; m<NoAn; m++) { /* Number of analyses per frame */\n        for (k=0; k<(dim-1); k++) {\n            pos=m*dim+k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if ((lsf[pos+1]-lsf[pos])<eps) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "if (lsf[pos+1]<lsf[pos]) {\n    tmp=lsf[pos+1];\n    lsf[pos+1]= lsf[pos]+eps2;\n    lsf[pos]= lsf[pos+1]-eps2;\n} else {\n    lsf[pos]-=eps2;\n    lsf[pos+1]+=eps2;\n}\nchange=1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 19,
      "text": "if (lsf[pos]<minlsf) {\n    lsf[pos]=minlsf;\n    change=1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "            if (lsf[pos]>maxlsf) {\n                lsf[pos]=maxlsf;\n                change=1;\n            }\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " return change; }",
      "ja": "釣り銭を返す。}"
    },
    {
      "indent": 0,
      "text": "A.27. hpInput.h",
      "section_title": true,
      "ja": "A.27. hpInput.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "hpInput.h",
      "ja": "hpInput.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HPINPUT_H #define __iLBC_HPINPUT_H",
      "ja": "#ifndef __iLBC_HPINPUT_H #define __iLBC_HPINPUT_H"
    },
    {
      "indent": 3,
      "text": "void hpInput(\n    float *In,  /* (i) vector to filter */\n    int len,    /* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.28. hpInput.c",
      "section_title": true,
      "ja": "A.28. hpInput.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code hpInput.c",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード hpInput.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"constants.h\"",
      "ja": "#include \"定数.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Input high-pass filter\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void hpInput(\n    float *In,  /* (i) vector to filter */\n    int len,    /* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n){\n    int i;\n    float *pi, *po;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* all-zero section*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pi = &In[0];\npo = &Out[0];\nfor (i=0; i<len; i++) {\n    *po = hpi_zero_coefsTbl[0] * (*pi);\n    *po += hpi_zero_coefsTbl[1] * mem[0];\n    *po += hpi_zero_coefsTbl[2] * mem[1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "mem[1] = mem[0];\nmem[0] = *pi;\npo++;\npi++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* all-pole section*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "po = &Out[0];\nfor (i=0; i<len; i++) {\n    *po -= hpi_pole_coefsTbl[1] * mem[2];\n    *po -= hpi_pole_coefsTbl[2] * mem[3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "mem[3] = mem[2];\nmem[2] = *po;\npo++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.29. hpOutput.h",
      "section_title": true,
      "ja": "A.29. hp出力.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "hpOutput.h",
      "ja": "hp出力.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_HPOUTPUT_H #define __iLBC_HPOUTPUT_H",
      "ja": "#ifndef __iLBC_HPOUTPUT_H #define __iLBC_HPOUTPUT_H"
    },
    {
      "indent": 3,
      "text": "void hpOutput(\n    float *In,  /* (i) vector to filter */\n    int len,/* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.30. hpOutput.c",
      "section_title": true,
      "ja": "A.30. hp出力.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "hpOutput.c",
      "ja": "hp出力.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"constants.h\"",
      "ja": "#include \"定数.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Output high-pass filter\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void hpOutput(",
      "ja": "void hpOutput("
    },
    {
      "indent": 3,
      "text": "    float *In,  /* (i) vector to filter */\n    int len,/* (i) length of vector to filter */\n    float *Out, /* (o) the resulting filtered vector */\n    float *mem  /* (i/o) the filter state */\n){\n    int i;\n    float *pi, *po;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* all-zero section*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pi = &In[0];\npo = &Out[0];\nfor (i=0; i<len; i++) {\n    *po = hpo_zero_coefsTbl[0] * (*pi);\n    *po += hpo_zero_coefsTbl[1] * mem[0];\n    *po += hpo_zero_coefsTbl[2] * mem[1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "mem[1] = mem[0];\nmem[0] = *pi;\npo++;\npi++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 7,
      "text": "/* all-pole section*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "po = &Out[0];\nfor (i=0; i<len; i++) {\n    *po -= hpo_pole_coefsTbl[1] * mem[2];\n    *po -= hpo_pole_coefsTbl[2] * mem[3];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        mem[3] = mem[2];\n        mem[2] = *po;\n        po++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.31. iCBConstruct.h",
      "section_title": true,
      "ja": "A.31. iCBConstruct.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iCBConstruct.h",
      "ja": "iCBConstruct.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ICBCONSTRUCT_H #define __iLBC_ICBCONSTRUCT_H",
      "ja": "#ifndef __iLBC_ICBCONSTRUCT_H #define __iLBC_ICBCONSTRUCT_H"
    },
    {
      "indent": 3,
      "text": "void index_conv_enc(\n    int *index          /* (i/o) Codebook indexes */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void index_conv_dec(\n    int *index          /* (i/o) Codebook indexes */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iCBConstruct(\n    float *decvector,   /* (o) Decoded vector */\n    int *index,         /* (i) Codebook indices */\n    int *gain_index,/* (i) Gain quantization indices */\n    float *mem,         /* (i) Buffer for codevector construction */\n    int lMem,           /* (i) Length of buffer */\n    int veclen,         /* (i) Length of vector */\n    int nStages         /* (i) Number of codebook stages */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.32. iCBConstruct.c",
      "section_title": true,
      "ja": "A.32. iCBConstruct.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iCBConstruct.c",
      "ja": "iCBConstruct.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"getCBvec.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"getCBvec.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Convert the codebook indexes to make the search easier\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void index_conv_enc(\n    int *index          /* (i/o) Codebook indexes */\n){\n    int k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (k=1; k<CB_NSTAGES; k++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if ((index[k]>=108)&&(index[k]<172)) {\n            index[k]-=64;\n        } else if (index[k]>=236) {\n            index[k]-=128;\n        } else {\n            /* ERROR */\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void index_conv_dec(\n    int *index          /* (i/o) Codebook indexes */\n){\n    int k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (k=1; k<CB_NSTAGES; k++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if ((index[k]>=44)&&(index[k]<108)) {\n            index[k]+=64;\n        } else if ((index[k]>=108)&&(index[k]<128)) {\n            index[k]+=128;\n        } else {\n            /* ERROR */\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Construct decoded vector from codebook and gains.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iCBConstruct(\n    float *decvector,   /* (o) Decoded vector */\n    int *index,         /* (i) Codebook indices */\n    int *gain_index,/* (i) Gain quantization indices */\n    float *mem,         /* (i) Buffer for codevector construction */\n    int lMem,           /* (i) Length of buffer */\n    int veclen,         /* (i) Length of vector */\n    int nStages         /* (i) Number of codebook stages */\n){\n    int j,k;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "float gain[CB_NSTAGES]; float cbvec[SUBL];",
      "ja": "浮動小数点ゲイン[CB_NSTAGES];float cbvec[SUBL];"
    },
    {
      "indent": 7,
      "text": "/* gain de-quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "gain[0] = gaindequant(gain_index[0], 1.0, 32);\nif (nStages > 1) {\n    gain[1] = gaindequant(gain_index[1],\n        (float)fabs(gain[0]), 16);\n}\nif (nStages > 2) {\n    gain[2] = gaindequant(gain_index[2],\n        (float)fabs(gain[1]), 8);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* codebook vector construction and construction of\ntotal vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    getCBvec(cbvec, mem, index[0], lMem, veclen);\n    for (j=0;j<veclen;j++){\n        decvector[j] = gain[0]*cbvec[j];\n    }\n    if (nStages > 1) {\n        for (k=1; k<nStages; k++) {\n            getCBvec(cbvec, mem, index[k], lMem, veclen);\n            for (j=0;j<veclen;j++) {\n                decvector[j] += gain[k]*cbvec[j];\n            }\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.33. iCBSearch.h",
      "section_title": true,
      "ja": "A.33. iCBSearch.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iCBSearch.h",
      "ja": "iCBSearch.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_ICBSEARCH_H\n#define __iLBC_ICBSEARCH_H\n   void iCBSearch(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) the encoder state structure */\n    int *index,         /* (o) Codebook indices */\n    int *gain_index,/* (o) Gain quantization indices */\n    float *intarget,/* (i) Target vector for encoding */\n    float *mem,         /* (i) Buffer for codebook construction */\n    int lMem,           /* (i) Length of buffer */\n    int lTarget,    /* (i) Length of vector */\n    int nStages,    /* (i) Number of codebook stages */\n    float *weightDenum, /* (i) weighting filter coefficients */\n    float *weightState, /* (i) weighting filter state */\n    int block           /* (i) the sub-block number */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.34. iCBSearch.c",
      "section_title": true,
      "ja": "A.34. iCBSearch.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "iCBSearch.c",
      "ja": "iCBSearch.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"createCB.h\" #include \"filter.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"gainquant.h\" #include \"createCB.h\" #include \"filter.h\" #include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  Search routine for codebook encoding and gain quantization.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void iCBSearch(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) the encoder state structure */\n    int *index,         /* (o) Codebook indices */\n    int *gain_index,/* (o) Gain quantization indices */\n       float *intarget,/* (i) Target vector for encoding */\n    float *mem,         /* (i) Buffer for codebook construction */\n    int lMem,           /* (i) Length of buffer */\n    int lTarget,    /* (i) Length of vector */\n    int nStages,    /* (i) Number of codebook stages */\n    float *weightDenum, /* (i) weighting filter coefficients */\n    float *weightState, /* (i) weighting filter state */\n    int block           /* (i) the sub-block number */\n){\n    int i, j, icount, stage, best_index, range, counter;\n    float max_measure, gain, measure, crossDot, ftmp;\n    float gains[CB_NSTAGES];\n    float target[SUBL];\n    int base_index, sInd, eInd, base_size;\n    int sIndAug=0, eIndAug=0;\n    float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];\n    float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];\n    float *pp, *ppi=0, *ppo=0, *ppe=0;\n    float cbvectors[CB_MEML];\n    float tene, cene, cvec[SUBL];\n    float aug_vec[SUBL];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(cvec,0,SUBL*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Determine size of codebook sections */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "base_size=lMem-lTarget+1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lTarget==SUBL) {\n    base_size=lMem-lTarget+1+lTarget/2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* setup buffer for weighting */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);\nmemcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));\nmemcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* weighting */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "AllPoleFilter(buf+LPC_FILTERORDER, weightDenum,\n    lMem+lTarget, LPC_FILTERORDER);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Construct the codebook and target needed */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "tene=0.0;",
      "ja": "10 = 0.0;"
    },
    {
      "indent": 7,
      "text": "for (i=0; i<lTarget; i++) {\n    tene+=target[i]*target[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Prepare search over one more codebook section. This section\n   is created by filtering the original buffer with a filter. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* The Main Loop over stages */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (stage=0; stage<nStages; stage++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "range = search_rangeTbl[block][stage];",
      "ja": "range = search_rangeTbl[ブロック][ステージ];"
    },
    {
      "indent": 11,
      "text": "/* initialize search measure */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "max_measure = (float)-10000000.0;\ngain = (float)0.0;\nbest_index = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Compute cross dot product between the target\n   and the CB memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "crossDot=0.0;\npp=buf+LPC_FILTERORDER+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (stage==0) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* Calculate energy in the first block of\n  'lTarget' samples. */\nppe = energy;\nppi = buf+LPC_FILTERORDER+lMem-lTarget-1;\nppo = buf+LPC_FILTERORDER+lMem-1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "*ppe=0.0;\npp=buf+LPC_FILTERORDER+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    *ppe+=(*pp)*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (*ppe>0.0) {\n    invenergy[0] = (float) 1.0 / (*ppe + EPS);\n} else {\n    invenergy[0] = (float) 0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "}\nppe++;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "measure=(float)-10000000.0;",
      "ja": "メジャー = (浮動小数点数)-10000000.0;"
    },
    {
      "indent": 11,
      "text": "    if (crossDot > 0.0) {\n           measure = crossDot*crossDot*invenergy[0];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[0];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n    best_index = 0;\n    max_measure = measure;\n    gain = ftmp;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over the main first codebook section,\n   full search */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (icount=1; icount<range; icount++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* calculate measure */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "crossDot=0.0;\npp = buf+LPC_FILTERORDER+lMem-lTarget-icount;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (j=0; j<lTarget; j++) {\n    crossDot += target[j]*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (stage==0) {\n    *ppe++ = energy[icount-1] + (*ppi)*(*ppi) -\n        (*ppo)*(*ppo);\n    ppo--;\n    ppi--;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if (energy[icount]>0.0) {\n    invenergy[icount] =\n        (float)1.0/(energy[icount]+EPS);\n} else {\n    invenergy[icount] = (float) 0.0;\n}\n                   measure=(float)-10000000.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*invenergy[icount];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[icount];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[icount];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n        best_index = icount;\n        max_measure = measure;\n        gain = ftmp;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Loop over augmented part in the first codebook\n * section, full search.\n * The vectors are interpolated.\n */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (lTarget==SUBL) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    /* Search for best possible cb vector and\n       compute the CB-vectors' energy. */\n    searchAugmentedCB(20, 39, stage, base_size-lTarget/2,\n        target, buf+LPC_FILTERORDER+lMem,\n        &max_measure, &best_index, &gain, energy,\n        invenergy);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* set search range for following codebook sections */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "base_index=best_index;",
      "ja": "ベースインデックス=ベストインデックス;"
    },
    {
      "indent": 11,
      "text": "/* unrestricted search */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (CB_RESRANGE == -1) {\n    sInd=0;\n    eInd=range-1;\n    sIndAug=20;\n    eIndAug=39;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* restricted search around best index from first\ncodebook section */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "else {\n    /* Initialize search indices */\n    sIndAug=0;\n    eIndAug=0;\n    sInd=base_index-CB_RESRANGE/2;\n    eInd=sInd+CB_RESRANGE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (lTarget==SUBL) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if (sInd<0) {",
      "ja": "if (sInd<0) {"
    },
    {
      "indent": 23,
      "text": "sIndAug = 40 + sInd;\neIndAug = 39;\nsInd=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "} else if ( base_index < (base_size-20) ) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "    if (eInd > range) {\n        sInd -= (eInd-range);\n        eInd = range;\n    }\n} else { /* base_index >= (base_size-20) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "if (sInd < (base_size-20)) {\n    sIndAug = 20;\n    sInd = 0;\n    eInd = 0;\n    eIndAug = 19 + CB_RESRANGE;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "        if(eIndAug > 39) {\n            eInd = eIndAug-39;\n            eIndAug = 39;\n        }\n    } else {\n        sIndAug = 20 + sInd - (base_size-20);\n        eIndAug = 39;\n        sInd = 0;\n        eInd = CB_RESRANGE - (eIndAug-sIndAug+1);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "} else { /* lTarget = 22 or 23 */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if (sInd < 0) {\n    eInd -= sInd;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": " sInd = 0; }",
      "ja": "sInd = 0;}"
    },
    {
      "indent": 11,
      "text": "        if(eInd > range) {\n            sInd -= (eInd - range);\n            eInd = range;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* search of higher codebook section */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* index search range */\ncounter = sInd;\nsInd += base_size;\neInd += base_size;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (stage==0) {\n    ppe = energy+base_size;\n    *ppe=0.0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "pp=cbvectors+lMem-lTarget;\nfor (j=0; j<lTarget; j++) {\n    *ppe+=(*pp)*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "ppi = cbvectors + lMem - 1 - lTarget;\nppo = cbvectors + lMem - 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    for (j=0; j<(range-1); j++) {\n        *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);\n        ppo--;\n        ppi--;\n        ppe++;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* loop over search range */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (icount=sInd; icount<eInd; icount++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* calculate measure */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "crossDot=0.0;\npp=cbvectors + lMem - (counter++) - lTarget;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "for (j=0;j<lTarget;j++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "    crossDot += target[j]*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (energy[icount]>0.0) {\n    invenergy[icount] =(float)1.0/(energy[icount]+EPS);\n} else {\n    invenergy[icount] =(float)0.0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (stage==0) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "measure=(float)-10000000.0;",
      "ja": "メジャー = (浮動小数点数)-10000000.0;"
    },
    {
      "indent": 15,
      "text": "    if (crossDot > 0.0) {\n        measure = crossDot*crossDot*\n            invenergy[icount];\n    }\n}\nelse {\n    measure = crossDot*crossDot*invenergy[icount];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* check if measure is better */\nftmp = crossDot*invenergy[icount];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n        best_index = icount;\n        max_measure = measure;\n        gain = ftmp;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Search the augmented CB inside the limited range. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ((lTarget==SUBL)&&(sIndAug!=0)) {\n    searchAugmentedCB(sIndAug, eIndAug, stage,\n        2*base_size-20, target, cbvectors+lMem,\n        &max_measure, &best_index, &gain, energy,\n        invenergy);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* record best index */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "index[stage] = best_index;",
      "ja": "インデックス[ステージ] = best_index;"
    },
    {
      "indent": 11,
      "text": "/* gain quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (stage==0){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (gain<0.0){\n    gain = 0.0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (gain>CB_MAXGAIN) {\n        gain = (float)CB_MAXGAIN;\n    }\n    gain = gainquant(gain, 1.0, 32, &gain_index[stage]);\n}\nelse {\n    if (stage==1) {\n        gain = gainquant(gain, (float)fabs(gains[stage-1]),\n            16, &gain_index[stage]);\n    } else {\n        gain = gainquant(gain, (float)fabs(gains[stage-1]),\n            8, &gain_index[stage]);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Extract the best (according to measure)\n   codebook vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (lTarget==(STATE_LEN-iLBCenc_inst->state_short_len)) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    if (index[stage]<base_size) {\n        pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];\n    } else {\n        pp=cbvectors+lMem-lTarget-\n            index[stage]+base_size;\n    }\n} else {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (index[stage]<base_size) {\n    if (index[stage]<(base_size-20)) {\n        pp=buf+LPC_FILTERORDER+lMem-\n            lTarget-index[stage];\n    } else {\n        createAugmentedVec(index[stage]-base_size+40,\n                buf+LPC_FILTERORDER+lMem,aug_vec);\n        pp=aug_vec;\n    }\n} else {\n    int filterno, position;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "filterno=index[stage]/base_size;\nposition=index[stage]-filterno*base_size;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "        if (position<(base_size-20)) {\n            pp=cbvectors+filterno*lMem-lTarget-\n                index[stage]+filterno*base_size;\n        } else {\n            createAugmentedVec(\n                index[stage]-(filterno+1)*base_size+40,\n                cbvectors+filterno*lMem,aug_vec);\n            pp=aug_vec;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Subtract the best codebook vector, according\n   to measure, from the target vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (j=0;j<lTarget;j++) {\n    cvec[j] += gain*(*pp);\n    target[j] -= gain*(*pp++);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* record quantized gain */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "gains[stage]=gain;",
      "ja": "ゲイン[段階]=ゲイン;"
    },
    {
      "indent": 7,
      "text": "}/* end of Main Loop. for (stage=0;... */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Gain adjustment for energy matching */\ncene=0.0;\nfor (i=0; i<lTarget; i++) {\n    cene+=cvec[i]*cvec[i];\n}\nj=gain_index[0];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=gain_index[0]; i<32; i++) {\n    ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        if ((ftmp<(tene*gains[0]*gains[0])) &&\n            (gain_sq5Tbl[j]<(2.0*gains[0]))) {\n            j=i;\n        }\n    }\n    gain_index[0]=j;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.35. LPCdecode.h",
      "section_title": true,
      "ja": "A.35. LPCdecode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "LPC_decode.h",
      "ja": "LPC_デコード.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LPC_DECODE_H #define __iLBC_LPC_DECODE_H",
      "ja": "#ifndef __iLBC_LPC_DECODE_H #define __iLBC_LPC_DECODE_H"
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_dec(\n    float *a,           /* (o) lpc coefficients for a sub-frame */\n    float *lsf1,    /* (i) first lsf coefficient vector */\n    float *lsf2,    /* (i) second lsf coefficient vector */\n    float coef,         /* (i) interpolation weight */\n    int length          /* (i) length of lsf vectors */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SimplelsfDEQ(\n    float *lsfdeq,      /* (o) dequantized lsf coefficients */\n    int *index,         /* (i) quantization index */\n    int lpc_n           /* (i) number of LPCs */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void DecoderInterpolateLSF(\n    float *syntdenum,   /* (o) synthesis filter coefficients */\n    float *weightdenum, /* (o) weighting denumerator\n                               coefficients */\n    float *lsfdeq,      /* (i) dequantized lsf coefficients */\n    int length,         /* (i) length of lsf coefficient vector */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i) the decoder state structure */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.36. LPCdecode.c",
      "section_title": true,
      "ja": "A.36. LPCデコード.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "LPC_decode.c",
      "ja": "LPC_デコード.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"helpfun.h\" #include \"lsf.h\" #include \"iLBC_define.h\" #include \"constants.h\"",
      "ja": "#include \"helpfun.h\" #include \"lsf.h\" #include \"iLBC_define.h\" #include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  interpolation of lsf coefficients for the decoder\n *--------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_dec(\n    float *a,           /* (o) lpc coefficients for a sub-frame */\n    float *lsf1,    /* (i) first lsf coefficient vector */\n    float *lsf2,    /* (i) second lsf coefficient vector */\n    float coef,         /* (i) interpolation weight */\n    int length          /* (i) length of lsf vectors */\n){\n    float  lsftmp[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    interpolate(lsftmp, lsf1, lsf2, coef, length);\n    lsf2a(a, lsftmp);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*---------------------------------------------------------------*\n *  obtain dequantized lsf coefficients from quantization index\n *--------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SimplelsfDEQ(\n    float *lsfdeq,    /* (o) dequantized lsf coefficients */\n    int *index,         /* (i) quantization index */\n    int lpc_n           /* (i) number of LPCs */\n){\n    int i, j, pos, cb_pos;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* decode first LSF */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "pos = 0;\ncb_pos = 0;\nfor (i = 0; i < LSF_NSPLIT; i++) {\n    for (j = 0; j < dim_lsfCbTbl[i]; j++) {\n        lsfdeq[pos + j] = lsfCbTbl[cb_pos +\n            (long)(index[i])*dim_lsfCbTbl[i] + j];\n    }\n    pos += dim_lsfCbTbl[i];\n    cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (lpc_n>1) {",
      "ja": "if (lpc_n>1) {"
    },
    {
      "indent": 11,
      "text": "/* decode last LSF */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        pos = 0;\n        cb_pos = 0;\n        for (i = 0; i < LSF_NSPLIT; i++) {\n            for (j = 0; j < dim_lsfCbTbl[i]; j++) {\n                lsfdeq[LPC_FILTERORDER + pos + j] =\n                    lsfCbTbl[cb_pos +\n                    (long)(index[LSF_NSPLIT + i])*\n                    dim_lsfCbTbl[i] + j];\n            }\n            pos += dim_lsfCbTbl[i];\n            cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  obtain synthesis and weighting filters form lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void DecoderInterpolateLSF(\n    float *syntdenum, /* (o) synthesis filter coefficients */\n    float *weightdenum, /* (o) weighting denumerator\n                               coefficients */\n    float *lsfdeq,       /* (i) dequantized lsf coefficients */\n    int length,         /* (i) length of lsf coefficient vector */\n    iLBC_Dec_Inst_t *iLBCdec_inst\n                        /* (i) the decoder state structure */\n){\n    int    i, pos, lp_length;\n    float  lp[LPC_FILTERORDER + 1], *lsfdeq2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "lsfdeq2 = lsfdeq + length;\nlp_length = length + 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30) {\n    /* sub-frame 1: Interpolation between old and first */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold, lsfdeq,\n    lsf_weightTbl_30ms[0], length);\nmemcpy(syntdenum,lp,lp_length*sizeof(float));\nbwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,\n    lp_length);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* sub-frames 2 to 6: interpolation between first\n   and last LSF */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    pos = lp_length;\n    for (i = 1; i < 6; i++) {\n        LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,\n            lsf_weightTbl_30ms[i], length);\n        memcpy(syntdenum + pos,lp,lp_length*sizeof(float));\n        bwexpand(weightdenum + pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}\nelse {\n    pos = 0;\n    for (i = 0; i < iLBCdec_inst->nsub; i++) {\n        LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold,\n            lsfdeq, lsf_weightTbl_20ms[i], length);\n        memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n        bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,\n            lp_length);\n        pos += lp_length;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCdec_inst->mode==30)\n    memcpy(iLBCdec_inst->lsfdeqold, lsfdeq2,\n                length*sizeof(float));\nelse\n    memcpy(iLBCdec_inst->lsfdeqold, lsfdeq,\n                length*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 0,
      "text": "A.37. LPCencode.h",
      "section_title": true,
      "ja": "A.37. LPEncode.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "LPCencode.h",
      "ja": "LPEncode.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LPCENCOD_H #define __iLBC_LPCENCOD_H",
      "ja": "#ifndef __iLBC_LPCENCOD_H #define __iLBC_LPCENCOD_H"
    },
    {
      "indent": 3,
      "text": "void LPCencode(\n    float *syntdenum,   /* (i/o) synthesis filter coefficients\n                               before/after encoding */\n    float *weightdenum, /* (i/o) weighting denumerator coefficients\n                               before/after encoding */\n    int *lsf_index,     /* (o) lsf quantization index */\n    float *data,    /* (i) lsf coefficients to quantize */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.38. LPCencode.c",
      "section_title": true,
      "ja": "A.38. LPエンコード.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "LPCencode.c",
      "ja": "LPエンコード.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"helpfun.h\" #include \"lsf.h\" #include \"constants.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"helpfun.h\" #include \"lsf.h\" #include \"constants.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc analysis (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SimpleAnalysis(\n    float *lsf,         /* (o) lsf coefficients */\n    float *data,    /* (i) new data vector */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    int k, is;\n    float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];\n    float lp2[LPC_FILTERORDER + 1];\n    float r[LPC_FILTERORDER + 1];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\nmemcpy(iLBCenc_inst->lpc_buffer+is,data,\n    iLBCenc_inst->blockl*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* No lookahead, last window is asymmetric */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (k = 0; k < iLBCenc_inst->lpc_n; k++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "is = LPC_LOOKBACK;",
      "ja": "= LPC_LOOKBACK;"
    },
    {
      "indent": 11,
      "text": "if (k < (iLBCenc_inst->lpc_n - 1)) {\n    window(temp, lpc_winTbl,\n        iLBCenc_inst->lpc_buffer, BLOCKL_MAX);\n} else {\n    window(temp, lpc_asymwinTbl,\n        iLBCenc_inst->lpc_buffer + is, BLOCKL_MAX);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);\nwindow(r, r, lpc_lagwinTbl, LPC_FILTERORDER + 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "levdurb(lp, temp, r, LPC_FILTERORDER);\nbwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        a2lsf(lsf + k*LPC_FILTERORDER, lp2);\n    }\n    is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\n    memmove(iLBCenc_inst->lpc_buffer,\n        iLBCenc_inst->lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,\n        is*sizeof(float));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "* lsf interpolator and conversion from lsf to a coefficients * (subrutine to SimpleInterpolateLSF) *---------------------------------------------------------------*/",
      "ja": "* LSF 補間器と LSF から係数への変換 * (サブルーチンから SimpleInterpolateLSF) *---------------------------------------------------------*/"
    },
    {
      "indent": 3,
      "text": "void LSFinterpolate2a_enc(\n    float *a,       /* (o) lpc coefficients */\n    float *lsf1,/* (i) first set of lsf coefficients */\n    float *lsf2,/* (i) second set of lsf coefficients */\n    float coef,     /* (i) weighting coefficient to use between\n                           lsf1 and lsf2 */\n    long length      /* (i) length of coefficient vectors */\n){\n    float  lsftmp[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    interpolate(lsftmp, lsf1, lsf2, coef, length);\n    lsf2a(a, lsftmp);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lsf interpolator (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SimpleInterpolateLSF(\n    float *syntdenum,   /* (o) the synthesis filter denominator\n                               resulting from the quantized\n                               interpolated lsf */\n    float *weightdenum, /* (o) the weighting filter denominator\n                               resulting from the unquantized\n                               interpolated lsf */\n    float *lsf,         /* (i) the unquantized lsf coefficients */\n    float *lsfdeq,      /* (i) the dequantized lsf coefficients */\n    float *lsfold,      /* (i) the unquantized lsf coefficients of\n                               the previous signal frame */\n    float *lsfdeqold, /* (i) the dequantized lsf coefficients of\n                               the previous signal frame */\n    int length,         /* (i) should equate LPC_FILTERORDER */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    int    i, pos, lp_length;\n    float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "lsf2 = lsf + length;\nlsfdeq2 = lsfdeq + length;\nlp_length = length + 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==30) {\n    /* sub-frame 1: Interpolation between old and first",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "set of lsf coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,\n    lsf_weightTbl_30ms[0], length);\nmemcpy(syntdenum,lp,lp_length*sizeof(float));\nLSFinterpolate2a_enc(lp, lsfold, lsf,\n    lsf_weightTbl_30ms[0], length);\nbwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM, lp_length);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* sub-frame 2 to 6: Interpolation between first\n   and second set of lsf coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "pos = lp_length;\nfor (i = 1; i < iLBCenc_inst->nsub; i++) {\n    LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,\n        lsf_weightTbl_30ms[i], length);\n    memcpy(syntdenum + pos,lp,lp_length*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        LSFinterpolate2a_enc(lp, lsf, lsf2,\n            lsf_weightTbl_30ms[i], length);\n        bwexpand(weightdenum + pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}\nelse {\n    pos = 0;\n    for (i = 0; i < iLBCenc_inst->nsub; i++) {\n        LSFinterpolate2a_enc(lp, lsfdeqold, lsfdeq,\n            lsf_weightTbl_20ms[i], length);\n        memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n        LSFinterpolate2a_enc(lp, lsfold, lsf,\n            lsf_weightTbl_20ms[i], length);\n        bwexpand(weightdenum+pos, lp,\n            LPC_CHIRP_WEIGHTDENUM, lp_length);\n        pos += lp_length;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* update memory */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (iLBCenc_inst->mode==30) {\n    memcpy(lsfold, lsf2, length*sizeof(float));\n    memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));\n}\nelse {\n    memcpy(lsfold, lsf, length*sizeof(float));\n    memcpy(lsfdeqold, lsfdeq, length*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lsf quantizer (subrutine to LPCencode)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void SimplelsfQ(\n    float *lsfdeq,    /* (o) dequantized lsf coefficients\n                           (dimension FILTERORDER) */\n    int *index,     /* (o) quantization index */\n    float *lsf,      /* (i) the lsf coefficient vector to be\n                           quantized (dimension FILTERORDER ) */\n    int lpc_n     /* (i) number of lsf sets to quantize */\n){\n    /* Quantize first LSF with memoryless split VQ */\n    SplitVQ(lsfdeq, index, lsf, lsfCbTbl, LSF_NSPLIT,\n        dim_lsfCbTbl, size_lsfCbTbl);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (lpc_n==2) {\n        /* Quantize second LSF with memoryless split VQ */\n        SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,\n            lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,\n            dim_lsfCbTbl, size_lsfCbTbl);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  lpc encoder\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void LPCencode(\n    float *syntdenum, /* (i/o) synthesis filter coefficients\n                               before/after encoding */\n    float *weightdenum, /* (i/o) weighting denumerator\n                               coefficients before/after\n                               encoding */\n    int *lsf_index,     /* (o) lsf quantization index */\n    float *data,    /* (i) lsf coefficients to quantize */\n    iLBC_Enc_Inst_t *iLBCenc_inst\n                        /* (i/o) the encoder state structure */\n){\n    float lsf[LPC_FILTERORDER * LPC_N_MAX];\n    float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];\n    int change=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "SimpleAnalysis(lsf, data, iLBCenc_inst);\nSimplelsfQ(lsfdeq, lsf_index, lsf, iLBCenc_inst->lpc_n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    change=LSF_check(lsfdeq, LPC_FILTERORDER, iLBCenc_inst->lpc_n);\n    SimpleInterpolateLSF(syntdenum, weightdenum,\n        lsf, lsfdeq, iLBCenc_inst->lsfold,\n        iLBCenc_inst->lsfdeqold, LPC_FILTERORDER, iLBCenc_inst);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.39. lsf.h",
      "section_title": true,
      "ja": "A.39. lsf.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "lsf.h",
      "ja": "lsf.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_LSF_H #define __iLBC_LSF_H",
      "ja": "#ifndef __iLBC_LSF_H #define __iLBC_LSF_H"
    },
    {
      "indent": 3,
      "text": "void a2lsf(\n    float *freq,/* (o) lsf coefficients */\n    float *a    /* (i) lpc coefficients */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void lsf2a(\n    float *a_coef,  /* (o) lpc coefficients */\n    float *freq     /* (i) lsf coefficients */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.40. lsf.c",
      "section_title": true,
      "ja": "A.40. lsf.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "lsf.c",
      "ja": "lsf.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  conversion from lpc coefficients to lsf coefficients\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void a2lsf(\n    float *freq,/* (o) lsf coefficients */\n    float *a    /* (i) lpc coefficients */\n){\n    float steps[LSF_NUMBER_OF_STEPS] =\n        {(float)0.00635, (float)0.003175, (float)0.0015875,\n        (float)0.00079375};\n    float step;\n    int step_idx;\n    int lsp_index;\n    float p[LPC_HALFORDER];\n    float q[LPC_HALFORDER];\n    float p_pre[LPC_HALFORDER];\n    float q_pre[LPC_HALFORDER];\n    float old_p, old_q, *old;\n    float *pq_coef;\n    float omega, old_omega;\n    int i;\n    float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER - i]);\n    q[i] = a[LPC_FILTERORDER - i] - a[i + 1];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "p_pre[0] = (float)-1.0 - p[0];\np_pre[1] = - p_pre[0] - p[1];\np_pre[2] = - p_pre[1] - p[2];\np_pre[3] = - p_pre[2] - p[3];\np_pre[4] = - p_pre[3] - p[4];\np_pre[4] = p_pre[4] / 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "q_pre[0] = (float)1.0 - q[0];\nq_pre[1] = q_pre[0] - q[1];\nq_pre[2] = q_pre[1] - q[2];\nq_pre[3] = q_pre[2] - q[3];\nq_pre[4] = q_pre[3] - q[4];\nq_pre[4] = q_pre[4] / 2;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "omega = 0.0;",
      "ja": "オメガ = 0.0;"
    },
    {
      "indent": 7,
      "text": "old_omega = 0.0;",
      "ja": "古いオメガ = 0.0;"
    },
    {
      "indent": 7,
      "text": "old_p = FLOAT_MAX;\nold_q = FLOAT_MAX;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Here we loop through lsp_index to find all the\n   LPC_FILTERORDER roots for omega. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (lsp_index = 0; lsp_index<LPC_FILTERORDER; lsp_index++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Depending on lsp_index being even or odd, we\nalternatively solve the roots for the two LSP equations. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ((lsp_index & 0x1) == 0) {\n    pq_coef = p_pre;\n    old = &old_p;\n} else {\n    pq_coef = q_pre;\n    old = &old_q;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Start with low resolution grid */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (step_idx = 0, step = steps[step_idx];\n    step_idx < LSF_NUMBER_OF_STEPS;){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +\npq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "hlp = (float)cos(omega * TWO_PI);\nhlp1 = (float)2.0 * hlp + pq_coef[0];\nhlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +\n    pq_coef[1];\nhlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];\nhlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];\nhlp5 = hlp * hlp4 - hlp3 + pq_coef[4];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "if (((hlp5 * (*old)) <= 0.0) || (omega >= 0.5)){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "if (step_idx == (LSF_NUMBER_OF_STEPS - 1)){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "if (fabs(hlp5) >= fabs(*old)) {\n    freq[lsp_index] = omega - step;\n} else {\n    freq[lsp_index] = omega;\n}\n                       if ((*old) >= 0.0){\n    *old = (float)-1.0 * FLOAT_MAX;\n} else {\n    *old = FLOAT_MAX;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "omega = old_omega;\nstep_idx = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "    step_idx = LSF_NUMBER_OF_STEPS;\n} else {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "if (step_idx == 0) {\n    old_omega = omega;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "step_idx++;\nomega -= steps[step_idx];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "/* Go back one grid step */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "        step = steps[step_idx];\n    }\n} else {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "        /* increment omega until they are of different sign,\n        and we know there is at least one root between omega\n        and old_omega */\n            *old = hlp5;\n            omega += step;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    for (i = 0; i<LPC_FILTERORDER; i++) {\n        freq[i] = freq[i] * TWO_PI;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  conversion from lsf coefficients to lpc coefficients\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void lsf2a(\n    float *a_coef,  /* (o) lpc coefficients */\n    float *freq     /* (i) lsf coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "){\n    int i, j;\n    float hlp;\n    float p[LPC_HALFORDER], q[LPC_HALFORDER];\n    float a[LPC_HALFORDER + 1], a1[LPC_HALFORDER],\n        a2[LPC_HALFORDER];\n    float b[LPC_HALFORDER + 1], b1[LPC_HALFORDER],\n        b2[LPC_HALFORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    freq[i] = freq[i] * PI2;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Check input for ill-conditioned cases.  This part is not\nfound in the TIA standard.  It involves the following 2 IF\nblocks.  If \"freq\" is judged ill-conditioned, then we first\nmodify freq[0] and freq[LPC_HALFORDER-1] (normally\nLPC_HALFORDER = 10 for LPC applications), then we adjust\nthe other \"freq\" values slightly */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ((freq[0] <= 0.0) || (freq[LPC_FILTERORDER - 1] >= 0.5)){",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (freq[0] <= 0.0) {\n    freq[0] = (float)0.022;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (freq[LPC_FILTERORDER - 1] >= 0.5) {\n    freq[LPC_FILTERORDER - 1] = (float)0.499;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "hlp = (freq[LPC_FILTERORDER - 1] - freq[0]) /\n    (float) (LPC_FILTERORDER - 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    for (i=1; i<LPC_FILTERORDER; i++) {\n        freq[i] = freq[i - 1] + hlp;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(a1, 0, LPC_HALFORDER*sizeof(float));\nmemset(a2, 0, LPC_HALFORDER*sizeof(float));\nmemset(b1, 0, LPC_HALFORDER*sizeof(float));\nmemset(b2, 0, LPC_HALFORDER*sizeof(float));\nmemset(a, 0, (LPC_HALFORDER+1)*sizeof(float));\nmemset(b, 0, (LPC_HALFORDER+1)*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* p[i] and q[i] compute cos(2*pi*omega_{2j}) and\ncos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1 and 4.2.2.2-2.\nNote that for this code p[i] specifies the coefficients\nused in .Q_A(z) while q[i] specifies the coefficients used\nin .P_A(z) */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    p[i] = (float)cos(TWO_PI * freq[2 * i]);\n    q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "a[0] = 0.25;\nb[0] = 0.25;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i= 0; i<LPC_HALFORDER; i++) {\n    a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n    b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n    a2[i] = a1[i];\n    a1[i] = a[i];\n    b2[i] = b1[i];\n    b1[i] = b[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (j=0; j<LPC_FILTERORDER; j++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (j == 0) {\n    a[0] = 0.25;\n    b[0] = -0.25;\n} else {\n    a[0] = b[0] = 0.0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "for (i=0; i<LPC_HALFORDER; i++) {\n    a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n    b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n    a2[i] = a1[i];\n    a1[i] = a[i];\n    b2[i] = b1[i];\n    b1[i] = b[i];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " a_coef[0] = 1.0; }",
      "ja": "a_coef[0] = 1.0;}"
    },
    {
      "indent": 0,
      "text": "A.41. packing.h",
      "section_title": true,
      "ja": "A.41. パッキング.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "packing.h",
      "ja": "パッキング.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __PACKING_H #define __PACKING_H",
      "ja": "#ifndef __PACKING_H #define __PACKING_H"
    },
    {
      "indent": 3,
      "text": "void packsplit(\n    int *index,                 /* (i) the value to split */\n    int *firstpart,             /* (o) the value specified by most\n                                       significant bits */\n    int *rest,                  /* (o) the value specified by least\n                                       significant bits */\n    int bitno_firstpart,    /* (i) number of bits in most\n                                       significant part */\n    int bitno_total             /* (i) number of bits in full range\n                                       of value */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void packcombine(\n    int *index,                 /* (i/o) the msb value in the\n                                       combined value out */\n    int rest,                   /* (i) the lsb value */\n    int bitno_rest              /* (i) the number of bits in the\n                                       lsb part */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void dopack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to pack\n                                       new data, on exit pointer\n                                       to place in bitstream to\n                                       pack future data */\n    int index,                  /* (i) the value to pack */\n    int bitno,                  /* (i) the number of bits that the\n                                       value will fit within */\n    int *pos                /* (i/o) write position in the\n                                       current byte */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void unpack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to\n                                       unpack new data from, on\n                                       exit pointer to place in\n                                       bitstream to unpack future\n                                       data from */\n    int *index,                 /* (o) resulting value */\n    int bitno,                  /* (i) number of bits used to\n                                       represent the value */\n    int *pos                /* (i/o) read position in the\n                                       current byte */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.42. packing.c",
      "section_title": true,
      "ja": "A.42. 梱包.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "packing.c",
      "ja": "梱包.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <stdlib.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"helpfun.h\" #include \"string.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"helpfun.h\" #include \"string.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  splitting an integer into first most significant bits and\n *  remaining least significant bits\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void packsplit(\n    int *index,                 /* (i) the value to split */\n    int *firstpart,             /* (o) the value specified by most\n                                       significant bits */\n    int *rest,                  /* (o) the value specified by least\n                                       significant bits */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    int bitno_firstpart,    /* (i) number of bits in most\n                                       significant part */\n    int bitno_total             /* (i) number of bits in full range\n                                       of value */\n){\n    int bitno_rest = bitno_total-bitno_firstpart;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    *firstpart = *index>>(bitno_rest);\n    *rest = *index-(*firstpart<<(bitno_rest));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  combining a value corresponding to msb's with a value\n *  corresponding to lsb's\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void packcombine(\n    int *index,                 /* (i/o) the msb value in the\n                                       combined value out */\n    int rest,                   /* (i) the lsb value */\n    int bitno_rest              /* (i) the number of bits in the\n                                       lsb part */\n){\n    *index = *index<<bitno_rest;\n    *index += rest;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  packing of bits into bitstream, i.e., vector of bytes\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void dopack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to pack\n                                       new data, on exit pointer\n                                       to place in bitstream to\n                                       pack future data */\n    int index,                  /* (i) the value to pack */\n    int bitno,                  /* (i) the number of bits that the\n                                       value will fit within */\n    int *pos                /* (i/o) write position in the\n                                       current byte */\n){\n    int posLeft;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Clear the bits before starting in a new byte */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if ((*pos)==0) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    **bitstream=0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "while (bitno>0) {",
      "ja": "while (ビット番号 > 0) {"
    },
    {
      "indent": 11,
      "text": "/* Jump to the next byte if end of this byte is reached*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (*pos==8) {\n    *pos=0;\n    (*bitstream)++;\n    **bitstream=0;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "posLeft=8-(*pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Insert index into the bitstream */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (bitno <= posLeft) {\n    **bitstream |= (unsigned char)(index<<(posLeft-bitno));\n    *pos+=bitno;\n    bitno=0;\n} else {\n    **bitstream |= (unsigned char)(index>>(bitno-posLeft));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "*pos=8;\nindex-=((index>>(bitno-posLeft))<<(bitno-posLeft));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            bitno-=posLeft;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  unpacking of bits from bitstream, i.e., vector of bytes\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void unpack(\n    unsigned char **bitstream,  /* (i/o) on entrance pointer to\n                                       place in bitstream to\n                                       unpack new data from, on\n                                       exit pointer to place in\n                                       bitstream to unpack future\n                                       data from */\n    int *index,                 /* (o) resulting value */\n    int bitno,                  /* (i) number of bits used to\n                                       represent the value */\n    int *pos                /* (i/o) read position in the\n                                       current byte */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "){ int BitsLeft;",
      "ja": "){ int BitsLeft;"
    },
    {
      "indent": 7,
      "text": "*index=0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "while (bitno>0) {",
      "ja": "while (ビット番号 > 0) {"
    },
    {
      "indent": 11,
      "text": "/* move forward in bitstream when the end of the\n   byte is reached */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (*pos==8) {\n    *pos=0;\n    (*bitstream)++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "BitsLeft=8-(*pos);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* Extract bits to index */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if (BitsLeft>=bitno) {\n    *index+=((((**bitstream)<<(*pos)) & 0xFF)>>(8-bitno));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "    *pos+=bitno;\n    bitno=0;\n} else {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "            if ((8-bitno)>0) {\n                *index+=((((**bitstream)<<(*pos)) & 0xFF)>>\n                    (8-bitno));\n                *pos=8;\n            } else {\n                *index+=(((int)(((**bitstream)<<(*pos)) & 0xFF))<<\n                    (bitno-8));\n                *pos=8;\n            }\n            bitno-=BitsLeft;\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.43. StateConstructW.h",
      "section_title": true,
      "ja": "A.43. StateConstructWh.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "StateConstructW.h Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "StateConstructW.h 著作権 (C) The Internet Society (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_STATECONSTRUCTW_H #define __iLBC_STATECONSTRUCTW_H",
      "ja": "#ifndef __iLBC_STATECONSTRUCTW_H #define __iLBC_STATECONSTRUCTW_H"
    },
    {
      "indent": 3,
      "text": "void StateConstructW(\n    int idxForMax,      /* (i) 6-bit index for the quantization of\n                               max amplitude */\n    int *idxVec,    /* (i) vector of quantization indexes */\n    float *syntDenum,   /* (i) synthesis filter denumerator */\n    float *out,         /* (o) the decoded state vector */\n    int len             /* (i) length of a state vector */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.44. StateConstructW.c",
      "section_title": true,
      "ja": "A.44. StateConstructW.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "StateConstructW.c",
      "ja": "StateConstructW.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  decoding of the start state\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void StateConstructW(\n    int idxForMax,      /* (i) 6-bit index for the quantization of\n                               max amplitude */\n    int *idxVec,    /* (i) vector of quantization indexes */\n    float *syntDenum,   /* (i) synthesis filter denumerator */\n       float *out,         /* (o) the decoded state vector */\n    int len             /* (i) length of a state vector */\n){\n    float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN], *tmp,\n        numerator[LPC_FILTERORDER+1];\n    float foutbuf[LPC_FILTERORDER+2*STATE_LEN], *fout;\n    int k,tmpi;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* decoding of the maximum value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "maxVal = state_frgqTbl[idxForMax];\nmaxVal = (float)pow(10,maxVal)/(float)4.5;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* initialization of buffers and coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));\nmemset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\nfor (k=0; k<LPC_FILTERORDER; k++) {\n    numerator[k]=syntDenum[LPC_FILTERORDER-k];\n}\nnumerator[LPC_FILTERORDER]=syntDenum[0];\ntmp = &tmpbuf[LPC_FILTERORDER];\nfout = &foutbuf[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* decoding of the sample values */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (k=0; k<len; k++) {\n    tmpi = len-1-k;\n    /* maxVal = 1/scal */\n    tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* circular convolution with all-pass filter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    memset(tmp+len, 0, len*sizeof(float));\n    ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,\n        LPC_FILTERORDER, fout);\n    for (k=0;k<len;k++) {\n        out[k] = fout[len-1-k]+fout[2*len-1-k];\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "A.45. StateSearchW.h",
      "section_title": true,
      "ja": "A.45. 州検索WH"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "StateSearchW.h",
      "ja": "州検索WH"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_STATESEARCHW_H #define __iLBC_STATESEARCHW_H",
      "ja": "#ifndef __iLBC_STATESEARCHW_H #define __iLBC_STATESEARCHW_H"
    },
    {
      "indent": 3,
      "text": "void AbsQuantW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *in,          /* (i) vector to encode */\n    float *syntDenum,   /* (i) denominator of synthesis filter */\n    float *weightDenum, /* (i) denominator of weighting filter */\n    int *out,           /* (o) vector of quantizer indexes */\n    int len,        /* (i) length of vector to encode and\n                               vector of quantizer indexes */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void StateSearchW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *residual,/* (i) target residual vector */\n    float *syntDenum,   /* (i) lpc synthesis filter */\n    float *weightDenum, /* (i) weighting filter denuminator */\n    int *idxForMax,     /* (o) quantizer index for maximum\n                               amplitude */\n    int *idxVec,    /* (o) vector of quantization indexes */\n    int len,        /* (i) length of all vectors */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.46. StateSearchW.c",
      "section_title": true,
      "ja": "A.46. 州検索W.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "StateSearchW.c",
      "ja": "州検索W.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include <math.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\" #include \"helpfun.h\"",
      "ja": "#include \"iLBC_define.h\" #include \"constants.h\" #include \"filter.h\" #include \"helpfun.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  predictive noise shaping encoding of scaled start state\n *  (subrutine for StateSearchW)\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void AbsQuantW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *in,          /* (i) vector to encode */\n    float *syntDenum,   /* (i) denominator of synthesis filter */\n    float *weightDenum, /* (i) denominator of weighting filter */\n    int *out,           /* (o) vector of quantizer indexes */\n    int len,        /* (i) length of vector to encode and\n                               vector of quantizer indexes */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n){\n    float *syntOut;\n    float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];\n    float toQ, xq;\n    int n;\n    int index;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* initialization of buffer for filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* initialization of pointer for filtering */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "syntOut = &syntOutBuf[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* synthesis and weighting filters on input */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (state_first) {\n    AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);\n} else {\n    AllPoleFilter (in, weightDenum,\n        iLBCenc_inst->state_short_len-SUBL,\n        LPC_FILTERORDER);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* encoding loop */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (n=0; n<len; n++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* time update of filter coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "if ((state_first)&&(n==SUBL)){\n    syntDenum += (LPC_FILTERORDER+1);\n    weightDenum += (LPC_FILTERORDER+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* synthesis and weighting filters on input */\nAllPoleFilter (&in[n], weightDenum, len-n,\n    LPC_FILTERORDER);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "} else if ((state_first==0)&&\n    (n==(iLBCenc_inst->state_short_len-SUBL))) {\n    syntDenum += (LPC_FILTERORDER+1);\n    weightDenum += (LPC_FILTERORDER+1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "/* synthesis and weighting filters on input */\nAllPoleFilter (&in[n], weightDenum, len-n,\n    LPC_FILTERORDER);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 11,
      "text": "/* prediction of synthesized and weighted input */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "syntOut[n] = 0.0; AllPoleFilter (&syntOut[n], weightDenum, 1, LPC_FILTERORDER);",
      "ja": "syntOut[n] = 0.0;AllPoleFilter (&syntOut[n]、weightDenum、1、LPC_FILTERORDER);"
    },
    {
      "indent": 11,
      "text": "/* quantization */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "toQ = in[n]-syntOut[n];",
      "ja": "toQ = in[n]-syntOut[n];"
    },
    {
      "indent": 11,
      "text": "sort_sq(&xq, &index, toQ, state_sq3Tbl, 8);\nout[n]=index;\nsyntOut[n] = state_sq3Tbl[out[n]];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "/* update of the prediction filter */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "        AllPoleFilter(&syntOut[n], weightDenum, 1,\n            LPC_FILTERORDER);\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  encoding of start state\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void StateSearchW(\n    iLBC_Enc_Inst_t *iLBCenc_inst,\n                        /* (i) Encoder instance */\n    float *residual,/* (i) target residual vector */\n    float *syntDenum,   /* (i) lpc synthesis filter */\n    float *weightDenum, /* (i) weighting filter denuminator */\n    int *idxForMax,     /* (o) quantizer index for maximum\n                               amplitude */\n    int *idxVec,    /* (o) vector of quantization indexes */\n    int len,        /* (i) length of all vectors */\n    int state_first     /* (i) position of start state in the\n                               80 vec */\n){\n    float dtmp, maxVal;\n    float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];\n    float *tmp, numerator[1+LPC_FILTERORDER];\n    float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS], *fout;\n    int k;\n    float qmax, scal;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* initialization of buffers and filter coefficients */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));\nmemset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\nfor (k=0; k<LPC_FILTERORDER; k++) {\n    numerator[k]=syntDenum[LPC_FILTERORDER-k];\n}\nnumerator[LPC_FILTERORDER]=syntDenum[0];\ntmp = &tmpbuf[LPC_FILTERORDER];\nfout = &foutbuf[LPC_FILTERORDER];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* circular convolution with the all-pass filter */\n       memcpy(tmp, residual, len*sizeof(float));\nmemset(tmp+len, 0, len*sizeof(float));\nZeroPoleFilter(tmp, numerator, syntDenum, 2*len,\n    LPC_FILTERORDER, fout);\nfor (k=0; k<len; k++) {\n    fout[k] += fout[k+len];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* identification of the maximum amplitude value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "maxVal = fout[0];\nfor (k=1; k<len; k++) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    if (fout[k]*fout[k] > maxVal*maxVal){\n        maxVal = fout[k];\n    }\n}\nmaxVal=(float)fabs(maxVal);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* encoding of the maximum amplitude value */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (maxVal < 10.0) {\n    maxVal = 10.0;\n}\nmaxVal = (float)log10(maxVal);\nsort_sq(&dtmp, idxForMax, maxVal, state_frgqTbl, 64);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* decoding of the maximum amplitude representation value,\n   and corresponding scaling of start state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "maxVal=state_frgqTbl[*idxForMax];\nqmax = (float)pow(10,maxVal);\nscal = (float)(4.5)/qmax;\nfor (k=0; k<len; k++){\n    fout[k] *= scal;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* predictive noise shaping encoding of scaled start state */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " AbsQuantW(iLBCenc_inst, fout,syntDenum, weightDenum,idxVec, len, state_first); }",
      "ja": "AbsQuantW(iLBCenc_inst, fout,syntDenum,weightDenum,idxVec, len, state_first);}"
    },
    {
      "indent": 0,
      "text": "A.47. syntFilter.h",
      "section_title": true,
      "ja": "A.47. syntFilter.h"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "syntFilter.h",
      "ja": "syntFilter.h"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#ifndef __iLBC_SYNTFILTER_H #define __iLBC_SYNTFILTER_H",
      "ja": "#ifndef __iLBC_SYNTFILTER_H #define __iLBC_SYNTFILTER_H"
    },
    {
      "indent": 3,
      "text": "void syntFilter(\n    float *Out,     /* (i/o) Signal to be filtered */\n    float *a,       /* (i) LP parameters */\n    int len,    /* (i) Length of signal */\n    float *mem      /* (i/o) Filter state */\n);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#endif",
      "ja": "#endif"
    },
    {
      "indent": 0,
      "text": "A.48. syntFilter.c",
      "section_title": true,
      "ja": "A.48. syntFilter.c"
    },
    {
      "indent": 3,
      "text": "/******************************************************************",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "iLBC Speech Coder ANSI-C Source Code",
      "ja": "iLBC スピーチ コーダー ANSI-C ソース コード"
    },
    {
      "indent": 7,
      "text": "syntFilter.c",
      "ja": "syntFilter.c"
    },
    {
      "indent": 7,
      "text": "Copyright (C) The Internet Society (2004). All Rights Reserved.",
      "ja": "著作権 (C) インターネット協会 (2004)。無断転載を禁じます。"
    },
    {
      "indent": 3,
      "text": "******************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "#include \"iLBC_define.h\"",
      "ja": "#include \"iLBC_define.h\""
    },
    {
      "indent": 3,
      "text": "/*----------------------------------------------------------------*\n *  LP synthesis filter.\n *---------------------------------------------------------------*/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "void syntFilter(\n    float *Out,     /* (i/o) Signal to be filtered */\n    float *a,       /* (i) LP parameters */\n    int len,    /* (i) Length of signal */\n       float *mem      /* (i/o) Filter state */\n){\n    int i, j;\n    float *po, *pi, *pa, *pm;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "po=Out;",
      "ja": "po=アウト;"
    },
    {
      "indent": 7,
      "text": "/* Filter first part using memory from past */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=0; i<LPC_FILTERORDER; i++) {\n    pi=&Out[i-1];\n    pa=&a[1];\n    pm=&mem[LPC_FILTERORDER-1];\n    for (j=1; j<=i; j++) {\n        *po-=(*pa++)*(*pi--);\n    }\n    for (j=i+1; j<LPC_FILTERORDER+1; j++) {\n        *po-=(*pa++)*(*pm--);\n    }\n    po++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Filter last part where the state is entirely in\n   the output vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "for (i=LPC_FILTERORDER; i<len; i++) {\n    pi=&Out[i-1];\n    pa=&a[1];\n    for (j=1; j<LPC_FILTERORDER+1; j++) {\n        *po-=(*pa++)*(*pi--);\n    }\n    po++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "/* Update state vector */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    memcpy(mem, &Out[len-LPC_FILTERORDER],\n        LPC_FILTERORDER*sizeof(float));\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Soren Vang Andersen Department of Communication Technology Aalborg University Fredrik Bajers Vej 7A 9200 Aalborg Denmark",
      "ja": "Soren Vang Andersen コミュニケーション技術学部 オールボー大学 Fredrik Bajers Vej 7A 9200 オールボー デンマーク"
    },
    {
      "indent": 3,
      "text": "Phone:  ++45 9 6358627\nEMail:  sva@kom.auc.dk",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Alan Duric Telio AS Stoperigt. 2 Oslo, N-0250 Norway",
      "ja": "アラン・デュリック・テリオ AS ストペリグト。2 オスロ、N-0250 ノルウェー"
    },
    {
      "indent": 3,
      "text": "Phone:  +47 21673555\nEMail:  alan.duric@telio.no",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Henrik Astrom Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "Henrik Astrom Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 54553040\nEMail:  henrik.astrom@globalipsound.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Roar Hagen Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "Roar Hagen Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone: +46 8 54553040 EMail: roar.hagen@globalipsound.com W. Bastiaan Kleijn Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 Sweden",
      "ja": "電話: 46 8 54553040 電子メール: Roar.hagen@globalipsound.com W. Bastiaan Kleijn Global IP Sound AB Olandsgatan 42 Stockholm, S-11663 スウェーデン"
    },
    {
      "indent": 3,
      "text": "Phone:  +46 8 54553040\nEMail:  bastiaan.kleijn@globalipsound.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jan Linden Global IP Sound Inc. 900 Kearny Street, suite 500 San Francisco, CA-94133 USA",
      "ja": "Jan Linden Global IP Sound Inc. 900 Kearny Street, suite 500 San Francisco, CA-94133 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 415 397 2555\nEMail: jan.linden@globalipsound.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権に関する声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2004).",
      "ja": "著作権 (C) インターネット協会 (2004)。"
    },
    {
      "indent": 3,
      "text": "This document is subject to the rights, licenses and restrictions contained in BCP 78, and except as set forth therein, the authors retain all their rights.",
      "ja": "この文書は、BCP 78 に含まれる権利、ライセンス、および制限の対象となり、そこに規定されている場合を除き、著者はすべての権利を保持します。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein are provided on an \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書およびここに含まれる情報は「現状のまま」で提供され、寄稿者、寄稿者が代表または後援する組織（存在する場合）、インターネット協会およびインターネット エンジニアリング タスク フォースは、明示的または明示的または明示的に、すべての保証を否認します。ここに記載された情報の使用がいかなる権利も侵害しないことの黙示的な保証、または商品性や特定の目的への適合性の黙示的な保証を含みますが、これに限定されません。"
    },
    {
      "indent": 0,
      "text": "Intellectual Property",
      "ja": "知的財産"
    },
    {
      "indent": 3,
      "text": "The IETF takes no position regarding the validity or scope of any Intellectual Property Rights or other rights that might be claimed to pertain to the implementation or use of the technology described in this document or the extent to which any license under such rights might or might not be available; nor does it represent that it has made any independent effort to identify any such rights. Information on the IETF's procedures with respect to rights in IETF Documents can be found in BCP 78 and BCP 79.",
      "ja": "IETF は、本書に記載されているテクノロジの実装または使用に関連すると主張される知的財産権またはその他の権利の有効性や範囲、あるいはそのような権利に基づくライセンスが適用されるかどうかの範囲に関して、いかなる立場も負いません。利用可能であること。また、かかる権利を特定するために独自の努力を行ったことを示すものでもありません。IETF 文書の権利に関する IETF の手順に関する情報は、BCP 78 および BCP 79 に記載されています。"
    },
    {
      "indent": 3,
      "text": "Copies of IPR disclosures made to the IETF Secretariat and any assurances of licenses to be made available, or the result of an attempt made to obtain a general license or permission for the use of such proprietary rights by implementers or users of this specification can be obtained from the IETF on-line IPR repository at http://www.ietf.org/ipr.",
      "ja": "IETF 事務局に提出された IPR 開示のコピー、および利用可能になるライセンスの保証、またはこの仕様の実装者またはユーザーによるそのような所有権の使用に対する一般ライセンスまたは許可を取得しようとする試みの結果を入手できます。IETF オンライン IPR リポジトリ (http://www.ietf.org/ipr) から入手してください。"
    },
    {
      "indent": 3,
      "text": "The IETF invites any interested party to bring to its attention any copyrights, patents or patent applications, or other proprietary rights that may cover technology that may be required to implement this standard. Please address the information to the IETF at ietf-ipr@ietf.org.",
      "ja": "IETF は、利害関係者に対し、この規格の実装に必要とされる可能性のある技術をカバーする著作権、特許、特許出願、またはその他の所有権について注意を喚起するよう呼びかけています。情報は IETF (ietf-ipr@ietf.org) に送信してください。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFC エディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}