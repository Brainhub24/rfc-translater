{
  "title": {
    "text": "RFC 3492 - Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)",
    "ja": "RFC 3492 - Punycode：アプリケーションでの国際化ドメイン名のUnicodeのブートストリングエンコーディング（IDNA）"
  },
  "number": 3492,
  "created_at": "2022-11-02 14:14:23.397484+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                        A. Costello\nRequest for Comments: 3492                 Univ. of California, Berkeley\nCategory: Standards Track                                     March 2003",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": " Punycode: A Bootstring encoding of Unicode for Internationalized Domain Names in Applications (IDNA)",
      "ja": "Punycode：アプリケーションでの国際化ドメイン名のUnicodeのブートストリングエンコーディング（IDNA）"
    },
    {
      "indent": 0,
      "text": "Status of this Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。全著作権所有。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Punycode is a simple and efficient transfer encoding syntax designed for use with Internationalized Domain Names in Applications (IDNA). It uniquely and reversibly transforms a Unicode string into an ASCII string. ASCII characters in the Unicode string are represented literally, and non-ASCII characters are represented by ASCII characters that are allowed in host name labels (letters, digits, and hyphens). This document defines a general algorithm called Bootstring that allows a string of basic code points to uniquely represent any string of code points drawn from a larger set. Punycode is an instance of Bootstring that uses particular parameter values specified by this document, appropriate for IDNA.",
      "ja": "Punycodeは、アプリケーション（IDNA）で国際化されたドメイン名で使用するために設計されたシンプルで効率的な転送エンコード構文です。ユニークでユニコード文字列をASCII文字列に変換します。Unicode文字列のASCII文字は文字通り表され、非ASCII文字はホスト名ラベル（文字、数字、ハイフン）で許可されるASCII文字で表されます。このドキュメントでは、Bootstringと呼ばれる一般的なアルゴリズムを定義します。これにより、一連の基本コードポイントが、より大きなセットから描かれた一連のコードポイントを一意に表すことができます。Punycodeは、IDNAに適したこのドキュメントで指定された特定のパラメーター値を使用するブートストリングのインスタンスです。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction...............................................2\n    1.1 Features..............................................2\n    1.2 Interaction of protocol parts.........................3\n2. Terminology................................................3\n3. Bootstring description.....................................4\n    3.1 Basic code point segregation..........................4\n    3.2 Insertion unsort coding...............................4\n    3.3 Generalized variable-length integers..................5\n    3.4 Bias adaptation.......................................7\n4. Bootstring parameters......................................8\n5. Parameter values for Punycode..............................8\n6. Bootstring algorithms......................................9",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    6.1 Bias adaptation function.............................10\n    6.2 Decoding procedure...................................11\n    6.3 Encoding procedure...................................12\n    6.4 Overflow handling....................................13\n7. Punycode examples.........................................14\n    7.1 Sample strings.......................................14\n    7.2 Decoding traces......................................17\n    7.3 Encoding traces......................................19\n8. Security Considerations...................................20\n9. References................................................21\n    9.1 Normative References.................................21\n    9.2 Informative References...............................21\nA. Mixed-case annotation.....................................22\nB. Disclaimer and license....................................22\nC. Punycode sample implementation............................23\nAuthor's Address.............................................34\nFull Copyright Statement.....................................35",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "[IDNA] describes an architecture for supporting internationalized domain names. Labels containing non-ASCII characters can be represented by ACE labels, which begin with a special ACE prefix and contain only ASCII characters. The remainder of the label after the prefix is a Punycode encoding of a Unicode string satisfying certain constraints. For the details of the prefix and constraints, see [IDNA] and [NAMEPREP].",
      "ja": "[IDNA]は、国際化されたドメイン名をサポートするためのアーキテクチャについて説明しています。非ASCII文字を含むラベルは、特別なACEプレフィックスで始まり、ASCII文字のみを含むACEラベルで表現できます。プレフィックスの後のラベルの残りの部分は、特定の制約を満たすユニコード文字列のパニコードエンコードです。接頭辞と制約の詳細については、[IDNA]と[NamePrep]を参照してください。"
    },
    {
      "indent": 3,
      "text": "Punycode is an instance of a more general algorithm called Bootstring, which allows strings composed from a small set of \"basic\" code points to uniquely represent any string of code points drawn from a larger set. Punycode is Bootstring with particular parameter values appropriate for IDNA.",
      "ja": "Punycodeは、Bootstringと呼ばれるより一般的なアルゴリズムのインスタンスであり、「基本的な」コードポイントの小さなセットから構成される文字列が、より大きなセットから描かれた一連のコードポイントを一意に表すことができます。Punycodeは、IDNAに適した特定のパラメーター値を持つブートストリングです。"
    },
    {
      "indent": 0,
      "text": "1.1 Features",
      "section_title": true,
      "ja": "1.1 特徴"
    },
    {
      "indent": 3,
      "text": "Bootstring has been designed to have the following features:",
      "ja": "Bootstringは、次の機能を持つように設計されています。"
    },
    {
      "indent": 3,
      "text": "* Completeness: Every extended string (sequence of arbitrary code points) can be represented by a basic string (sequence of basic code points). Restrictions on what strings are allowed, and on length, can be imposed by higher layers.",
      "ja": "* 完全性：すべての拡張文字列（任意のコードポイントのシーケンス）は、基本文字列（基本コードポイントのシーケンス）で表すことができます。許可されている文字列の制限、および長さの制限は、より高い層によって課すことができます。"
    },
    {
      "indent": 3,
      "text": "* Uniqueness: There is at most one basic string that represents a given extended string.",
      "ja": "* 一意性：与えられた拡張文字列を表す基本的な文字列は最大1つあります。"
    },
    {
      "indent": 3,
      "text": "* Reversibility: Any extended string mapped to a basic string can be recovered from that basic string.",
      "ja": "* 可逆性：基本的な文字列にマッピングされた拡張された文字列は、その基本文字列から回復できます。"
    },
    {
      "indent": 3,
      "text": "* Efficient encoding: The ratio of basic string length to extended string length is small. This is important in the context of domain names because RFC 1034 [RFC1034] restricts the length of a domain label to 63 characters.",
      "ja": "* 効率的なエンコーディング：基本文字列の長さと延長された文字列の長さの比は小さいです。これは、RFC 1034 [RFC1034]がドメインラベルの長さを63文字に制限するため、ドメイン名のコンテキストで重要です。"
    },
    {
      "indent": 3,
      "text": "* Simplicity: The encoding and decoding algorithms are reasonably simple to implement. The goals of efficiency and simplicity are at odds; Bootstring aims at a good balance between them.",
      "ja": "* シンプルさ：エンコーディングおよびデコードアルゴリズムの実装はかなり簡単です。効率とシンプルさの目標は対立しています。ブートストリングは、それらの間のバランスをとることを目指しています。"
    },
    {
      "indent": 3,
      "text": "* Readability: Basic code points appearing in the extended string are represented as themselves in the basic string (although the main purpose is to improve efficiency, not readability).",
      "ja": "* 読みやすさ：拡張文字列に表示される基本コードポイントは、基本的な文字列でそれ自体として表されます（ただし、主な目的は、読みやすさではなく効率を改善することです）。"
    },
    {
      "indent": 3,
      "text": "Punycode can also support an additional feature that is not used by the ToASCII and ToUnicode operations of [IDNA]. When extended strings are case-folded prior to encoding, the basic string can use mixed case to tell how to convert the folded string into a mixed-case string. See appendix A \"Mixed-case annotation\".",
      "ja": "Punycodeは、[IDNA]のToasciiおよびTounicode操作では使用されていない追加の機能もサポートできます。エンコードの前に拡張された文字列がケース折りたたまれると、基本的な文字列は混合ケースを使用して、折り畳まれた文字列を混合ケースの文字列に変換する方法を伝えることができます。付録A「混合ケースアノテーション」を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.2 Interaction of protocol parts",
      "section_title": true,
      "ja": "1.2 プロトコル部分の相互作用"
    },
    {
      "indent": 3,
      "text": "Punycode is used by the IDNA protocol [IDNA] for converting domain labels into ASCII; it is not designed for any other purpose. It is explicitly not designed for processing arbitrary free text.",
      "ja": "Punycodeは、ドメインラベルをASCIIに変換するためにIDNAプロトコル[IDNA]によって使用されます。他の目的のために設計されていません。任意の無料テキストを処理するために明示的に設計されていません。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、BCP 14、RFC 2119 [RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "A code point is an integral value associated with a character in a coded character set.",
      "ja": "コードポイントは、コード化された文字セットの文字に関連付けられた不可欠な値です。"
    },
    {
      "indent": 3,
      "text": "As in the Unicode Standard [UNICODE], Unicode code points are denoted by \"U+\" followed by four to six hexadecimal digits, while a range of code points is denoted by two hexadecimal numbers separated by \"..\", with no prefixes.",
      "ja": "Unicode標準[Unicode]と同様に、Unicodeコードポイントは「U」に続く4〜6匹の16進数で示されますが、コードポイントの範囲は、「..」で区切られた2つの16進数で示されます。"
    },
    {
      "indent": 3,
      "text": "The operators div and mod perform integer division; (x div y) is the quotient of x divided by y, discarding the remainder, and (x mod y) is the remainder, so (x div y) * y + (x mod y) == x. Bootstring uses these operators only with nonnegative operands, so the quotient and remainder are always nonnegative.",
      "ja": "オペレーターDivおよびMODは、整数部門を実行します。（x div y）はxの商をyで割って残りを破棄し、（x mod y）が残りを廃棄するので、（x div y） * y（x mod y）== x。Bootstringはこれらのオペレーターを非陰性オペランドでのみ使用するため、商と残りは常に非陰性です。"
    },
    {
      "indent": 3,
      "text": "The break statement jumps out of the innermost loop (as in C).",
      "ja": "ブレークステートメントは、最も内側のループから飛び出します（cのように）。"
    },
    {
      "indent": 3,
      "text": "An overflow is an attempt to compute a value that exceeds the maximum value of an integer variable.",
      "ja": "オーバーフローとは、整数変数の最大値を超える値を計算する試みです。"
    },
    {
      "indent": 0,
      "text": "3. Bootstring description",
      "section_title": true,
      "ja": "3. ブートストリングの説明"
    },
    {
      "indent": 3,
      "text": "Bootstring represents an arbitrary sequence of code points (the \"extended string\") as a sequence of basic code points (the \"basic string\"). This section describes the representation. Section 6 \"Bootstring algorithms\" presents the algorithms as pseudocode. Sections 7.1 \"Decoding traces\" and 7.2 \"Encoding traces\" trace the algorithms for sample inputs.",
      "ja": "ブートストリングは、基本コードポイント（「基本文字列」）のシーケンスとしてのコードポイント（「拡張文字列」）の任意のシーケンスを表します。このセクションでは、表現について説明します。セクション6「ブートストリングアルゴリズム」は、アルゴリズムを擬似コードとして示します。セクション7.1「デコードトレース」と7.2「エンコードトレース」は、サンプル入力のアルゴリズムをトレースします。"
    },
    {
      "indent": 3,
      "text": "The following sections describe the four techniques used in Bootstring. \"Basic code point segregation\" is a very simple and efficient encoding for basic code points occurring in the extended string: they are simply copied all at once. \"Insertion unsort coding\" encodes the non-basic code points as deltas, and processes the code points in numerical order rather than in order of appearance, which typically results in smaller deltas. The deltas are represented as \"generalized variable-length integers\", which use basic code points to represent nonnegative integers. The parameters of this integer representation are dynamically adjusted using \"bias adaptation\", to improve efficiency when consecutive deltas have similar magnitudes.",
      "ja": "次のセクションでは、ブートストリングで使用される4つの手法について説明します。「Basic Code Point Segregation」は、拡張文字列で発生する基本コードポイントの非常にシンプルで効率的なエンコードです。それらは一度にすべてコピーされます。「Insertion unsort Coding」は、非基準コードポイントをデルタとしてエンコードし、外観の順にコードポイントを数値で処理します。これにより、通常は小さくなります。デルタは「一般化された可変長さの整数」として表され、基本的なコードポイントを使用して非陰性整数を表します。この整数表現のパラメーターは、「バイアス適応」を使用して動的に調整され、連続したデルタが同様の大きさを持っている場合に効率を向上させます。"
    },
    {
      "indent": 0,
      "text": "3.1 Basic code point segregation",
      "section_title": true,
      "ja": "3.1 基本的なコードポイント分離"
    },
    {
      "indent": 3,
      "text": "All basic code points appearing in the extended string are represented literally at the beginning of the basic string, in their original order, followed by a delimiter if (and only if) the number of basic code points is nonzero. The delimiter is a particular basic code point, which never appears in the remainder of the basic string. The decoder can therefore find the end of the literal portion (if there is one) by scanning for the last delimiter.",
      "ja": "拡張文字列に表示されるすべての基本コードポイントは、基本的な文字列の先頭に文字通り元の順序で表され、その後に基本コードポイントの数がゼロである場合（および場合にのみ）区切り文字が続きます。区切り文字は特定の基本コードポイントであり、基本文字列の残りの部分には決して表示されません。したがって、デコーダーは、最後の区切り文字をスキャンすることにより、リテラル部分の終わり（ある場合）を見つけることができます。"
    },
    {
      "indent": 0,
      "text": "3.2 Insertion unsort coding",
      "section_title": true,
      "ja": "3.2 挿入アンソートコーディング"
    },
    {
      "indent": 3,
      "text": "The remainder of the basic string (after the last delimiter if there is one) represents a sequence of nonnegative integral deltas as generalized variable-length integers, described in section 3.3. The meaning of the deltas is best understood in terms of the decoder.",
      "ja": "基本文字列の残りの部分（最後の区切り文字がある場合は、最後の区切り文字がある場合）は、セクション3.3で説明されている一般化された可変長整数としての非陰性積分デルタのシーケンスを表します。デルタの意味は、デコーダーの観点から最もよく理解されています。"
    },
    {
      "indent": 3,
      "text": "The decoder builds the extended string incrementally. Initially, the extended string is a copy of the literal portion of the basic string (excluding the last delimiter). The decoder inserts non-basic code points, one for each delta, into the extended string, ultimately arriving at the final decoded string.",
      "ja": "デコーダーは、拡張文字列を段階的に構築します。最初に、拡張文字列は、基本文字列のリテラル部分のコピーです（最後の区切り文字を除く）。デコーダーは、各デルタ用に1つの非基準コードポイントを拡張文字列に挿入し、最終的に最終的なデコードされた文字列に到着します。"
    },
    {
      "indent": 3,
      "text": "At the heart of this process is a state machine with two state variables: an index i and a counter n. The index i refers to a position in the extended string; it ranges from 0 (the first position) to the current length of the extended string (which refers to a potential position beyond the current end). If the current state is <n,i>, the next state is <n,i+1> if i is less than the length of the extended string, or <n+1,0> if i equals the length of the extended string. In other words, each state change causes i to increment, wrapping around to zero if necessary, and n counts the number of wrap-arounds.",
      "ja": "このプロセスの中心には、インデックスIとカウンターnの2つの状態変数を備えた状態マシンがあります。インデックスIは、拡張文字列の位置を指します。0（最初の位置）から拡張文字列の現在の長さ（現在の端を超えた潜在的な位置を指します）の範囲です。現在の状態が<n、i>の場合、次の状態は<n、i 1>拡張文字列の長さよりも小さい場合、または拡張文字列の長さに等しい場合は<n 1,0>です。言い換えれば、各状態の変化により、Iが増加し、必要に応じてゼロに包み込み、nはラップアラウンドの数を数えます。"
    },
    {
      "indent": 3,
      "text": "Notice that the state always advances monotonically (there is no way for the decoder to return to an earlier state). At each state, an insertion is either performed or not performed. At most one insertion is performed in a given state. An insertion inserts the value of n at position i in the extended string. The deltas are a run-length encoding of this sequence of events: they are the lengths of the runs of non-insertion states preceeding the insertion states. Hence, for each delta, the decoder performs delta state changes, then an insertion, and then one more state change. (An implementation need not perform each state change individually, but can instead use division and remainder calculations to compute the next insertion state directly.) It is an error if the inserted code point is a basic code point (because basic code points were supposed to be segregated as described in section 3.1).",
      "ja": "状態は常に単調に進歩していることに注意してください（デコーダーが以前の状態に戻る方法はありません）。各状態で、挿入が実行されるか、実行されません。最大で1つの挿入が特定の状態で実行されます。挿入により、拡張文字列の位置Iにnの値が挿入されます。デルタは、この一連のイベントの走行距離エンコードです。これらは、挿入状態を前処理する非挿入状態の実行の長さです。したがって、各デルタについて、デコーダーはデルタ状態の変更を実行し、次に挿入し、さらに1つの状態の変更を実行します。（実装は各状態の変更を個別に実行する必要はありませんが、代わりに分割と残りの計算を使用して次の挿入状態を直接計算できます。）挿入されたコードポイントが基本コードポイントである場合（基本コードポイントが想定されていたため、エラーです。セクション3.1で説明されているように分離されます）。"
    },
    {
      "indent": 3,
      "text": "The encoder's main task is to derive the sequence of deltas that will cause the decoder to construct the desired string. It can do this by repeatedly scanning the extended string for the next code point that the decoder would need to insert, and counting the number of state changes the decoder would need to perform, mindful of the fact that the decoder's extended string will include only those code points that have already been inserted. Section 6.3 \"Encoding procedure\" gives a precise algorithm.",
      "ja": "エンコーダーの主なタスクは、デコーダーが目的の文字列を構築する原因となるデルタのシーケンスを導出することです。これは、デコーダーが挿入する必要がある次のコードポイントの拡張文字列を繰り返しスキャンし、デコーダーが実行する必要がある状態の変更の数をカウントすることでこれを行うことができます。すでに挿入されているコードポイント。セクション6.3「エンコード手順」は、正確なアルゴリズムを示しています。"
    },
    {
      "indent": 0,
      "text": "3.3 Generalized variable-length integers",
      "section_title": true,
      "ja": "3.3 一般化された可変長整数"
    },
    {
      "indent": 3,
      "text": "In a conventional integer representation the base is the number of distinct symbols for digits, whose values are 0 through base-1. Let digit_0 denote the least significant digit, digit_1 the next least significant, and so on. The value represented is the sum over j of digit_j * w(j), where w(j) = base^j is the weight (scale factor) for position j. For example, in the base 8 integer 437, the digits are 7, 3, and 4, and the weights are 1, 8, and 64, so the value is 7 + 3*8 + 4*64 = 287. This representation has two disadvantages: First, there are multiple encodings of each value (because there can be extra zeros in the most significant positions), which is inconvenient",
      "ja": "従来の整数表現では、ベースは数字の明確なシンボルの数であり、その値は0からbase-1です。DIGIT_0は、最も有意な数字、DIGIT_1が次に最も重要でないことなどを示します。表される値は、digit_j * w（j）のjの合計です。ここで、w（j）= base^jは位置jの重み（スケール係数）です。たとえば、ベース8整数437では、数字は7、3、および4、重みは1、8、および64であるため、値は7 3*8 4*64 = 287です。この表現には2つの欠点があります。：最初に、各値には複数のエンコーディングがあります（最も重要な位置に余分なゼロがある可能性があるため）。"
    },
    {
      "indent": 3,
      "text": "when unique encodings are needed. Second, the integer is not self-delimiting, so if multiple integers are concatenated the boundaries between them are lost.",
      "ja": "一意のエンコーディングが必要な場合。第二に、整数は自己決定ではないため、複数の整数が連結されている場合、それらの間の境界が失われます。"
    },
    {
      "indent": 3,
      "text": "The generalized variable-length representation solves these two problems. The digit values are still 0 through base-1, but now the integer is self-delimiting by means of thresholds t(j), each of which is in the range 0 through base-1. Exactly one digit, the most significant, satisfies digit_j < t(j). Therefore, if several integers are concatenated, it is easy to separate them, starting with the first if they are little-endian (least significant digit first), or starting with the last if they are big-endian (most significant digit first). As before, the value is the sum over j of digit_j * w(j), but the weights are different:",
      "ja": "一般化された可変長い表現は、これら2つの問題を解決します。数字の値はまだ0からbase-1ですが、現在、整数はしきい値t（j）によって自己削除されており、それぞれが範囲0からbase-1にあります。最も重要な1桁の正確な1桁は、digit_j <t（j）を満たしています。したがって、いくつかの整数が連結されている場合、それらを分離するのは簡単です。最初の整数は、小さなエンディアンの場合（最初は最も有意な数字ではない）、またはビッグエンディアンの場合は最後から始まります（最初は最も有意な数字）。前と同様に、値はdigit_j * w（j）のjの合計ですが、重みは異なります。"
    },
    {
      "indent": 6,
      "text": "w(0) = 1\nw(j) = w(j-1) * (base - t(j-1)) for j > 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "For example, consider the little-endian sequence of base 8 digits 734251... Suppose the thresholds are 2, 3, 5, 5, 5, 5... This implies that the weights are 1, 1*(8-2) = 6, 6*(8-3) = 30, 30*(8-5) = 90, 90*(8-5) = 270, and so on. 7 is not less than 2, and 3 is not less than 3, but 4 is less than 5, so 4 is the last digit. The value of 734 is 7*1 + 3*6 + 4*30 = 145. The next integer is 251, with value 2*1 + 5*6 + 1*30 = 62. Decoding this representation is very similar to decoding a conventional integer: Start with a current value of N = 0 and a weight w = 1. Fetch the next digit d and increase N by d * w. If d is less than the current threshold (t) then stop, otherwise increase w by a factor of (base - t), update t for the next position, and repeat.",
      "ja": "たとえば、ベース8桁の小さなエンディアンシーケンス734251を考えてみましょう...しきい値が2、3、5、5、5、5であると仮定します...これは、重みが1、1*（8-2）であることを意味します= 6、6*（8-3）= 30、30*（8-5）= 90、90*（8-5）= 270など。7は2歳以上で、3は3歳以上ですが、4は5未満であるため、4は最後の数字です。734の値は7*1 3*6 4*30 = 145です。次の整数は251で、値2*1 5*6 1*30 = 62です。この表現のデコードは、従来の整数のデコードに非常に似ています。n = 0とa重量w = 1の電流値があります。次の桁dを取得し、d * wでnを増やします。Dが現在のしきい値（t）よりも少ない場合、停止し、それ以外の場合はwを（base -t）係数で増やし、次の位置にtを更新し、繰り返します。"
    },
    {
      "indent": 3,
      "text": "Encoding this representation is similar to encoding a conventional integer: If N < t then output one digit for N and stop, otherwise output the digit for t + ((N - t) mod (base - t)), then replace N with (N - t) div (base - t), update t for the next position, and repeat.",
      "ja": "この表現をエンコードすることは、従来の整数のエンコードに似ています。n<tの場合、nに1桁を出力して停止し、それ以外の場合はt（（n -t）mod（base -t））の数字を出力し、nを（nを置き換えます。-t）div（base -t）、次の位置にtを更新し、繰り返します。"
    },
    {
      "indent": 3,
      "text": "For any particular set of values of t(j), there is exactly one generalized variable-length representation of each nonnegative integral value.",
      "ja": "t（j）の特定の値のセットについて、各非陰性積分値の一般化された変数長い表現が正確に1つあります。"
    },
    {
      "indent": 3,
      "text": "Bootstring uses little-endian ordering so that the deltas can be separated starting with the first. The t(j) values are defined in terms of the constants base, tmin, and tmax, and a state variable called bias:",
      "ja": "Bootstringは小さなエンディアン注文を使用して、Deltasを最初から分離できるようにします。T（j）値は、定数ベース、TMIN、およびTMAX、およびバイアスと呼ばれる状態変数に関して定義されます。"
    },
    {
      "indent": 6,
      "text": "t(j) = base * (j + 1) - bias,\nclamped to the range tmin through tmax",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The clamping means that if the formula yields a value less than tmin or greater than tmax, then t(j) = tmin or tmax, respectively. (In the pseudocode in section 6 \"Bootstring algorithms\", the expression base * (j + 1) is denoted by k for performance reasons.) These t(j) values cause the representation to favor integers within a particular range determined by the bias.",
      "ja": "クランプは、式がTMINよりも少ない値またはTMAXより大きい値を生成する場合、それぞれt（j）= TMINまたはTMAXを生成することを意味します。（セクション6「ブートストリングアルゴリズム」の擬似コードでは、式ベース *（j 1）はパフォーマンス上の理由でKで示されます。）これらのt（j）値により、表現はバイアスによって決定される特定の範囲内の整数を支持します。"
    },
    {
      "indent": 0,
      "text": "3.4 Bias adaptation",
      "section_title": true,
      "ja": "3.4 バイアス適応"
    },
    {
      "indent": 3,
      "text": "After each delta is encoded or decoded, bias is set for the next delta as follows:",
      "ja": "各デルタがエンコードまたはデコードされた後、次のように次のデルタにバイアスが設定されます。"
    },
    {
      "indent": 3,
      "text": "1. Delta is scaled in order to avoid overflow in the next step:",
      "ja": "1. デルタは、次のステップでオーバーフローを避けるために拡大されています。"
    },
    {
      "indent": 9,
      "text": "let delta = delta div 2",
      "ja": "Delta = Delta Div 2とします"
    },
    {
      "indent": 6,
      "text": "But when this is the very first delta, the divisor is not 2, but instead a constant called damp. This compensates for the fact that the second delta is usually much smaller than the first.",
      "ja": "しかし、これが最初のデルタである場合、除数は2ではなく、湿気と呼ばれる定数です。これは、通常、2番目のデルタが最初のデルタよりもはるかに小さいという事実を補います。"
    },
    {
      "indent": 3,
      "text": "2. Delta is increased to compensate for the fact that the next delta will be inserting into a longer string:",
      "ja": "2. デルタは、次のデルタがより長い文字列に挿入するという事実を補うために増加します。"
    },
    {
      "indent": 9,
      "text": "let delta = delta + (delta div numpoints)",
      "ja": "let delta = delta（delta div numpoints）"
    },
    {
      "indent": 6,
      "text": "numpoints is the total number of code points encoded/decoded so far (including the one corresponding to this delta itself, and including the basic code points).",
      "ja": "Numpointsは、これまでにエンコード/デコードされたコードポイントの総数（このデルタ自体に対応するものを含む、および基本的なコードポイントを含む）です。"
    },
    {
      "indent": 3,
      "text": "3. Delta is repeatedly divided until it falls within a threshold, to predict the minimum number of digits needed to represent the next delta:",
      "ja": "3. デルタは、次のデルタを表すために必要な最小数字の数を予測するために、しきい値に該当するまで繰り返し分割されます。"
    },
    {
      "indent": 9,
      "text": "while delta > ((base - tmin) * tmax) div 2\ndo let delta = delta div (base - tmin)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "4. The bias is set:",
      "ja": "4. バイアスが設定されています："
    },
    {
      "indent": 9,
      "text": "let bias =\n  (base * the number of divisions performed in step 3) +\n  (((base - tmin + 1) * delta) div (delta + skew))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "The motivation for this procedure is that the current delta provides a hint about the likely size of the next delta, and so t(j) is set to tmax for the more significant digits starting with the one expected to be last, tmin for the less significant digits up through the one expected to be third-last, and somewhere between tmin and tmax for the digit expected to be second-last",
      "ja": "この手順の動機は、現在のデルタが次のデルタの可能性のあるサイズに関するヒントを提供することです。したがって、t（j）は、最後になると予想されるものから始まるより重要な数字でtmaxに設定されます。3番目の最後になると予想されるものを介して大幅に数字を上げ、TMINとTMAXの間のどこかで2番目に続くと予想される桁"
    },
    {
      "indent": 6,
      "text": "(balancing the hope of the expected-last digit being unnecessary against the danger of it being insufficient).",
      "ja": "（予想される最後の数字が不十分であるという危険に対して不要であるという希望のバランスをとる）。"
    },
    {
      "indent": 0,
      "text": "4. Bootstring parameters",
      "section_title": true,
      "ja": "4. ブートストリングパラメーター"
    },
    {
      "indent": 3,
      "text": "Given a set of basic code points, one needs to be designated as the delimiter. The base cannot be greater than the number of distinguishable basic code points remaining. The digit-values in the range 0 through base-1 need to be associated with distinct non-delimiter basic code points. In some cases multiple code points need to have the same digit-value; for example, uppercase and lowercase versions of the same letter need to be equivalent if basic strings are case-insensitive.",
      "ja": "一連の基本的なコードポイントを考えると、デリミッターとして指定する必要があります。ベースは、残っている識別可能な基本コードポイントの数より大きくすることはできません。範囲0からbase-1の数字値は、異なる非削除型基本コードポイントに関連付ける必要があります。場合によっては、複数のコードポイントが同じ数字値を持つ必要があります。たとえば、基本文字列がケースに依存しない場合、同じ文字の大文字と小文字のバージョンが同等である必要があります。"
    },
    {
      "indent": 3,
      "text": "The initial value of n cannot be greater than the minimum non-basic code point that could appear in extended strings.",
      "ja": "nの初期値は、拡張文字列に表示される可能性のある最小の非基準コードポイントよりも大きくすることはできません。"
    },
    {
      "indent": 3,
      "text": "The remaining five parameters (tmin, tmax, skew, damp, and the initial value of bias) need to satisfy the following constraints:",
      "ja": "残りの5つのパラメーター（TMIN、TMAX、スキュー、湿気、およびバイアスの初期値）は、次の制約を満たす必要があります。"
    },
    {
      "indent": 6,
      "text": "0 <= tmin <= tmax <= base-1\nskew >= 1\ndamp >= 2\ninitial_bias mod base <= base - tmin",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Provided the constraints are satisfied, these five parameters affect efficiency but not correctness. They are best chosen empirically.",
      "ja": "制約が満たされている場合、これらの5つのパラメーターは効率に影響しますが、正しさには影響しません。それらは経験的に最もよく選ばれています。"
    },
    {
      "indent": 3,
      "text": "If support for mixed-case annotation is desired (see appendix A), make sure that the code points corresponding to 0 through tmax-1 all have both uppercase and lowercase forms.",
      "ja": "混合ケースの注釈のサポートが必要な場合（付録Aを参照）、0からTMAX-1に対応するコードポイントにすべて大文字と小文字の両方のフォームがあることを確認してください。"
    },
    {
      "indent": 0,
      "text": "5. Parameter values for Punycode",
      "section_title": true,
      "ja": "5. Punycodeのパラメーター値"
    },
    {
      "indent": 3,
      "text": "Punycode uses the following Bootstring parameter values:",
      "ja": "Punycodeは、次のブートストリングパラメーター値を使用します。"
    },
    {
      "indent": 6,
      "text": "base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80",
      "ja": "base = 36 tmin = 1 tmax = 26 skew = 38 damp = 700 initial_bias = 72 initial_n = 128 = 0x80"
    },
    {
      "indent": 3,
      "text": "Although the only restriction Punycode imposes on the input integers is that they be nonnegative, these parameters are especially designed to work well with Unicode [UNICODE] code points, which are integers in the range 0..10FFFF (but not D800..DFFF, which are reserved for",
      "ja": "入力整数に唯一の制限が課すのは、それらが非陰性であることですが、これらのパラメーターは特に、0..10FFFの範囲の整数であるUnicode [Unicode]コードポイントでうまく機能するように設計されています（ただし、D800..DFFFではありません、予約されています"
    },
    {
      "indent": 3,
      "text": "use by the UTF-16 encoding of Unicode). The basic code points are the ASCII [ASCII] code points (0..7F), of which U+002D (-) is the delimiter, and some of the others have digit-values as follows:",
      "ja": "UnicodeのUTF-16エンコーディングによる使用）。基本的なコードポイントは、ASCII [ASCII]コードポイント（0..7F）です。u 002d（ - ）は区切り文字であり、他の一部には次のように数字の値があります。"
    },
    {
      "indent": 6,
      "text": "code points    digit-values\n------------   ----------------------\n41..5A (A-Z) =  0 to 25, respectively\n61..7A (a-z) =  0 to 25, respectively\n30..39 (0-9) = 26 to 35, respectively",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Using hyphen-minus as the delimiter implies that the encoded string can end with a hyphen-minus only if the Unicode string consists entirely of basic code points, but IDNA forbids such strings from being encoded. The encoded string can begin with a hyphen-minus, but IDNA prepends a prefix. Therefore IDNA using Punycode conforms to the RFC 952 rule that host name labels neither begin nor end with a hyphen-minus [RFC952].",
      "ja": "ハイフン - マイナスを区切り文字として使用すると、ユニコード文字列が完全に基本的なコードポイントで構成されている場合にのみ、エンコードされた文字列がハイフン - マイナスで終わることを意味しますが、IDNAはそのような文字列がエンコードされるのを禁止します。エンコードされた文字列はハイフン - マイナスで始まることができますが、IDNAはプレフィックスを準備します。したがって、Punycodeを使用したIDNAは、ホスト名がハイフン - マイナスで始まることも終了しないRFC 952ルールに準拠しています[RFC952]。"
    },
    {
      "indent": 3,
      "text": "A decoder MUST recognize the letters in both uppercase and lowercase forms (including mixtures of both forms). An encoder SHOULD output only uppercase forms or only lowercase forms, unless it uses mixed-case annotation (see appendix A).",
      "ja": "デコーダーは、大文字と小文字の両方の文字（両方のフォームの混合物を含む）の文字を認識する必要があります。エンコーダーは、混合ケースの注釈を使用しない限り、大文字または小文字のみのみを出力する必要があります（付録Aを参照）。"
    },
    {
      "indent": 3,
      "text": "Presumably most users will not manually write or type encoded strings (as opposed to cutting and pasting them), but those who do will need to be alert to the potential visual ambiguity between the following sets of characters:",
      "ja": "おそらく、ほとんどのユーザーは、エンコードされた文字列を手動で書き込み、タイプしません（それらを切断して貼り付けるのではなく）が、次の文字のセット間の潜在的な視覚的曖昧さに注意する必要があります。"
    },
    {
      "indent": 6,
      "text": "G 6 I l 1 O 0 S 5 U V Z 2",
      "ja": "G 6 I L 1 O 0 S 5 U V Z 2"
    },
    {
      "indent": 3,
      "text": "Such ambiguities are usually resolved by context, but in a Punycode encoded string there is no context apparent to humans.",
      "ja": "このようなあいまいさは通常、コンテキストによって解決されますが、プニュコードエンコードされた文字列には、人間に明らかなコンテキストはありません。"
    },
    {
      "indent": 0,
      "text": "6. Bootstring algorithms",
      "section_title": true,
      "ja": "6. ブートストリングアルゴリズム"
    },
    {
      "indent": 3,
      "text": "Some parts of the pseudocode can be omitted if the parameters satisfy certain conditions (for which Punycode qualifies). These parts are enclosed in {braces}, and notes immediately following the pseudocode explain the conditions under which they can be omitted.",
      "ja": "パラメーターが特定の条件を満たしている場合（Punycodeの資格がある）、Pseudocodeの一部を省略できます。これらの部分は{ブレース}に囲まれており、擬似コードの直後のメモは、それらが省略できる条件を説明します。"
    },
    {
      "indent": 3,
      "text": "Formally, code points are integers, and hence the pseudocode assumes that arithmetic operations can be performed directly on code points. In some programming languages, explicit conversion between code points and integers might be necessary.",
      "ja": "正式には、コードポイントは整数であるため、擬似コードは算術操作をコードポイントで直接実行できると想定しています。一部のプログラミング言語では、コードポイントと整数間の明示的な変換が必要になる場合があります。"
    },
    {
      "indent": 0,
      "text": "6.1 Bias adaptation function",
      "section_title": true,
      "ja": "6.1 バイアス適応関数"
    },
    {
      "indent": 3,
      "text": "function adapt(delta,numpoints,firsttime):\n  if firsttime then let delta = delta div damp\n  else let delta = delta div 2\n  let delta = delta + (delta div numpoints)\n  let k = 0\n  while delta > ((base - tmin) * tmax) div 2 do begin\n    let delta = delta div (base - tmin)\n    let k = k + base\n  end\n  return k + (((base - tmin + 1) * delta) div (delta + skew))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It does not matter whether the modifications to delta and k inside adapt() affect variables of the same name inside the encoding/decoding procedures, because after calling adapt() the caller does not read those variables before overwriting them.",
      "ja": "Adapt（）内部のDeltaとKの変更がエンコード/デコード手順内の同じ名前の変数に影響するかどうかは関係ありません。Adapt（）を呼び出した後、発信者はそれらを上書きする前にそれらの変数を読み取らないためです。"
    },
    {
      "indent": 0,
      "text": "6.2 Decoding procedure",
      "section_title": true,
      "ja": "6.2 デコード手順"
    },
    {
      "indent": 3,
      "text": "let n = initial_n\nlet i = 0\nlet bias = initial_bias\nlet output = an empty string indexed from 0\nconsume all code points before the last delimiter (if there is one)\n  and copy them to output, fail on any non-basic code point\nif more than zero code points were consumed then consume one more\n  (which will be the last delimiter)\nwhile the input is not exhausted do begin\n  let oldi = i\n  let w = 1\n  for k = base to infinity in steps of base do begin\n    consume a code point, or fail if there was none to consume\n    let digit = the code point's digit-value, fail if it has none\n    let i = i + digit * w, fail on overflow\n    let t = tmin if k <= bias {+ tmin}, or\n            tmax if k >= bias + tmax, or k - bias otherwise\n    if digit < t then break\n    let w = w * (base - t), fail on overflow\n  end\n  let bias = adapt(i - oldi, length(output) + 1, test oldi is 0?)\n  let n = n + i div (length(output) + 1), fail on overflow\n  let i = i mod (length(output) + 1)\n  {if n is a basic code point then fail}\n  insert n into output at position i\n  increment i\nend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The full statement enclosed in braces (checking whether n is a basic code point) can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because n is never less than initial_n.",
      "ja": "nがinitial_n以下ではないため、initial_nがすべての基本コードポイント（これはpunycodeに当てはまる）を超える場合、ブレースに囲まれた完全なステートメント（nが基本コードポイントであるかどうかを確認）は省略できます。"
    },
    {
      "indent": 3,
      "text": "In the assignment of t, where t is clamped to the range tmin through tmax, \"+ tmin\" can always be omitted. This makes the clamping calculation incorrect when bias < k < bias + tmin, but that cannot happen because of the way bias is computed and because of the constraints on the parameters.",
      "ja": "tの割り当てでは、tがtmaxを介して範囲tminにクランプされ、「tmin」はいつでも省略できます。これにより、バイアス<k <バイアスTMINの場合、クランプ計算が正しくなりますが、バイアスの計算方法とパラメーターの制約のために発生することはできません。"
    },
    {
      "indent": 3,
      "text": "Because the decoder state can only advance monotonically, and there is only one representation of any delta, there is therefore only one encoded string that can represent a given sequence of integers. The only error conditions are invalid code points, unexpected end-of-input, overflow, and basic code points encoded using deltas instead of appearing literally. If the decoder fails on these errors as shown above, then it cannot produce the same output for two distinct inputs. Without this property it would have been necessary to re-",
      "ja": "デコーダー状態は単調にしか前進しないため、デルタの表現は1つしかないため、整数の特定のシーケンスを表すことができるエンコードされた文字列は1つだけです。唯一のエラー条件は、無効なコードポイント、予期しない入力終了、オーバーフロー、および文字通りに表示される代わりにDeltasを使用してエンコードされた基本的なコードポイントです。上記のようにこれらのエラーでデコーダーが故障した場合、2つの異なる入力に対して同じ出力を生成することはできません。このプロパティがなければ、それは"
    },
    {
      "indent": 3,
      "text": "encode the output and verify that it matches the input in order to guarantee the uniqueness of the encoding.",
      "ja": "出力をエンコードし、エンコードの一意性を保証するために入力と一致することを確認します。"
    },
    {
      "indent": 0,
      "text": "6.3 Encoding procedure",
      "section_title": true,
      "ja": "6.3 エンコード手順"
    },
    {
      "indent": 3,
      "text": "let n = initial_n\nlet delta = 0\nlet bias = initial_bias\nlet h = b = the number of basic code points in the input\ncopy them to the output in order, followed by a delimiter if b > 0\n{if the input contains a non-basic code point < n then fail}\nwhile h < length(input) do begin\n  let m = the minimum {non-basic} code point >= n in the input\n  let delta = delta + (m - n) * (h + 1), fail on overflow\n  let n = m\n  for each code point c in the input (in order) do begin\n    if c < n {or c is basic} then increment delta, fail on overflow\n    if c == n then begin\n      let q = delta\n      for k = base to infinity in steps of base do begin\n        let t = tmin if k <= bias {+ tmin}, or\n                tmax if k >= bias + tmax, or k - bias otherwise\n        if q < t then break\n        output the code point for digit t + ((q - t) mod (base - t))\n        let q = (q - t) div (base - t)\n      end\n      output the code point for digit q\n      let bias = adapt(delta, h + 1, test h equals b?)\n      let delta = 0\n      increment h\n    end\n  end\n  increment delta and n\nend",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The full statement enclosed in braces (checking whether the input contains a non-basic code point less than n) can be omitted if all code points less than initial_n are basic code points (which is true for Punycode if code points are unsigned).",
      "ja": "ブレースに囲まれた完全なステートメント（入力にn未満の基本コードポイントが含まれているかどうかを確認する）は、すべてのコードポイントがinitial_nより少ない場合、基本コードポイント（コードポイントが符号なしである場合はプニコードに当てはまる）である場合は省略できます。"
    },
    {
      "indent": 3,
      "text": "The brace-enclosed conditions \"non-basic\" and \"or c is basic\" can be omitted if initial_n exceeds all basic code points (which is true for Punycode), because the code point being tested is never less than initial_n.",
      "ja": "テストされているコードポイントがInitial_nを超えることはないため、initial_nがすべての基本コードポイント（Punycodeに当てはまる）を超える場合、「非基準」および「またはcは基本」を省略できます。"
    },
    {
      "indent": 3,
      "text": "In the assignment of t, where t is clamped to the range tmin through tmax, \"+ tmin\" can always be omitted. This makes the clamping calculation incorrect when bias < k < bias + tmin, but that cannot",
      "ja": "tの割り当てでは、tがtmaxを介して範囲tminにクランプされ、「tmin」はいつでも省略できます。これにより、バイアス<k <バイアスtminの場合、クランプ計算が正しくなりますが、それはできません"
    },
    {
      "indent": 3,
      "text": "happen because of the way bias is computed and because of the constraints on the parameters.",
      "ja": "バイアスの計算方法とパラメーターの制約のために発生します。"
    },
    {
      "indent": 3,
      "text": "The checks for overflow are necessary to avoid producing invalid output when the input contains very large values or is very long.",
      "ja": "オーバーフローのチェックは、入力に非常に大きな値が含まれているか、非常に長い場合に無効な出力の生成を避けるために必要です。"
    },
    {
      "indent": 3,
      "text": "The increment of delta at the bottom of the outer loop cannot overflow because delta < length(input) before the increment, and length(input) is already assumed to be representable. The increment of n could overflow, but only if h == length(input), in which case the procedure is finished anyway.",
      "ja": "外側ループの下部にあるデルタの増分は、増分前のデルタ<長さ（入力）、および長さ（入力）がすでに表現可能であると想定されているため、オーバーフローできません。nの増分はオーバーフローする可能性がありますが、h ==長さ（入力）の場合にのみ、その場合は手順が完了します。"
    },
    {
      "indent": 0,
      "text": "6.4 Overflow handling",
      "section_title": true,
      "ja": "6.4 オーバーフロー処理"
    },
    {
      "indent": 3,
      "text": "For IDNA, 26-bit unsigned integers are sufficient to handle all valid IDNA labels without overflow, because any string that needed a 27-bit delta would have to exceed either the code point limit (0..10FFFF) or the label length limit (63 characters). However, overflow handling is necessary because the inputs are not necessarily valid IDNA labels.",
      "ja": "IDNAの場合、26ビットのデルタを必要とする文字列がコードポイント制限（0..10ffff）またはラベルの長さの制限（ラベル長）を超える必要があるため、26ビットの符号なしの整数はオーバーフローなしですべての有効なIDNAラベルを処理するのに十分です。63文字）。ただし、入力は必ずしも有効なIDNAラベルではないため、オーバーフロー処理が必要です。"
    },
    {
      "indent": 3,
      "text": "If the programming language does not provide overflow detection, the following technique can be used. Suppose A, B, and C are representable nonnegative integers and C is nonzero. Then A + B overflows if and only if B > maxint - A, and A + (B * C) overflows if and only if B > (maxint - A) div C, where maxint is the greatest integer for which maxint + 1 cannot be represented. Refer to appendix C \"Punycode sample implementation\" for demonstrations of this technique in the C language.",
      "ja": "プログラミング言語がオーバーフロー検出を提供しない場合、次の手法を使用できます。A、B、およびCが表現可能な非陰性整数であり、Cが非ゼロであると仮定します。b> maxint -a、およびa（b * c）がb>（maxint -a）div cの場合にのみ、b> maxint -aとa（b * c）がオーバーフローする場合にのみ、bオーバーフローします。C言語でのこの手法のデモンストレーションについては、付録C「Punycodeサンプルの実装」を参照してください。"
    },
    {
      "indent": 3,
      "text": "The decoding and encoding algorithms shown in sections 6.2 and 6.3 handle overflow by detecting it whenever it happens. Another approach is to enforce limits on the inputs that prevent overflow from happening. For example, if the encoder were to verify that no input code points exceed M and that the input length does not exceed L, then no delta could ever exceed (M - initial_n) * (L + 1), and hence no overflow could occur if integer variables were capable of representing values that large. This prevention approach would impose more restrictions on the input than the detection approach does, but might be considered simpler in some programming languages.",
      "ja": "セクション6.2および6.3に示されているデコードおよびエンコードアルゴリズムは、発生するたびに検出してオーバーフローを処理します。別のアプローチは、オーバーフローが発生しないようにする入力の制限を強制することです。たとえば、エンコーダが入力コードポイントがmを超えていないこと、入力長がLを超えないことを確認した場合、デルタは（m -initial_n） *（l 1）を超えることができないため、オーバーフローが発生しない場合、整数変数は、その大きな値を表すことができました。この予防アプローチは、検出アプローチよりも入力により多くの制限を課しますが、一部のプログラミング言語ではより単純であると見なされる場合があります。"
    },
    {
      "indent": 3,
      "text": "In theory, the decoder could use an analogous approach, limiting the number of digits in a variable-length integer (that is, limiting the number of iterations in the innermost loop). However, the number of digits that suffice to represent a given delta can sometimes represent much larger deltas (because of the adaptation), and hence this approach would probably need integers wider than 32 bits.",
      "ja": "理論的には、デコーダーは類似のアプローチを使用して、可変長整数の数字数を制限できます（つまり、最も内側のループの反復回数を制限します）。ただし、特定のデルタを表すのに十分な数字の数は、（適応のため）はるかに大きなデルタを表すことがあります。したがって、このアプローチはおそらく32ビットよりも広い整数が必要です。"
    },
    {
      "indent": 3,
      "text": "Yet another approach for the decoder is to allow overflow to occur, but to check the final output string by re-encoding it and comparing to the decoder input. If and only if they do not match (using a case-insensitive ASCII comparison) overflow has occurred. This delayed-detection approach would not impose any more restrictions on the input than the immediate-detection approach does, and might be considered simpler in some programming languages.",
      "ja": "デコーダーのもう1つのアプローチは、オーバーフローが発生することを許可することですが、最終出力文字列を再エンコードしてデコーダー入力と比較することにより、最終出力文字列を確認することです。それらが一致しない場合にのみ（ケース非感受性ASCII比較を使用して）オーバーフローが発生しました。この遅延検出アプローチは、即時の検出アプローチよりも入力に多くの制限を課すことはなく、一部のプログラミング言語ではより単純であると見なされる可能性があります。"
    },
    {
      "indent": 3,
      "text": "In fact, if the decoder is used only inside the IDNA ToUnicode operation [IDNA], then it need not check for overflow at all, because ToUnicode performs a higher level re-encoding and comparison, and a mismatch has the same consequence as if the Punycode decoder had failed.",
      "ja": "実際、デコーダーがiDNA tounicode操作[idna]内でのみ使用されている場合、tounicodeはより高いレベルの再エンコードと比較を実行し、不一致が同じ結果をもたらすため、オーバーフローをまったくチェックする必要はありません。Punycode Decoderが失敗しました。"
    },
    {
      "indent": 0,
      "text": "7. Punycode examples",
      "section_title": true,
      "ja": "7. パニコードの例"
    },
    {
      "indent": 0,
      "text": "7.1 Sample strings",
      "section_title": true,
      "ja": "7.1 サンプル文字列"
    },
    {
      "indent": 3,
      "text": "In the Punycode encodings below, the ACE prefix is not shown. Backslashes show where line breaks have been inserted in strings too long for one line.",
      "ja": "以下のプニュコードエンコーディングでは、ACEプレフィックスは表示されません。バックスラッシュは、1つのラインに対して長い文字列にラインブレークが挿入された場所を示しています。"
    },
    {
      "indent": 3,
      "text": "The first several examples are all translations of the sentence \"Why can't they just speak in <language>?\" (courtesy of Michael Kaplan's \"provincial\" page [PROVINCIAL]). Word breaks and punctuation have been removed, as is often done in domain names.",
      "ja": "最初のいくつかの例は、すべて「なぜ彼らは<言語>で話すことができないのか」という文の翻訳です。（Michael Kaplanの「Provincial」ページ[Provincial]の厚意により）。ドメイン名でしばしば行われるように、単語の破損と句読点が削除されました。"
    },
    {
      "indent": 3,
      "text": "(A) Arabic (Egyptian):\n    u+0644 u+064A u+0647 u+0645 u+0627 u+0628 u+062A u+0643 u+0644\n    u+0645 u+0648 u+0634 u+0639 u+0631 u+0628 u+064A u+061F\n    Punycode: egbpdaj6bu4bxfgehfvwxn",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(B) Chinese (simplified):\n    u+4ED6 u+4EEC u+4E3A u+4EC0 u+4E48 u+4E0D u+8BF4 u+4E2D u+6587\n    Punycode: ihqwcrb4cv8a8dqg056pqjye",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(C) Chinese (traditional):\n    u+4ED6 u+5011 u+7232 u+4EC0 u+9EBD u+4E0D u+8AAA u+4E2D u+6587\n    Punycode: ihqwctvzc91f659drss3x8bo0yb",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(D) Czech: Pro<ccaron>prost<ecaron>nemluv<iacute><ccaron>esky\n    U+0050 u+0072 u+006F u+010D u+0070 u+0072 u+006F u+0073 u+0074\n    u+011B u+006E u+0065 u+006D u+006C u+0075 u+0076 u+00ED u+010D\n    u+0065 u+0073 u+006B u+0079\n    Punycode: Proprostnemluvesky-uyb24dma41a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(E) Hebrew:\n    u+05DC u+05DE u+05D4 u+05D4 u+05DD u+05E4 u+05E9 u+05D5 u+05D8\n    u+05DC u+05D0 u+05DE u+05D3 u+05D1 u+05E8 u+05D9 u+05DD u+05E2\n    u+05D1 u+05E8 u+05D9 u+05EA\n    Punycode: 4dbcagdahymbxekheh6e0a7fei0b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(F) Hindi (Devanagari):\n    u+092F u+0939 u+0932 u+094B u+0917 u+0939 u+093F u+0928 u+094D\n    u+0926 u+0940 u+0915 u+094D u+092F u+094B u+0902 u+0928 u+0939\n    u+0940 u+0902 u+092C u+094B u+0932 u+0938 u+0915 u+0924 u+0947\n    u+0939 u+0948 u+0902\n    Punycode: i1baa7eci9glrd9b2ae1bj0hfcgg6iyaf8o0a1dig0cd",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(G) Japanese (kanji and hiragana):\n    u+306A u+305C u+307F u+3093 u+306A u+65E5 u+672C u+8A9E u+3092\n    u+8A71 u+3057 u+3066 u+304F u+308C u+306A u+3044 u+306E u+304B\n    Punycode: n8jok5ay5dzabd5bym9f0cm5685rrjetr6pdxa",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(H) Korean (Hangul syllables):\n    u+C138 u+ACC4 u+C758 u+BAA8 u+B4E0 u+C0AC u+B78C u+B4E4 u+C774\n    u+D55C u+AD6D u+C5B4 u+B97C u+C774 u+D574 u+D55C u+B2E4 u+BA74\n    u+C5BC u+B9C8 u+B098 u+C88B u+C744 u+AE4C\n    Punycode: 989aomsvi5e83db1d2a355cv1e0vak1dwrv93d5xbh15a0dt30a5j\\\n              psd879ccm6fea98c",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(I) Russian (Cyrillic):\n    U+043F u+043E u+0447 u+0435 u+043C u+0443 u+0436 u+0435 u+043E\n    u+043D u+0438 u+043D u+0435 u+0433 u+043E u+0432 u+043E u+0440\n    u+044F u+0442 u+043F u+043E u+0440 u+0443 u+0441 u+0441 u+043A\n    u+0438\n    Punycode: b1abfaaepdrnnbgefbaDotcwatmq2g4l",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(J) Spanish: Porqu<eacute>nopuedensimplementehablarenEspa<ntilde>ol\n    U+0050 u+006F u+0072 u+0071 u+0075 u+00E9 u+006E u+006F u+0070\n    u+0075 u+0065 u+0064 u+0065 u+006E u+0073 u+0069 u+006D u+0070\n    u+006C u+0065 u+006D u+0065 u+006E u+0074 u+0065 u+0068 u+0061\n    u+0062 u+006C u+0061 u+0072 u+0065 u+006E U+0045 u+0073 u+0070\n    u+0061 u+00F1 u+006F u+006C\n    Punycode: PorqunopuedensimplementehablarenEspaol-fmd56a",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(K) Vietnamese:\n    T<adotbelow>isaoh<odotbelow>kh<ocirc>ngth<ecirchookabove>ch\\\n    <ihookabove>n<oacute>iti<ecircacute>ngVi<ecircdotbelow>t\n    U+0054 u+1EA1 u+0069 u+0073 u+0061 u+006F u+0068 u+1ECD u+006B\n    u+0068 u+00F4 u+006E u+0067 u+0074 u+0068 u+1EC3 u+0063 u+0068\n    u+1EC9 u+006E u+00F3 u+0069 u+0074 u+0069 u+1EBF u+006E u+0067\n    U+0056 u+0069 u+1EC7 u+0074\n    Punycode: TisaohkhngthchnitingVit-kjcr8268qyxafd2f1b9g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The next several examples are all names of Japanese music artists, song titles, and TV programs, just because the author happens to have them handy (but Japanese is useful for providing examples of single-row text, two-row text, ideographic text, and various mixtures thereof).",
      "ja": "次のいくつかの例はすべて、著者がそれらを便利にしているからといって、日本の音楽アーティスト、歌のタイトル、テレビ番組のすべての名前です（ただし、日本語は単一列テキスト、2列テキスト、表意文字テキスト、およびそのさまざまな混合物）。"
    },
    {
      "indent": 3,
      "text": "(L) 3<nen>B<gumi><kinpachi><sensei>\n    u+0033 u+5E74 U+0042 u+7D44 u+91D1 u+516B u+5148 u+751F\n    Punycode: 3B-ww4c5e180e575a65lsy2b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(M) <amuro><namie>-with-SUPER-MONKEYS\n    u+5B89 u+5BA4 u+5948 u+7F8E u+6075 u+002D u+0077 u+0069 u+0074\n    u+0068 u+002D U+0053 U+0055 U+0050 U+0045 U+0052 u+002D U+004D\n    U+004F U+004E U+004B U+0045 U+0059 U+0053\n    Punycode: -with-SUPER-MONKEYS-pc58ag80a8qai00g7n9n",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(N) Hello-Another-Way-<sorezore><no><basho>\n    U+0048 u+0065 u+006C u+006C u+006F u+002D U+0041 u+006E u+006F\n    u+0074 u+0068 u+0065 u+0072 u+002D U+0057 u+0061 u+0079 u+002D\n    u+305D u+308C u+305E u+308C u+306E u+5834 u+6240\n    Punycode: Hello-Another-Way--fc4qua05auwb3674vfr0b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(O) <hitotsu><yane><no><shita>2\n    u+3072 u+3068 u+3064 u+5C4B u+6839 u+306E u+4E0B u+0032\n    Punycode: 2-u9tlzr9756bt3uc0v",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(P) Maji<de>Koi<suru>5<byou><mae>\n    U+004D u+0061 u+006A u+0069 u+3067 U+004B u+006F u+0069 u+3059\n    u+308B u+0035 u+79D2 u+524D\n    Punycode: MajiKoi5-783gue6qz075azm5e",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(Q) <pafii>de<runba>\n    u+30D1 u+30D5 u+30A3 u+30FC u+0064 u+0065 u+30EB u+30F3 u+30D0\n    Punycode: de-jg4avhby1noc0d",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(R) <sono><supiido><de>\n    u+305D u+306E u+30B9 u+30D4 u+30FC u+30C9 u+3067\n    Punycode: d9juau41awczczp",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The last example is an ASCII string that breaks the existing rules for host name labels. (It is not a realistic example for IDNA, because IDNA never encodes pure ASCII labels.)",
      "ja": "最後の例は、ホスト名ラベルの既存のルールを破るASCII文字列です。（IDNAは純粋なASCIIラベルをエンコードしないため、IDNAの現実的な例ではありません。）"
    },
    {
      "indent": 3,
      "text": "(S) -> $1.00 <-\n    u+002D u+003E u+0020 u+0024 u+0031 u+002E u+0030 u+0030 u+0020\n    u+003C u+002D\n    Punycode: -> $1.00 <--",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.2 Decoding traces",
      "section_title": true,
      "ja": "7.2 デコードトレース"
    },
    {
      "indent": 3,
      "text": "In the following traces, the evolving state of the decoder is shown as a sequence of hexadecimal values, representing the code points in the extended string. An asterisk appears just after the most recently inserted code point, indicating both n (the value preceeding the asterisk) and i (the position of the value just after the asterisk). Other numerical values are decimal.",
      "ja": "次のトレースでは、デコーダーの進化する状態は、拡張された文字列のコードポイントを表す16進数のシーケンスとして表示されます。アスタリスクは、ごく最近挿入されたコードポイントの直後に表示され、N（アスタリスクの前処理値）とI（アスタリスクの直後の値の位置）の両方を示します。他の数値値は小数です。"
    },
    {
      "indent": 3,
      "text": "Decoding trace of example B from section 7.1:",
      "ja": "セクション7.1からの例Bのトレースの解読："
    },
    {
      "indent": 3,
      "text": "n is 128, i is 0, bias is 72\ninput is \"ihqwcrb4cv8a8dqg056pqjye\"\nthere is no delimiter, so extended string starts empty\ndelta \"ihq\" decodes to 19853\nbias becomes 21\n4E0D *\ndelta \"wc\" decodes to 64\nbias becomes 20\n4E0D 4E2D *\ndelta \"rb\" decodes to 37\nbias becomes 13\n4E3A * 4E0D 4E2D\ndelta \"4c\" decodes to 56\nbias becomes 17\n4E3A 4E48 * 4E0D 4E2D\ndelta \"v8a\" decodes to 599\nbias becomes 32\n4E3A 4EC0 * 4E48 4E0D 4E2D\ndelta \"8d\" decodes to 130\nbias becomes 23\n4ED6 * 4E3A 4EC0 4E48 4E0D 4E2D\ndelta \"qg\" decodes to 154\nbias becomes 25\n4ED6 4EEC * 4E3A 4EC0 4E48 4E0D 4E2D\ndelta \"056p\" decodes to 46301\nbias becomes 84\n4ED6 4EEC 4E3A 4EC0 4E48 4E0D 4E2D 6587 *\ndelta \"qjye\" decodes to 88531\nbias becomes 90\n4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 * 4E2D 6587",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Decoding trace of example L from section 7.1:",
      "ja": "セクション7.1からの例Lのトレースの解読："
    },
    {
      "indent": 3,
      "text": "n is 128, i is 0, bias is 72 input is \"3B-ww4c5e180e575a65lsy2b\" literal portion is \"3B-\", so extended string starts as: 0033 0042 delta \"ww4c\" decodes to 62042 bias becomes 27 0033 0042 5148 * delta \"5e\" decodes to 139 bias becomes 24 0033 0042 516B * 5148 delta \"180e\" decodes to 16683 bias becomes 67 0033 5E74 * 0042 516B 5148 delta \"575a\" decodes to 34821 bias becomes 82 0033 5E74 0042 516B 5148 751F * delta \"65l\" decodes to 14592 bias becomes 67 0033 5E74 0042 7D44 * 516B 5148 751F delta \"sy2b\" decodes to 42088 bias becomes 84 0033 5E74 0042 7D44 91D1 * 516B 5148 751F",
      "ja": "nは128、iは0、バイアスは72入力です。入力は「3B-WW4C5E180E575A65LSY2B \"リテラル部分は「3B」です。したがって、拡張文字列は次のように開始されます。5e \"139のバイアスへのデコードは24 0033 0042 516B * 5148 DELTA\" 180E \"DECODE TO 16683になります67 0033 5E74 * 0042 516B 5148 DELTA\" 575A \"TO 34821 BIASになります。14592までのデコードバイアスは67 0033 5E74 0042 7D44 * 516B 5148 751F DELTA \"SY2B\" 42088へのデコードは84 0033 5E74 0042 7D44 91D1 * 516B 5148 751FF"
    },
    {
      "indent": 0,
      "text": "7.3 Encoding traces",
      "section_title": true,
      "ja": "7.3 トレースのエンコード"
    },
    {
      "indent": 3,
      "text": "In the following traces, code point values are hexadecimal, while other numerical values are decimal.",
      "ja": "次のトレースでは、コードポイント値は16進数であり、他の数値値は10進数です。"
    },
    {
      "indent": 3,
      "text": "Encoding trace of example B from section 7.1:",
      "ja": "セクション7.1からの例Bのトレースのエンコード："
    },
    {
      "indent": 3,
      "text": "bias is 72 input is: 4ED6 4EEC 4E3A 4EC0 4E48 4E0D 8BF4 4E2D 6587 there are no basic code points, so no literal portion next code point to insert is 4E0D needed delta is 19853, encodes as \"ihq\" bias becomes 21 next code point to insert is 4E2D needed delta is 64, encodes as \"wc\" bias becomes 20 next code point to insert is 4E3A needed delta is 37, encodes as \"rb\" bias becomes 13 next code point to insert is 4E48 needed delta is 56, encodes as \"4c\" bias becomes 17 next code point to insert is 4EC0 needed delta is 599, encodes as \"v8a\" bias becomes 32 next code point to insert is 4ED6 needed delta is 130, encodes as \"8d\" bias becomes 23 next code point to insert is 4EEC needed delta is 154, encodes as \"qg\" bias becomes 25 next code point to insert is 6587 needed delta is 46301, encodes as \"056p\" bias becomes 84 next code point to insert is 8BF4 needed delta is 88531, encodes as \"qjye\" bias becomes 90 output is \"ihqwcrb4cv8a8dqg056pqjye\"",
      "ja": "バイアスは72入力です。4ED64EEC4EEC 4EEC 4EC0 4E48 4E0D 8BF4 4E2D 6587基本的なコードポイントはありません。INSERT IS 4E2D必要なデルタは64、「WC」バイアスが20になるとエンコードは20次のコードポイントが挿入されます4E3A必要なデルタは37、「RB」バイアスが13になるとエンコードは13次のコードポイントを挿入する必要があります4E48必要なデルタは56、エンコードとしてエンコード「4c」バイアスは17になります挿入するコードポイントは4ec0必要なコードポイントが599である必要があり、「V8a」バイアスが挿入される32次のコードポイントは4ed6必要なデルタです。IS IS 4EECが必要なデルタは154で、「QG」バイアスが25になるようにエンコードは25次のコードポイントを挿入します6587必要なデルタは46301、「056p」バイアスが84次のコードポイントになるため、挿入される必要があります。「Qjye」バイアスは90出力になります「ihqwcrb4cv8a8dqg056pqjye」"
    },
    {
      "indent": 3,
      "text": "Encoding trace of example L from section 7.1:",
      "ja": "セクション7.1からの例Lのトレースをエンコードする："
    },
    {
      "indent": 3,
      "text": "bias is 72 input is: 0033 5E74 0042 7D44 91D1 516B 5148 751F basic code points (0033, 0042) are copied to literal portion: \"3B-\" next code point to insert is 5148 needed delta is 62042, encodes as \"ww4c\" bias becomes 27 next code point to insert is 516B needed delta is 139, encodes as \"5e\" bias becomes 24 next code point to insert is 5E74 needed delta is 16683, encodes as \"180e\" bias becomes 67 next code point to insert is 751F needed delta is 34821, encodes as \"575a\" bias becomes 82 next code point to insert is 7D44 needed delta is 14592, encodes as \"65l\" bias becomes 67 next code point to insert is 91D1 needed delta is 42088, encodes as \"sy2b\" bias becomes 84 output is \"3B-ww4c5e180e575a65lsy2b\"",
      "ja": "バイアスは72入力です：0033 5E74 0042 7D44 91D1 516B 5148 751F基本コードポイント（0033、0042）はリテラル部分にコピーされます： \"3b-\"次のコードポイントは5148必要なデルタです。挿入する27次のコードポイントは516B必要なデルタは139、「5E」バイアスが24になるアックアセンズ24次のコードポイントIS 5E74必要なデルタは16683、エンコード「180E」バイアスは67次のコードポイントが挿入デルタは34821で、「575a」バイアスが82になるとエンコードは82次のコードポイントを挿入します7d44必要なデルタは14592、「65L」バイアスは67次のコードポイントが挿入されます91d1必要なデルタは42088、「sy2b」バイアスとしてエンコードする必要があります84出力になります「3B-WW4C5E180E575A65LSY2B」"
    },
    {
      "indent": 0,
      "text": "8. Security Considerations",
      "section_title": true,
      "ja": "8. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Users expect each domain name in DNS to be controlled by a single authority. If a Unicode string intended for use as a domain label could map to multiple ACE labels, then an internationalized domain name could map to multiple ASCII domain names, each controlled by a different authority, some of which could be spoofs that hijack service requests intended for another. Therefore Punycode is designed so that each Unicode string has a unique encoding.",
      "ja": "ユーザーは、DNSの各ドメイン名が単一の当局によって制御されることを期待しています。ドメインラベルとして使用することを目的としたユニコード文字列が複数のACEラベルにマッピングできる場合、国際化されたドメイン名が複数のASCIIドメイン名にマッピングできます。それぞれが異なる権限によって制御されます。別。したがって、Punycodeは、各Unicode文字列に一意のエンコードがあるように設計されています。"
    },
    {
      "indent": 3,
      "text": "However, there can still be multiple Unicode representations of the \"same\" text, for various definitions of \"same\". This problem is addressed to some extent by the Unicode standard under the topic of canonicalization, and this work is leveraged for domain names by Nameprep [NAMEPREP].",
      "ja": "ただし、「同じ」のさまざまな定義に対して、「同じ」テキストの複数のユニコード表現がまだある場合があります。この問題は、標準化のトピックに基づくユニコード標準によってある程度対処されており、この作業はNamePrep [NamePrep]によってドメイン名に活用されています。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1 Normative References",
      "section_title": true,
      "ja": "9.1 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "9.2 Informative References",
      "section_title": true,
      "ja": "9.2 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC952] Harrenstien, K., Stahl, M. and E. Feinler, \"DOD Internet Host Table Specification\", RFC 952, October 1985.",
      "ja": "[RFC952] Harrenstien、K.、Stahl、M。、およびE. Feinler、「Dod Internet Host Table Specification」、RFC 952、1985年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1034] Mockapetris, P., \"Domain Names - Concepts and Facilities\", STD 13, RFC 1034, November 1987.",
      "ja": "[RFC1034] Mockapetris、P。、「ドメイン名 - 概念と施設」、STD 13、RFC 1034、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[IDNA] Faltstrom, P., Hoffman, P. and A. Costello, \"Internationalizing Domain Names in Applications (IDNA)\", RFC 3490, March 2003.",
      "ja": "[IDNA] Faltstrom、P.、Hoffman、P。and A. Costello、「アプリケーションの国際化ドメイン名（IDNA）」、RFC 3490、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[NAMEPREP] Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep Profile for Internationalized Domain Names (IDN)\", RFC 3491, March 2003.",
      "ja": "[Nameprep] Hoffman、P。and M. Blanchet、「NamePrep：国際化ドメイン名のStringPrepプロファイル（IDN）」、RFC 3491、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[ASCII] Cerf, V., \"ASCII format for Network Interchange\", RFC 20, October 1969.",
      "ja": "[ASCII] Cerf、V。、「ネットワークインターチェンジ用ASCII形式」、RFC 20、1969年10月。"
    },
    {
      "indent": 3,
      "text": "[PROVINCIAL] Kaplan, M., \"The 'anyone can be provincial!' page\", http://www.trigeminal.com/samples/provincial.html.",
      "ja": "[州]カプラン、M。、「「誰でも地方！」Page \"、http://www.trigeminal.com/samples/provincial.html。"
    },
    {
      "indent": 3,
      "text": "[UNICODE] The Unicode Consortium, \"The Unicode Standard\", http://www.unicode.org/unicode/standard/standard.html.",
      "ja": "[Unicode] Unicode Consortium、「Unicode Standard」、http://www.unicode.org/unicode/standard/standard.html。"
    },
    {
      "indent": 0,
      "text": "A. Mixed-case annotation",
      "ja": "A.混合ケースアノテーション"
    },
    {
      "indent": 3,
      "text": "In order to use Punycode to represent case-insensitive strings, higher layers need to case-fold the strings prior to Punycode encoding. The encoded string can use mixed case as an annotation telling how to convert the folded string into a mixed-case string for display purposes. Note, however, that mixed-case annotation is not used by the ToASCII and ToUnicode operations specified in [IDNA], and therefore implementors of IDNA can disregard this appendix.",
      "ja": "パニコードを使用して症例感受性の文字列を表すためには、高層がパニコードエンコードの前に文字列をケース折る必要があります。エンコードされた文字列は、折り畳まれた文字列をディスプレイの目的で混合ケースの文字列に変換する方法を示す注釈として混合ケースを使用できます。ただし、[IDNA]で指定されたToasciiおよびTounicode操作では混合ケースの注釈が使用されていないため、IDNAの実装者はこの付録を無視できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Basic code points can use mixed case directly, because the decoder copies them verbatim, leaving lowercase code points lowercase, and leaving uppercase code points uppercase. Each non-basic code point is represented by a delta, which is represented by a sequence of basic code points, the last of which provides the annotation. If it is uppercase, it is a suggestion to map the non-basic code point to uppercase (if possible); if it is lowercase, it is a suggestion to map the non-basic code point to lowercase (if possible).",
      "ja": "デコーダーが逐語的にコピーし、小文字コードポイント小文字を残し、大文字のコードポイント大文字を残すため、基本的なコードポイントは混合ケースを直接使用できます。各非基準コードポイントは、基本コードポイントのシーケンスで表されるデルタで表されます。最後のコードポイントは注釈を提供します。大文字の場合、非基本コードポイントを大文字にマッピングすることは提案です（可能であれば）。小文字の場合、非基本コードポイントを小文字にマッピングすることは提案です（可能であれば）。"
    },
    {
      "indent": 3,
      "text": "These annotations do not alter the code points returned by decoders; the annotations are returned separately, for the caller to use or ignore. Encoders can accept annotations in addition to code points, but the annotations do not alter the output, except to influence the uppercase/lowercase form of ASCII letters.",
      "ja": "これらの注釈は、デコーダによって返されるコードポイントを変更しません。発信者が使用または無視するように、注釈は個別に返されます。エンコーダーはコードポイントに加えて注釈を受け入れることができますが、注釈はASCII文字の大文字/小文字の形式に影響を与えることを除いて出力を変更しません。"
    },
    {
      "indent": 3,
      "text": "Punycode encoders and decoders need not support these annotations, and higher layers need not use them.",
      "ja": "Punycodeエンコーダーとデコーダーはこれらの注釈をサポートする必要はなく、高層はそれらを使用する必要はありません。"
    },
    {
      "indent": 0,
      "text": "B. Disclaimer and license",
      "ja": "B.免責事項とライセンス"
    },
    {
      "indent": 3,
      "text": "Regarding this entire document or any portion of it (including the pseudocode and C code), the author makes no guarantees and is not responsible for any damage resulting from its use. The author grants irrevocable permission to anyone to use, modify, and distribute it in any way that does not diminish the rights of anyone else to use, modify, and distribute it, provided that redistributed derivative works do not contain misleading author or version information. Derivative works need not be licensed under similar terms.",
      "ja": "このドキュメント全体またはその一部（PseudocodeおよびC Codeを含む）に関して、著者は保証せず、その使用に起因する損害について責任を負いません。著者は、再配分されたデリバティブ作業に誤解を招く著者またはバージョン情報が含まれていない限り、他の人がそれを使用、変更、および配布する権利を減少させない方法で、使用、変更、および配布する人に取消不能の許可を与えます。デリバティブ作業は、同様の条件でライセンスされる必要はありません。"
    },
    {
      "indent": 0,
      "text": "C. Punycode sample implementation",
      "ja": "C.パニコードサンプルの実装"
    },
    {
      "indent": 0,
      "text": "/*\npunycode.c from RFC 3492\nhttp://www.nicemice.net/idn/\nAdam M. Costello\nhttp://www.nicemice.net/amc/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "This is ANSI C code (C89) implementing Punycode (RFC 3492).",
      "ja": "これは、Punycode（RFC 3492）を実装するANSI Cコード（C89）です。"
    },
    {
      "indent": 0,
      "text": "*/",
      "ja": "*/"
    },
    {
      "indent": 0,
      "text": "/************************************************************/\n/* Public interface (would normally go in its own .h file): */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include <limits.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum punycode_status {\n  punycode_success,\n  punycode_bad_input,   /* Input is invalid.                       */\n  punycode_big_output,  /* Output would exceed the space provided. */\n  punycode_overflow     /* Input needs wider integers to process.  */\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#if UINT_MAX >= (1 << 26) - 1\ntypedef unsigned int punycode_uint;\n#else\ntypedef unsigned long punycode_uint;\n#endif",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] );",
      "ja": "enum punycode_status punycode_encode（punycode_uint input_length、const punycode_uint input []、const unsigned char case_flags []、punycode_uint *output_length、char output []）;"
    },
    {
      "indent": 4,
      "text": "/* punycode_encode() converts Unicode to Punycode.  The input     */\n/* is represented as an array of Unicode code points (not code    */\n/* units; surrogate pairs are not allowed), and the output        */\n/* will be represented as an array of ASCII code points.  The     */\n/* output string is *not* null-terminated; it will contain        */\n/* zeros if and only if the input contains zeros.  (Of course     */\n/* the caller can leave room for a terminator and add one if      */\n/* needed.)  The input_length is the number of code points in     */\n/* the input.  The output_length is an in/out argument: the       */\n/* caller passes in the maximum number of code points that it     */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* can receive, and on successful return it will contain the      */\n/* number of code points actually output.  The case_flags array   */\n/* holds input_length boolean values, where nonzero suggests that */\n/* the corresponding Unicode character be forced to uppercase     */\n/* after being decoded (if possible), and zero suggests that      */\n/* it be forced to lowercase (if possible).  ASCII code points    */\n/* are encoded literally, except that ASCII letters are forced    */\n/* to uppercase or lowercase according to the corresponding       */\n/* uppercase flags.  If case_flags is a null pointer then ASCII   */\n/* letters are left as they are, and other code points are        */\n/* treated as if their uppercase flags were zero.  The return     */\n/* value can be any of the punycode_status values defined above   */\n/* except punycode_bad_input; if not punycode_success, then       */\n/* output_size and output might contain garbage.                  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] );",
      "ja": "enum punycode_status punycode_decode（punycode_uint input_length、const char input []、punycode_uint *output_length、punycode_uint output []、unsigned char case_flags []）;"
    },
    {
      "indent": 4,
      "text": "/* punycode_decode() converts Punycode to Unicode.  The input is  */\n/* represented as an array of ASCII code points, and the output   */\n/* will be represented as an array of Unicode code points.  The   */\n/* input_length is the number of code points in the input.  The   */\n/* output_length is an in/out argument: the caller passes in      */\n/* the maximum number of code points that it can receive, and     */\n/* on successful return it will contain the actual number of      */\n/* code points output.  The case_flags array needs room for at    */\n/* least output_length values, or it can be a null pointer if the */\n/* case information is not needed.  A nonzero flag suggests that  */\n/* the corresponding Unicode character be forced to uppercase     */\n/* by the caller (if possible), while zero suggests that it be    */\n/* forced to lowercase (if possible).  ASCII code points are      */\n/* output already in the proper case, but their flags will be set */\n/* appropriately so that applying the flags would be harmless.    */\n/* The return value can be any of the punycode_status values      */\n/* defined above; if not punycode_success, then output_length,    */\n/* output, and case_flags might contain garbage.  On success, the */\n/* decoder will never need to write an output_length greater than */\n/* input_length, because of how the encoding is defined.          */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/**********************************************************/\n/* Implementation (would normally go in its own .c file): */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*** Bootstring parameters for Punycode ***/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum { base = 36, tmin = 1, tmax = 26, skew = 38, damp = 700,\n       initial_bias = 72, initial_n = 0x80, delimiter = 0x2D };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* basic(cp) tests whether cp is a basic code point: */\n#define basic(cp) ((punycode_uint)(cp) < 0x80)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* delim(cp) tests whether cp is a delimiter: */\n#define delim(cp) ((cp) == delimiter)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* decode_digit(cp) returns the numeric value of a basic code */\n/* point (for use in representing integers) in the range 0 to */\n/* base-1, or base if cp is does not represent a value.       */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static punycode_uint decode_digit(punycode_uint cp)\n{\n  return  cp - 48 < 10 ? cp - 22 :  cp - 65 < 26 ? cp - 65 :\n          cp - 97 < 26 ? cp - 97 :  base;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* encode_digit(d,flag) returns the basic code point whose value      */\n/* (when used for representing integers) is d, which needs to be in   */\n/* the range 0 to base-1.  The lowercase form is used unless flag is  */\n/* nonzero, in which case the uppercase form is used.  The behavior   */\n/* is undefined if flag is nonzero and digit d has no uppercase form. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static char encode_digit(punycode_uint d, int flag)\n{\n  return d + 22 + 75 * (d < 26) - ((flag != 0) << 5);\n  /*  0..25 map to ASCII a..z or A..Z */\n  /* 26..35 map to ASCII 0..9         */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* flagged(bcp) tests whether a basic code point is flagged */\n/* (uppercase).  The behavior is undefined if bcp is not a  */\n/* basic code point.                                        */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#define flagged(bcp) ((punycode_uint)(bcp) - 65 < 26)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* encode_basic(bcp,flag) forces a basic code point to lowercase */\n/* if flag is zero, uppercase if flag is nonzero, and returns    */\n/* the resulting code point.  The code point is unchanged if it  */\n/* is caseless.  The behavior is undefined if bcp is not a basic */\n/* code point.                                                   */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static char encode_basic(punycode_uint bcp, int flag) {",
      "ja": "static char ecode_basic（punycode_uint bcp、int flag）{"
    },
    {
      "indent": 0,
      "text": "  bcp -= (bcp - 97 < 26) << 5;\n  return bcp + ((!flag && (bcp - 65 < 26)) << 5);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*** Platform-specific constants ***/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* maxint is the maximum value of a punycode_uint variable: */\nstatic const punycode_uint maxint = -1;\n/* Because maxint is unsigned, -1 becomes the maximum value. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*** Bias adaptation function ***/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static punycode_uint adapt( punycode_uint delta, punycode_uint numpoints, int firsttime ) { punycode_uint k;",
      "ja": "static punycode_uint adapt（punycode_uint delta、punycode_uint numpoints、int firsttime）{punycode_uint k;"
    },
    {
      "indent": 2,
      "text": "delta = firsttime ? delta / damp : delta >> 1;\n/* delta >> 1 is a faster way of doing delta / 2 */\ndelta += delta / numpoints;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (k = 0;  delta > ((base - tmin) * tmax) / 2;  k += base) {\n  delta /= base - tmin;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  return k + (base - tmin + 1) * delta / (delta + skew);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*** Main encode function ***/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_encode( punycode_uint input_length, const punycode_uint input[], const unsigned char case_flags[], punycode_uint *output_length, char output[] ) { punycode_uint n, delta, h, b, out, max_out, bias, j, m, q, k, t;",
      "ja": "enum punycode_status punycode_encode（punycode_uint input_length、const punycode_uint input []、const unsigned char case_flags []、punycode_uint *output_length、char output []）{punycode_uint n、delta、h、out out、max_out、j、m、m、q、m、m、m、Q、K、T;"
    },
    {
      "indent": 2,
      "text": "/* Initialize the state: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "n = initial_n;\ndelta = out = 0;\nmax_out = *output_length;\nbias = initial_bias;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Handle the basic code points: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (j = 0;  j < input_length;  ++j) {\n  if (basic(input[j])) {\n    if (max_out - out < 2) return punycode_big_output;\n    output[out++] =\n      case_flags ?  encode_basic(input[j], case_flags[j]) : input[j];\n  }\n  /* else if (input[j] < n) return punycode_bad_input; */\n  /* (not needed for Punycode with unsigned code points) */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "h = b = out;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* h is the number of code points that have been handled, b is the  */\n/* number of basic code points, and out is the number of characters */\n/* that have been output.                                           */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (b > 0) output[out++] = delimiter;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Main encoding loop: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "while (h < input_length) {\n  /* All non-basic code points < n have been     */\n  /* handled already.  Find the next larger one: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (m = maxint, j = 0;  j < input_length;  ++j) {\n  /* if (basic(input[j])) continue; */\n  /* (not needed for Punycode) */\n  if (input[j] >= n && input[j] < m) m = input[j];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Increase delta enough to advance the decoder's    */\n/* <n,i> state to <m,0>, but guard against overflow: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (m - n > (maxint - delta) / (h + 1)) return punycode_overflow;\ndelta += (m - n) * (h + 1);\nn = m;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < input_length;  ++j) {\n  /* Punycode does not need to check whether input[j] is basic: */\n  if (input[j] < n /* || basic(input[j]) */ ) {\n    if (++delta == 0) return punycode_overflow;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (input[j] == n) {\n  /* Represent delta as a generalized variable-length integer: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "for (q = delta, k = base;  ;  k += base) {\n  if (out >= max_out) return punycode_big_output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "  t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n      k >= bias + tmax ? tmax : k - bias;\n  if (q < t) break;\n  output[out++] = encode_digit(t + (q - t) % (base - t), 0);\n  q = (q - t) / (base - t);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "    output[out++] = encode_digit(q, case_flags && case_flags[j]);\n    bias = adapt(delta, h + 1, h == b);\n    delta = 0;\n    ++h;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  ++delta, ++n;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  *output_length = out;\n  return punycode_success;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/*** Main decode function ***/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum punycode_status punycode_decode( punycode_uint input_length, const char input[], punycode_uint *output_length, punycode_uint output[], unsigned char case_flags[] ) { punycode_uint n, out, i, max_out, bias, b, j, in, oldi, w, k, digit, t;",
      "ja": "enum punycode_status punycode_decode（punycode_uint input_length、const char input []、punycode_uint *output_length、punycode_uint output []、unsigned char case_flags []）{punycode_uint n、out、i、max_out、bias、b、j、oldi、K、桁、T;"
    },
    {
      "indent": 2,
      "text": "/* Initialize the state: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "n = initial_n;\nout = i = 0;\nmax_out = *output_length;\nbias = initial_bias;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Handle the basic code points:  Let b be the number of input code */\n/* points before the last delimiter, or 0 if there is none, then    */\n/* copy the first b code points to the output.                      */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (b = j = 0;  j < input_length;  ++j) if (delim(input[j])) b = j;\nif (b > max_out) return punycode_big_output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (j = 0;  j < b;  ++j) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  if (case_flags) case_flags[out] = flagged(input[j]);\n  if (!basic(input[j])) return punycode_bad_input;\n  output[out++] = input[j];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "/* Main decoding loop:  Start just after the last delimiter if any  */\n/* basic code points were copied; start at the beginning otherwise. */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "for (in = b > 0 ? b + 1 : 0;  in < input_length;  ++out) {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* in is the index of the next character to be consumed, and */\n/* out is the number of code points in the output array.     */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Decode a generalized variable-length integer into delta,  */\n/* which gets added to i.  The overflow checking is easier   */\n/* if we increase i as we go, then subtract off its starting */\n/* value at the end to obtain delta.                         */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (oldi = i, w = 1, k = base;  ;  k += base) {\n  if (in >= input_length) return punycode_bad_input;\n  digit = decode_digit(input[in++]);\n  if (digit >= base) return punycode_bad_input;\n  if (digit > (maxint - i) / w) return punycode_overflow;\n  i += digit * w;\n  t = k <= bias /* + tmin */ ? tmin :     /* +tmin not needed */\n      k >= bias + tmax ? tmax : k - bias;\n  if (digit < t) break;\n  if (w > maxint / (base - t)) return punycode_overflow;\n  w *= (base - t);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "bias = adapt(i - oldi, out + 1, oldi == 0);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* i was supposed to wrap around from out+1 to 0,   */\n/* incrementing n each time, so we'll fix that now: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (i / (out + 1) > maxint - n) return punycode_overflow;\nn += i / (out + 1);\ni %= (out + 1);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Insert n at position i of the output: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* not needed for Punycode: */\n/* if (decode_digit(n) <= base) return punycode_invalid_input; */\nif (out >= max_out) return punycode_big_output;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (case_flags) {\n  memmove(case_flags + i + 1, case_flags + i, out - i);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "  /* Case of last character determines uppercase flag: */\n  case_flags[i] = flagged(input[in - 1]);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  memmove(output + i + 1, output + i, (out - i) * sizeof *output);\n  output[i++] = n;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "  *output_length = out;\n  return punycode_success;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/******************************************************************/\n/* Wrapper for testing (would normally go in a separate .c file): */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* For testing, we'll just set some compile-time limits rather than */\n/* use malloc(), and set a compile-time option rather than using a  */\n/* command-line option.                                             */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "enum {\n  unicode_max_length = 256,\n  ace_max_length = 256\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static void usage(char **argv)\n{\n  fprintf(stderr,\n    \"\\n\"\n    \"%s -e reads code points and writes a Punycode string.\\n\"\n    \"%s -d reads a Punycode string and writes code points.\\n\"\n    \"\\n\"\n    \"Input and output are plain text in the native character set.\\n\"\n    \"Code points are in the form u+hex separated by whitespace.\\n\"\n    \"Although the specification allows Punycode strings to contain\\n\"\n    \"any characters from the ASCII repertoire, this test code\\n\"\n    \"supports only the printable characters, and needs the Punycode\\n\"\n    \"string to be followed by a newline.\\n\"\n    \"The case of the u in u+hex is the force-to-uppercase flag.\\n\"\n    , argv[0], argv[0]);\n  exit(EXIT_FAILURE);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static void fail(const char *msg)",
      "ja": "静的ボイド障害（const char *msg）"
    },
    {
      "indent": 0,
      "text": "{\n  fputs(msg,stderr);\n  exit(EXIT_FAILURE);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static const char too_big[] =\n  \"input or output is too large, recompile with larger limits\\n\";\nstatic const char invalid_input[] = \"invalid input\\n\";\nstatic const char overflow[] = \"arithmetic overflow\\n\";\nstatic const char io_error[] = \"I/O error\\n\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "/* The following string is used to convert printable */\n/* characters between ASCII and the native charset:  */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "static const char print_ascii[] =\n  \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"\n  \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\"\n  \" !\\\"#$%&'()*+,-./\"\n  \"0123456789:;<=>?\"\n  \"@ABCDEFGHIJKLMNO\"\n  \"PQRSTUVWXYZ[\\\\]^_\"\n  \"`abcdefghijklmno\"\n  \"pqrstuvwxyz{|}~\\n\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "int main(int argc, char **argv)\n{\n  enum punycode_status status;\n  int r;\n  unsigned int input_length, output_length, j;\n  unsigned char case_flags[unicode_max_length];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (argc != 2) usage(argv);\nif (argv[1][0] != '-') usage(argv);\nif (argv[1][2] != 0) usage(argv);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (argv[1][1] == 'e') {\n  punycode_uint input[unicode_max_length];\n  unsigned long codept;\n  char output[ace_max_length+1], uplus[3];\n  int c;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Read the input code points: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "input_length = 0;",
      "ja": "input_length = 0;"
    },
    {
      "indent": 4,
      "text": "for (;;) {\n  r = scanf(\"%2s%lx\", uplus, &codept);\n  if (ferror(stdin)) fail(io_error);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (r == EOF || r == 0) break;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (r != 2 || uplus[1] != '+' || codept > (punycode_uint)-1) {\n  fail(invalid_input);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (input_length == unicode_max_length) fail(too_big);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (uplus[0] == 'u') case_flags[input_length] = 0;\nelse if (uplus[0] == 'U') case_flags[input_length] = 1;\nelse fail(invalid_input);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "  input[input_length++] = codept;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Encode: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "output_length = ace_max_length;\nstatus = punycode_encode(input_length, input, case_flags,\n                         &output_length, output);\nif (status == punycode_bad_input) fail(invalid_input);\nif (status == punycode_big_output) fail(too_big);\nif (status == punycode_overflow) fail(overflow);\nassert(status == punycode_success);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Convert to native charset and output: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < output_length;  ++j) {\n  c = output[j];\n  assert(c >= 0 && c <= 127);\n  if (print_ascii[c] == 0) fail(invalid_input);\n  output[j] = print_ascii[c];\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "  output[j] = 0;\n  r = puts(output);\n  if (r == EOF) fail(io_error);\n  return EXIT_SUCCESS;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": "if (argv[1][1] == 'd') {\n  char input[ace_max_length+2], *p, *pp;\n  punycode_uint output[unicode_max_length];",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Read the Punycode input string and convert to ASCII: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "fgets(input, ace_max_length+2, stdin);\nif (ferror(stdin)) fail(io_error);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "if (feof(stdin)) fail(invalid_input);\ninput_length = strlen(input) - 1;\nif (input[input_length] != '\\n') fail(too_big);\ninput[input_length] = 0;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (p = input;  *p != 0;  ++p) {\n  pp = strchr(print_ascii, *p);\n  if (pp == 0) fail(invalid_input);\n  *p = pp - print_ascii;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Decode: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "output_length = unicode_max_length;\nstatus = punycode_decode(input_length, input, &output_length,\n                         output, case_flags);\nif (status == punycode_bad_input) fail(invalid_input);\nif (status == punycode_big_output) fail(too_big);\nif (status == punycode_overflow) fail(overflow);\nassert(status == punycode_success);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "/* Output the result: */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "for (j = 0;  j < output_length;  ++j) {\n  r = printf(\"%s+%04lX\\n\",\n             case_flags[j] ? \"U\" : \"u\",\n             (unsigned long) output[j] );\n  if (r < 0) fail(io_error);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 2,
      "text": " return EXIT_SUCCESS; }",
      "ja": "exit_successを返します。}"
    },
    {
      "indent": 0,
      "text": "  usage(argv);\n  return EXIT_SUCCESS;  /* not reached, but quiets compiler warning */\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Adam M. Costello\nUniversity of California, Berkeley\nhttp://www.nicemice.net/amc/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Full Copyright Statement",
      "ja": "完全な著作権声明"
    },
    {
      "indent": 3,
      "text": "Copyright (C) The Internet Society (2003). All Rights Reserved.",
      "ja": "Copyright（c）The Internet Society（2003）。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document and translations of it may be copied and furnished to others, and derivative works that comment on or otherwise explain it or assist in its implementation may be prepared, copied, published and distributed, in whole or in part, without restriction of any kind, provided that the above copyright notice and this paragraph are included on all such copies and derivative works. However, this document itself may not be modified in any way, such as by removing the copyright notice or references to the Internet Society or other Internet organizations, except as needed for the purpose of developing Internet standards in which case the procedures for copyrights defined in the Internet Standards process must be followed, or as required to translate it into languages other than English.",
      "ja": "このドキュメントと翻訳は他の人にコピーされて提供される場合があり、それについてコメントまたは説明するか、その実装を支援する派生作品は、いかなる種類の制限なしに、準備、コピー、公開、配布される場合があります。、上記の著作権通知とこの段落がそのようなすべてのコピーとデリバティブ作品に含まれている場合。ただし、このドキュメント自体は、インターネット協会や他のインターネット組織への著作権通知や参照を削除するなど、いかなる方法でも変更できない場合があります。インターネット標準のプロセスに従うか、英語以外の言語に翻訳するために必要な場合に従う必要があります。"
    },
    {
      "indent": 3,
      "text": "The limited permissions granted above are perpetual and will not be revoked by the Internet Society or its successors or assigns.",
      "ja": "上記の限られた許可は永続的であり、インターネット社会またはその後継者または譲受人によって取り消されることはありません。"
    },
    {
      "indent": 3,
      "text": "This document and the information contained herein is provided on an \"AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.",
      "ja": "この文書と本書に含まれる情報は、「現状」に基づいて提供されており、インターネット社会とインターネットエンジニアリングタスクフォースは、ここにある情報の使用が行われないという保証を含むがこれらに限定されないすべての保証を否認します。特定の目的に対する商品性または適合性の権利または黙示的な保証を侵害します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgement",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Funding for the RFC Editor function is currently provided by the Internet Society.",
      "ja": "RFCエディター機能の資金は現在、インターネット協会によって提供されています。"
    }
  ]
}