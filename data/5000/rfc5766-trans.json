{
  "title": {
    "text": "RFC 5766 - Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)",
    "ja": "RFC 5766 - NAT周辺のリレーを使用したトラバーサル（ターン）：NATのセッショントラバーサルユーティリティへのリレー拡張機能（STUN）"
  },
  "number": 5766,
  "created_at": "2023-02-11 17:17:46.587737+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                           R. Mahy\nRequest for Comments: 5766                                  Unaffiliated\nCategory: Standards Track                                    P. Matthews\nISSN: 2070-1721                                           Alcatel-Lucent\n                                                            J. Rosenberg\n                                                             jdrosen.net\n                                                              April 2010",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " Traversal Using Relays around NAT (TURN): Relay Extensions to Session Traversal Utilities for NAT (STUN)",
      "ja": "NAT周辺のリレーを使用したトラバーサル（ターン）：NATのセッショントラバーサルユーティリティへのリレー拡張機能（STUN）"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "If a host is located behind a NAT, then in certain situations it can be impossible for that host to communicate directly with other hosts (peers). In these situations, it is necessary for the host to use the services of an intermediate node that acts as a communication relay. This specification defines a protocol, called TURN (Traversal Using Relays around NAT), that allows the host to control the operation of the relay and to exchange packets with its peers using the relay. TURN differs from some other relay control protocols in that it allows a client to communicate with multiple peers using a single relay address.",
      "ja": "ホストがNATの後ろにある場合、特定の状況では、そのホストが他のホスト（ピア）と直接通信することは不可能です。これらの状況では、ホストが通信リレーとして機能する中間ノードのサービスを使用する必要があります。この仕様は、ホストがリレーの動作を制御し、リレーを使用してピアとパケットを交換できるようにするため、ターン（NATの周りのリレーを使用してトラバーサル）と呼ばれるプロトコルを定義します。ターンは、クライアントが単一のリレーアドレスを使用して複数のピアと通信できるという点で、他のいくつかのリレー制御プロトコルとは異なります。"
    },
    {
      "indent": 3,
      "text": "The TURN protocol was designed to be used as part of the ICE (Interactive Connectivity Establishment) approach to NAT traversal, though it also can be used without ICE.",
      "ja": "ターンプロトコルは、氷（インタラクティブ接続確立）アプローチの一部としてNat Traversalへのアプローチの一部として使用するように設計されていますが、氷なしでも使用できます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 5741のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5766.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc5766で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2010 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Overview of Operation  . . . . . . . . . . . . . . . . . . . .  5\n  2.1.  Transports . . . . . . . . . . . . . . . . . . . . . . . .  8\n  2.2.  Allocations  . . . . . . . . . . . . . . . . . . . . . . .  9\n  2.3.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . 11\n  2.4.  Send Mechanism . . . . . . . . . . . . . . . . . . . . . . 12\n  2.5.  Channels . . . . . . . . . . . . . . . . . . . . . . . . . 13\n  2.6.  Unprivileged TURN Servers  . . . . . . . . . . . . . . . . 15\n  2.7.  Avoiding IP Fragmentation  . . . . . . . . . . . . . . . . 16\n  2.8.  RTP Support  . . . . . . . . . . . . . . . . . . . . . . . 17\n  2.9.  Anycast Discovery of Servers . . . . . . . . . . . . . . . 17\n3.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . 18\n4.  General Behavior . . . . . . . . . . . . . . . . . . . . . . . 19\n5.  Allocations  . . . . . . . . . . . . . . . . . . . . . . . . . 22\n6.  Creating an Allocation . . . . . . . . . . . . . . . . . . . . 23\n  6.1.  Sending an Allocate Request  . . . . . . . . . . . . . . . 23\n  6.2.  Receiving an Allocate Request  . . . . . . . . . . . . . . 24\n  6.3.  Receiving an Allocate Success Response . . . . . . . . . . 28\n  6.4.  Receiving an Allocate Error Response . . . . . . . . . . . 29\n7.  Refreshing an Allocation . . . . . . . . . . . . . . . . . . . 31\n  7.1.  Sending a Refresh Request  . . . . . . . . . . . . . . . . 31\n  7.2.  Receiving a Refresh Request  . . . . . . . . . . . . . . . 31\n  7.3.  Receiving a Refresh Response . . . . . . . . . . . . . . . 32\n8.  Permissions  . . . . . . . . . . . . . . . . . . . . . . . . . 32\n9.  CreatePermission . . . . . . . . . . . . . . . . . . . . . . . 34\n  9.1.  Forming a CreatePermission Request . . . . . . . . . . . . 34\n  9.2.  Receiving a CreatePermission Request . . . . . . . . . . . 34\n  9.3.  Receiving a CreatePermission Response  . . . . . . . . . . 35\n10. Send and Data Methods  . . . . . . . . . . . . . . . . . . . . 35\n  10.1. Forming a Send Indication  . . . . . . . . . . . . . . . . 35\n  10.2. Receiving a Send Indication  . . . . . . . . . . . . . . . 35\n     10.3. Receiving a UDP Datagram . . . . . . . . . . . . . . . . . 36\n  10.4. Receiving a Data Indication  . . . . . . . . . . . . . . . 37\n11. Channels . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\n  11.1. Sending a ChannelBind Request  . . . . . . . . . . . . . . 39\n  11.2. Receiving a ChannelBind Request  . . . . . . . . . . . . . 39\n  11.3. Receiving a ChannelBind Response . . . . . . . . . . . . . 40\n  11.4. The ChannelData Message  . . . . . . . . . . . . . . . . . 41\n  11.5. Sending a ChannelData Message  . . . . . . . . . . . . . . 41\n  11.6. Receiving a ChannelData Message  . . . . . . . . . . . . . 42\n  11.7. Relaying Data from the Peer  . . . . . . . . . . . . . . . 43\n12. IP Header Fields . . . . . . . . . . . . . . . . . . . . . . . 43\n13. New STUN Methods . . . . . . . . . . . . . . . . . . . . . . . 45\n14. New STUN Attributes  . . . . . . . . . . . . . . . . . . . . . 45\n  14.1. CHANNEL-NUMBER . . . . . . . . . . . . . . . . . . . . . . 45\n  14.2. LIFETIME . . . . . . . . . . . . . . . . . . . . . . . . . 46\n  14.3. XOR-PEER-ADDRESS . . . . . . . . . . . . . . . . . . . . . 46\n  14.4. DATA . . . . . . . . . . . . . . . . . . . . . . . . . . . 46\n  14.5. XOR-RELAYED-ADDRESS  . . . . . . . . . . . . . . . . . . . 46\n  14.6. EVEN-PORT  . . . . . . . . . . . . . . . . . . . . . . . . 46\n  14.7. REQUESTED-TRANSPORT  . . . . . . . . . . . . . . . . . . . 47\n  14.8. DONT-FRAGMENT  . . . . . . . . . . . . . . . . . . . . . . 47\n  14.9. RESERVATION-TOKEN  . . . . . . . . . . . . . . . . . . . . 48\n15. New STUN Error Response Codes  . . . . . . . . . . . . . . . . 48\n16. Detailed Example . . . . . . . . . . . . . . . . . . . . . . . 48\n17. Security Considerations  . . . . . . . . . . . . . . . . . . . 55\n  17.1. Outsider Attacks . . . . . . . . . . . . . . . . . . . . . 55\n    17.1.1.  Obtaining Unauthorized Allocations  . . . . . . . . . 55\n    17.1.2.  Offline Dictionary Attacks  . . . . . . . . . . . . . 56\n    17.1.3.  Faked Refreshes and Permissions . . . . . . . . . . . 56\n    17.1.4.  Fake Data . . . . . . . . . . . . . . . . . . . . . . 56\n    17.1.5.  Impersonating a Server  . . . . . . . . . . . . . . . 57\n    17.1.6.  Eavesdropping Traffic . . . . . . . . . . . . . . . . 58\n    17.1.7.  TURN Loop Attack  . . . . . . . . . . . . . . . . . . 58\n  17.2. Firewall Considerations  . . . . . . . . . . . . . . . . . 59\n    17.2.1.  Faked Permissions . . . . . . . . . . . . . . . . . . 59\n    17.2.2.  Blacklisted IP Addresses  . . . . . . . . . . . . . . 60\n    17.2.3.  Running Servers on Well-Known Ports . . . . . . . . . 60\n  17.3. Insider Attacks  . . . . . . . . . . . . . . . . . . . . . 60\n    17.3.1.  DoS against TURN Server . . . . . . . . . . . . . . . 60\n    17.3.2.  Anonymous Relaying of Malicious Traffic . . . . . . . 61\n    17.3.3.  Manipulating Other Allocations  . . . . . . . . . . . 61\n  17.4. Other Considerations . . . . . . . . . . . . . . . . . . . 61\n18. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 61\n19. IAB Considerations . . . . . . . . . . . . . . . . . . . . . . 62\n20. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 63\n21. References . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n  21.1. Normative References . . . . . . . . . . . . . . . . . . . 64\n  21.2. Informative References . . . . . . . . . . . . . . . . . . 64",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "A host behind a NAT may wish to exchange packets with other hosts, some of which may also be behind NATs. To do this, the hosts involved can use \"hole punching\" techniques (see [RFC5128]) in an attempt discover a direct communication path; that is, a communication path that goes from one host to another through intervening NATs and routers, but does not traverse any relays.",
      "ja": "NATの背後にあるホストは、他のホストとパケットを交換することを望むかもしれません。これを行うために、関係するホストは「ホールパンチ」テクニック（[RFC5128]を参照）を使用して、直接通信パスを発見できます。つまり、介在するNATとルーターを介して、あるホストから別のホストへの通信パスですが、リレーを通過しません。"
    },
    {
      "indent": 3,
      "text": "As described in [RFC5128] and [RFC4787], hole punching techniques will fail if both hosts are behind NATs that are not well behaved. For example, if both hosts are behind NATs that have a mapping behavior of \"address-dependent mapping\" or \"address- and port-dependent mapping\", then hole punching techniques generally fail.",
      "ja": "[RFC5128]および[RFC4787]で説明されているように、両方のホストが十分に動作していないNATの背後にある場合、ホールパンチング技術は失敗します。たとえば、両方のホストが「アドレス依存マッピング」または「アドレス依存およびポート依存マッピング」のマッピング動作を持つNATの背後にある場合、ホールパンチテクニックは一般に失敗します。"
    },
    {
      "indent": 3,
      "text": "When a direct communication path cannot be found, it is necessary to use the services of an intermediate host that acts as a relay for the packets. This relay typically sits in the public Internet and relays packets between two hosts that both sit behind NATs.",
      "ja": "直接通信パスが見つからない場合、パケットのリレーとして機能する中間ホストのサービスを使用する必要があります。このリレーは通常、パブリックインターネットに配置され、両方ともNATの後ろに座っている2つのホスト間でパケットをリレーします。"
    },
    {
      "indent": 3,
      "text": "This specification defines a protocol, called TURN, that allows a host behind a NAT (called the TURN client) to request that another host (called the TURN server) act as a relay. The client can arrange for the server to relay packets to and from certain other hosts (called peers) and can control aspects of how the relaying is done. The client does this by obtaining an IP address and port on the server, called the relayed transport address. When a peer sends a packet to the relayed transport address, the server relays the packet to the client. When the client sends a data packet to the server, the server relays it to the appropriate peer using the relayed transport address as the source.",
      "ja": "この仕様では、NAT（Turn Clientと呼ばれる）の背後にあるホスト（Turn Serverと呼ばれる）（Turn Serverと呼ばれる）がリレーとして機能するように要求できるプロトコルを定義します。クライアントは、サーバーが特定の他のホスト（ピアと呼ばれる）との間でパケットを中継するように手配し、リレーの完了方法の側面を制御できます。クライアントは、リレー輸送アドレスと呼ばれるサーバー上のIPアドレスとポートを取得することにより、これを行います。ピアがリレーのトランスポートアドレスにパケットを送信すると、サーバーはパケットをクライアントにリレーします。クライアントがデータパケットをサーバーに送信すると、サーバーはソースとして中継されたトランスポートアドレスを使用して適切なピアにリレーします。"
    },
    {
      "indent": 3,
      "text": "A client using TURN must have some way to communicate the relayed transport address to its peers, and to learn each peer's IP address and port (more precisely, each peer's server-reflexive transport address, see Section 2). How this is done is out of the scope of the TURN protocol. One way this might be done is for the client and peers to exchange email messages. Another way is for the client and its peers to use a special-purpose \"introduction\" or \"rendezvous\" protocol (see [RFC5128] for more details).",
      "ja": "ターンを使用しているクライアントは、リレーの輸送アドレスをピアに通信し、各ピアのIPアドレスとポートを学習するための何らかの方法を持っている必要があります（より正確には、各ピアのサーバー反射輸送アドレス、セクション2を参照）。これがどのように行われるかは、ターンプロトコルの範囲外です。これが行われる可能性のある方法の1つは、クライアントとピアが電子メールメッセージを交換することです。もう1つの方法は、クライアントとそのピアが特別な目的の「紹介」または「ランデブー」プロトコルを使用することです（詳細については[RFC5128]を参照）。"
    },
    {
      "indent": 3,
      "text": "If TURN is used with ICE [RFC5245], then the relayed transport address and the IP addresses and ports of the peers are included in the ICE candidate information that the rendezvous protocol must carry. For example, if TURN and ICE are used as part of a multimedia solution using SIP [RFC3261], then SIP serves the role of the rendezvous protocol, carrying the ICE candidate information inside the body of SIP messages. If TURN and ICE are used with some other rendezvous protocol, then [MMUSIC-ICE-NONSIP] provides guidance on the services the rendezvous protocol must perform.",
      "ja": "ターンがICE [RFC5245]で使用される場合、リレー輸送アドレスとピアのIPアドレスとポートは、Rendezvousプロトコルが運ぶ必要があるICE候補の情報に含まれています。たとえば、SIP [RFC3261]を使用してマルチメディアソリューションの一部としてターンとアイスを使用する場合、SIPはRendezvousプロトコルの役割を果たし、SIPメッセージのボディ内にICE候補の情報を運びます。ターンと氷を他のいくつかのランデブープロトコルとともに使用する場合、[mmusic-ice-nonsip]は、ランデブープロトコルが実行する必要があるサービスに関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "Though the use of a TURN server to enable communication between two hosts behind NATs is very likely to work, it comes at a high cost to the provider of the TURN server, since the server typically needs a high-bandwidth connection to the Internet. As a consequence, it is best to use a TURN server only when a direct communication path cannot be found. When the client and a peer use ICE to determine the communication path, ICE will use hole punching techniques to search for a direct path first and only use a TURN server when a direct path cannot be found.",
      "ja": "NATの背後にある2つのホスト間の通信を有効にするためのターンサーバーの使用は非常に効果的ですが、サーバーは通常、インターネットへの高帯域幅接続が必要なため、ターンサーバーのプロバイダーに高コストがかかります。結果として、直接通信パスが見つからない場合にのみ、ターンサーバーを使用することをお勧めします。クライアントとピアがICEを使用して通信パスを決定する場合、ICEは最初に直接パスを検索するためにホールパンチングテクニックを使用し、直接パスが見つからない場合にのみターンサーバーを使用します。"
    },
    {
      "indent": 3,
      "text": "TURN was originally invented to support multimedia sessions signaled using SIP. Since SIP supports forking, TURN supports multiple peers per relayed transport address; a feature not supported by other approaches (e.g., SOCKS [RFC1928]). However, care has been taken to make sure that TURN is suitable for other types of applications.",
      "ja": "ターンはもともと、SIPを使用して合図されたマルチメディアセッションをサポートするために発明されました。SIPはフォーキングをサポートしているため、Turnはリレーした輸送住所ごとに複数のピアをサポートします。他のアプローチでサポートされていない機能（例：ソックス[RFC1928]）。ただし、そのターンが他のタイプのアプリケーションに適していることを確認するために注意が払われています。"
    },
    {
      "indent": 3,
      "text": "TURN was designed as one piece in the larger ICE approach to NAT traversal. Implementors of TURN are urged to investigate ICE and seriously consider using it for their application. However, it is possible to use TURN without ICE.",
      "ja": "ターンは、Nat Traversalのより大きな氷のアプローチの1つのピースとして設計されました。ターンの実装者は、氷を調査し、アプリケーションに使用することを真剣に検討することを求められます。ただし、氷なしでターンを使用することは可能です。"
    },
    {
      "indent": 3,
      "text": "TURN is an extension to the STUN (Session Traversal Utilities for NAT) protocol [RFC5389]. Most, though not all, TURN messages are STUN-formatted messages. A reader of this document should be familiar with STUN.",
      "ja": "ターンは、スタン（NATのセッショントラバーサルユーティリティ）プロトコル[RFC5389]の拡張です。ほとんどではありませんが、ターンメッセージはスタンフォーマットメッセージです。このドキュメントの読者は、スタンに精通している必要があります。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Operation",
      "section_title": true,
      "ja": "2. 操作の概要"
    },
    {
      "indent": 3,
      "text": "This section gives an overview of the operation of TURN. It is non-normative.",
      "ja": "このセクションでは、ターンの操作の概要を示します。それは非規範的です。"
    },
    {
      "indent": 3,
      "text": "In a typical configuration, a TURN client is connected to a private network [RFC1918] and through one or more NATs to the public Internet. On the public Internet is a TURN server. Elsewhere in the Internet are one or more peers with which the TURN client wishes to communicate. These peers may or may not be behind one or more NATs. The client uses the server as a relay to send packets to these peers and to receive packets from these peers.",
      "ja": "典型的な構成では、ターンクライアントはプライベートネットワーク[RFC1918]に接続され、1つ以上のNATを介してパブリックインターネットに接続されます。パブリックインターネットにはターンサーバーがあります。インターネットの他の場所には、ターンクライアントがコミュニケーションを望んでいる1つ以上のピアがあります。これらのピアは、1つ以上のNATの後ろにいる場合とそうでない場合があります。クライアントは、サーバーをリレーとして使用して、これらのピアにパケットを送信し、これらのピアからパケットを受信します。"
    },
    {
      "indent": 1,
      "text": "                                       Peer A\n                                       Server-Reflexive    +---------+\n                                       Transport Address   |         |\n                                       192.0.2.150:32102   |         |\n                                           |              /|         |\n                         TURN              |            / ^|  Peer A |\n   Client's              Server            |           /  ||         |\n   Host Transport        Transport         |         //   ||         |\n   Address               Address           |       //     |+---------+\n  10.1.1.2:49721       192.0.2.15:3478     |+-+  //     Peer A\n           |               |               ||N| /       Host Transport\n           |   +-+         |               ||A|/        Address\n           |   | |         |               v|T|     192.168.100.2:49582\n           |   | |         |               /+-+\n+---------+|   | |         |+---------+   /              +---------+\n|         ||   |N|         ||         | //               |         |\n| TURN    |v   | |         v| TURN    |/                 |         |\n| Client  |----|A|----------| Server  |------------------|  Peer B |\n|         |    | |^         |         |^                ^|         |\n|         |    |T||         |         ||                ||         |\n+---------+    | ||         +---------+|                |+---------+\n               | ||                    |                |\n               | ||                    |                |\n               +-+|                    |                |\n                  |                    |                |\n                  |                    |                |\n            Client's                   |            Peer B\n            Server-Reflexive    Relayed             Transport\n            Transport Address   Transport Address   Address\n            192.0.2.1:7000      192.0.2.15:50000     192.0.2.210:49191",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 1",
      "ja": "図1"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows a typical deployment. In this figure, the TURN client and the TURN server are separated by a NAT, with the client on the private side and the server on the public side of the NAT. This NAT is assumed to be a \"bad\" NAT; for example, it might have a mapping property of \"address-and-port-dependent mapping\" (see [RFC4787]).",
      "ja": "図1は、典型的な展開を示しています。この図では、ターンクライアントとターンサーバーはNATによって分離され、クライアントはプライベート側に、サーバーはNATのパブリック側にあります。このNATは「悪い」NATであると想定されています。たとえば、「アドレスとポートに依存するマッピング」のマッピングプロパティがある場合があります（[RFC4787]を参照）。"
    },
    {
      "indent": 3,
      "text": "The client talks to the server from a (IP address, port) combination called the client's HOST TRANSPORT ADDRESS. (The combination of an IP address and port is called a TRANSPORT ADDRESS.)",
      "ja": "クライアントは、クライアントのホストトランスポートアドレスと呼ばれる（IPアドレス、ポート）の組み合わせからサーバーに話しかけます。（IPアドレスとポートの組み合わせは、トランスポートアドレスと呼ばれます。）"
    },
    {
      "indent": 3,
      "text": "The client sends TURN messages from its host transport address to a transport address on the TURN server that is known as the TURN SERVER TRANSPORT ADDRESS. The client learns the TURN server transport address through some unspecified means (e.g., configuration), and this address is typically used by many clients simultaneously.",
      "ja": "クライアントは、ホストトランスポートアドレスからターンサーバートランスポートアドレスとして知られているターンサーバーのトランスポートアドレスにターンメッセージを送信します。クライアントは、いくつかの不特定の手段（たとえば、構成）を介してターンサーバートランスポートアドレスを学習し、このアドレスは通常、多くのクライアントが同時に使用します。"
    },
    {
      "indent": 3,
      "text": "Since the client is behind a NAT, the server sees packets from the client as coming from a transport address on the NAT itself. This address is known as the client's SERVER-REFLEXIVE transport address; packets sent by the server to the client's server-reflexive transport address will be forwarded by the NAT to the client's host transport address.",
      "ja": "クライアントはNATの背後にいるので、サーバーはクライアントからのパケットをNAT自体のトランスポートアドレスから来ていると見ています。このアドレスは、クライアントのサーバー反射輸送アドレスとして知られています。サーバーからクライアントのサーバーに送信されるパケットは、NATによってクライアントのホストトランスポートアドレスに転送されます。"
    },
    {
      "indent": 3,
      "text": "The client uses TURN commands to create and manipulate an ALLOCATION on the server. An allocation is a data structure on the server. This data structure contains, amongst other things, the RELAYED TRANSPORT ADDRESS for the allocation. The relayed transport address is the transport address on the server that peers can use to have the server relay data to the client. An allocation is uniquely identified by its relayed transport address.",
      "ja": "クライアントは、ターンコマンドを使用して、サーバー上の割り当てを作成および操作します。割り当ては、サーバー上のデータ構造です。このデータ構造には、とりわけ、割り当てのための中継輸送アドレスが含まれています。中継されたトランスポートアドレスは、ピアがサーバーリレーデータをクライアントに配置するために使用できるサーバー上のトランスポートアドレスです。割り当ては、その中継輸送アドレスによって一意に識別されます。"
    },
    {
      "indent": 3,
      "text": "Once an allocation is created, the client can send application data to the server along with an indication of to which peer the data is to be sent, and the server will relay this data to the appropriate peer. The client sends the application data to the server inside a TURN message; at the server, the data is extracted from the TURN message and sent to the peer in a UDP datagram. In the reverse direction, a peer can send application data in a UDP datagram to the relayed transport address for the allocation; the server will then encapsulate this data inside a TURN message and send it to the client along with an indication of which peer sent the data. Since the TURN message always contains an indication of which peer the client is communicating with, the client can use a single allocation to communicate with multiple peers.",
      "ja": "割り当てが作成されると、クライアントはアプリケーションデータをサーバーに送信し、どのピアデータを送信するかを示すことができ、サーバーはこのデータを適切なピアに中継します。クライアントは、ターンメッセージ内のサーバーにアプリケーションデータを送信します。サーバーでは、データがターンメッセージから抽出され、UDPデータグラムのピアに送信されます。逆方向には、ピアは、割り当てのためにUDPデータグラム内のリレー輸送アドレスにアプリケーションデータを送信できます。サーバーは、このデータをターンメッセージ内にカプセル化し、どのピアがデータを送信したかを示すとともにクライアントに送信します。ターンメッセージには、クライアントがどのピアと通信しているかの表示が常に含まれているため、クライアントは単一の割り当てを使用して複数のピアと通信できます。"
    },
    {
      "indent": 3,
      "text": "When the peer is behind a NAT, then the client must identify the peer using its server-reflexive transport address rather than its host transport address. For example, to send application data to Peer A in the example above, the client must specify 192.0.2.150:32102 (Peer A's server-reflexive transport address) rather than 192.168.100.2: 49582 (Peer A's host transport address).",
      "ja": "ピアがNATの背後にいる場合、クライアントはホストトランスポートアドレスではなく、サーバー反射輸送アドレスを使用してピアを識別する必要があります。たとえば、上記の例でアプリケーションデータをピアAに送信するには、クライアントは192.168.100.2：49582（ピアAのホストトランスポースアドレス）ではなく、192.0.2.150:32102（ピアAのサーバー反射性輸送アドレス）を指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each allocation on the server belongs to a single client and has exactly one relayed transport address that is used only by that allocation. Thus, when a packet arrives at a relayed transport address on the server, the server knows for which client the data is intended.",
      "ja": "サーバー上の各割り当ては単一のクライアントに属し、その割り当てによってのみ使用される1つのリレー輸送アドレスがあります。したがって、パケットがサーバー上の中継されたトランスポートアドレスに到着すると、サーバーはどのクライアントが意図されているかを知っています。"
    },
    {
      "indent": 3,
      "text": "The client may have multiple allocations on a server at the same time.",
      "ja": "クライアントは、同時にサーバーに複数の割り当てを持っている場合があります。"
    },
    {
      "indent": 0,
      "text": "2.1. Transports",
      "section_title": true,
      "ja": "2.1. 輸送"
    },
    {
      "indent": 3,
      "text": "TURN, as defined in this specification, always uses UDP between the server and the peer. However, this specification allows the use of any one of UDP, TCP, or Transport Layer Security (TLS) over TCP to carry the TURN messages between the client and the server.",
      "ja": "この仕様で定義されているように、ターンは常にサーバーとピアの間でUDPを使用します。ただし、この仕様により、TCPを介したUDP、TCP、またはTransport Layer Security（TLS）のいずれかを使用して、クライアントとサーバーの間でターンメッセージを伝達することができます。"
    },
    {
      "indent": 11,
      "text": "+----------------------------+---------------------+\n| TURN client to TURN server | TURN server to peer |\n+----------------------------+---------------------+\n|             UDP            |         UDP         |\n|             TCP            |         UDP         |\n|        TLS over TCP        |         UDP         |\n+----------------------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If TCP or TLS-over-TCP is used between the client and the server, then the server will convert between these transports and UDP transport when relaying data to/from the peer.",
      "ja": "クライアントとサーバーの間でTCPまたはTLS-Over-TCPが使用されている場合、サーバーはピアにデータを中継するときにこれらのトランスポートとUDPトランスポート間で変換されます。"
    },
    {
      "indent": 3,
      "text": "Since this version of TURN only supports UDP between the server and the peer, it is expected that most clients will prefer to use UDP between the client and the server as well. That being the case, some readers may wonder: Why also support TCP and TLS-over-TCP?",
      "ja": "このバージョンのターンはサーバーとピア間のUDPのみをサポートするため、ほとんどのクライアントはクライアントとサーバーの間でもUDPを使用することを好むことが期待されています。その場合、一部の読者は、なぜTCPとTLS-Over-TCPもサポートするのか疑問に思うかもしれません。"
    },
    {
      "indent": 3,
      "text": "TURN supports TCP transport between the client and the server because some firewalls are configured to block UDP entirely. These firewalls block UDP but not TCP, in part because TCP has properties that make the intention of the nodes being protected by the firewall more obvious to the firewall. For example, TCP has a three-way handshake that makes in clearer that the protected node really wishes to have that particular connection established, while for UDP the best the firewall can do is guess which flows are desired by using filtering rules. Also, TCP has explicit connection teardown; while for UDP, the firewall has to use timers to guess when the flow is finished.",
      "ja": "一部のファイアウォールはUDPを完全にブロックするように構成されているため、ターンはクライアントとサーバー間のTCPトランスポートをサポートします。これらのファイアウォールは、TCPではなくUDPをブロックします。これは、TCPにはファイアウォールがファイアウォールに対してより明白で保護されているノードを意図するプロパティを持っているためです。たとえば、TCPには3方向の握手があり、保護されたノードがその特定の接続を確立したいと本当に望んでいることを明確にしますが、UDPの場合、ファイアウォールでできる最善のフローは、フィルタリングルールを使用することでどのフローが望ましいかを推測します。また、TCPには明示的な接続分解があります。UDPの場合、ファイアウォールはタイマーを使用して、フローが終了したときに推測する必要があります。"
    },
    {
      "indent": 3,
      "text": "TURN supports TLS-over-TCP transport between the client and the server because TLS provides additional security properties not provided by TURN's default digest authentication; properties that some clients may wish to take advantage of. In particular, TLS provides a way for the client to ascertain that it is talking to the correct server, and provides for confidentiality of TURN control messages. TURN does not require TLS because the overhead of using TLS is higher than that of digest authentication; for example, using TLS likely means that most application data will be doubly encrypted (once by TLS and once to ensure it is still encrypted in the UDP datagram).",
      "ja": "TLSは、ターンのデフォルトダイジェスト認証によって提供されていない追加のセキュリティプロパティを提供するため、ターンはクライアントとサーバー間のTLS-over-TCPトランスポートをサポートします。一部のクライアントが利用したいと思うプロパティ。特に、TLSは、クライアントが正しいサーバーと話していることを確認する方法を提供し、ターンコントロールメッセージの機密性を提供します。TLSを使用するオーバーヘッドはダイジェスト認証のオーバーヘッドよりも高いため、ターンはTLSを必要としません。たとえば、TLSを使用すると、ほとんどのアプリケーションデータが二重に暗号化されることを意味する可能性があります（TLSによって1回、1回はUDPデータグラムで暗号化されていることを確認します）。"
    },
    {
      "indent": 3,
      "text": "There is a planned extension to TURN to add support for TCP between the server and the peers [TURN-TCP]. For this reason, allocations that use UDP between the server and the peers are known as UDP allocations, while allocations that use TCP between the server and the peers are known as TCP allocations. This specification describes only UDP allocations.",
      "ja": "サーバーとピアの間にTCPのサポートを追加するための計画された拡張機能があります[Turn-TCP]。このため、サーバーとピア間でUDPを使用する割り当てはUDP割り当てとして知られていますが、サーバーとピア間でTCPを使用する割り当てはTCP割り当てとして知られています。この仕様では、UDPの割り当てのみが記載されています。"
    },
    {
      "indent": 3,
      "text": "TURN, as defined in this specification, only supports IPv4. All IP addresses in this specification must be IPv4 addresses. There is a planned extension to TURN to add support for IPv6 and for relaying between IPv4 and IPv6 [TURN-IPv6].",
      "ja": "この仕様で定義されているように、ターンはIPv4のみをサポートします。この仕様のすべてのIPアドレスは、IPv4アドレスでなければなりません。IPv6のサポートを追加し、IPv4とIPv6 [Turn-IPV6]を中継するためのターンをターンする計画された拡張機能があります。"
    },
    {
      "indent": 3,
      "text": "In some applications for TURN, the client may send and receive packets other than TURN packets on the host transport address it uses to communicate with the server. This can happen, for example, when using TURN with ICE. In these cases, the client can distinguish TURN packets from other packets by examining the source address of the arriving packet: those arriving from the TURN server will be TURN packets.",
      "ja": "一部のアプリケーションでは、クライアントは、サーバーと通信するために使用するホストトランスポートアドレスのターンパケット以外のパケットを送信および受信する場合があります。これは、たとえば、氷でターンを使用する場合に発生する可能性があります。これらの場合、クライアントは、到着するパケットのソースアドレスを調べることにより、ターンパケットを他のパケットと区別できます。TurnServerから到着するものはターンパケットになります。"
    },
    {
      "indent": 0,
      "text": "2.2. Allocations",
      "section_title": true,
      "ja": "2.2. 割り当て"
    },
    {
      "indent": 3,
      "text": "To create an allocation on the server, the client uses an Allocate transaction. The client sends an Allocate request to the server, and the server replies with an Allocate success response containing the allocated relayed transport address. The client can include attributes in the Allocate request that describe the type of allocation it desires (e.g., the lifetime of the allocation). Since relaying data has security implications, the server requires that the client authenticate itself, typically using STUN's long-term credential mechanism, to show that it is authorized to use the server.",
      "ja": "サーバーに割り当てを作成するために、クライアントは割り当てトランザクションを使用します。クライアントはサーバーに割り当てリクエストを送信し、サーバーは割り当てられた中継輸送アドレスを含む割り当て成功応答で返信します。クライアントは、望む割り当てのタイプ（たとえば、割り当ての寿命）を説明する割り当て要求に属性を含めることができます。データを中継するにはセキュリティの影響があるため、サーバーは、通常、Stunの長期的な資格情報メカニズムを使用して、サーバーを使用することが許可されていることを示すために、クライアントが自体を認証することを要求します。"
    },
    {
      "indent": 3,
      "text": "Once a relayed transport address is allocated, a client must keep the allocation alive. To do this, the client periodically sends a Refresh request to the server. TURN deliberately uses a different method (Refresh rather than Allocate) for refreshes to ensure that the client is informed if the allocation vanishes for some reason.",
      "ja": "中継の輸送アドレスが割り当てられたら、クライアントは割り当てを生かし続ける必要があります。これを行うために、クライアントは定期的にサーバーに更新リクエストを送信します。ターンは、リフレッシュに異なる方法（割り当てではなく更新）を意図的に使用して、何らかの理由で割り当てが消滅した場合にクライアントに通知されるようにします。"
    },
    {
      "indent": 3,
      "text": "The frequency of the Refresh transaction is determined by the lifetime of the allocation. The default lifetime of an allocation is 10 minutes -- this value was chosen to be long enough so that refreshing is not typically a burden on the client, while expiring allocations where the client has unexpectedly quit in a timely manner. However, the client can request a longer lifetime in the Allocate request and may modify its request in a Refresh request, and the server always indicates the actual lifetime in the response. The client must issue a new Refresh transaction within \"lifetime\" seconds of the previous Allocate or Refresh transaction. Once a client no longer wishes to use an allocation, it should delete the allocation using a Refresh request with a requested lifetime of 0.",
      "ja": "更新トランザクションの頻度は、割り当ての寿命によって決まります。割り当てのデフォルトの寿命は10分です。この値は、クライアントが通常クライアントの負担ではないように、クライアントが予期せずにタイムリーに辞めた割り当てを期限切れにしているように、十分に長いために選択されました。ただし、クライアントは割り当てリクエストでより長い寿命を要求し、リクエストを更新リクエストで変更することができ、サーバーは常に応答の実際の寿命を示します。クライアントは、以前の割り当てまたはリフレッシュトランザクションの「Lifetime」秒以内に新しい更新トランザクションを発行する必要があります。クライアントが割り当てを使用したくないと、リクエストされたLifetime 0の更新要求を使用して割り当てを削除する必要があります。"
    },
    {
      "indent": 3,
      "text": "Both the server and client keep track of a value known as the 5-TUPLE. At the client, the 5-tuple consists of the client's host transport address, the server transport address, and the transport protocol used by the client to communicate with the server. At the server, the 5-tuple value is the same except that the client's host transport address is replaced by the client's server-reflexive address, since that is the client's address as seen by the server.",
      "ja": "サーバーとクライアントの両方が、5タプルと呼ばれる値を追跡します。クライアントでは、5タプルは、クライアントのホストトランスポートアドレス、サーバートランスポートアドレス、およびクライアントがサーバーと通信するために使用するトランスポートプロトコルで構成されています。サーバーでは、5タプルの値は同じです。クライアントのホストトランスポートアドレスが、サーバーで見られるクライアントのアドレスであるため、クライアントのサーバー反射アドレスに置き換えられます。"
    },
    {
      "indent": 3,
      "text": "Both the client and the server remember the 5-tuple used in the Allocate request. Subsequent messages between the client and the server use the same 5-tuple. In this way, the client and server know which allocation is being referred to. If the client wishes to allocate a second relayed transport address, it must create a second allocation using a different 5-tuple (e.g., by using a different client host address or port).",
      "ja": "クライアントとサーバーの両方が、Alocateリクエストで使用された5タプルを覚えています。クライアントとサーバーの間の後続のメッセージは、同じ5タプルを使用します。このようにして、クライアントとサーバーは、どの割り当てが参照されているかを知っています。クライアントが2番目のリレー輸送アドレスを割り当てたい場合は、別の5タプルを使用して2番目の割り当てを作成する必要があります（たとえば、別のクライアントホストアドレスまたはポートを使用して）。"
    },
    {
      "indent": 6,
      "text": "NOTE: While the terminology used in this document refers to 5-tuples, the TURN server can store whatever identifier it likes that yields identical results. Specifically, an implementation may use a file-descriptor in place of a 5-tuple to represent a TCP connection.",
      "ja": "注：このドキュメントで使用されている用語は5タプルを指しますが、ターンサーバーは、同一の結果をもたらす好きな識別子を格納できます。具体的には、実装では、5タプルの代わりにファイル記述子を使用してTCP接続を表す場合があります。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |-- Allocate request --------------->|             |             |\n  |                                    |             |             |\n  |<--------------- Allocate failure --|             |             |\n  |                 (401 Unauthorized) |             |             |\n  |                                    |             |             |\n  |-- Allocate request --------------->|             |             |\n  |                                    |             |             |\n  |<---------- Allocate success resp --|             |             |\n  |            (192.0.2.15:50000)      |             |             |\n  //                                   //            //            //\n  |                                    |             |             |\n  |-- Refresh request ---------------->|             |             |\n  |                                    |             |             |\n  |<----------- Refresh success resp --|             |             |\n  |                                    |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 2",
      "ja": "図2"
    },
    {
      "indent": 3,
      "text": "In Figure 2, the client sends an Allocate request to the server without credentials. Since the server requires that all requests be authenticated using STUN's long-term credential mechanism, the server rejects the request with a 401 (Unauthorized) error code. The client then tries again, this time including credentials (not shown). This time, the server accepts the Allocate request and returns an Allocate success response containing (amongst other things) the relayed transport address assigned to the allocation. Sometime later, the client decides to refresh the allocation and thus sends a Refresh request to the server. The refresh is accepted and the server replies with a Refresh success response.",
      "ja": "図2では、クライアントは資格情報なしでサーバーに割り当てリクエストを送信します。サーバーは、Stunの長期的な資格情報メカニズムを使用してすべての要求を認証する必要があるため、サーバーは401（不正な）エラーコードで要求を拒否します。その後、クライアントは、今回は資格情報を含めて再び試みます（図示せず）。今回、サーバーは割り当てリクエストを受け入れ、割り当てに割り当てられたリレー輸送アドレスを含む（とりわけ）割り当て成功応答を返します。しばらくして、クライアントは割り当てを更新することを決定し、サーバーに更新リクエストを送信します。更新は受け入れられ、サーバーは更新成功応答で返信します。"
    },
    {
      "indent": 0,
      "text": "2.3. Permissions",
      "section_title": true,
      "ja": "2.3. 権限"
    },
    {
      "indent": 3,
      "text": "To ease concerns amongst enterprise IT administrators that TURN could be used to bypass corporate firewall security, TURN includes the notion of permissions. TURN permissions mimic the address-restricted filtering mechanism of NATs that comply with [RFC4787].",
      "ja": "企業のファイアウォールセキュリティをバイパスするためにターンを使用できるエンタープライズIT管理者間の懸念を容易にするために、ターンには許可の概念が含まれます。[RFC4787]に準拠したNATのアドレス制限フィルタリングメカニズムをターン権限を模倣します。"
    },
    {
      "indent": 3,
      "text": "An allocation can have zero or more permissions. Each permission consists of an IP address and a lifetime. When the server receives a UDP datagram on the allocation's relayed transport address, it first checks the list of permissions. If the source IP address of the datagram matches a permission, the application data is relayed to the client, otherwise the UDP datagram is silently discarded.",
      "ja": "割り当てにはゼロ以上の権限があります。各許可は、IPアドレスと生涯で構成されています。サーバーが割り当ての中継輸送アドレスでUDPデータグラムを受信すると、最初に権限のリストをチェックします。データグラムのソースIPアドレスが許可と一致する場合、アプリケーションデータはクライアントに中継されます。そうしないと、UDPデータグラムは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "A permission expires after 5 minutes if it is not refreshed, and there is no way to explicitly delete a permission. This behavior was selected to match the behavior of a NAT that complies with [RFC4787].",
      "ja": "更新されていない場合、5分後に許可証は期限切れになり、許可を明示的に削除する方法はありません。この動作は、[RFC4787]に準拠するNATの動作に一致するように選択されました。"
    },
    {
      "indent": 3,
      "text": "The client can install or refresh a permission using either a CreatePermission request or a ChannelBind request. Using the CreatePermission request, multiple permissions can be installed or refreshed with a single request -- this is important for applications that use ICE. For security reasons, permissions can only be installed or refreshed by transactions that can be authenticated; thus, Send indications and ChannelData messages (which are used to send data to peers) do not install or refresh any permissions.",
      "ja": "クライアントは、CreatePermissionリクエストまたはChannelBindリクエストのいずれかを使用して、許可をインストールまたは更新できます。createpermission要求を使用すると、複数のアクセス許可を1つのリクエストでインストールまたは更新できます。これは、ICEを使用するアプリケーションにとって重要です。セキュリティ上の理由から、許可は認証できるトランザクションによってのみインストールまたは更新できます。したがって、表示とチャネルデータのメッセージ（ピアにデータの送信に使用される）を送信しても、アクセス許可はインストールまたは更新されません。"
    },
    {
      "indent": 3,
      "text": "Note that permissions are within the context of an allocation, so adding or expiring a permission in one allocation does not affect other allocations.",
      "ja": "許可は割り当てのコンテキスト内にあるため、1つの割り当てで許可を追加または期限切れにしても、他の割り当てには影響しないことに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.4. Send Mechanism",
      "section_title": true,
      "ja": "2.4. メカニズムを送信します"
    },
    {
      "indent": 3,
      "text": "There are two mechanisms for the client and peers to exchange application data using the TURN server. The first mechanism uses the Send and Data methods, the second way uses channels. Common to both ways is the ability of the client to communicate with multiple peers using a single allocated relayed transport address; thus, both ways include a means for the client to indicate to the server which peer should receive the data, and for the server to indicate to the client which peer sent the data.",
      "ja": "クライアントとピアがターンサーバーを使用してアプリケーションデータを交換するメカニズムが2つあります。最初のメカニズムは送信方法とデータ方法を使用し、2番目の方法はチャネルを使用します。両方の方法に共通するのは、クライアントが単一の割り当てられた中継輸送アドレスを使用して複数のピアと通信する能力です。したがって、両方の方法には、クライアントがピアがデータを受信する必要があるサーバーに、およびピアがデータを送信したサーバーにクライアントに示すための手段が含まれます。"
    },
    {
      "indent": 3,
      "text": "The Send mechanism uses Send and Data indications. Send indications are used to send application data from the client to the server, while Data indications are used to send application data from the server to the client.",
      "ja": "送信メカニズムは、送信とデータの表示を使用します。送信表示は、クライアントからサーバーにアプリケーションデータを送信するために使用されますが、データ表示はサーバーからクライアントにアプリケーションデータを送信するために使用されます。"
    },
    {
      "indent": 3,
      "text": "When using the Send mechanism, the client sends a Send indication to the TURN server containing (a) an XOR-PEER-ADDRESS attribute specifying the (server-reflexive) transport address of the peer and (b) a DATA attribute holding the application data. When the TURN server receives the Send indication, it extracts the application data from the DATA attribute and sends it in a UDP datagram to the peer, using the allocated relay address as the source address. Note that there is no need to specify the relayed transport address, since it is implied by the 5-tuple used for the Send indication.",
      "ja": "送信メカニズムを使用する場合、クライアントは（a）ピアの（サーバー反射）輸送アドレスを指定するxor-peer-address属性を含むターンサーバーに送信表示を送信し、（b）アプリケーションデータを保持するデータ属性を送信します。。ターンサーバーが送信指示を受信すると、データ属性からアプリケーションデータを抽出し、udpデータグラムでそれをピアに送信し、ソースアドレスとして割り当てられたリレーアドレスを使用します。送信指示に使用される5タプルによって暗示されるため、中継輸送アドレスを指定する必要はないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "In the reverse direction, UDP datagrams arriving at the relayed transport address on the TURN server are converted into Data indications and sent to the client, with the server-reflexive transport address of the peer included in an XOR-PEER-ADDRESS attribute and the data itself in a DATA attribute. Since the relayed transport address uniquely identified the allocation, the server knows which client should receive the data.",
      "ja": "逆方向には、ターンサーバーの中継輸送アドレスに到着するUDPデータグラムは、XOR-Peer-Address属性とデータに含まれるサーバー反射性の輸送アドレスと、クライアントに送信され、クライアントに送信されます。データ属性にそれ自体。中継されたトランスポートアドレスが割り当てを一意に識別したため、サーバーはどのクライアントがデータを受信するかを知っています。"
    },
    {
      "indent": 3,
      "text": "Send and Data indications cannot be authenticated, since the long-term credential mechanism of STUN does not support authenticating indications. This is not as big an issue as it might first appear, since the client-to-server leg is only half of the total path to the peer. Applications that want proper security should encrypt the data sent between the client and a peer.",
      "ja": "STUNの長期的な資格メカニズムは認証された適応症をサポートしていないため、送信およびデータの適応症を認証することはできません。クライアントからサーバーへの脚はピアへの合計パスの半分にすぎないため、これは最初に表示されるほど大きな問題ではありません。適切なセキュリティを必要とするアプリケーションは、クライアントとピア間で送信されたデータを暗号化する必要があります。"
    },
    {
      "indent": 3,
      "text": "Because Send indications are not authenticated, it is possible for an attacker to send bogus Send indications to the server, which will then relay these to a peer. To partly mitigate this attack, TURN requires that the client install a permission towards a peer before sending data to it using a Send indication.",
      "ja": "送信指示は認証されていないため、攻撃者が偽の兆候をサーバーに送信することが可能です。この攻撃を部分的に軽減するには、ターンでは、センド表示を使用してデータを送信する前に、クライアントがピアに許可をインストールする必要があります。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |                                    |             |             |\n  |-- CreatePermission req (Peer A) -->|             |             |\n  |<-- CreatePermission success resp --|             |             |\n  |                                    |             |             |\n  |--- Send ind (Peer A)-------------->|             |             |\n  |                                    |=== data ===>|             |\n  |                                    |             |             |\n  |                                    |<== data ====|             |\n  |<-------------- Data ind (Peer A) --|             |             |\n  |                                    |             |             |\n  |                                    |             |             |\n  |--- Send ind (Peer B)-------------->|             |             |\n  |                                    | dropped     |             |\n  |                                    |             |             |\n  |                                    |<== data ==================|\n  |                            dropped |             |             |\n  |                                    |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 3",
      "ja": "図3"
    },
    {
      "indent": 3,
      "text": "In Figure 3, the client has already created an allocation and now wishes to send data to its peers. The client first creates a permission by sending the server a CreatePermission request specifying Peer A's (server-reflexive) IP address in the XOR-PEER-ADDRESS attribute; if this was not done, the server would not relay data between the client and the server. The client then sends data to Peer A using a Send indication; at the server, the application data is extracted and forwarded in a UDP datagram to Peer A, using the relayed transport address as the source transport address. When a UDP datagram from Peer A is received at the relayed transport address, the contents are placed into a Data indication and forwarded to the client. Later, the client attempts to exchange data with Peer B; however, no permission has been installed for Peer B, so the Send indication from the client and the UDP datagram from the peer are both dropped by the server.",
      "ja": "図3では、クライアントはすでに割り当てを作成しており、現在、ピアにデータを送信したいと考えています。クライアントは、XOR-Peer-Address属性にピアA（サーバー反射）IPアドレスを指定するCreatePermissionリクエストをサーバーに送信することにより、最初に許可を作成します。これが完了していない場合、サーバーはクライアントとサーバー間のデータを中継しません。次に、クライアントは送信指示を使用してピアAにデータを送信します。サーバーでは、リレー輸送アドレスをソーストランスポートアドレスとして使用して、アプリケーションデータがUDPデータグラムでピアAに転送されます。ピアAからのUDPデータグラムが中継された輸送アドレスで受信されると、内容はデータ表示に配置され、クライアントに転送されます。その後、クライアントはピアBとデータを交換しようとします。ただし、ピアBの許可はインストールされていないため、クライアントからの表示とピアからのUDPデータグラムの送信は、両方ともサーバーによって削除されます。"
    },
    {
      "indent": 0,
      "text": "2.5. Channels",
      "section_title": true,
      "ja": "2.5. チャネル"
    },
    {
      "indent": 3,
      "text": "For some applications (e.g., Voice over IP), the 36 bytes of overhead that a Send indication or Data indication adds to the application data can substantially increase the bandwidth required between the client and the server. To remedy this, TURN offers a second way for the client and server to associate data with a specific peer.",
      "ja": "一部のアプリケーション（例：Voice over IP）の場合、送信指示またはデータの表示がアプリケーションデータに追加する36バイトのオーバーヘッドは、クライアントとサーバーの間で必要な帯域幅を大幅に増加させる可能性があります。これを改善するために、ターンはクライアントとサーバーが特定のピアにデータを関連付ける2番目の方法を提供します。"
    },
    {
      "indent": 3,
      "text": "This second way uses an alternate packet format known as the ChannelData message. The ChannelData message does not use the STUN header used by other TURN messages, but instead has a 4-byte header that includes a number known as a channel number. Each channel number in use is bound to a specific peer and thus serves as a shorthand for the peer's host transport address.",
      "ja": "この2番目の方法では、ChannelDataメッセージとして知られる代替パケット形式を使用します。ChannelDataメッセージは、他のターンメッセージで使用されるスタンヘッダーを使用しませんが、代わりにチャネル番号と呼ばれる番号を含む4バイトヘッダーがあります。使用中の各チャネル番号は特定のピアにバインドされるため、ピアのホスト輸送アドレスの速記として機能します。"
    },
    {
      "indent": 3,
      "text": "To bind a channel to a peer, the client sends a ChannelBind request to the server, and includes an unbound channel number and the transport address of the peer. Once the channel is bound, the client can use a ChannelData message to send the server data destined for the peer. Similarly, the server can relay data from that peer towards the client using a ChannelData message.",
      "ja": "チャネルをピアにバインドするために、クライアントはサーバーにチャンネルバインドリクエストを送信し、ピアの非結合チャネル番号とトランスポートアドレスが含まれています。チャネルがバインドされると、クライアントはチャンネルDataメッセージを使用して、ピア用に運命づけられたサーバーデータを送信できます。同様に、サーバーは、チャンネルDataメッセージを使用して、そのピアからクライアントに向かってそのピアを中継することができます。"
    },
    {
      "indent": 3,
      "text": "Channel bindings last for 10 minutes unless refreshed -- this lifetime was chosen to be longer than the permission lifetime. Channel bindings are refreshed by sending another ChannelBind request rebinding the channel to the peer. Like permissions (but unlike allocations), there is no way to explicitly delete a channel binding; the client must simply wait for it to time out.",
      "ja": "チャネルバインディングは、更新されない限り10分間続きます - この寿命は、許可の寿命よりも長くなるように選択されました。チャネルバインディングは、チャンネルをピアにリバインする別のチャンネルバインドリクエストを送信することで更新されます。許可（ただし、割り当てとは異なり）と同様に、チャネルバインディングを明示的に削除する方法はありません。クライアントは、単にタイムアウトを待つ必要があります。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |                                    |             |             |\n  |-- ChannelBind req ---------------->|             |             |\n  | (Peer A to 0x4001)                 |             |             |\n  |                                    |             |             |\n  |<---------- ChannelBind succ resp --|             |             |\n  |                                    |             |             |\n  |-- [0x4001] data ------------------>|             |             |\n  |                                    |=== data ===>|             |\n  |                                    |             |             |\n  |                                    |<== data ====|             |\n  |<------------------ [0x4001] data --|             |             |\n  |                                    |             |             |\n  |--- Send ind (Peer A)-------------->|             |             |\n  |                                    |=== data ===>|             |\n  |                                    |             |             |\n  |                                    |<== data ====|             |\n  |<------------------ [0x4001] data --|             |             |\n  |                                    |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Figure 4",
      "ja": "図4"
    },
    {
      "indent": 3,
      "text": "Figure 4 shows the channel mechanism in use. The client has already created an allocation and now wishes to bind a channel to Peer A. To do this, the client sends a ChannelBind request to the server, specifying the transport address of Peer A and a channel number (0x4001). After that, the client can send application data encapsulated inside ChannelData messages to Peer A: this is shown as",
      "ja": "図4は、使用中のチャネルメカニズムを示しています。クライアントはすでに割り当てを作成しており、チャネルをピアAにバインドしたいと考えています。これを行うために、クライアントはピアAのトランスポートアドレスとチャネル番号（0x4001）を指定して、サーバーにチャンネルバインド要求を送信します。その後、クライアントはピアAにチャンネルDataメッセージ内部のカプセル化されたアプリケーションデータを送信できます：これは次のように表示されます"
    },
    {
      "indent": 3,
      "text": "\"[0x4001] data\" where 0x4001 is the channel number. When the ChannelData message arrives at the server, the server transfers the data to a UDP datagram and sends it to Peer A (which is the peer bound to channel number 0x4001).",
      "ja": "「[0x4001]データ」ここで、0x4001はチャネル番号です。ChannelDataメッセージがサーバーに到着すると、サーバーはデータをUDPデータグラムに転送し、ピアA（チャネル番号0x4001にチャネルバインドされたピア）に送信します。"
    },
    {
      "indent": 3,
      "text": "In the reverse direction, when Peer A sends a UDP datagram to the relayed transport address, this UDP datagram arrives at the server on the relayed transport address assigned to the allocation. Since the UDP datagram was received from Peer A, which has a channel number assigned to it, the server encapsulates the data into a ChannelData message when sending the data to the client.",
      "ja": "逆方向に、ピアAがUDPデータグラムをリレー輸送アドレスに送信すると、このUDPデータグラムは、割り当てに割り当てられたリレー輸送アドレスのサーバーに到着します。UDPデータグラムは、チャネル番号が割り当てられているPeer Aから受信されたため、サーバーはデータをクライアントに送信するときにデータをChannelDataメッセージにカプセル化します。"
    },
    {
      "indent": 3,
      "text": "Once a channel has been bound, the client is free to intermix ChannelData messages and Send indications. In the figure, the client later decides to use a Send indication rather than a ChannelData message to send additional data to Peer A. The client might decide to do this, for example, so it can use the DONT-FRAGMENT attribute (see the next section). However, once a channel is bound, the server will always use a ChannelData message, as shown in the call flow.",
      "ja": "チャネルがバインドされると、クライアントは自由にチャンネルデータをインターミックスして表示し、表示を送信できます。図では、クライアントは後にチャンネルDataメッセージではなく送信表示を使用してピアAに追加データを送信することを決定します。たとえば、クライアントはこれを行うことを決定する可能性があります。セクション）。ただし、チャネルがバインドされると、サーバーはコールフローに示されているように、常にチャンネルDataメッセージを使用します。"
    },
    {
      "indent": 3,
      "text": "Note that ChannelData messages can only be used for peers to which the client has bound a channel. In the example above, Peer A has been bound to a channel, but Peer B has not, so application data to and from Peer B would use the Send mechanism.",
      "ja": "ChannelDataメッセージは、クライアントがチャネルをバインドするピアにのみ使用できることに注意してください。上記の例では、ピアAはチャネルにバインドされていますが、ピアBにはそうではないため、ピアBとのアプリケーションデータは送信メカニズムを使用します。"
    },
    {
      "indent": 0,
      "text": "2.6. Unprivileged TURN Servers",
      "section_title": true,
      "ja": "2.6. 普及していないターンサーバー"
    },
    {
      "indent": 3,
      "text": "This version of TURN is designed so that the server can be implemented as an application that runs in user space under commonly available operating systems without requiring special privileges. This design decision was made to make it easy to deploy a TURN server: for example, to allow a TURN server to be integrated into a peer-to-peer application so that one peer can offer NAT traversal services to another peer.",
      "ja": "このバージョンのターンは、特別な特権を必要とせずに一般的に利用可能なオペレーティングシステムの下でユーザースペースで実行されるアプリケーションとしてサーバーを実装できるように設計されています。この設計上の決定は、ターンサーバーの展開を容易にするために行われました。たとえば、ターンサーバーをピアツーピアアプリケーションに統合して、あるピアがNATトラバーサルサービスを別のピアに提供できるようにします。"
    },
    {
      "indent": 3,
      "text": "This design decision has the following implications for data relayed by a TURN server:",
      "ja": "この設計上の決定には、ターンサーバーによって中継されるデータに次の意味があります。"
    },
    {
      "indent": 3,
      "text": "o The value of the Diffserv field may not be preserved across the server;",
      "ja": "o DiffServフィールドの値は、サーバー全体に保存されない場合があります。"
    },
    {
      "indent": 3,
      "text": "o The Time to Live (TTL) field may be reset, rather than decremented, across the server;",
      "ja": "o ライブ（TTL）フィールドは、サーバー全体で減少するのではなく、リセットされる場合があります。"
    },
    {
      "indent": 3,
      "text": "o The Explicit Congestion Notification (ECN) field may be reset by the server;",
      "ja": "o 明示的な混雑通知（ECN）フィールドは、サーバーによってリセットされる場合があります。"
    },
    {
      "indent": 3,
      "text": "o ICMP messages are not relayed by the server;",
      "ja": "o ICMPメッセージはサーバーによって中継されません。"
    },
    {
      "indent": 3,
      "text": "o There is no end-to-end fragmentation, since the packet is re-assembled at the server.",
      "ja": "o パケットがサーバーで再組み立てされているため、エンドツーエンドの断片化はありません。"
    },
    {
      "indent": 3,
      "text": "Future work may specify alternate TURN semantics that address these limitations.",
      "ja": "将来の作業は、これらの制限に対処する代替ターンセマンティクスを指定する場合があります。"
    },
    {
      "indent": 0,
      "text": "2.7. Avoiding IP Fragmentation",
      "section_title": true,
      "ja": "2.7. IPの断片化を回避します"
    },
    {
      "indent": 3,
      "text": "For reasons described in [Frag-Harmful], applications, especially those sending large volumes of data, should try hard to avoid having their packets fragmented. Applications using TCP can more or less ignore this issue because fragmentation avoidance is now a standard part of TCP, but applications using UDP (and thus any application using this version of TURN) must handle fragmentation avoidance themselves.",
      "ja": "[Frag-Harmful]に記載されている理由により、アプリケーション、特に大量のデータを送信するアプリケーションは、パケットを断片化することを避けるために一生懸命努力する必要があります。TCPを使用したアプリケーションは、断片化回避がTCPの標準部分になっているため、多かれ少なかれこの問題を無視できますが、UDPを使用するアプリケーション（したがって、このバージョンのターンを使用するアプリケーション）は、断片化回避自体を処理する必要があります。"
    },
    {
      "indent": 3,
      "text": "The application running on the client and the peer can take one of two approaches to avoid IP fragmentation.",
      "ja": "クライアントとピアで実行されているアプリケーションは、IPの断片化を回避するために2つのアプローチのいずれかをとることができます。"
    },
    {
      "indent": 3,
      "text": "The first approach is to avoid sending large amounts of application data in the TURN messages/UDP datagrams exchanged between the client and the peer. This is the approach taken by most VoIP (Voice-over-IP) applications. In this approach, the application exploits the fact that the IP specification [RFC0791] specifies that IP packets up to 576 bytes should never need to be fragmented.",
      "ja": "最初のアプローチは、クライアントとピアの間で交換されるターンメッセージ/UDPデータグラムに大量のアプリケーションデータを送信しないようにすることです。これは、ほとんどのVoIP（Voice-Over-IP）アプリケーションが取得したアプローチです。このアプローチでは、アプリケーションは、IP仕様[RFC0791]が576バイトまでのIPパケットを断片化する必要はないことを指定するという事実を活用しています。"
    },
    {
      "indent": 3,
      "text": "The exact amount of application data that can be included while avoiding fragmentation depends on the details of the TURN session between the client and the server: whether UDP, TCP, or TLS transport is used, whether ChannelData messages or Send/Data indications are used, and whether any additional attributes (such as the DONT-FRAGMENT attribute) are included. Another factor, which is hard to determine, is whether the MTU is reduced somewhere along the path for other reasons, such as the use of IP-in-IP tunneling.",
      "ja": "断片化を回避しながら含めることができるアプリケーションデータの正確な量は、クライアントとサーバー間のターンセッションの詳細に依存します。UDP、TCP、またはTLSトランスポートが使用されているかどうか、ChannelDataメッセージまたは送信/データ表示が使用されるかどうか、また、追加の属性（dont-fragment属性など）が含まれているかどうか。判断するのが難しいもう1つの要因は、IP-in-IPトンネリングの使用など、他の理由でMTUがパスに沿ってどこかに減少しているかどうかです。"
    },
    {
      "indent": 3,
      "text": "As a guideline, sending a maximum of 500 bytes of application data in a single TURN message (by the client on the client-to-server leg) or a UDP datagram (by the peer on the peer-to-server leg) will generally avoid IP fragmentation. To further reduce the chance of fragmentation, it is recommended that the client use ChannelData messages when transferring significant volumes of data, since the overhead of the ChannelData message is less than Send and Data indications.",
      "ja": "ガイドラインとして、単一のターンメッセージ（クライアントからサーバーへの脚のクライアントによる）またはUDPデータグラム（ピアツーサーバーレッグのピアによる）で最大500バイトのアプリケーションデータを送信します。IPの断片化を避けてください。断片化の可能性をさらに減らすために、ChannelDataメッセージのオーバーヘッドは送信やデータの表示よりも少ないため、かなりの量のデータを転送するときにチャネルDataメッセージを使用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The second approach the client and peer can take to avoid fragmentation is to use a path MTU discovery algorithm to determine the maximum amount of application data that can be sent without fragmentation.",
      "ja": "クライアントとピアが断片化を回避するために取ることができる2番目のアプローチは、パスMTUディスカバリーアルゴリズムを使用して、断片化なしで送信できるアプリケーションデータの最大量を決定することです。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, because servers implementing this version of TURN do not relay ICMP messages, the classic path MTU discovery algorithm defined in [RFC1191] is not able to discover the MTU of the transmission path between the client and the peer. (Even if they did relay ICMP messages, the algorithm would not always work since ICMP messages are often filtered out by combined NAT/firewall devices).",
      "ja": "残念ながら、このバージョンのターンを実装するサーバーはICMPメッセージをリレーしないため、[RFC1191]で定義されているクラシックパスMTUディスカバリーアルゴリズムは、クライアントとピアの間の送信パスのMTUを発見することはできません。（ICMPメッセージを中継したとしても、ICMPメッセージはしばしばNAT/ファイアウォールデバイスを組み合わせてフィルタリングすることが多いため、アルゴリズムは常に機能するとは限りません）。"
    },
    {
      "indent": 3,
      "text": "So the client and server need to use a path MTU discovery algorithm that does not require ICMP messages. The Packetized Path MTU Discovery algorithm defined in [RFC4821] is one such algorithm.",
      "ja": "そのため、クライアントとサーバーは、ICMPメッセージを必要としないPATH MTU Discoveryアルゴリズムを使用する必要があります。[RFC4821]で定義されているパケットパスMTUディスカバリーアルゴリズムは、そのようなアルゴリズムの1つです。"
    },
    {
      "indent": 3,
      "text": "The details of how to use the algorithm of [RFC4821] with TURN are still under investigation. However, as a step towards this goal, this version of TURN supports a DONT-FRAGMENT attribute. When the client includes this attribute in a Send indication, this tells the server to set the DF bit in the resulting UDP datagram that it sends to the peer. Since some servers may be unable to set the DF bit, the client should also include this attribute in the Allocate request -- any server that does not support the DONT-FRAGMENT attribute will indicate this by rejecting the Allocate request.",
      "ja": "[RFC4821]のアルゴリズムを使用する方法の詳細は、まだ調査中です。ただし、この目標への一歩として、このバージョンのTurnは、fragment属性の属性をサポートしています。クライアントが送信指示にこの属性を含めると、これはサーバーに、ピアに送信する結果のUDPデータグラムにDFビットを設定するように指示します。一部のサーバーではDFビットを設定できない場合があるため、クライアントはこの属性を割り当て要求に含める必要があります。Dont-Fragment属性をサポートしていないサーバーは、割り当てリクエストを拒否することによりこれを示します。"
    },
    {
      "indent": 0,
      "text": "2.8. RTP Support",
      "section_title": true,
      "ja": "2.8. RTPサポート"
    },
    {
      "indent": 3,
      "text": "One of the envisioned uses of TURN is as a relay for clients and peers wishing to exchange real-time data (e.g., voice or video) using RTP. To facilitate the use of TURN for this purpose, TURN includes some special support for older versions of RTP.",
      "ja": "ターンの想定されている使用の1つは、RTPを使用してリアルタイムデータ（音声やビデオなど）を交換したいクライアントとピアのリレーとしてです。この目的のためのターンの使用を容易にするために、ターンにはRTPの古いバージョンの特別なサポートが含まれています。"
    },
    {
      "indent": 3,
      "text": "Old versions of RTP [RFC3550] required that the RTP stream be on an even port number and the associated RTP Control Protocol (RTCP) stream, if present, be on the next highest port. To allow clients to work with peers that still require this, TURN allows the client to request that the server allocate a relayed transport address with an even port number, and to optionally request the server reserve the next-highest port number for a subsequent allocation.",
      "ja": "RTP [RFC3550]の古いバージョンは、RTPストリームが均等なポート番号にあることを要求し、関連するRTP制御プロトコル（RTCP）ストリームが存在する場合は、次の最高ポートにあることを要求しました。クライアントがこれを必要とするピアと一緒に作業できるようにするために、ターンすると、クライアントはサーバーが均等なポート番号で中継のトランスポートアドレスを割り当てるように要求し、オプションでサーバーが次の割り当てのために次の高いポート番号を予約することをオプションで要求することができます。"
    },
    {
      "indent": 0,
      "text": "2.9. Anycast Discovery of Servers",
      "section_title": true,
      "ja": "2.9. サーバーのエイキャストの発見"
    },
    {
      "indent": 3,
      "text": "This version of TURN has been designed to permit the future specification of a method of doing anycast discovery of a TURN server over UDP.",
      "ja": "このバージョンのターンは、UDPを介したターンサーバーのAnycast Discoveryを実行する方法の将来の仕様を許可するように設計されています。"
    },
    {
      "indent": 3,
      "text": "Specifically, a TURN server can reject an Allocate request with the suggestion that the client try an alternate server. To avoid certain types of attacks, the client must use the same credentials with the alternate server as it would have with the initial server.",
      "ja": "具体的には、ターンサーバーは、クライアントが代替サーバーを試すという提案を使用して、割り当て要求を拒否できます。特定の種類の攻撃を回避するには、クライアントは、初期サーバーと同じように、代替サーバーで同じ資格情報を使用する必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 3,
      "text": "Readers are expected to be familiar with [RFC5389] and the terms defined there.",
      "ja": "読者は[RFC5389]とそこで定義されている用語に精通していることが期待されています。"
    },
    {
      "indent": 3,
      "text": "The following terms are used in this document:",
      "ja": "このドキュメントでは、次の用語が使用されています。"
    },
    {
      "indent": 3,
      "text": "TURN: The protocol spoken between a TURN client and a TURN server. It is an extension to the STUN protocol [RFC5389]. The protocol allows a client to allocate and use a relayed transport address.",
      "ja": "ターン：ターンクライアントとターンサーバーの間で話されるプロトコル。これは、STUNプロトコル[RFC5389]の拡張です。このプロトコルにより、クライアントは中継輸送アドレスを割り当てて使用できます。"
    },
    {
      "indent": 3,
      "text": "TURN client: A STUN client that implements this specification.",
      "ja": "クライアントをターン：この仕様を実装するスタンクライアント。"
    },
    {
      "indent": 3,
      "text": "TURN server: A STUN server that implements this specification. It relays data between a TURN client and its peer(s).",
      "ja": "サーバーターン：この仕様を実装するスタンサーバー。ターンクライアントとそのピアの間でデータを中継します。"
    },
    {
      "indent": 3,
      "text": "Peer: A host with which the TURN client wishes to communicate. The TURN server relays traffic between the TURN client and its peer(s). The peer does not interact with the TURN server using the protocol defined in this document; rather, the peer receives data sent by the TURN server and the peer sends data towards the TURN server.",
      "ja": "ピア：ターンクライアントが通信したいホスト。ターンサーバーは、ターンクライアントとそのピアの間のトラフィックを中心にします。ピアは、このドキュメントで定義されているプロトコルを使用して、ターンサーバーと対話しません。むしろ、ピアはターンサーバーから送信されたデータを受信し、ピアはターンサーバーにデータを送信します。"
    },
    {
      "indent": 3,
      "text": "Transport Address: The combination of an IP address and a port.",
      "ja": "トランスポートアドレス：IPアドレスとポートの組み合わせ。"
    },
    {
      "indent": 3,
      "text": "Host Transport Address: A transport address on a client or a peer.",
      "ja": "ホスト輸送住所：クライアントまたはピアの輸送住所。"
    },
    {
      "indent": 3,
      "text": "Server-Reflexive Transport Address: A transport address on the \"public side\" of a NAT. This address is allocated by the NAT to correspond to a specific host transport address.",
      "ja": "サーバー反射輸送アドレス：NATの「パブリック側」の輸送アドレス。このアドレスは、特定のホスト輸送アドレスに対応するためにNATによって割り当てられます。"
    },
    {
      "indent": 3,
      "text": "Relayed Transport Address: A transport address on the TURN server that is used for relaying packets between the client and a peer. A peer sends to this address on the TURN server, and the packet is then relayed to the client.",
      "ja": "中継輸送住所：クライアントとピア間のパケットを中継するために使用されるターンサーバー上のトランスポートアドレス。ピアがターンサーバー上のこのアドレスに送信し、パケットがクライアントに中継されます。"
    },
    {
      "indent": 3,
      "text": "TURN Server Transport Address: A transport address on the TURN server that is used for sending TURN messages to the server. This is the transport address that the client uses to communicate with the server.",
      "ja": "ターンサーバートランスポートアドレス：ターンメッセージをサーバーに送信するために使用されるターンサーバーのトランスポートアドレス。これは、クライアントがサーバーと通信するために使用するトランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "Peer Transport Address: The transport address of the peer as seen by the server. When the peer is behind a NAT, this is the peer's server-reflexive transport address.",
      "ja": "ピアトランスポートアドレス：サーバーで見られるピアの輸送アドレス。ピアがNATの背後にいるとき、これはピアのサーバー反射トランスポートアドレスです。"
    },
    {
      "indent": 3,
      "text": "Allocation: The relayed transport address granted to a client through an Allocate request, along with related state, such as permissions and expiration timers.",
      "ja": "割り当て：許可や有効期限タイマーなどの関連状態とともに、割り当て要求を通じてクライアントに付与された中継輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "5-tuple: The combination (client IP address and port, server IP address and port, and transport protocol (currently one of UDP, TCP, or TLS)) used to communicate between the client and the server. The 5-tuple uniquely identifies this communication stream. The 5-tuple also uniquely identifies the Allocation on the server.",
      "ja": "5タプル：クライアントとサーバー間の通信に使用される組み合わせ（クライアントIPアドレスとポート、サーバーIPアドレスとポート、およびトランスポートプロトコル（現在UDP、TCP、またはTLSの1つ））。5タプルは、この通信ストリームを独自に識別します。5タプルはまた、サーバー上の割り当てを一意に識別します。"
    },
    {
      "indent": 3,
      "text": "Channel: A channel number and associated peer transport address. Once a channel number is bound to a peer's transport address, the client and server can use the more bandwidth-efficient ChannelData message to exchange data.",
      "ja": "チャネル：チャネル番号と関連するピア輸送アドレス。チャネル番号がピアのトランスポートアドレスにバインドされると、クライアントとサーバーは、より帯域幅効率の高いChannelDataメッセージを使用してデータを交換できます。"
    },
    {
      "indent": 3,
      "text": "Permission: The IP address and transport protocol (but not the port) of a peer that is permitted to send traffic to the TURN server and have that traffic relayed to the TURN client. The TURN server will only forward traffic to its client from peers that match an existing permission.",
      "ja": "許可：トラフィックをターンサーバーに送信し、そのトラフィックをターンクライアントに中継することが許可されているピアのIPアドレスとトランスポートプロトコル（ただし、ポートではありません）。ターンサーバーは、既存の許可と一致するピアからクライアントにトラフィックを転送するだけです。"
    },
    {
      "indent": 3,
      "text": "Realm: A string used to describe the server or a context within the server. The realm tells the client which username and password combination to use to authenticate requests.",
      "ja": "レルム：サーバー内のサーバーまたはコンテキストを記述するために使用される文字列。領域は、リクエストを認証するために使用するユーザー名とパスワードの組み合わせをクライアントに伝えます。"
    },
    {
      "indent": 3,
      "text": "Nonce: A string chosen at random by the server and included in the message-digest. To prevent reply attacks, the server should change the nonce regularly.",
      "ja": "NONCE：サーバーによってランダムに選択され、メッセージダイジストに含まれている文字列。返信攻撃を防ぐために、サーバーは定期的にノンセを変更する必要があります。"
    },
    {
      "indent": 0,
      "text": "4. General Behavior",
      "section_title": true,
      "ja": "4. 一般的な行動"
    },
    {
      "indent": 3,
      "text": "This section contains general TURN processing rules that apply to all TURN messages.",
      "ja": "このセクションには、すべてのターンメッセージに適用される一般的なターン処理ルールが含まれています。"
    },
    {
      "indent": 3,
      "text": "TURN is an extension to STUN. All TURN messages, with the exception of the ChannelData message, are STUN-formatted messages. All the base processing rules described in [RFC5389] apply to STUN-formatted messages. This means that all the message-forming and message-processing descriptions in this document are implicitly prefixed with the rules of [RFC5389].",
      "ja": "ターンはスタンの拡張機能です。すべてのターンメッセージは、チャンネルDataメッセージを除き、スタンフォーマットメッセージです。[RFC5389]で説明されているすべての基本処理ルールは、スタンフォーマットメッセージに適用されます。これは、このドキュメントのすべてのメッセージ形成とメッセージ処理の説明に、[RFC5389]のルールが暗黙的に前に付けられていることを意味します。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] specifies an authentication mechanism called the long-term credential mechanism. TURN servers and clients MUST implement this mechanism. The server MUST demand that all requests from the client be authenticated using this mechanism, or that a equally strong or stronger mechanism for client authentication is used.",
      "ja": "[RFC5389]は、長期の資格情報メカニズムと呼ばれる認証メカニズムを指定します。サーバーとクライアントのターンは、このメカニズムを実装する必要があります。サーバーは、クライアントからのすべての要求をこのメカニズムを使用して認証すること、またはクライアント認証のための同様に強力または強力なメカニズムを使用することを要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that the long-term credential mechanism applies only to requests and cannot be used to authenticate indications; thus, indications in TURN are never authenticated. If the server requires requests to be authenticated, then the server's administrator MUST choose a realm value that will uniquely identify the username and password combination that the client must use, even if the client uses multiple servers under different administrations. The server's administrator MAY choose to allocate a unique username to each client, or MAY choose to allocate the same username to more than one client (for example, to all clients from the same department or company). For each allocation, the server SHOULD generate a new random nonce when the allocation is first attempted following the randomness recommendations in [RFC4086] and SHOULD expire the nonce at least once every hour during the lifetime of the allocation.",
      "ja": "長期的な資格メカニズムはリクエストにのみ適用され、適応症を認証するために使用できないことに注意してください。したがって、適応症は決して認証されません。サーバーがリクエストを認証する必要がある場合、サーバーの管理者は、クライアントが異なる管理下で複数のサーバーを使用していても、クライアントが使用する必要があるユーザー名とパスワードの組み合わせを一意に識別するレルム値を選択する必要があります。サーバーの管理者は、各クライアントに一意のユーザー名を割り当てることを選択するか、同じユーザー名を複数のクライアント（たとえば、同じ部門または会社のすべてのクライアントに）を割り当てることを選択できます。各割り当てについて、[RFC4086]のランダム性推奨事項に従って割り当てが最初に試行されたときに、サーバーは新しいランダムNonCEを生成する必要があり、割り当ての生涯に少なくとも1回はNonCeを期限切れにする必要があります。"
    },
    {
      "indent": 3,
      "text": "All requests after the initial Allocate must use the same username as that used to create the allocation, to prevent attackers from hijacking the client's allocation. Specifically, if the server requires the use of the long-term credential mechanism, and if a non-Allocate request passes authentication under this mechanism, and if the 5-tuple identifies an existing allocation, but the request does not use the same username as used to create the allocation, then the request MUST be rejected with a 441 (Wrong Credentials) error.",
      "ja": "最初の割り当て後のすべての要求は、攻撃者がクライアントの割り当てをハイジャックするのを防ぐために、割り当てを作成するために使用したものと同じユーザー名を使用する必要があります。具体的には、サーバーが長期的な資格メカニズムの使用を必要とする場合、および非アロケート要求がこのメカニズムの下で認証を渡す場合、および5タプルが既存の割り当てを識別する場合、リクエストは同じユーザー名を使用しません割り当ての作成に使用すると、リクエストは441（間違った資格情報）エラーで拒否される必要があります。"
    },
    {
      "indent": 3,
      "text": "When a TURN message arrives at the server from the client, the server uses the 5-tuple in the message to identify the associated allocation. For all TURN messages (including ChannelData) EXCEPT an Allocate request, if the 5-tuple does not identify an existing allocation, then the message MUST either be rejected with a 437 Allocation Mismatch error (if it is a request) or silently ignored (if it is an indication or a ChannelData message). A client receiving a 437 error response to a request other than Allocate MUST assume the allocation no longer exists.",
      "ja": "ターンメッセージがクライアントからサーバーに到着すると、サーバーはメッセージの5タプルを使用して、関連する割り当てを識別します。割り当てリクエストを除くすべてのターンメッセージ（ChannelDataを含む）の場合、5タプルが既存の割り当てを識別しない場合、メッセージは437割り当ての不一致エラー（リクエストの場合）で拒否されるか、静かに無視する必要があります（場合）これは、兆候またはチャネルデータです）。割り当て以外のリクエストに対する437エラー応答を受信したクライアントは、割り当てが存在しなくなったと想定する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] defines a number of attributes, including the SOFTWARE and FINGERPRINT attributes. The client SHOULD include the SOFTWARE attribute in all Allocate and Refresh requests and MAY include it in any other requests or indications. The server SHOULD include the SOFTWARE attribute in all Allocate and Refresh responses (either success or failure) and MAY include it in other responses or indications. The client and the server MAY include the FINGERPRINT attribute in any STUN-formatted messages defined in this document.",
      "ja": "[RFC5389]は、ソフトウェアや指紋属性を含む多くの属性を定義します。クライアントは、すべての割り当ておよび更新リクエストにソフトウェア属性を含める必要があり、他のリクエストまたは表示にそれを含めることができます。サーバーには、すべての割り当ておよび更新応答（成功または失敗）にソフトウェア属性を含める必要があり、他の応答または適応症にそれを含めることができます。クライアントとサーバーには、このドキュメントで定義されているスタンフォーマットメッセージに指紋属性を含めることができます。"
    },
    {
      "indent": 3,
      "text": "TURN does not use the backwards-compatibility mechanism described in [RFC5389].",
      "ja": "ターンは[RFC5389]で説明されている後方互換性メカニズムを使用しません。"
    },
    {
      "indent": 3,
      "text": "TURN, as defined in this specification, only supports IPv4. The client's IP address, the server's IP address, and all IP addresses appearing in a relayed transport address MUST be IPv4 addresses.",
      "ja": "この仕様で定義されているように、ターンはIPv4のみをサポートします。クライアントのIPアドレス、サーバーのIPアドレス、およびリレー輸送アドレスに表示されるすべてのIPアドレスは、IPv4アドレスでなければなりません。"
    },
    {
      "indent": 3,
      "text": "By default, TURN runs on the same ports as STUN: 3478 for TURN over UDP and TCP, and 5349 for TURN over TLS. However, TURN has its own set of Service Record (SRV) names: \"turn\" for UDP and TCP, and \"turns\" for TLS. Either the SRV procedures or the ALTERNATE-SERVER procedures, both described in Section 6, can be used to run TURN on a different port.",
      "ja": "デフォルトでは、ターンはUDPとTCPをターンするために3478、TLSをターンする場合は5349と同じポートで実行されます。ただし、ターンには独自のサービスレコード（SRV）の名前があります：UDPおよびTCPの「ターン」、TLSの「ターン」。どちらもセクション6で説明されているSRV手順または代替サーバー手順のいずれかを使用して、別のポートをオンにすることができます。"
    },
    {
      "indent": 3,
      "text": "To ensure interoperability, a TURN server MUST support the use of UDP transport between the client and the server, and SHOULD support the use of TCP and TLS transport.",
      "ja": "相互運用性を確保するために、ターンサーバーはクライアントとサーバー間のUDPトランスポートの使用をサポートする必要があり、TCPおよびTLSトランスポートの使用をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When UDP transport is used between the client and the server, the client will retransmit a request if it does not receive a response within a certain timeout period. Because of this, the server may receive two (or more) requests with the same 5-tuple and same transaction id. STUN requires that the server recognize this case and treat the request as idempotent (see [RFC5389]). Some implementations may choose to meet this requirement by remembering all received requests and the corresponding responses for 40 seconds. Other implementations may choose to reprocess the request and arrange that such reprocessing returns essentially the same response. To aid implementors who choose the latter approach (the so-called \"stateless stack approach\"), this specification includes some implementation notes on how this might be done. Implementations are free to choose either approach or choose some other approach that gives the same results.",
      "ja": "クライアントとサーバーの間でUDPトランスポートが使用されると、クライアントは特定のタイムアウト期間内に応答を受信しない場合、リクエストを再送信します。このため、サーバーは、同じ5タプルと同じトランザクションIDで2つ（またはそれ以上）リクエストを受信する場合があります。STUNは、サーバーがこのケースを認識し、要求をiDEMPOTENTとして扱うことを要求します（[RFC5389]を参照）。一部の実装では、受信したすべてのリクエストと対応する応答を40秒間記憶することにより、この要件を満たすことを選択する場合があります。他の実装は、要求を再処理し、そのような再処理が本質的に同じ応答を返すことを手配することを選択する場合があります。後者のアプローチ（いわゆる「ステートレススタックアプローチ」）を選択する実装者を支援するために、この仕様には、これがどのように行われるかに関するいくつかの実装ノートが含まれています。実装は、アプローチを選択するか、同じ結果をもたらす他のアプローチを選択することができます。"
    },
    {
      "indent": 3,
      "text": "When TCP transport is used between the client and the server, it is possible that a bit error will cause a length field in a TURN packet to become corrupted, causing the receiver to lose synchronization with the incoming stream of TURN messages. A client or server that detects a long sequence of invalid TURN messages over TCP transport SHOULD close the corresponding TCP connection to help the other end detect this situation more rapidly.",
      "ja": "クライアントとサーバーの間でTCPトランスポートを使用すると、少しエラーが発生すると、ターンパケットの長さフィールドが破損する可能性があり、受信機はターンメッセージの入っているストリームと同期を失います。TCPトランスポートを介した無効なターンメッセージの長いシーケンスを検出するクライアントまたはサーバーは、対応するTCP接続を閉じて、他の端がこの状況をより迅速に検出できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "To mitigate either intentional or unintentional denial-of-service attacks against the server by clients with valid usernames and passwords, it is RECOMMENDED that the server impose limits on both the number of allocations active at one time for a given username and on the amount of bandwidth those allocations can use. The server should reject new allocations that would exceed the limit on the allowed number of allocations active at one time with a 486 (Allocation Quota Exceeded) (see Section 6.2), and should discard application data traffic that exceeds the bandwidth quota.",
      "ja": "有効なユーザー名とパスワードを備えたクライアントによるサーバーに対する意図的または意図的ではないサービス拒否攻撃のいずれかを緩和するには、サーバーが特定のユーザー名に対して一度にアクティブな割り当ての数との両方に制限を課すことをお勧めします。これらの割り当てが使用できる帯域幅。サーバーは、486（割り当てクォータを超えた）で一度にアクティブな割り当ての許可数の制限を超える新しい割り当てを拒否する必要があります（セクション6.2を参照）。"
    },
    {
      "indent": 0,
      "text": "5. Allocations",
      "section_title": true,
      "ja": "5. 割り当て"
    },
    {
      "indent": 3,
      "text": "All TURN operations revolve around allocations, and all TURN messages are associated with an allocation. An allocation conceptually consists of the following state data:",
      "ja": "すべてのターン操作は割り当てを中心に展開し、すべてのターンメッセージは割り当てに関連付けられています。割り当ては、概念的に次の状態データで構成されています。"
    },
    {
      "indent": 3,
      "text": "o the relayed transport address;",
      "ja": "o 中継輸送アドレス。"
    },
    {
      "indent": 3,
      "text": "o the 5-tuple: (client's IP address, client's port, server IP address, server port, transport protocol);",
      "ja": "o 5タプル：（クライアントのIPアドレス、クライアントのポート、サーバーIPアドレス、サーバーポート、トランスポートプロトコル）;"
    },
    {
      "indent": 3,
      "text": "o the authentication information;",
      "ja": "o 認証情報;"
    },
    {
      "indent": 3,
      "text": "o the time-to-expiry;",
      "ja": "o expiryまでの時間。"
    },
    {
      "indent": 3,
      "text": "o a list of permissions;",
      "ja": "o 権限のリスト。"
    },
    {
      "indent": 3,
      "text": "o a list of channel to peer bindings.",
      "ja": "o ピアバインディングへのチャネルのリスト。"
    },
    {
      "indent": 3,
      "text": "The relayed transport address is the transport address allocated by the server for communicating with peers, while the 5-tuple describes the communication path between the client and the server. On the client, the 5-tuple uses the client's host transport address; on the server, the 5-tuple uses the client's server-reflexive transport address.",
      "ja": "中継されたトランスポートアドレスは、ピアと通信するためにサーバーによって割り当てられた輸送アドレスであり、5タプルはクライアントとサーバーの間の通信パスを説明します。クライアントでは、5タプルはクライアントのホストトランスポートアドレスを使用します。サーバーでは、5タプルがクライアントのサーバー反射トランスタップアドレスを使用します。"
    },
    {
      "indent": 3,
      "text": "Both the relayed transport address and the 5-tuple MUST be unique across all allocations, so either one can be used to uniquely identify the allocation.",
      "ja": "リレー輸送アドレスと5タプルの両方がすべての割り当てにわたって一意でなければならないため、いずれかを使用して割り当てを一意に識別することができます。"
    },
    {
      "indent": 3,
      "text": "The authentication information (e.g., username, password, realm, and nonce) is used to both verify subsequent requests and to compute the message integrity of responses. The username, realm, and nonce values are initially those used in the authenticated Allocate request that creates the allocation, though the server can change the nonce value during the lifetime of the allocation using a 438 (Stale Nonce) reply. Note that, rather than storing the password explicitly, for security reasons, it may be desirable for the server to store the key value, which is an MD5 hash over the username, realm, and password (see [RFC5389]).",
      "ja": "認証情報（ユーザー名、パスワード、レルム、ノンセなど）は、後続の要求を検証し、応答のメッセージの整合性を計算するために使用されます。ユーザー名、レルム、およびNonCE値は、最初に認証された割り当て要求で使用されたものであり、割り当てを作成するものですが、サーバーは438（古い非CE）応答を使用して割り当ての寿命の間にNonCE値を変更できます。パスワードを明示的に保存するのではなく、セキュリティ上の理由で、サーバーがユーザー名、領域、パスワードにMD5ハッシュであるキー値を保存することが望ましい場合があることに注意してください（[RFC5389]を参照）。"
    },
    {
      "indent": 3,
      "text": "The time-to-expiry is the time in seconds left until the allocation expires. Each Allocate or Refresh transaction sets this timer, which then ticks down towards 0. By default, each Allocate or Refresh transaction resets this timer to the default lifetime value of 600 seconds (10 minutes), but the client can request a different value in the Allocate and Refresh request. Allocations can only be refreshed using the Refresh request; sending data to a peer does not refresh an allocation. When an allocation expires, the state data associated with the allocation can be freed.",
      "ja": "卓越した時間は、割り当てが期限切れになるまで、残りの数秒の時間です。各トランザクションを割り当てる各リフレッシュこのタイマーは0にチェックダウンします。デフォルトでは、各トランザクションを割り当てたり更新したりする各トランザクションは、このタイマーをデフォルトのライフタイム値の600秒（10分）にリセットしますが、クライアントは異なる値を要求できます。リクエストを割り当てて更新します。割り当ては、更新リクエストを使用してのみ更新できます。ピアにデータを送信しても、割り当ては更新されません。割り当ての有効期限が切れると、割り当てに関連する状態データが解放されます。"
    },
    {
      "indent": 3,
      "text": "The list of permissions is described in Section 8 and the list of channels is described in Section 11.",
      "ja": "権限のリストはセクション8で説明されており、チャネルのリストはセクション11で説明されています。"
    },
    {
      "indent": 0,
      "text": "6. Creating an Allocation",
      "section_title": true,
      "ja": "6. 割り当ての作成"
    },
    {
      "indent": 3,
      "text": "An allocation on the server is created using an Allocate transaction.",
      "ja": "サーバー上の割り当ては、割り当てトランザクションを使用して作成されます。"
    },
    {
      "indent": 0,
      "text": "6.1. Sending an Allocate Request",
      "section_title": true,
      "ja": "6.1. 割り当てリクエストを送信します"
    },
    {
      "indent": 3,
      "text": "The client forms an Allocate request as follows.",
      "ja": "クライアントは、次のように割り当てリクエストを形成します。"
    },
    {
      "indent": 3,
      "text": "The client first picks a host transport address. It is RECOMMENDED that the client pick a currently unused transport address, typically by allowing the underlying OS to pick a currently unused port for a new socket.",
      "ja": "クライアントは最初にホストトランスポートアドレスを選択します。通常、基礎となるOSが新しいソケットの現在使用されていないポートを選択できるようにすることにより、クライアントが現在使用されていない輸送アドレスを選択することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The client then picks a transport protocol to use between the client and the server. The transport protocol MUST be one of UDP, TCP, or TLS-over-TCP. Since this specification only allows UDP between the server and the peers, it is RECOMMENDED that the client pick UDP unless it has a reason to use a different transport. One reason to pick a different transport would be that the client believes, either through configuration or by experiment, that it is unable to contact any TURN server using UDP. See Section 2.1 for more discussion.",
      "ja": "クライアントは、クライアントとサーバーの間で使用するトランスポートプロトコルを選択します。輸送プロトコルは、UDP、TCP、またはTLS-Over-TCPの1つでなければなりません。この仕様では、サーバーとピア間のUDPのみが許可されているため、異なるトランスポートを使用する理由がない限り、クライアントがUDPを選択することをお勧めします。別のトランスポートを選択する理由の1つは、クライアントが構成または実験のいずれかで、UDPを使用してターンサーバーに連絡できないと考えていることです。詳細については、セクション2.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "The client also picks a server transport address, which SHOULD be done as follows. The client receives (perhaps through configuration) a domain name for a TURN server. The client then uses the DNS procedures described in [RFC5389], but using an SRV service name of \"turn\" (or \"turns\" for TURN over TLS) instead of \"stun\" (or \"stuns\"). For example, to find servers in the example.com domain, the client performs a lookup for '_turn._udp.example.com', '_turn._tcp.example.com', and '_turns._tcp.example.com' if the client wants to communicate with the server using UDP, TCP, or TLS-over-TCP, respectively.",
      "ja": "また、クライアントはサーバートランスポートアドレスを選択します。これは次のように行う必要があります。クライアントは（おそらく構成を介して）ターンサーバーのドメイン名を受信します。次に、クライアントは[RFC5389]で説明されているDNS手順を使用しますが、「スタン」（または「スタン」）の代わりに「ターン」（またはTLSをターンオーバーするために「ターン」）のSRVサービス名を使用します。たとえば、example.comドメインでサーバーを見つけるために、クライアントは「_turn._udp.example.com」、 '_turn._tcp.example.com'、および「_turns._tcp.example.com」の検索を実行します。クライアントは、それぞれUDP、TCP、またはTLS-Over-TCPを使用してサーバーと通信したいと考えています。"
    },
    {
      "indent": 3,
      "text": "The client MUST include a REQUESTED-TRANSPORT attribute in the request. This attribute specifies the transport protocol between the server and the peers (note that this is NOT the transport protocol that appears in the 5-tuple). In this specification, the REQUESTED-TRANSPORT type is always UDP. This attribute is included to allow future extensions to specify other protocols.",
      "ja": "クライアントは、リクエストに要求された輸送属性を含める必要があります。この属性は、サーバーとピアの間のトランスポートプロトコルを指定します（これは5タプルに表示されるトランスポートプロトコルではないことに注意してください）。この仕様では、要求された輸送タイプは常にUDPです。この属性は、将来の拡張機能が他のプロトコルを指定できるようにするために含まれています。"
    },
    {
      "indent": 3,
      "text": "If the client wishes the server to initialize the time-to-expiry field of the allocation to some value other than the default lifetime, then it MAY include a LIFETIME attribute specifying its desired value. This is just a request, and the server may elect to use a different value. Note that the server will ignore requests to initialize the field to less than the default value.",
      "ja": "クライアントが、デフォルトのライフタイム以外の値への割り当ての時間フィールドを初期化するようにサーバーに希望する場合、その希望の値を指定するLifetime属性が含まれる場合があります。これは単なる要求であり、サーバーは異なる値を使用することを選択する場合があります。サーバーは、フィールドをデフォルト値より少ないものに初期化するリクエストを無視することに注意してください。"
    },
    {
      "indent": 3,
      "text": "If the client wishes to later use the DONT-FRAGMENT attribute in one or more Send indications on this allocation, then the client SHOULD include the DONT-FRAGMENT attribute in the Allocate request. This allows the client to test whether this attribute is supported by the server.",
      "ja": "クライアントが後でこの割り当ての1つ以上の送信指示でdont-fragment属性を使用したい場合、クライアントは割り当てリクエストにdont-fragment属性を含める必要があります。これにより、クライアントはこの属性がサーバーによってサポートされているかどうかをテストできます。"
    },
    {
      "indent": 3,
      "text": "If the client requires the port number of the relayed transport address be even, the client includes the EVEN-PORT attribute. If this attribute is not included, then the port can be even or odd. By setting the R bit in the EVEN-PORT attribute to 1, the client can request that the server reserve the next highest port number (on the same IP address) for a subsequent allocation. If the R bit is 0, no such request is made.",
      "ja": "クライアントが中継輸送アドレスのポート番号を均等に要求する場合、クライアントには均一なポート属性が含まれます。この属性が含まれていない場合、ポートは均等または奇数になります。自由ポート属性のRビットを1に設定することにより、クライアントは、次の割り当てのために、サーバーが次に高いポート番号（同じIPアドレス）を予約することを要求できます。Rビットが0の場合、そのような要求は行われません。"
    },
    {
      "indent": 3,
      "text": "The client MAY also include a RESERVATION-TOKEN attribute in the request to ask the server to use a previously reserved port for the allocation. If the RESERVATION-TOKEN attribute is included, then the client MUST omit the EVEN-PORT attribute.",
      "ja": "クライアントは、リクエストに予約トークン属性を含めることも、サーバーに割り当てに予約されていたポートを使用するように依頼することもできます。予約トークン属性が含まれている場合、クライアントは均一な属性を省略する必要があります。"
    },
    {
      "indent": 3,
      "text": "Once constructed, the client sends the Allocate request on the 5-tuple.",
      "ja": "構築されると、クライアントは5タプルで割り当てリクエストを送信します。"
    },
    {
      "indent": 0,
      "text": "6.2. Receiving an Allocate Request",
      "section_title": true,
      "ja": "6.2. 割り当てリクエストを受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives an Allocate request, it performs the following checks:",
      "ja": "サーバーが割り当て要求を受信すると、次のチェックが実行されます。"
    },
    {
      "indent": 3,
      "text": "1. The server MUST require that the request be authenticated. This authentication MUST be done using the long-term credential mechanism of [RFC5389] unless the client and server agree to use another mechanism through some procedure outside the scope of this document.",
      "ja": "1. サーバーは、リクエストを認証する必要があります。この認証は、クライアントとサーバーがこのドキュメントの範囲外の何らかの手順を介して別のメカニズムを使用することに同意しない限り、[RFC5389]の長期的な資格メカニズムを使用して行う必要があります。"
    },
    {
      "indent": 3,
      "text": "2. The server checks if the 5-tuple is currently in use by an existing allocation. If yes, the server rejects the request with a 437 (Allocation Mismatch) error.",
      "ja": "2. サーバーは、5タプルが現在既存の割り当てによって使用されているかどうかを確認します。はいの場合、サーバーは437（割り当ての不一致）エラーでリクエストを拒否します。"
    },
    {
      "indent": 3,
      "text": "3. The server checks if the request contains a REQUESTED-TRANSPORT attribute. If the REQUESTED-TRANSPORT attribute is not included or is malformed, the server rejects the request with a 400 (Bad Request) error. Otherwise, if the attribute is included but specifies a protocol other that UDP, the server rejects the request with a 442 (Unsupported Transport Protocol) error.",
      "ja": "3. サーバーは、要求に要求されたトランスポート属性が含まれているかどうかを確認します。要求されたトランスポート属性が含まれていないか、奇形が含まれていない場合、サーバーは400（悪い要求）エラーで要求を拒否します。それ以外の場合、属性が含まれているが、UDPが他のプロトコルを指定している場合、サーバーは442（サポートされていないトランスポートプロトコル）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "4. The request may contain a DONT-FRAGMENT attribute. If it does, but the server does not support sending UDP datagrams with the DF bit set to 1 (see Section 12), then the server treats the DONT-FRAGMENT attribute in the Allocate request as an unknown comprehension-required attribute.",
      "ja": "4. リクエストには、fragment属性が含まれていない場合があります。それがそうである場合、しかし、サーバーはDFビットが1に設定されたUDPデータグラムの送信をサポートしていません（セクション12を参照）、サーバーは不明な理解要求属性として割り当てリクエストの非フラグメント属性を扱います。"
    },
    {
      "indent": 3,
      "text": "5. The server checks if the request contains a RESERVATION-TOKEN attribute. If yes, and the request also contains an EVEN-PORT attribute, then the server rejects the request with a 400 (Bad Request) error. Otherwise, it checks to see if the token is valid (i.e., the token is in range and has not expired and the corresponding relayed transport address is still available). If the token is not valid for some reason, the server rejects the request with a 508 (Insufficient Capacity) error.",
      "ja": "5. サーバーは、リクエストに予約トークン属性が含まれているかどうかを確認します。はい、そしてリクエストに均一な属性も含まれている場合、サーバーは400（悪い要求）エラーでリクエストを拒否します。それ以外の場合、トークンが有効かどうかを確認します（つまり、トークンは範囲であり、有効期限が切れておらず、対応するリレー輸送アドレスがまだ利用可能です）。トークンが何らかの理由で有効でない場合、サーバーは508（容量不足）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "6. The server checks if the request contains an EVEN-PORT attribute. If yes, then the server checks that it can satisfy the request (i.e., can allocate a relayed transport address as described below). If the server cannot satisfy the request, then the server rejects the request with a 508 (Insufficient Capacity) error.",
      "ja": "6. サーバーは、リクエストに均一ポート属性が含まれているかどうかを確認します。はいの場合、サーバーはリクエストを満たすことができることをチェックします（つまり、以下に説明するように中継された輸送アドレスを割り当てることができます）。サーバーがリクエストを満たせない場合、サーバーは508（容量不足）エラーでリクエストを拒否します。"
    },
    {
      "indent": 3,
      "text": "7. At any point, the server MAY choose to reject the request with a 486 (Allocation Quota Reached) error if it feels the client is trying to exceed some locally defined allocation quota. The server is free to define this allocation quota any way it wishes, but SHOULD define it based on the username used to authenticate the request, and not on the client's transport address.",
      "ja": "7. いつでも、サーバーは、クライアントがローカルで定義された割り当てクォータを超えようとしていると感じている場合、486（割り当てクォータに達した）エラーでリクエストを拒否することを選択できます。サーバーは、この割り当てクォータを希望する方法で自由に定義できますが、クライアントのトランスポートアドレスではなく、リクエストを認証するために使用されるユーザー名に基づいて定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "8. Also at any point, the server MAY choose to reject the request with a 300 (Try Alternate) error if it wishes to redirect the client to a different server. The use of this error code and attribute follow the specification in [RFC5389].",
      "ja": "8. また、サーバーは、クライアントを別のサーバーにリダイレクトする場合、300（代替）エラーでリクエストを拒否することを選択できます。このエラーコードと属性の使用は、[RFC5389]の仕様に従います。"
    },
    {
      "indent": 3,
      "text": "If all the checks pass, the server creates the allocation. The 5-tuple is set to the 5-tuple from the Allocate request, while the list of permissions and the list of channels are initially empty.",
      "ja": "すべてのチェックが通過した場合、サーバーは割り当てを作成します。5タプルは、割り当てリクエストから5タプルに設定され、許可のリストとチャネルのリストは最初に空です。"
    },
    {
      "indent": 3,
      "text": "The server chooses a relayed transport address for the allocation as follows:",
      "ja": "サーバーは、次のように、割り当てのリレー輸送アドレスを選択します。"
    },
    {
      "indent": 3,
      "text": "o If the request contains a RESERVATION-TOKEN, the server uses the previously reserved transport address corresponding to the included token (if it is still available). Note that the reservation is a server-wide reservation and is not specific to a particular allocation, since the Allocate request containing the RESERVATION-TOKEN uses a different 5-tuple than the Allocate request that made the reservation. The 5-tuple for the Allocate request containing the RESERVATION-TOKEN attribute can be any allowed 5-tuple; it can use a different client IP address and port, a different transport protocol, and even different server IP address and port (provided, of course, that the server IP address and port are ones on which the server is listening for TURN requests).",
      "ja": "o リクエストに予約が含まれている場合、サーバーは、含まれているトークンに対応する以前に予約された輸送アドレスを使用します（まだ利用可能な場合）。予約はサーバー全体の予約であり、特定の割り当てに固有のものではないことに注意してください。これは、予約トークンを含む割り当て要求は、予約を行った割り当て要求とは異なる5タプルを使用しているためです。予約トークン属性を含む割り当てリクエストの5タプルは、5タプルを許可することができます。異なるクライアントIPアドレスとポート、異なるトランスポートプロトコル、さらには異なるサーバーIPアドレスとポートを使用できます（もちろん、サーバーIPアドレスとポートがサーバーがターンリクエストをリッスンしているものであることを提供）。"
    },
    {
      "indent": 3,
      "text": "o If the request contains an EVEN-PORT attribute with the R bit set to 0, then the server allocates a relayed transport address with an even port number.",
      "ja": "o 要求にrビットが0に設定された均一ポート属性が含まれている場合、サーバーは均一なポート番号で中継されたトランスポートアドレスを割り当てます。"
    },
    {
      "indent": 3,
      "text": "o If the request contains an EVEN-PORT attribute with the R bit set to 1, then the server looks for a pair of port numbers N and N+1 on the same IP address, where N is even. Port N is used in the current allocation, while the relayed transport address with port N+1 is assigned a token and reserved for a future allocation. The server MUST hold this reservation for at least 30 seconds, and MAY choose to hold longer (e.g., until the allocation with port N expires). The server then includes the token in a RESERVATION-TOKEN attribute in the success response.",
      "ja": "o 要求にrビットが1に設定された均一ポート属性が含まれている場合、サーバーは同じIPアドレスでポート番号nとn 1のペアを探します。ポートNは現在の割り当てで使用されますが、ポートN 1の中継輸送アドレスはトークンを割り当てられ、将来の割り当てのために予約されています。サーバーは、この予約を少なくとも30秒間保持する必要があり、より長く保持することを選択できます（たとえば、ポートNとの割り当てが失効するまで）。サーバーには、成功応答の予約トークン属性のトークンが含まれます。"
    },
    {
      "indent": 3,
      "text": "o Otherwise, the server allocates any available relayed transport address.",
      "ja": "o それ以外の場合、サーバーは利用可能な中継輸送アドレスを割り当てます。"
    },
    {
      "indent": 3,
      "text": "In all cases, the server SHOULD only allocate ports from the range 49152 - 65535 (the Dynamic and/or Private Port range [Port-Numbers]), unless the TURN server application knows, through some means not specified here, that other applications running on the same host as the TURN server application will not be impacted by allocating ports outside this range. This condition can often be satisfied by running the TURN server application on a dedicated machine and/or by arranging that any other applications on the machine allocate ports before the TURN server application starts. In any case, the TURN server SHOULD NOT allocate ports in the range 0 - 1023 (the Well-Known Port range) to discourage clients from using TURN to run standard services.",
      "ja": "すべての場合において、サーバーは、ターンサーバーのアプリケーションがここで指定されていない何らかの方法で、実行されている他のアプリケーションを実行していることを知っていない限り、範囲49152-65535（ダイナミックおよび/またはプライベートポート範囲[ポート番号]）の範囲からポートを割り当てる必要があります。ターンサーバーアプリケーションと同じホストでは、この範囲外にポートを割り当てることによって影響を受けません。この条件は、多くの場合、専用マシンでターンサーバーアプリケーションを実行したり、ターンサーバーアプリケーションが開始される前にマシン上の他のアプリケーションがポートを割り当てることを整理することで満たすことができます。いずれにせよ、ターンサーバーは、クライアントが標準サービスを実行するのを防ぐために、範囲0〜1023（有名なポート範囲）の範囲のポートを割り当てるべきではありません。"
    },
    {
      "indent": 6,
      "text": "NOTE: The IETF is currently investigating the topic of randomized port assignments to avoid certain types of attacks (see [TSVWG-PORT]). It is strongly recommended that a TURN implementor keep abreast of this topic and, if appropriate, implement a randomized port assignment algorithm. This is especially applicable to servers that choose to pre-allocate a number of ports from the underlying OS and then later assign them to allocations; for example, a server may choose this technique to implement the EVEN-PORT attribute.",
      "ja": "注：IETFは現在、特定の種類の攻撃を回避するために、ランダム化ポート割り当てのトピックを調査しています（[TSVWG-Port]を参照）。ターン実装者がこのトピックに遅れずについており、必要に応じてランダム化ポート割り当てアルゴリズムを実装することを強くお勧めします。これは、基礎となるOSから多くのポートを事前に割り当て、後で割り当てに割り当てることを選択するサーバーに特に適用されます。たとえば、サーバーはこの手法を選択して、均一な属性を実装できます。"
    },
    {
      "indent": 3,
      "text": "The server determines the initial value of the time-to-expiry field as follows. If the request contains a LIFETIME attribute, then the server computes the minimum of the client's proposed lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the server uses the computed lifetime as the initial value of the time-to-expiry field. Otherwise, the server uses the default lifetime. It is RECOMMENDED that the server use a maximum allowed lifetime value of no more than 3600 seconds (1 hour). Servers that implement allocation quotas or charge users for allocations in some way may wish to use a smaller maximum allowed lifetime (perhaps as small as the default lifetime) to more quickly remove orphaned allocations (that is, allocations where the corresponding client has crashed or terminated or the client connection has been lost for some reason). Also, note that the time-to-expiry is recomputed with each successful Refresh request, and thus the value computed here applies only until the first refresh.",
      "ja": "サーバーは、次のように、拡張期間フィールドの初期値を決定します。リクエストに生涯属性が含まれている場合、サーバーはクライアントの提案された生涯とサーバーの最大許容寿命の最小値を計算します。この計算された値がデフォルトの寿命よりも大きい場合、サーバーは計算された寿命をexpiryまでの時間フィールドの初期値として使用します。それ以外の場合、サーバーはデフォルトのライフタイムを使用します。サーバーは、3600秒以下（1時間）以下の最大許可された寿命値を使用することをお勧めします。割り当てクォータまたは請求ユーザーを何らかの方法で実装するサーバーは、より少ない最大許容寿命（おそらくデフォルトの寿命と同じくらい小さい）を使用して、より迅速に孤児の割り当てを削除したい場合があります（つまり、対応するクライアントがクラッシュまたは終了した割り当てまたは、何らかの理由でクライアント接続が失われました）。また、Expiryまでの時間は、成功するリフレッシュリクエストごとに再計算されるため、ここで計算された値は最初の更新までのみ適用されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Once the allocation is created, the server replies with a success response. The success response contains:",
      "ja": "割り当てが作成されると、サーバーは成功応答で返信します。成功応答には次のものが含まれています。"
    },
    {
      "indent": 3,
      "text": "o An XOR-RELAYED-ADDRESS attribute containing the relayed transport address.",
      "ja": "o リレー輸送アドレスを含むXORリレードドレス属性。"
    },
    {
      "indent": 3,
      "text": "o A LIFETIME attribute containing the current value of the time-to-expiry timer.",
      "ja": "o expiryまでの時間の現在の値を含む生涯属性。"
    },
    {
      "indent": 3,
      "text": "o A RESERVATION-TOKEN attribute (if a second relayed transport address was reserved).",
      "ja": "o 予約トークン属性（2番目のリレー輸送アドレスが予約されている場合）。"
    },
    {
      "indent": 3,
      "text": "o An XOR-MAPPED-ADDRESS attribute containing the client's IP address and port (from the 5-tuple).",
      "ja": "o クライアントのIPアドレスとポート（5タプルから）を含むXOR-Mapp-Address属性。"
    },
    {
      "indent": 6,
      "text": "NOTE: The XOR-MAPPED-ADDRESS attribute is included in the response as a convenience to the client. TURN itself does not make use of this value, but clients running ICE can often need this value and can thus avoid having to do an extra Binding transaction with some STUN server to learn it.",
      "ja": "注：XOR-Mapped-Address属性は、クライアントへの利便性として応答に含まれています。ターン自体はこの値を利用していませんが、ICEを実行するクライアントはこの値を必要とすることが多いため、STUNサーバーを使用して追加のバインディングトランザクションを実行する必要がなくなります。"
    },
    {
      "indent": 3,
      "text": "The response (either success or error) is sent back to the client on the 5-tuple.",
      "ja": "応答（成功またはエラー）は、5タプルでクライアントに送り返されます。"
    },
    {
      "indent": 6,
      "text": "NOTE: When the Allocate request is sent over UDP, section 7.3.1 of [RFC5389] requires that the server handle the possible retransmissions of the request so that retransmissions do not cause multiple allocations to be created. Implementations may achieve this using the so-called \"stateless stack approach\" as follows. To detect retransmissions when the original request was successful in creating an allocation, the server can store the transaction id that created the request with the allocation data and compare it with incoming Allocate requests on the same 5-tuple. Once such a request is detected, the server can stop parsing the request and immediately generate a success response. When building this response, the value of the LIFETIME attribute can be taken from the time-to-expiry field in the allocate state data, even though this value may differ slightly from the LIFETIME value originally returned. In addition, the server may need to store an indication of any reservation token returned in the original response, so that this may be returned in any retransmitted responses.",
      "ja": "注：AlocateリクエストがUDPを介して送信されると、[RFC5389]のセクション7.3.1では、サーバーがリクエストの可能な再送信を処理することを要求して、再送信が複数の割り当てを作成しないようにします。次のように、いわゆる「ステートレススタックアプローチ」を使用してこれを実現する場合があります。元のリクエストが割り当ての作成に成功したときに再送信を検出するために、サーバーはリクエストを作成したトランザクションIDを割り当てデータで保存し、同じ5タプルでの着信割り当てリクエストと比較できます。そのような要求が検出されると、サーバーは要求の解析を停止し、すぐに成功応答を生成できます。この応答を構築するとき、この値は元々返された生涯値とはわずかに異なる場合でも、生涯属性の値は、割り当てされた状態データの時間からexpiryまでのフィールドから取得できます。さらに、サーバーは、元の応答で返された予約トークンの表示を保存する必要がある場合があります。これにより、これは再送信された応答で返される可能性があります。"
    },
    {
      "indent": 6,
      "text": "For the case where the original request was unsuccessful in creating an allocation, the server may choose to do nothing special. Note, however, that there is a rare case where the server rejects the original request but accepts the retransmitted request (because conditions have changed in the brief intervening time period). If the client receives the first failure response, it will ignore the second (success) response and believe that an allocation was not created. An allocation created in this matter will eventually timeout, since the client will not refresh it. Furthermore, if the client later retries with the same 5-tuple but different transaction id, it will receive a 437 (Allocation Mismatch), which will cause it to retry with a different 5-tuple. The server may use a smaller maximum lifetime value to minimize the lifetime of allocations \"orphaned\" in this manner.",
      "ja": "元のリクエストが割り当ての作成に失敗した場合、サーバーは特別なことを何もしないことを選択する場合があります。ただし、サーバーが元のリクエストを拒否しているが、再送信要求を受け入れるまれなケースがあることに注意してください（短い介入期間に条件が変更されたため）。クライアントが最初の障害応答を受信した場合、2番目の（成功）応答を無視し、割り当てが作成されなかったと考えます。クライアントが更新されないため、この問題で作成された割り当ては最終的にタイムアウトになります。さらに、クライアントが後で同じ5タプルで異なるトランザクションIDで取得すると、437（割り当ての不一致）が届き、異なる5タプルで再試行されます。サーバーは、より少ない最大寿命の値を使用して、この方法で「孤児」の割り当ての寿命を最小限に抑えることができます。"
    },
    {
      "indent": 0,
      "text": "6.3. Receiving an Allocate Success Response",
      "section_title": true,
      "ja": "6.3. 割り当て成功応答を受信します"
    },
    {
      "indent": 3,
      "text": "If the client receives an Allocate success response, then it MUST check that the mapped address and the relayed transport address are in an address family that the client understands and is prepared to handle. This specification only covers the case where these two addresses are IPv4 addresses. If these two addresses are not in an address family which the client is prepared to handle, then the client MUST delete the allocation (Section 7) and MUST NOT attempt to create another allocation on that server until it believes the mismatch has been fixed.",
      "ja": "クライアントが割り当ての成功応答を受信した場合、マッピングされたアドレスと中継輸送アドレスが、クライアントが理解し、処理する準備ができているアドレスファミリにあることを確認する必要があります。この仕様は、これら2つのアドレスがIPv4アドレスである場合のみをカバーします。これらの2つのアドレスがクライアントが処理する準備ができているアドレスファミリにない場合、クライアントは割り当て（セクション7）を削除する必要があり、不一致が修正されたと信じるまでそのサーバーに別の割り当てを作成しようとしてはなりません。"
    },
    {
      "indent": 6,
      "text": "The IETF is currently considering mechanisms for transitioning between IPv4 and IPv6 that could result in a client originating an Allocate request over IPv6, but the request would arrive at the server over IPv4, or vice versa.",
      "ja": "IETFは現在、IPv4とIPv6の間を移行するためのメカニズムを検討しており、クライアントがIPv6を介して割り当て要求を発信するクライアントになる可能性がありますが、リクエストはIPv4を介してサーバーに到着します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the client creates its own copy of the allocation data structure to track what is happening on the server. In particular, the client needs to remember the actual lifetime received back from the server, rather than the value sent to the server in the request.",
      "ja": "それ以外の場合、クライアントは、サーバーで何が起こっているかを追跡するために、割り当てデータ構造の独自のコピーを作成します。特に、クライアントは、リクエストでサーバーに送信された値ではなく、サーバーから受け取った実際の生涯を覚えておく必要があります。"
    },
    {
      "indent": 3,
      "text": "The client must also remember the 5-tuple used for the request and the username and password it used to authenticate the request to ensure that it reuses them for subsequent messages. The client also needs to track the channels and permissions it establishes on the server.",
      "ja": "また、クライアントは、リクエストに使用された5タプルと、リクエストを認証するために使用されるユーザー名とパスワードを覚えておく必要があります。また、クライアントは、サーバーで確立するチャネルとアクセス許可を追跡する必要があります。"
    },
    {
      "indent": 3,
      "text": "The client will probably wish to send the relayed transport address to peers (using some method not specified here) so the peers can communicate with it. The client may also wish to use the server-reflexive address it receives in the XOR-MAPPED-ADDRESS attribute in its ICE processing.",
      "ja": "クライアントは、おそらくピアにリレー輸送アドレスをピアに送信したいと思う必要があります（ここでは指定されていない方法を使用して）ピアは通信できます。また、クライアントは、ICE処理でXOR-Mapped-Address属性で受信するサーバー反射アドレスを使用することもできます。"
    },
    {
      "indent": 0,
      "text": "6.4. Receiving an Allocate Error Response",
      "section_title": true,
      "ja": "6.4. 割り当てエラー応答を受信します"
    },
    {
      "indent": 3,
      "text": "If the client receives an Allocate error response, then the processing depends on the actual error code returned:",
      "ja": "クライアントが割り当てエラー応答を受信した場合、処理は実際のエラーコードに依存します。"
    },
    {
      "indent": 3,
      "text": "o (Request timed out): There is either a problem with the server, or a problem reaching the server with the chosen transport. The client considers the current transaction as having failed but MAY choose to retry the Allocate request using a different transport (e.g., TCP instead of UDP).",
      "ja": "o （リクエストのタイミング）：サーバーに問題があるか、選択したトランスポートでサーバーに到達する問題があります。クライアントは、現在のトランザクションが失敗したと見なしますが、異なるトランスポート（UDPの代わりにTCPなど）を使用して割り当て要求を再試行することを選択できます。"
    },
    {
      "indent": 3,
      "text": "o 300 (Try Alternate): The server would like the client to use the server specified in the ALTERNATE-SERVER attribute instead. The client considers the current transaction as having failed, but SHOULD try the Allocate request with the alternate server before trying any other servers (e.g., other servers discovered using the SRV procedures). When trying the Allocate request with the alternate server, the client follows the ALTERNATE-SERVER procedures specified in [RFC5389].",
      "ja": "o 300（代替を試してください）：サーバーは、代わりに代替サーバー属性で指定されたサーバーをクライアントに使用してほしい。クライアントは、現在のトランザクションが失敗したと見なしますが、他のサーバーを試す前に、代替サーバーで割り当てリクエストを試してみる必要があります（たとえば、SRV手順を使用して発見された他のサーバー）。代替サーバーで割り当てリクエストを試してみると、クライアントは[RFC5389]で指定された代替サーバー手順に従います。"
    },
    {
      "indent": 3,
      "text": "o 400 (Bad Request): The server believes the client's request is malformed for some reason. The client considers the current transaction as having failed. The client MAY notify the user or operator and SHOULD NOT retry the request with this server until it believes the problem has been fixed.",
      "ja": "o 400（悪い要求）：サーバーは、何らかの理由でクライアントの要求が奇形であると考えています。クライアントは、現在のトランザクションが失敗したと考えています。クライアントは、ユーザーまたはオペレーターに通知する場合があり、問題が修正されたと判断されるまで、このサーバーでリクエストを再試行しないでください。"
    },
    {
      "indent": 3,
      "text": "o 401 (Unauthorized): If the client has followed the procedures of the long-term credential mechanism and still gets this error, then the server is not accepting the client's credentials. In this case, the client considers the current transaction as having failed and SHOULD notify the user or operator. The client SHOULD NOT send any further requests to this server until it believes the problem has been fixed.",
      "ja": "o 401（不正）：クライアントが長期的な資格メカニズムの手順に従ってこのエラーを取得した場合、サーバーはクライアントの資格情報を受け入れていません。この場合、クライアントは現在のトランザクションが失敗したと見なし、ユーザーまたはオペレーターに通知する必要があります。クライアントは、問題が修正されたと信じるまで、このサーバーにさらなるリクエストを送信しないでください。"
    },
    {
      "indent": 3,
      "text": "o 403 (Forbidden): The request is valid, but the server is refusing to perform it, likely due to administrative restrictions. The client considers the current transaction as having failed. The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.",
      "ja": "o 403（禁止）：リクエストは有効ですが、おそらく管理上の制限により、サーバーはそれを実行することを拒否しています。クライアントは、現在のトランザクションが失敗したと考えています。クライアントは、ユーザーまたはオペレーターに通知する場合があり、問題が修正されたと判断されるまで、このサーバーで同じリクエストを再試行しないでください。"
    },
    {
      "indent": 3,
      "text": "o 420 (Unknown Attribute): If the client included a DONT-FRAGMENT attribute in the request and the server rejected the request with a 420 error code and listed the DONT-FRAGMENT attribute in the UNKNOWN-ATTRIBUTES attribute in the error response, then the client now knows that the server does not support the DONT-FRAGMENT attribute. The client considers the current transaction as having failed but MAY choose to retry the Allocate request without the DONT-FRAGMENT attribute.",
      "ja": "o 420（不明な属性）：クライアントがリクエストにfragment属性を含め、サーバーが420エラーコードでリクエストを拒否し、エラー応答のnokning-aTtributes属性にdont-fragment属性をリストした場合、クライアントはクライアントをリストしました。これで、サーバーがfragmentの属性をサポートしていないことがわかりました。クライアントは、現在のトランザクションが失敗したと見なしますが、fragment属性なしで割り当て要求を再試行することを選択する場合があります。"
    },
    {
      "indent": 3,
      "text": "o 437 (Allocation Mismatch): This indicates that the client has picked a 5-tuple that the server sees as already in use. One way this could happen is if an intervening NAT assigned a mapped transport address that was used by another client that recently crashed. The client considers the current transaction as having failed. The client SHOULD pick another client transport address and retry the Allocate request (using a different transaction id). The client SHOULD try three different client transport addresses before giving up on this server. Once the client gives up on the server, it SHOULD NOT try to create another allocation on the server for 2 minutes.",
      "ja": "o 437（割り当てのミスマッチ）：これは、クライアントがサーバーがすでに使用していると見ている5タプルを選択したことを示しています。これが起こる可能性のある方法の1つは、介在するNATが最近クラッシュした別のクライアントが使用したマッピングされたトランスポートアドレスを割り当てた場合です。クライアントは、現在のトランザクションが失敗したと考えています。クライアントは、別のクライアントトランスポートアドレスを選択し、割り当て要求を再試行する必要があります（別のトランザクションIDを使用）。クライアントは、このサーバーをあきらめる前に、3つの異なるクライアントトランスポートアドレスを試す必要があります。クライアントがサーバーで放棄したら、サーバーに別の割り当てを2分間作成しようとしないでください。"
    },
    {
      "indent": 3,
      "text": "o 438 (Stale Nonce): See the procedures for the long-term credential mechanism [RFC5389].",
      "ja": "o 438（古い非CE）：長期的な資格メカニズムの手順[RFC5389]を参照してください。"
    },
    {
      "indent": 3,
      "text": "o 441 (Wrong Credentials): The client should not receive this error in response to a Allocate request. The client MAY notify the user or operator and SHOULD NOT retry the same request with this server until it believes the problem has been fixed.",
      "ja": "o 441（間違った資格情報）：クライアントは、割り当てリクエストに応じてこのエラーを受信してはなりません。クライアントは、ユーザーまたはオペレーターに通知する場合があり、問題が修正されたと判断されるまで、このサーバーで同じリクエストを再試行しないでください。"
    },
    {
      "indent": 3,
      "text": "o 442 (Unsupported Transport Address): The client should not receive this error in response to a request for a UDP allocation. The client MAY notify the user or operator and SHOULD NOT reattempt the request with this server until it believes the problem has been fixed.",
      "ja": "o 442（サポートされていないトランスポートアドレス）：クライアントは、UDP割り当ての要求に応じてこのエラーを受け取ってはなりません。クライアントは、ユーザーまたはオペレーターに通知する場合があり、問題が修正されたと判断されるまで、このサーバーでリクエストを返信してはなりません。"
    },
    {
      "indent": 3,
      "text": "o 486 (Allocation Quota Reached): The server is currently unable to create any more allocations with this username. The client considers the current transaction as having failed. The client SHOULD wait at least 1 minute before trying to create any more allocations on the server.",
      "ja": "o 486（到達した割り当てクォータ）：サーバーは現在、このユーザー名でこれ以上割り当てを作成できません。クライアントは、現在のトランザクションが失敗したと考えています。クライアントは、サーバーにこれ以上割り当てを作成しようとする前に、少なくとも1分間待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "o 508 (Insufficient Capacity): The server has no more relayed transport addresses available, or has none with the requested properties, or the one that was reserved is no longer available. The client considers the current operation as having failed. If the client is using either the EVEN-PORT or the RESERVATION-TOKEN attribute, then the client MAY choose to remove or modify this attribute and try again immediately. Otherwise, the client SHOULD wait at least 1 minute before trying to create any more allocations on this server.",
      "ja": "o 508（容量が不十分）：サーバーには、利用可能な輸送アドレスがなく、要求されたプロパティがないか、予約されたプロパティがありません。クライアントは、現在の操作が失敗したと考えています。クライアントがEven-PortまたはReservation-Token属性のいずれかを使用している場合、クライアントはこの属性を削除または変更してすぐに再試行することを選択できます。それ以外の場合、クライアントは、このサーバーでこれ以上の割り当てを作成しようとする前に、少なくとも1分間待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "An unknown error response MUST be handled as described in [RFC5389].",
      "ja": "[RFC5389]に記載されているように、不明なエラー応答を処理する必要があります。"
    },
    {
      "indent": 0,
      "text": "7. Refreshing an Allocation",
      "section_title": true,
      "ja": "7. 割り当てをリフレッシュします"
    },
    {
      "indent": 3,
      "text": "A Refresh transaction can be used to either (a) refresh an existing allocation and update its time-to-expiry or (b) delete an existing allocation.",
      "ja": "更新トランザクションを使用して、（a）既存の割り当てを更新し、拡張時間を更新するか、（b）既存の割り当てを削除することもできます。"
    },
    {
      "indent": 3,
      "text": "If a client wishes to continue using an allocation, then the client MUST refresh it before it expires. It is suggested that the client refresh the allocation roughly 1 minute before it expires. If a client no longer wishes to use an allocation, then it SHOULD explicitly delete the allocation. A client MAY refresh an allocation at any time for other reasons.",
      "ja": "クライアントが割り当ての使用を続けたい場合、クライアントは有効期限が切れる前にそれを更新する必要があります。クライアントが期限切れになる約1分前に割り当てを更新することが示唆されています。クライアントが割り当てを使用したくない場合、割り当てを明示的に削除する必要があります。クライアントは、他の理由でいつでも割り当てを更新する場合があります。"
    },
    {
      "indent": 0,
      "text": "7.1. Sending a Refresh Request",
      "section_title": true,
      "ja": "7.1. 更新リクエストの送信"
    },
    {
      "indent": 3,
      "text": "If the client wishes to immediately delete an existing allocation, it includes a LIFETIME attribute with a value of 0. All other forms of the request refresh the allocation.",
      "ja": "クライアントが既存の割り当てをすぐに削除したい場合、値0の値を持つ生涯属性が含まれます。"
    },
    {
      "indent": 3,
      "text": "The Refresh transaction updates the time-to-expiry timer of an allocation. If the client wishes the server to set the time-to-expiry timer to something other than the default lifetime, it includes a LIFETIME attribute with the requested value. The server then computes a new time-to-expiry value in the same way as it does for an Allocate transaction, with the exception that a requested lifetime of 0 causes the server to immediately delete the allocation.",
      "ja": "更新トランザクションは、割り当ての時間式タイマーを更新します。クライアントが、デフォルトのライフタイム以外のものにexpiryまでのタイマーを設定するようサーバーに希望する場合、要求された値を持つ生涯属性が含まれます。次に、サーバーは、割り当てトランザクションの場合と同じように、新しい時間から除外までの新しい値を計算します。"
    },
    {
      "indent": 0,
      "text": "7.2. Receiving a Refresh Request",
      "section_title": true,
      "ja": "7.2. 更新リクエストを受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives a Refresh request, it processes as per Section 4 plus the specific rules mentioned here.",
      "ja": "サーバーが更新リクエストを受信すると、セクション4に従って処理され、ここで説明した特定のルールが処理されます。"
    },
    {
      "indent": 3,
      "text": "The server computes a value called the \"desired lifetime\" as follows: if the request contains a LIFETIME attribute and the attribute value is 0, then the \"desired lifetime\" is 0. Otherwise, if the request contains a LIFETIME attribute, then the server computes the minimum of the client's requested lifetime and the server's maximum allowed lifetime. If this computed value is greater than the default lifetime, then the \"desired lifetime\" is the computed value. Otherwise, the \"desired lifetime\" is the default lifetime.",
      "ja": "サーバーは次のように「望ましい生涯」と呼ばれる値を計算します。リクエストに寿命属性が含まれ、属性値が0の場合、「望ましい寿命」は0です。クライアントの要求された寿命の最小値と、サーバーの最大許容寿命を計算します。この計算された値がデフォルトの寿命よりも大きい場合、「望ましい寿命」は計算値です。それ以外の場合、「望ましい生涯」はデフォルトの寿命です。"
    },
    {
      "indent": 3,
      "text": "Subsequent processing depends on the \"desired lifetime\" value:",
      "ja": "後続の処理は、「望ましい生涯」値に依存します。"
    },
    {
      "indent": 3,
      "text": "o If the \"desired lifetime\" is 0, then the request succeeds and the allocation is deleted.",
      "ja": "o 「望ましい寿命」が0の場合、リクエストが成功し、割り当てが削除されます。"
    },
    {
      "indent": 3,
      "text": "o If the \"desired lifetime\" is non-zero, then the request succeeds and the allocation's time-to-expiry is set to the \"desired lifetime\".",
      "ja": "o 「望ましい寿命」がゼロではない場合、要求は成功し、割り当ての時間は「望ましい生涯」に設定されます。"
    },
    {
      "indent": 3,
      "text": "If the request succeeds, then the server sends a success response containing:",
      "ja": "リクエストが成功した場合、サーバーは以下を含む成功応答を送信します。"
    },
    {
      "indent": 3,
      "text": "o A LIFETIME attribute containing the current value of the time-to-expiry timer.",
      "ja": "o expiryまでの時間の現在の値を含む生涯属性。"
    },
    {
      "indent": 6,
      "text": "NOTE: A server need not do anything special to implement idempotency of Refresh requests over UDP using the \"stateless stack approach\". Retransmitted Refresh requests with a non-zero \"desired lifetime\" will simply refresh the allocation. A retransmitted Refresh request with a zero \"desired lifetime\" will cause a 437 (Allocation Mismatch) response if the allocation has already been deleted, but the client will treat this as equivalent to a success response (see below).",
      "ja": "注：サーバーは、「Stateless Stackアプローチ」を使用してUDPを介して更新要求のiDempotencyを実装するために特別なことを行う必要はありません。ゼロ以外の「望ましいライフタイム」を使用した再送信された更新リクエストは、単に割り当てを更新します。ゼロの「望ましいライフタイム」で再送信された更新要求は、割り当てが既に削除されている場合、437（割り当ての不一致）応答を引き起こしますが、クライアントはこれを成功応答に相当するものとして扱います（以下を参照）。"
    },
    {
      "indent": 0,
      "text": "7.3. Receiving a Refresh Response",
      "section_title": true,
      "ja": "7.3. 更新応答を受信します"
    },
    {
      "indent": 3,
      "text": "If the client receives a success response to its Refresh request with a non-zero lifetime, it updates its copy of the allocation data structure with the time-to-expiry value contained in the response.",
      "ja": "クライアントがゼロ以外の寿命で更新要求に対する成功応答を受け取った場合、応答に含まれる時間までの値を使用して、割り当てデータ構造のコピーを更新します。"
    },
    {
      "indent": 3,
      "text": "If the client receives a 437 (Allocation Mismatch) error response to a request to delete the allocation, then the allocation no longer exists and it should consider its request as having effectively succeeded.",
      "ja": "クライアントが割り当てを削除するリクエストに対する437（割り当ての不一致）エラー応答を受信した場合、割り当ては存在せず、その要求を効果的に成功したと考える必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Permissions",
      "section_title": true,
      "ja": "8. 権限"
    },
    {
      "indent": 3,
      "text": "For each allocation, the server keeps a list of zero or more permissions. Each permission consists of an IP address and an associated time-to-expiry. While a permission exists, all peers using the IP address in the permission are allowed to send data to the client. The time-to-expiry is the number of seconds until the permission expires. Within the context of an allocation, a permission is uniquely identified by its associated IP address.",
      "ja": "各割り当てについて、サーバーはゼロ以上の権限のリストを保持します。それぞれの許可は、IPアドレスと関連する時間をとる時間で構成されています。許可が存在しますが、許可でIPアドレスを使用しているすべてのピアは、クライアントにデータを送信することが許可されています。拡張時間は、許可が切れるまで秒数です。割り当てのコンテキスト内で、関連するIPアドレスによって許可が一意に識別されます。"
    },
    {
      "indent": 3,
      "text": "By sending either CreatePermission requests or ChannelBind requests, the client can cause the server to install or refresh a permission for a given IP address. This causes one of two things to happen:",
      "ja": "CreatePermissionリクエストまたはChannelBindリクエストのいずれかを送信することにより、クライアントはサーバーに特定のIPアドレスの許可をインストールまたは更新させることができます。これにより、2つのことが発生します。"
    },
    {
      "indent": 3,
      "text": "o If no permission for that IP address exists, then a permission is created with the given IP address and a time-to-expiry equal to Permission Lifetime.",
      "ja": "o そのIPアドレスの許可が存在しない場合、指定されたIPアドレスと、許可の寿命に等しい時間に等しい時間を使用して許可が作成されます。"
    },
    {
      "indent": 3,
      "text": "o If a permission for that IP address already exists, then the time-to-expiry for that permission is reset to Permission Lifetime.",
      "ja": "o そのIPアドレスの許可が既に存在する場合、その許可の時間が拡大するまでの時間は、許可寿命にリセットされます。"
    },
    {
      "indent": 3,
      "text": "The Permission Lifetime MUST be 300 seconds (= 5 minutes).",
      "ja": "許可寿命は300秒（= 5分）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Each permission's time-to-expiry decreases down once per second until it reaches 0; at which point, the permission expires and is deleted.",
      "ja": "各許可の拡張時間は、0に達するまで1秒あたり1回減少します。その時点で、許可が期限切れになり、削除されます。"
    },
    {
      "indent": 3,
      "text": "CreatePermission and ChannelBind requests may be freely intermixed on a permission. A given permission may be initially installed and/or refreshed with a CreatePermission request, and then later refreshed with a ChannelBind request, or vice versa.",
      "ja": "CreatePermissionおよびChannelBindリクエストは、許可を得て自由に混合される場合があります。指定された許可が最初にインストールされ、および/またはCreatePermissionリクエストで更新され、その後ChannelBindリクエストで更新されるか、その逆も同様です。"
    },
    {
      "indent": 3,
      "text": "When a UDP datagram arrives at the relayed transport address for the allocation, the server extracts the source IP address from the IP header. The server then compares this address with the IP address associated with each permission in the list of permissions for the allocation. If no match is found, relaying is not permitted, and the server silently discards the UDP datagram. If an exact match is found, then the permission check is considered to have succeeded and the server continues to process the UDP datagram as specified elsewhere (Section 10.3). Note that only addresses are compared and port numbers are not considered.",
      "ja": "UDPデータグラムが割り当てのリレー輸送アドレスに到着すると、サーバーはIPヘッダーからソースIPアドレスを抽出します。サーバーは、このアドレスを、割り当ての許可リストの各許可に関連付けられたIPアドレスと比較します。一致が見つからない場合、中継は許可されておらず、サーバーはUDPデータグラムを静かに破棄します。正確な一致が見つかった場合、許可チェックは成功したと見なされ、サーバーは他の場所で指定されているようにUDPデータグラムを処理し続けます（セクション10.3）。アドレスのみが比較され、ポート番号は考慮されないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The permissions for one allocation are totally unrelated to the permissions for a different allocation. If an allocation expires, all its permissions expire with it.",
      "ja": "1つの割り当ての権限は、異なる割り当ての権限とはまったく関係ありません。割り当てが期限切れになった場合、そのすべての権限はそれで期限切れになります。"
    },
    {
      "indent": 6,
      "text": "NOTE: Though TURN permissions expire after 5 minutes, many NATs deployed at the time of publication expire their UDP bindings considerably faster. Thus, an application using TURN will probably wish to send some sort of keep-alive traffic at a much faster rate. Applications using ICE should follow the keep-alive guidelines of ICE [RFC5245], and applications not using ICE are advised to do something similar.",
      "ja": "注：ターンアクセス許可は5分後に期限切れになりますが、出版時に展開された多くのNATがUDPバインディングの非常に速く期限切れになります。したがって、ターンを使用するアプリケーションは、おそらく、ある種のキープアライブトラフィックをはるかに速い速度で送信することを望んでいます。ICEを使用したアプリケーションは、氷の維持用ガイドライン[RFC5245]に従う必要があり、ICEを使用していないアプリケーションは、同様のことをすることをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9. CreatePermission",
      "section_title": true,
      "ja": "9. createpermission"
    },
    {
      "indent": 3,
      "text": "TURN supports two ways for the client to install or refresh permissions on the server. This section describes one way: the CreatePermission request.",
      "ja": "ターンは、クライアントがサーバーにアクセス許可をインストールまたは更新する2つの方法をサポートします。このセクションでは、1つの方法について説明します。CreatePermissionリクエスト。"
    },
    {
      "indent": 3,
      "text": "A CreatePermission request may be used in conjunction with either the Send mechanism in Section 10 or the Channel mechanism in Section 11.",
      "ja": "セクション10の送信メカニズムまたはセクション11のチャネルメカニズムのいずれかと組み合わせて、createpermissionリクエストを使用できます。"
    },
    {
      "indent": 0,
      "text": "9.1. Forming a CreatePermission Request",
      "section_title": true,
      "ja": "9.1. createpermissionリクエストの形成"
    },
    {
      "indent": 3,
      "text": "The client who wishes to install or refresh one or more permissions can send a CreatePermission request to the server.",
      "ja": "1つ以上のアクセス許可をインストールまたは更新したいクライアントは、サーバーにcreatepermissionリクエストを送信できます。"
    },
    {
      "indent": 3,
      "text": "When forming a CreatePermission request, the client MUST include at least one XOR-PEER-ADDRESS attribute, and MAY include more than one such attribute. The IP address portion of each XOR-PEER-ADDRESS attribute contains the IP address for which a permission should be installed or refreshed. The port portion of each XOR-PEER-ADDRESS attribute will be ignored and can be any arbitrary value. The various XOR-PEER-ADDRESS attributes can appear in any order.",
      "ja": "CreatePermissionリクエストを作成する場合、クライアントは少なくとも1つのXor-Peer-Address属性を含める必要があり、複数のそのような属性を含めることができます。各Xor-Peer-Address属性のIPアドレス部分には、許可をインストールまたは更新するIPアドレスが含まれています。各Xor-Peer-Address属性のポート部分は無視され、あらゆる任意の値になる可能性があります。さまざまなXor-Peer-Addressの属性は、任意の順序で表示できます。"
    },
    {
      "indent": 0,
      "text": "9.2. Receiving a CreatePermission Request",
      "section_title": true,
      "ja": "9.2. CreatePermissionリクエストを受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives the CreatePermission request, it processes as per Section 4 plus the specific rules mentioned here.",
      "ja": "サーバーがcreatepermission要求を受信すると、セクション4に従って処理され、ここで説明する特定のルールが処理されます。"
    },
    {
      "indent": 3,
      "text": "The message is checked for validity. The CreatePermission request MUST contain at least one XOR-PEER-ADDRESS attribute and MAY contain multiple such attributes. If no such attribute exists, or if any of these attributes are invalid, then a 400 (Bad Request) error is returned. If the request is valid, but the server is unable to satisfy the request due to some capacity limit or similar, then a 508 (Insufficient Capacity) error is returned.",
      "ja": "メッセージの有効性が確認されます。CreatePermission要求には、少なくとも1つのXor-Peer-Address属性を含める必要があり、複数のそのような属性が含まれる場合があります。そのような属性が存在しない場合、またはこれらの属性のいずれかが無効である場合、400（悪い要求）エラーが返されます。リクエストが有効であるが、サーバーが容量制限または同様のためにリクエストを満たすことができない場合、508（容量不足）エラーが返されます。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address allowed in the XOR-PEER-ADDRESS attribute -- if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.",
      "ja": "サーバーは、Xor-Peer-Address属性で許可されているIPアドレスに制限を課す場合があります。値が許可されていない場合、サーバーは403（禁止）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "If the message is valid and the server is capable of carrying out the request, then the server installs or refreshes a permission for the IP address contained in each XOR-PEER-ADDRESS attribute as described in Section 8. The port portion of each attribute is ignored and may be any arbitrary value.",
      "ja": "メッセージが有効であり、サーバーがリクエストを実行できる場合、サーバーはセクション8に記載されているように、各Xor-Peer-Address属性に含まれるIPアドレスの許可をインストールまたはリフレッシュします。各属性のポート部分は次のとおりです。無視され、あらゆる任意の価値があります。"
    },
    {
      "indent": 3,
      "text": "The server then responds with a CreatePermission success response. There are no mandatory attributes in the success response.",
      "ja": "サーバーは、createpermission成功応答で応答します。成功応答には必須の属性はありません。"
    },
    {
      "indent": 6,
      "text": "NOTE: A server need not do anything special to implement idempotency of CreatePermission requests over UDP using the \"stateless stack approach\". Retransmitted CreatePermission requests will simply refresh the permissions.",
      "ja": "注：サーバーは、「Stateless Stackアプローチ」を使用して、UDPを介してCreatePermission要求の実装を実装するために特別なことを行う必要はありません。再送信されたCreatePermissionリクエストは、権限を単純に更新します。"
    },
    {
      "indent": 0,
      "text": "9.3. Receiving a CreatePermission Response",
      "section_title": true,
      "ja": "9.3. createpermission応答を受信します"
    },
    {
      "indent": 3,
      "text": "If the client receives a valid CreatePermission success response, then the client updates its data structures to indicate that the permissions have been installed or refreshed.",
      "ja": "クライアントが有効なCreatePermission成功応答を受信した場合、クライアントはデータ構造を更新して、アクセス許可がインストールまたは更新されていることを示します。"
    },
    {
      "indent": 0,
      "text": "10. Send and Data Methods",
      "section_title": true,
      "ja": "10. 送信およびデータメソッド"
    },
    {
      "indent": 3,
      "text": "TURN supports two mechanisms for sending and receiving data from peers. This section describes the use of the Send and Data mechanisms, while Section 11 describes the use of the Channel mechanism.",
      "ja": "ターンは、ピアからデータを送信および受信するための2つのメカニズムをサポートします。このセクションでは、送信メカニズムとデータメカニズムの使用について説明し、セクション11ではチャネルメカニズムの使用について説明します。"
    },
    {
      "indent": 0,
      "text": "10.1. Forming a Send Indication",
      "section_title": true,
      "ja": "10.1. 送信表示を形成します"
    },
    {
      "indent": 3,
      "text": "The client can use a Send indication to pass data to the server for relaying to a peer. A client may use a Send indication even if a channel is bound to that peer. However, the client MUST ensure that there is a permission installed for the IP address of the peer to which the Send indication is being sent; this prevents a third party from using a TURN server to send data to arbitrary destinations.",
      "ja": "クライアントは、送信表示を使用して、ピアに中継するためにデータをサーバーに渡すことができます。クライアントは、チャネルがそのピアにバインドされている場合でも、送信表示を使用できます。ただし、クライアントは、送信表示が送信されているピアのIPアドレスに対して許可がインストールされていることを確認する必要があります。これにより、サードパーティはターンサーバーを使用して任意の目的地にデータを送信することを防ぎます。"
    },
    {
      "indent": 3,
      "text": "When forming a Send indication, the client MUST include an XOR-PEER-ADDRESS attribute and a DATA attribute. The XOR-PEER-ADDRESS attribute contains the transport address of the peer to which the data is to be sent, and the DATA attribute contains the actual application data to be sent to the peer.",
      "ja": "送信指示を形成する場合、クライアントはXor-Peer-Address属性とデータ属性を含める必要があります。Xor-Peer-Address属性には、データが送信されるピアのトランスポートアドレスが含まれており、データ属性には実際のアプリケーションデータが含まれています。"
    },
    {
      "indent": 3,
      "text": "The client MAY include a DONT-FRAGMENT attribute in the Send indication if it wishes the server to set the DF bit on the UDP datagram sent to the peer.",
      "ja": "クライアントは、サーバーがピアに送信されたUDPデータグラムにDFビットを設定することを望む場合、送信指示にfragment属性を含めることができます。"
    },
    {
      "indent": 0,
      "text": "10.2. Receiving a Send Indication",
      "section_title": true,
      "ja": "10.2. 送信指示を受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives a Send indication, it processes as per Section 4 plus the specific rules mentioned here.",
      "ja": "サーバーが送信指示を受信すると、セクション4に従って処理され、ここで説明した特定のルールが処理されます。"
    },
    {
      "indent": 3,
      "text": "The message is first checked for validity. The Send indication MUST contain both an XOR-PEER-ADDRESS attribute and a DATA attribute. If one of these attributes is missing or invalid, then the message is discarded. Note that the DATA attribute is allowed to contain zero bytes of data.",
      "ja": "メッセージの有効性は最初にチェックされます。送信指示には、Xor-Peer-Address属性とデータ属性の両方が含まれている必要があります。これらの属性のいずれかが欠落または無効な場合、メッセージは破棄されます。データ属性には、ゼロバイトのデータが含まれていることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Send indication may also contain the DONT-FRAGMENT attribute. If the server is unable to set the DF bit on outgoing UDP datagrams when this attribute is present, then the server acts as if the DONT-FRAGMENT attribute is an unknown comprehension-required attribute (and thus the Send indication is discarded).",
      "ja": "送信指示には、fragment属性がないことも含まれます。この属性が存在するときにサーバーが送信UDPデータグラムでDFビットを設定できない場合、サーバーは、不正な属性が不明な理解要因属性であるかのように動作します（したがって、送信表示は破棄されます）。"
    },
    {
      "indent": 3,
      "text": "The server also checks that there is a permission installed for the IP address contained in the XOR-PEER-ADDRESS attribute. If no such permission exists, the message is discarded. Note that a Send indication never causes the server to refresh the permission.",
      "ja": "また、サーバーは、Xor-Peer-Address属性に含まれるIPアドレスの許可がインストールされていることを確認します。そのような許可が存在しない場合、メッセージは破棄されます。送信指示により、サーバーが許可を更新することはないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute -- if a value is not allowed, the server silently discards the Send indication.",
      "ja": "サーバーは、Xor-Peer-Address属性で許可されているIPアドレスとポート値に制限を課す場合があります。値が許可されていない場合、サーバーはSend Indixicationを静かに破棄します。"
    },
    {
      "indent": 3,
      "text": "If everything is OK, then the server forms a UDP datagram as follows:",
      "ja": "すべてが問題ない場合、サーバーは次のようにUDPデータグラムを形成します。"
    },
    {
      "indent": 3,
      "text": "o the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the Send indication arrived;",
      "ja": "o ソーストランスポートアドレスは、割り当ての中継輸送アドレスであり、配分は送信表示が到着した5タプルによって決定されます。"
    },
    {
      "indent": 3,
      "text": "o the destination transport address is taken from the XOR-PEER-ADDRESS attribute;",
      "ja": "o 宛先輸送アドレスは、Xor-Peer-Address属性から取得されます。"
    },
    {
      "indent": 3,
      "text": "o the data following the UDP header is the contents of the value field of the DATA attribute.",
      "ja": "o UDPヘッダーに続くデータは、データ属性の値フィールドの内容です。"
    },
    {
      "indent": 3,
      "text": "The handling of the DONT-FRAGMENT attribute (if present), is described in Section 12.",
      "ja": "非フラグメント属性の処理（存在する場合）は、セクション12で説明されています。"
    },
    {
      "indent": 3,
      "text": "The resulting UDP datagram is then sent to the peer.",
      "ja": "結果のUDPデータグラムがピアに送信されます。"
    },
    {
      "indent": 0,
      "text": "10.3. Receiving a UDP Datagram",
      "section_title": true,
      "ja": "10.3. UDPデータグラムを受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives a UDP datagram at a currently allocated relayed transport address, the server looks up the allocation associated with the relayed transport address. The server then checks to see whether the set of permissions for the allocation allow the relaying of the UDP datagram as described in Section 8.",
      "ja": "サーバーが現在割り当てられているリレー輸送アドレスでUDPデータグラムを受信すると、サーバーは中継輸送アドレスに関連付けられた割り当てを調べます。次に、サーバーは、セクション8で説明されているように、割り当ての許可のセットがUDPデータグラムの中継を可能にするかどうかを確認します。"
    },
    {
      "indent": 3,
      "text": "If relaying is permitted, then the server checks if there is a channel bound to the peer that sent the UDP datagram (see Section 11). If a channel is bound, then processing proceeds as described in Section 11.7.",
      "ja": "中継が許可されている場合、サーバーは、UDPデータグラムを送信したピアにバインドされたチャネルがあるかどうかをチェックします（セクション11を参照）。チャネルがバインドされている場合、セクション11.7で説明されているように処理が進みます。"
    },
    {
      "indent": 3,
      "text": "If relaying is permitted but no channel is bound to the peer, then the server forms and sends a Data indication. The Data indication MUST contain both an XOR-PEER-ADDRESS and a DATA attribute. The DATA attribute is set to the value of the 'data octets' field from the datagram, and the XOR-PEER-ADDRESS attribute is set to the source transport address of the received UDP datagram. The Data indication is then sent on the 5-tuple associated with the allocation.",
      "ja": "中継が許可されているが、ピアにチャネルがバインドされていない場合、サーバーはデータ表示を形成して送信します。データ表示には、Xor-Peer-Addressとデータ属性の両方を含める必要があります。データ属性は、データグラムから「データオクテット」フィールドの値に設定され、Xor-Peer-Address属性は、受信したUDPデータグラムのソーストランスポートアドレスに設定されます。データの表示は、割り当てに関連付けられた5タプルに送信されます。"
    },
    {
      "indent": 0,
      "text": "10.4. Receiving a Data Indication",
      "section_title": true,
      "ja": "10.4. データ表示を受信します"
    },
    {
      "indent": 3,
      "text": "When the client receives a Data indication, it checks that the Data indication contains both an XOR-PEER-ADDRESS and a DATA attribute, and discards the indication if it does not. The client SHOULD also check that the XOR-PEER-ADDRESS attribute value contains an IP address with which the client believes there is an active permission, and discard the Data indication otherwise. Note that the DATA attribute is allowed to contain zero bytes of data.",
      "ja": "クライアントがデータ表示を受信すると、データ表示にXor-Peer-Addressとデータ属性の両方が含まれていることを確認し、そうでない場合は表示を破棄します。また、クライアントは、Xor-Peer-Address属性値に、積極的な許可があるとクライアントが信じているIPアドレスが含まれていることを確認し、それ以外の場合はデータの表示を破棄する必要があります。データ属性には、ゼロバイトのデータが含まれていることに注意してください。"
    },
    {
      "indent": 6,
      "text": "NOTE: The latter check protects the client against an attacker who somehow manages to trick the server into installing permissions not desired by the client.",
      "ja": "注：後者のチェックは、クライアントが何らかの形で必要としないアクセス許可をインストールするようにサーバーをだましていない攻撃者からクライアントを保護します。"
    },
    {
      "indent": 3,
      "text": "If the Data indication passes the above checks, the client delivers the data octets inside the DATA attribute to the application, along with an indication that they were received from the peer whose transport address is given by the XOR-PEER-ADDRESS attribute.",
      "ja": "データ表示が上記のチェックに合格した場合、クライアントはデータ属性内のデータオクテットをアプリケーションに配信し、XOR-Peer-Address属性によって輸送アドレスが与えられたピアから受信されたことを示すことを示します。"
    },
    {
      "indent": 0,
      "text": "11. Channels",
      "section_title": true,
      "ja": "11. チャネル"
    },
    {
      "indent": 3,
      "text": "Channels provide a way for the client and server to send application data using ChannelData messages, which have less overhead than Send and Data indications.",
      "ja": "チャネルは、クライアントとサーバーが、送信およびデータの表示よりもオーバーヘッドが少ないChannelDataメッセージを使用してアプリケーションデータを送信する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "The ChannelData message (see Section 11.4) starts with a two-byte field that carries the channel number. The values of this field are allocated as follows:",
      "ja": "ChannelDataメッセージ（セクション11.4を参照）は、チャネル番号を運ぶ2バイトフィールドから始まります。このフィールドの値は次のように割り当てられます。"
    },
    {
      "indent": 6,
      "text": "0x0000 through 0x3FFF: These values can never be used for channel numbers.",
      "ja": "0x0000から0x3fff：これらの値は、チャネル番号に使用することはできません。"
    },
    {
      "indent": 6,
      "text": "0x4000 through 0x7FFF: These values are the allowed channel numbers (16,383 possible values).",
      "ja": "0x4000から0x7fff：これらの値は許可されたチャネル番号（16,383の可能な値）です。"
    },
    {
      "indent": 6,
      "text": "0x8000 through 0xFFFF: These values are reserved for future use.",
      "ja": "0x8000から0xffff：これらの値は、将来の使用のために予約されています。"
    },
    {
      "indent": 3,
      "text": "Because of this division, ChannelData messages can be distinguished from STUN-formatted messages (e.g., Allocate request, Send indication, etc.) by examining the first two bits of the message:",
      "ja": "この部門のため、ChannelDataメッセージは、メッセージの最初の2つのビットを調べることにより、スタンフォーマットメッセージ（例：リクエストを割り当て、表示など）と区別できます。"
    },
    {
      "indent": 6,
      "text": "0b00: STUN-formatted message (since the first two bits of a STUN-formatted message are always zero).",
      "ja": "0B00：スタンフォーマットメッセージ（スタンフォーマットメッセージの最初の2ビットは常にゼロであるため）。"
    },
    {
      "indent": 6,
      "text": "0b01: ChannelData message (since the channel number is the first field in the ChannelData message and channel numbers fall in the range 0x4000 - 0x7FFF).",
      "ja": "0B01：ChannelDataメッセージ（チャネル番号はチャネルDATAメッセージの最初のフィールドであり、チャネル番号は0x4000-0x7fffの範囲に分類されるため）。"
    },
    {
      "indent": 6,
      "text": "0b10: Reserved",
      "ja": "0B10：予約済み"
    },
    {
      "indent": 6,
      "text": "0b11: Reserved",
      "ja": "0B11：予約済み"
    },
    {
      "indent": 3,
      "text": "The reserved values may be used in the future to extend the range of channel numbers. Thus, an implementation MUST NOT assume that a TURN message always starts with a 0 bit.",
      "ja": "予約された値は、チャネル数の範囲を拡張するために将来使用される場合があります。したがって、実装は、ターンメッセージが常に0ビットで始まると想定してはなりません。"
    },
    {
      "indent": 3,
      "text": "Channel bindings are always initiated by the client. The client can bind a channel to a peer at any time during the lifetime of the allocation. The client may bind a channel to a peer before exchanging data with it, or after exchanging data with it (using Send and Data indications) for some time, or may choose never to bind a channel to it. The client can also bind channels to some peers while not binding channels to other peers.",
      "ja": "チャネルバインディングは常にクライアントによって開始されます。クライアントは、割り当ての寿命の間、いつでもチャンネルをピアにバインドできます。クライアントは、データを交換する前にチャンネルをピアにバインドするか、しばらくの間（送信およびデータの表示を使用して）データを交換した後、またはチャネルをバインドしないことを選択することができます。クライアントは、他のピアにチャネルを拘束することなく、一部のピアにチャネルをバインドすることもできます。"
    },
    {
      "indent": 3,
      "text": "Channel bindings are specific to an allocation, so that the use of a channel number or peer transport address in a channel binding in one allocation has no impact on their use in a different allocation. If an allocation expires, all its channel bindings expire with it.",
      "ja": "チャネルバインディングは割り当てに固有のものであるため、1つの割り当てでチャネルバインディングでチャネル番号またはピアトランスポートアドレスの使用は、異なる割り当てでの使用に影響を与えません。割り当ての有効期限が切れると、すべてのチャネルバインディングが期限切れになります。"
    },
    {
      "indent": 3,
      "text": "A channel binding consists of:",
      "ja": "チャネルバインディングは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o a channel number;",
      "ja": "o チャネル番号。"
    },
    {
      "indent": 3,
      "text": "o a transport address (of the peer); and",
      "ja": "o （ピアの）輸送住所;と"
    },
    {
      "indent": 3,
      "text": "o A time-to-expiry timer.",
      "ja": "o expiryまでの時間タイム。"
    },
    {
      "indent": 3,
      "text": "Within the context of an allocation, a channel binding is uniquely identified either by the channel number or by the peer's transport address. Thus, the same channel cannot be bound to two different transport addresses, nor can the same transport address be bound to two different channels.",
      "ja": "割り当てのコンテキスト内で、チャネルバインディングは、チャネル番号またはピアの輸送住所のいずれかによって一意に識別されます。したがって、同じチャネルを2つの異なる輸送アドレスにバインドすることも、同じ輸送アドレスを2つの異なるチャネルにバインドすることもできません。"
    },
    {
      "indent": 3,
      "text": "A channel binding lasts for 10 minutes unless refreshed. Refreshing the binding (by the server receiving a ChannelBind request rebinding the channel to the same peer) resets the time-to-expiry timer back to 10 minutes.",
      "ja": "チャネルバインディングは、更新されない限り10分間続きます。バインディングを更新します（チャンネルバインド要求を受信するサーバーにより、チャンネルを同じピアにリバインしています）。"
    },
    {
      "indent": 3,
      "text": "When the channel binding expires, the channel becomes unbound. Once unbound, the channel number can be bound to a different transport address, and the transport address can be bound to a different channel number. To prevent race conditions, the client MUST wait 5 minutes after the channel binding expires before attempting to bind the channel number to a different transport address or the transport address to a different channel number.",
      "ja": "チャネルバインディングが期限切れになると、チャネルはバウンドされていません。バインドされていないと、チャネル番号は別の輸送アドレスにバインドでき、輸送アドレスは別のチャネル番号にバインドできます。レース条件を防ぐために、チャンネルのバインディングが失効してから5分後に待機する必要があります。その後、チャネル番号を別の輸送住所または輸送アドレスを別のチャネル番号にバインドしようとします。"
    },
    {
      "indent": 3,
      "text": "When binding a channel to a peer, the client SHOULD be prepared to receive ChannelData messages on the channel from the server as soon as it has sent the ChannelBind request. Over UDP, it is possible for the client to receive ChannelData messages from the server before it receives a ChannelBind success response.",
      "ja": "チャネルをピアにバインドする場合、クライアントは、チャネルBindリクエストを送信したらすぐに、サーバーからチャネル上のチャネルDataメッセージを受信する準備をする必要があります。UDPを超えると、クライアントがチャネルビンドの成功応答を受信する前に、サーバーからチャネルデータメッセージを受信することができます。"
    },
    {
      "indent": 3,
      "text": "In the other direction, the client MAY elect to send ChannelData messages before receiving the ChannelBind success response. Doing so, however, runs the risk of having the ChannelData messages dropped by the server if the ChannelBind request does not succeed for some reason (e.g., packet lost if the request is sent over UDP, or the server being unable to fulfill the request). A client that wishes to be safe should either queue the data or use Send indications until the channel binding is confirmed.",
      "ja": "他の方向では、クライアントは、ChannelBind成功応答を受信する前にChannelDataメッセージを送信することを選択できます。ただし、そうすることは、何らかの理由でChannelBindリクエストが成功しない場合、サーバーによってチャネルDataメッセージをサーバーによってドロップするリスクを実行します（たとえば、リクエストがUDPを介して送信された場合、またはサーバーがリクエストを満たせない場合にパケットが失われます）。安全であることを希望するクライアントは、データをキューにキューするか、チャネルバインディングが確認されるまで表示を送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.1. Sending a ChannelBind Request",
      "section_title": true,
      "ja": "11.1. ChannelBindリクエストの送信"
    },
    {
      "indent": 3,
      "text": "A channel binding is created or refreshed using a ChannelBind transaction. A ChannelBind transaction also creates or refreshes a permission towards the peer (see Section 8).",
      "ja": "チャネルバインディングが作成または更新されます。チャンネルビンドトランザクションを使用して。また、ChannelBindトランザクションは、ピアに対して許可を作成または更新します（セクション8を参照）。"
    },
    {
      "indent": 3,
      "text": "To initiate the ChannelBind transaction, the client forms a ChannelBind request. The channel to be bound is specified in a CHANNEL-NUMBER attribute, and the peer's transport address is specified in an XOR-PEER-ADDRESS attribute. Section 11.2 describes the restrictions on these attributes.",
      "ja": "ChannelBindトランザクションを開始するには、クライアントがChannelBindリクエストを形成します。バインドされるチャネルは、チャネル番号属性で指定され、ピアのトランスポートアドレスはXor-Peer-Address属性で指定されています。セクション11.2では、これらの属性の制限について説明します。"
    },
    {
      "indent": 3,
      "text": "Rebinding a channel to the same transport address that it is already bound to provides a way to refresh a channel binding and the corresponding permission without sending data to the peer. Note however, that permissions need to be refreshed more frequently than channels.",
      "ja": "チャンネルを同じ輸送アドレスにリバインして、すでにピアにデータを送信せずにチャネルバインディングと対応する許可を更新する方法を提供することになります。ただし、許可はチャネルよりも頻繁に更新する必要があることに注意してください。"
    },
    {
      "indent": 0,
      "text": "11.2. Receiving a ChannelBind Request",
      "section_title": true,
      "ja": "11.2. ChannelBindリクエストを受信します"
    },
    {
      "indent": 3,
      "text": "When the server receives a ChannelBind request, it processes as per Section 4 plus the specific rules mentioned here.",
      "ja": "サーバーがChannelBindリクエストを受信すると、セクション4に従って処理され、ここで説明した特定のルールが処理されます。"
    },
    {
      "indent": 3,
      "text": "The server checks the following:",
      "ja": "サーバーは以下をチェックします。"
    },
    {
      "indent": 3,
      "text": "o The request contains both a CHANNEL-NUMBER and an XOR-PEER-ADDRESS attribute;",
      "ja": "o リクエストには、チャネル番号とXor-Peer-Address属性の両方が含まれています。"
    },
    {
      "indent": 3,
      "text": "o The channel number is in the range 0x4000 through 0x7FFE (inclusive);",
      "ja": "o チャネル番号は、0x4000から0x7ffe（包括的）の範囲です。"
    },
    {
      "indent": 3,
      "text": "o The channel number is not currently bound to a different transport address (same transport address is OK);",
      "ja": "o チャネル番号は現在、別の輸送アドレスにバインドされていません（同じ輸送アドレスは問題ありません）。"
    },
    {
      "indent": 3,
      "text": "o The transport address is not currently bound to a different channel number.",
      "ja": "o 現在、輸送アドレスは別のチャネル番号にバインドされていません。"
    },
    {
      "indent": 3,
      "text": "If any of these tests fail, the server replies with a 400 (Bad Request) error.",
      "ja": "これらのテストのいずれかが失敗した場合、サーバーは400（悪い要求）エラーで返信します。"
    },
    {
      "indent": 3,
      "text": "The server MAY impose restrictions on the IP address and port values allowed in the XOR-PEER-ADDRESS attribute -- if a value is not allowed, the server rejects the request with a 403 (Forbidden) error.",
      "ja": "サーバーは、Xor-Peer-Address属性で許可されているIPアドレスとポート値に制限を課す場合があります。値が許可されていない場合、サーバーは403（禁止）エラーで要求を拒否します。"
    },
    {
      "indent": 3,
      "text": "If the request is valid, but the server is unable to fulfill the request due to some capacity limit or similar, the server replies with a 508 (Insufficient Capacity) error.",
      "ja": "要求が有効であるが、サーバーが容量制限または同様のためにリクエストを満たすことができない場合、サーバーは508（容量が不十分）エラーで返信します。"
    },
    {
      "indent": 3,
      "text": "Otherwise, the server replies with a ChannelBind success response. There are no required attributes in a successful ChannelBind response.",
      "ja": "それ以外の場合、サーバーはChannelBind Success Responseで返信します。成功したチャンネルバインド応答には、必要な属性はありません。"
    },
    {
      "indent": 3,
      "text": "If the server can satisfy the request, then the server creates or refreshes the channel binding using the channel number in the CHANNEL-NUMBER attribute and the transport address in the XOR-PEER-ADDRESS attribute. The server also installs or refreshes a permission for the IP address in the XOR-PEER-ADDRESS attribute as described in Section 8.",
      "ja": "サーバーがリクエストを満たすことができる場合、サーバーは、チャネル番号属性のチャネル番号とXor-Peer-Address属性のトランスポートアドレスを使用してチャネルバインディングを作成または再表示します。サーバーは、セクション8で説明されているように、Xor-Peer-Address属性のIPアドレスの許可をインストールまたは再表示します。"
    },
    {
      "indent": 6,
      "text": "NOTE: A server need not do anything special to implement idempotency of ChannelBind requests over UDP using the \"stateless stack approach\". Retransmitted ChannelBind requests will simply refresh the channel binding and the corresponding permission. Furthermore, the client must wait 5 minutes before binding a previously bound channel number or peer address to a different channel, eliminating the possibility that the transaction would initially fail but succeed on a retransmission.",
      "ja": "注：サーバーは、「Stateless Stackアプローチ」を使用して、UDPを介してChannelBind要求のiDempotencyを実装するために特別なことを行う必要はありません。再送信されたChannelBindリクエストは、チャネルバインディングと対応する許可を単純に更新します。さらに、クライアントは、以前にバインドされたチャネル番号またはピアアドレスを別のチャネルにバインドする前に5分間待つ必要があり、トランザクションが最初に失敗しますが、再送信で成功する可能性を排除する必要があります。"
    },
    {
      "indent": 0,
      "text": "11.3. Receiving a ChannelBind Response",
      "section_title": true,
      "ja": "11.3. ChannelBind応答を受信します"
    },
    {
      "indent": 3,
      "text": "When the client receives a ChannelBind success response, it updates its data structures to record that the channel binding is now active. It also updates its data structures to record that the corresponding permission has been installed or refreshed.",
      "ja": "クライアントがChannelBind Success Responseを受信すると、データ構造を更新して、チャネルバインディングがアクティブになっていることを記録します。また、データ構造を更新して、対応する許可がインストールまたは更新されたことを記録します。"
    },
    {
      "indent": 3,
      "text": "If the client receives a ChannelBind failure response that indicates that the channel information is out-of-sync between the client and the server (e.g., an unexpected 400 \"Bad Request\" response), then it is RECOMMENDED that the client immediately delete the allocation and start afresh with a new allocation.",
      "ja": "クライアントがチャネル情報がクライアントとサーバーの間でシンク外であることを示すチャネルバインド障害応答を受信した場合（たとえば、予期しない400の「悪い要求」応答）、クライアントがすぐに割り当てを削除することをお勧めしますそして、新しい割り当てから新たに始めます。"
    },
    {
      "indent": 0,
      "text": "11.4. The ChannelData Message",
      "section_title": true,
      "ja": "11.4. ChannelDataメッセージ"
    },
    {
      "indent": 3,
      "text": "The ChannelData message is used to carry application data between the client and the server. It has the following format:",
      "ja": "ChannelDataメッセージは、クライアントとサーバーの間にアプリケーションデータを伝達するために使用されます。次の形式があります。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|         Channel Number        |            Length             |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                                                               |\n/                       Application Data                        /\n/                                                               /\n|                                                               |\n|                               +-------------------------------+\n|                               |\n+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Channel Number field specifies the number of the channel on which the data is traveling, and thus the address of the peer that is sending or is to receive the data.",
      "ja": "チャネル番号フィールドは、データが移動しているチャネルの数、したがって、データを送信または受信するピアのアドレスを指定します。"
    },
    {
      "indent": 3,
      "text": "The Length field specifies the length in bytes of the application data field (i.e., it does not include the size of the ChannelData header). Note that 0 is a valid length.",
      "ja": "長さフィールドは、アプリケーションデータフィールドのバイト単位の長さを指定します（つまり、チャネルDataヘッダーのサイズは含まれません）。0は有効な長さであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The Application Data field carries the data the client is trying to send to the peer, or that the peer is sending to the client.",
      "ja": "アプリケーションデータフィールドには、クライアントがピアに送信しようとしているデータ、またはピアがクライアントに送信しているデータが搭載されています。"
    },
    {
      "indent": 0,
      "text": "11.5. Sending a ChannelData Message",
      "section_title": true,
      "ja": "11.5. ChannelDataメッセージの送信"
    },
    {
      "indent": 3,
      "text": "Once a client has bound a channel to a peer, then when the client has data to send to that peer it may use either a ChannelData message or a Send indication; that is, the client is not obligated to use the channel when it exists and may freely intermix the two message types when sending data to the peer. The server, on the other hand, MUST use the ChannelData message if a channel has been bound to the peer.",
      "ja": "クライアントがチャネルをピアにバインドすると、クライアントがそのピアに送信するデータを持っている場合、チャンネルDataメッセージまたは送信表示のいずれかを使用できます。つまり、クライアントは、チャンネルが存在するときに使用する義務がなく、ピアにデータを送信するときに2つのメッセージタイプを自由に混合することができます。一方、サーバーは、チャネルがピアにバインドされている場合は、チャネルDataメッセージを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "The fields of the ChannelData message are filled in as described in Section 11.4.",
      "ja": "ChannelDataメッセージのフィールドは、セクション11.4で説明されているように記入されています。"
    },
    {
      "indent": 3,
      "text": "Over TCP and TLS-over-TCP, the ChannelData message MUST be padded to a multiple of four bytes in order to ensure the alignment of subsequent messages. The padding is not reflected in the length field of the ChannelData message, so the actual size of a ChannelData message (including padding) is (4 + Length) rounded up to the nearest multiple of 4. Over UDP, the padding is not required but MAY be included.",
      "ja": "TCPおよびTLS-over-TCPでは、後続のメッセージのアライメントを確保するために、チャネルDATAメッセージを4バイトの倍数にパッドでパッドに入れなければなりません。パディングはチャネルデータの長さフィールドに反映されていないため、チャネルデータの実際のサイズ（パディングを含む）は（4の長さ）の最寄りの倍数に丸められています。含まれます。"
    },
    {
      "indent": 3,
      "text": "The ChannelData message is then sent on the 5-tuple associated with the allocation.",
      "ja": "次に、チャンネルDataメッセージは、割り当てに関連付けられた5タプルに送信されます。"
    },
    {
      "indent": 0,
      "text": "11.6. Receiving a ChannelData Message",
      "section_title": true,
      "ja": "11.6. ChannelDataメッセージを受信します"
    },
    {
      "indent": 3,
      "text": "The receiver of the ChannelData message uses the first two bits to distinguish it from STUN-formatted messages, as described above. If the message uses a value in the reserved range (0x8000 through 0xFFFF), then the message is silently discarded.",
      "ja": "ChannelDataメッセージの受信機は、上記のように、最初の2つのビットを使用してスタンフォーマットメッセージと区別します。メッセージが予約範囲（0x8000〜0xffff）の値を使用する場合、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received in a UDP datagram, and if the UDP datagram is too short to contain the claimed length of the ChannelData message (i.e., the UDP header length field value is less than the ChannelData header length field value + 4 + 8), then the message is silently discarded.",
      "ja": "ChannelDataメッセージがUDPデータグラムで受信され、UDPデータグラムが短すぎてChannelDataメッセージの主張された長さを含めることができない場合（つまり、UDPヘッダー長のフィールド値はチャネルDataヘッダー長さフィールド値4 8よりも少ない）、その後、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received over TCP or over TLS-over-TCP, then the actual length of the ChannelData message is as described in Section 11.5.",
      "ja": "ChannelDataメッセージがTCPまたはTLS-Over-TCPを介して受信された場合、ChannelDataメッセージの実際の長さはセクション11.5で説明されています。"
    },
    {
      "indent": 3,
      "text": "If the ChannelData message is received on a channel that is not bound to any peer, then the message is silently discarded.",
      "ja": "ChannelDataメッセージがピアにバインドされていないチャネルで受信された場合、メッセージは静かに破棄されます。"
    },
    {
      "indent": 3,
      "text": "On the client, it is RECOMMENDED that the client discard the ChannelData message if the client believes there is no active permission towards the peer. On the server, the receipt of a ChannelData message MUST NOT refresh either the channel binding or the permission towards the peer.",
      "ja": "クライアントでは、クライアントがピアに対して積極的な許可がないとクライアントが信じている場合、クライアントがチャンネルDataメッセージを破棄することをお勧めします。サーバーでは、チャネルDataメッセージの受信を、チャネルバインディングまたはピアに対する許可を更新してはなりません。"
    },
    {
      "indent": 3,
      "text": "On the server, if no errors are detected, the server relays the application data to the peer by forming a UDP datagram as follows:",
      "ja": "サーバーでは、エラーが検出されない場合、サーバーは次のようにUDPデータグラムを形成することにより、アプリケーションデータをピアにリレーします。"
    },
    {
      "indent": 3,
      "text": "o the source transport address is the relayed transport address of the allocation, where the allocation is determined by the 5-tuple on which the ChannelData message arrived;",
      "ja": "o ソーストランスポートアドレスは、割り当ての中継輸送アドレスであり、割り当てはチャネルDATAメッセージが届いた5タプルによって決定されます。"
    },
    {
      "indent": 3,
      "text": "o the destination transport address is the transport address to which the channel is bound;",
      "ja": "o 宛先輸送アドレスは、チャネルがバインドされる輸送アドレスです。"
    },
    {
      "indent": 3,
      "text": "o the data following the UDP header is the contents of the data field of the ChannelData message.",
      "ja": "o UDPヘッダーに続くデータは、ChannelDataメッセージのデータフィールドの内容です。"
    },
    {
      "indent": 3,
      "text": "The resulting UDP datagram is then sent to the peer. Note that if the Length field in the ChannelData message is 0, then there will be no data in the UDP datagram, but the UDP datagram is still formed and sent.",
      "ja": "結果のUDPデータグラムがピアに送信されます。ChannelDataメッセージの長さフィールドが0の場合、UDPデータグラムにはデータがありませんが、UDPデータグラムはまだ形成されて送信されます。"
    },
    {
      "indent": 0,
      "text": "11.7. Relaying Data from the Peer",
      "section_title": true,
      "ja": "11.7. ピアからのデータの中継"
    },
    {
      "indent": 3,
      "text": "When the server receives a UDP datagram on the relayed transport address associated with an allocation, the server processes it as described in Section 10.3. If that section indicates that a ChannelData message should be sent (because there is a channel bound to the peer that sent to the UDP datagram), then the server forms and sends a ChannelData message as described in Section 11.5.",
      "ja": "サーバーが割り当てに関連付けられたリレー輸送アドレスのUDPデータグラムを受信すると、サーバーはセクション10.3で説明されているように処理します。そのセクションがチャネルデータを送信する必要があることを示している場合（UDPデータグラムに送信されたピアにバインドされたチャネルがあるため）、サーバーはセクション11.5で説明されているようにチャネルデータをフォームして送信します。"
    },
    {
      "indent": 0,
      "text": "12. IP Header Fields",
      "section_title": true,
      "ja": "12. IPヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "This section describes how the server sets various fields in the IP header when relaying between the client and the peer or vice versa. The descriptions in this section apply: (a) when the server sends a UDP datagram to the peer, or (b) when the server sends a Data indication or ChannelData message to the client over UDP transport. The descriptions in this section do not apply to TURN messages sent over TCP or TLS transport from the server to the client.",
      "ja": "このセクションでは、クライアントとピアの間で中継するときにサーバーがIPヘッダーにさまざまなフィールドを設定する方法について説明します。このセクションの説明が適用されます。（a）サーバーがUDPデータグラムをピアに送信したとき、または（b）サーバーがUDPトランスポートを介してデータ表示またはチャネルデータをクライアントに送信するとき。このセクションの説明は、サーバーからクライアントへのTCPまたはTLSトランスポートを介して送信されたメッセージをターンすることには適用されません。"
    },
    {
      "indent": 3,
      "text": "The descriptions below have two parts: a preferred behavior and an alternate behavior. The server SHOULD implement the preferred behavior, but if that is not possible for a particular field, then it SHOULD implement the alternative behavior.",
      "ja": "以下の説明には、好みの動作と別の動作の2つの部分があります。サーバーは優先動作を実装する必要がありますが、特定のフィールドでそれが不可能な場合は、代替動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Time to Live (TTL) field",
      "ja": "ライブ（TTL）フィールドの時間"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: If the incoming value is 0, then the drop the incoming packet. Otherwise, set the outgoing Time to Live/Hop Count to one less than the incoming value.",
      "ja": "優先挙動：着信値が0の場合、着信パケットをドロップします。それ以外の場合は、発信時間をライブ/ホップカウントに設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to the default for outgoing packets.",
      "ja": "代替動作：送信パケットのデフォルトに送信値を設定します。"
    },
    {
      "indent": 3,
      "text": "Differentiated Services Code Point (DSCP) field [RFC2474]",
      "ja": "差別化されたサービスコードポイント（DSCP）フィールド[RFC2474]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Set the outgoing value to the incoming value, unless the server includes a differentiated services classifier and marker [RFC2474].",
      "ja": "優先行動：サーバーに差別化されたサービス分類器とマーカー[RFC2474]が含まれていない限り、発信値を着信値に設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to a fixed value, which by default is Best Effort unless configured otherwise.",
      "ja": "代替動作：発信値を固定値に設定します。これは、特に構成されていない限り、デフォルトでは最適な努力です。"
    },
    {
      "indent": 6,
      "text": "In both cases, if the server is immediately adjacent to a differentiated services classifier and marker, then DSCP MAY be set to any arbitrary value in the direction towards the classifier.",
      "ja": "どちらの場合も、サーバーが差別化されたサービス分類器とマーカーにすぐに隣接している場合、DSCPは分類器に向かって方向の任意の値に設定できます。"
    },
    {
      "indent": 3,
      "text": "Explicit Congestion Notification (ECN) field [RFC3168]",
      "ja": "明示的な混雑通知（ECN）フィールド[RFC3168]"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: Set the outgoing value to the incoming value, UNLESS the server is doing Active Queue Management, the incoming ECN field is ECT(1) (=0b01) or ECT(0) (=0b10), and the server wishes to indicate that congestion has been experienced, in which case set the outgoing value to CE (=0b11).",
      "ja": "優先挙動：サーバーがアクティブキュー管理を行っている場合を除き、発信値を着信値に設定し、着信ECNフィールドがECT（1）（= 0B01）またはECT（0）（= 0B10）であり、サーバーは示すことを望みます。その混雑は経験されており、その場合、ce（= 0b11）に送信値を設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Set the outgoing value to Not-ECT (=0b00).",
      "ja": "代替動作：発信値をnot-ect（= 0b00）に設定します。"
    },
    {
      "indent": 3,
      "text": "IPv4 Fragmentation fields",
      "ja": "IPv4断片化フィールド"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: When the server sends a packet to a peer in response to a Send indication containing the DONT-FRAGMENT attribute, then set the DF bit in the outgoing IP header to 1. In all other cases when sending an outgoing packet containing application data (e.g., Data indication, ChannelData message, or DONT-FRAGMENT attribute not included in the Send indication), copy the DF bit from the DF bit of the incoming packet that contained the application data.",
      "ja": "優先挙動：サーバーがfragment属性を含む送信指示に応じてパケットをピアに送信する場合、発信IPヘッダーのDFビットを1に設定します。（たとえば、データ指示、ChannelDataメッセージ、または送信表示に含まれていない属性属性のない属性）は、アプリケーションデータを含む着信パケットのDFビットからDFビットをコピーします。"
    },
    {
      "indent": 6,
      "text": "Set the other fragmentation fields (Identification, More Fragments, Fragment Offset) as appropriate for a packet originating from the server.",
      "ja": "サーバーから発信するパケットに適しているように、他のフラグメンテーションフィールド（識別、より多くのフラグメント、フラグメントオフセット）を設定します。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: As described in the Preferred Behavior, except always assume the incoming DF bit is 0.",
      "ja": "代替動作：優先動作で説明されているように、着信するDFビットが0であると常に仮定します。"
    },
    {
      "indent": 6,
      "text": "In both the Preferred and Alternate Behaviors, the resulting packet may be too large for the outgoing link. If this is the case, then the normal fragmentation rules apply [RFC1122].",
      "ja": "優先挙動と代替動作の両方で、結果のパケットは、発信リンクに対して大きすぎる可能性があります。この場合、通常の断片化ルールが適用されます[RFC1122]。"
    },
    {
      "indent": 3,
      "text": "IPv4 Options",
      "ja": "IPv4オプション"
    },
    {
      "indent": 6,
      "text": "Preferred Behavior: The outgoing packet is sent without any IPv4 options.",
      "ja": "優先動作：発信パケットは、IPv4オプションなしで送信されます。"
    },
    {
      "indent": 6,
      "text": "Alternate Behavior: Same as preferred.",
      "ja": "代替動作：優先と同じ。"
    },
    {
      "indent": 0,
      "text": "13. New STUN Methods",
      "section_title": true,
      "ja": "13. 新しいスタン方法"
    },
    {
      "indent": 3,
      "text": "This section lists the codepoints for the new STUN methods defined in this specification. See elsewhere in this document for the semantics of these new methods.",
      "ja": "このセクションには、この仕様で定義されている新しいスタンメソッドのコードポイントをリストします。これらの新しい方法のセマンティクスについては、このドキュメントの他の場所をご覧ください。"
    },
    {
      "indent": 3,
      "text": "0x003 : Allocate (only request/response semantics defined) 0x004 : Refresh (only request/response semantics defined) 0x006 : Send (only indication semantics defined) 0x007 : Data (only indication semantics defined) 0x008 : CreatePermission (only request/response semantics defined 0x009 : ChannelBind (only request/response semantics defined)",
      "ja": "0x003：割り当て（リクエスト/応答セマンティクスのみが定義されている）0x004：更新（リクエスト/応答セマンティクスのみが定義された）0x009：ChannelBind（リクエスト/応答セマンティクスのみが定義されています）"
    },
    {
      "indent": 0,
      "text": "14. New STUN Attributes",
      "section_title": true,
      "ja": "14. 新しいスタン属性"
    },
    {
      "indent": 3,
      "text": "This STUN extension defines the following new attributes:",
      "ja": "このスタンエクステンションは、次の新しい属性を定義します。"
    },
    {
      "indent": 5,
      "text": "0x000C: CHANNEL-NUMBER 0x000D: LIFETIME 0x0010: Reserved (was BANDWIDTH) 0x0012: XOR-PEER-ADDRESS 0x0013: DATA 0x0016: XOR-RELAYED-ADDRESS 0x0018: EVEN-PORT 0x0019: REQUESTED-TRANSPORT 0x001A: DONT-FRAGMENT 0x0021: Reserved (was TIMER-VAL) 0x0022: RESERVATION-TOKEN",
      "ja": "0x000C：チャンネル番号0x000D：Lifetime 0x0010：予約済み（帯域幅）0x0012：XOR-PEER-ADDRESS 0X0013：データ0x0016：XOR-RELAYED-ADDRESS 0X0018：ven-port 0x0019：要求されたトランスポート0x001a（Timer-valでした）0x0022：予約トークン"
    },
    {
      "indent": 3,
      "text": "Some of these attributes have lengths that are not multiples of 4. By the rules of STUN, any attribute whose length is not a multiple of 4 bytes MUST be immediately followed by 1 to 3 padding bytes to ensure the next attribute (if any) would start on a 4-byte boundary (see [RFC5389]).",
      "ja": "これらの属性のいくつかには、4の倍数ではない長さがあります。4バイトの境界から始めます（[rfc5389]を参照）。"
    },
    {
      "indent": 0,
      "text": "14.1. CHANNEL-NUMBER",
      "section_title": true,
      "ja": "14.1. チャンネル番号"
    },
    {
      "indent": 3,
      "text": "The CHANNEL-NUMBER attribute contains the number of the channel. The value portion of this attribute is 4 bytes long and consists of a 16- bit unsigned integer, followed by a two-octet RFFU (Reserved For Future Use) field, which MUST be set to 0 on transmission and MUST be ignored on reception.",
      "ja": "チャネル番号属性には、チャネルの数が含まれています。この属性の値部分は4バイトの長さで、16ビットの署名されていない整数で構成され、その後に2オクテットのRFFU（将来の使用のために予約されています）フィールドが続きます。これは、送信時に0に設定する必要があり、受信で無視する必要があります。"
    },
    {
      "indent": 5,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Channel Number         |         RFFU = 0              |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "14.2. LIFETIME",
      "section_title": true,
      "ja": "14.2. 一生"
    },
    {
      "indent": 3,
      "text": "The LIFETIME attribute represents the duration for which the server will maintain an allocation in the absence of a refresh. The value portion of this attribute is 4-bytes long and consists of a 32-bit unsigned integral value representing the number of seconds remaining until expiration.",
      "ja": "Lifetime属性は、リフレッシュがない場合にサーバーが割り当てを維持する期間を表します。この属性の値部分は4バイトの長さで、有効期限が切れるまで残りの秒数を表す32ビットの符号なしの積分値で構成されています。"
    },
    {
      "indent": 0,
      "text": "14.3. XOR-PEER-ADDRESS",
      "section_title": true,
      "ja": "14.3. Xor-Peer-Address"
    },
    {
      "indent": 3,
      "text": "The XOR-PEER-ADDRESS specifies the address and port of the peer as seen from the TURN server. (For example, the peer's server-reflexive transport address if the peer is behind a NAT.) It is encoded in the same way as XOR-MAPPED-ADDRESS [RFC5389].",
      "ja": "Xor-Peer-Addressは、ターンサーバーから見たピアのアドレスとポートを指定します。（たとえば、ピアがNATの背後にある場合、ピアのサーバー反射トランスポートアドレス。）Xor-Mapped-Address [RFC5389]と同じ方法でエンコードされます。"
    },
    {
      "indent": 0,
      "text": "14.4. DATA",
      "section_title": true,
      "ja": "14.4. データ"
    },
    {
      "indent": 3,
      "text": "The DATA attribute is present in all Send and Data indications. The value portion of this attribute is variable length and consists of the application data (that is, the data that would immediately follow the UDP header if the data was been sent directly between the client and the peer). If the length of this attribute is not a multiple of 4, then padding must be added after this attribute.",
      "ja": "データ属性は、すべての送信およびデータ指示に存在します。この属性の値部分は変動長であり、アプリケーションデータ（つまり、データがクライアントとピア間で直接送信された場合にUDPヘッダーに直接従うデータ）で構成されます。この属性の長さが4の倍数でない場合、この属性の後にパディングを追加する必要があります。"
    },
    {
      "indent": 0,
      "text": "14.5. XOR-RELAYED-ADDRESS",
      "section_title": true,
      "ja": "14.5. xor-relayed-address"
    },
    {
      "indent": 3,
      "text": "The XOR-RELAYED-ADDRESS is present in Allocate responses. It specifies the address and port that the server allocated to the client. It is encoded in the same way as XOR-MAPPED-ADDRESS [RFC5389].",
      "ja": "XORリレードアドレスは、割り当て応答に存在します。サーバーがクライアントに割り当てたアドレスとポートを指定します。Xor-Mapp-Address [RFC5389]と同じ方法でエンコードされています。"
    },
    {
      "indent": 0,
      "text": "14.6. EVEN-PORT",
      "section_title": true,
      "ja": "14.6. 均一なポート"
    },
    {
      "indent": 3,
      "text": "This attribute allows the client to request that the port in the relayed transport address be even, and (optionally) that the server reserve the next-higher port number. The value portion of this attribute is 1 byte long. Its format is:",
      "ja": "この属性により、クライアントは、中継された輸送アドレスのポートが均等になり、（オプションでは）サーバーが次の高さのポート番号を予約することをクライアントに要求できます。この属性の値部分は1バイトの長さです。その形式は次のとおりです。"
    },
    {
      "indent": 5,
      "text": " 0\n 0 1 2 3 4 5 6 7\n+-+-+-+-+-+-+-+-+\n|R|    RFFU     |\n+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value contains a single 1-bit flag:",
      "ja": "値には、単一の1ビットフラグが含まれています。"
    },
    {
      "indent": 3,
      "text": "R: If 1, the server is requested to reserve the next-higher port number (on the same IP address) for a subsequent allocation. If 0, no such reservation is requested.",
      "ja": "R：1の場合、サーバーは次の割り当てのために次の高さのポート番号（同じIPアドレス）を予約するように要求されます。0の場合、そのような予約は要求されません。"
    },
    {
      "indent": 3,
      "text": "The other 7 bits of the attribute's value must be set to zero on transmission and ignored on reception.",
      "ja": "属性の値の他の7ビットは、送信時にゼロに設定し、受信で無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Since the length of this attribute is not a multiple of 4, padding must immediately follow this attribute.",
      "ja": "この属性の長さは4の倍数ではないため、パディングはすぐにこの属性に従う必要があります。"
    },
    {
      "indent": 0,
      "text": "14.7. REQUESTED-TRANSPORT",
      "section_title": true,
      "ja": "14.7. 要求された輸送"
    },
    {
      "indent": 3,
      "text": "This attribute is used by the client to request a specific transport\nprotocol for the allocated transport address.  The value of this\nattribute is 4 bytes with the following format:\n   0                   1                   2                   3\n   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  |    Protocol   |                    RFFU                       |\n  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The Protocol field specifies the desired protocol. The codepoints used in this field are taken from those allowed in the Protocol field in the IPv4 header and the NextHeader field in the IPv6 header [Protocol-Numbers]. This specification only allows the use of codepoint 17 (User Datagram Protocol).",
      "ja": "プロトコルフィールドは、目的のプロトコルを指定します。このフィールドで使用されるコードポイントは、IPv4ヘッダーのプロトコルフィールドとIPv6ヘッダーのNexTheaderフィールド[Protocol-Numbers]で許可されたコードから取得されます。この仕様では、CodePoint 17（ユーザーデータグラムプロトコル）の使用のみが可能です。"
    },
    {
      "indent": 3,
      "text": "The RFFU field MUST be set to zero on transmission and MUST be ignored on reception. It is reserved for future uses.",
      "ja": "RFFUフィールドは、送信時にゼロに設定する必要があり、受信で無視する必要があります。将来の用途のために予約されています。"
    },
    {
      "indent": 0,
      "text": "14.8. DONT-FRAGMENT",
      "section_title": true,
      "ja": "14.8. fragmentではありません"
    },
    {
      "indent": 3,
      "text": "This attribute is used by the client to request that the server set the DF (Don't Fragment) bit in the IP header when relaying the application data onward to the peer. This attribute has no value part and thus the attribute length field is 0.",
      "ja": "この属性は、アプリケーションデータをピアに中継するときに、サーバーがIPヘッダーにDF（断片化しない）ビットを設定するようにクライアントによって使用されます。この属性には値部分がないため、属性の長さフィールドは0です。"
    },
    {
      "indent": 0,
      "text": "14.9. RESERVATION-TOKEN",
      "section_title": true,
      "ja": "14.9. 予約のトークン"
    },
    {
      "indent": 3,
      "text": "The RESERVATION-TOKEN attribute contains a token that uniquely identifies a relayed transport address being held in reserve by the server. The server includes this attribute in a success response to tell the client about the token, and the client includes this attribute in a subsequent Allocate request to request the server use that relayed transport address for the allocation.",
      "ja": "予約トークン属性には、サーバーが予約しているリレー輸送アドレスを独自に識別するトークンが含まれています。サーバーには、クライアントにトークンについてクライアントに伝えるための成功応答にこの属性を含め、クライアントはこの属性を後続の割り当て要求に含めて、割り当てのためにリレーしたトランスポートアドレスをリレーしたサーバーを要求します。"
    },
    {
      "indent": 3,
      "text": "The attribute value is 8 bytes and contains the token value.",
      "ja": "属性値は8バイトで、トークン値が含まれています。"
    },
    {
      "indent": 0,
      "text": "15. New STUN Error Response Codes",
      "section_title": true,
      "ja": "15. 新しいスタンエラー応答コード"
    },
    {
      "indent": 3,
      "text": "This document defines the following new error response codes:",
      "ja": "このドキュメントは、次の新しいエラー応答コードを定義します。"
    },
    {
      "indent": 3,
      "text": "403 (Forbidden): The request was valid but cannot be performed due to administrative or similar restrictions.",
      "ja": "403（禁止）：リクエストは有効でしたが、管理的または同様の制限のために実行することはできません。"
    },
    {
      "indent": 3,
      "text": "437 (Allocation Mismatch): A request was received by the server that requires an allocation to be in place, but no allocation exists, or a request was received that requires no allocation, but an allocation exists.",
      "ja": "437（割り当てのミスマッチ）：割り当てを必要とするが、割り当ては存在しないか、割り当てを必要としないリクエストが受信されたが、割り当てが存在するリクエストが存在する、サーバーによってリクエストが受信されました。"
    },
    {
      "indent": 3,
      "text": "441 (Wrong Credentials): The credentials in the (non-Allocate) request do not match those used to create the allocation.",
      "ja": "441（間違った資格情報）：（非アロケート）要求の資格情報は、割り当てを作成するために使用されるものと一致しません。"
    },
    {
      "indent": 3,
      "text": "442 (Unsupported Transport Protocol): The Allocate request asked the server to use a transport protocol between the server and the peer that the server does not support. NOTE: This does NOT refer to the transport protocol used in the 5-tuple.",
      "ja": "442（サポートされていないTransport Protocol）：割り当て要求は、サーバーとサーバーがサポートしていないピア間のトランスポートプロトコルを使用するようサーバーに求めました。注：これは、5タプルで使用されている輸送プロトコルを指すものではありません。"
    },
    {
      "indent": 3,
      "text": "486 (Allocation Quota Reached): No more allocations using this username can be created at the present time.",
      "ja": "486（到達した割り当てクォータ）：このユーザー名を使用した割り当ては、現時点では作成できません。"
    },
    {
      "indent": 3,
      "text": "508 (Insufficient Capacity): The server is unable to carry out the request due to some capacity limit being reached. In an Allocate response, this could be due to the server having no more relayed transport addresses available at that time, having none with the requested properties, or the one that corresponds to the specified reservation token is not available.",
      "ja": "508（容量が不十分）：容量制限に達したため、サーバーは要求を実行できません。割り当ての応答では、これは、当時利用可能な輸送アドレスをリレーしなく、要求されたプロパティを持たないサーバーがないこと、または指定された予約トークンに対応するプロパティを持たないことが原因である可能性があります。"
    },
    {
      "indent": 0,
      "text": "16. Detailed Example",
      "section_title": true,
      "ja": "16. 詳細な例"
    },
    {
      "indent": 3,
      "text": "This section gives an example of the use of TURN, showing in detail the contents of the messages exchanged. The example uses the network diagram shown in the Overview (Figure 1).",
      "ja": "このセクションでは、ターンの使用の例を示し、交換されたメッセージの内容を詳細に示します。この例では、概要に示すネットワーク図を使用します（図1）。"
    },
    {
      "indent": 3,
      "text": "For each message, the attributes included in the message and their values are shown. For convenience, values are shown in a human-readable format rather than showing the actual octets; for example, \"XOR-RELAYED-ADDRESS=192.0.2.15:9000\" shows that the XOR-RELAYED-ADDRESS attribute is included with an address of 192.0.2.15 and a port of 9000, here the address and port are shown before the xor-ing is done. For attributes with string-like values (e.g., SOFTWARE=\"Example client, version 1.03\" and NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"), the value of the attribute is shown in quotes for readability, but these quotes do not appear in the actual value.",
      "ja": "各メッセージについて、メッセージに含まれる属性とその値が表示されます。便宜上、値は実際のオクテットを表示するのではなく、人間の読み取り可能な形式で表示されます。たとえば、「xor-lelayed-address = 192.0.2.15：9000」は、Xor-lelayed-address属性が192.0.2.15のアドレスと9000のポートに含まれていることを示しています。-ingが完了しました。文字列のような値を持つ属性（例：ソフトウェア= \"例クライアント、バージョン1.03\"およびnonce = \"adl7w7pedu4hke72jdaqvbamcr6h39sm\"）の場合、属性の値は読みやすさのための引用符で表示されますが、これらの引用は実際の値には表示されません。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |                                    |             |             |\n  |--- Allocate request -------------->|             |             |\n  |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |\n  |    SOFTWARE=\"Example client, version 1.03\"       |             |\n  |    LIFETIME=3600 (1 hour)          |             |             |\n  |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |\n  |    DONT-FRAGMENT                   |             |             |\n  |                                    |             |             |\n  |<-- Allocate error response --------|             |             |\n  |    Transaction-Id=0xA56250D3F17ABE679422DE85     |             |\n  |    SOFTWARE=\"Example server, version 1.17\"       |             |\n  |    ERROR-CODE=401 (Unauthorized)   |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n  |                                    |             |             |\n  |--- Allocate request -------------->|             |             |\n  |    Transaction-Id=0xC271E932AD7446A32C234492     |             |\n  |    SOFTWARE=\"Example client 1.03\"  |             |             |\n  |    LIFETIME=3600 (1 hour)          |             |             |\n  |    REQUESTED-TRANSPORT=17 (UDP)    |             |             |\n  |    DONT-FRAGMENT                   |             |             |\n  |    USERNAME=\"George\"               |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |\n  |                                    |             |             |\n  |<-- Allocate success response ------|             |             |\n  |    Transaction-Id=0xC271E932AD7446A32C234492     |             |\n  |    SOFTWARE=\"Example server, version 1.17\"       |             |\n  |    LIFETIME=1200 (20 minutes)      |             |             |\n  |    XOR-RELAYED-ADDRESS=192.0.2.15:50000          |             |\n  |    XOR-MAPPED-ADDRESS=192.0.2.1:7000             |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client begins by selecting a host transport address to use for the TURN session; in this example, the client has selected 10.1.1.2: 49721 as shown in Figure 1. The client then sends an Allocate request to the server at the server transport address. The client randomly selects a 96-bit transaction id of 0xA56250D3F17ABE679422DE85 for this transaction; this is encoded in the transaction id field in the fixed header. The client includes a SOFTWARE attribute that gives information about the client's software; here the value is \"Example client, version 1.03\" to indicate that this is version 1.03 of something called the Example client. The client includes the LIFETIME attribute because it wishes the allocation to have a longer lifetime than the default of 10 minutes; the value of this attribute is 3600 seconds, which corresponds to 1 hour. The client must always include a REQUESTED-TRANSPORT attribute in an Allocate request and the only value allowed by this specification is 17, which indicates UDP transport between the server and the peers. The client also includes the DONT-FRAGMENT attribute because it wishes to use the DONT-FRAGMENT attribute later in Send indications; this attribute consists of only an attribute header, there is no value part. We assume the client has not recently interacted with the server, thus the client does not include USERNAME, REALM, NONCE, or MESSAGE-INTEGRITY attribute. Finally, note that the order of attributes in a message is arbitrary (except for the MESSAGE-INTEGRITY and FINGERPRINT attributes) and the client could have used a different order.",
      "ja": "クライアントは、ターンセッションに使用するホストトランスポートアドレスを選択することから始めます。この例では、図1に示すように、クライアントは10.1.1.2：49721を選択しました。クライアントは、サーバートランスポートアドレスのサーバーに割り当て要求を送信します。クライアントは、このトランザクションのために0xA56250D3F17ABE679422DE85の96ビットトランザクションIDをランダムに選択します。これは、固定ヘッダーのトランザクションIDフィールドでエンコードされています。クライアントには、クライアントのソフトウェアに関する情報を提供するソフトウェア属性が含まれています。ここでは、値は「クライアントの例、バージョン1.03」です。これは、これがサンプルクライアントと呼ばれるもののバージョン1.03であることを示しています。クライアントには、デフォルトの10分よりも長いライフタイムを持つことを望んでいるため、Lifetime属性が含まれています。この属性の値は3600秒で、これは1時間に相当します。クライアントは常に割り当て要求に要求された輸送属性を含める必要があり、この仕様で許可される唯一の値は17です。これは、サーバーとピア間のUDP輸送を示しています。クライアントには、dont-fragment属性を後で送信表示で使用したいため、dont-fragment属性も含まれています。この属性は属性ヘッダーのみで構成されており、値部分はありません。クライアントが最近サーバーとやり取りしていないと仮定しているため、クライアントにはユーザー名、レルム、ノンセ、またはメッセージインテグリティ属性が含まれていないと仮定します。最後に、メッセージ内の属性の順序は任意であり（メッセージ統合と指紋属性を除く）、クライアントは別の注文を使用できた可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Servers require any request to be authenticated. Thus, when the server receives the initial Allocate request, it rejects the request because the request does not contain the authentication attributes. Following the procedures of the long-term credential mechanism of STUN [RFC5389], the server includes an ERROR-CODE attribute with a value of 401 (Unauthorized), a REALM attribute that specifies the authentication realm used by the server (in this case, the server's domain \"example.com\"), and a nonce value in a NONCE attribute. The server also includes a SOFTWARE attribute that gives information about the server's software.",
      "ja": "サーバーは、リクエストを認証する必要があります。したがって、サーバーが最初の割り当て要求を受信すると、リクエストに認証属性が含まれていないため、リクエストが拒否されます。Stun [RFC5389]の長期的な資格メカニズムの手順に従って、サーバーには、401（不正）の値を持つエラーコード属性が含まれています。サーバーのドメイン「Example.com」）、およびNonCe属性のNonCe値。サーバーには、サーバーのソフトウェアに関する情報を提供するソフトウェア属性も含まれています。"
    },
    {
      "indent": 3,
      "text": "The client, upon receipt of the 401 error, re-attempts the Allocate request, this time including the authentication attributes. The client selects a new transaction id, and then populates the new Allocate request with the same attributes as before. The client includes a USERNAME attribute and uses the realm value received from the server to help it determine which value to use; here the client is configured to use the username \"George\" for the realm \"example.com\". The client also includes the REALM and NONCE attributes, which are just copied from the 401 error response. Finally, the client includes a MESSAGE-INTEGRITY attribute as the last attribute in the message, whose value is a Hashed Message Authentication Code - Secure Hash Algorithm 1 (HMAC-SHA1) hash over the contents of the message (shown as just \"...\" above); this HMAC-SHA1 computation includes a password value. Thus, an attacker cannot compute the message integrity value without somehow knowing the secret password.",
      "ja": "クライアントは、401エラーを受け取ったときに、認証属性を含む今回は割り当て要求を再検討します。クライアントは、新しいトランザクションIDを選択し、以前と同じ属性を新しい割り当て要求に入力します。クライアントには、ユーザー名属性を含み、サーバーから受信したレルム値を使用して、使用する値を決定するのに役立ちます。ここで、クライアントは、領域「example.com」にユーザー名「ジョージ」を使用するように構成されています。クライアントには、401エラー応答からコピーされた領域とNonCE属性も含まれています。最後に、クライアントには、メッセージの最後の属性としてメッセージインテグリティ属性を含めます。その値は、メッセージの内容（単に「。。\" その上）;このHMAC-SHA1計算には、パスワード値が含まれています。したがって、攻撃者は、秘密のパスワードを何らかの形で知ることなく、メッセージの整合性値を計算することはできません。"
    },
    {
      "indent": 3,
      "text": "The server, upon receipt of the authenticated Allocate request, checks that everything is OK, then creates an allocation. The server replies with an Allocate success response. The server includes a LIFETIME attribute giving the lifetime of the allocation; here, the server has reduced the client's requested 1-hour lifetime to just 20 minutes, because this particular server doesn't allow lifetimes longer than 20 minutes. The server includes an XOR-RELAYED-ADDRESS attribute whose value is the relayed transport address of the allocation. The server includes an XOR-MAPPED-ADDRESS attribute whose value is the server-reflexive address of the client; this value is not used otherwise in TURN but is returned as a convenience to the client. The server includes a MESSAGE-INTEGRITY attribute to authenticate the response and to ensure its integrity; note that the response does not contain the USERNAME, REALM, and NONCE attributes. The server also includes a SOFTWARE attribute.",
      "ja": "サーバーは、認証された割り当てリクエストを受信すると、すべてが問題ないことを確認し、割り当てを作成します。サーバーは、成功応答を割り当てて返信します。サーバーには、割り当ての寿命を与える生涯属性が含まれています。ここで、サーバーはクライアントの要求された1時間の寿命をわずか20分に短縮しました。この特定のサーバーは20分以上の寿命が許されないためです。サーバーには、XOR-LELAYED-ADDRESS属性が含まれています。サーバーには、クライアントのサーバー反射アドレスです。この値はそうでない場合は使用されませんが、クライアントの利便性として返されます。サーバーには、応答を認証し、その整合性を確保するためのメッセージインテグリティ属性が含まれています。応答には、ユーザー名、レルム、およびNonCE属性が含まれていないことに注意してください。サーバーにはソフトウェア属性も含まれています。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |--- CreatePermission request ------>|             |             |\n  |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |\n  |    XOR-PEER-ADDRESS=192.0.2.150:0  |             |             |\n  |    USERNAME=\"George\"               |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |\n  |                                    |             |             |\n  |<-- CreatePermission success resp.--|             |             |\n  |    Transaction-Id=0xE5913A8F460956CA277D3319     |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client then creates a permission towards Peer A in preparation for sending it some application data. This is done through a CreatePermission request. The XOR-PEER-ADDRESS attribute contains the IP address for which a permission is established (the IP address of peer A); note that the port number in the attribute is ignored when used in a CreatePermission request, and here it has been set to 0; also, note how the client uses Peer A's server-reflexive IP address and not its (private) host address. The client uses the same username, realm, and nonce values as in the previous request on the allocation. Though it is allowed to do so, the client has chosen not to include a SOFTWARE attribute in this request.",
      "ja": "次に、クライアントは、いくつかのアプリケーションデータを送信するために、ピアAに向けて許可を作成します。これは、createpermissionリクエストを介して行われます。Xor-Peer-Address属性には、許可が確立されるIPアドレスが含まれています（ピアAのIPアドレス）。CreatePermissionリクエストで使用されると、属性内のポート番号が無視され、ここで0に設定されていることに注意してください。また、クライアントが（プライベート）ホストアドレスではなく、ピアAのサーバー反射IPアドレスを使用する方法に注意してください。クライアントは、割り当ての前の要求と同じユーザー名、レルム、およびNonCE値を使用します。そうすることは許可されていますが、クライアントはこのリクエストにソフトウェア属性を含めないことを選択しています。"
    },
    {
      "indent": 3,
      "text": "The server receives the CreatePermission request, creates the corresponding permission, and then replies with a CreatePermission success response. Like the client, the server chooses not to include the SOFTWARE attribute in its reply. Again, note how success responses contain a MESSAGE-INTEGRITY attribute (assuming the server uses the long-term credential mechanism), but no USERNAME, REALM, and NONCE attributes.",
      "ja": "サーバーは、createpermissionリクエストを受信し、対応する許可を作成し、createpermission成功応答で返信します。クライアントと同様に、サーバーはその返信にソフトウェア属性を含めないことを選択します。繰り返しになりますが、成功応答にメッセージインテグリティ属性がどのように含まれているかに注意してください（サーバーが長期的な資格情報メカニズムを使用すると仮定）が、ユーザー名、レルム、およびNonCE属性はありません。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |--- Send indication --------------->|             |             |\n  |    Transaction-Id=0x1278E9ACA2711637EF7D3328     |             |\n  |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |\n  |    DONT-FRAGMENT                   |             |             |\n  |    DATA=...                        |             |             |\n  |                                    |-- UDP dgm ->|             |\n  |                                    |  data=...   |             |\n  |                                    |             |             |\n  |                                    |<- UDP dgm --|             |\n  |                                    |  data=...   |             |\n  |<-- Data indication ----------------|             |             |\n  |    Transaction-Id=0x8231AE8F9242DA9FF287FEFF     |             |\n  |    XOR-PEER-ADDRESS=192.0.2.150:32102            |             |\n  |    DATA=...                        |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client now sends application data to Peer A using a Send indication. Peer A's server-reflexive transport address is specified in the XOR-PEER-ADDRESS attribute, and the application data (shown here as just \"...\") is specified in the DATA attribute. The client is doing a form of path MTU discovery at the application layer and thus specifies (by including the DONT-FRAGMENT attribute) that the server should set the DF bit in the UDP datagram to send to the peer. Indications cannot be authenticated using the long-term credential mechanism of STUN, so no MESSAGE-INTEGRITY attribute is included in the message. An application wishing to ensure that its data is not altered or forged must integrity-protect its data at the application level.",
      "ja": "クライアントは、送信表示を使用してピアAにアプリケーションデータを送信します。Peer Aのサーバー反射トランスポートアドレスは、Xor-Peer-Address属性で指定されており、アプリケーションデータ（ここでは「...」として表示されます）は、データ属性で指定されています。クライアントは、アプリケーションレイヤーでPATH MTU発見の形式を実行しているため、サーバーがUDPデータグラムにDFビットを設定してピアに送信することを（fragment属性を含めることにより）（fragment属性を含めること）を指定しています。STUNの長期的な資格情報メカニズムを使用して適応症を認証することはできないため、メッセージにメッセージに含まれていません。データが変更または偽造されないようにしたいアプリケーションは、アプリケーションレベルでデータを整合性に保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the Send indication, the server extracts the application data and sends it in a UDP datagram to Peer A, with the relayed transport address as the source transport address of the datagram, and with the DF bit set as requested. Note that, had the client not previously established a permission for Peer A's server-reflexive IP address, then the server would have silently discarded the Send indication instead.",
      "ja": "送信指示を受け取ると、サーバーはアプリケーションデータを抽出し、UDPデータグラムでPEER Aに送信し、リレーした輸送アドレスをデータグラムのソーストランスポートアドレスとして、DF BITを要求に従って設定します。クライアントが以前にPeer Aのサーバー反射IPアドレスの許可を確立していなかった場合、サーバーは代わりにSend表示を静かに破棄していたことに注意してください。"
    },
    {
      "indent": 3,
      "text": "Peer A then replies with its own UDP datagram containing application data. The datagram is sent to the relayed transport address on the server. When this arrives, the server creates a Data indication containing the source of the UDP datagram in the XOR-PEER-ADDRESS attribute, and the data from the UDP datagram in the DATA attribute. The resulting Data indication is then sent to the client.",
      "ja": "ピアAは、アプリケーションデータを含む独自のUDPデータグラムで返信します。データグラムは、サーバー上の中継輸送アドレスに送信されます。これが到着すると、サーバーはXor-Peer-Address属性のUDPデータグラムのソースを含むデータ表示と、データ属性のUDPデータグラムのデータを作成します。結果のデータ表示がクライアントに送信されます。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |--- ChannelBind request ----------->|             |             |\n  |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |\n  |    CHANNEL-NUMBER=0x4000           |             |             |\n  |    XOR-PEER-ADDRESS=192.0.2.210:49191            |             |\n  |    USERNAME=\"George\"               |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |\n  |                                    |             |             |\n  |<-- ChannelBind success response ---|             |             |\n  |    Transaction-Id=0x6490D3BC175AFF3D84513212     |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client now binds a channel to Peer B, specifying a free channel number (0x4000) in the CHANNEL-NUMBER attribute, and Peer B's transport address in the XOR-PEER-ADDRESS attribute. As before, the client re-uses the username, realm, and nonce from its last request in the message.",
      "ja": "クライアントは、チャネルをピアBにバインドし、チャネル番号属性のフリーチャネル番号（0x4000）とXor-Peer-Address属性のピアBのトランスポートアドレスを指定します。前と同様に、クライアントはメッセージ内の最後の要求からユーザー名、レルム、およびノンセを再利用します。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of the request, the server binds the channel number to the peer, installs a permission for Peer B's IP address, and then replies with ChannelBind success response.",
      "ja": "リクエストを受け取ると、サーバーはチャネル番号をピアにバインドし、ピアBのIPアドレスの許可をインストールし、ChannelBind Success Responseで返信します。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |--- ChannelData ------------------->|             |             |\n  |    Channel-number=0x4000           |--- UDP datagram --------->|\n  |    Data=...                        |    Data=...               |\n  |                                    |             |             |\n  |                                    |<-- UDP datagram ----------|\n  |                                    |    Data=... |             |\n  |<-- ChannelData --------------------|             |             |\n  |    Channel-number=0x4000           |             |             |\n  |    Data=...                        |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The client now sends a ChannelData message to the server with data destined for Peer B. The ChannelData message is not a STUN message, and thus has no transaction id. Instead, it has only three fields: a channel number, data, and data length; here the channel number field is 0x4000 (the channel the client just bound to Peer B). When the server receives the ChannelData message, it checks that the channel is currently bound (which it is) and then sends the data onward to Peer B in a UDP datagram, using the relayed transport address as the source transport address and 192.0.2.210:49191 (the value of the XOR-PEER-ADDRESS attribute in the ChannelBind request) as the destination transport address.",
      "ja": "クライアントは、ピアBに向けたデータを使用して、チャネルDataメッセージをサーバーに送信するようになりました。チャンネルDataメッセージはスタンメッセージではないため、トランザクションIDがありません。代わりに、チャネル番号、データ、データの長さの3つのフィールドのみがあります。ここで、チャネル番号フィールドは0x4000です（クライアントがピアBにバインドするチャネル）。サーバーがチャンネルDataメッセージを受信すると、チャネルが現在バインドされていること（これが）であることを確認し、ソーストランスポートアドレスと192.0.2.210としてリレー輸送アドレスを使用して、UDPデータグラムでピアBにデータを送信します。宛先輸送アドレスとしての49191（ChannelBindリクエストのXor-Peer-Address属性の値）。"
    },
    {
      "indent": 3,
      "text": "Later, Peer B sends a UDP datagram back to the relayed transport address. This causes the server to send a ChannelData message to the client containing the data from the UDP datagram. The server knows to which client to send the ChannelData message because of the relayed transport address at which the UDP datagram arrived, and knows to use channel 0x4000 because this is the channel bound to 192.0.2.210:49191. Note that if there had not been any channel number bound to that address, the server would have used a Data indication instead.",
      "ja": "その後、Peer BはUDPデータグラムをリレー輸送アドレスに送り返します。これにより、サーバーはUDPデータグラムからのデータを含むChannelDataメッセージをクライアントに送信します。サーバーは、UDPデータグラムが到着した中継輸送アドレスのためにチャンネルDataメッセージを送信するクライアントを知っており、192.0.2.210:49191にバインドされたチャネルであるため、チャネル0x4000を使用することを知っています。そのアドレスにバインドされたチャネル番号がなかった場合、サーバーは代わりにデータ表示を使用していたであろうことに注意してください。"
    },
    {
      "indent": 2,
      "text": "TURN                                 TURN           Peer          Peer\nclient                               server          A             B\n  |--- Refresh request --------------->|             |             |\n  |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |\n  |    SOFTWARE=\"Example client 1.03\"  |             |             |\n  |    USERNAME=\"George\"               |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"adl7W7PeDU4hKE72jdaQvbAMcr6h39sm\"      |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |\n  |                                    |             |             |\n  |<-- Refresh error response ---------|             |             |\n  |    Transaction-Id=0x0864B3C27ADE9354B4312414     |             |\n  |    SOFTWARE=\"Example server, version 1.17\"       |             |\n  |    ERROR-CODE=438 (Stale Nonce)    |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"npSw1Xw239bBwGYhjNWgz2yH47sxB2j\"       |             |\n  |                                    |             |             |\n  |--- Refresh request --------------->|             |             |\n  |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |\n  |    SOFTWARE=\"Example client 1.03\"  |             |             |\n  |    USERNAME=\"George\"               |             |             |\n  |    REALM=\"example.com\"             |             |             |\n  |    NONCE=\"npSw1Xw239bBwGYhjNWgz2yH47sxB2j\"       |             |\n  |    MESSAGE-INTEGRITY=...           |             |             |\n  |                                    |             |             |\n  |<-- Refresh success response -------|             |             |\n  |    Transaction-Id=0x427BD3E625A85FC731DC4191     |             |\n  |    SOFTWARE=\"Example server, version 1.17\"       |             |\n  |    LIFETIME=600 (10 minutes)       |             |             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sometime before the 20 minute lifetime is up, the client refreshes the allocation. This is done using a Refresh request. As before, the client includes the latest username, realm, and nonce values in the request. The client also includes the SOFTWARE attribute, following the recommended practice of always including this attribute in Allocate and Refresh messages. When the server receives the Refresh request, it notices that the nonce value has expired, and so replies with 438 (Stale Nonce) error given a new nonce value. The client then reattempts the request, this time with the new nonce value. This second attempt is accepted, and the server replies with a success response. Note that the client did not include a LIFETIME attribute in the request, so the server refreshes the allocation for the default lifetime of 10 minutes (as can be seen by the LIFETIME attribute in the success response).",
      "ja": "20分間の寿命が終わる前に、クライアントは割り当てを再表示します。これは、更新リクエストを使用して行われます。前と同様に、クライアントには、リクエストに最新のユーザー名、レルム、およびNonCE値が含まれています。クライアントには、Allocate and Refreshメッセージに常にこの属性を含めるという推奨されるプラクティスに従って、ソフトウェア属性も含まれています。サーバーが更新リクエストを受信すると、NonCE値が期限切れになっていることに気付くため、新しいNonCE値がある場合は438（古いNonCE）エラーで返信します。その後、クライアントはリクエストを再請求し、今回は新しいNonCe値を使用します。この2回目の試みは受け入れられ、サーバーは成功応答で返信します。クライアントはリクエストに生涯属性を含めなかったため、サーバーはデフォルトの生涯の10分の割り当てを再表示します（成功応答の生涯属性で見られるように）。"
    },
    {
      "indent": 0,
      "text": "17. Security Considerations",
      "section_title": true,
      "ja": "17. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section considers attacks that are possible in a TURN deployment, and discusses how they are mitigated by mechanisms in the protocol or recommended practices in the implementation.",
      "ja": "このセクションでは、ターン展開で可能な攻撃を検討し、プロトコルのメカニズムまたは実装で推奨されるプラクティスによってどのように緩和されるかについて説明します。"
    },
    {
      "indent": 3,
      "text": "Most of the attacks on TURN are mitigated by the server requiring requests be authenticated. Thus, this specification requires the use of authentication. The mandatory-to-implement mechanism is the long-term credential mechanism of STUN. Other authentication mechanisms of equal or stronger security properties may be used. However, it is important to ensure that they can be invoked in an inter-operable way.",
      "ja": "ターンに対する攻撃のほとんどは、リクエストを認証する必要があるサーバーによって軽減されます。したがって、この仕様には認証の使用が必要です。必須の実装メカニズムは、スタンの長期的な資格メカニズムです。等しいまたはより強力なセキュリティプロパティのその他の認証メカニズムを使用できます。ただし、操作可能な方法で呼び出すことができることを確認することが重要です。"
    },
    {
      "indent": 0,
      "text": "17.1. Outsider Attacks",
      "section_title": true,
      "ja": "17.1. 部外者攻撃"
    },
    {
      "indent": 3,
      "text": "Outsider attacks are ones where the attacker has no credentials in the system, and is attempting to disrupt the service seen by the client or the server.",
      "ja": "アウトサイダーの攻撃は、攻撃者がシステムに資格情報を持っていない場合であり、クライアントまたはサーバーが見たサービスを混乱させようとしています。"
    },
    {
      "indent": 0,
      "text": "17.1.1. Obtaining Unauthorized Allocations",
      "section_title": true,
      "ja": "17.1.1. 不正な割り当ての取得"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to obtain allocations on a TURN server for any number of nefarious purposes. A TURN server provides a mechanism for sending and receiving packets while cloaking the actual IP address of the client. This makes TURN servers an attractive target for attackers who wish to use it to mask their true identity.",
      "ja": "攻撃者は、何度も邪悪な目的でターンサーバーで割り当てを取得したい場合があります。ターンサーバーは、クライアントの実際のIPアドレスをクローキングしながら、パケットを送信および受信するメカニズムを提供します。これにより、Turn Serverは、真のアイデンティティをマスクするためにそれを使用したい攻撃者にとって魅力的なターゲットになります。"
    },
    {
      "indent": 3,
      "text": "An attacker might also wish to simply utilize the services of a TURN server without paying for them. Since TURN services require resources from the provider, it is anticipated that their usage will come with a cost.",
      "ja": "攻撃者は、ターンサーバーのサービスを支払わずに単純に利用したい場合もあります。ターンサービスにはプロバイダーからのリソースが必要なため、使用にはコストがかかると予想されます。"
    },
    {
      "indent": 3,
      "text": "These attacks are prevented using the long-term credential mechanism, which allows the TURN server to determine the identity of the requestor and whether the requestor is allowed to obtain the allocation.",
      "ja": "これらの攻撃は、長期的な資格情報メカニズムを使用して防止されます。これにより、ターンサーバーは要求者のIDとリクエスタが割り当てを取得できるかどうかを決定できます。"
    },
    {
      "indent": 0,
      "text": "17.1.2. Offline Dictionary Attacks",
      "section_title": true,
      "ja": "17.1.2. オフライン辞書攻撃"
    },
    {
      "indent": 3,
      "text": "The long-term credential mechanism used by TURN is subject to offline dictionary attacks. An attacker that is capable of eavesdropping on a message exchange between a client and server can determine the password by trying a number of candidate passwords and seeing if one of them is correct. This attack works when the passwords are low entropy, such as a word from the dictionary. This attack can be mitigated by using strong passwords with large entropy. In situations where even stronger mitigation is required, TLS transport between the client and the server can be used.",
      "ja": "ターンで使用される長期的な資格メカニズムは、オフラインの辞書攻撃の対象となります。クライアントとサーバーの間のメッセージ交換を盗聴できる攻撃者は、多くの候補パスワードを試して、そのうちの1つが正しいかどうかを確認することでパスワードを決定できます。この攻撃は、辞書からの単語など、パスワードがエントロピーが低い場合に機能します。この攻撃は、大きなエントロピーを備えた強力なパスワードを使用することで軽減できます。より強力な緩和が必要な状況では、クライアントとサーバー間のTLS輸送を使用できます。"
    },
    {
      "indent": 0,
      "text": "17.1.3. Faked Refreshes and Permissions",
      "section_title": true,
      "ja": "17.1.3. 偽造リフレッシュとアクセス許可"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to attack an active allocation by sending it a Refresh request with an immediate expiration, in order to delete it and disrupt service to the client. This is prevented by authentication of refreshes. Similarly, an attacker wishing to send CreatePermission requests to create permissions to undesirable destinations is prevented from doing so through authentication. The motivations for such an attack are described in Section 17.2.",
      "ja": "攻撃者は、削除してクライアントへのサービスを妨害するために、すぐに有効期限を取得して更新リクエストを送信することにより、アクティブな割り当てを攻撃したい場合があります。これは、更新の認証によって防止されます。同様に、望ましくない宛先にアクセス許可を作成するためにcreatepermissionリクエストを送信したい攻撃者は、認証を通じてそうすることができません。このような攻撃の動機は、セクション17.2で説明されています。"
    },
    {
      "indent": 0,
      "text": "17.1.4. Fake Data",
      "section_title": true,
      "ja": "17.1.4. 偽のデータ"
    },
    {
      "indent": 3,
      "text": "An attacker might wish to send data to the client or the peer, as if they came from the peer or client, respectively. To do that, the attacker can send the client a faked Data Indication or ChannelData message, or send the TURN server a faked Send Indication or ChannelData message.",
      "ja": "攻撃者は、それぞれピアまたはクライアントから来たかのように、クライアントまたはピアにデータを送信したい場合があります。そのために、攻撃者は、クライアントに偽造データ表示またはChannelDataメッセージを送信するか、ターンサーバーに偽の送信表示またはChannelDataメッセージを送信できます。"
    },
    {
      "indent": 3,
      "text": "Since indications and ChannelData messages are not authenticated, this attack is not prevented by TURN. However, this attack is generally present in IP-based communications and is not substantially worsened by TURN. Consider a normal, non-TURN IP session between hosts A and B. An attacker can send packets to B as if they came from A by sending packets towards A with a spoofed IP address of B. This attack requires the attacker to know the IP addresses of A and B. With TURN, an attacker wishing to send packets towards a client using a Data indication needs to know its IP address (and port), the IP address and port of the TURN server, and the IP address and port of the peer (for inclusion in the XOR-PEER-ADDRESS attribute). To send a fake ChannelData message to a client, an attacker needs to know the IP address and port of the client, the IP address and port of the TURN server, and the channel number. This particular combination is mildly more guessable than in the non-TURN case.",
      "ja": "適応症とチャネルDataメッセージは認証されていないため、この攻撃は順番に防止されません。ただし、この攻撃は一般にIPベースの通信に存在し、ターンごとに実質的に悪化していません。ホストAとBの間の通常の非ターンIPセッションを検討してください。攻撃者は、BのスプーフィングされたIPアドレスでAにパケットを送信することで、Aからパケットを送信するかのようにパケットをBに送信できます。この攻撃では、攻撃者にIPを知る必要がありますAとBのアドレスは、ターンを使用すると、データ表示を使用してクライアントにパケットを送信したい攻撃者が、IPアドレス（およびポート）、ターンサーバーのIPアドレスとポート、およびIPアドレスとポートを知る必要があります。ピア（Xor-Peer-Address属性に含めるため）。偽のChannelDataメッセージをクライアントに送信するには、攻撃者がクライアントのIPアドレスとポート、ターンサーバーのIPアドレスとポート、およびチャネル番号を知る必要があります。この特定の組み合わせは、非ターンの場合よりもわずかに推測可能です。"
    },
    {
      "indent": 3,
      "text": "These attacks are more properly mitigated by application-layer authentication techniques. In the case of real-time traffic, usage of SRTP [RFC3711] prevents these attacks.",
      "ja": "これらの攻撃は、アプリケーション層認証技術によってより適切に軽減されます。リアルタイムトラフィックの場合、SRTP [RFC3711]の使用はこれらの攻撃を防ぎます。"
    },
    {
      "indent": 3,
      "text": "In some situations, the TURN server may be situated in the network such that it is able to send to hosts to which the client cannot directly send. This can happen, for example, if the server is located behind a firewall that allows packets from outside the firewall to be delivered to the server, but not to other hosts behind the firewall. In these situations, an attacker could send the server a Send indication with an XOR-PEER-ADDRESS attribute containing the transport address of one of the other hosts behind the firewall. If the server was to allow relaying of traffic to arbitrary peers, then this would provide a way for the attacker to attack arbitrary hosts behind the firewall.",
      "ja": "状況によっては、ターンサーバーがネットワーク内に位置する可能性があり、クライアントが直接送信できないホストに送信できるようにします。これは、たとえば、サーバーがファイアウォールの外側からのパケットをサーバーに配信できるが、ファイアウォールの背後にある他のホストには使用できないファイアウォールの後ろにある場合に発生する可能性があります。これらの状況では、攻撃者は、ファイアウォールの背後にある他のホストの1つのトランスポートアドレスを含むXor-Peer-Address属性を使用してサーバーに送信表示を送信できます。サーバーが任意のピアへのトラフィックの中継を許可する場合、これは攻撃者がファイアウォールの背後に任意のホストを攻撃する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "To mitigate this attack, TURN requires that the client establish a permission to a host before sending it data. Thus, an attacker can only attack hosts with which the client is already communicating, unless the attacker is able to create authenticated requests. Furthermore, the server administrator may configure the server to restrict the range of IP addresses and ports to which it will relay data. To provide even greater security, the server administrator can require that the client use TLS for all communication between the client and the server.",
      "ja": "この攻撃を緩和するには、ターンでは、データを送信する前にクライアントがホストに許可を確立することを要求します。したがって、攻撃者は、攻撃者が認証されたリクエストを作成できない限り、クライアントがすでに通信しているホストのみを攻撃できます。さらに、サーバー管理者は、データを中継するIPアドレスとポートの範囲を制限するようにサーバーを構成する場合があります。さらに大きなセキュリティを提供するために、サーバー管理者は、クライアントとサーバー間のすべての通信にTLSを使用することを要求できます。"
    },
    {
      "indent": 0,
      "text": "17.1.5. Impersonating a Server",
      "section_title": true,
      "ja": "17.1.5. サーバーになりすまします"
    },
    {
      "indent": 3,
      "text": "When a client learns a relayed address from a TURN server, it uses that relayed address in application protocols to receive traffic. Therefore, an attacker wishing to intercept or redirect that traffic might try to impersonate a TURN server and provide the client with a faked relayed address.",
      "ja": "クライアントがターンサーバーから中継アドレスを学習すると、アプリケーションプロトコルで中継されたアドレスを使用してトラフィックを受信します。したがって、トラフィックがターンサーバーになりすまし、偽造されたアドレスをクライアントに提供しようとする可能性があることを傍受またはリダイレクトしたい攻撃者。"
    },
    {
      "indent": 3,
      "text": "This attack is prevented through the long-term credential mechanism, which provides message integrity for responses in addition to verifying that they came from the server. Furthermore, an attacker cannot replay old server responses as the transaction id in the STUN header prevents this. Replay attacks are further thwarted through frequent changes to the nonce value.",
      "ja": "この攻撃は、サーバーから来たことを確認することに加えて、応答のメッセージの整合性を提供する長期的な資格情報メカニズムによって防止されます。さらに、攻撃者は、スタンヘッダーのトランザクションIDがこれを防ぐため、古いサーバーの応答を再生できません。リプレイ攻撃は、頻繁に変化してnonce値を頻繁に変更することにより、さらに阻止されます。"
    },
    {
      "indent": 0,
      "text": "17.1.6. Eavesdropping Traffic",
      "section_title": true,
      "ja": "17.1.6. トラフィックの盗聴"
    },
    {
      "indent": 3,
      "text": "TURN concerns itself primarily with authentication and message integrity. Confidentiality is only a secondary concern, as TURN control messages do not include information that is particularly sensitive. The primary protocol content of the messages is the IP address of the peer. If it is important to prevent an eavesdropper on a TURN connection from learning this, TURN can be run over TLS.",
      "ja": "主に認証とメッセージの整合性に関心を持っています。ターンコントロールメッセージには特に敏感な情報が含まれていないため、機密性は二次的な懸念にすぎません。メッセージの主要なプロトコルコンテンツは、ピアのIPアドレスです。ターン接続の盗聴者がこれを学習するのを防ぐことが重要な場合は、ターンをTLSで実行できます。"
    },
    {
      "indent": 3,
      "text": "Confidentiality for the application data relayed by TURN is best provided by the application protocol itself, since running TURN over TLS does not protect application data between the server and the peer. If confidentiality of application data is important, then the application should encrypt or otherwise protect its data. For example, for real-time media, confidentiality can be provided by using SRTP.",
      "ja": "ターンごとに中継されたアプリケーションデータの機密性は、アプリケーションプロトコル自体によって最適に提供されます。これは、TLSの実行がサーバーとピア間のアプリケーションデータを保護しないためです。アプリケーションデータの機密性が重要な場合、アプリケーションはデータを暗号化または保護する必要があります。たとえば、リアルタイムメディアの場合、SRTPを使用して機密性を提供できます。"
    },
    {
      "indent": 0,
      "text": "17.1.7. TURN Loop Attack",
      "section_title": true,
      "ja": "17.1.7. ループ攻撃をターンします"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to cause data packets to loop indefinitely between two TURN servers. The attack goes as follows. First, the attacker sends an Allocate request to server A, using the source address of server B. Server A will send its response to server B, and for the attack to succeed, the attacker must have the ability to either view or guess the contents of this response, so that the attacker can learn the allocated relayed transport address. The attacker then sends an Allocate request to server B, using the source address of server A. Again, the attacker must be able to view or guess the contents of the response, so it can send learn the allocated relayed transport address. Using the same spoofed source address technique, the attacker then binds a channel number on server A to the relayed transport address on server B, and similarly binds the same channel number on server B to the relayed transport address on server A. Finally, the attacker sends a ChannelData message to server A.",
      "ja": "攻撃者は、2つのターンサーバー間でデータパケットを無期限にループさせようとする場合があります。攻撃は次のとおりです。まず、攻撃者はサーバーAに割り当て要求を送信し、サーバーBのソースアドレスを使用してサーバーAに応答します。サーバーAはサーバーBに応答を送信し、攻撃を成功させるには、攻撃者がコンテンツを表示または推測する能力を持たなければなりませんこの応答のうち、攻撃者が割り当てられた中継輸送アドレスを学ぶことができるように。次に、攻撃者はサーバーAのソースアドレスを使用してサーバーBに割り当てリクエストを送信します。再び、攻撃者は応答の内容を表示または推測できる必要があります。そうすれば、割り当てられた中継輸送アドレスを学習できます。同じスプーフィングされたソースアドレステクニックを使用して、攻撃者はサーバーAのチャネル番号をサーバーBの中継輸送アドレスにバインドし、同様にサーバーBの同じチャネル番号をサーバーAの中継輸送アドレスにバインドします。最後に、攻撃者は攻撃者です。サーバーAにチャンネルDataメッセージを送信します。"
    },
    {
      "indent": 3,
      "text": "The result is a data packet that loops from the relayed transport address on server A to the relayed transport address on server B, then from server B's transport address to server A's transport address, and then around the loop again.",
      "ja": "その結果、サーバーAの中継輸送アドレスからサーバーBの中継輸送アドレスに、サーバーBのトランスポートアドレスからサーバーAのトランスポートアドレスまで、そして再びループの周りにループするデータパケットができます。"
    },
    {
      "indent": 3,
      "text": "This attack is mitigated as follows. By requiring all requests to be authenticated and/or by randomizing the port number allocated for the relayed transport address, the server forces the attacker to either intercept or view responses sent to a third party (in this case, the other server) so that the attacker can authenticate the requests and learn the relayed transport address. Without one of these two measures, an attacker can guess the contents of the responses without needing to see them, which makes the attack much easier to perform. Furthermore, by requiring authenticated requests, the server forces the attacker to have credentials acceptable to the server, which turns this from an outsider attack into an insider attack and allows the attack to be traced back to the client initiating it.",
      "ja": "この攻撃は次のように軽減されます。すべてのリクエストがリレー輸送アドレスに割り当てられたポート番号をランダム化することにより、すべてのリクエストを要求することにより、サーバーは攻撃者に第三者（この場合、他のサーバー）に送信された応答をインターセプトまたは表示するように強制します。攻撃者は、リクエストを認証し、中継輸送アドレスを学習できます。これらの2つの測定のいずれかがなければ、攻撃者はそれらを見る必要なく応答の内容を推測できます。これにより、攻撃の実行がはるかに容易になります。さらに、認証されたリクエストを要求することにより、サーバーは攻撃者にサーバーに許容できる資格情報を強制します。これは、これをアウトサイダー攻撃からインサイダー攻撃に変換し、攻撃を開始するクライアントに追跡できるようにします。"
    },
    {
      "indent": 3,
      "text": "The attack can be further mitigated by imposing a per-username limit on the bandwidth used to relay data by allocations owned by that username, to limit the impact of this attack on other allocations. More mitigation can be achieved by decrementing the TTL when relaying data packets (if the underlying OS allows this).",
      "ja": "攻撃は、他の割り当てに対するこの攻撃の影響を制限するために、そのユーザー名が所有する割り当てによってデータを中継するために使用される帯域幅にユーザー名ごとの制限を課すことにより、さらに軽減できます。データパケットを中継するときにTTLを減少させることにより、より緩和されることができます（基礎となるOSがこれを許可する場合）。"
    },
    {
      "indent": 0,
      "text": "17.2. Firewall Considerations",
      "section_title": true,
      "ja": "17.2. ファイアウォールの考慮事項"
    },
    {
      "indent": 3,
      "text": "A key security consideration of TURN is that TURN should not weaken the protections afforded by firewalls deployed between a client and a TURN server. It is anticipated that TURN servers will often be present on the public Internet, and clients may often be inside enterprise networks with corporate firewalls. If TURN servers provide a 'backdoor' for reaching into the enterprise, TURN will be blocked by these firewalls.",
      "ja": "ターンの主要なセキュリティの考慮事項は、クライアントとターンサーバーの間に展開されたファイアウォールによって得られる保護を弱めるべきではないということです。ターンサーバーがパブリックインターネットに存在することが多く、クライアントは企業のファイアウォールを備えたエンタープライズネットワーク内にいることが多いことが予想されます。ターンサーバーがエンタープライズに到達するための「バックドア」を提供する場合、ターンはこれらのファイアウォールによってブロックされます。"
    },
    {
      "indent": 3,
      "text": "TURN servers therefore emulate the behavior of NAT devices that implement address-dependent filtering [RFC4787], a property common in many firewalls as well. When a NAT or firewall implements this behavior, packets from an outside IP address are only allowed to be sent to an internal IP address and port if the internal IP address and port had recently sent a packet to that outside IP address. TURN servers introduce the concept of permissions, which provide exactly this same behavior on the TURN server. An attacker cannot send a packet to a TURN server and expect it to be relayed towards the client, unless the client has tried to contact the attacker first.",
      "ja": "したがって、サーバーは、多くのファイアウォールで共通のプロパティであるアドレス依存フィルタリング[RFC4787]を実装するNATデバイスの動作をエミュレートします。NATまたはファイアウォールがこの動作を実装する場合、外部のIPアドレスからのパケットは、内部IPアドレスとポートが最近その外側のIPアドレスにパケットを送信した場合にのみ、内部IPアドレスとポートに送信できます。ターンサーバーは、ターンサーバーでまったく同じ動作を提供する権限の概念を導入します。攻撃者は、クライアントが最初に攻撃者に連絡しようとしない限り、パケットをターンサーバーに送信して、クライアントにリレーすることを期待することはできません。"
    },
    {
      "indent": 3,
      "text": "It is important to note that some firewalls have policies that are even more restrictive than address-dependent filtering. Firewalls can also be configured with address- and port-dependent filtering, or can be configured to disallow inbound traffic entirely. In these cases, if a client is allowed to connect the TURN server, communications to the client will be less restrictive than what the firewall would normally allow.",
      "ja": "一部のファイアウォールには、アドレス依存フィルタリングよりもさらに制限的なポリシーがあることに注意することが重要です。ファイアウォールは、アドレス依存およびポート依存のフィルタリングで構成することも、インバウンドトラフィックを完全に許可するように構成することもできます。これらの場合、クライアントがターンサーバーを接続することを許可されている場合、クライアントへの通信は、ファイアウォールが通常許可するものよりも制限が少なくなります。"
    },
    {
      "indent": 0,
      "text": "17.2.1. Faked Permissions",
      "section_title": true,
      "ja": "17.2.1. 偽造許可"
    },
    {
      "indent": 3,
      "text": "In firewalls and NAT devices, permissions are granted implicitly through the traversal of a packet from the inside of the network towards the outside peer. Thus, a permission cannot, by definition, be created by any entity except one inside the firewall or NAT. With TURN, this restriction no longer holds. Since the TURN server sits outside the firewall, at attacker outside the firewall can now send a message to the TURN server and try to create a permission for itself.",
      "ja": "ファイアウォールとNATデバイスでは、ネットワークの内側から外側のピアへのパケットのトラバーサルを通じて、許可が暗黙的に付与されます。したがって、定義上、ファイアウォールまたはNAT内の1つを除くエンティティが許可を作成することはできません。ターンとともに、この制限はもはや保持されません。ターンサーバーはファイアウォールの外側にあるため、ファイアウォールの外側の攻撃者で、ターンサーバーにメッセージを送信し、それ自体の許可を作成することができます。"
    },
    {
      "indent": 3,
      "text": "This attack is prevented because all messages that create permissions (i.e., ChannelBind and CreatePermission) are authenticated.",
      "ja": "この攻撃は、アクセス許可（つまり、ChannelBindおよびCreatePermission）を作成するすべてのメッセージが認証されているため、防止されます。"
    },
    {
      "indent": 0,
      "text": "17.2.2. Blacklisted IP Addresses",
      "section_title": true,
      "ja": "17.2.2. ブラックリストIPアドレス"
    },
    {
      "indent": 3,
      "text": "Many firewalls can be configured with blacklists that prevent a client behind the firewall from sending packets to, or receiving packets from, ranges of blacklisted IP addresses. This is accomplished by inspecting the source and destination addresses of packets entering and exiting the firewall, respectively.",
      "ja": "多くのファイアウォールは、ブラックリストのIPアドレスの範囲にファイアウォールの後ろのクライアントがパケットを送信したり、パケットを受信したりすることを防ぐブラックリストで構成できます。これは、それぞれファイアウォールを出入りするパケットのソースアドレスと宛先アドレスを検査することによって達成されます。"
    },
    {
      "indent": 3,
      "text": "This feature is also present in TURN, since TURN servers are allowed to arbitrarily restrict the range of addresses of peers that they will relay to.",
      "ja": "ターンサーバーは、リレーするピアのアドレスの範囲を任意に制限できるため、この機能も順番に存在します。"
    },
    {
      "indent": 0,
      "text": "17.2.3. Running Servers on Well-Known Ports",
      "section_title": true,
      "ja": "17.2.3. よく知られているポートでサーバーを実行しています"
    },
    {
      "indent": 3,
      "text": "A malicious client behind a firewall might try to connect to a TURN server and obtain an allocation which it then uses to run a server. For example, a client might try to run a DNS server or FTP server.",
      "ja": "ファイアウォールの背後にある悪意のあるクライアントは、ターンサーバーに接続し、それが使用してサーバーを実行するために使用する割り当てを取得しようとする可能性があります。たとえば、クライアントはDNSサーバーまたはFTPサーバーを実行しようとする場合があります。"
    },
    {
      "indent": 3,
      "text": "This is not possible in TURN. A TURN server will never accept traffic from a peer for which the client has not installed a permission. Thus, peers cannot just connect to the allocated port in order to obtain the service.",
      "ja": "これは順番に不可能です。ターンサーバーは、クライアントが許可をインストールしていないピアからのトラフィックを決して受け入れません。したがって、ピアはサービスを取得するために割り当てられたポートに接続するだけではありません。"
    },
    {
      "indent": 0,
      "text": "17.3. Insider Attacks",
      "section_title": true,
      "ja": "17.3. インサイダー攻撃"
    },
    {
      "indent": 3,
      "text": "In insider attacks, a client has legitimate credentials but defies the trust relationship that goes with those credentials. These attacks cannot be prevented by cryptographic means but need to be considered in the design of the protocol.",
      "ja": "インサイダー攻撃では、クライアントは正当な資格情報を持っていますが、それらの資格情報に合う信頼関係に反します。これらの攻撃は暗号化手段によって防ぐことはできませんが、プロトコルの設計で考慮する必要があります。"
    },
    {
      "indent": 0,
      "text": "17.3.1. DoS against TURN Server",
      "section_title": true,
      "ja": "17.3.1. ターンサーバーに対するDOS"
    },
    {
      "indent": 3,
      "text": "A client wishing to disrupt service to other clients might obtain an allocation and then flood it with traffic, in an attempt to swamp the server and prevent it from servicing other legitimate clients. This is mitigated by the recommendation that the server limit the amount of bandwidth it will relay for a given username. This won't prevent a client from sending a large amount of traffic, but it allows the server to immediately discard traffic in excess.",
      "ja": "他のクライアントへのサービスを混乱させたいクライアントは、サーバーを圧倒し、他の正当なクライアントにサービスを提供することを防ぐために、割り当てを取得し、トラフィックにあふれている場合があります。これは、サーバーが特定のユーザー名にリレーする帯域幅の量を制限するという推奨によって軽減されます。これにより、クライアントが大量のトラフィックを送信することは妨げられませんが、サーバーはすぐにトラフィックを過剰に破棄することができます。"
    },
    {
      "indent": 3,
      "text": "Since each allocation uses a port number on the IP address of the TURN server, the number of allocations on a server is finite. An attacker might attempt to consume all of them by requesting a large number of allocations. This is prevented by the recommendation that the server impose a limit of the number of allocations active at a time for a given username.",
      "ja": "各割り当ては、ターンサーバーのIPアドレスでポート番号を使用するため、サーバー上の割り当ての数は有限です。攻撃者は、多数の割り当てを要求することにより、それらすべてを消費しようとするかもしれません。これは、サーバーが特定のユーザー名に対して一度にアクティブな割り当ての数の制限を課すことを推奨することによって防止されます。"
    },
    {
      "indent": 0,
      "text": "17.3.2. Anonymous Relaying of Malicious Traffic",
      "section_title": true,
      "ja": "17.3.2. 悪意のあるトラフィックの匿名の中継"
    },
    {
      "indent": 3,
      "text": "TURN servers provide a degree of anonymization. A client can send data to peers without revealing its own IP address. TURN servers may therefore become attractive vehicles for attackers to launch attacks against targets without fear of detection. Indeed, it is possible for a client to chain together multiple TURN servers, such that any number of relays can be used before a target receives a packet.",
      "ja": "ターンサーバーは、ある程度の匿名化を提供します。クライアントは、独自のIPアドレスを表示せずにピアにデータを送信できます。したがって、ターンサーバーは、攻撃者が検出を恐れることなくターゲットに対する攻撃を開始するための魅力的な車両になる可能性があります。実際、クライアントが複数のターンサーバーを一緒にチェーンすることができ、ターゲットがパケットを受信する前に任意の数のリレーを使用できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "Administrators who are worried about this attack can maintain logs that capture the actual source IP and port of the client, and perhaps even every permission that client installs. This will allow for forensic tracing to determine the original source, should it be discovered that an attack is being relayed through a TURN server.",
      "ja": "この攻撃を心配している管理者は、クライアントの実際のソースIPとポートをキャプチャするログ、およびおそらくクライアントがインストールするすべての許可を維持できます。これにより、ターンサーバーを介して攻撃が中継されていることが発見された場合、元のソースを決定するための法医学トレースが可能になります。"
    },
    {
      "indent": 0,
      "text": "17.3.3. Manipulating Other Allocations",
      "section_title": true,
      "ja": "17.3.3. 他の割り当ての操作"
    },
    {
      "indent": 3,
      "text": "An attacker might attempt to disrupt service to other users of the TURN server by sending Refresh requests or CreatePermission requests that (through source address spoofing) appear to be coming from another user of the TURN server. TURN prevents this by requiring that the credentials used in CreatePermission, Refresh, and ChannelBind messages match those used to create the initial allocation. Thus, the fake requests from the attacker will be rejected.",
      "ja": "攻撃者は、（ソースアドレスのスプーフィングを介して）ターンサーバーの別のユーザーから来ているように見えるリフレッシュリクエストまたはcreatePermissionリクエストを送信することにより、ターンサーバーの他のユーザーへのサービスを破壊しようとする場合があります。ターンは、CreatePermission、Refresh、およびChannelBindメッセージで使用される資格情報が初期割り当てを作成するために使用されるものと一致することを要求することにより、これを防ぎます。したがって、攻撃者からの偽の要求は拒否されます。"
    },
    {
      "indent": 0,
      "text": "17.4. Other Considerations",
      "section_title": true,
      "ja": "17.4. その他の考慮事項"
    },
    {
      "indent": 3,
      "text": "Any relay addresses learned through an Allocate request will not operate properly with IPsec Authentication Header (AH) [RFC4302] in transport or tunnel mode. However, tunnel-mode IPsec Encapsulating Security Payload (ESP) [RFC4303] should still operate.",
      "ja": "割り当てリクエストを介して学習したリレーアドレスは、輸送モードまたはトンネルモードでIPSEC認証ヘッダー（AH）[RFC4302]で適切に動作しません。ただし、セキュリティペイロード（ESP）[RFC4303]をカプセル化するトンネルモードIPSECは引き続き動作する必要があります。"
    },
    {
      "indent": 0,
      "text": "18. IANA Considerations",
      "section_title": true,
      "ja": "18. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Since TURN is an extension to STUN [RFC5389], the methods, attributes, and error codes defined in this specification are new methods, attributes, and error codes for STUN. IANA has added these new protocol elements to the IANA registry of STUN protocol elements.",
      "ja": "ターンはスタン[RFC5389]の拡張であるため、この仕様で定義されているメソッド、属性、およびエラーコードは、STUNの新しい方法、属性、およびエラーコードです。IANAは、これらの新しいプロトコル要素をSTUNプロトコル要素のIANAレジストリに追加しました。"
    },
    {
      "indent": 3,
      "text": "The codepoints for the new STUN methods defined in this specification are listed in Section 13.",
      "ja": "この仕様で定義されている新しいスタンメソッドのコードポイントは、セクション13にリストされています。"
    },
    {
      "indent": 3,
      "text": "The codepoints for the new STUN attributes defined in this specification are listed in Section 14.",
      "ja": "この仕様で定義されている新しいスタン属性のコードポイントは、セクション14にリストされています。"
    },
    {
      "indent": 3,
      "text": "The codepoints for the new STUN error codes defined in this specification are listed in Section 15.",
      "ja": "この仕様で定義されている新しいスタンエラーコードのコードポイントは、セクション15にリストされています。"
    },
    {
      "indent": 3,
      "text": "IANA has allocated the SRV service name of \"turn\" for TURN over UDP or TCP, and the service name of \"turns\" for TURN over TLS.",
      "ja": "IANAは、UDPまたはTCPをターンオーバーするために「Turn」のSRVサービス名を割り当て、TLSをターンするために「Turn」のサービス名を割り当てました。"
    },
    {
      "indent": 3,
      "text": "IANA has created a registry for TURN channel numbers, initially populated as follows:",
      "ja": "IANAは、最初は次のようにターンチャネル番号のレジストリを作成しました。"
    },
    {
      "indent": 6,
      "text": "0x0000 through 0x3FFF: Reserved and not available for use, since they conflict with the STUN header.",
      "ja": "0x0000から0x3fff：予約済みで使用できません。なぜなら、それらはスタンヘッダーと競合するためです。"
    },
    {
      "indent": 6,
      "text": "0x4000 through 0x7FFF: A TURN implementation is free to use channel numbers in this range.",
      "ja": "0x4000から0x7fff：ターン実装は、この範囲でチャネル番号を無料で使用できます。"
    },
    {
      "indent": 6,
      "text": "0x8000 through 0xFFFF: Unassigned.",
      "ja": "0x8000から0xffff：未割り当て。"
    },
    {
      "indent": 3,
      "text": "Any change to this registry must be made through an IETF Standards Action.",
      "ja": "このレジストリの変更は、IETF標準アクションを通じて行う必要があります。"
    },
    {
      "indent": 0,
      "text": "19. IAB Considerations",
      "section_title": true,
      "ja": "19. IABの考慮事項"
    },
    {
      "indent": 3,
      "text": "The IAB has studied the problem of \"Unilateral Self Address Fixing\" (UNSAF), which is the general process by which a client attempts to determine its address in another realm on the other side of a NAT through a collaborative protocol-reflection mechanism [RFC3424]. The TURN extension is an example of a protocol that performs this type of function. The IAB has mandated that any protocols developed for this purpose document a specific set of considerations. These considerations and the responses for TURN are documented in this section.",
      "ja": "IABは、「一方的なセルフアドレス修正」（UNSAF）の問題を研究しています。これは、クライアントが共同プロトコルリフレクションメカニズムを通じてNATの反対側の別の領域のアドレスを決定しようとする一般的なプロセスです[RFC34244]。ターンエクステンションは、このタイプの関数を実行するプロトコルの例です。IABは、この目的のために開発されたプロトコルが特定の考慮事項を文書化することを義務付けています。これらの考慮事項とターンの回答は、このセクションで文書化されています。"
    },
    {
      "indent": 3,
      "text": "Consideration 1: Precise definition of a specific, limited-scope problem that is to be solved with the UNSAF proposal. A short-term fix should not be generalized to solve other problems. Such generalizations lead to the prolonged dependence on and usage of the supposed short-term fix -- meaning that it is no longer accurate to call it \"short-term\".",
      "ja": "考慮事項1：UNSAF提案で解決される特定の限られたスコープ問題の正確な定義。他の問題を解決するために、短期的な修正を一般化しないでください。このような一般化は、想定される短期的な修正への長期依存と使用につながります。つまり、それを「短期」と呼ぶことはもはや正確ではありません。"
    },
    {
      "indent": 3,
      "text": "Response: TURN is a protocol for communication between a relay (= TURN server) and its client. The protocol allows a client that is behind a NAT to obtain and use a public IP address on the relay. As a convenience to the client, TURN also allows the client to determine its server-reflexive transport address.",
      "ja": "応答：ターンは、リレー（=サーバー）とそのクライアント間の通信のためのプロトコルです。このプロトコルにより、NATの背後にあるクライアントがリレー上のパブリックIPアドレスを取得して使用できます。クライアントにとって便利であるため、ターンにより、クライアントはサーバー反射トランスポートアドレスを決定することもできます。"
    },
    {
      "indent": 3,
      "text": "Consideration 2: Description of an exit strategy/transition plan. The better short-term fixes are the ones that will naturally see less and less use as the appropriate technology is deployed.",
      "ja": "考慮2：出口戦略/移行計画の説明。より良い短期的な修正は、適切なテクノロジーが展開されるにつれて、自然に使用が少なくなると思われるものです。"
    },
    {
      "indent": 3,
      "text": "Response: TURN will no longer be needed once there are no longer any NATs. Unfortunately, as of the date of publication of this document, it no longer seems very likely that NATs will go away any time soon. However, the need for TURN will also decrease as the number of NATs with the mapping property of Endpoint-Independent Mapping [RFC4787] increases.",
      "ja": "応答：NATがなくなったら、ターンは不要になります。残念ながら、この文書の公開日の時点で、NATがすぐに消える可能性はもはやありません。ただし、エンドポイント非依存マッピング[RFC4787]のマッピングプロパティを持つNATの数が増加するにつれて、ターンの必要性も減少します。"
    },
    {
      "indent": 3,
      "text": "Consideration 3: Discussion of specific issues that may render systems more \"brittle\". For example, approaches that involve using data at multiple network layers create more dependencies, increase debugging challenges, and make it harder to transition.",
      "ja": "考慮事項3：システムをより「脆く」する可能性のある特定の問題の議論。たとえば、複数のネットワークレイヤーでデータを使用することを含むアプローチは、より多くの依存関係を作成し、デバッグの課題を増やし、移行を難しくします。"
    },
    {
      "indent": 3,
      "text": "Response: TURN is \"brittle\" in that it requires the NAT bindings between the client and the server to be maintained unchanged for the lifetime of the allocation. This is typically done using keep-alives. If this is not done, then the client will lose its allocation and can no longer exchange data with its peers.",
      "ja": "応答：ターンは、クライアントとサーバーの間のNATバインディングを、割り当ての寿命のために変更せずに維持する必要があるという点で「脆い」ことです。これは通常、Keep-Alivesを使用して行われます。これが行われない場合、クライアントは割り当てを失い、ピアとデータを交換することができなくなります。"
    },
    {
      "indent": 3,
      "text": "Consideration 4: Identify requirements for longer-term, sound technical solutions; contribute to the process of finding the right longer-term solution.",
      "ja": "考慮4：長期的な健全な技術ソリューションの要件を特定します。適切な長期ソリューションを見つけるプロセスに貢献します。"
    },
    {
      "indent": 3,
      "text": "Response: The need for TURN will be reduced once NATs implement the recommendations for NAT UDP behavior documented in [RFC4787]. Applications are also strongly urged to use ICE [RFC5245] to communicate with peers; though ICE uses TURN, it does so only as a last resort, and uses it in a controlled manner.",
      "ja": "応答：NATが[RFC4787]に文書化されたNAT UDPの動作の推奨事項を実装すると、ターンの必要性が減ります。アプリケーションは、ピアと通信するために氷[RFC5245]を使用することも強く求められています。ICEはターンを使用しますが、最後の手段としてのみ行い、制御された方法で使用します。"
    },
    {
      "indent": 3,
      "text": "Consideration 5: Discussion of the impact of the noted practical issues with existing deployed NATs and experience reports.",
      "ja": "考慮事項5：既存の展開されたNATおよび経験レポートに関する有名な実用的な問題の影響に関する議論。"
    },
    {
      "indent": 3,
      "text": "Response: Some NATs deployed today exhibit a mapping behavior other than Endpoint-Independent mapping. These NATs are difficult to work with, as they make it difficult or impossible for protocols like ICE to use server-reflexive transport addresses on those NATs. A client behind such a NAT is often forced to use a relay protocol like TURN because \"UDP hole punching\" techniques [RFC5128] do not work.",
      "ja": "応答：本日展開されている一部のNATは、エンドポイント非依存マッピング以外のマッピング動作を示しています。これらのNATは、ICEのようなプロトコルがそれらのNATでサーバー反射トランスタップアドレスを使用することを困難または不可能にするため、操作するのが困難です。このようなNATの背後にあるクライアントは、「UDPホールパンチ」テクニック[RFC5128]が機能しないため、ターンのようなリレープロトコルの使用を強制されることがよくあります。"
    },
    {
      "indent": 0,
      "text": "20. Acknowledgements",
      "section_title": true,
      "ja": "20. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank the various participants in the BEHAVE working group for their many comments on this document. Marc Petit-Huguenin, Remi Denis-Courmont, Jason Fischl, Derek MacDonald, Scott Godin, Cullen Jennings, Lars Eggert, Magnus Westerlund, Benny Prijono, and Eric Rescorla have been particularly helpful, with Eric suggesting the channel allocation mechanism, Cullen suggesting an earlier version of the EVEN-PORT mechanism, and Marc spending many hours implementing the preliminary versions to look for problems. Christian Huitema was an early contributor to this document and was a co-author on the first few versions. Finally, the authors would like to thank Dan Wing for both his contributions to the text and his huge help in restarting progress on this document after work had stalled.",
      "ja": "著者は、このドキュメントに関する多くのコメントについて、Deviveワーキンググループのさまざまな参加者に感謝したいと思います。マーク・プチ・フーゲニン、レミ・デニス・コールモント、ジェイソン・フィシュル、デレク・マクドナルド、スコット・ゴディン、カレン・ジェニングス、ラース・エガート、マグナス・ウェスターランド、ベニー・プリジョノ、エリック・レスコルラは特に役立ち、エリックはチャネル割り当て機械を示唆していることを示唆しています。均一なメカニズムの以前のバージョンと、問題を探すために予備バージョンを実装するために何時間も費やしています。Christian Huitemaはこの文書への初期の貢献者であり、最初のいくつかのバージョンの共著者でした。最後に、著者は、テキストへの彼の貢献と、仕事が停止した後にこのドキュメントの進捗を再開する際の彼の大きな助けに感謝したいと思います。"
    },
    {
      "indent": 0,
      "text": "21. References",
      "section_title": true,
      "ja": "21. 参考文献"
    },
    {
      "indent": 0,
      "text": "21.1. Normative References",
      "section_title": true,
      "ja": "21.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「NATのセッショントラバーサルユーティリティ（STUN）」、RFC 5389、2008年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2474] Nichols, K., Blake, S., Baker, F., and D. Black, \"Definition of the Differentiated Services Field (DS Field) in the IPv4 and IPv6 Headers\", RFC 2474, December 1998.",
      "ja": "[RFC2474] Nichols、K.、Blake、S.、Baker、F。、およびD. Black、「IPv4およびIPv6ヘッダーの差別化されたサービスフィールド（DSフィールド）の定義」、RFC 2474、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "[RFC3168] Ramakrishnan、K.、Floyd、S。、およびD. Black、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 0,
      "text": "21.2. Informative References",
      "section_title": true,
      "ja": "21.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC0791] Postel, J., \"Internet Protocol\", STD 5, RFC 791, September 1981.",
      "ja": "[RFC0791] Postel、J。、「インターネットプロトコル」、STD 5、RFC 791、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1918] Rekhter, Y., Moskowitz, R., Karrenberg, D., Groot, G., and E. Lear, \"Address Allocation for Private Internets\", BCP 5, RFC 1918, February 1996.",
      "ja": "[RFC1918] Rekhter、Y.、Moskowitz、R.、Karrenberg、D.、Groot、G。、およびE. Lear、「Private Internetsのアドレス割り当て」、BCP 5、RFC 1918、1996年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3424] Daigle, L. and IAB, \"IAB Considerations for UNilateral Self-Address Fixing (UNSAF) Across Network Address Translation\", RFC 3424, November 2002.",
      "ja": "[RFC3424] Daigle、L。およびIAB、「ネットワークアドレス翻訳全体の一方的な自己アドレス固定（UNSAF）に関するIABの考慮事項」、RFC 3424、2002年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787] Audet、F。およびC. Jennings、「Unicast UDPのネットワークアドレス変換（NAT）行動要件」、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5245] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", RFC 5245, April 2010.",
      "ja": "[RFC5245] Rosenberg、J。、「Interactive Connectivity Indecivity（ICE）：オファー/回答プロトコルのネットワークアドレス翻訳者（NAT）トラバーサルのプロトコル」、RFC 5245、2010年4月。"
    },
    {
      "indent": 3,
      "text": "[TURN-TCP] Perreault, S. and J. Rosenberg, \"Traversal Using Relays around NAT (TURN) Extensions for TCP Allocations\", Work in Progress, March 2010.",
      "ja": "[Turn-TCP] Perreault、S。およびJ. Rosenberg、「TCP割り当てのNAT（Turn）拡張機能の周りのリレーを使用したトラバーサル」、2010年3月の作業。"
    },
    {
      "indent": 3,
      "text": "[TURN-IPv6] Perreault, S., Camarillo, G., and O. Novo, \"Traversal Using Relays around NAT (TURN) Extension for IPv6\", Work in Progress, March 2010.",
      "ja": "[Turn-IPV6] Perreault、S.、Camarillo、G。、およびO. Novo、「IPv6のNATの周りのリレーを使用したトラバーサル」、2010年3月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[TSVWG-PORT] Larsen, M. and F. Gont, \"Port Randomization\", Work in Progress, April 2010.",
      "ja": "[TSVWG-Port] Larsen、M。およびF. Gont、「ポートランダム化」、2010年4月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[RFC5128] Srisuresh, P., Ford, B., and D. Kegel, \"State of Peer-to-Peer (P2P) Communication across Network Address Translators (NATs)\", RFC 5128, March 2008.",
      "ja": "[RFC5128] Srisuresh、P.、Ford、B。、およびD. Kegel、「ネットワークアドレス翻訳者（NAT）全体のピアツーピア（P2P）通信」、RFC 5128、2008年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC1928] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., and L. Jones, \"SOCKS Protocol Version 5\", RFC 1928, March 1996.",
      "ja": "[RFC1928] Leech、M.、Ganis、M.、Lee、Y.、Kuris、R.、Koblas、D。、およびL. Jones、 \"Socks Protocolバージョン5\"、RFC 1928、1996年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーション用の輸送プロトコル」、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「The Secure Real-Time Transport Protocol（SRTP）」、RFC 3711、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302] Kent、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303] Kent、S。、「セキュリティペイロードのカプセル化（ESP）」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SESSION INTIANIATION Protocol」、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[MMUSIC-ICE-NONSIP] Rosenberg, J., \"Guidelines for Usage of Interactive Connectivity Establishment (ICE) by non Session Initiation Protocol (SIP) Protocols\", Work in Progress, July 2008.",
      "ja": "[MMUSIC-ICE-NONSIP] Rosenberg、J。、「非セッション開始プロトコル（SIP）プロトコルによるインタラクティブな接続性確立（ICE）の使用に関するガイドライン」、2008年7月の進行中。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, June 2005.",
      "ja": "[RFC4086] Eastlake、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[Frag-Harmful] Kent and Mogul, \"Fragmentation Considered Harmful\". Proc. SIGCOMM '87, vol. 17, No. 5, October 1987",
      "ja": "[断片的な]ケントと大御所、「断片化は有害と考えられていた」。Proc。Sigcomm '87、vol。17、No。5、1987年10月"
    },
    {
      "indent": 3,
      "text": "[Port-Numbers] \"IANA Port Numbers Registry\", <http://www.iana.org>.",
      "ja": "[Port-Numbers]「Ianaポート番号レジストリ」、<http://www.iana.org>。"
    },
    {
      "indent": 3,
      "text": "[Protocol-Numbers] \"IANA Protocol Numbers Registry\", 2005, <http://www.iana.org>.",
      "ja": "[Protocol-Numbers]「Iana Protocol Numbers Registry」、2005、<http://www.iana.org>。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Rohan Mahy Unaffiliated",
      "ja": "Rohan Mahyは関係ありません"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@ekabal.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Philip Matthews Alcatel-Lucent 600 March Road Ottawa, Ontario Canada",
      "ja": "フィリップマシューズアルカテルルーセント600マーチロードオタワ、オンタリオカナダ"
    },
    {
      "indent": 3,
      "text": "EMail: philip_matthews@magma.ca",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jonathan Rosenberg jdrosen.net Monmouth, NJ USA",
      "ja": "Jonathan Rosenberg Jdrosen.net Monmouth、NJ USA"
    },
    {
      "indent": 3,
      "text": "EMail: jdrosen@jdrosen.net\nURI:   http://www.jdrosen.net",
      "raw": true,
      "ja": ""
    }
  ]
}