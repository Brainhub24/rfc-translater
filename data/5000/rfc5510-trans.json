{
  "title": {
    "text": "RFC 5510 - Reed-Solomon Forward Error Correction (FEC) Schemes",
    "ja": "RFC 5510 - リードソロモンフォワードエラー補正（FEC）スキーム"
  },
  "number": 5510,
  "created_at": "2023-03-15 19:17:15.471361+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                           J. Lacan\nRequest for Comments: 5510                                ISAE/LAAS-CNRS\nCategory: Standards Track                                        V. Roca\n                                                                   INRIA\n                                                            J. Peltotalo\n                                                            S. Peltotalo\n                                        Tampere University of Technology\n                                                              April 2009",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Reed-Solomon Forward Error Correction (FEC) Schemes",
      "ja": "リードソロモンフォワードエラー補正（FEC）スキーム"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2009 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびこのドキュメントの公開日（http://trustee.ietf.org/license-info）に有効なIETFドキュメントに関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの貢献からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得しないと、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版または英語以外の言語に翻訳する。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a Fully-Specified Forward Error Correction (FEC) Scheme for the Reed-Solomon FEC codes over GF(2^^m), where m is in {2..16}, and its application to the reliable delivery of data objects on the packet erasure channel (i.e., a communication path where packets are either received without any corruption or discarded during transmission). This document also describes a Fully-Specified FEC Scheme for the special case of Reed-Solomon codes over GF(2^^8) when there is no encoding symbol group. Finally, in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129), this document assigns an FEC Instance ID to the special case of Reed-Solomon codes over GF(2^^8).",
      "ja": "このドキュメントでは、GF（2 ^^ M）を介したReed-Solomon FECコードの完全に指定されたフォワードエラー補正（FEC）スキーム（Mが{2..16}）と、データの信頼できる配信への適用について説明します。パケット消去チャネル上のオブジェクト（つまり、パケットが破損せずに受信されるか、送信中に破棄される通信パス）。このドキュメントでは、エンコードシンボルグループがない場合のGF（2 ^^ 8）をめぐるReed-Solomonコードの特別なケースのための完全に指定されたFECスキームについても説明しています。最後に、不足している小さなブロック系統的FECスキーム（FECエンコードID 129）のコンテキストで、このドキュメントは、GF（2 ^^ 8）を介したReed-Solomonコードの特別なケースにFECインスタンスIDを割り当てます。"
    },
    {
      "indent": 3,
      "text": "Reed-Solomon codes belong to the class of Maximum Distance Separable (MDS) codes, i.e., they enable a receiver to recover the k source symbols from any set of k received symbols. The schemes described here are compatible with the implementation from Luigi Rizzo.",
      "ja": "Reed-Solomonコードは、最大距離分離可能な（MDS）コードのクラスに属します。つまり、受信したシンボルのセットからkソース記号を受信者が回復できるようにします。ここで説明するスキームは、Luigi Rizzoの実装と互換性があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n2. Terminology .....................................................5\n3. Definitions Notations and Abbreviations .........................5\n   3.1. Definitions ................................................5\n   3.2. Notations ..................................................6\n   3.3. Abbreviations ..............................................7\n4. Formats and Codes with FEC Encoding ID 2 ........................7\n   4.1. FEC Payload ID .............................................7\n   4.2. FEC Object Transmission Information ........................8\n        4.2.1. Mandatory Elements ..................................8\n        4.2.2. Common Elements .....................................8\n        4.2.3. Scheme-Specific Elements ............................9\n        4.2.4. Encoding Format .....................................9\n5. Formats and Codes with FEC Encoding ID 5 .......................11\n   5.1. FEC Payload ID ............................................11\n   5.2. FEC Object Transmission Information .......................12\n        5.2.1. Mandatory Elements .................................12\n        5.2.2. Common Elements ....................................12\n        5.2.3. Scheme-Specific Elements ...........................12\n        5.2.4. Encoding Format ....................................12\n6. Procedures with FEC Encoding IDs 2 and 5 .......................13\n   6.1. Determining the Maximum Source Block Length (B) ...........13\n   6.2. Determining the Number of Encoding Symbols of a Block .....14\n7. Small Block Systematic FEC Scheme (FEC Encoding ID 129)\n   and Reed-Solomon Codes over GF(2^^8) ...........................15\n8. Reed-Solomon Codes Specification for the Erasure Channel .......16\n   8.1. Finite Field ..............................................16\n   8.2. Reed-Solomon Encoding Algorithm ...........................17\n        8.2.1. Encoding Principles ................................17\n        8.2.2. Encoding Complexity ................................18\n   8.3. Reed-Solomon Decoding Algorithm ...........................18\n        8.3.1. Decoding Principles ................................18\n        8.3.2. Decoding Complexity ................................19\n   8.4. Implementation for the Packet Erasure Channel .............19\n9. Security Considerations ........................................22\n   9.1. Problem Statement .........................................22\n   9.2. Attacks against the Data Flow .............................23\n        9.2.1. Access to Confidential Objects .....................23\n        9.2.2. Content Corruption .................................23\n   9.3. Attacks against the FEC Parameters ........................24\n10. IANA Considerations ...........................................25\n11. Acknowledgments ...............................................25\n12. References ....................................................26\n   12.1. Normative References .....................................26\n   12.2. Informative References ...................................26",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The use of Forward Error Correction (FEC) codes is a classical solution to improve the reliability of multicast and broadcast transmissions. The [RFC5052] document describes a general framework to use FEC in Content Delivery Protocols (CDPs). The companion document [RFC3453] describes some applications of FEC codes for content delivery.",
      "ja": "フォワードエラー補正（FEC）コードの使用は、マルチキャストとブロードキャストの送信の信頼性を改善するための古典的なソリューションです。[RFC5052]ドキュメントは、コンテンツ配信プロトコル（CDP）でFECを使用する一般的なフレームワークについて説明しています。コンパニオンドキュメント[RFC3453]は、コンテンツ配信のためのFECコードのいくつかのアプリケーションについて説明しています。"
    },
    {
      "indent": 3,
      "text": "Recent FEC schemes like [RFC5053] and [RFC5170] proposed erasure codes based on sparse graphs/matrices. These codes are efficient in terms of processing but not optimal in terms of correction capabilities when dealing with \"small\" objects.",
      "ja": "[RFC5053]や[RFC5170]などの最近のFECスキームは、スパースグラフ/マトリックスに基づいて消去コードを提案しました。これらのコードは、処理の点で効率的ですが、「小さな」オブジェクトを扱う際の補正機能の点では最適ではありません。"
    },
    {
      "indent": 3,
      "text": "The FEC schemes described in this document belongs to the class of Maximum Distance Separable codes that are optimal in terms of erasure correction capability. In others words, it enables a receiver to recover the k source symbols from any set of exactly k encoding symbols. They are also systematic codes, which means that the k source symbols are part of the encoding symbols. Even if the encoding/decoding complexity is larger than that of [RFC5053] or [RFC5170], this family of codes is very useful.",
      "ja": "このドキュメントで説明されているFECスキームは、消去補正機能の観点から最適な最大距離分離可能なコードのクラスに属します。他の言葉では、レシーバーは、正確なKエンコードシンボルのセットからkソース記号を回復することができます。また、体系的なコードです。つまり、Kソースシンボルはエンコードシンボルの一部です。エンコード/デコードの複雑さが[RFC5053]または[RFC5170]のエンコード/デコードが大きい場合でも、このコードファミリは非常に便利です。"
    },
    {
      "indent": 3,
      "text": "Many applications dealing with content transmission or content storage already rely on packet-based Reed-Solomon codes. In particular, many of them use the Reed-Solomon codec of Luigi Rizzo [RS-codec] [Rizzo97]. The goal of the present document is to specify an implementation of Reed-Solomon codes that is compatible with this codec.",
      "ja": "コンテンツの送信またはコンテンツストレージを扱う多くのアプリケーションは、すでにパケットベースのReed-Solomonコードに依存しています。特に、それらの多くは、Luigi Rizzo [RS-Codec] [Rizzo97]のReed-Solomon Codecを使用しています。現在のドキュメントの目標は、このコーデックと互換性のあるリードソロモンコードの実装を指定することです。"
    },
    {
      "indent": 3,
      "text": "The present document:",
      "ja": "現在のドキュメント："
    },
    {
      "indent": 3,
      "text": "o introduces the Fully-Specified FEC Scheme with FEC Encoding ID 2, which specifies the use of Reed-Solomon codes over GF(2^^m), where m is in {2..16},",
      "ja": "o FECをエンコードするID 2を使用して完全に指定されたFECスキームを導入します。これは、GF（2 ^^ m）を介したリードソロモンコードの使用を指定します。ここで、mは{2..16}です。"
    },
    {
      "indent": 3,
      "text": "o introduces the Fully-Specified FEC Scheme with FEC Encoding ID 5, which focuses on the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group (i.e., exactly one symbol per packet), and",
      "ja": "o FECをエンコードID 5で完全に指定したFECスキームを導入します。これは、GF（2 ^^ 8）およびエンコードシンボルグループ（つまり、パケットごとに1つのシンボル）を介したリードソロモンコードの特別なケースに焦点を当てています。"
    },
    {
      "indent": 3,
      "text": "o in the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129) [RFC5445], assigns the FEC Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "ja": "o 不足していない小さなブロック系統的FECスキーム（FECエンコードID129）[RFC5445）のコンテキストでは、FECインスタンスID 0をGF（2 ^^ 8）上のリードソロモンコードの特別なケースに割り当て、エンコードシンボルはありませんグループ。"
    },
    {
      "indent": 3,
      "text": "For a definition of the terms Fully-Specified and Under-Specified FEC Schemes, see [RFC5052], Section 4.",
      "ja": "完全に指定されていないFECスキームの用語の定義については、[RFC5052]、セクション4を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Definitions Notations and Abbreviations",
      "section_title": true,
      "ja": "3. 定義表記と略語"
    },
    {
      "indent": 0,
      "text": "3.1. Definitions",
      "section_title": true,
      "ja": "3.1. 定義"
    },
    {
      "indent": 3,
      "text": "This document uses the same terms and definitions as those specified in [RFC5052]. Additionally, it uses the following definitions:",
      "ja": "このドキュメントは、[RFC5052]で指定されている用語と同じ用語と定義を使用します。さらに、次の定義を使用します。"
    },
    {
      "indent": 6,
      "text": "Source symbol: unit of data used during the encoding process.",
      "ja": "ソースシンボル：エンコーディングプロセス中に使用されるデータの単位。"
    },
    {
      "indent": 6,
      "text": "Encoding symbol: unit of data generated by the encoding process.",
      "ja": "エンコーディングシンボル：エンコードプロセスによって生成されたデータの単位。"
    },
    {
      "indent": 6,
      "text": "Repair symbol: encoding symbol that is not a source symbol.",
      "ja": "修復シンボル：ソースシンボルではないエンコードシンボル。"
    },
    {
      "indent": 6,
      "text": "Code rate: the k/n ratio, i.e., the ratio between the number of source symbols and the number of encoding symbols. By definition, the code rate is such that: 0 < code rate <= 1. A code rate close to 1 indicates that a small number of repair symbols have been produced during the encoding process.",
      "ja": "コードレート：K/N比、つまり、ソースシンボルの数とエンコーディングシンボルの数との比率。定義上、コードレートは次のとおりです。0<コードレート<= 1に近いコードレートは、エンコーディングプロセス中に少数の修復記号が生成されたことを示します。"
    },
    {
      "indent": 6,
      "text": "Systematic code: FEC code in which the source symbols are part of the encoding symbols.",
      "ja": "系統的コード：ソースシンボルがエンコードシンボルの一部であるFECコード。"
    },
    {
      "indent": 6,
      "text": "Source block: a block of k source symbols that are considered together for the encoding.",
      "ja": "ソースブロック：エンコーディングのために一緒に考慮されるKソース記号のブロック。"
    },
    {
      "indent": 6,
      "text": "Encoding Symbol Group: a group of encoding symbols that are sent together within the same packet, and whose relationships to the source block can be derived from a single Encoding Symbol ID.",
      "ja": "エンコーディングシンボルグループ：同じパケット内で一緒に送信され、ソースブロックとの関係を単一のエンコードシンボルIDから導き出すことができるエンコードシンボルのグループ。"
    },
    {
      "indent": 6,
      "text": "Source Packet: a data packet containing only source symbols.",
      "ja": "ソースパケット：ソース記号のみを含むデータパケット。"
    },
    {
      "indent": 6,
      "text": "Repair Packet: a data packet containing only repair symbols.",
      "ja": "修理パケット：修理記号のみを含むデータパケット。"
    },
    {
      "indent": 6,
      "text": "Packet Erasure Channel: a communication path where packets are either dropped (e.g., by a congested router, or because the number of transmission errors exceeds the correction capabilities of the physical layer codes) or received. When a packet is received, it is assumed that this packet is not corrupted.",
      "ja": "パケット消去チャネル：パケットがドロップされる通信パス（たとえば、混雑したルーターによって、または伝送エラーの数が物理層コードの修正機能を超えるため）または受信した通信パス。パケットが受信されると、このパケットが破損していないと想定されます。"
    },
    {
      "indent": 0,
      "text": "3.2. Notations",
      "section_title": true,
      "ja": "3.2. 表記"
    },
    {
      "indent": 3,
      "text": "This document uses the following notations:",
      "ja": "このドキュメントでは、次の表記法を使用しています。"
    },
    {
      "indent": 6,
      "text": "L the object transfer length in bytes.",
      "ja": "lバイト単位のオブジェクト転送長。"
    },
    {
      "indent": 6,
      "text": "k the number of source symbols in a source block.",
      "ja": "kソースブロック内のソース記号の数。"
    },
    {
      "indent": 6,
      "text": "n_r the number of repair symbols generated for a source block.",
      "ja": "N_Rソースブロック用に生成された修理記号の数。"
    },
    {
      "indent": 6,
      "text": "n the encoding block length, i.e., the number of encoding symbols generated for a source block. Therefore: n = k + n_r.",
      "ja": "nエンコーディングブロック長、つまり、ソースブロックに生成されたエンコードシンボルの数。したがって、n = k n_r。"
    },
    {
      "indent": 6,
      "text": "max_n the maximum number of encoding symbols generated for any source block.",
      "ja": "max_n任意のソースブロックに対して生成されたエンコードシンボルの最大数。"
    },
    {
      "indent": 6,
      "text": "B the maximum source block length in symbols, i.e., the maximum number of source symbols per source block.",
      "ja": "bシンボルの最大ソースブロック長、つまりソースブロックごとのソース記号の最大数。"
    },
    {
      "indent": 6,
      "text": "N the number of source blocks into which the object shall be partitioned.",
      "ja": "nオブジェクトが分割されるソースブロックの数。"
    },
    {
      "indent": 6,
      "text": "E the encoding symbol length in bytes.",
      "ja": "eバイトのエンコーディングシンボル長。"
    },
    {
      "indent": 6,
      "text": "S the symbol size in units of m-bit elements. When m = 8, then S and E are equal.",
      "ja": "s Mビット要素の単位のシンボルサイズ。M = 8の場合、SとEは等しくなります。"
    },
    {
      "indent": 6,
      "text": "m the length of the elements in the finite field, in bits. In this document, m belongs to {2..16}.",
      "ja": "M有限フィールドの要素の長さ、ビット。このドキュメントでは、mは{2..16}に属します。"
    },
    {
      "indent": 6,
      "text": "q the number of elements in the finite field. We have: q = 2^^m in this specification.",
      "ja": "Q有限フィールドの要素の数。この仕様にはq = 2 ^^ mがあります。"
    },
    {
      "indent": 6,
      "text": "G the number of encoding symbols per group, i.e., the number of symbols sent in the same packet.",
      "ja": "gグループごとのエンコーディングシンボルの数、つまり、同じパケットで送信されるシンボルの数。"
    },
    {
      "indent": 6,
      "text": "GM the Generator Matrix of a Reed-Solomon code.",
      "ja": "GMリードソロモンコードのジェネレーターマトリックス。"
    },
    {
      "indent": 6,
      "text": "CR the \"code rate\", i.e., the k/n ratio.",
      "ja": "CR「コードレート」、つまりK/N比。"
    },
    {
      "indent": 6,
      "text": "a^^b a raised to the power b.",
      "ja": "a ^^ b a a a power b。"
    },
    {
      "indent": 6,
      "text": "a^^-1 the inverse of a.",
      "ja": "a ^^ -1 aの逆数。"
    },
    {
      "indent": 6,
      "text": "I_k the k*k identity matrix.",
      "ja": "i_k k*k Identityマトリックス。"
    },
    {
      "indent": 0,
      "text": "3.3. Abbreviations",
      "section_title": true,
      "ja": "3.3. 略語"
    },
    {
      "indent": 3,
      "text": "This document uses the following abbreviations:",
      "ja": "このドキュメントでは、次の略語を使用しています。"
    },
    {
      "indent": 6,
      "text": "ESI Encoding Symbol ID.",
      "ja": "ESIエンコードシンボルID。"
    },
    {
      "indent": 6,
      "text": "FEC OTI FEC Object Transmission Information.",
      "ja": "FEC OTI FECオブジェクト伝送情報。"
    },
    {
      "indent": 6,
      "text": "RS Reed-Solomon.",
      "ja": "RSリードソロモン。"
    },
    {
      "indent": 6,
      "text": "MDS Maximum Distance Separable code.",
      "ja": "MDS最大距離分離可能なコード。"
    },
    {
      "indent": 6,
      "text": "GF(q) a finite field (also known as Galois Field) with q elements. We assume that q = 2^^m in this document.",
      "ja": "GF（Q）Q要素を備えた有限フィールド（ガロワフィールドとも呼ばれます）。このドキュメントではq = 2 ^^ mであると想定しています。"
    },
    {
      "indent": 0,
      "text": "4. Formats and Codes with FEC Encoding ID 2",
      "section_title": true,
      "ja": "4. ID 2をエンコードするFECを使用したフォーマットとコード"
    },
    {
      "indent": 3,
      "text": "This section introduces the formats and codes associated with the Fully-Specified FEC Scheme with FEC Encoding ID 2, which specifies the use of Reed-Solomon codes over GF(2^^m).",
      "ja": "このセクションでは、GF（2 ^^ m）を介したリードソロモンコードの使用を指定するFECを使用して、完全に指定されたFECスキームに関連するフォーマットとコードを紹介します。"
    },
    {
      "indent": 0,
      "text": "4.1. FEC Payload ID",
      "section_title": true,
      "ja": "4.1. FECペイロードID"
    },
    {
      "indent": 3,
      "text": "The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID. The lengths of these two fields depend on the parameter m (which is transmitted in the FEC OTI) as follows:",
      "ja": "FECペイロードIDは、ソースブロック番号とエンコードシンボルIDで構成されています。これらの2つのフィールドの長さは、次のようにパラメーターM（FEC OTIで送信されます）に依存します。"
    },
    {
      "indent": 3,
      "text": "o The Source Block Number (field of size 32-m bits) identifies from which source block of the object the encoding symbol(s) in the payload are generated. There is a maximum of 2^^(32-m) blocks per object.",
      "ja": "o ソースブロック番号（サイズ32 mビットのフィールド）は、ペイロードのエンコーディングシンボルが生成されるオブジェクトのソースブロックから識別します。オブジェクトごとに最大2 ^^（32-m）ブロックがあります。"
    },
    {
      "indent": 3,
      "text": "o The Encoding Symbol ID (field of size m bits) identifies which specific encoding symbol(s) generated from the source block are carried in the packet payload. There is a maximum of 2^^m encoding symbols per block. The first k values (0 to k - 1) identify source symbols, the remaining n-k values identify repair symbols.",
      "ja": "o エンコーディングシンボルID（サイズMビットのフィールド）は、ソースブロックから生成された特定のエンコードシンボルがパケットペイロードに掲載されるかを識別します。ブロックごとに最大2 ^^ mエンコードシンボルがあります。最初のk値（0からk -1）はソースシンボルを識別し、残りのn -k値は修復記号を識別します。"
    },
    {
      "indent": 3,
      "text": "There MUST be exactly one FEC Payload ID per source or repair packet. In case of an Encoding Symbol Group, when multiple encoding symbols are sent in the same packet, the FEC Payload ID refers to the first symbol of the packet. The other symbols can be deduced from the ESI of the first symbol by incrementing sequentially the ESI.",
      "ja": "ソースまたは修理パケットごとにFECペイロードIDが1つだけある必要があります。エンコードシンボルグループの場合、複数のエンコードシンボルが同じパケットで送信される場合、FECペイロードIDはパケットの最初のシンボルを指します。他のシンボルは、ESIを連続的に増加させることにより、最初のシンボルのESIから推定できます。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|     Source Block Number (32-8=24 bits)        | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 1: FEC Payload ID Encoding Format for m = 8 (Default)",
      "ja": "図1：M = 8のFECペイロードIDエンコード形式（デフォルト）"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n| Src Block Nb (32-16=16 bits)  |  Enc. Symbol ID (m=16 bits)   |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Figure 2: FEC Payload ID Encoding Format for m = 16",
      "ja": "図2：M = 16のFECペイロードIDエンコード形式"
    },
    {
      "indent": 3,
      "text": "The formats of the FEC Payload ID for m = 8 and m = 16 are illustrated in Figure 1 and Figure 2, respectively.",
      "ja": "M = 8およびM = 16のFECペイロードIDの形式を、それぞれ図1と図2に示します。"
    },
    {
      "indent": 0,
      "text": "4.2. FEC Object Transmission Information",
      "section_title": true,
      "ja": "4.2. FECオブジェクト伝送情報"
    },
    {
      "indent": 0,
      "text": "4.2.1. Mandatory Elements",
      "section_title": true,
      "ja": "4.2.1. 必須要素"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 2.",
      "ja": "o FECエンコーディングID：このセクションで説明する完全に指定されたFECスキームでは、FECエンコーディングID 2を使用します。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Common Elements",
      "section_title": true,
      "ja": "4.2.2. 一般的な要素"
    },
    {
      "indent": 3,
      "text": "The following elements MUST be defined with the present FEC scheme.",
      "ja": "次の要素は、現在のFECスキームで定義する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Transfer-Length (L): a non-negative integer indicating the length of the object in bytes. There are some restrictions on the maximum Transfer-Length that can be supported:",
      "ja": "o トランスファーレングス（L）：バイト内のオブジェクトの長さを示す非陰性整数。サポートできる最大転送長にはいくつかの制限があります。"
    },
    {
      "indent": 9,
      "text": "max_transfer_length = 2^^(32-m) * B * E",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "For instance, for m = 8, for B = 2^^8 - 1 (because the codec operates on a finite field with 2^^8 elements), and if E = 1024 bytes, then the maximum transfer length is approximately equal to 2^^42 bytes (i.e., 4 terabytes). Similarly, for m = 16, for B = 2^^16 - 1, and if E = 1024 bytes, then the maximum transfer length is also approximately equal to 2^^42 bytes. For larger objects, another FEC scheme, with a larger Source Block Number field in the FEC Payload ID, could be defined. Another solution consists in fragmenting large objects into smaller objects, each of them complying with the above limits.",
      "ja": "たとえば、m = 8の場合、b = 2 ^^ 8-1の場合（コーデックは2 ^^ 8要素を持つ有限フィールドで動作するため）。2 ^^ 42バイト（つまり、4テラバイト）。同様に、m = 16の場合、b = 2 ^^ 16-1の場合、およびe = 1024バイトの場合、最大転送長は2 ^^ 42バイトにもほぼ等しくなります。より大きなオブジェクトの場合、FECペイロードIDに大きなソースブロック番号フィールドを備えた別のFECスキームを定義できます。別のソリューションは、大きなオブジェクトを小さなオブジェクトに断片化することで構成されており、それぞれが上記の制限に準拠しています。"
    },
    {
      "indent": 3,
      "text": "o Encoding-Symbol-Length (E): a non-negative integer indicating the length of each encoding symbol in bytes.",
      "ja": "o エンコーディング-Symbol-Length（e）：バイト内の各エンコーディングシンボルの長さを示す非陰性整数。"
    },
    {
      "indent": 3,
      "text": "o Maximum-Source-Block-Length (B): a non-negative integer indicating the maximum number of source symbols in a source block.",
      "ja": "o 最大ソースブロック長（b）：ソースブロック内のソース記号の最大数を示す非陰性整数。"
    },
    {
      "indent": 3,
      "text": "o Max-Number-of-Encoding-Symbols (max_n): a non-negative integer indicating the maximum number of encoding symbols generated for any source block.",
      "ja": "o Max-Number-of-Encoding-Symbols（MAX_N）：ソースブロックに生成されたエンコード記号の最大数を示す非陰性整数。"
    },
    {
      "indent": 3,
      "text": "Section 6 explains how to derive the values of each of these elements.",
      "ja": "セクション6では、これらの各要素の値を導出する方法について説明します。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Scheme-Specific Elements",
      "section_title": true,
      "ja": "4.2.3. スキーム固有の要素"
    },
    {
      "indent": 3,
      "text": "The following element MUST be defined with the present FEC scheme. It contains two distinct pieces of information:",
      "ja": "次の要素は、現在のFECスキームで定義する必要があります。2つの異なる情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "o G: a non-negative integer indicating the number of encoding symbols per group used for the object. The default value is 1, meaning that each packet contains exactly one symbol. When no G parameter is communicated to the decoder, then the latter MUST assume that G = 1.",
      "ja": "o G：オブジェクトに使用されるグループごとのエンコード記号の数を示す非陰性整数。デフォルトの値は1です。つまり、各パケットには1つのシンボルが正確に含まれています。Gパラメーターがデコーダーに通信されない場合、後者はG = 1と仮定する必要があります。"
    },
    {
      "indent": 3,
      "text": "o m: The m parameter is the length of the finite field elements, in bits. It also characterizes the number of elements in the finite field: q = 2^^m elements. The default value is m = 8. When no finite field size parameter is communicated to the decoder, then the latter MUST assume that m = 8.",
      "ja": "o M：Mパラメーターは、ビット内の有限フィールド要素の長さです。また、有限フィールドの要素の数を特徴付けます：q = 2 ^^ m要素。デフォルト値はM = 8です。フィールドサイズの有限サイズパラメーターがデコーダーに通信されない場合、後者はM = 8と仮定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.4. Encoding Format",
      "section_title": true,
      "ja": "4.2.4. エンコード形式"
    },
    {
      "indent": 3,
      "text": "This section shows the two possible encoding formats of the above FEC OTI. The present document does not specify when one encoding format or the other should be used.",
      "ja": "このセクションでは、上記のFEC OTIの2つの可能なエンコード形式を示します。現在のドキュメントでは、1つのエンコード形式またはもう1つのドキュメントを使用する必要がある場合は指定されていません。"
    },
    {
      "indent": 0,
      "text": "4.2.4.1. Using the General EXT_FTI Format",
      "section_title": true,
      "ja": "4.2.4.1. 一般的なext_fti形式を使用します"
    },
    {
      "indent": 3,
      "text": "The FEC OTI binary format is the following, when the EXT_FTI mechanism is used (e.g., within the ALC [ALC] or NORM [NORM] protocols).",
      "ja": "fec otiバイナリ形式は、ext_ftiメカニズムが使用される場合（たとえば、alc [alc]またはnorm [norm]プロトコル）を使用します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   HET = 64    |    HEL = 4    |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                      Transfer Length (L)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       m       |       G       |   Encoding Symbol Length (E)  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|  Max Source Block Length (B)  |  Max Nb Enc. Symbols (max_n)  |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 3: EXT_FTI Header Format",
      "ja": "図3：ext_ftiヘッダー形式"
    },
    {
      "indent": 0,
      "text": "4.2.4.2. Using the FDT Instance (FLUTE specific)",
      "section_title": true,
      "ja": "4.2.4.2. FDTインスタンスの使用（フルート固有）"
    },
    {
      "indent": 3,
      "text": "When it is desired that the FEC OTI be carried in the FDT (File Delivery Table) Instance of a FLUTE session [FLUTE], the following XML attributes must be described for the associated object:",
      "ja": "FEC OTIをFDT（ファイル配信テーブル）フルートセッション[フルート]のインスタンスに携帯することが望ましい場合は、次のXML属性を関連するオブジェクトについて説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-FEC-Encoding-ID",
      "ja": "o FEC-OTI-FEC-ENCODING-ID"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Transfer-Length (L)",
      "ja": "o fec-oti transfer-length（l）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Encoding-Symbol-Length (E)",
      "ja": "o fec-oti-encoding-symbol-length（e）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Maximum-Source-Block-Length (B)",
      "ja": "o fec-oti-maximum-source-block-length（b）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)",
      "ja": "o fec-oti-max-number-of-encoding-symbols（max_n）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Scheme-Specific-Info",
      "ja": "o FEC-OTI-SCHEME特異的INFO"
    },
    {
      "indent": 3,
      "text": "The FEC-OTI-Scheme-Specific-Info contains the string resulting from the Base64 encoding (in the XML Schema xs:base64Binary sense) of the following value:",
      "ja": "FEC-OTI-SCHEME特異的INFOには、次の値のbase64エンコード（XMLスキーマXS：base64Birany感覚）から生じる文字列が含まれています。"
    },
    {
      "indent": 3,
      "text": " 0                   1\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|       m       |       G       |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "Figure 4: FEC OTI Scheme Specific Information To Be Included in the FDT Instance",
      "ja": "図4：FEC OTIスキームFDTインスタンスに含まれる特定の情報"
    },
    {
      "indent": 3,
      "text": "When no m parameter is to be carried in the FEC OTI, the m field is set to 0 (which is not a valid seed value). Otherwise, the m field contains a valid value as explained in Section 4.2.3. Similarly, when no G parameter is to be carried in the FEC OTI, the G field is set to 0 (which is not a valid seed value). Otherwise, the G field contains a valid value as explained in Section 4.2.3. When neither m nor G are to be carried in the FEC OTI, then the sender simply omits the FEC-OTI-Scheme-Specific-Info attribute.",
      "ja": "FEC OTIでMパラメーターを運ばない場合、Mフィールドは0に設定されています（これは有効な種子値ではありません）。それ以外の場合、Mフィールドには、セクション4.2.3で説明されているように有効な値が含まれています。同様に、gパラメーターがfec otiに運ばれない場合、gフィールドは0に設定されています（これは有効なシード値ではありません）。それ以外の場合、Gフィールドには、セクション4.2.3で説明されているように有効な値が含まれています。MもGもFEC OTIで運ばない場合、送信者はFEC-OTI-SCHEME固有のINFO属性を単純に省略します。"
    },
    {
      "indent": 3,
      "text": "During Base64 encoding, the 2 bytes of the FEC OTI Scheme-Specific Information are transformed into a string of 4 printable characters (in the 64-character alphabet) that is added to the FEC-OTI-Scheme-Specific-Info attribute.",
      "ja": "Base64エンコーディング中、FEC OTIスキーム固有の情報の2バイトは、FEC-OTI-SCHEME固有のINFO属性に追加される4つの印刷可能な文字（64文字のアルファベット）の文字列に変換されます。"
    },
    {
      "indent": 0,
      "text": "5. Formats and Codes with FEC Encoding ID 5",
      "section_title": true,
      "ja": "5. ID 5をエンコードするFECを使用したフォーマットとコード"
    },
    {
      "indent": 3,
      "text": "This section introduces the formats and codes associated with the Fully-Specified FEC Scheme with FEC Encoding ID 5, which focuses on the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "ja": "このセクションでは、FECをエンコードするID 5を使用した完全に指定されたFECスキームに関連するフォーマットとコードを紹介します。これは、GF（2 ^^ 8）およびエンコードシンボルグループを介したリードソロモンコードの特別なケースに焦点を当てています。"
    },
    {
      "indent": 0,
      "text": "5.1. FEC Payload ID",
      "section_title": true,
      "ja": "5.1. FECペイロードID"
    },
    {
      "indent": 3,
      "text": "The FEC Payload ID is composed of the Source Block Number and the Encoding Symbol ID:",
      "ja": "FECペイロードIDは、ソースブロック番号とエンコードシンボルIDで構成されています。"
    },
    {
      "indent": 3,
      "text": "o The Source Block Number (24-bit field) identifies from which source block of the object the encoding symbol in the payload is generated. There is a maximum of 2^^24 blocks per object.",
      "ja": "o ソースブロック番号（24ビットフィールド）は、ペイロード内のエンコードシンボルが生成されるオブジェクトのソースブロックから識別します。オブジェクトごとに最大2 ^^ 24ブロックがあります。"
    },
    {
      "indent": 3,
      "text": "o The Encoding Symbol ID (8-bit field) identifies which specific encoding symbol generated from the source block is carried in the packet payload. There is a maximum of 2^^8 encoding symbols per block. The first k values (0 to k - 1) identify source symbols; the remaining n-k values identify repair symbols.",
      "ja": "o エンコーディングシンボルID（8ビットフィールド）は、ソースブロックから生成された特定のエンコードシンボルがパケットペイロード内で運ばれるかを識別します。ブロックごとに最大2つの^^ 8エンコードシンボルがあります。最初のk値（0からk -1）はソースシンボルを識別します。残りのn-k値は、修復記号を識別します。"
    },
    {
      "indent": 3,
      "text": "There MUST be exactly one FEC Payload ID per source or repair packet. This FEC Payload ID refers to the one and only symbol of the packet.",
      "ja": "ソースまたは修理パケットごとにFECペイロードIDが1つだけある必要があります。このFECペイロードIDは、パケットの唯一のシンボルを指します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|        Source Block Number (24 bits)          | Enc. Symb. ID |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 5: FEC Payload ID Encoding Format with FEC Encoding ID 5",
      "ja": "図5：FECエンコードID 5を使用したFECペイロードIDエンコード形式"
    },
    {
      "indent": 0,
      "text": "5.2. FEC Object Transmission Information",
      "section_title": true,
      "ja": "5.2. FECオブジェクト伝送情報"
    },
    {
      "indent": 0,
      "text": "5.2.1. Mandatory Elements",
      "section_title": true,
      "ja": "5.2.1. 必須要素"
    },
    {
      "indent": 3,
      "text": "o FEC Encoding ID: the Fully-Specified FEC Scheme described in this section uses FEC Encoding ID 5.",
      "ja": "o FECエンコーディングID：このセクションで説明する完全に指定されたFECスキームでは、FECエンコーディングID 5を使用します。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Common Elements",
      "section_title": true,
      "ja": "5.2.2. 一般的な要素"
    },
    {
      "indent": 3,
      "text": "The Common elements are the same as those specified in Section 4.2.2 when m = 8 and G = 1.",
      "ja": "共通要素は、M = 8およびG = 1の場合、セクション4.2.2で指定された要素と同じです。"
    },
    {
      "indent": 0,
      "text": "5.2.3. Scheme-Specific Elements",
      "section_title": true,
      "ja": "5.2.3. スキーム固有の要素"
    },
    {
      "indent": 3,
      "text": "No Scheme-Specific elements are defined by this FEC scheme.",
      "ja": "このFECスキームでは、スキーム固有の要素は定義されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.4. Encoding Format",
      "section_title": true,
      "ja": "5.2.4. エンコード形式"
    },
    {
      "indent": 3,
      "text": "This section shows the two possible encoding formats of the above FEC OTI. The present document does not specify when one encoding format or the other should be used.",
      "ja": "このセクションでは、上記のFEC OTIの2つの可能なエンコード形式を示します。現在のドキュメントでは、1つのエンコード形式またはもう1つのドキュメントを使用する必要がある場合は指定されていません。"
    },
    {
      "indent": 0,
      "text": "5.2.4.1. Using the General EXT_FTI Format",
      "section_title": true,
      "ja": "5.2.4.1. 一般的なext_fti形式を使用します"
    },
    {
      "indent": 3,
      "text": "The FEC OTI binary format is the following, when the EXT_FTI mechanism is used (e.g., within the ALC [ALC] or NORM [NORM] protocols).",
      "ja": "fec otiバイナリ形式は、ext_ftiメカニズムが使用される場合（たとえば、alc [alc]またはnorm [norm]プロトコル）を使用します。"
    },
    {
      "indent": 3,
      "text": " 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   HET = 64    |    HEL = 3    |                               |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n|                      Transfer Length (L)                      |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|   Encoding Symbol Length (E)  | MaxBlkLen (B) |     max_n     |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 6: EXT_FTI Header Format with FEC Encoding ID 5",
      "ja": "図6：FECをエンコードするID5を備えたExt_ftiヘッダー形式"
    },
    {
      "indent": 0,
      "text": "5.2.4.2. Using the FDT Instance (FLUTE specific)",
      "section_title": true,
      "ja": "5.2.4.2. FDTインスタンスの使用（フルート固有）"
    },
    {
      "indent": 3,
      "text": "When it is desired that the FEC OTI be carried in the FDT Instance of a FLUTE session [FLUTE], the following XML attributes must be described for the associated object:",
      "ja": "FEC OTIをフルートセッション[フルート]のFDTインスタンスに携帯することが望ましい場合は、関連するオブジェクトについて次のXML属性を説明する必要があります。"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-FEC-Encoding-ID o FEC-OTI-Transfer-Length (L)",
      "ja": "o FEC-OTI-FEC-ENCODING-ID O FEC-OTI-TRANSFER-LENGTH（L）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Encoding-Symbol-Length (E)",
      "ja": "o fec-oti-encoding-symbol-length（e）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Maximum-Source-Block-Length (B)",
      "ja": "o fec-oti-maximum-source-block-length（b）"
    },
    {
      "indent": 3,
      "text": "o FEC-OTI-Max-Number-of-Encoding-Symbols (max_n)",
      "ja": "o fec-oti-max-number-of-encoding-symbols（max_n）"
    },
    {
      "indent": 0,
      "text": "6. Procedures with FEC Encoding IDs 2 and 5",
      "section_title": true,
      "ja": "6. ID 2および5のFECエンコードを使用した手順"
    },
    {
      "indent": 3,
      "text": "This section defines procedures that are common to FEC Encoding IDs 2 and 5. In case of FEC Encoding ID 5, m = 8 and G = 1. The block partitioning algorithm that is defined in Section 9.1 of [RFC5052] MUST be used with FEC Encoding IDs 2 and 5.",
      "ja": "このセクションでは、FECをエンコードするID 2および5に共通する手順を定義します。FECをエンコードするID 5、M = 8、およびg = 1の場合、[RFC5052]のセクション9.1で定義されているブロックパーティションアルゴリズムは、FECで使用する必要があります。ID 2および5のエンコード。"
    },
    {
      "indent": 0,
      "text": "6.1. Determining the Maximum Source Block Length (B)",
      "section_title": true,
      "ja": "6.1. 最大ソースブロック長の決定（b）"
    },
    {
      "indent": 3,
      "text": "The finite field size parameter, m, defines the number of non-zero elements in this field, which is equal to: q - 1 = 2^^m - 1. Note that q - 1 is also the theoretical maximum number of encoding symbols that can be produced for a source block. For instance, when m = 8 (default) there is a maximum of 2^^8 - 1 = 255 encoding symbols.",
      "ja": "有限のフィールドサイズパラメーターMは、このフィールドの非ゼロ要素の数を定義します。これはQ -1 = 2 ^^ m -1に等しい。ソースブロック用に作成できます。たとえば、m = 8（デフォルト）の場合、最大2 ^^ 8-1 = 255エンコードシンボルがあります。"
    },
    {
      "indent": 3,
      "text": "Given the target FEC code rate (e.g., provided by the user when starting a FLUTE sending application), the sender calculates:",
      "ja": "ターゲットFECコードレート（たとえば、フルートの送信アプリケーションを開始するときにユーザーが提供する）を考えると、送信者は次のように計算します。"
    },
    {
      "indent": 6,
      "text": "max1_B = floor((2^^m - 1) * CR)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This max1_B value leaves enough room for the sender to produce the desired number of parity symbols.",
      "ja": "このmax1_b値は、送信者が望ましい数のパリティシンボルを生成するのに十分なスペースを残します。"
    },
    {
      "indent": 3,
      "text": "Additionally, a codec MAY impose other limitations on the maximum block size. Yet it is not expected that such limits exist when using the default m = 8 value. This decision MUST be clarified at implementation time, when the target use case is known. This results in a max2_B limitation.",
      "ja": "さらに、コーデックは最大ブロックサイズに他の制限を課す場合があります。しかし、デフォルトのM = 8値を使用する場合、そのような制限が存在することは予想されません。この決定は、ターゲットユースケースが既知の場合に、実装時に明確にする必要があります。これにより、MAX2_Bの制限が得られます。"
    },
    {
      "indent": 3,
      "text": "Then, B is given by:",
      "ja": "次に、Bは次のように与えられます。"
    },
    {
      "indent": 6,
      "text": "B = min(max1_B, max2_B)",
      "ja": "b = min（max1_b、max2_b）"
    },
    {
      "indent": 3,
      "text": "Note that this calculation is only required at the coder, since the B parameter is communicated to the decoder through the FEC OTI.",
      "ja": "BパラメーターはFEC OTIを介してデコーダーに通信されるため、この計算はコーダーでのみ必要であることに注意してください。"
    },
    {
      "indent": 0,
      "text": "6.2. Determining the Number of Encoding Symbols of a Block",
      "section_title": true,
      "ja": "6.2. ブロックのエンコーディングシンボルの数を決定します"
    },
    {
      "indent": 3,
      "text": "The following algorithm, also called \"n-algorithm\", explains how to determine the maximum number of encoding symbols generated for any source block (max_n) and the number of encoding symbols for a given block (n) as a function of the target code rate.",
      "ja": "「n-アルゴリズム」とも呼ばれる次のアルゴリズムは、ターゲットコードの関数として、任意のソースブロック（max_n）に生成されたエンコーディングシンボルの最大数と、特定のブロック（n）のエンコードシンボルの数を決定する方法を説明します。レート。"
    },
    {
      "indent": 3,
      "text": "AT A SENDER:",
      "ja": "送信者で："
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "B: Maximum source block length, for any source block. Section 6.1 explains how to determine its value.",
      "ja": "B：ソースブロックの最大ソースブロック長。セクション6.1では、その価値を決定する方法について説明します。"
    },
    {
      "indent": 6,
      "text": "k: Current source block length. This parameter is given by the block partitioning algorithm.",
      "ja": "K：現在のソースブロック長。このパラメーターは、ブロックパーティションアルゴリズムによって与えられます。"
    },
    {
      "indent": 6,
      "text": "CR: FEC code rate, which is given by the user (e.g., when starting a FLUTE sending application). It is expressed as a floating point value.",
      "ja": "CR：FECコードレート。これは、ユーザーによって与えられます（たとえば、フルートの送信アプリケーションを開始するとき）。これは、浮動小数点値として表されます。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "max_n: Maximum number of encoding symbols generated for any source block.",
      "ja": "MAX_N：ソースブロックに対して生成されたエンコードシンボルの最大数。"
    },
    {
      "indent": 6,
      "text": "n: Number of encoding symbols generated for this source block.",
      "ja": "N：このソースブロックに生成されたエンコードシンボルの数。"
    },
    {
      "indent": 3,
      "text": "Algorithm:",
      "ja": "アルゴリズム："
    },
    {
      "indent": 6,
      "text": "max_n = ceil(B / CR);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "if (max_n > 2^^m - 1), then return an error (\"invalid code rate\");",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "n = floor(k * max_n / B);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "AT A RECEIVER:",
      "ja": "レシーバーで："
    },
    {
      "indent": 3,
      "text": "Input:",
      "ja": "入力："
    },
    {
      "indent": 6,
      "text": "B: Extracted from the received FEC OTI.",
      "ja": "B：受信したFEC OTIから抽出。"
    },
    {
      "indent": 6,
      "text": "max_n: Extracted from the received FEC OTI.",
      "ja": "MAX_N：受信したFEC OTIから抽出。"
    },
    {
      "indent": 6,
      "text": "k: Given by the block partitioning algorithm.",
      "ja": "K：ブロックパーティションアルゴリズムによって与えられます。"
    },
    {
      "indent": 3,
      "text": "Output:",
      "ja": "出力："
    },
    {
      "indent": 6,
      "text": "n",
      "ja": "n"
    },
    {
      "indent": 3,
      "text": "Algorithm:",
      "ja": "アルゴリズム："
    },
    {
      "indent": 6,
      "text": "n = floor(k * max_n / B);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It is RECOMMENDED that the \"n-algorithm\" be used by a sender, but other algorithms remain possible to determine max_n and/or n.",
      "ja": "「n-アルゴリズム」を送信者が使用することをお勧めしますが、MAX_Nおよび/またはnを決定するために他のアルゴリズムは引き続き可能です。"
    },
    {
      "indent": 3,
      "text": "At a receiver, the max_n value is extracted from the received FEC OTI. Since the Reed-Solomon decoder does not need to know the actual n value, using the receiver part of the \"n-algorithm\" is not necessary from a decoding point of view.",
      "ja": "受信機では、MAX_N値が受信したFEC OTIから抽出されます。Reed-Solomon Decoderは実際のn値を知る必要はないため、「n-algorithm」の受信部品を使用することは、デコードの観点からは必要ありません。"
    },
    {
      "indent": 3,
      "text": "However, a receiver may want to have an estimate of n for other reasons (e.g., for memory management purposes). In that case, a receiver knows that the number of encoding symbols of a block cannot exceed max_n. Additionally, if a receiver believes that a sender uses the \"n-algorithm\", this receiver MAY use the receiver part of the \"n-algorithm\" to get a better estimate of n. When this is the case, a receiver MUST be prepared to handle symbols with an Encoding Symbol ID superior or equal to the computed n value (e.g., it can choose to simply drop them).",
      "ja": "ただし、受信者は、他の理由で（メモリ管理の目的など）、Nの推定値を持ちたい場合があります。その場合、レシーバーは、ブロックのエンコード記号の数がMAX_Nを超えないことを知っています。さらに、受信者が送信者が「nアルゴリズム」を使用すると信じている場合、このレシーバーは「nアルゴリズム」の受信者部分を使用してnのより良い推定値を取得することができます。この場合、レシーバーは、計算されたn値よりも優れているか等しいエンコードシンボルIDでシンボルを処理するために準備する必要があります（たとえば、単にドロップすることを選択できます）。"
    },
    {
      "indent": 0,
      "text": "7. Small Block Systematic FEC Scheme (FEC Encoding ID 129) and Reed-Solomon Codes over GF(2^^8)",
      "section_title": true,
      "ja": "7. GFを介した小さなブロック系統的FECスキーム（FECエンコードID 129）およびリードソロモンコード（2 ^^ 8）"
    },
    {
      "indent": 3,
      "text": "In the context of the Under-Specified Small Block Systematic FEC Scheme (FEC Encoding ID 129) [RFC5445], this document assigns the FEC Instance ID 0 to the special case of Reed-Solomon codes over GF(2^^8) and no encoding symbol group.",
      "ja": "不足していない小さなブロック系統的FECスキーム（FECエンコードID 129）[RFC5445）のコンテキストでは、このドキュメントは、GF（2 ^^ 8）およびNO NOを介したReed-Solomonコードの特別なケースにFECインスタンスID 0を割り当てます。シンボルグループをエンコードします。"
    },
    {
      "indent": 3,
      "text": "The FEC Instance ID 0 uses the Formats and Codes specified in [RFC5445].",
      "ja": "FECインスタンスID 0は、[RFC5445]で指定された形式とコードを使用します。"
    },
    {
      "indent": 3,
      "text": "The FEC scheme with FEC Instance ID 0 MAY use the block partitioning algorithm defined in Section 9.1 of [RFC5052] to partition the object into source blocks. This FEC scheme MAY also use another algorithm. For instance, the CDP sender may change the length of each source block dynamically, depending on some external criteria (e.g., to adjust the FEC coding rate to the current loss rate experienced by NORM receivers) and inform the CDP receivers of the current block length by means of the EXT_FTI mechanism. This choice is out of the scope of the current document.",
      "ja": "FECインスタンスID 0を使用したFECスキームは、[RFC5052]のセクション9.1で定義されたブロックパーティションアルゴリズムを使用して、オブジェクトをソースブロックに分割することができます。このFECスキームは、別のアルゴリズムを使用する場合もあります。たとえば、CDP送信者は、一部の外部基準（たとえば、NORM受信機が経験した現在の損失率にFECコーディングレートを調整する）に応じて、各ソースブロックの長さを動的に変更し、CDPレシーバーに現在のブロックレジットを通知する場合があります。ext_ftiメカニズムによって。この選択は、現在のドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "8. Reed-Solomon Codes Specification for the Erasure Channel",
      "section_title": true,
      "ja": "8. Reed-Solomonコードは、消去チャネルの仕様をコードします"
    },
    {
      "indent": 3,
      "text": "Reed-Solomon (RS) codes are linear block codes. They also belong to the class of MDS codes. A [n,k]-RS code encodes a sequence of k source elements defined over a finite field GF(q) into a sequence of n encoding elements, where n is upper bounded by q - 1. The implementation described in this document is based on a generator matrix built from a Vandermonde matrix put into systematic form.",
      "ja": "Reed-Solomon（RS）コードは線形ブロックコードです。また、MDSコードのクラスにも属します。a [n、k] -RSコードは、有限フィールドGF（q）を介して定義されたkソース要素のシーケンスをエンコードして、nがq -1によって上限に境界があるnエンコード要素のシーケンスにエンコードします。このドキュメントで説明する実装はです。系統的な形に置かれたヴァンダーモンドマトリックスから構築されたジェネレーターマトリックスに基づいています。"
    },
    {
      "indent": 3,
      "text": "Sections 8.1 to 8.3 specify the [n,k]-RS codes when applied to m-bit elements, and Section 8.4 specifies the use of [n,k]-RS codes when applied to symbols composed of several m-bit elements. The use described in Section 8.4 is the crux of this specification.",
      "ja": "セクション8.1〜8.3は、Mビット要素に適用されたときに[n、k] -RSコードを指定し、セクション8.4は、いくつかのMビット要素で構成されるシンボルに適用された場合の[n、k] -RSコードの使用を指定します。セクション8.4で説明する使用は、この仕様の核心です。"
    },
    {
      "indent": 3,
      "text": "A reader who wants to understand the underlying theory is invited to refer to references [Rizzo97] and [MWS77].",
      "ja": "基礎となる理論を理解したい読者は、参照[Rizzo97]および[MWS77]を参照するように招待されています。"
    },
    {
      "indent": 0,
      "text": "8.1. Finite Field",
      "section_title": true,
      "ja": "8.1. 有限フィールド"
    },
    {
      "indent": 3,
      "text": "A finite field GF(q) is defined as a finite set of q elements that has a structure of field. It contains necessarily q = p^^m elements, where p is a prime number. With packet erasure channels, p is always set to 2. The elements of the field GF(2^^m) can be represented by polynomials with binary coefficients (i.e., over GF(2)) of degree lower or equal to m-1. The polynomials can be associated with binary vectors of length m. For example, the vector (11001) represents the polynomial 1 + x + x^^4. This representation is often called polynomial representation. The addition between two elements is defined as the addition of binary polynomials in GF(2) and the multiplication is the multiplication modulo a given irreducible polynomial over GF(2) of degree m. Note that all the roots of this polynomial are in GF(2^^m) but not in GF(2).",
      "ja": "有限フィールドGF（Q）は、フィールドの構造を持つQ要素の有限セットとして定義されます。必然的にq = p ^^ m要素が含まれ、pは素数です。パケット消去チャネルでは、Pは常に2に設定されます。フィールドGF（2 ^^ m）の要素は、M-1以下のバイナリ係数（すなわち、GF（2）を超える）を持つ多項式で表現できます。。多項式は、長さmのバイナリベクターに関連付けられます。たとえば、ベクトル（11001）は多項式1 x x ^^ 4を表します。この表現は、しばしば多項式表現と呼ばれます。2つの要素間の添加は、GF（2）のバイナリ多項式の添加として定義され、乗算は、程度mのGF（2）にわたって与えられた既約多項式の乗算モジュロです。この多項式のすべての根はGF（2 ^^ m）にあるが、GF（2）にはないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "The chosen polynomial representation of the finite field GF(2^^m) is completely characterized by the irreducible polynomial. The following polynomials are chosen to represent the field GF(2^^m), for m varying from 2 to 16:",
      "ja": "有限フィールドGF（2 ^^ m）の選択された多項式表現は、既約多項式によって完全に特徴付けられます。2から16までのmの場合、フィールドGF（2 ^^ m）を表すために、次の多項式が選択されています。"
    },
    {
      "indent": 6,
      "text": "m = 2, \"111\" (1+x+x^^2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 3, \"1101\", (1+x+x^^3)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 4, \"11001\", (1+x+x^^4)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 5, \"101001\", (1+x^^2+x^^5)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 6, \"1100001\", (1+x+x^^6)\n      m = 7, \"10010001\", (1+x^^3+x^^7)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 8, \"101110001\", (1+x^^2+x^^3+x^^4+x^^8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 9, \"1000100001\", (1+x^^4+x^^9)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 10, \"10010000001\", (1+x^^3+x^^10)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 11, \"101000000001\", (1+x^^2+x^^11)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 12, \"1100101000001\", (1+x+x^^4+x^^6+x^^12)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 13, \"11011000000001\", (1+x+x^^3+x^^4+x^^13)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 14, \"110000100010001\", (1+x+x^^6+x^^10+x^^14)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 15, \"1100000000000001\", (1+x+x^^15)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "m = 16, \"11010000000010001\", (1+x+x^^3+x^^12+x^^16)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In order to facilitate the implementation, these polynomials are also primitive. This means that any element of GF(2^^m) can be expressed as a power of a given root of this polynomial. These polynomials are also chosen so that they contain the minimum number of monomials.",
      "ja": "実装を促進するために、これらの多項式も原始的です。これは、GF（2 ^^ m）のすべての要素が、この多項式の特定の根の力として表現できることを意味します。これらの多項式も選択されているため、最小数のモノマリアルが含まれています。"
    },
    {
      "indent": 0,
      "text": "8.2. Reed-Solomon Encoding Algorithm",
      "section_title": true,
      "ja": "8.2. Reed-Solomonエンコードアルゴリズム"
    },
    {
      "indent": 0,
      "text": "8.2.1. Encoding Principles",
      "section_title": true,
      "ja": "8.2.1. エンコード原則"
    },
    {
      "indent": 3,
      "text": "Let s = (s_0, ..., s_{k-1}) be a source vector of k elements over\nGF(2^^m).  Let e = (e_0, ..., e_{n-1}) be the corresponding encoding\nvector of n elements over GF(2^^m).  Being a linear code, encoding is\nperformed by multiplying the source vector by a generator matrix, GM,\nof k rows and n columns over GF(2^^m).  Thus:",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "e = s * GM.",
      "ja": "e = s * gm。"
    },
    {
      "indent": 3,
      "text": "The definition of the generator matrix completely characterizes the RS code.",
      "ja": "ジェネレーターマトリックスの定義は、RSコードを完全に特徴付けます。"
    },
    {
      "indent": 3,
      "text": "Let us consider that n = 2^^m - 1 and that 0 < k <= n. Let us denote by alpha the root of the primitive polynomial of degree m chosen in the list of Section 8.1 for the corresponding value of m. Let us consider a Vandermonde matrix of k rows and n columns, denoted by V_{k,n}, and built as follows: the {i, j} entry of V_{k,n} is v_{i,j} = alpha^^(i*j), where 0 <= i <= k - 1 and 0 <= j <= n - 1. This matrix generates a MDS code. However, this MDS code is not systematic, which is a problem for many networking applications. To obtain a systematic matrix (and code), the simplest solution consists in considering the matrix V_{k,k} formed by the first k columns of V_{k,n}, then to invert it and to multiply this inverse by V_{k,n}. Clearly, the product V_{k,k}^^-1 * V_{k,n} contains the identity matrix I_k on its first k columns, meaning that the first k encoding elements are equal to source elements. Besides, the associated code keeps the MDS property.",
      "ja": "n = 2 ^^ m -1と0 <k <= nを考えてみましょう。Alphaは、Mの対応する値について、セクション8.1のリストで選択された次数mの原始多項式の根を示します。v_ {k、n}で示され、次のように構築されたk行とn列のヴァンダーモンドマトリックスを考えてみましょう。v_{k、n}の{i、j}エントリはv_ {i、j} = alphaです^^（i*j）、ここで、0 <= i <= k -1および0 <= j <= n -1。このマトリックスはMDSコードを生成します。ただし、このMDSコードは体系的ではなく、多くのネットワーキングアプリケーションにとって問題です。系統的行列（およびコード）を取得するために、最も単純なソリューションは、V_ {k、n}の最初のk列によって形成されたマトリックスV_ {k、k}を考慮し、それを反転させ、v_ {K、n}。明らかに、製品v_ {k、k} ^^ -1 * v_ {k、n}には、最初のk列にIDマトリックスi_kが含まれています。つまり、最初のkエンコード要素はソース要素に等しいことを意味します。その上、関連するコードはMDSプロパティを保持します。"
    },
    {
      "indent": 3,
      "text": "Therefore, the generator matrix of the code considered in this document is:",
      "ja": "したがって、このドキュメントで検討されているコードのジェネレーターマトリックスは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "GM = (V_{k,k}^^-1) * V_{k,n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that, in practice, the [n,k]-RS code can be shortened to a [n',k]-RS code, where k <= n' < n, by considering the sub-matrix formed by the n' first columns of GM.",
      "ja": "実際には、[n、k] -RSコードは、n 'によって形成されたサブマトリックスを考慮することにより、k <= n' <nでa [n '、k] -RSコードに短縮できることに注意してください。GMの最初の列。"
    },
    {
      "indent": 0,
      "text": "8.2.2. Encoding Complexity",
      "section_title": true,
      "ja": "8.2.2. 複雑さのエンコード"
    },
    {
      "indent": 3,
      "text": "Encoding can be performed by first pre-computing GM and by multiplying the source vector (k elements) by GM (k rows and n columns). The complexity of the pre-computation of the generator matrix can be estimated as the complexity of the multiplication of the inverse of a Vandermonde matrix by n-k vectors (i.e., the last n-k columns of V_{k,n}). Since the complexity of the inverse of a k*k-Vandermonde matrix by a vector is O(k * (log(k))^^2), the generator matrix can be computed in 0((n-k)* k * (log(k))^^2)) operations. When the generator matrix is pre-computed, the encoding needs k operations per repair element (vector-matrix multiplication).",
      "ja": "エンコーディングは、最初の事前計算GMと、ソースベクトル（k要素）にGM（k行とn列）を掛けることで実行できます。発電機マトリックスの事前計算の複雑さは、n-kベクター（すなわち、v_ {k、n}の最後のn-k列）によるヴァンダーモンドマトリックスの逆の乗算の複雑さとして推定できます。ベクトルによるk * k-vandermondeマトリックスの逆の複雑さはo（k *（log（k））^^ 2）であるため、ジェネレーターマトリックスは0（（n-k） * k *（log（log））で計算できます。k））^^ 2））操作。発電機マトリックスが事前に計算されている場合、エンコーディングは修復要素ごとにK操作が必要です（ベクトルマトリックス増殖）。"
    },
    {
      "indent": 3,
      "text": "Encoding can also be performed by first computing the product s *\nV_{k,k}^^-1 and then by multiplying the result with V_{k,n}.  The\nmultiplication by the inverse of a square Vandermonde matrix is known\nas the interpolation problem and its complexity is O(k *\n(log(k))^^2).  The multiplication by a Vandermonde matrix, known as\nthe multipoint evaluation problem, requires O((n-k) * log(k)) by\nusing Fast Fourier Transform, as explained in [GO94].  The total\ncomplexity of this encoding algorithm is then O((k/(n-k)) *\n(log(k))^^2 + log(k)) operations per repair element.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8.3. Reed-Solomon Decoding Algorithm",
      "section_title": true,
      "ja": "8.3. リードソロモンデコードアルゴリズム"
    },
    {
      "indent": 0,
      "text": "8.3.1. Decoding Principles",
      "section_title": true,
      "ja": "8.3.1. デコード原則"
    },
    {
      "indent": 3,
      "text": "The Reed-Solomon decoding algorithm for the erasure channel allows the recovery of the k source elements from any set of k received elements. It is based on the fundamental property of the generator matrix, which is such that any k*k-submatrix is invertible (see",
      "ja": "消去チャネルのReed-Solomonデコードアルゴリズムにより、kの受信要素のセットからkソース要素を回復することができます。これは、発電機マトリックスの基本的な特性に基づいています。これは、k*k-submatrixが反転可能であるようなものです（参照"
    },
    {
      "indent": 3,
      "text": "[MWS77]). The first step of the decoding consists in extracting the k*k submatrix of the generator matrix obtained by considering the columns corresponding to the received elements. Indeed, since any encoding element is obtained by multiplying the source vector by one column of the generator matrix, the received vector of k encoding elements can be considered as the result of the multiplication of the source vector by a k*k submatrix of the generator matrix. Since this submatrix is invertible, the second step of the algorithm is to invert this matrix and to multiply the received vector by the obtained matrix to recover the source vector.",
      "ja": "[MWS77]）。デコードの最初のステップは、受信した要素に対応する列を考慮することにより得られた発電機マトリックスのk*kサブマトリックスを抽出することです。実際、エンコード要素はソースベクトルにジェネレーターマトリックスの1つの列を掛けることで取得されるため、K*Kサブマトリックスによるソースベクトルの増殖の結果として、K*Kサブマトリックスによるソースベクトルの乗算の結果として考慮されます。。このサブマトリックスは反転可能であるため、アルゴリズムの2番目のステップは、このマトリックスを反転させ、受信したベクトルに取得したマトリックスを掛けてソースベクトルを回復することです。"
    },
    {
      "indent": 0,
      "text": "8.3.2. Decoding Complexity",
      "section_title": true,
      "ja": "8.3.2. 複雑さを解読します"
    },
    {
      "indent": 3,
      "text": "The decoding algorithm described previously includes the matrix inversion and the vector-matrix multiplication. With the classical Gauss-Jordan algorithm, the matrix inversion requires O(k^^3) operations and the vector-matrix multiplication is performed in O(k^^2) operations.",
      "ja": "以前に説明したデコードアルゴリズムには、マトリックスの反転とベクトルマトリックス乗算が含まれます。古典的なガウスヨルダンアルゴリズムでは、マトリックスの反転にはO（k ^^ 3）操作が必要であり、ベクターマトリックスの乗算はO（k ^^ 2）操作で実行されます。"
    },
    {
      "indent": 3,
      "text": "This complexity can be improved by considering that the received submatrix of GM is the product between the inverse of a Vandermonde matrix (V_(k,k)^^-1) and another Vandermonde matrix (denoted by V', which is a submatrix of V_(k,n)). The decoding can be done by multiplying the received vector by V'^^-1 (interpolation problem with complexity O( k * (log(k))^^2) ) then by V_{k,k} (multipoint evaluation with complexity O(k * log(k))). The global decoding complexity is then O((log(k))^^2) operations per source element.",
      "ja": "この複雑さは、GMの受信したサブマトリックスがヴァンダーモンドマトリックス（V_（k、k）^^ -1）の逆数と別のヴァンダーモンドマトリックス（v 'で示されています。V_（K、N））。デコードは、受信したベクトルにv '^^ -1（補間の複雑さO（k *（log（k））^^ 2））をv_ {k、k}（複雑さを伴うマルチポイント評価）を掛けることで実行できます。o（k * log（k）））。グローバルデコードの複雑さは、ソース要素ごとのo（（log（k））^^ 2）操作です。"
    },
    {
      "indent": 0,
      "text": "8.4. Implementation for the Packet Erasure Channel",
      "section_title": true,
      "ja": "8.4. パケット消去チャネルの実装"
    },
    {
      "indent": 3,
      "text": "In a packet erasure channel, each packet (including its symbol(s), since packets contain G >= 1 symbols) is either correctly received or erased. The location of the erased symbols in the sequence of symbols MUST be known. The following specification describes the use of Reed-Solomon codes for generating redundant symbols from the k source symbols and for recovering the source symbols from any set of k received symbols.",
      "ja": "パケット消去チャネルでは、各パケット（パケットにはg> = 1シンボルが含まれているため、そのシンボルを含む）が正しく受信または消去されます。シンボルのシーケンス内の消去されたシンボルの位置を知っておく必要があります。次の仕様では、Kソース記号から冗長記号を生成し、kの受信記号のセットからソース記号を回復するためのリードソロモンコードの使用について説明します。"
    },
    {
      "indent": 3,
      "text": "The k source symbols of a source block are assumed to be composed of S m-bit elements. Each m-bit element corresponds to an element of the finite field GF(2^^m) through the polynomial representation (Section 8.1). If some of the source symbols contain less than S elements, they MUST be virtually padded with zero elements (this can be the case for the last symbol of the last block of the object). However, this padding does not need to be actually sent with the data to the receivers.",
      "ja": "ソースブロックのKソース記号は、S Mビット要素で構成されていると想定されています。各Mビット要素は、多項式表現を介して有限フィールドGF（2 ^^ m）の要素に対応します（セクション8.1）。ソースシンボルの一部にSより少ない要素が含まれている場合、それらはゼロ要素で実質的にパディングする必要があります（これは、オブジェクトの最後のブロックの最後のシンボルに当てはまります）。ただし、このパディングは、データをレシーバーに実際に送信する必要はありません。"
    },
    {
      "indent": 3,
      "text": "The encoding process produces n encoding symbols of size S m-bit elements, of which k are source symbols (this is a systematic code) and n-k are repair symbols (Figure 7). The m-bit elements of the repair symbols are calculated using the corresponding m-bit elements of the source symbol set. A logical u-th source vector, comprised of the u-th elements from the set of source symbols, is used to calculate a u-th encoding vector. This u-th encoding vector then provides the u-th elements for the set encoding symbols calculated for the block. As a systematic code, the first k encoding symbols are the same as the k source symbols, and the last n-k repair symbols are the result of the Reed-Solomon encoding.",
      "ja": "エンコーディングプロセスは、サイズs mビット要素のnエンコードシンボルを生成し、そのkはソースシンボル（これは系統的コードです）、n-kは修復記号です（図7）。修復記号のMビット要素は、ソースシンボルセットの対応するMビット要素を使用して計算されます。ソースシンボルのセットからのU番目の要素で構成される論理U-Thソースベクトルは、U-Thエンコードベクトルを計算するために使用されます。このU-Thエンコードベクトルは、ブロックに対して計算されたセットエンコードシンボルのU-Th要素を提供します。系統的コードとして、最初のKエンコードシンボルはKソース記号と同じであり、最後のN-K修復シンボルはリードソロモンエンコードの結果です。"
    },
    {
      "indent": 10,
      "text": "Input: k source symbols",
      "ja": "入力：Kソースシンボル"
    },
    {
      "indent": 3,
      "text": " 0             u                                S-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol 0\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             . . .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | source symbol k-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "*",
      "ja": "*"
    },
    {
      "indent": 8,
      "text": "+--------------------+\n|  generator matrix  |\n|         GM         |\n|       (k x n)      |\n+--------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "| V",
      "ja": "|v"
    },
    {
      "indent": 8,
      "text": "Output: n encoding symbols (source + repair)",
      "ja": "出力：nエンコーディングシンボル（ソース修理）"
    },
    {
      "indent": 3,
      "text": " 0             u                                S-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | enc. symbol 0\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |X|                                 | enc. symbol 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             . . .\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|             |Y|                                 | enc. symbol n-1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 7: Packet Encoding Scheme",
      "ja": "図7：パケットエンコーディングスキーム"
    },
    {
      "indent": 3,
      "text": "An asset of this scheme is that the loss of some encoding symbols produces the same erasure pattern for each of the S encoding vectors. It follows that the matrix inversion must be done only once and will be used by all the S encoding vectors. For large S, this matrix inversion cost becomes negligible in front of the S vector-matrix multiplications.",
      "ja": "このスキームの資産は、一部のエンコードシンボルを失うと、各エンコードベクトルに対して同じ消去パターンが生成されることです。したがって、マトリックスの反転は一度だけ行われなければならず、すべてのsエンコードベクトルによって使用されます。大規模なSの場合、このマトリックス反転コストは、Sベクターマトリックス乗算の前で無視できます。"
    },
    {
      "indent": 3,
      "text": "Another asset is that the n-k repair symbols can be produced on demand. For instance, a sender can start by producing a limited number of repair symbols and later on, depending on the observed erasures on the channel, decide to produce additional repair symbols, up to the n-k upper limit. Indeed, to produce the repair symbol e_j, where k <= j < n, it is sufficient to multiply the S source vectors with column j of GM.",
      "ja": "別の資産は、N-K修復記号をオンデマンドで作成できることです。たとえば、送信者は、限られた数の修理記号を生成することから始まり、後でチャネルで観察された消去に応じて、N-Kの上限までの追加の修理記号を作成することを決定します。実際、修復記号E_Jを生成するには、k <= j <nでは、SソースベクトルにGMの列jを掛けるだけで十分です。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "9.1. Problem Statement",
      "section_title": true,
      "ja": "9.1. 問題文"
    },
    {
      "indent": 3,
      "text": "A content delivery system is potentially subject to many attacks: some of them target the network (e.g., to compromise the routing infrastructure, by compromising the congestion control component), others target the Content Delivery Protocol (CDP) (e.g., to compromise its normal behavior), and finally some attacks target the content itself. Since this document focuses on a FEC building block independently of any particular CDP (even if ALC and NORM are two natural candidates), this section only discusses the additional threats that an arbitrary CDP may be exposed to when using this building block.",
      "ja": "コンテンツ配信システムは、多くの攻撃の対象となる可能性があります。それらのいくつかはネットワークをターゲットにします（たとえば、輻輳制御コンポーネントを侵害することにより、ルーティングインフラストラクチャを侵害するため）、コンテンツ配信プロトコル（CDP）をターゲットにする他のもの（例えば、通常を損なうために動作）、最後にいくつかの攻撃はコンテンツ自体をターゲットにします。このドキュメントは、特定のCDPとは無関係にFECビルディングブロックに焦点を当てているため（ALCとNORMが2つの自然候補であっても）、このセクションでは、このビルディングブロックを使用するときに任意のCDPがさらされる可能性のある追加の脅威についてのみ説明します。"
    },
    {
      "indent": 3,
      "text": "More specifically, several kinds of attacks exist:",
      "ja": "より具体的には、いくつかの種類の攻撃が存在します："
    },
    {
      "indent": 3,
      "text": "o those that are meant to give access to confidential content (e.g., in case of non-free content),",
      "ja": "o 機密コンテンツにアクセスすることを意図したもの（例：非フリーコンテンツの場合）、"
    },
    {
      "indent": 3,
      "text": "o those that try to corrupt the object being transmitted (e.g., to inject malicious code within an object or to prevent a receiver from using an object),",
      "ja": "o 送信されているオブジェクトを破損しようとするもの（たとえば、オブジェクト内に悪意のあるコードを注入するか、受信者がオブジェクトを使用しないようにするため）、"
    },
    {
      "indent": 3,
      "text": "o and those that try to compromise the receiver's behavior (e.g., by making the decoding of an object computationally expensive).",
      "ja": "o そして、受信者の動作を妥協しようとするもの（たとえば、オブジェクトのデコードを計算高価にすることにより）。"
    },
    {
      "indent": 3,
      "text": "These attacks can be launched either against the data flow itself (e.g., by sending forged symbols) or against the FEC parameters that are sent either in-band (e.g., in an EXT_FTI or FDT Instance) or out-of-band (e.g., in a session description).",
      "ja": "これらの攻撃は、データフロー自体（たとえば、偽造シンボルを送信することにより）または帯域内（例えば、ext_ftiまたはfdtインスタンス）または帯域外（例：セッションの説明で）。"
    },
    {
      "indent": 0,
      "text": "9.2. Attacks against the Data Flow",
      "section_title": true,
      "ja": "9.2. データフローに対する攻撃"
    },
    {
      "indent": 3,
      "text": "First of all, let us consider the attacks against the data flow.",
      "ja": "まず、データフローに対する攻撃を考えてみましょう。"
    },
    {
      "indent": 0,
      "text": "9.2.1. Access to Confidential Objects",
      "section_title": true,
      "ja": "9.2.1. 機密オブジェクトへのアクセス"
    },
    {
      "indent": 3,
      "text": "Access control to the object being transmitted is typically provided by means of encryption. This encryption can be done over the whole object (e.g., by the content provider, before the FEC encoding process), or be done on a packet per-packet basis (e.g., when IPsec Encapsulating Security Payload (ESP) is used [RFC4303]). If access control is a concern, it is RECOMMENDED that one of these solutions be used. Even if we mention these attacks here, they are not related nor facilitated by the use of FEC.",
      "ja": "送信されるオブジェクトへのアクセス制御は、通常、暗号化によって提供されます。この暗号化は、オブジェクト全体（たとえば、FECエンコーディングプロセスの前にコンテンツプロバイダーによって）で実行されるか、パケットごとにパケットごとに実行できます（たとえば、セキュリティペイロードをカプセル化するIPSEC（ESP）が使用される場合[RFC4303]）。アクセス制御が懸念される場合は、これらのソリューションの1つを使用することをお勧めします。ここでこれらの攻撃に言及したとしても、FECの使用によって関連したり促進されたりしていません。"
    },
    {
      "indent": 0,
      "text": "9.2.2. Content Corruption",
      "section_title": true,
      "ja": "9.2.2. コンテンツの破損"
    },
    {
      "indent": 3,
      "text": "Protection against corruptions (e.g., after sending forged packets) is achieved by means of a content integrity verification/sender authentication scheme. This service can be provided at the object level, but in that case a receiver has no way to identify which symbol(s) are corrupted if the object is detected as corrupted. This service can also be provided at the packet level. In this case, after removing all forged packets, the object may be recovered sometimes. Several techniques can provide this source authentication/content integrity service:",
      "ja": "腐敗に対する保護（たとえば、偽造パケットを送信した後）は、コンテンツの整合性検証/送信者認証スキームによって達成されます。このサービスはオブジェクトレベルで提供できますが、その場合、受信者は、オブジェクトが破損していると検出された場合、どのシンボルが破損しているかを識別する方法がありません。このサービスは、パケットレベルでも提供できます。この場合、すべての鍛造パケットを削除した後、オブジェクトは時々回復することがあります。いくつかの手法では、このソース認証/コンテンツインテグリティサービスを提供できます。"
    },
    {
      "indent": 3,
      "text": "o At the object level, the object MAY be digitally signed (with public key cryptography), for instance by using RSASSA-PKCS1-v1_5 [RFC3447]. This signature enables a receiver to check the object integrity, once the object has been fully decoded. Even if digital signatures are computationally expensive, this calculation occurs only once per object, which is usually acceptable.",
      "ja": "o オブジェクトレベルでは、たとえばRSASSA-PKCS1-V1_5 [RFC3447]を使用して、オブジェクトがデジタル署名（公開キー暗号化）に署名することができます（公開キー暗号化）。この署名により、オブジェクトが完全にデコードされたら、受信機がオブジェクトの整合性を確認できます。デジタル署名が計算高価であっても、この計算はオブジェクトごとに1回のみ発生しますが、通常は許容されます。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, each packet can be digitally signed. A major limitation is the high computational and transmission overheads that this solution requires (unless Elliptic Curve Cryptography (ECC) is used). To avoid this problem, the signature may span a set of symbols (instead of a single one) in order to amortize the signature calculation. But if a single symbol is missing, the integrity of the whole set cannot be checked.",
      "ja": "o パケットレベルでは、各パケットにデジタル署名できます。主な制限は、このソリューションが必要とする高い計算および伝送オーバーヘッドです（楕円曲線暗号化（ECC）が使用されない限り）。この問題を回避するために、署名の計算を償却するために、署名は（単一のシンボルの代わりに）一連の記号に及ぶことがあります。ただし、単一のシンボルが欠落している場合、セット全体の整合性をチェックできません。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, a Group Message Authentication Code (MAC) [RFC2104] scheme can be used; for instance, by using HMAC-SHA-256 with a secret key shared by all the group members (i.e., the sender(s) and receivers). Thanks to the secret key, this technique creates a cryptographically secured digest of a packet that is sent along with the packet. The Group MAC scheme does not create prohibitive processing load nor transmission overhead, but it has a major limitation: it only provides a group authentication/integrity service since all group members share the same secret group key, which means that each member can send a forged packet. It is therefore restricted to situations where group members are fully trusted (or in association with another technique as a pre-check).",
      "ja": "o パケットレベルでは、グループメッセージ認証コード（MAC）[RFC2104]スキームを使用できます。たとえば、すべてのグループメンバー（つまり、送信者と受信機）が共有する秘密キーを持つHMAC-SHA-256を使用することにより。シークレットキーのおかげで、この手法は、パケットとともに送信されるパケットの暗号化されたダイジェストを作成します。Group MACスキームは、法外な処理負荷も張り出しもオーバーヘッドを作成しませんが、大きな制限があります。すべてのグループメンバーが同じシークレットグループキーを共有しているため、グループ認証/整合性サービスを提供します。つまり、各メンバーは偽造を送信できます。パケット。したがって、グループメンバーが完全に信頼されている（または事前チェックとしての別の手法に関連して）状況に制限されています。"
    },
    {
      "indent": 3,
      "text": "o At the packet level, TESLA [RFC4082] is a very attractive and efficient solution that is robust to losses, provides a true authentication/integrity service, and does not create any prohibitive processing load or transmission overhead. Yet checking a packet requires a small delay (a second or more) after its reception.",
      "ja": "o パケットレベルでは、Tesla [RFC4082]は、損失に対して堅牢で、真の認証/整合性サービスを提供する非常に魅力的で効率的なソリューションであり、禁止されている処理負荷またはトランスミッションオーバーヘッドを作成しません。しかし、パケットをチェックするには、受信後にわずかな遅延（1秒以上）が必要です。"
    },
    {
      "indent": 3,
      "text": "Techniques relying on public key cryptography (digital signatures and TESLA during the bootstrap process, when used) require that public keys be securely associated to the entities. This can be achieved by a Public Key Infrastructure (PKI), or by a PGP Web of Trust, or by pre-distributing the public keys of each group member.",
      "ja": "公開キーの暗号化（使用時にブートストラッププロセス中にデジタル署名とテスラ）に依存する手法では、パブリックキーがエンティティにしっかりと関連する必要があります。これは、公開キーインフラストラクチャ（PKI）、PGP Web of Trust、または各グループメンバーの公開キーを事前に配布することによって達成できます。"
    },
    {
      "indent": 3,
      "text": "Techniques relying on symmetric key cryptography (group MAC) require that a secret key be shared by all group members. This can be achieved by means of a group key management protocol, or simply by pre-distributing the secret key (but this manual solution has many limitations).",
      "ja": "対称キー暗号化（グループMAC）に依存する手法では、すべてのグループメンバーが秘密鍵を共有する必要があります。これは、グループキー管理プロトコルによって、または単にシークレットキーを事前に配置することで実現できます（ただし、この手動ソリューションには多くの制限があります）。"
    },
    {
      "indent": 3,
      "text": "It is up to the developer and deployer, who know the security requirements and features of the target application area, to define which solution is the most appropriate. Nonetheless, in case there is any concern of the threat of object corruption, it is RECOMMENDED that at least one of these techniques be used.",
      "ja": "ターゲットアプリケーション領域のセキュリティ要件と機能を知っている開発者と展開者次第で、どのソリューションが最も適切かを定義します。それにもかかわらず、オブジェクトの腐敗の脅威に懸念がある場合は、これらの手法の少なくとも1つを使用することをお勧めします。"
    },
    {
      "indent": 0,
      "text": "9.3. Attacks against the FEC Parameters",
      "section_title": true,
      "ja": "9.3. FECパラメーターに対する攻撃"
    },
    {
      "indent": 3,
      "text": "Let us now consider attacks against the FEC parameters (or FEC OTI). The FEC OTI can either be sent in-band (i.e., in an EXT_FTI or in an FDT Instance containing FEC OTI for the object) or out-of-band (e.g., in a session description). Attacks on these FEC parameters can prevent the decoding of the associated object: for instance, modifying the B parameter will lead to a different block partitioning at a receiver thereby compromising decoding; or setting the m parameter to 16 instead of 8 with FEC Encoding ID 2 will increase the processing load while compromising decoding.",
      "ja": "ここで、FECパラメーター（またはFEC OTI）に対する攻撃を考えてみましょう。fec otiは、バンド内（つまり、ext_ftiまたはオブジェクトのfec otiを含むfdtインスタンス）またはバンド外（たとえば、セッションの説明で）のいずれかを送信できます。これらのFECパラメーターへの攻撃により、関連するオブジェクトのデコードが妨げられます。たとえば、Bパラメーターを変更すると、レシーバーでの異なるブロックパーティションが表示され、デコードが損なわれます。または、FECエンコードID 2では、8の代わりにMパラメーターを16に設定すると、デコードが損なわれながら処理荷重が増加します。"
    },
    {
      "indent": 3,
      "text": "It is therefore RECOMMENDED that security measures be taken to guarantee the FEC OTI integrity. To that purpose, the packets carrying the FEC parameters sent in-band in an EXT_FTI header extension SHOULD be protected by one of the per-packet techniques described above: digital signature, group MAC, or TESLA. When FEC OTI is contained in an FDT Instance, this FDT Instance object SHOULD be protected, for instance, by digitally signing it with XML digital signatures [RFC3275]. Finally, when FEC OTI is sent out-of-band (e.g., in a session description), this FEC OTI SHOULD be protected, for instance, by digitally signing the object that includes this FEC OTI.",
      "ja": "したがって、FEC OTIの完全性を保証するためにセキュリティ対策を講じることをお勧めします。その目的のために、ext_ftiヘッダー拡張機能で帯域内で送信されたFECパラメーターを運ぶパケットは、上記のパケットごとの手法の1つであるデジタル署名、グループMAC、またはテスラによって保護する必要があります。FEC OTIがFDTインスタンスに含まれている場合、このFDTインスタンスオブジェクトは、たとえば、XMLデジタル署名[RFC3275]でデジタル的に署名することにより、保護する必要があります。最後に、FEC OTIが帯域外に送られる場合（たとえば、セッションの説明で）、このFEC OTIは、このFEC OTIを含むオブジェクトにデジタル署名することにより、保護する必要があります。"
    },
    {
      "indent": 3,
      "text": "The same considerations concerning the key management aspects apply here also.",
      "ja": "主要な管理の側面に関する同じ考慮事項もここにも当てはまります。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Values of FEC Encoding IDs and FEC Instance IDs are subject to IANA registration. For general guidelines on IANA considerations as they apply to this document, see [RFC5052].",
      "ja": "FECエンコードIDとFECインスタンスIDの値は、IANA登録の対象となります。IANAの考慮事項に関する一般的なガイドラインについては、この文書に適用されます。[RFC5052]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This document assigns the Fully-Specified FEC Encoding ID 2 under the \"ietf:rmt:fec:encoding\" name-space to \"Reed-Solomon Codes over GF(2^^m)\".",
      "ja": "このドキュメントでは、「IETF：RMT：FEC：「NAME-SPACE」に「GF（2 ^^ M）」をエンコードする「IETF：RMT：FEC：エンコード」の下に、完全に指定されたFECエンコードID 2を割り当てます。"
    },
    {
      "indent": 3,
      "text": "This document assigns the Fully-Specified FEC Encoding ID 5 under the \"ietf:rmt:fec:encoding\" name-space to \"Reed-Solomon Codes over GF(2^^8)\".",
      "ja": "このドキュメントでは、「IETF：RMT：FEC：「NAME-SPACE」に「GF（2 ^^ 8）」をエンコードする「IETF：RMT：FEC：エンコード」の下に、完全に指定されたFECエンコードID 5を割り当てます。"
    },
    {
      "indent": 3,
      "text": "This document assigns the FEC Instance ID 0 scoped by the Under-Specified FEC Encoding ID 129 to \"Reed-Solomon Codes over GF(2^^8)\". More specifically, under the \"ietf:rmt:fec:encoding:instance\" sub-name-space that is scoped by the \"ietf:rmt:fec:encoding\" called \"Small Block Systematic FEC Codes\", this document assigns FEC Instance ID 0 to \"Reed-Solomon Codes over GF(2^^8)\".",
      "ja": "このドキュメントは、不足しているFECインスタンスID 0を、不足しているFECエンコードID 129によって「GF（2 ^^ 8）上のリードソロモンコード」にscopedを割り当てます。より具体的には、「IETF：RMT：FEC：Encoding：Instance」の下で、「IETF：RMT：FEC：「Small Block Systematic FEC Codes」と呼ばれるエンコード」によってスコープされたサブ名ました。このドキュメントは、FECインスタンスIDを割り当てます0から「GF（2 ^^ 8）上のリードソロモンコード」。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgments",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors want to thank Brian Adamson, Igor Slepchin, Stephen Kent, Francis Dupont, Elwyn Davies, Magnus Westerlund, and Alfred Hoenes for their valuable comments. The authors also want to thank Luigi Rizzo for his comments and for the design of the reference Reed-Solomon codec.",
      "ja": "著者は、ブライアン・アダムソン、イゴール・スレプチン、スティーブン・ケント、フランシス・デュポン、エルウィン・デイヴィス、マグナス・ウェスターランド、そして彼らの貴重なコメントに感謝したいと考えています。著者はまた、Luigi Rizzoのコメントと参照リードソロモンコーデックのデザインについて感謝したいと考えています。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5052] Watson, M., Luby, M., and L. Vicisano, \"Forward Error Correction (FEC) Building Block\", RFC 5052, August 2007.",
      "ja": "[RFC5052] Watson、M.、Luby、M。、およびL. Vicisano、「フォワードエラー補正（FEC）ビルディングブロック」、RFC 5052、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5445] Watson, M., \"Basic Forward Error Correction (FEC) Schemes\", RFC 5445, March 2009.",
      "ja": "[RFC5445] Watson、M。、「基本的なフォワードエラー補正（FEC）スキーム」、RFC 5445、2009年3月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3453] Luby, M., Vicisano, L., Gemmell, J., Rizzo, L., Handley, M., and J. Crowcroft, \"The Use of Forward Error Correction (FEC) in Reliable Multicast\", RFC 3453, December 2002.",
      "ja": "[RFC3453] Luby、M.、Vicisano、L.、Gemmell、J.、Rizzo、L.、Handley、M。、およびJ. Crowcroft、「信頼できるマルチキャストでのフォワードエラー補正（FEC）の使用」、RFC 3453、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RS-codec] Rizzo, L., \"Reed-Solomon FEC codec\", available at http://info.iet.unipi.it/~luigi/vdm98/vdm980702.tgz and mirrored at http://planete-bcast.inrialpes.fr/, revised version of July 1998.",
      "ja": "[RS-Codec] Rizzo、L。、「Reed-Solomon FEC Codec」、http：//info.iet.unipi.it/~luigi/vdm98/vdm980702.tgzで入手し、http：// planete-bcastでミラーリングされています。.inrialpes.fr/、1998年7月の改訂版。"
    },
    {
      "indent": 3,
      "text": "[Rizzo97] Rizzo, L., \"Effective Erasure Codes for Reliable Computer Communication Protocols\", ACM SIGCOMM Computer Communication Review Vol.27, No.2, pp.24-36, April 1997.",
      "ja": "[Rizzo97] Rizzo、L。、「信頼できるコンピューター通信プロトコルの効果的な消去コード」、ACM Sigcomm Computer Communication Review Vol.27、No.2、pp.24-36、1997年4月。"
    },
    {
      "indent": 3,
      "text": "[MWS77] Mac Williams, F. and N. Sloane, \"The Theory of Error Correcting Codes\", North Holland, 1977.",
      "ja": "[MWS77] Mac Williams、F。およびN. Sloane、「エラー修正コードの理論」、North Holland、1977。"
    },
    {
      "indent": 3,
      "text": "[GO94] Gohberg, I. and V. Olshevsky, \"Fast algorithms with preprocessing for matrix-vector multiplication problems\", Journal of Complexity, pp. 411-427, vol. 10, 1994.",
      "ja": "[GO94] Gohberg、I。およびV. Olshevsky、「マトリックスベクトル乗算の問題に対する前処理を伴う高速アルゴリズム」、Journal of Complexity、pp。411-427、vol。10、1994。"
    },
    {
      "indent": 3,
      "text": "[RFC5170] Roca, V., Neumann, C., and D. Furodet, \"Low Density Parity Check (LDPC) Forward Error Correction\", RFC 5170, June 2008.",
      "ja": "[RFC5170] Roca、V.、Neumann、C。、およびD. Furodet、「低密度パリティチェック（LDPC）前方エラー補正」、RFC 5170、2008年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5053] Luby, M., Shokrollahi, A., Watson, M., and T. Stockhammer, \"Raptor Forward Error Correction Scheme\", RFC 5053, October 2007.",
      "ja": "[RFC5053] Luby、M.、Shokrollahi、A.、Watson、M。、およびT. Stockhammer、「Raptor Forward Error Correction Scheme」、RFC 5053、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[ALC] Luby, M., Watson, M., and L. Vicisano, \"Asynchronous Layered Coding (ALC) Protocol Instantiation\", Work in Progress, November 2008.",
      "ja": "[ALC] Luby、M.、Watson、M。、およびL. Vicisano、「非同期層コーディング（ALC）プロトコルインスタンス化」、2008年11月、作業進行中。"
    },
    {
      "indent": 3,
      "text": "[NORM] Adamson, B., Bormann, C., Handley, M., and J. Macker, \"NACK-Oriented Reliable Multicast Protocol\", Work in Progress, March 2009.",
      "ja": "[Norm] Adamson、B.、Bormann、C.、Handley、M。、およびJ. Macker、「Nack指向の信頼できるマルチキャストプロトコル」、2009年3月、Work in Progress。"
    },
    {
      "indent": 3,
      "text": "[FLUTE] Paila, T., Walsh, R., Luby, M., Lehtonen, R., and V. Roca, \"FLUTE - File Delivery over Unidirectional Transport\", Work in Progress, September 2008.",
      "ja": "[Flute] Paila、T.、Walsh、R.、Luby、M.、Lehtonen、R.、およびV. Roca、「フルート - 単方向輸送を介したファイル配信」、2008年9月の進行中。"
    },
    {
      "indent": 3,
      "text": "[RFC3447] Jonsson, J. and B. Kaliski, \"Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1\", RFC 3447, February 2003.",
      "ja": "[RFC3447] Jonsson、J.およびB. Kaliski、「Public-Key Cryptography Standards（PKCS）＃1：RSA暗号仕様バージョン2.1」、RFC 3447、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303] Kent、S。、「セキュリティペイロード（ESP）」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104]「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC4082] \"Timed Efficient Stream Loss-Tolerant Authentication (TESLA): Multicast Source Authentication Transform Introduction\", RFC 4082, June 2005.",
      "ja": "[RFC4082]「タイムされた効率的なストリーム損失耐性認証（TESLA）：マルチキャストソース認証変換導入」、RFC 4082、2005年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3275] Eastlake 3rd, D., Reagle, J., and D. Solo, \"(Extensible Markup Language) XML-Signature Syntax and Processing\", RFC 3275, March 2002.",
      "ja": "[RFC3275] EastLake 3rd、D.、Reagle、J。、およびD. Solo、 \"（拡張可能なマークアップ言語）XML-Signature構文と処理\"、RFC 3275、2002年3月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Jerome Lacan ISAE/LAAS-CNRS 1, place Emile Blouin Toulouse 31056 France",
      "ja": "ジェロームラカンイサエ/laas-cnrs 1、場所エミールブルーイントゥールーズ31056フランス"
    },
    {
      "indent": 3,
      "text": "EMail: jerome.lacan@isae.fr\nURI:   http://pagespro.isae.fr/jerome-lacan/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Vincent Roca INRIA 655, av. de l'Europe Inovallee; Montbonnot ST ISMIER cedex 38334 France",
      "ja": "Vincent Roca Inria 655、av。de l'Ueporn Inovallee;Montbonnot St Ismier Cedex 38334フランス"
    },
    {
      "indent": 3,
      "text": "EMail: vincent.roca@inria.fr\nURI:   http://planete.inrialpes.fr/people/roca/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jani Peltotalo Tampere University of Technology P.O. Box 553 (Korkeakoulunkatu 1) Tampere FIN-33101 Finland",
      "ja": "Jani Peltotalo Tampere Technology P.O.Box 553（Korkeakoulunkatu 1）Tampere Fin-33101フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: jani.peltotalo@tut.fi\nURI:   http://mad.cs.tut.fi/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Sami Peltotalo Tampere University of Technology P.O. Box 553 (Korkeakoulunkatu 1) Tampere FIN-33101 Finland",
      "ja": "Sami Peltotalo Tampere Technology P.O.Box 553（Korkeakoulunkatu 1）Tampere Fin-33101フィンランド"
    },
    {
      "indent": 3,
      "text": "EMail: sami.peltotalo@tut.fi\nURI:   http://mad.cs.tut.fi/",
      "raw": true,
      "ja": ""
    }
  ]
}