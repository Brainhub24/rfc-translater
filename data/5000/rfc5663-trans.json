{
  "title": {
    "text": "RFC 5663 - Parallel NFS (pNFS) Block/Volume Layout",
    "ja": "RFC 5663 - パラレルNFS（PNFS）ブロック/ボリュームレイアウト"
  },
  "number": 5663,
  "created_at": "2023-02-22 05:17:48.018247+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          D. Black\nRequest for Comments: 5663                                   S. Fridella\nCategory: Standards Track                                EMC Corporation\nISSN: 2070-1721                                               J. Glasgow\n                                                                  Google\n                                                            January 2010",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Parallel NFS (pNFS) Block/Volume Layout",
      "ja": "パラレルNFS（PNFS）ブロック/ボリュームレイアウト"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Parallel NFS (pNFS) extends Network File Sharing version 4 (NFSv4) to allow clients to directly access file data on the storage used by the NFSv4 server. This ability to bypass the server for data access can increase both performance and parallelism, but requires additional client functionality for data access, some of which is dependent on the class of storage used. The main pNFS operations document specifies storage-class-independent extensions to NFS; this document specifies the additional extensions (primarily data structures) for use of pNFS with block- and volume-based storage.",
      "ja": "Parallel NFS（PNFS）は、ネットワークファイル共有バージョン4（NFSV4）を拡張して、クライアントがNFSV4サーバーで使用されるストレージ上のファイルデータに直接アクセスできるようにします。データアクセスのためにサーバーをバイパスするこの機能は、パフォーマンスと並列性の両方を向上させる可能性がありますが、データアクセスには追加のクライアント機能が必要です。その一部は、使用されるストレージのクラスに依存します。主なPNFS操作ドキュメントは、NFSへのストレージクラスに依存しない拡張機能を指定します。このドキュメントは、ブロックベースとボリュームベースのストレージを備えたPNFを使用するための追加の拡張（主にデータ構造）を指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 5741のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5663.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc5663で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2010 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Conventions Used in This Document ..........................4\n   1.2. General Definitions ........................................5\n   1.3. Code Components Licensing Notice ...........................5\n   1.4. XDR Description ............................................5\n2. Block Layout Description ........................................7\n   2.1. Background and Architecture ................................7\n   2.2. GETDEVICELIST and GETDEVICEINFO ............................9\n        2.2.1. Volume Identification ...............................9\n        2.2.2. Volume Topology ....................................10\n        2.2.3. GETDEVICELIST and GETDEVICEINFO deviceid4 ..........12\n   2.3. Data Structures: Extents and Extent Lists .................12\n        2.3.1. Layout Requests and Extent Lists ...................15\n        2.3.2. Layout Commits .....................................16\n        2.3.3. Layout Returns .....................................16\n        2.3.4. Client Copy-on-Write Processing ....................17\n        2.3.5. Extents are Permissions ............................18\n        2.3.6. End-of-file Processing .............................20\n        2.3.7. Layout Hints .......................................20\n        2.3.8. Client Fencing .....................................21\n   2.4. Crash Recovery Issues .....................................23\n   2.5. Recalling Resources: CB_RECALL_ANY ........................23\n   2.6. Transient and Permanent Errors ............................24\n3. Security Considerations ........................................24\n4. Conclusions ....................................................26\n5. IANA Considerations ............................................26\n6. Acknowledgments ................................................26\n7. References .....................................................27\n   7.1. Normative References ......................................27\n   7.2. Informative References ....................................27",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "Figure 1 shows the overall architecture of a Parallel NFS (pNFS) system:",
      "ja": "図1は、並列NFS（PNFS）システムの全体的なアーキテクチャを示しています。"
    },
    {
      "indent": 6,
      "text": "+-----------+\n|+-----------+                                 +-----------+\n||+-----------+                                |           |\n|||           |       NFSv4.1 + pNFS           |           |\n+||  Clients  |<------------------------------>|   Server  |\n +|           |                                |           |\n  +-----------+                                |           |\n       |||                                     +-----------+\n       |||                                           |\n       |||                                           |\n       ||| Storage        +-----------+              |\n       ||| Protocol       |+-----------+             |\n       ||+----------------||+-----------+  Control   |\n       |+-----------------|||           |    Protocol|\n       +------------------+||  Storage  |------------+\n                           +|  Systems  |\n                            +-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 1: pNFS Architecture",
      "ja": "図1：PNFSアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The overall approach is that pNFS-enhanced clients obtain sufficient information from the server to enable them to access the underlying storage (on the storage systems) directly. See the pNFS portion of [NFSv4.1] for more details. This document is concerned with access from pNFS clients to storage systems over storage protocols based on blocks and volumes, such as the Small Computer System Interface (SCSI) protocol family (e.g., parallel SCSI, Fibre Channel Protocol (FCP) for Fibre Channel, Internet SCSI (iSCSI), Serial Attached SCSI (SAS), and Fibre Channel over Ethernet (FCoE)). This class of storage is referred to as block/volume storage. While the Server to Storage System protocol, called the \"Control Protocol\", is not of concern for interoperability here, it will typically also be a block/volume protocol when clients use block/ volume protocols.",
      "ja": "全体的なアプローチは、PNFS強化クライアントがサーバーから十分な情報を取得して、基礎となるストレージ（ストレージシステム）に直接アクセスできるようにすることです。詳細については、[NFSV4.1]のPNFS部分を参照してください。このドキュメントは、PNFSクライアントから、小さなコンピューターシステムインターフェイス（SCSI）プロトコルファミリー（並列SCSI、ファイバーチャネルプロトコル（FCP）などのブロックやボリュームに基づくストレージプロトコルを介したストレージシステムへのアクセスに関係しています。SCSI（ISCSI）、シリアル接続SCSI（SAS）、およびファイバーチャネル上のファイバーチャネル（FCOE））。このクラスのストレージは、ブロック/ボリュームストレージと呼ばれます。「コントロールプロトコル」と呼ばれるサーバーからストレージシステムプロトコルは、ここでの相互運用性については懸念されませんが、クライアントがブロック/ボリュームプロトコルを使用する場合、通常、ブロック/ボリュームプロトコルにもなります。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用されている規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 [RFC2119].",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はRFC 2119 [RFC2119]で説明されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. General Definitions",
      "section_title": true,
      "ja": "1.2. 一般的な定義"
    },
    {
      "indent": 3,
      "text": "The following definitions are provided for the purpose of providing an appropriate context for the reader.",
      "ja": "読者に適切なコンテキストを提供する目的で、以下の定義が提供されています。"
    },
    {
      "indent": 3,
      "text": "Byte",
      "ja": "バイト"
    },
    {
      "indent": 6,
      "text": "This document defines a byte as an octet, i.e., a datum exactly 8 bits in length.",
      "ja": "このドキュメントでは、バイトをオクテット、つまり長さが正確に8ビットのデータを定義しています。"
    },
    {
      "indent": 3,
      "text": "Client",
      "ja": "クライアント"
    },
    {
      "indent": 6,
      "text": "The \"client\" is the entity that accesses the NFS server's resources. The client may be an application that contains the logic to access the NFS server directly. The client may also be the traditional operating system client that provides remote file system services for a set of applications.",
      "ja": "「クライアント」は、NFSサーバーのリソースにアクセスするエンティティです。クライアントは、NFSサーバーに直接アクセスするロジックを含むアプリケーションである場合があります。クライアントは、一連のアプリケーションにリモートファイルシステムサービスを提供する従来のオペレーティングシステムクライアントでもあります。"
    },
    {
      "indent": 3,
      "text": "Server",
      "ja": "サーバ"
    },
    {
      "indent": 6,
      "text": "The \"server\" is the entity responsible for coordinating client access to a set of file systems and is identified by a server owner.",
      "ja": "「サーバー」は、ファイルシステムのセットへのクライアントアクセスを調整するためのエンティティであり、サーバーの所有者によって識別されます。"
    },
    {
      "indent": 0,
      "text": "1.3. Code Components Licensing Notice",
      "section_title": true,
      "ja": "1.3. コードコンポーネントライセンス通知"
    },
    {
      "indent": 3,
      "text": "The external data representation (XDR) description and scripts for extracting the XDR description are Code Components as described in Section 4 of \"Legal Provisions Relating to IETF Documents\" [LEGAL]. These Code Components are licensed according to the terms of Section 4 of \"Legal Provisions Relating to IETF Documents\".",
      "ja": "XDR説明を抽出するための外部データ表現（XDR）の説明とスクリプトは、「IETFドキュメントに関連する法的規定」[法的]のセクション4で説明されているように、コードコンポーネントです。これらのコードコンポーネントは、「IETFドキュメントに関連する法的規定」のセクション4の条件に従ってライセンスされています。"
    },
    {
      "indent": 0,
      "text": "1.4. XDR Description",
      "section_title": true,
      "ja": "1.4. XDRの説明"
    },
    {
      "indent": 3,
      "text": "This document contains the XDR ([XDR]) description of the NFSv4.1 block layout protocol. The XDR description is embedded in this document in a way that makes it simple for the reader to extract into a ready-to-compile form. The reader can feed this document into the following shell script to produce the machine readable XDR description of the NFSv4.1 block layout:",
      "ja": "このドキュメントには、NFSV4.1ブロックレイアウトプロトコルのXDR（[XDR]）説明が含まれています。XDRの説明は、このドキュメントに組み込まれており、読者がすぐにコンパイルできるフォームに抽出できるようにします。読者は、このドキュメントを次のシェルスクリプトに送り込み、NFSV4.1ブロックレイアウトの機械読み取り可能なXDR説明を作成できます。"
    },
    {
      "indent": 3,
      "text": "#!/bin/sh grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??' That is, if the above script is stored in a file called \"extract.sh\", and this document is in a file called \"spec.txt\", then the reader can do:",
      "ja": "＃！/bin/sh grep '^ * ///' $ * |sed 's？^ */// ??'|sed 's？^ */// $ ??'つまり、上記のスクリプトが「extract.sh」というファイルに保存され、このドキュメントが「spec.txt」というファイルにある場合、読者は次のことができます。"
    },
    {
      "indent": 6,
      "text": "sh extract.sh < spec.txt > nfs4_block_layout_spec.x",
      "ja": "sh extract.sh <Spec.txt> nfs4_block_layout_spec.x"
    },
    {
      "indent": 3,
      "text": "The effect of the script is to remove both leading white space and a sentinel sequence of \"///\" from each matching line.",
      "ja": "スクリプトの効果は、各マッチングラインから主要な空白と「///」のセンチネルシーケンスの両方を削除することです。"
    },
    {
      "indent": 3,
      "text": "The embedded XDR file header follows, with subsequent pieces embedded throughout the document:",
      "ja": "埋め込まれたXDRファイルヘッダーが続き、後続のピースがドキュメント全体に埋め込まれています。"
    },
    {
      "indent": 3,
      "text": "/// /*\n///  * This code was derived from RFC 5663.\n///  * Please reproduce this note if possible.\n///  */\n/// /*\n///  * Copyright (c) 2010 IETF Trust and the persons identified\n///  * as the document authors.  All rights reserved.\n///  *\n///  * Redistribution and use in source and binary forms, with\n///  * or without modification, are permitted provided that the\n///  * following conditions are met:\n///  *\n///  * - Redistributions of source code must retain the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer.\n///  *\n///  * - Redistributions in binary form must reproduce the above\n///  *   copyright notice, this list of conditions and the\n///  *   following disclaimer in the documentation and/or other\n///  *   materials provided with the distribution.\n///  *\n///  * - Neither the name of Internet Society, IETF or IETF\n///  *   Trust, nor the names of specific contributors, may be\n///  *   used to endorse or promote products derived from this\n///  *   software without specific prior written permission.\n///  *\n///  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS\n///  *   AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED\n///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n///  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n///  *   EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n///  *   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n///  *   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n///  *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n///  *   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n///  *   IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n///  *   ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n///  */\n///\n/// /*\n///  *      nfs4_block_layout_prot.x\n///  */\n///\n/// %#include \"nfsv41.h\"\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The XDR code contained in this document depends on types from the nfsv41.x file. This includes both nfs types that end with a 4, such as offset4, length4, etc., as well as more generic types such as uint32_t and uint64_t.",
      "ja": "このドキュメントに含まれるXDRコードは、NFSV41.xファイルのタイプに依存します。これには、Offset4、length4などなど、4で終了するNFSタイプと、UINT32_TやUINT64_Tなどのより一般的なタイプが含まれます。"
    },
    {
      "indent": 0,
      "text": "2. Block Layout Description",
      "section_title": true,
      "ja": "2. ブロックレイアウトの説明"
    },
    {
      "indent": 0,
      "text": "2.1. Background and Architecture",
      "section_title": true,
      "ja": "2.1. 背景とアーキテクチャ"
    },
    {
      "indent": 3,
      "text": "The fundamental storage abstraction supported by block/volume storage is a storage volume consisting of a sequential series of fixed-size blocks. This can be thought of as a logical disk; it may be realized by the storage system as a physical disk, a portion of a physical disk, or something more complex (e.g., concatenation, striping, RAID, and combinations thereof) involving multiple physical disks or portions thereof.",
      "ja": "ブロック/ボリュームストレージでサポートされる基本的なストレージ抽象化は、一連の固定サイズブロックシリーズで構成されるストレージボリュームです。これは論理ディスクと考えることができます。ストレージシステムは、物理ディスク、物理ディスクの一部、または複数の物理的ディスクまたはその部分を含むより複雑な（連結、ストライピング、襲撃、および組み合わせ）として実現することができます。"
    },
    {
      "indent": 3,
      "text": "A pNFS layout for this block/volume class of storage is responsible for mapping from an NFS file (or portion of a file) to the blocks of storage volumes that contain the file. The blocks are expressed as extents with 64-bit offsets and lengths using the existing NFSv4 offset4 and length4 types. Clients must be able to perform I/O to the block extents without affecting additional areas of storage (especially important for writes); therefore, extents MUST be aligned to 512-byte boundaries, and writable extents MUST be aligned to the block size used by the NFSv4 server in managing the actual file system (4 kilobytes and 8 kilobytes are common block sizes). This block size is available as the NFSv4.1 layout_blksize attribute. [NFSv4.1]. Readable extents SHOULD be aligned to the block size used by the NFSv4 server, but in order to support legacy file systems with fragments, alignment to 512-byte boundaries is acceptable.",
      "ja": "このブロック/ボリュームクラスのストレージのPNFSレイアウトは、NFSファイル（またはファイルの一部）からファイルを含むストレージボリュームのブロックへのマッピングを担当します。ブロックは、既存のNFSV4オフセットと長さ4型を使用して、64ビットのオフセットと長さを持つ範囲として表されます。クライアントは、ストレージの追加領域に影響を与えることなく、ブロック範囲にI/Oを実行できる必要があります（特に書き込みにとって重要）。したがって、エクステントは512バイトの境界に整列する必要があり、実際のファイルシステムを管理する際にNFSV4サーバーが使用するブロックサイズにwritableエルテントを調整する必要があります（4キロバイトと8キロバイトは一般的なブロックサイズです）。このブロックサイズは、nfsv4.1 layout_blksize属性として使用できます。[NFSV4.1]。読み取り可能な拡張機能は、NFSV4サーバーで使用されるブロックサイズに整列する必要がありますが、フラグメントを持つレガシーファイルシステムをサポートするためには、512バイトの境界に合わせて許容されます。"
    },
    {
      "indent": 3,
      "text": "The pNFS operation for requesting a layout (LAYOUTGET) includes the \"layoutiomode4 loga_iomode\" argument, which indicates whether the requested layout is for read-only use or read-write use. A read-only layout may contain holes that are read as zero, whereas a read-write layout will contain allocated, but un-initialized storage in those holes (read as zero, can be written by client). This document also supports client participation in copy-on-write (e.g., for file systems with snapshots) by providing both read-only and un-initialized storage for the same range in a layout. Reads are initially performed on the read-only storage, with writes going to the un-initialized storage. After the first write that initializes the un-initialized storage, all reads are performed to that now-initialized writable storage, and the corresponding read-only storage is no longer used.",
      "ja": "レイアウトを要求するためのPNFS操作（layoutget）には、「layoutiomode4 loga_iomode」引数が含まれています。これは、要求されたレイアウトが読み取り専用の使用または読み取りワイトの使用のためのものかを示すものです。読み取り専用のレイアウトには、ゼロとして読み取られる穴が含まれている場合がありますが、読み取りワイトレイアウトには割り当てられたが、それらの穴には無向メイリングストレージが含まれます（ゼロとして読み取られ、クライアントが書くことができます）。また、このドキュメントは、レイアウトで同じ範囲の読み取り専用および無向的なストレージの両方を提供することにより、コピーオンワリット（例：スナップショットを備えたファイルシステムの場合）へのクライアントの参加もサポートしています。読み取りは最初は読み取り専用のストレージで実行され、ワタリは無向気のストレージに送られます。初期化されていないストレージを初期化した最初の書き込みの後、すべての読み取りは、現在有効化された書き込みストレージに対して実行され、対応する読み取り専用ストレージは使用されなくなります。"
    },
    {
      "indent": 3,
      "text": "The block/volume layout solution expands the security responsibilities of the pNFS clients, and there are a number of environments where the mandatory to implement security properties for NFS cannot be satisfied. The additional security responsibilities of the client follow, and a full discussion is present in Section 3, \"Security Considerations\".",
      "ja": "ブロック/ボリュームレイアウトソリューションは、PNFSクライアントのセキュリティ責任を拡大し、NFSのセキュリティプロパティを実装するための必須の環境が満たされない環境がいくつかあります。クライアントの追加のセキュリティ責任が続き、セクション3「セキュリティ上の考慮事項」に完全な議論が存在します。"
    },
    {
      "indent": 3,
      "text": "o Typically, storage area network (SAN) disk arrays and SAN protocols provide access control mechanisms (e.g., Logical Unit Number (LUN) mapping and/or masking), which operate at the granularity of individual hosts, not individual blocks. For this reason, block-based protection must be provided by the client software.",
      "ja": "o 通常、ストレージエリアネットワーク（SAN）ディスクアレイとSANプロトコルは、個々のブロックではなく個々のホストの粒度で動作するアクセス制御メカニズム（例：論理単位数（LUN）マッピングおよび/またはマスキング）を提供します。このため、クライアントソフトウェアによってブロックベースの保護を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Similarly, SAN disk arrays and SAN protocols typically are not able to validate NFS locks that apply to file regions. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests, and not to allow writes to the existing parts of the file.",
      "ja": "o 同様に、SANディスクアレイとSANプロトコルは通常、ファイル領域に適用されるNFSロックを検証することができません。たとえば、ファイルが必須の読み取り専用ロックでカバーされている場合、サーバーは、ファイルの読み取り可能なレイアウトのみがPNFSクライアントに付与されるようにします。ただし、読み取り可能なレイアウトが読み取りリクエストのサービスにのみ使用され、ファイルの既存の部分に書き込みを許可しないようにするのは、各PNFSクライアント次第です。"
    },
    {
      "indent": 3,
      "text": "Since block/volume storage systems are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS block/volume storage layouts SHOULD NOT be used.",
      "ja": "ブロック/ボリュームストレージシステムは一般に、このようなファイルベースのセキュリティを実施できないため、PNFSクライアントをそのようなポリシーを実施するために信頼できない環境では、PNFSブロック/ボリュームストレージレイアウトは使用しないでください。"
    },
    {
      "indent": 0,
      "text": "2.2. GETDEVICELIST and GETDEVICEINFO",
      "section_title": true,
      "ja": "2.2. getDeviceListとgetDeviceInfo"
    },
    {
      "indent": 0,
      "text": "2.2.1. Volume Identification",
      "section_title": true,
      "ja": "2.2.1. ボリューム識別"
    },
    {
      "indent": 3,
      "text": "Storage systems such as storage arrays can have multiple physical network ports that need not be connected to a common network, resulting in a pNFS client having simultaneous multipath access to the same storage volumes via different ports on different networks.",
      "ja": "ストレージアレイなどのストレージシステムには、共通のネットワークに接続する必要がない複数の物理ネットワークポートを搭載することができ、PNFSクライアントが異なるネットワーク上の異なるポートを介して同じストレージボリュームに同時にアクセスできるようになります。"
    },
    {
      "indent": 3,
      "text": "The networks may not even be the same technology -- for example, access to the same volume via both iSCSI and Fibre Channel is possible, hence network addresses are difficult to use for volume identification. For this reason, this pNFS block layout identifies storage volumes by content, for example providing the means to match (unique portions of) labels used by volume managers. Volume identification is performed by matching one or more opaque byte sequences to specific parts of the stored data. Any block pNFS system using this layout MUST support a means of content-based unique volume identification that can be employed via the data structure given here.",
      "ja": "ネットワークは同じテクノロジーでさえない可能性があります。たとえば、ISCSIチャネルとファイバーチャネルの両方を介して同じボリュームへのアクセスが可能であるため、ネットワークアドレスをボリューム識別に使用することは困難です。このため、このPNFSブロックレイアウトは、コンテンツごとにストレージボリュームを識別します。たとえば、ボリュームマネージャーが使用するラベルを一致させる手段を提供します。ボリューム識別は、1つ以上の不透明なバイトシーケンスを保存されたデータの特定の部分に一致させることにより実行されます。このレイアウトを使用するブロックPNFSシステムは、ここにあるデータ構造を介して使用できるコンテンツベースの一意のボリューム識別の手段をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "/// struct pnfs_block_sig_component4 { /* disk signature component */\n///     int64_t bsc_sig_offset;        /* byte offset of component\n///                                       on volume*/\n///     opaque  bsc_contents<>;        /* contents of this component\n///                                       of the signature */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the opaque \"bsc_contents\" field in the \"pnfs_block_sig_component4\" structure MUST NOT be interpreted as a zero-terminated string, as it may contain embedded zero-valued bytes. There are no restrictions on alignment (e.g., neither bsc_sig_offset nor the length are required to be multiples of 4). The bsc_sig_offset is a signed quantity, which, when positive, represents an byte offset from the start of the volume, and when negative represents an byte offset from the end of the volume.",
      "ja": "「pnfs_block_sig_component4」構造の不透明な「bsc_contents」フィールドは、埋め込まれたゼロ値バイトが含まれている可能性があるため、ゼロ終端文字列として解釈してはならないことに注意してください。アライメントに制限はありません（たとえば、BSC_SIG_OFFSESTも長さも4の倍数である必要はありません）。bsc_sig_offsetは署名された数量であり、ポジティブの場合、ボリュームの開始からバイトオフセットを表し、負の場合はボリュームの終わりからバイトオフセットを表します。"
    },
    {
      "indent": 3,
      "text": "Negative offsets are permitted in order to simplify the client implementation on systems where the device label is found at a fixed offset from the end of the volume. If the server uses negative offsets to describe the signature, then the client and server MUST NOT see different volume sizes. Negative offsets SHOULD NOT be used in systems that dynamically resize volumes unless care is taken to ensure that the device label is always present at the offset from the end of the volume as seen by the clients.",
      "ja": "ボリュームの終わりからの固定オフセットでデバイスラベルが見つかったシステム上のクライアントの実装を簡素化するために、負のオフセットが許可されます。サーバーがネガティブオフセットを使用して署名を説明する場合、クライアントとサーバーは異なるボリュームサイズを表示してはなりません。クライアントが見たように、ボリュームの終わりからオフセットに常に存在するように注意が払われない限り、ボリュームを動的にサイズ変更するシステムでは、負のオフセットを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "A signature is an array of up to \"PNFS_BLOCK_MAX_SIG_COMP\" (defined below) signature components. The client MUST NOT assume that all signature components are co-located within a single sector on a block device.",
      "ja": "署名とは、「pnfs_block_max_sig_comp」（以下に定義）までの署名コンポーネントまでの配列です。クライアントは、すべての署名コンポーネントがブロックデバイス上の単一セクター内で共同住宅されていると想定してはなりません。"
    },
    {
      "indent": 3,
      "text": "The pNFS client block layout driver uses this volume identification to map pnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLE deviceid4s to its local view of a LUN.",
      "ja": "PNFSクライアントブロックレイアウトドライバーは、このボリューム識別を使用して、PNFS_BLOCK_VOLUME_TYPE4 PNFS_BLOCK_VOLUME_SIMPLE DeviceID4SをLUNのローカルビューにマッピングします。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Volume Topology",
      "section_title": true,
      "ja": "2.2.2. ボリュームトポロジ"
    },
    {
      "indent": 3,
      "text": "The pNFS block server volume topology is expressed as an arbitrary combination of base volume types enumerated in the following data structures. The individual components of the topology are contained in an array and components may refer to other components by using array indices.",
      "ja": "PNFSブロックサーバーボリュームトポロジは、以下のデータ構造に列挙されたベースボリュームタイプの任意の組み合わせとして表されます。トポロジの個々のコンポーネントは配列に含まれており、コンポーネントは配列インデックスを使用して他のコンポーネントを参照する場合があります。"
    },
    {
      "indent": 3,
      "text": "/// enum pnfs_block_volume_type4 {\n///     PNFS_BLOCK_VOLUME_SIMPLE = 0,  /* volume maps to a single\n///                                       LU */\n///     PNFS_BLOCK_VOLUME_SLICE  = 1,  /* volume is a slice of\n///                                       another volume */\n///     PNFS_BLOCK_VOLUME_CONCAT = 2,  /* volume is a\n///                                       concatenation of\n///                                       multiple volumes */\n///     PNFS_BLOCK_VOLUME_STRIPE = 3   /* volume is striped across\n///                                       multiple volumes */\n/// };\n///\n/// const PNFS_BLOCK_MAX_SIG_COMP = 16;/* maximum components per\n///                                       signature */\n/// struct pnfs_block_simple_volume_info4 {\n///     pnfs_block_sig_component4 bsv_ds<PNFS_BLOCK_MAX_SIG_COMP>;\n///                                    /* disk signature */\n/// };\n///\n///\n/// struct pnfs_block_slice_volume_info4 {\n///     offset4  bsv_start;            /* offset of the start of the\n///                                       slice in bytes */\n///     length4  bsv_length;           /* length of slice in bytes */\n///     uint32_t bsv_volume;           /* array index of sliced\n///                                       volume */\n/// };\n///\n/// struct pnfs_block_concat_volume_info4 {\n///     uint32_t  bcv_volumes<>;       /* array indices of volumes\n///                                       which are concatenated */",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "/// };\n///\n/// struct pnfs_block_stripe_volume_info4 {\n///     length4  bsv_stripe_unit;      /* size of stripe in bytes */\n///     uint32_t bsv_volumes<>;        /* array indices of volumes\n///                                       which are striped across --\n///                                       MUST be same size */\n/// };\n///\n/// union pnfs_block_volume4 switch (pnfs_block_volume_type4 type) {\n///     case PNFS_BLOCK_VOLUME_SIMPLE:\n///         pnfs_block_simple_volume_info4 bv_simple_info;\n///     case PNFS_BLOCK_VOLUME_SLICE:\n///         pnfs_block_slice_volume_info4 bv_slice_info;\n///     case PNFS_BLOCK_VOLUME_CONCAT:\n///         pnfs_block_concat_volume_info4 bv_concat_info;\n///     case PNFS_BLOCK_VOLUME_STRIPE:\n///         pnfs_block_stripe_volume_info4 bv_stripe_info;\n/// };\n///\n/// /* block layout specific type for da_addr_body */\n/// struct pnfs_block_deviceaddr4 {\n///     pnfs_block_volume4 bda_volumes<>; /* array of volumes */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"pnfs_block_deviceaddr4\" data structure is a structure that allows arbitrarily complex nested volume structures to be encoded. The types of aggregations that are allowed are stripes, concatenations, and slices. Note that the volume topology expressed in the pnfs_block_deviceaddr4 data structure will always resolve to a set of pnfs_block_volume_type4 PNFS_BLOCK_VOLUME_SIMPLE. The array of volumes is ordered such that the root of the volume hierarchy is the last element of the array. Concat, slice, and stripe volumes MUST refer to volumes defined by lower indexed elements of the array.",
      "ja": "「PNFS_BLOCK_DEVICEADDR4」データ構造は、任意に複雑なネストされたボリューム構造をエンコードできるようにする構造です。許可される集計の種類は、ストライプ、連結、スライスです。PNFS_BLOCK_DEVICEADDR4データ構造で表されるボリュームトポロジは、常にPNFS_BLOCK_VOLUME_TYPE4 PNFS_BLOCK_VOLUME_SIMPLEのセットに解決することに注意してください。ボリューム階層のルートが配列の最後の要素であるように、ボリュームの配列が注文されます。Concat、Slice、およびStripeボリュームは、アレイのより低いインデックス付き要素によって定義されたボリュームを参照する必要があります。"
    },
    {
      "indent": 3,
      "text": "The \"pnfs_block_device_addr4\" data structure is returned by the server as the storage-protocol-specific opaque field da_addr_body in the \"device_addr4\" structure by a successful GETDEVICEINFO operation [NFSv4.1].",
      "ja": "「PNFS_BLOCK_DEVICE_ADDR4」データ構造は、GetDeviceInfo操作の成功により、「device_addr4」構造のストレージプロトコル固有の不透明フィールドDA_ADDR_BODY [NFSV4.1]によってサーバーによって返されます。"
    },
    {
      "indent": 3,
      "text": "As noted above, all device_addr4 structures eventually resolve to a set of volumes of type PNFS_BLOCK_VOLUME_SIMPLE. These volumes are each uniquely identified by a set of signature components. Complicated volume hierarchies may be composed of dozens of volumes each with several signature components; thus, the device address may require several kilobytes. The client SHOULD be prepared to allocate a large buffer to contain the result. In the case of the server returning NFS4ERR_TOOSMALL, the client SHOULD allocate a buffer of at least gdir_mincount_bytes to contain the expected result and retry the GETDEVICEINFO request.",
      "ja": "上記のように、すべてのdevice_addr4構造は、最終的にpnfs_block_volume_simpleのタイプのボリュームのセットに解決します。これらのボリュームはそれぞれ、一連の署名コンポーネントによって一意に識別されます。複雑なボリューム階層は、それぞれにいくつかの署名コンポーネントを備えた数十のボリュームで構成されている場合があります。したがって、デバイスアドレスにはいくつかのキロバイトが必要になる場合があります。クライアントは、結果を抑えるために大きなバッファーを割り当てる準備をする必要があります。nfs4err_toosmallを返すサーバーの場合、クライアントは、少なくともGDIR_MINCOUNT_BYTESのバッファを割り当てて、期待結果を含め、getDeviceInfoリクエストを再試行する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.3. GETDEVICELIST and GETDEVICEINFO deviceid4",
      "section_title": true,
      "ja": "2.2.3. getDeviceListおよびgetDeviceInfo DeviceID4"
    },
    {
      "indent": 3,
      "text": "The server in response to a GETDEVICELIST request typically will return a single \"deviceid4\" in the gdlr_deviceid_list array. This is because the deviceid4 when passed to GETDEVICEINFO will return a \"device_addr4\", which encodes the entire volume hierarchy. In the case of copy-on-write file systems, the \"gdlr_deviceid_list\" array may contain two deviceid4's, one referencing the read-only volume hierarchy, and one referencing the writable volume hierarchy. There is no required ordering of the readable and writable IDs in the array as the volumes are uniquely identified by their deviceid4, and are referred to by layouts using the deviceid4. Another example of the server returning multiple device items occurs when the file handle represents the root of a namespace spanning multiple physical file systems on the server, each with a different volume hierarchy. In this example, a server implementation may return either a list of device IDs used by each of the physical file systems, or it may return an empty list.",
      "ja": "getDeviceListリクエストに応じたサーバーは、通常、GDLR_DEVICEID_LISTアレイに単一の「deviceID4」を返します。これは、getDeviceInfoに渡されたときにdeviceID4が「device_addr4」を返すためです。これは、ボリューム階層全体をコードするためです。コピーオンワイトファイルシステムの場合、「GDLR_DEVICEID_LIST」アレイには、2つのDeviceID4、読み取り専用のボリューム階層を参照する2つのDeviceID4、および書き込み可能なボリューム階層を参照する1つのDeviceID4が含まれます。ボリュームはDeviceID4によって一意に識別され、DeviceID4を使用したレイアウトによって参照されるため、アレイ内の読み取り可能な書き込み可能なIDを必要とする必要はありません。ファイルハンドルがサーバー上の複数の物理ファイルシステムにまたがる名前空間のルートを表し、それぞれが異なるボリューム階層を持つ名前空間のルートを表すと、複数のデバイスアイテムを返すサーバーの別の例が発生します。この例では、サーバーの実装は、物理ファイルシステムのそれぞれが使用するデバイスIDのリストを返すか、空のリストを返すことができます。"
    },
    {
      "indent": 3,
      "text": "Each deviceid4 returned by a successful GETDEVICELIST operation is a shorthand id used to reference the whole volume topology. These device IDs, as well as device IDs returned in extents of a LAYOUTGET operation, can be used as input to the GETDEVICEINFO operation. Decoding the \"pnfs_block_deviceaddr4\" results in a flat ordering of data blocks mapped to PNFS_BLOCK_VOLUME_SIMPLE volumes. Combined with the mapping to a client LUN described in Section 2.2.1 \"Volume Identification\", a logical volume offset can be mapped to a block on a pNFS client LUN [NFSv4.1].",
      "ja": "GetDeviceList操作の成功によって返される各deviceID4は、ボリュームトポロジ全体を参照するために使用される速記IDです。これらのデバイスIDと、レイアウト操作の範囲で返されるデバイスIDは、getDeviceInfo操作への入力として使用できます。「PNFS_BLOCK_DEVICEADDR4」をデコードすると、PNFS_BLOCK_VOLUME_SIMPLEボリュームにマッピングされたデータブロックのフラットな順序が表示されます。セクション2.2.1「ボリューム識別」で説明したクライアントLUNへのマッピングと組み合わせて、論理ボリュームオフセットをPNFSクライアントLUN [NFSV4.1]のブロックにマッピングできます。"
    },
    {
      "indent": 0,
      "text": "2.3. Data Structures: Extents and Extent Lists",
      "section_title": true,
      "ja": "2.3. データ構造：範囲と範囲リスト"
    },
    {
      "indent": 3,
      "text": "A pNFS block layout is a list of extents within a flat array of data blocks in a logical volume. The details of the volume topology can be determined by using the GETDEVICEINFO operation (see discussion of volume identification, Section 2.2 above). The block layout describes the individual block extents on the volume that make up the file. The offsets and length contained in an extent are specified in units of bytes.",
      "ja": "PNFSブロックレイアウトは、論理ボリューム内のデータブロックのフラット配列内の範囲のリストです。ボリュームトポロジの詳細は、getDeviceInfo操作を使用して決定できます（上記のボリューム識別の説明、セクション2.2を参照）。ブロックレイアウトは、ファイルを構成するボリューム上の個々のブロック拡張機能を記述します。ある程度含まれるオフセットと長さは、バイト単位で指定されています。"
    },
    {
      "indent": 3,
      "text": "/// enum pnfs_block_extent_state4 {\n///     PNFS_BLOCK_READ_WRITE_DATA = 0,/* the data located by this\n///                                       extent is valid\n///                                       for reading and writing. */\n///     PNFS_BLOCK_READ_DATA      = 1, /* the data located by this\n///                                       extent is valid for reading\n///                                       only; it may not be\n///                                       written. */\n///     PNFS_BLOCK_INVALID_DATA   = 2, /* the location is valid; the\n///                                       data is invalid.  It is a\n///                                       newly (pre-) allocated\n///                                       extent.  There is physical\n///                                       space on the volume. */\n///     PNFS_BLOCK_NONE_DATA      = 3  /* the location is invalid.\n///                                       It is a hole in the file.\n///                                       There is no physical space\n///                                       on the volume. */\n/// };",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "///\n/// struct pnfs_block_extent4 {\n///     deviceid4    bex_vol_id;       /* id of logical volume on\n///                                       which extent of file is\n///                                       stored. */\n///     offset4      bex_file_offset;  /* the starting byte offset in\n///                                       the file */\n///     length4      bex_length;       /* the size in bytes of the\n///                                       extent */\n///     offset4      bex_storage_offset;  /* the starting byte offset\n///                                       in the volume */\n///     pnfs_block_extent_state4 bex_state;\n///                                    /* the state of this extent */\n/// };\n///\n/// /* block layout specific type for loc_body */\n/// struct pnfs_block_layout4 {\n///     pnfs_block_extent4 blo_extents<>;\n///                                    /* extents which make up this\n///                                       layout. */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The block layout consists of a list of extents that map the logical regions of the file to physical locations on a volume. The \"bex_storage_offset\" field within each extent identifies a location on the logical volume specified by the \"bex_vol_id\" field in the extent. The bex_vol_id itself is shorthand for the whole topology of the logical volume on which the file is stored. The client is responsible for translating this logical offset into an offset on the appropriate underlying SAN logical unit. In most cases, all extents in a layout will reside on the same volume and thus have the same bex_vol_id. In the case of copy-on-write file systems, the PNFS_BLOCK_READ_DATA extents may have a different bex_vol_id from the writable extents.",
      "ja": "ブロックレイアウトは、ファイルの論理領域をボリューム上の物理的な場所にマッピングする範囲のリストで構成されています。各範囲内の「bex_storage_offset」フィールドは、範囲で「bex_vol_id」フィールドで指定された論理ボリューム上の場所を識別します。BEX_VOL_ID自体は、ファイルが保存されている論理ボリュームのトポロジ全体の速記です。クライアントは、この論理オフセットを適切な基礎となるSAN論理ユニットのオフセットに変換する責任があります。ほとんどの場合、レイアウト内のすべての範囲は同じボリュームに存在するため、同じbex_vol_idがあります。コピーオンワイトファイルシステムの場合、PNFS_BLOCK_READ_DATA EXTENTは、筆記の範囲とは異なるBEX_VOL_IDを持っている場合があります。"
    },
    {
      "indent": 3,
      "text": "Each extent maps a logical region of the file onto a portion of the specified logical volume. The bex_file_offset, bex_length, and bex_state fields for an extent returned from the server are valid for all extents. In contrast, the interpretation of the bex_storage_offset field depends on the value of bex_state as follows (in increasing order):",
      "ja": "各範囲は、ファイルの論理領域を指定された論理ボリュームの一部にマッピングします。サーバーから返された程度の程度のbex_file_offset、bex_length、およびbex_stateフィールドは、すべての範囲で有効です。対照的に、bex_storage_offsetフィールドの解釈は、次のようにbex_stateの値に依存します（順序を増やします）："
    },
    {
      "indent": 3,
      "text": "o PNFS_BLOCK_READ_WRITE_DATA means that bex_storage_offset is valid, and points to valid/initialized data that can be read and written.",
      "ja": "o pnfs_block_read_write_dataとは、bex_storage_offsetが有効であることを意味し、読み書きできる有効/初期化されたデータを指します。"
    },
    {
      "indent": 3,
      "text": "o PNFS_BLOCK_READ_DATA means that bex_storage_offset is valid and points to valid/ initialized data that can only be read. Write operations are prohibited; the client may need to request a read-write layout.",
      "ja": "o pnfs_block_read_dataとは、bex_storage_offsetが有効であり、読み取ることができる有効/初期化されたデータをポイントすることを意味します。書き込み操作は禁止されています。クライアントは、読み取りワイトレイアウトを要求する必要がある場合があります。"
    },
    {
      "indent": 3,
      "text": "o PNFS_BLOCK_INVALID_DATA means that bex_storage_offset is valid, but points to invalid un-initialized data. This data must not be physically read from the disk until it has been initialized. A read request for a PNFS_BLOCK_INVALID_DATA extent must fill the user buffer with zeros, unless the extent is covered by a PNFS_BLOCK_READ_DATA extent of a copy-on-write file system. Write requests must write whole server-sized blocks to the disk; bytes not initialized by the user must be set to zero. Any write to storage in a PNFS_BLOCK_INVALID_DATA extent changes the written portion of the extent to PNFS_BLOCK_READ_WRITE_DATA; the pNFS client is responsible for reporting this change via LAYOUTCOMMIT.",
      "ja": "o pnfs_block_invalid_dataは、bex_storage_offsetが有効であることを意味しますが、無効化されていないデータを指します。このデータは、初期化されるまでディスクから物理的に読み取ってはなりません。範囲がPNFS_BLOCK_READ_DATAコピーオンワイトファイルシステムの範囲でカバーされていない限り、PNFS_BLOCK_INVALID_DATA範囲の読み取り要求は、ユーザーバッファーにZerosで埋める必要があります。書き込みリクエストは、サーバーサイズのブロック全体をディスクに書き込む必要があります。ユーザーによって初期化されていないバイトは、ゼロに設定する必要があります。PNFS_BLOCK_INVALID_DATA範囲のストレージへの書き込み範囲は、pnfs_block_read_write_dataの範囲の書かれた部分を変更します。PNFSクライアントは、レイアウトコミットを介してこの変更を報告する責任があります。"
    },
    {
      "indent": 3,
      "text": "o PNFS_BLOCK_NONE_DATA means that bex_storage_offset is not valid, and this extent may not be used to satisfy write requests. Read requests may be satisfied by zero-filling as for PNFS_BLOCK_INVALID_DATA. PNFS_BLOCK_NONE_DATA extents may be returned by requests for readable extents; they are never returned if the request was for a writable extent.",
      "ja": "o pnfs_block_none_dataは、bex_storage_offsetが有効ではなく、この範囲を書き込み要求を満たすために使用されないことを意味します。PNFS_BLOCK_INVALID_DATAのように、読み取りリクエストはゼロ充填によって満たされる場合があります。PNFS_BLOCK_NONE_DATA EXTENTは、読み取り可能な範囲のリクエストによって返される場合があります。リクエストが書かれた範囲であった場合、それらは決して返されません。"
    },
    {
      "indent": 3,
      "text": "An extent list contains all relevant extents in increasing order of the bex_file_offset of each extent; any ties are broken by increasing order of the extent state (bex_state).",
      "ja": "範囲リストには、各範囲のbex_file_offsetの順序の増加に関連するすべての関連性が含まれます。範囲状態（bex_state）の順序を増やすことにより、ネクタイは破られます。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Layout Requests and Extent Lists",
      "section_title": true,
      "ja": "2.3.1. レイアウトリクエストと範囲リスト"
    },
    {
      "indent": 3,
      "text": "Each request for a layout specifies at least three parameters: file offset, desired size, and minimum size. If the status of a request indicates success, the extent list returned must meet the following criteria:",
      "ja": "レイアウトの各要求は、少なくとも3つのパラメーターを指定します。ファイルオフセット、目的のサイズ、最小サイズです。リクエストのステータスが成功を示した場合、返される範囲リストは次の基準を満たす必要があります。"
    },
    {
      "indent": 3,
      "text": "o A request for a readable (but not writable) layout returns only PNFS_BLOCK_READ_DATA or PNFS_BLOCK_NONE_DATA extents (but not PNFS_BLOCK_INVALID_DATA or PNFS_BLOCK_READ_WRITE_DATA extents).",
      "ja": "o 読み取り可能な（ただし、書き込み可能ではない）レイアウトのリクエストは、pnfs_block_read_dataまたはpnfs_block_none_data Extentsのみを返します（ただし、pnfs_block_invalid_dataまたはpnfs_block_read_write_data extents）。"
    },
    {
      "indent": 3,
      "text": "o A request for a writable layout returns PNFS_BLOCK_READ_WRITE_DATA or PNFS_BLOCK_INVALID_DATA extents (but not PNFS_BLOCK_NONE_DATA extents). It may also return PNFS_BLOCK_READ_DATA extents only when the offset ranges in those extents are also covered by PNFS_BLOCK_INVALID_DATA extents to permit writes.",
      "ja": "o 書き込み可能なレイアウトのリクエストは、pnfs_block_read_write_dataまたはpnfs_block_invalid_data Extentsを返します（ただし、pnfs_block_none_data Extentsではありません）。また、それらの範囲のオフセット範囲がPNFS_BLOCK_INVALID_DATA EXTENTでカバーされている場合にのみ、PNFS_BLOCK_READ_DATA EXTENTを返すこともあります。"
    },
    {
      "indent": 3,
      "text": "o The first extent in the list MUST contain the requested starting offset.",
      "ja": "o リスト内の最初の範囲には、要求された開始オフセットが含まれている必要があります。"
    },
    {
      "indent": 3,
      "text": "o The total size of extents within the requested range MUST cover at least the minimum size. One exception is allowed: the total size MAY be smaller if only readable extents were requested and EOF is encountered.",
      "ja": "o 要求された範囲内の範囲の合計サイズは、少なくとも最小サイズをカバーする必要があります。1つの例外が許可されています。読みやすい範囲のみが要求され、EOFが発生した場合、合計サイズは小さくなる場合があります。"
    },
    {
      "indent": 3,
      "text": "o Extents in the extent list MUST be logically contiguous for a read-only layout. For a read-write layout, the set of writable extents (i.e., excluding PNFS_BLOCK_READ_DATA extents) MUST be logically contiguous. Every PNFS_BLOCK_READ_DATA extent in a read-write layout MUST be covered by one or more PNFS_BLOCK_INVALID_DATA extents. This overlap of PNFS_BLOCK_READ_DATA and PNFS_BLOCK_INVALID_DATA extents is the only permitted extent overlap.",
      "ja": "o 範囲リストの範囲は、読み取り専用のレイアウトでは論理的に隣接する必要があります。読み取りワイトレイアウトの場合、筆記可能な範囲のセット（つまり、PNFS_BLOCK_READ_DATA EXTENTSを除く）は論理的に隣接する必要があります。読み取りワイトレイアウトのすべてのpnfs_block_read_data範囲は、1つ以上のpnfs_block_invalid_data stentsでカバーする必要があります。PNFS_BLOCK_READ_DATAとPNFS_BLOCK_INVALID_DATA EXTENTのこのオーバーラップは、許可された範囲の範囲です。"
    },
    {
      "indent": 3,
      "text": "o Extents MUST be ordered in the list by starting offset, with PNFS_BLOCK_READ_DATA extents preceding PNFS_BLOCK_INVALID_DATA extents in the case of equal bex_file_offsets.",
      "ja": "o extentsは、Outhsetを起動することでリストに注文する必要があります。PNFS_BLOCK_INVALID_DATAEXTENTSの前にPNFS_BLOCK_READ_DATA EXTENTSが等しいBEX_FILE_OFFSETSの場合はExtentsに先行する必要があります。"
    },
    {
      "indent": 3,
      "text": "If the minimum requested size, loga_minlength, is zero, this is an indication to the metadata server that the client desires any layout at offset loga_offset or less that the metadata server has \"readily available\". Readily is subjective, and depends on the layout type and the pNFS server implementation. For block layout servers, readily available SHOULD be interpreted such that readable layouts are always available, even if some extents are in the PNFS_BLOCK_NONE_DATA state. When processing requests for writable layouts, a layout is readily available if extents can be returned in the PNFS_BLOCK_READ_WRITE_DATA state.",
      "ja": "最小要求されたサイズのLOGA_MINLENGTHがゼロの場合、これはメタデータサーバーへの兆候であり、クライアントがオフセットLOGA_OFFSETでレイアウトを望みます。容易に主観的であり、レイアウトタイプとPNFSサーバーの実装に依存します。ブロックレイアウトサーバーの場合、PNFS_BLOCK_NONE_DATA状態にある範囲がある場合でも、読み取り可能なレイアウトが常に利用できるように、すぐに利用できるように解釈する必要があります。書き込み可能なレイアウトのリクエストを処理する場合、PNFS_BLOCK_READ_WRITE_DATA STATEでExtentを返すことができる場合、レイアウトを容易に利用できます。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Layout Commits",
      "section_title": true,
      "ja": "2.3.2. レイアウトがコミットします"
    },
    {
      "indent": 3,
      "text": "/// /* block layout specific type for lou_body */\n/// struct pnfs_block_layoutupdate4 {\n///     pnfs_block_extent4 blu_commit_list<>;\n///                                    /* list of extents which\n///                                     * now contain valid data.\n///                                     */\n/// };\n///",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"pnfs_block_layoutupdate4\" structure is used by the client as the block-protocol specific argument in a LAYOUTCOMMIT operation. The \"blu_commit_list\" field is an extent list covering regions of the file layout that were previously in the PNFS_BLOCK_INVALID_DATA state, but have been written by the client and should now be considered in the PNFS_BLOCK_READ_WRITE_DATA state. The bex_state field of each extent in the blu_commit_list MUST be set to PNFS_BLOCK_READ_WRITE_DATA. The extents in the commit list MUST be disjoint and MUST be sorted by bex_file_offset. The bex_storage_offset field is unused. Implementors should be aware that a server may be unable to commit regions at a granularity smaller than a file-system block (typically 4 KB or 8 KB). As noted above, the block-size that the server uses is available as an NFSv4 attribute, and any extents included in the \"blu_commit_list\" MUST be aligned to this granularity and have a size that is a multiple of this granularity. If the client believes that its actions have moved the end-of-file into the middle of a block being committed, the client MUST write zeroes from the end-of-file to the end of that block before committing the block. Failure to do so may result in junk (un-initialized data) appearing in that area if the file is subsequently extended by moving the end-of-file.",
      "ja": "「PNFS_BLOCK_LAYOUTUPDATE4」構造は、クライアントがレイアウトコミット操作におけるブロックプロトコル固有の引数として使用します。「blu_commit_list」フィールドは、以前はpnfs_block_invalid_data状態にあったファイルレイアウトの領域をカバーする範囲のリストですが、クライアントによって書かれており、現在はpnfs_block_read_write_data状態で考慮されるべきです。blu_commit_listの各範囲のbex_stateフィールドは、pnfs_block_read_write_dataに設定する必要があります。コミットリストの範囲はばらばらでなければならず、bex_file_offsetでソートする必要があります。bex_storage_offsetフィールドは未使用です。実装者は、サーバーがファイルシステムブロック（通常4 kbまたは8 kb）よりも小さい粒度で領域をコミットできない場合があることに注意する必要があります。上記のように、サーバーが使用するブロックサイズはNFSV4属性として利用可能であり、「blu_commit_list」に含まれるすべての範囲は、この粒度に整列し、この粒度の倍数であるサイズを持つ必要があります。クライアントが、アクションがファイルの終わりをコミットされるブロックの中央に移動したと考えている場合、クライアントはブロックをコミットする前に、そのブロックの終わりからそのブロックの終わりまでゼロを書き込む必要があります。そうしないと、ファイルがファイルの終わりを移動することでその後拡張されると、その領域にジャンク（無向データ）が現れる可能性があります。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Layout Returns",
      "section_title": true,
      "ja": "2.3.3. レイアウトリターン"
    },
    {
      "indent": 3,
      "text": "The LAYOUTRETURN operation is done without any block layout specific data. When the LAYOUTRETURN operation specifies a LAYOUTRETURN4_FILE_return type, then the layoutreturn_file4 data structure specifies the region of the file layout that is no longer needed by the client. The opaque \"lrf_body\" field of the \"layoutreturn_file4\" data structure MUST have length zero. A LAYOUTRETURN operation represents an explicit release of resources by the client, usually done for the purpose of avoiding unnecessary CB_LAYOUTRECALL operations in the future. The client may return disjoint regions of the file by using multiple LAYOUTRETURN operations within a single COMPOUND operation.",
      "ja": "layoutreturn操作は、ブロックレイアウト固有のデータなしで行われます。layoutreturn操作がLayoutReturn4_file_returnタイプを指定する場合、Layoutreturn_file4データ構造は、クライアントがもはや必要としないファイルレイアウトの領域を指定します。「layoutreturn_file4」データ構造の不透明な「lrf_body」フィールドには長さゼロが必要です。layoutreturn操作は、クライアントによるリソースの明示的なリリースを表します。通常、将来的に不必要なCB_Layoutrecallオペレーションを回避する目的で行われます。クライアントは、単一の化合物操作内で複数のlayoutreturn操作を使用して、ファイルの分離領域を返すことができます。"
    },
    {
      "indent": 3,
      "text": "Note that the block/volume layout supports unilateral layout revocation. When a layout is unilaterally revoked by the server, usually due to the client's lease time expiring, or a delegation being recalled, or the client failing to return a layout in a timely manner, it is important for the sake of correctness that any in-flight I/Os that the client issued before the layout was revoked are rejected at the storage. For the block/volume protocol, this is possible by fencing a client with an expired layout timer from the physical storage. Note, however, that the granularity of this operation can only be at the host/logical-unit level. Thus, if one of a client's layouts is unilaterally revoked by the server, it will effectively render useless *all* of the client's layouts for files located on the storage units comprising the logical volume. This may render useless the client's layouts for files in other file systems.",
      "ja": "ブロック/ボリュームレイアウトは、一方的なレイアウトの取り消しをサポートしていることに注意してください。通常、クライアントのリース時間の期限が切れるか、リコールされる代表団、またはクライアントがタイムリーにレイアウトを返すことができないため、サーバーによってレイアウトが一方的に取り消された場合、正確さのためにレイアウトをタイムリーに返すことができない場合、レイアウトが取り消される前にクライアントが発行したフライトI/OSは、ストレージで拒否されます。ブロック/ボリュームプロトコルの場合、これは、物理ストレージから期限切れのレイアウトタイマーを使用してクライアントをフェンシングすることで可能です。ただし、この操作の粒度は、ホスト/論理ユニットレベルにのみあることに注意してください。したがって、クライアントのレイアウトの1つがサーバーによって一方的に取り消されている場合、論理ボリュームを含むストレージユニットにあるファイルに対して、クライアントのレイアウトのすべての *すべてを効果的に *すべてにします。これにより、他のファイルシステムのファイルのクライアントのレイアウトが役に立たない場合があります。"
    },
    {
      "indent": 0,
      "text": "2.3.4. Client Copy-on-Write Processing",
      "section_title": true,
      "ja": "2.3.4. クライアントコピーオンワリット処理"
    },
    {
      "indent": 3,
      "text": "Copy-on-write is a mechanism used to support file and/or file system snapshots. When writing to unaligned regions, or to regions smaller than a file system block, the writer must copy the portions of the original file data to a new location on disk. This behavior can either be implemented on the client or the server. The paragraphs below describe how a pNFS block layout client implements access to a file that requires copy-on-write semantics.",
      "ja": "コピーオンワイトは、ファイルおよび/またはファイルシステムのスナップショットをサポートするために使用されるメカニズムです。整理されていない領域、またはファイルシステムブロックよりも小さい地域に書き込む場合、ライターは元のファイルデータの部分をディスク上の新しい場所にコピーする必要があります。この動作は、クライアントまたはサーバーに実装できます。以下の段落では、PNFSブロックレイアウトクライアントが、コピーオンワリットセマンティクスを必要とするファイルへのアクセスをどのように実装するかについて説明します。"
    },
    {
      "indent": 3,
      "text": "Distinguishing the PNFS_BLOCK_READ_WRITE_DATA and PNFS_BLOCK_READ_DATA extent types in combination with the allowed overlap of PNFS_BLOCK_READ_DATA extents with PNFS_BLOCK_INVALID_DATA extents allows copy-on-write processing to be done by pNFS clients. In classic NFS, this operation would be done by the server. Since pNFS enables clients to do direct block access, it is useful for clients to participate in copy-on-write operations. All block/volume pNFS clients MUST support this copy-on-write processing.",
      "ja": "PNFS_BLOCK_READ_WRITE_DATAおよびPNFS_BLOCK_READ_DATA範囲をPNFS_BLOCK_READ_DATA EXTENTとPNFS_INVALID_DATA EXTENTSがPNFSクライアントによるコピーオンライト処理を際立たせます。クラシックNFSでは、この操作はサーバーによって行われます。PNFは、クライアントが直接ブロックアクセスを行うことを可能にするため、クライアントがコピーオンワイトオペレーションに参加するのに役立ちます。すべてのブロック/ボリュームPNFSクライアントは、このコピーオンワリット処理をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to write data covered by a PNFS_BLOCK_READ_DATA extent, it MUST have requested a writable layout from the server; that layout will contain PNFS_BLOCK_INVALID_DATA extents to cover all the data ranges of that layout's PNFS_BLOCK_READ_DATA extents. More precisely, for any bex_file_offset range covered by one or more PNFS_BLOCK_READ_DATA extents in a writable layout, the server MUST include one or more PNFS_BLOCK_INVALID_DATA extents in the layout that cover the same bex_file_offset range. When performing a write to such an area of a layout, the client MUST effectively copy the data from the PNFS_BLOCK_READ_DATA extent for any partial blocks of bex_file_offset and range, merge in the changes to be written, and write the result to the PNFS_BLOCK_INVALID_DATA extent for the blocks for that bex_file_offset and range. That is, if entire blocks of data are to be overwritten by an operation, the corresponding PNFS_BLOCK_READ_DATA blocks need not be fetched, but any partial-block writes must be merged with data fetched via PNFS_BLOCK_READ_DATA extents before storing the result via PNFS_BLOCK_INVALID_DATA extents. For the purposes of this discussion, \"entire blocks\" and \"partial blocks\" refer to the server's file-system block size. Storing of data in a PNFS_BLOCK_INVALID_DATA extent converts the written portion of the PNFS_BLOCK_INVALID_DATA extent to a PNFS_BLOCK_READ_WRITE_DATA extent; all subsequent reads MUST be performed from this extent; the corresponding portion of the PNFS_BLOCK_READ_DATA extent MUST NOT be used after storing data in a PNFS_BLOCK_INVALID_DATA extent. If a client writes only a portion of an extent, the extent may be split at block aligned boundaries.",
      "ja": "クライアントがPNFS_BLOCK_READ_DATAの範囲でカバーされているデータを書きたい場合、サーバーから書き込み可能なレイアウトを要求している必要があります。そのレイアウトには、PNFS_BLOCK_INVALID_DATA EXTENTSが含まれ、そのレイアウトのPNFS_BLOCK_READ_DATA EXTENTSのすべてのデータ範囲をカバーします。より正確には、1つまたは複数のPNFS_BLOCK_READ_DATA EXTENTSでカバーされているBEX_FILE_OFFSET範囲の場合、サーバーには、同じBEX_FILE_OFFSET範囲をカバーするレイアウトに1つ以上のPNFS_BLOCK_INVALID_DATA Extentを含める必要があります。レイアウトのそのような領域に書き込みを実行するとき、クライアントは、bex_file_offsetと範囲の部分的なブロックについて、pnfs_block_read_dataの範囲からデータを効果的にコピーし、書き込みの変更をマージし、pnfs_block_invalid_data程度に結果を記述する必要があります。そのbex_file_offsetと範囲のブロック。つまり、データのブロック全体が操作によって上書きされる場合、対応するPNFS_BLOCK_READ_DATAブロックを取得する必要はありませんが、PNFS_BLOCK_INVALID_DATA EXTENTENTSを介して結果を保存する前に、部分的なブロックの書き込みをPNFS_BLOCK_READ_DATA Extentsを介して取得する必要があります。この議論の目的のために、「ブロック全体」と「部分ブロック」は、サーバーのファイルシステムブロックサイズを指します。PNFS_BLOCK_INVALID_DATA範囲にデータを保存すると、PNFS_BLOCK_INVALID_DATA範囲の書かれた部分をPNFS_BLOCK_READ_WRITE_DATA範囲に変換します。後続のすべての読み取りは、この程度から実行する必要があります。PNFS_BLOCK_INVALID_DATA範囲にデータを保存した後、PNFS_BLOCK_READ_DATA範囲の対応する部分を使用してはなりません。クライアントが範囲の一部のみを書き込む場合、範囲はブロックアラインされた境界で分割される場合があります。"
    },
    {
      "indent": 3,
      "text": "When a client wishes to write data to a PNFS_BLOCK_INVALID_DATA extent that is not covered by a PNFS_BLOCK_READ_DATA extent, it MUST treat this write identically to a write to a file not involved with copy-on-write semantics. Thus, data must be written in at least block-sized increments, aligned to multiples of block-sized offsets, and unwritten portions of blocks must be zero filled.",
      "ja": "クライアントがPNFS_BLOCK_INVALID_DATAの範囲にデータを書き込みたい場合、PNFS_BLOCK_READ_DATA範囲でカバーされていない場合、コピーオンワイトセマンティクスに関係しないファイルの書き込みと同じようにこの書き込みを扱う必要があります。したがって、データは少なくともブロックサイズの増分で記述し、ブロックサイズのオフセットの倍数に整列し、ブロックの記載されていない部分はゼロで塗りつぶされなければなりません。"
    },
    {
      "indent": 3,
      "text": "In the LAYOUTCOMMIT operation that normally sends updated layout information back to the server, for writable data, some PNFS_BLOCK_INVALID_DATA extents may be committed as PNFS_BLOCK_READ_WRITE_DATA extents, signifying that the storage at the corresponding bex_storage_offset values has been stored into and is now to be considered as valid data to be read. PNFS_BLOCK_READ_DATA extents are not committed to the server. For extents that the client receives via LAYOUTGET as PNFS_BLOCK_INVALID_DATA and returns via LAYOUTCOMMIT as PNFS_BLOCK_READ_WRITE_DATA, the server will understand that the PNFS_BLOCK_READ_DATA mapping for that extent is no longer valid or necessary for that file.",
      "ja": "通常、更新されたレイアウト情報をサーバーに送り返すレイアウトコマット操作では、書き込み可能なデータについては、PNFS_BLOCK_READ_WRITE_DATA EXTENTとしてコミットされる場合があります。読み取るデータ。PNFS_BLOCK_READ_DATA Extentsはサーバーにコミットしていません。クライアントがPNFS_BLOCK_INVALID_DATAとしてレイアウトゲットを介して受信し、PNFS_BLOCK_READ_WRITE_DATAとしてレイアウトコマットを介して返すことの場合、サーバーはPNFS_BLOCK_READ_DATAマッピングがそのファイルにはもはや有効または必要ではないことを理解します。"
    },
    {
      "indent": 0,
      "text": "2.3.5. Extents are Permissions",
      "section_title": true,
      "ja": "2.3.5. Extentsは権限です"
    },
    {
      "indent": 3,
      "text": "Layout extents returned to pNFS clients grant permission to read or write; PNFS_BLOCK_READ_DATA and PNFS_BLOCK_NONE_DATA are read-only (PNFS_BLOCK_NONE_DATA reads as zeroes), PNFS_BLOCK_READ_WRITE_DATA and PNFS_BLOCK_INVALID_DATA are read/write, (PNFS_BLOCK_INVALID_DATA reads as zeros, any write converts it to PNFS_BLOCK_READ_WRITE_DATA). This is the only means a client has of obtaining permission to perform direct I/O to storage devices; a pNFS client MUST NOT perform direct I/O operations that are not permitted by an extent held by the client. Client adherence to this rule places the pNFS server in control of potentially conflicting storage device operations, enabling the server to determine what does conflict and how to avoid conflicts by granting and recalling extents to/from clients.",
      "ja": "PNFSクライアントに返されたレイアウトExtentsは、読み書き許可を付与しました。PNFS_BLOCK_READ_DATAおよびPNFS_BLOCK_NONE_DATAは読み取り専用です（PNFS_BLOCK_NONE_DATAはゼロとして読み取ります）、PNFS_BLOCK_READ_WRITE_DATAおよびPNFS_BLOCK_INVALID_DATA read/readid_block read（pnfs_bblock_block read edid dacfda）これは、クライアントがストレージデバイスに直接I/Oを実行する許可を取得する唯一の意味です。PNFSクライアントは、クライアントが保有する範囲で許可されていない直接I/O操作を実行してはなりません。このルールのクライアントの順守により、PNFSサーバーは潜在的に矛盾するストレージデバイス操作を制御し、競合が何であり、クライアントに範囲を付与およびリコールすることで競合を回避する方法を決定できるようにします。"
    },
    {
      "indent": 3,
      "text": "Block/volume class storage devices are not required to perform read and write operations atomically. Overlapping concurrent read and write operations to the same data may cause the read to return a mixture of before-write and after-write data. Overlapping write operations can be worse, as the result could be a mixture of data from the two write operations; data corruption can occur if the underlying storage is striped and the operations complete in different orders on different stripes. When there are multiple clients who wish to access the same data, a pNFS server can avoid these conflicts by implementing a concurrency control policy of single writer XOR multiple readers. This policy MUST be implemented when storage devices do not provide atomicity for concurrent read/write and write/write operations to the same data.",
      "ja": "ブロック/ボリュームクラスストレージデバイスは、読み取りおよび書き込み操作を原子的に実行する必要はありません。同じデータに同時に読み取りおよび書き込み操作が重複すると、読み取りが事前にライター以前のデータと筆記後データの混合物を返すことがあります。結果は、2つの書き込み操作のデータが混在する可能性があるため、重複する書き込み操作は悪化する可能性があります。基礎となるストレージが縞模様であり、操作が異なるストライプで異なる注文で完了した場合、データの破損が発生する可能性があります。同じデータにアクセスしたい複数のクライアントがいる場合、PNFSサーバーは、単一のライターXOR複数の読者の同時制御ポリシーを実装することにより、これらの競合を回避できます。このポリシーは、ストレージデバイスが同じデータに同時読み取り/書き込みおよび書き込み操作の原子性を提供しない場合に実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client makes a layout request that conflicts with an existing layout delegation, the request will be rejected with the error NFS4ERR_LAYOUTTRYLATER. This client is then expected to retry the request after a short interval. During this interval, the server SHOULD recall the conflicting portion of the layout delegation from the client that currently holds it. This reject-and-retry approach does not prevent client starvation when there is contention for the layout of a particular file. For this reason, a pNFS server SHOULD implement a mechanism to prevent starvation. One possibility is that the server can maintain a queue of rejected layout requests. Each new layout request can be checked to see if it conflicts with a previous rejected request, and if so, the newer request can be rejected. Once the original requesting client retries its request, its entry in the rejected request queue can be cleared, or the entry in the rejected request queue can be removed when it reaches a certain age.",
      "ja": "クライアントが既存のレイアウト代表団と競合するレイアウト要求を行うと、リクエストはエラーnfs4err_layouttrylaterで拒否されます。このクライアントは、短い間隔の後にリクエストを再試行することが期待されます。この間隔中、サーバーは、現在それを保持しているクライアントからのレイアウト代表団の競合する部分をリコールする必要があります。この拒否と再連絡のアプローチは、特定のファイルのレイアウトの競合がある場合、クライアントの飢starを妨げません。このため、PNFSサーバーは飢vを防ぐメカニズムを実装する必要があります。1つの可能性は、サーバーが拒否されたレイアウトリクエストのキューを維持できることです。新しいレイアウト要求をチェックして、以前の拒否されたリクエストと競合するかどうかを確認できます。もしそうなら、新しいリクエストを拒否できます。元の要求クライアントがリクエストを取得すると、拒否された要求キューへのエントリをクリアするか、特定の年齢に達したときに拒否された要求キューのエントリを削除することができます。"
    },
    {
      "indent": 3,
      "text": "NFSv4 supports mandatory locks and share reservations. These are mechanisms that clients can use to restrict the set of I/O operations that are permissible to other clients. Since all I/O operations ultimately arrive at the NFSv4 server for processing, the server is in a position to enforce these restrictions. However, with pNFS layouts, I/Os will be issued from the clients that hold the layouts directly to the storage devices that host the data. These devices have no knowledge of files, mandatory locks, or share reservations, and are not in a position to enforce such restrictions. For this reason the NFSv4 server MUST NOT grant layouts that conflict with mandatory locks or share reservations. Further, if a conflicting mandatory lock request or a conflicting open request arrives at the server, the server MUST recall the part of the layout in conflict with the request before granting the request.",
      "ja": "NFSV4は、必須のロックをサポートし、予約を共有します。これらは、クライアントが他のクライアントに許容されるI/O操作のセットを制限するために使用できるメカニズムです。すべてのI/O操作は最終的に処理のためにNFSV4サーバーに到着するため、サーバーはこれらの制限を実施する立場にあります。ただし、PNFSレイアウトを使用すると、データをホストするストレージデバイスに直接レイアウトを保持するクライアントからI/OSが発行されます。これらのデバイスには、ファイル、必須のロック、または予約を共有する知識はなく、そのような制限を実施する立場にありません。このため、NFSV4サーバーは、必須のロックと競合するレイアウトを許可したり、予約を共有したりしてはなりません。さらに、競合する必須ロックリクエストまたは競合するオープンリクエストがサーバーに到着した場合、サーバーはリクエストを許可する前にリクエストと競合するレイアウトの部分をリコールする必要があります。"
    },
    {
      "indent": 0,
      "text": "2.3.6. End-of-file Processing",
      "section_title": true,
      "ja": "2.3.6. ファイル終了処理"
    },
    {
      "indent": 3,
      "text": "The end-of-file location can be changed in two ways: implicitly as the result of a WRITE or LAYOUTCOMMIT beyond the current end-of-file, or explicitly as the result of a SETATTR request. Typically, when a file is truncated by an NFSv4 client via the SETATTR call, the server frees any disk blocks belonging to the file that are beyond the new end-of-file byte, and MUST write zeros to the portion of the new end-of-file block beyond the new end-of-file byte. These actions render any pNFS layouts that refer to the blocks that are freed or written semantically invalid. Therefore, the server MUST recall from clients the portions of any pNFS layouts that refer to blocks that will be freed or written by the server before processing the truncate request. These recalls may take time to complete; as explained in [NFSv4.1], if the server cannot respond to the client SETATTR request in a reasonable amount of time, it SHOULD reply to the client with the error NFS4ERR_DELAY.",
      "ja": "ファイルの終わりの場所は、現在のファイルの終わりを超えて書き込みまたはレイアウトコミットの結果として暗黙的に、またはSetATTRリクエストの結果として明示的に変更できます。通常、Setattrコールを介してNFSV4クライアントによってファイルが切り捨てられると、サーバーは新しいファイルの終了バイトを超えたファイルに属するディスクブロックをフリーし、新しいエンドの部分にゼロを書き込む必要があります。新しいファイル終了バイトを越えてファイルブロックのブロック。これらのアクションは、解放または書かれたブロックを意味的に無効にしているPNFSレイアウトを提供します。したがって、サーバーは、トランケートリクエストを処理する前にサーバーによって解放または書き込まれるブロックを参照するPNFSレイアウトの部分をクライアントからリコールする必要があります。これらのリコールは完了するのに時間がかかる場合があります。[NFSV4.1]で説明されているように、サーバーが妥当な時間以内にクライアントSetATTR要求に応答できない場合、エラーNFS4err_Delayでクライアントに返信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Blocks in the PNFS_BLOCK_INVALID_DATA state that lie beyond the new end-of-file block present a special case. The server has reserved these blocks for use by a pNFS client with a writable layout for the file, but the client has yet to commit the blocks, and they are not yet a part of the file mapping on disk. The server MAY free these blocks while processing the SETATTR request. If so, the server MUST recall any layouts from pNFS clients that refer to the blocks before processing the truncate. If the server does not free the PNFS_BLOCK_INVALID_DATA blocks while processing the SETATTR request, it need not recall layouts that refer only to the PNFS_BLOCK_INVALID DATA blocks.",
      "ja": "PNFS_BLOCK_INVALID_DATAのブロックは、新しいファイル終了ブロックを超えてある状態で特別なケースを示しています。サーバーは、ファイルの書き込み可能なレイアウトを備えたPNFSクライアントが使用するためにこれらのブロックを予約していますが、クライアントはまだブロックをコミットしておらず、ディスク上のファイルマッピングの一部ではありません。サーバーは、SetATTRリクエストの処理中にこれらのブロックを解放できます。その場合、サーバーは、トランケートを処理する前にブロックを参照するPNFSクライアントからのレイアウトをリコールする必要があります。サーバーがPNFS_BLOCK_INVALID_DATAブロックを無料で無料で提供している場合、SetATTRリクエストの処理中にブロックするには、PNFS_BLOCK_INVALIDデータブロックのみを参照するレイアウトをリコールする必要はありません。"
    },
    {
      "indent": 3,
      "text": "When a file is extended implicitly by a WRITE or LAYOUTCOMMIT beyond the current end-of-file, or extended explicitly by a SETATTR request, the server need not recall any portions of any pNFS layouts.",
      "ja": "ファイルが現在のファイルの終了を超えて書き込みまたはレイアウトコミットによって暗黙的に拡張されるか、SetATTRリクエストによって明示的に拡張された場合、サーバーはPNFSレイアウトの一部をリコールする必要はありません。"
    },
    {
      "indent": 0,
      "text": "2.3.7. Layout Hints",
      "section_title": true,
      "ja": "2.3.7. レイアウトのヒント"
    },
    {
      "indent": 3,
      "text": "The SETATTR operation supports a layout hint attribute [NFSv4.1]. When the client sets a layout hint (data type layouthint4) with a layout type of LAYOUT4_BLOCK_VOLUME (the loh_type field), the loh_body field contains a value of data type pnfs_block_layouthint4.",
      "ja": "SetATTR操作は、レイアウトヒント属性[NFSV4.1]をサポートしています。クライアントがレイアウトタイプのlayout4_block_volume（loh_typeフィールド）を使用してレイアウトヒント（データ型layouthint4）を設定すると、loh_bodyフィールドにはデータ型pnfs_block_layouthint4の値が含まれています。"
    },
    {
      "indent": 3,
      "text": "/// /* block layout specific type for loh_body */\n/// struct pnfs_block_layouthint4 {\n///     uint64_t blh_maximum_io_time;  /* maximum i/o time in seconds\n///                                       */\n/// };\n///\n   The block layout client uses the layout hint data structure to\ncommunicate to the server the maximum time that it may take an I/O to\nexecute on the client.  Clients using block layouts MUST set the\nlayout hint attribute before using LAYOUTGET operations.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.3.8. Client Fencing",
      "section_title": true,
      "ja": "2.3.8. クライアントフェンシング"
    },
    {
      "indent": 3,
      "text": "The pNFS block protocol must handle situations in which a system failure, typically a network connectivity issue, requires the server to unilaterally revoke extents from one client in order to transfer the extents to another client. The pNFS server implementation MUST ensure that when resources are transferred to another client, they are not used by the client originally owning them, and this must be ensured against any possible combination of partitions and delays among all of the participants to the protocol (server, storage and client). Two approaches to guaranteeing this isolation are possible and are discussed below.",
      "ja": "PNFSブロックプロトコルは、システム障害（通常はネットワーク接続の問題）が、範囲を別のクライアントに転送するために、あるクライアントから範囲を一方的に取り消す必要がある状況を処理する必要があります。PNFSサーバーの実装は、リソースが別のクライアントに転送されたときに、元々所有しているクライアントが使用しないことを保証する必要があります。これは、すべての参加者間のパーティションと遅延の可能な組み合わせに対して、プロトコル（サーバー、サーバー、ストレージとクライアント）。この分離を保証する2つのアプローチが可能であり、以下で説明します。"
    },
    {
      "indent": 3,
      "text": "One implementation choice for fencing the block client from the block storage is the use of LUN masking or mapping at the storage systems or storage area network to disable access by the client to be isolated. This requires server access to a management interface for the storage system and authorization to perform LUN masking and management operations. For example, the Storage Management Initiative Specification (SMI-S) [SMIS] provides a means to discover and mask LUNs, including a means of associating clients with the necessary World Wide Names or Initiator names to be masked.",
      "ja": "ブロッククライアントをブロックストレージからフェンシングするための1つの実装選択は、LUNマスキングの使用またはストレージシステムまたはストレージエリアネットワークでのマッピングを使用して、クライアントによるアクセスを無効にすることです。これには、ストレージシステムの管理インターフェイスへのサーバーアクセスとLUNマスキングおよび管理操作を実行する許可が必要です。たとえば、ストレージ管理イニシアチブ仕様（SMI-S）[SMIS]は、クライアントに必要な世界的な名前またはマスクされるイニシエーター名を関連付ける手段を含む、LUNを発見およびマスクする手段を提供します。"
    },
    {
      "indent": 3,
      "text": "In the absence of support for LUN masking, the server has to rely on the clients to implement a timed-lease I/O fencing mechanism. Because clients do not know if the server is using LUN masking, in all cases, the client MUST implement timed-lease fencing. In timed-lease fencing, we define two time periods, the first, \"lease_time\" is the length of a lease as defined by the server's lease_time attribute (see [NFSv4.1]), and the second, \"blh_maximum_io_time\" is the maximum time it can take for a client I/O to the storage system to either complete or fail; this value is often 30 seconds or 60 seconds, but may be longer in some environments. If the maximum client I/O time cannot be bounded, the client MUST use a value of all 1s as the blh_maximum_io_time.",
      "ja": "LUNマスキングのサポートがない場合、サーバーはクライアントに頼ってタイムリースI/Oフェンシングメカニズムを実装する必要があります。クライアントは、サーバーがLUNマスキングを使用しているかどうかを知らないため、すべての場合において、クライアントはタイムリースフェンシングを実装する必要があります。タイムリースフェンシングでは、2つの期間を定義します。最初の「リース_TIME」は、サーバーのリース_TIME属性（[NFSV4.1]を参照）で定義されているリースの長さと2番目の「Blh_maximum_io_time」は最大値です。クライアントI/Oがストレージシステムにかかる時間を完了または故障させる時間を取ることができます。この値は多くの場合30秒または60秒ですが、一部の環境では長くなる場合があります。最大クライアントI/O時間を制限できない場合、クライアントはすべての1の値をBLH_MAXIMUM_IO_TIMEとして使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "After a new client ID is established, the client MUST use SETATTR with a layout hint of type LAYOUT4_BLOCK_VOLUME to inform the server of its maximum I/O time prior to issuing the first LAYOUTGET operation. While the maximum I/O time hint is a per-file attribute, it is actually a per-client characteristic. Thus, the server MUST maintain the last maximum I/O time hint sent separately for each client. Each time the maximum I/O time changes, the server MUST apply it to all files for which the client has a layout. If the client does not specify this attribute on a file for which a block layout is requested, the server SHOULD use the most recent value provided by the same client for any file; if that client has not provided a value for this attribute, the server SHOULD reject the layout request with the error NFS4ERR_LAYOUTUNAVAILABLE. The client SHOULD NOT send a SETATTR of the layout hint with every LAYOUTGET. A server that implements fencing via LUN masking SHOULD accept any maximum I/O time value from a client. A server that does not implement fencing may return an error NFS4ERR_INVAL to the SETATTR operation. Such a server SHOULD return NFS4ERR_INVAL when a client sends an unbounded maximum I/O time (all 1s), or when the maximum I/O time is significantly greater than that of other clients using block layouts with pNFS.",
      "ja": "新しいクライアントIDが確立された後、クライアントは、タイプのlayout4_block_volumeのレイアウトヒントを備えたSetATTRを使用して、最初のレイアウト操作を発行する前にサーバーに最大I/O時間を通知する必要があります。最大I/Oタイムヒントはファイルごとの属性ですが、実際にはクライアントごとの特性です。したがって、サーバーは、クライアントごとに個別に送信される最後の最大I/Oタイムヒントを維持する必要があります。最大I/O時間が変更されるたびに、サーバーはクライアントがレイアウトを持っているすべてのファイルにそれを適用する必要があります。クライアントがブロックレイアウトが要求されるファイルにこの属性を指定しない場合、サーバーは任意のファイルに対して同じクライアントが提供する最新の値を使用する必要があります。そのクライアントがこの属性の値を提供していない場合、サーバーはエラーnfs4err_layoutunavailableでレイアウト要求を拒否する必要があります。クライアントは、レイアウトヒントのすべてのレイアウトゲットを使用してレイアウトヒントを送信しないでください。LUNマスキングを介してフェンシングを実装するサーバーは、クライアントからの最大I/O時間値を受け入れる必要があります。フェンシングを実装しないサーバーは、setATTR操作にエラーNFS4err_invalを返す場合があります。このようなサーバーは、クライアントが無制限の最大I/O時間（すべて1S）を送信するとき、またはPNFSを使用してブロックレイアウトを使用して他のクライアントの時間よりも最大I/O時間が大幅に大きい場合、NFS4err_Invalを返す必要があります。"
    },
    {
      "indent": 3,
      "text": "When a client receives the error NFS4ERR_INVAL in response to the SETATTR operation for a layout hint, the client MUST NOT use the LAYOUTGET operation. After responding with NFS4ERR_INVAL to the SETATTR for layout hint, the server MUST return the error NFS4ERR_LAYOUTUNAVAILABLE to all subsequent LAYOUTGET operations from that client. Thus, the server, by returning either NFS4ERR_INVAL or NFS4_OK determines whether or not a client with a large, or an unbounded-maximum I/O time may use pNFS.",
      "ja": "クライアントがレイアウトヒントのSetATTR操作に応じてエラーNFS4err_Invalを受信した場合、クライアントはレイアウトゲット操作を使用してはなりません。nfs4err_invalでレイアウトヒントのためにsetattrに応答した後、サーバーはそのクライアントからの後続のすべてのレイアウト操作に対してエラーnfs4err_layoutunavailableを返す必要があります。したがって、サーバーは、nfs4err_invalまたはnfs4_okのいずれかを返すことにより、大型のクライアント、または固定されていない最大I/O時間がPNFを使用できるかどうかを決定します。"
    },
    {
      "indent": 3,
      "text": "Using the lease time and the maximum I/O time values, we specify the behavior of the client and server as follows.",
      "ja": "リース時間と最大I/O時間値を使用して、次のようにクライアントとサーバーの動作を指定します。"
    },
    {
      "indent": 3,
      "text": "When a client receives layout information via a LAYOUTGET operation, those layouts are valid for at most \"lease_time\" seconds from when the server granted them. A layout is renewed by any successful SEQUENCE operation, or whenever a new stateid is created or updated (see the section \"Lease Renewal\" of [NFSv4.1]). If the layout lease is not renewed prior to expiration, the client MUST cease to use the layout after \"lease_time\" seconds from when it either sent the original LAYOUTGET command or sent the last operation renewing the lease. In other words, the client may not issue any I/O to blocks specified by an expired layout. In the presence of large communication delays between the client and server, it is even possible for the lease to expire prior to the server response arriving at the client. In such a situation, the client MUST NOT use the expired layouts, and SHOULD revert to using standard NFSv41 READ and WRITE operations. Furthermore, the client must be configured such that I/O operations complete within the \"blh_maximum_io_time\" even in the presence of multipath drivers that will retry I/Os via multiple paths.",
      "ja": "クライアントがレイアウト操作を介してレイアウト情報を受信すると、これらのレイアウトは、サーバーが付与されたときから最大の「lease_time」秒で有効です。レイアウトは、成功したシーケンス操作によって更新されます。または、新しいStateIDが作成または更新されるたびにレイアウトが更新されます（[NFSV4.1]のセクション「リース更新」を参照）。有効期限が切れる前にレイアウトリースが更新されない場合、クライアントは、元のレイアウトゲットコマンドを送信するか、リースを更新する最後の操作を送信したときから「リース_time」秒後にレイアウトの使用を停止する必要があります。言い換えれば、クライアントは、期限切れのレイアウトによって指定されたブロックにI/Oを発行することはできません。クライアントとサーバーの間に大きな通信遅延が存在する場合、クライアントに到着するサーバーの応答の前にリースが期限切れになることさえあります。このような状況では、クライアントは期限切れのレイアウトを使用してはなりません。標準のNFSV41読み取り操作の使用に戻る必要があります。さらに、複数のパスを介してI/OSを再試行するマルチパスドライバーが存在する場合でも、「BLH_MAXIMUM_IO_IO_TIME」内でI/O操作が完了するようにクライアントを構成する必要があります。"
    },
    {
      "indent": 3,
      "text": "As stated in the \"Dealing with Lease Expiration on the Client\" section of [NFSv4.1], if any SEQUENCE operation is successful, but sr_status_flag has SEQ4_STATUS_EXPIRED_ALL_STATE_REVOKED, SEQ4_STATUS_EXPIRED_SOME_STATE_REVOKED, or SEQ4_STATUS_ADMIN_STATE_REVOKED is set, the client MUST immediately cease to use all layouts and device ID to device address mappings associated with the corresponding server.",
      "ja": "[nfsv4.1]の「クライアントのリースの有効期限の取引」セクションで述べたように、シーケンス操作が成功した場合、sr_status_flagにはseq4_status_expired_all_state_revoked、seq4_status_expired_some_state_revokedまたはseq4_status_state forvoked forevokes対応するサーバーに関連付けられたデバイスへのデバイスアドレスマッピング。"
    },
    {
      "indent": 3,
      "text": "In the absence of known two-way communication between the client and the server on the fore channel, the server must wait for at least the time period \"lease_time\" plus \"blh_maximum_io_time\" before transferring layouts from the original client to any other client. The server, like the client, must take a conservative approach, and start the lease expiration timer from the time that it received the operation that last renewed the lease.",
      "ja": "クライアントとフォアチャネルのサーバー間の既知の双方向通信がない場合、サーバーは、少なくとも期間「Lease_Time」と「BLH_MAXIMUM_IO_TIME」を待機する必要があります。サーバーは、クライアントと同様に、保守的なアプローチを採用し、リースを最後に更新した操作を受け取った時点からリース有効期限タイマーを開始する必要があります。"
    },
    {
      "indent": 0,
      "text": "2.4. Crash Recovery Issues",
      "section_title": true,
      "ja": "2.4. クラッシュ回復の問題"
    },
    {
      "indent": 3,
      "text": "A critical requirement in crash recovery is that both the client and the server know when the other has failed. Additionally, it is required that a client sees a consistent view of data across server restarts. These requirements and a full discussion of crash recovery issues are covered in the \"Crash Recovery\" section of the NFSv41 specification [NFSv4.1]. This document contains additional crash recovery material specific only to the block/volume layout.",
      "ja": "クラッシュの回復における重要な要件は、クライアントとサーバーの両方が他者がいつ失敗したかを知っていることです。さらに、クライアントがサーバーの再起動全体でデータの一貫したビューを確認する必要があります。これらの要件とクラッシュ回復の問題に関する完全な議論は、NFSV41仕様[NFSV4.1]の「クラッシュ回復」セクションで説明されています。このドキュメントには、ブロック/ボリュームレイアウトにのみ固有の追加のクラッシュリカバリ資料が含まれています。"
    },
    {
      "indent": 3,
      "text": "When the server crashes while the client holds a writable layout, and the client has written data to blocks covered by the layout, and the blocks are still in the PNFS_BLOCK_INVALID_DATA state, the client has two options for recovery. If the data that has been written to these blocks is still cached by the client, the client can simply re-write the data via NFSv4, once the server has come back online. However, if the data is no longer in the client's cache, the client MUST NOT attempt to source the data from the data servers. Instead, it should attempt to commit the blocks in question to the server during the server's recovery grace period, by sending a LAYOUTCOMMIT with the \"loca_reclaim\" flag set to true. This process is described in detail in Section 18.42.4 of [NFSv4.1].",
      "ja": "クライアントが書き込み可能なレイアウトを保持している間にサーバーがクラッシュし、クライアントがレイアウトでカバーされているブロックのデータを作成し、ブロックはまだPNFS_BLOCK_INVALID_DATA状態にあり、クライアントには回復のための2つのオプションがあります。これらのブロックに書き込まれたデータがまだクライアントによってキャッシュされている場合、クライアントはサーバーがオンラインで戻ってきたら、NFSV4を介してデータを書き直すだけです。ただし、データがクライアントのキャッシュにない場合、クライアントはデータサーバーからデータを調達しようとしてはなりません。代わりに、「loca_recame」フラグをtrueに設定したレイアウトコミットを送信することにより、サーバーの回復グレース期間中に問題のブロックをサーバーにコミットしようとする必要があります。このプロセスについては、[NFSV4.1]のセクション18.42.4で詳しく説明しています。"
    },
    {
      "indent": 0,
      "text": "2.5. Recalling Resources: CB_RECALL_ANY",
      "section_title": true,
      "ja": "2.5. リソースのリコール：cb_recall_any"
    },
    {
      "indent": 3,
      "text": "The server may decide that it cannot hold all of the state for layouts without running out of resources. In such a case, it is free to recall individual layouts using CB_LAYOUTRECALL to reduce the load, or it may choose to request that the client return any layout.",
      "ja": "サーバーは、リソースを使い果たすことなく、レイアウトのためにすべての状態を保持できないと判断する場合があります。そのような場合、CB_LayoutreCallを使用して個々のレイアウトをリコールして負荷を減らすか、クライアントがレイアウトを返すように要求することを選択できます。"
    },
    {
      "indent": 3,
      "text": "The NFSv4.1 spec [NFSv4.1] defines the following types:",
      "ja": "NFSV4.1仕様[NFSV4.1]は、次のタイプを定義します。"
    },
    {
      "indent": 3,
      "text": "const RCA4_TYPE_MASK_BLK_LAYOUT = 4;",
      "ja": "const rca4_type_mask_blk_layout = 4;"
    },
    {
      "indent": 3,
      "text": "struct CB_RECALL_ANY4args {\n       uint32_t      craa_objects_to_keep;\n       bitmap4       craa_type_mask;\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When the server sends a CB_RECALL_ANY request to a client specifying the RCA4_TYPE_MASK_BLK_LAYOUT bit in craa_type_mask, the client should immediately respond with NFS4_OK, and then asynchronously return complete file layouts until the number of files with layouts cached on the client is less than craa_object_to_keep.",
      "ja": "サーバーがcb_recall_anyリクエストをクライアントに送信した場合、rca4_type_mask_blk_layoutビットをCRAA_TYPE_MASKで指定する場合、クライアントはNFS4_OKですぐに応答し、クライアントがクライアントではないレイアウトを持つファイル数が少ないまで完全なファイルレイアウトを非同期に返す必要があります。"
    },
    {
      "indent": 0,
      "text": "2.6. Transient and Permanent Errors",
      "section_title": true,
      "ja": "2.6. 一時的および永続的なエラー"
    },
    {
      "indent": 3,
      "text": "The server may respond to LAYOUTGET with a variety of error statuses. These errors can convey transient conditions or more permanent conditions that are unlikely to be resolved soon.",
      "ja": "サーバーは、さまざまなエラーステータスを持つLayoutGetに応答する場合があります。これらのエラーは、すぐに解決される可能性が低い過渡的な条件またはより永続的な条件を伝えることができます。"
    },
    {
      "indent": 3,
      "text": "The transient errors, NFS4ERR_RECALLCONFLICT and NFS4ERR_TRYLATER, are used to indicate that the server cannot immediately grant the layout to the client. In the former case, this is because the server has recently issued a CB_LAYOUTRECALL to the requesting client, whereas in the case of NFS4ERR_TRYLATER, the server cannot grant the request possibly due to sharing conflicts with other clients. In either case, a reasonable approach for the client is to wait several milliseconds and retry the request. The client SHOULD track the number of retries, and if forward progress is not made, the client SHOULD send the READ or WRITE operation directly to the server.",
      "ja": "一時的なエラー、nfs4err_recallconflictおよびnfs4err_trylaterは、サーバーがクライアントにすぐにレイアウトを許可できないことを示すために使用されます。前者のケースでは、これはサーバーが最近リクエストクライアントにCB_LayouTreCallを発行したためですが、NFS4err_tryLaterの場合、サーバーは他のクライアントと競合を共有するためにリクエストを許可できません。どちらの場合でも、クライアントにとって合理的なアプローチは、数ミリ秒待ってリクエストを再試行することです。クライアントはレトリの数を追跡する必要があり、前方の進行が行われない場合、クライアントは読み取りまたは書き込み操作を直接サーバーに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The error NFS4ERR_LAYOUTUNAVAILABLE may be returned by the server if layouts are not supported for the requested file or its containing file system. The server may also return this error code if the server is the progress of migrating the file from secondary storage, or for any other reason that causes the server to be unable to supply the layout. As a result of receiving NFS4ERR_LAYOUTUNAVAILABLE, the client SHOULD send future READ and WRITE requests directly to the server. It is expected that a client will not cache the file's layoutunavailable state forever, particular if the file is closed, and thus eventually, the client MAY reissue a LAYOUTGET operation.",
      "ja": "リクエストされたファイルまたはその含有ファイルシステムでレイアウトがサポートされていない場合、エラーNFS4err_layoutunavailableはサーバーによって返される場合があります。サーバーがセカンダリストレージからファイルを移行することの進捗状況、またはサーバーがレイアウトを提供できない他の理由で、サーバーがこのエラーコードを返すこともできます。nfs4err_layoutunavailableを受信した結果、クライアントは将来の読み取りと書き込みリクエストをサーバーに直接送信する必要があります。クライアントは、特にファイルが閉じている場合、ファイルのレイート販売可能状態を永久にキャッシュしないため、最終的にはクライアントがレイアウトゲット操作を再発行する可能性があることが予想されます。"
    },
    {
      "indent": 0,
      "text": "3. Security Considerations",
      "section_title": true,
      "ja": "3. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Typically, SAN disk arrays and SAN protocols provide access control mechanisms (e.g., LUN mapping and/or masking) that operate at the granularity of individual hosts. The functionality provided by such mechanisms makes it possible for the server to \"fence\" individual client machines from certain physical disks -- that is to say, to prevent individual client machines from reading or writing to certain physical disks. Finer-grained access control methods are not generally available. For this reason, certain security responsibilities are delegated to pNFS clients for block/volume layouts. Block/volume storage systems generally control access at a volume granularity, and hence pNFS clients have to be trusted to only perform accesses allowed by the layout extents they currently hold (e.g., and not access storage for files on which a layout extent is not held). In general, the server will not be able to prevent a client that holds a layout for a file from accessing parts of the physical disk not covered by the layout. Similarly, the server will not be able to prevent a client from accessing blocks covered by a layout that it has already returned. This block-based level of protection must be provided by the client software.",
      "ja": "通常、SANディスクアレイとSANプロトコルは、個々のホストの粒度で動作するアクセス制御メカニズム（例：LUNマッピングやマスキング）を提供します。このようなメカニズムによって提供される機能により、サーバーは特定の物理的なディスクから個々のクライアントマシン、つまり個々のクライアントマシンが特定の物理ディスクに読み書きまたは書き込みを防ぐことを可能にします。より細かいアクセス制御方法は一般に利用できません。このため、特定のセキュリティ責任は、ブロック/ボリュームレイアウトのためにPNFSクライアントに委任されます。ブロック/ボリュームストレージシステムは一般にボリュームの粒度でアクセスを制御するため、PNFSクライアントは、現在保持しているレイアウトエンテントによって許可されているアクセスのみを実行するために信頼する必要があります（例：レイアウト範囲が保持されていないファイルのアクセスストレージではありません）。一般に、サーバーは、ファイルのレイアウトを保持しているクライアントが、レイアウトでカバーされていない物理ディスクの部分にアクセスするのを防ぐことができません。同様に、サーバーは、すでに返されたレイアウトでカバーされているブロックにクライアントにアクセスできないようにすることができません。このブロックベースのレベルの保護は、クライアントソフトウェアによって提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "An alternative method of block/volume protocol use is for the storage devices to export virtualized block addresses, which do reflect the files to which blocks belong. These virtual block addresses are exported to pNFS clients via layouts. This allows the storage device to make appropriate access checks, while mapping virtual block addresses to physical block addresses. In environments where the security requirements are such that client-side protection from access to storage outside of the authorized layout extents is not sufficient, pNFS block/volume storage layouts SHOULD NOT be used unless the storage device is able to implement the appropriate access checks, via use of virtualized block addresses or other means. In contrast, an environment where client-side protection may suffice consists of co-located clients, server and storage systems in a data center with a physically isolated SAN under control of a single system administrator or small group of system administrators.",
      "ja": "ブロック/ボリュームプロトコルの使用の代替方法は、ストレージデバイスが仮想化ブロックアドレスをエクスポートするためのものであり、ブロックが属するファイルを反映しています。これらの仮想ブロックアドレスは、レイアウトを介してPNFSクライアントにエクスポートされます。これにより、ストレージデバイスが適切なアクセスチェックを作成し、仮想ブロックアドレスを物理ブロックアドレスにマッピングすることができます。セキュリティ要件がある環境では、クライアント側のストレージへのアクセスからのクライアント側の保護が許可されたレイアウトエンテント以外のものでは十分ではありません。PNFSブロック/ボリュームストレージレイアウトは、ストレージデバイスが適切なアクセスチェックを実装できない限り使用しないでください。仮想化されたブロックアドレスまたはその他の手段の使用を介して。対照的に、クライアント側の保護が十分である可能性がある環境では、単一のシステム管理者またはシステム管理者の小グループを制御している物理的に孤立したSANを備えたデータセンターの共同配置されたクライアント、サーバー、およびストレージシステムで構成されています。"
    },
    {
      "indent": 3,
      "text": "This also has implications for some NFSv4 functionality outside pNFS. For instance, if a file is covered by a mandatory read-only lock, the server can ensure that only readable layouts for the file are granted to pNFS clients. However, it is up to each pNFS client to ensure that the readable layout is used only to service read requests, and not to allow writes to the existing parts of the file. Similarly, block/volume storage devices are unable to validate NFS Access Control Lists (ACLs) and file open modes, so the client must enforce the policies before sending a READ or WRITE request to the storage device. Since block/volume storage systems are generally not capable of enforcing such file-based security, in environments where pNFS clients cannot be trusted to enforce such policies, pNFS block/volume storage layouts SHOULD NOT be used.",
      "ja": "これは、PNFS以外の一部のNFSV4機能にも影響を与えます。たとえば、ファイルが必須の読み取り専用ロックでカバーされている場合、サーバーは、ファイルの読み取り可能なレイアウトのみがPNFSクライアントに付与されるようにします。ただし、読み取り可能なレイアウトが読み取りリクエストのサービスにのみ使用され、ファイルの既存の部分に書き込みを許可しないようにするのは、各PNFSクライアント次第です。同様に、ブロック/ボリュームストレージデバイスでは、NFSアクセス制御リスト（ACLS）とファイルオープンモードを検証できないため、クライアントはストレージデバイスに読み取りまたは書き込みリクエストを送信する前にポリシーを実施する必要があります。ブロック/ボリュームストレージシステムは一般に、このようなファイルベースのセキュリティを実施できないため、PNFSクライアントをそのようなポリシーを実施するために信頼できない環境では、PNFSブロック/ボリュームストレージレイアウトは使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Access to block/volume storage is logically at a lower layer of the I/O stack than NFSv4, and hence NFSv4 security is not directly applicable to protocols that access such storage directly. Depending on the protocol, some of the security mechanisms provided by NFSv4 (e.g., encryption, cryptographic integrity) may not be available or may be provided via different means. At one extreme, pNFS with block/volume storage can be used with storage access protocols (e.g., parallel SCSI) that provide essentially no security functionality. At the other extreme, pNFS may be used with storage protocols such as iSCSI that can provide significant security functionality. It is the responsibility of those administering and deploying pNFS with a block/volume storage access protocol to ensure that appropriate protection is provided to that protocol (physical security is a common means for protocols not based on IP). In environments where the security requirements for the storage protocol cannot be met, pNFS block/volume storage layouts SHOULD NOT be used.",
      "ja": "ブロック/ボリュームストレージへのアクセスは、論理的にNFSV4よりもI/Oスタックの下層にあります。したがって、NFSV4セキュリティは、そのようなストレージに直接アクセスするプロトコルに直接適用できません。プロトコルに応じて、NFSV4によって提供されるセキュリティメカニズムの一部（たとえば、暗号化、暗号化の完全性）は利用できないか、さまざまな手段で提供される場合があります。極端な場合、ブロック/ボリュームストレージを備えたPNFは、本質的にセキュリティ機能を提供しないストレージアクセスプロトコル（並列SCSIなど）で使用できます。もう1つの極端な場合、PNFは、重要なセキュリティ機能を提供できるISCSIなどのストレージプロトコルで使用できます。これは、そのプロトコルに適切な保護が提供されることを保証するために、ブロック/ボリュームストレージアクセスプロトコルを使用してPNFを管理および展開する責任です（物理セキュリティは、IPに基づいていないプロトコルの一般的な手段です）。ストレージプロトコルのセキュリティ要件を満たせない環境では、PNFSブロック/ボリュームストレージレイアウトを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "When security is available for a storage protocol, it is generally at a different granularity and with a different notion of identity than NFSv4 (e.g., NFSv4 controls user access to files, iSCSI controls initiator access to volumes). The responsibility for enforcing appropriate correspondences between these security layers is placed upon the pNFS client. As with the issues in the first paragraph of this section, in environments where the security requirements are such that client-side protection from access to storage outside of the layout is not sufficient, pNFS block/volume storage layouts SHOULD NOT be used.",
      "ja": "ストレージプロトコルのセキュリティが利用可能である場合、それは一般に異なる粒度であり、NFSV4とは異なるアイデンティティの概念を持つ（たとえば、NFSV4はファイルへのユーザーアクセスを制御し、ISCSIはボリュームへのイニシエーターアクセスを制御します）。これらのセキュリティレイヤー間の適切な対応を実施する責任は、PNFSクライアントに配置されます。このセクションの最初の段落の問題と同様に、セキュリティ要件がレイアウト外のストレージへのアクセスからのクライアント側の保護が十分ではないような環境では、PNFSブロック/ボリュームストレージレイアウトを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "4. Conclusions",
      "section_title": true,
      "ja": "4. 結論"
    },
    {
      "indent": 3,
      "text": "This document specifies the block/volume layout type for pNFS and associated functionality.",
      "ja": "このドキュメントは、PNFと関連する機能のブロック/ボリュームレイアウトタイプを指定します。"
    },
    {
      "indent": 0,
      "text": "5. IANA Considerations",
      "section_title": true,
      "ja": "5. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "There are no IANA considerations in this document. All pNFS IANA Considerations are covered in [NFSv4.1].",
      "ja": "このドキュメントにはIANAの考慮事項はありません。すべてのPNFS IANAの考慮事項は[NFSV4.1]で説明されています。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgments",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document draws extensively on the authors' familiarity with the mapping functionality and protocol in EMC's Multi-Path File System (MPFS) (previously named HighRoad) system [MPFS]. The protocol used by MPFS is called FMP (File Mapping Protocol); it is an add-on protocol that runs in parallel with file system protocols such as NFSv3 to provide pNFS-like functionality for block/volume storage. While drawing on FMP, the data structures and functional considerations in this document differ in significant ways, based on lessons learned and the opportunity to take advantage of NFSv4 features such as COMPOUND operations. The design to support pNFS client participation in copy-on-write is based on text and ideas contributed by Craig Everhart.",
      "ja": "このドキュメントは、EMCのマルチパスファイルシステム（MPFS）（以前はHighroad）システム[MPFS]のマッピング機能とプロトコルに対する著者の精通性について広く描かれています。MPFSが使用するプロトコルはFMP（ファイルマッピングプロトコル）と呼ばれます。これは、NFSV3などのファイルシステムプロトコルと並行して実行され、ブロック/ボリュームストレージにPNFS様の機能を提供するアドオンプロトコルです。FMPを利用している間、このドキュメントのデータ構造と機能的な考慮事項は、学んだ教訓と複合操作などのNFSV4機能を活用する機会に基づいて、重要な方法で異なります。PNFSクライアントのコピーライトへの参加をサポートするための設計は、Craig Everhartが提供するテキストとアイデアに基づいています。"
    },
    {
      "indent": 3,
      "text": "Andy Adamson, Ben Campbell, Richard Chandler, Benny Halevy, Fredric Isaman, and Mario Wurzl all helped to review versions of this specification.",
      "ja": "Andy Adamson、Ben Campbell、Richard Chandler、Benny Halevy、Fredric Isaman、Mario Wurzlはすべて、この仕様のバージョンをレビューするのに役立ちました。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[LEGAL] IETF Trust, \"Legal Provisions Relating to IETF Documents\", http://trustee.ietf.org/docs/IETF-Trust-License-Policy.pdf, November 2008.",
      "ja": "[法的] IETFトラスト、「IETFドキュメントに関連する法的規定」、http：//trustee.ietf.org/docs/ietf-trust-license-policy.pdf、2008年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[NFSv4.1] Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed., \"Network File System (NFS) Version 4 Minor Version 1 Protocol\", RFC 5661, January 2010.",
      "ja": "[NFSV4.1] Shepler、S.、Ed。、Eisler、M.、Ed。、およびD. Noveck、ed。、「Network File System（NFS）バージョン4マイナーバージョン1プロトコル」、RFC 5661、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[XDR] Eisler, M., Ed., \"XDR: External Data Representation Standard\", STD 67, RFC 4506, May 2006.",
      "ja": "[XDR] Eisler、M.、ed。、「XDR：外部データ表現標準」、STD 67、RFC 4506、2006年5月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[MPFS] EMC Corporation, \"EMC Celerra Multi-Path File System (MPFS)\", EMC Data Sheet, http://www.emc.com/collateral/software/data-sheet/ h2006-celerra-mpfs-mpfsi.pdf.",
      "ja": "[MPFS] EMC Corporation、「EMC Celerra Multi-Path File System（MPFS）」、EMCデータシート、http：//www.emc.com/collateral/software/data-sheet/ h2006-celerra-mpfs-mpfsi.pdf。"
    },
    {
      "indent": 3,
      "text": "[SMIS] SNIA, \"Storage Management Initiative Specification (SMI-S) v1.4\", http://www.snia.org/tech_activities/standards/ curr_standards/smi/SMI-S_Technical_Position_v1.4.0r4.zip.",
      "ja": "[SMIS] SNIA、「ストレージ管理イニシアチブ仕様（SMI-S）V1.4」、http：//www.snia.org/tech_activities/standards/ curr_standards/smi/smi-s_technical_position_v1.4.0r4.zip。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "David L. Black EMC Corporation 176 South Street Hopkinton, MA 01748",
      "ja": "David L. Black EMC Corporation 176 South Street Hopkinton、MA 01748"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (508) 293-7953\nEMail: black_david@emc.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Stephen Fridella Nasuni Inc 313 Speen St Natick MA 01760",
      "ja": "Stephen Fridella Nasuni Inc 313 Speen St Natick MA 01760"
    },
    {
      "indent": 3,
      "text": "EMail: stevef@nasuni.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jason Glasgow Google 5 Cambridge Center Cambridge, MA 02142",
      "ja": "ジェイソングラスゴーグーグル5ケンブリッジセンターケンブリッジ、マサチューセッツ州02142"
    },
    {
      "indent": 3,
      "text": "Phone: +1 (617) 575 1599\nEMail: jglasgow@aya.yale.edu",
      "raw": true,
      "ja": ""
    }
  ]
}