{
  "title": {
    "text": "RFC 5626 - Managing Client-Initiated Connections in the Session Initiation Protocol (SIP)",
    "ja": "RFC 5626 - セッション開始プロトコル（SIP）でのクライアント開始接続の管理"
  },
  "number": 5626,
  "created_at": "2023-02-25 17:17:46.627905+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                   C. Jennings, Ed.\nRequest for Comments: 5626                                 Cisco Systems\nUpdates: 3261, 3327                                         R. Mahy, Ed.\nCategory: Standards Track                                   Unaffiliated\n                                                           F. Audet, Ed.\n                                                              Skype Labs\n                                                            October 2009",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": " Managing Client-Initiated Connections in the Session Initiation Protocol (SIP)",
      "ja": "セッション開始プロトコル（SIP）でのクライアント開始接続の管理"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The Session Initiation Protocol (SIP) allows proxy servers to initiate TCP connections or to send asynchronous UDP datagrams to User Agents in order to deliver requests. However, in a large number of real deployments, many practical considerations, such as the existence of firewalls and Network Address Translators (NATs) or the use of TLS with server-provided certificates, prevent servers from connecting to User Agents in this way. This specification defines behaviors for User Agents, registrars, and proxy servers that allow requests to be delivered on existing connections established by the User Agent. It also defines keep-alive behaviors needed to keep NAT bindings open and specifies the usage of multiple connections from the User Agent to its registrar.",
      "ja": "セッション開始プロトコル（SIP）により、プロキシサーバーはTCP接続を開始したり、リクエストを配信するために非同期UDPデータグラムをユーザーエージェントに送信したりできます。ただし、多くの実際の展開では、ファイアウォールやネットワークアドレス翻訳者（NAT）の存在やサーバーが提供する証明書を使用したTLSの使用など、多くの実用的な考慮事項により、サーバーがこの方法でユーザーエージェントに接続できないようにします。この仕様は、ユーザーエージェントが確立した既存の接続でリクエストを配信できるユーザーエージェント、レジストラ、およびプロキシサーバーの動作を定義します。また、NATバインディングを開いたままにしておくために必要なキープアライブの動作を定義し、ユーザーエージェントからレジストラへの複数の接続の使用を指定します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2009 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、BSDライセンスに記載されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの寄付からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得せずに、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版またはそれを英語以外の言語に翻訳するため。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  4\n2.  Conventions and Terminology  . . . . . . . . . . . . . . . . .  5\n  2.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  Overview . . . . . . . . . . . . . . . . . . . . . . . . . . .  6\n  3.1.  Summary of Mechanism . . . . . . . . . . . . . . . . . . .  6\n  3.2.  Single Registrar and UA  . . . . . . . . . . . . . . . . .  7\n  3.3.  Multiple Connections from a User Agent . . . . . . . . . .  8\n  3.4.  Edge Proxies . . . . . . . . . . . . . . . . . . . . . . . 10\n  3.5.  Keep-Alive Technique . . . . . . . . . . . . . . . . . . . 11\n    3.5.1.  CRLF Keep-Alive Technique  . . . . . . . . . . . . . . 12\n    3.5.2.  STUN Keep-Alive Technique  . . . . . . . . . . . . . . 12\n4.  User Agent Procedures  . . . . . . . . . . . . . . . . . . . . 13\n  4.1.  Instance ID Creation . . . . . . . . . . . . . . . . . . . 13\n  4.2.  Registrations  . . . . . . . . . . . . . . . . . . . . . . 14\n    4.2.1.  Initial Registrations  . . . . . . . . . . . . . . . . 14\n    4.2.2.  Subsequent REGISTER Requests . . . . . . . . . . . . . 16\n    4.2.3.  Third-Party Registrations  . . . . . . . . . . . . . . 17\n  4.3.  Sending Non-REGISTER Requests  . . . . . . . . . . . . . . 17\n  4.4.  Keep-Alives and Detecting Flow Failure . . . . . . . . . . 18\n    4.4.1.  Keep-Alive with CRLF . . . . . . . . . . . . . . . . . 19\n    4.4.2.  Keep-Alive with STUN . . . . . . . . . . . . . . . . . 21\n  4.5.  Flow Recovery  . . . . . . . . . . . . . . . . . . . . . . 21\n5.  Edge Proxy Procedures  . . . . . . . . . . . . . . . . . . . . 22\n  5.1.  Processing Register Requests . . . . . . . . . . . . . . . 22\n  5.2.  Generating Flow Tokens . . . . . . . . . . . . . . . . . . 23\n  5.3.  Forwarding Non-REGISTER Requests . . . . . . . . . . . . . 23\n    5.3.1.  Processing Incoming Requests . . . . . . . . . . . . . 24\n    5.3.2.  Processing Outgoing Requests . . . . . . . . . . . . . 24\n  5.4.  Edge Proxy Keep-Alive Handling . . . . . . . . . . . . . . 25\n6.  Registrar Procedures . . . . . . . . . . . . . . . . . . . . . 25\n7.  Authoritative Proxy Procedures: Forwarding Requests  . . . . . 27\n   8.  STUN Keep-Alive Processing . . . . . . . . . . . . . . . . . . 28\n  8.1.  Use with SigComp . . . . . . . . . . . . . . . . . . . . . 29\n9.  Example Message Flow . . . . . . . . . . . . . . . . . . . . . 30\n  9.1.  Subscription to Configuration Package  . . . . . . . . . . 30\n  9.2.  Registration . . . . . . . . . . . . . . . . . . . . . . . 32\n  9.3.  Incoming Call and Proxy Crash  . . . . . . . . . . . . . . 34\n  9.4.  Re-Registration  . . . . . . . . . . . . . . . . . . . . . 37\n  9.5.  Outgoing Call  . . . . . . . . . . . . . . . . . . . . . . 38\n10. Grammar  . . . . . . . . . . . . . . . . . . . . . . . . . . . 40\n11. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 40\n  11.1. Flow-Timer Header Field  . . . . . . . . . . . . . . . . . 40\n  11.2. \"reg-id\" Contact Header Field Parameter  . . . . . . . . . 40\n  11.3. SIP/SIPS URI Parameters  . . . . . . . . . . . . . . . . . 41\n  11.4. SIP Option Tag . . . . . . . . . . . . . . . . . . . . . . 41\n  11.5. 430 (Flow Failed) Response Code  . . . . . . . . . . . . . 41\n  11.6. 439 (First Hop Lacks Outbound Support) Response Code . . . 42\n  11.7. Media Feature Tag  . . . . . . . . . . . . . . . . . . . . 42\n12. Security Considerations  . . . . . . . . . . . . . . . . . . . 43\n13. Operational Notes on Transports  . . . . . . . . . . . . . . . 44\n14. Requirements . . . . . . . . . . . . . . . . . . . . . . . . . 44\n15. Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 45\n16. References . . . . . . . . . . . . . . . . . . . . . . . . . . 45\n  16.1. Normative References . . . . . . . . . . . . . . . . . . . 45\n  16.2. Informative References . . . . . . . . . . . . . . . . . . 47\nAppendix A.  Default Flow Registration Backoff Times . . . . . . . 49\nAppendix B.  ABNF  . . . . . . . . . . . . . . . . . . . . . . . . 49",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There are many environments for SIP [RFC3261] deployments in which the User Agent (UA) can form a connection to a registrar or proxy but in which connections in the reverse direction to the UA are not possible. This can happen for several reasons, but the most likely is a NAT or a firewall in between the SIP UA and the proxy. Many such devices will only allow outgoing connections. This specification allows a SIP User Agent behind such a firewall or NAT to receive inbound traffic associated with registrations or dialogs that it initiates.",
      "ja": "ユーザーエージェント（UA）がレジストラまたはプロキシへの接続を形成できるが、UAへの逆方向の接続が不可能なSIP [RFC3261]展開には多くの環境があります。これはいくつかの理由で発生する可能性がありますが、最も可能性が最も高いのは、SIP UAとプロキシの間のNATまたはファイアウォールです。そのようなデバイスの多くは、発信接続のみを許可します。この仕様により、このようなファイアウォールまたはNATの背後にあるSIPユーザーエージェントは、開始する登録またはダイアログに関連付けられたインバウンドトラフィックを受信できます。"
    },
    {
      "indent": 3,
      "text": "Most IP phones and personal computers get their network configurations dynamically via a protocol such as the Dynamic Host Configuration Protocol (DHCP) [RFC2131]. These systems typically do not have a useful name in the Domain Name System (DNS) [RFC1035], and they almost never have a long-term, stable DNS name that is appropriate for use in the subjectAltName of a certificate, as required by [RFC3261]. However, these systems can still act as a Transport Layer Security (TLS) [RFC5246] client and form outbound connections to a proxy or registrar that authenticates with a server certificate. The server can authenticate the UA using a shared secret in a digest challenge (as defined in Section 22 of RFC 3261) over that TLS connection. This specification allows a SIP User Agent who has to initiate the TLS connection to receive inbound traffic associated with registrations or dialogs that it initiates.",
      "ja": "ほとんどのIP電話とパーソナルコンピューターは、動的ホスト構成プロトコル（DHCP）[RFC2131]などのプロトコルを介して動的にネットワーク構成を取得します。これらのシステムは通常、ドメイン名システム（DNS）[RFC1035]に有用な名前を持っていません。RFC3261]。ただし、これらのシステムは、トランスポートレイヤーセキュリティ（TLS）[RFC5246]クライアントとして機能し、サーバー証明書で認証するプロキシまたはレジストラへのアウトバウンド接続を形成できます。サーバーは、そのTLS接続を介して、ダイジェストチャレンジ（RFC 3261のセクション22で定義されているように）で共有秘密を使用してUAを認証できます。この仕様により、TLS接続を開始して、開始する登録またはダイアログに関連付けられたインバウンドトラフィックを受信する必要があるSIPユーザーエージェントが可能になります。"
    },
    {
      "indent": 3,
      "text": "The key idea of this specification is that when a UA sends a REGISTER request or a dialog-forming request, the proxy can later use this same network \"flow\" -- whether this is a bidirectional stream of UDP datagrams, a TCP connection, or an analogous concept in another transport protocol -- to forward any incoming requests that need to go to this UA in the context of the registration or dialog.",
      "ja": "この仕様の重要なアイデアは、UAがレジスタリクエストまたはダイアログ形成リクエストを送信する場合、プロキシは後で同じネットワーク「フロー」を使用できることです。別のトランスポートプロトコルの類似の概念 - 登録またはダイアログのコンテキストでこのUAに移動する必要がある着信要求を転送します。"
    },
    {
      "indent": 3,
      "text": "For a UA to receive incoming requests, the UA has to connect to a server. Since the server can't connect to the UA, the UA has to make sure that a flow is always active. This requires the UA to detect when a flow fails. Since such detection takes time and leaves a window of opportunity for missed incoming requests, this mechanism allows the UA to register over multiple flows at the same time. This specification also defines two keep-alive schemes. The keep-alive mechanism is used to keep NAT bindings fresh, and to allow the UA to detect when a flow has failed.",
      "ja": "UAが着信リクエストを受信するには、UAがサーバーに接続する必要があります。サーバーはUAに接続できないため、UAはフローが常にアクティブであることを確認する必要があります。これには、UAがフローが故障したときに検出する必要があります。このような検出には時間がかかり、着信要求を逃した機会の窓が残るため、このメカニズムにより、UAは複数のフローに同時に登録できます。この仕様では、2つのキープアライブスキームも定義します。キープアライブメカニズムは、NATバインディングを新鮮に保ち、UAがフローが故障したときに検出できるようにするために使用されます。"
    },
    {
      "indent": 0,
      "text": "2. Conventions and Terminology",
      "section_title": true,
      "ja": "2. 慣習と用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions",
      "section_title": true,
      "ja": "2.1. 定義"
    },
    {
      "indent": 3,
      "text": "Authoritative Proxy: A proxy that handles non-REGISTER requests for a specific Address-of-Record (AOR), performs the logical Location Server lookup described in [RFC3261], and forwards those requests to specific Contact URIs. (In [RFC3261], the role that is authoritative for REGISTER requests for a specific AOR is a Registration Server.)",
      "ja": "権威あるプロキシ：特定の録音アドレス（AOR）の非登録要求を処理し、[RFC3261]で説明されている論理ロケーションサーバーの検索を実行し、それらの要求を特定の連絡先URIに転送するプロキシ。（[RFC3261]では、特定のAORの登録要求に対して権威ある役割は登録サーバーです。）"
    },
    {
      "indent": 3,
      "text": "Edge Proxy: An edge proxy is any proxy that is located topologically between the registering User Agent and the Authoritative Proxy. The \"first\" edge proxy refers to the first edge proxy encountered when a UA sends a request.",
      "ja": "Edge Proxy：Edgeプロキシは、登録ユーザーエージェントと権威あるプロキシの間にトポロジカルに位置するプロキシです。「最初の」エッジプロキシは、UAがリクエストを送信したときに遭遇する第一エッジプロキシを指します。"
    },
    {
      "indent": 3,
      "text": "Flow: A Flow is a transport-layer association between two hosts that is represented by the network address and port number of both ends and by the transport protocol. For TCP, a flow is equivalent to a TCP connection. For UDP a flow is a bidirectional stream of datagrams between a single pair of IP addresses and ports of both peers. With TCP, a flow often has a one-to-one correspondence with a single file descriptor in the operating system.",
      "ja": "フロー：フローは、ネットワークアドレスと両端のポート番号と輸送プロトコルによって表される2つのホスト間の輸送層関連です。TCPの場合、フローはTCP接続と同等です。UDPの場合、フローは、両方のピアの1つのIPアドレスとポートの間のデータグラムの双方向ストリームです。TCPを使用すると、フローは多くの場合、オペレーティングシステムに単一のファイル記述子を使用して1対1の対応をします。"
    },
    {
      "indent": 3,
      "text": "Flow Token: An identifier that uniquely identifies a flow which can be included in a SIP URI (Uniform Resource Identifier [RFC3986]).",
      "ja": "フロートークン：SIP URI（均一なリソース識別子[RFC3986]）に含めることができるフローを一意に識別する識別子。"
    },
    {
      "indent": 3,
      "text": "reg-id: This refers to the value of a new header field parameter value for the Contact header field. When a UA registers multiple times, each for a different flow, each concurrent registration gets a unique reg-id value.",
      "ja": "reg-id：これは、コンタクトヘッダーフィールドの新しいヘッダーフィールドパラメーター値の値を指します。UAが複数回登録すると、それぞれ異なるフローに対して、各登録は一意のreg-ID値を取得します。"
    },
    {
      "indent": 3,
      "text": "instance-id: This specification uses the word instance-id to refer to the value of the \"sip.instance\" media feature tag which appears as a \"+sip.instance\" Contact header field parameter. This is a Uniform Resource Name (URN) that uniquely identifies this specific UA instance.",
      "ja": "Instance-ID：この仕様では、単語Instance-IDを使用して、「sip.instance」コンタクトヘッダーフィールドパラメーターとして表示される「sip.instance」メディア機能タグの値を参照します。これは、この特定のUAインスタンスを一意に識別する均一なリソース名（URN）です。"
    },
    {
      "indent": 3,
      "text": "\"ob\" Parameter: The \"ob\" parameter is a SIP URI parameter that has a different meaning depending on context. In a Path header field value, it is used by the first edge proxy to indicate that a flow token was added to the URI. In a Contact or Route header field value, it indicates that the UA would like other requests in the same dialog to be routed over the same flow.",
      "ja": "「OB」パラメーター：「OB」パラメーターは、コンテキストに応じて異なる意味を持つSIP URIパラメーターです。パスヘッダーフィールド値では、最初のエッジプロキシによって使用されて、フロートークンがURIに追加されたことを示します。連絡先またはルートヘッダーのフィールド値では、UAが同じフロー上で同じダイアログ内の他のリクエストをルーティングすることを望んでいることを示しています。"
    },
    {
      "indent": 3,
      "text": "outbound-proxy-set: A set of SIP URIs (Uniform Resource Identifiers) that represents each of the outbound proxies (often edge proxies) with which the UA will attempt to maintain a direct flow. The first URI in the set is often referred to as the primary outbound proxy and the second as the secondary outbound proxy. There is no difference between any of the URIs in this set, nor does the primary/secondary terminology imply that one is preferred over the other.",
      "ja": "Autbound-Proxy-Set：UAが直接流れを維持しようとするアウトバウンドプロキシ（しばしばエッジプロキシ）を表すSIP URI（均一なリソース識別子）のセット。セットの最初のURIは、多くの場合、プライマリアウトバウンドプロキシと呼ばれ、2番目のURIはセカンダリアウトバウンドプロキシと呼ばれます。このセットのurisのいずれかに違いはありません。また、一次/二次用語は、一方が他方よりも優先されることを暗示していません。"
    },
    {
      "indent": 0,
      "text": "3. Overview",
      "section_title": true,
      "ja": "3. 概要"
    },
    {
      "indent": 3,
      "text": "The mechanisms defined in this document are useful in several scenarios discussed below, including the simple co-located registrar and proxy, a User Agent desiring multiple connections to a resource (for redundancy, for example), and a system that uses edge proxies.",
      "ja": "このドキュメントで定義されているメカニズムは、以下で説明するいくつかのシナリオで役立ちます。これには、単純な共同配置レジストラとプロキシ、リソースへの複数の接続（冗長性など）を必要とするユーザーエージェント、エッジプロキシを使用するシステムが含まれます。"
    },
    {
      "indent": 3,
      "text": "This entire section is non-normative.",
      "ja": "このセクション全体は非規範的です。"
    },
    {
      "indent": 0,
      "text": "3.1. Summary of Mechanism",
      "section_title": true,
      "ja": "3.1. メカニズムの概要"
    },
    {
      "indent": 3,
      "text": "Each UA has a unique instance-id that stays the same for this UA even if the UA reboots or is power cycled. Each UA can register multiple times over different flows for the same SIP Address of Record (AOR) to achieve high reliability. Each registration includes the instance-id for the UA and a reg-id label that is different for each flow. The registrar can use the instance-id to recognize that two different registrations both correspond to the same UA. The registrar can use the reg-id label to recognize whether a UA is creating a new flow or refreshing or replacing an old one, possibly after a reboot or a network failure.",
      "ja": "各UAには、UAの再起動または電源サイクルであっても、このUAについては同じままであるユニークなInstance-IDがあります。各UAは、同じ信頼性を実現するために、同じSIPアドレス（AOR）の異なるフローに複数回登録できます。各登録には、UA用のInstance-IDと、各フローで異なるreg-IDラベルが含まれます。レジストラは、Instance-IDを使用して、2つの異なる登録が両方とも同じUAに対応することを認識できます。レジストラは、Reg-IDラベルを使用して、UAが新しいフローを作成しているのか、リフレッシュしているのか、それとも再起動した後、ネットワーク障害の後に古いフローをリフレッシュしているのか、それとも交換しているのかを認識できます。"
    },
    {
      "indent": 3,
      "text": "When a proxy goes to route a message to a UA for which it has a binding, it can use any one of the flows on which a successful registration has been completed. A failure to deliver a request on a particular flow can be tried again on an alternate flow. Proxies can determine which flows go to the same UA by comparing the instance-id. Proxies can tell that a flow replaces a previously abandoned flow by looking at the reg-id.",
      "ja": "プロキシが拘束力のあるUAにメッセージをルーティングすると、登録が完了したフローのいずれかを使用できます。特定のフローでリクエストを配信できない場合、代替フローで再試行できます。プロキシは、Instance-IDを比較することにより、同じフローを同じUAに送信するかを決定できます。プロキシは、reg-idを見ることで、フローが以前に放棄されたフローに取って代わることを知ることができます。"
    },
    {
      "indent": 3,
      "text": "When sending a dialog-forming request, a UA can also ask its first edge proxy to route subsequent requests in that dialog over the same flow. This is necessary whether the UA has registered or not.",
      "ja": "ダイアログ形成リクエストを送信するとき、UAは、その最初のエッジプロキシに、同じフローの上でそのダイアログ内の後続のリクエストをルーティングするように依頼することもできます。これは、UAが登録しているかどうかにかかわらず必要です。"
    },
    {
      "indent": 3,
      "text": "UAs use a simple periodic message as a keep-alive mechanism to keep their flow to the proxy or registrar alive. For connection-oriented transports such as TCP this is based on carriage-return and line-feed sequences (CRLF), while for transports that are not connection oriented, this is accomplished by using a SIP-specific usage profile of STUN (Session Traversal Utilities for NAT) [RFC5389].",
      "ja": "UASは、プロキシまたはレジストラへの流れを生かし続けるために、キープアライブメカニズムとして単純な周期メッセージを使用します。TCPなどの接続指向のトランスポートは、キャリッジリターンとラインフィードシーケンス（CRLF）に基づいていますが、接続指向のないトランスポートの場合、STUNのSIP固有の使用プロファイルを使用して達成されます（セッショントラバーサルユーティリティNATの場合）[RFC5389]。"
    },
    {
      "indent": 0,
      "text": "3.2. Single Registrar and UA",
      "section_title": true,
      "ja": "3.2. 単一のレジストラとUA"
    },
    {
      "indent": 3,
      "text": "In the topology shown below, a single server is acting as both a registrar and proxy.",
      "ja": "以下に示すトポロジでは、単一のサーバーがレジストラとプロキシの両方として機能しています。"
    },
    {
      "indent": 6,
      "text": "+-----------+\n| Registrar |\n| Proxy     |\n+-----+-----+\n      |\n      |\n +----+--+\n | User  |\n | Agent |\n +-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "User Agents that form only a single flow continue to register normally but include the instance-id as described in Section 4.1. The UA also includes a \"reg-id\" Contact header field parameter that is used to allow the registrar to detect and avoid keeping invalid contacts when a UA reboots or reconnects after its old connection has failed for some reason.",
      "ja": "単一のフローのみを形成するユーザーエージェントは、正常に登録し続けますが、セクション4.1で説明されているようにインスタンスIDを含めます。UAには、レジストラが何らかの理由で古い接続が失敗した後にUAの再起動または再接続を再起動または再接続するときに、レジストラが無効な連絡先を検出および避けるために使用される「reg-id」連絡先ヘッダーフィールドパラメーターも含まれています。"
    },
    {
      "indent": 3,
      "text": "For clarity, here is an example. Bob's UA creates a new TCP flow to the registrar and sends the following REGISTER request.",
      "ja": "明確にするために、ここに例があります。ボブのUAは、レジストラへの新しいTCPフローを作成し、次のレジスタリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bK-bad0ce-11-1036\nMax-Forwards: 70\nFrom: Bob <sip:bob@example.com>;tag=d879h76\nTo: Bob <sip:bob@example.com>\nCall-ID: 8921348ju72je840.204\nCSeq: 1 REGISTER\nSupported: path, outbound\nContact: <sip:line1@192.0.2.2;transport=tcp>; reg-id=1;\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-000A95A0E128>\"\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The registrar challenges this registration to authenticate Bob. When the registrar adds an entry for this contact under the AOR for Bob, the registrar also keeps track of the connection over which it received this registration.",
      "ja": "レジストラは、ボブを認証するためにこの登録に挑戦します。レジストラがボブのAORの下でこの連絡先のエントリを追加すると、レジストラはこの登録を受け取った接続を追跡します。"
    },
    {
      "indent": 3,
      "text": "The registrar saves the instance-id (\"urn:uuid:00000000-0000-1000-8000-000A95A0E128\") and reg-id (\"1\") along with the rest of the Contact header field. If the instance-id and reg-id are the same as a previous registration for the same AOR, the registrar replaces the old Contact URI and flow information. This allows a UA that has rebooted to replace its previous registration for each flow with minimal impact on overall system load.",
      "ja": "レジストラは、Instance-ID（ \"urn：uuid：00000000-0000-0000-1000-8000-000A95A0E128\"）とreg-id（ \"1\"）を残りのコンタクトヘッダーフィールドとともに保存します。Instance-IDとreg-IDが同じAORの以前の登録と同じである場合、レジストラは古い連絡先URIとフロー情報を置き換えます。これにより、各フローの以前の登録を再起動したUAが、システム全体の負荷への影響を最小限に抑えることができます。"
    },
    {
      "indent": 3,
      "text": "When Alice sends a request to Bob, his authoritative proxy selects the target set. The proxy forwards the request to elements in the target set based on the proxy's policy. The proxy looks at the target set and uses the instance-id to understand if two targets both end up routing to the same UA. When the proxy goes to forward a request to a given target, it looks and finds the flows over which it received the registration. The proxy then forwards the request over an existing flow, instead of resolving the Contact URI using the procedures in [RFC3263] and trying to form a new flow to that contact.",
      "ja": "アリスがボブにリクエストを送信すると、彼の権威あるプロキシがターゲットセットを選択します。プロキシは、プロキシのポリシーに基づいて、ターゲットセットの要素にリクエストを転送します。プロキシはターゲットセットを調べ、Instance-IDを使用して、2つのターゲットが両方とも同じUAにルーティングするかどうかを理解します。プロキシが特定のターゲットにリクエストを転送すると、登録を受け取ったフローを見て見つけます。次に、プロキシは、[RFC3263]の手順を使用して接触URIを解決し、その接点に新しいフローを形成しようとする代わりに、既存のフローよりもリクエストを転送します。"
    },
    {
      "indent": 3,
      "text": "As described in the next section, if the proxy has multiple flows that all go to this UA, the proxy can choose any one of the registration bindings for this AOR that has the same instance-id as the selected UA.",
      "ja": "次のセクションで説明したように、プロキシにすべてがこのUAに送られる複数のフローがある場合、プロキシは、選択したUAと同じインスタンスIDを持つこのAORの登録バインディングのいずれかを選択できます。"
    },
    {
      "indent": 0,
      "text": "3.3. Multiple Connections from a User Agent",
      "section_title": true,
      "ja": "3.3. ユーザーエージェントからの複数の接続"
    },
    {
      "indent": 3,
      "text": "There are various ways to deploy SIP to build a reliable and scalable system. This section discusses one such design that is possible with the mechanisms in this specification. Other designs are also possible.",
      "ja": "信頼できるスケーラブルなシステムを構築するためにSIPを展開するさまざまな方法があります。このセクションでは、この仕様のメカニズムで可能なそのような設計について説明します。他のデザインも可能です。"
    },
    {
      "indent": 3,
      "text": "In the example system below, the logical outbound proxy/registrar for the domain is running on two hosts that share the appropriate state and can both provide registrar and outbound proxy functionality for the domain. The UA will form connections to two of the physical hosts that can perform the authoritative proxy/registrar function for the domain. Reliability is achieved by having the UA form two TCP connections to the domain.",
      "ja": "以下のシステムでは、ドメインの論理アウトバウンドプロキシ/レジストラが2つのホストで実行されており、適切な状態を共有し、ドメインにレジストラとアウトバウンドのプロキシ機能を提供できます。UAは、ドメインの権威あるプロキシ/レジストラ関数を実行できる2つの物理ホストへの接続を形成します。信頼性は、UAをドメインに2つのTCP接続を形成することにより達成されます。"
    },
    {
      "indent": 7,
      "text": "+-------------------+\n| Domain            |\n| Logical Proxy/Reg |\n|                   |\n|+-----+     +-----+|\n||Host1|     |Host2||\n|+-----+     +-----+|\n+---\\------------/--+\n     \\          /\n      \\        /\n       \\      /\n        \\    /\n       +------+\n       | User |\n       | Agent|\n       +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The UA is configured with multiple outbound proxy registration URIs. These URIs are configured into the UA through whatever the normal mechanism is to configure the proxy address and AOR in the UA. If the AOR is alice@example.com, the outbound-proxy-set might look something like \"sip:primary.example.com\" and \"sip: secondary.example.com\". Note that each URI in the outbound-proxy-set could resolve to several different physical hosts. The administrative domain that created these URIs should ensure that the two URIs resolve to separate hosts. These URIs are handled according to normal SIP processing rules, so mechanisms like DNS SRV [RFC2782] can be used to do load-balancing across a proxy farm. The approach in this document does not prevent future extensions, such as the SIP UA configuration framework [CONFIG-FMWK], from adding other ways for a User Agent to discover its outbound-proxy-set.",
      "ja": "UAは、複数のアウトバウンドプロキシ登録URIで構成されています。これらのURIは、UAのプロキシアドレスとAORを構成するための通常のメカニズムが何であれ、UAに構成されます。AORがalice@example.comの場合、Outbound-Proxy-Setは「sip：primary.example.com」および「sip：Secondary.example.com」のようなものに見えるかもしれません。アウトバウンドプロキシセットの各URIは、いくつかの異なる物理ホストに解決できることに注意してください。これらのURIを作成した管理ドメインは、2つのURIがホストを分離するように解決することを保証する必要があります。これらのURIは通常のSIP処理ルールに従って処理されるため、DNS SRV [RFC2782]などのメカニズムを使用して、プロキシファーム全体で負荷分散を行うことができます。このドキュメントのアプローチは、SIP UA構成フレームワーク[Config-FMWK]など、将来の拡張機能を防ぐことはできません。"
    },
    {
      "indent": 3,
      "text": "The domain also needs to ensure that a request for the UA sent to Host1 or Host2 is then sent across the appropriate flow to the UA. The domain might choose to use the Path header approach (as described in the next section) to store this internal routing information on Host1 or Host2.",
      "ja": "また、ドメインは、host1またはhost2に送信されたUAのリクエストが、適切なフローを越えてUAへのフローを越えて送信されることを確認する必要があります。ドメインは、Path Headerアプローチ（次のセクションで説明されているように）を使用して、この内部ルーティング情報をHost1またはHost2に保存することを選択できます。"
    },
    {
      "indent": 3,
      "text": "When a single server fails, all the UAs that have a flow through it will detect a flow failure and try to reconnect. This can cause large loads on the server. When large numbers of hosts reconnect nearly simultaneously, this is referred to as the avalanche restart problem, and is further discussed in Section 4.5. The multiple flows to many servers help reduce the load caused by the avalanche restart. If a UA has multiple flows, and one of the servers fails, the UA delays a recommended amount of time before trying to form a new connection to replace the flow to the server that failed. By spreading out the time used for all the UAs to reconnect to a server, the load on the server farm is reduced.",
      "ja": "単一のサーバーが失敗すると、フローを通過するすべてのUAがフロー障害を検出し、再接続しようとします。これにより、サーバーに大きな負荷が発生する可能性があります。多数のホストがほぼ同時に再接続すると、これは雪崩の再起動問題と呼ばれ、セクション4.5でさらに説明します。多くのサーバーへの複数のフローは、雪崩の再起動によって引き起こされる負荷を減らすのに役立ちます。UAに複数のフローがあり、サーバーの1つが失敗した場合、UAは故障したサーバーにフローを置き換えるために新しい接続を形成しようとする前に、推奨される時間を遅らせます。すべてのUASがサーバーに再接続するために使用される時間を広げることにより、サーバーファームの負荷が削減されます。"
    },
    {
      "indent": 3,
      "text": "Scalability is achieved by using DNS SRV [RFC2782] to load-balance the primary connection across a set of machines that can service the primary connection, and also using DNS SRV to load-balance across a separate set of machines that can service the secondary connection. The deployment here requires that DNS is configured with one entry that resolves to all the primary hosts and another entry that resolves to all the secondary hosts. While this introduces additional DNS configuration, the approach works and requires no additional SIP extensions to [RFC3263].",
      "ja": "Scalabilityは、DNS SRV [RFC2782]を使用して、プライマリ接続にサービスを提供できるマシンのセットにわたってプライマリ接続をロードバランスし、DNS SRVを使用して、セカンダリ接続にサービスを提供できる個別のマシンに負荷バランスを実行することによって達成されます。。ここでの展開では、DNSがすべてのプライマリホストに解決する1つのエントリとすべてのセカンダリホストに解決する別のエントリで構成される必要があります。これにより追加のDNS構成が導入されますが、アプローチは機能し、[RFC3263]に追加のSIP拡張機能を必要としません。"
    },
    {
      "indent": 3,
      "text": "Another motivation for maintaining multiple flows between the UA and its registrar is related to multihomed UAs. Such UAs can benefit from multiple connections from different interfaces to protect against the failure of an individual access link.",
      "ja": "UAとそのレジストラの間に複数のフローを維持するもう1つの動機は、マルチホームUAに関連しています。このようなUAは、個々のアクセスリンクの障害から保護するために、異なるインターフェイスからの複数の接続から恩恵を受けることができます。"
    },
    {
      "indent": 0,
      "text": "3.4. Edge Proxies",
      "section_title": true,
      "ja": "3.4. エッジプロキシ"
    },
    {
      "indent": 3,
      "text": "Some SIP deployments use edge proxies such that the UA sends the REGISTER to an edge proxy that then forwards the REGISTER to the registrar. There could be a NAT or firewall between the UA and the edge proxy.",
      "ja": "一部のSIP展開は、UAがレジスタをエッジプロキシに送信してレジスタをレジストラに転送するようにエッジプロキシを使用します。UAとEdgeプロキシの間にNATまたはファイアウォールがある可能性があります。"
    },
    {
      "indent": 8,
      "text": "        +---------+\n        |Registrar|\n        |Proxy    |\n        +---------+\n         /      \\\n        /        \\\n       /          \\\n    +-----+     +-----+\n    |Edge1|     |Edge2|\n    +-----+     +-----+\n       \\           /\n        \\         /\n----------------------------NAT/FW\n          \\     /\n           \\   /\n          +------+\n          |User  |\n          |Agent |\n          +------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The edge proxy includes a Path header [RFC3327] so that when the proxy/registrar later forwards a request to this UA, the request is routed through the edge proxy.",
      "ja": "Edgeプロキシにはパスヘッダー[RFC3327]が含まれているため、プロキシ/レジストラが後でこのUAにリクエストを転送すると、リクエストはエッジプロキシを介してルーティングされます。"
    },
    {
      "indent": 3,
      "text": "These systems can use effectively the same mechanism as described in the previous sections but need to use the Path header. When the edge proxy receives a registration, it needs to create an identifier value that is unique to this flow (and not a subsequent flow with the same addresses) and put this identifier in the Path header URI. This identifier has two purposes. First, it allows the edge proxy to map future requests back to the correct flow. Second, because the identifier will only be returned if the user authenticates with the registrar successfully, it allows the edge proxy to indirectly check the user's authentication information via the registrar. The identifier is placed in the user portion of a loose route in the Path header. If the registration succeeds, the edge proxy needs to map future requests (that are routed to the identifier value from the Path header) to the associated flow.",
      "ja": "これらのシステムは、前のセクションで説明したものと同じメカニズムを効果的に使用できますが、パスヘッダーを使用する必要があります。Edgeプロキシが登録を受信する場合、このフローに固有の識別子値を作成する必要があります（同じアドレスを持つ後続のフローではなく）。この識別子には2つの目的があります。まず、Edgeプロキシが将来のリクエストを正しいフローにマッピングできるようにします。第二に、識別子はレジストラで正常に認証された場合にのみ識別子が返されるため、エッジプロキシはレジストラを介してユーザーの認証情報を間接的に確認できます。識別子は、パスヘッダーのルーズルートのユーザー部分に配置されます。登録が成功した場合、Edgeプロキシは、将来の要求（パスヘッダーから識別子値にルーティングされる）を関連するフローにマッピングする必要があります。"
    },
    {
      "indent": 3,
      "text": "The term edge proxy is often used to refer to deployments where the edge proxy is in the same administrative domain as the registrar. However, in this specification we use the term to refer to any proxy between the UA and the registrar. For example, the edge proxy may be inside an enterprise that requires its use, and the registrar could be from a service provider with no relationship to the enterprise. Regardless of whether they are in the same administrative domain, this specification requires that registrars and edge proxies support the Path header mechanism in [RFC3327].",
      "ja": "Edgeプロキシという用語は、Edgeプロキシがレジストラと同じ管理ドメインにある展開を参照するためによく使用されます。ただし、この仕様では、この用語を使用して、UAとレジストラの間のプロキシを参照します。たとえば、Edgeプロキシはその使用を必要とする企業内にある場合があり、レジストラは企業と関係のないサービスプロバイダーからのものである可能性があります。それらが同じ管理ドメインにあるかどうかに関係なく、この仕様では、レジストラとエッジプロキシが[RFC3327]のパスヘッダーメカニズムをサポートする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.5. Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5. 維持する技術"
    },
    {
      "indent": 3,
      "text": "This document describes two keep-alive mechanisms: a CRLF keep-alive and a STUN keep-alive. Each of these mechanisms uses a client-to-server \"ping\" keep-alive and a corresponding server-to-client \"pong\" message. This ping-pong sequence allows the client, and optionally the server, to tell if its flow is still active and useful for SIP traffic. The server responds to pings by sending pongs. If the client does not receive a pong in response to its ping (allowing for retransmission for STUN as described in Section 4.4.2), it declares the flow dead and opens a new flow in its place.",
      "ja": "このドキュメントでは、2つのキープアライブメカニズムについて説明します。CRLFキープアライブとスタンキープアライブです。これらの各メカニズムは、クライアントからサーバーへの「ping」キープアライブと対応するサーバーからクライアントの「ポン」メッセージを使用します。このPing-Pongシーケンスにより、クライアント、およびオプションでサーバーが、そのフローがまだアクティブであり、SIPトラフィックに役立つかどうかを判断できます。サーバーは、ポンを送信することでpingに応答します。クライアントがそのpingに応じてポンを受け取らない場合（セクション4.4.2で説明されているように、スタンの再送信を可能にします）、流れが死んだと宣言し、その場所に新しい流れが開きます。"
    },
    {
      "indent": 3,
      "text": "This document also suggests timer values for these client keep-alive mechanisms. These timer values were chosen to keep most NAT and firewall bindings open, to detect unresponsive servers within 2 minutes, and to mitigate against the avalanche restart problem. However, the client may choose different timer values to suit its needs, for example to optimize battery life. In some environments, the server can also keep track of the time since a ping was received over a flow to guess the likelihood that the flow is still useful for delivering SIP messages.",
      "ja": "このドキュメントは、これらのクライアントのキープアライブメカニズムのタイマー値も示唆しています。これらのタイマー値は、ほとんどのNATとファイアウォールのバインディングを開いたままにし、2分以内に反応しないサーバーを検出し、雪崩の再起動問題に対して緩和するために選択されました。ただし、クライアントは、バッテリー寿命を最適化するために、ニーズに合わせて異なるタイマー値を選択する場合があります。一部の環境では、サーバーは、流れがSIPメッセージを配信するのに役立つ可能性を推測するために、Pingがフローで受信されたため、時間を追跡することもできます。"
    },
    {
      "indent": 3,
      "text": "When the UA detects that a flow has failed or that the flow definition has changed, the UA needs to re-register and will use the back-off mechanism described in Section 4.5 to provide congestion relief when a large number of agents simultaneously reboot.",
      "ja": "UAがフローが故障したこと、またはフロー定義が変更されたことを検出すると、UAは再登録する必要があり、セクション4.5で説明されているバックオフメカニズムを使用して、多数のエージェントが同時に再起動したときに混雑の軽減を提供します。"
    },
    {
      "indent": 3,
      "text": "A keep-alive mechanism needs to keep NAT bindings refreshed; for connections, it also needs to detect failure of a connection; and for connectionless transports, it needs to detect flow failures including changes to the NAT public mapping. For connection-oriented transports such as TCP [RFC0793] and SCTP [RFC4960], this specification describes a keep-alive approach based on sending CRLFs. For connectionless transport, such as UDP [RFC0768], this specification describes using STUN [RFC5389] over the same flow as the SIP traffic to perform the keep-alive.",
      "ja": "ナットバインディングをリフレッシュするために、キープアライブメカニズムが必要です。接続の場合、接続の障害を検出する必要があります。また、Connectionless Transportsの場合、NATパブリックマッピングの変更など、フロー障害を検出する必要があります。TCP [RFC0793]やSCTP [RFC4960]などの接続指向のトランスポートの場合、この仕様では、CRLFSの送信に基づく維持アプローチについて説明しています。UDP [RFC0768]などのコネクションレストランスポートの場合、この仕様では、SIPトラフィックと同じフローでStun [RFC5389]を使用してKeep-Aliveを実行することを説明しています。"
    },
    {
      "indent": 3,
      "text": "UAs and Proxies are also free to use native transport keep-alives; however, the application may not be able to set these timers on a per-connection basis, and the server certainly cannot make any assumption about what values are used. Use of native transport keep-alives is outside the scope of this document.",
      "ja": "UASとプロキシは、ネイティブトランスポートキープアリブを自由に使用できます。ただし、アプリケーションはこれらのタイマーを接続ごとに設定できない場合があり、サーバーは確かに使用されている値について仮定することはできません。ネイティブトランスポートキープアリブの使用は、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.5.1. CRLF Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5.1. CRLFキープアライブテクニック"
    },
    {
      "indent": 3,
      "text": "This approach can only be used with connection-oriented transports such as TCP or SCTP. The client periodically sends a double-CRLF (the \"ping\") then waits to receive a single CRLF (the \"pong\"). If the client does not receive a \"pong\" within an appropriate amount of time, it considers the flow failed.",
      "ja": "このアプローチは、TCPやSCTPなどの接続指向の輸送でのみ使用できます。クライアントは定期的にダブルCRLF（「ping」）を送信し、1つのCRLF（「ポン」）を受信するのを待ちます。クライアントが適切な時間内に「ポン」を受け取らない場合、フローが失敗したと見なします。"
    },
    {
      "indent": 6,
      "text": "Note: Sending a CRLF over a connection-oriented transport is backwards compatible (because of requirements in Section 7.5 of [RFC3261]), but only implementations which support this specification will respond to a \"ping\" with a \"pong\".",
      "ja": "注：接続指向のトランスポートを介してCRLFを送信することは、後方互換性があります（[RFC3261]のセクション7.5の要件のため）が、この仕様をサポートする実装のみが「ポン」で「ping」に応答します。"
    },
    {
      "indent": 0,
      "text": "3.5.2. STUN Keep-Alive Technique",
      "section_title": true,
      "ja": "3.5.2. スタンキープアライブテクニック"
    },
    {
      "indent": 3,
      "text": "This approach can only be used for connection-less transports, such as UDP.",
      "ja": "このアプローチは、UDPなどの接続のないトランスポートにのみ使用できます。"
    },
    {
      "indent": 3,
      "text": "For connection-less transports, a flow definition could change because a NAT device in the network path reboots and the resulting public IP address or port mapping for the UA changes. To detect this, STUN requests are sent over the same flow that is being used for the SIP traffic. The proxy or registrar acts as a limited Session Traversal Utilities for NAT (STUN) [RFC5389] server on the SIP signaling port.",
      "ja": "接続のないトランスポートの場合、ネットワークパスのNATデバイスが再起動し、結果のパブリックIPアドレスまたはUA変更のポートマッピングが変更されるため、フロー定義が変更される可能性があります。これを検出するために、SIPトラフィックに使用されている同じフローの上にスタンリクエストが送信されます。プロキシまたはレジストラは、SIPシグナリングポートのNAT（STUN）[RFC5389]サーバーの限定セッショントラバーサルユーティリティとして機能します。"
    },
    {
      "indent": 6,
      "text": "Note: The STUN mechanism is very robust and allows the detection of a changed IP address and port. Many other options were considered, but the SIP Working Group selected the STUN-based approach. Approaches using SIP requests were abandoned because many believed that good performance and full backwards compatibility using this method were mutually exclusive.",
      "ja": "注：スタンメカニズムは非常に堅牢で、変更されたIPアドレスとポートの検出を可能にします。他の多くのオプションが考慮されましたが、SIPワーキンググループはスタンベースのアプローチを選択しました。SIPリクエストを使用したアプローチは、この方法を使用した優れたパフォーマンスと完全な後方互換性が相互に排他的であると多くの人が信じていたため、放棄されました。"
    },
    {
      "indent": 0,
      "text": "4. User Agent Procedures",
      "section_title": true,
      "ja": "4. ユーザーエージェント手順"
    },
    {
      "indent": 0,
      "text": "4.1. Instance ID Creation",
      "section_title": true,
      "ja": "4.1. インスタンスIDの作成"
    },
    {
      "indent": 3,
      "text": "Each UA MUST have an Instance Identifier Uniform Resource Name (URN) [RFC2141] that uniquely identifies the device. Usage of a URN provides a persistent and unique name for the UA instance. It also provides an easy way to guarantee uniqueness within the AOR. This URN MUST be persistent across power cycles of the device. The instance ID MUST NOT change as the device moves from one network to another.",
      "ja": "各UAには、デバイスを一意に識別するインスタンス識別子ユニフォームリソース名（URN）[RFC2141]が必要です。URNの使用は、UAインスタンスに永続的で一意の名前を提供します。また、AOR内の独自性を保証する簡単な方法も提供します。このurnは、デバイスの電源サイクル全体で永続的でなければなりません。インスタンスIDは、デバイスがあるネットワークから別のネットワークに移動するため、変更してはなりません。"
    },
    {
      "indent": 3,
      "text": "A UA SHOULD create a Universally Unique Identifier (UUID) URN [RFC4122] as its instance-id. The UUID URN allows for non-centralized computation of a URN based on time, unique names (such as a MAC address), or a random number generator.",
      "ja": "UAは、そのインスタンスIDとして、普遍的に一意の識別子（UUID）urn [rfc4122]を作成する必要があります。UUID URNは、時間、一意の名前（MACアドレスなど）、または乱数ジェネレーターに基づいて、URNの非中央集団化された計算を許可します。"
    },
    {
      "indent": 6,
      "text": "Note: A device like a \"soft phone\", when first installed, can generate a UUID [RFC4122] and then save this in persistent storage for all future use. For a device such as a \"hard phone\", which will only ever have a single SIP UA present, the UUID can include the MAC address and be generated at any time because it is guaranteed that no other UUID is being generated at the same time on that physical device. This means the value of the time component of the UUID can be arbitrarily selected to be any time less than the time when the device was manufactured. A time of 0 (as shown in the example in Section 3.2) is perfectly legal as long as the device knows no other UUIDs were generated at this time on this device.",
      "ja": "注：最初にインストールされたときに「ソフト電話」のようなデバイスは、UUID [RFC4122]を生成し、これを将来のすべての使用のために永続的なストレージに保存できます。単一のSIP UAが存在する「ハード電話」などのデバイスの場合、UUIDはMACアドレスを含めることができ、他のUUIDが同時に生成されないことが保証されているため、いつでも生成できます。その物理的なデバイスで。これは、UUIDの時間コンポーネントの値を、デバイスが製造された時期よりも短い時間になるように任意に選択できることを意味します。0の時間（セクション3.2の例に示すように）は、このデバイスでこの時点で他のUUIDが生成されなかったことをデバイスが知っている限り、完全に合法です。"
    },
    {
      "indent": 3,
      "text": "If a URN scheme other than UUID is used, the UA MUST only use URNs for which an RFC (from the IETF stream) defines how the specific URN needs to be constructed and used in the \"+sip.instance\" Contact header field parameter for outbound behavior.",
      "ja": "UUID以外のURNスキームが使用されている場合、UAはRFC（IETFストリームから）が「SIP.Instance」で使用する方法を定義するurnsのみを使用する必要があります。行動。"
    },
    {
      "indent": 3,
      "text": "To convey its instance-id in both requests and responses, the UA includes a \"sip.instance\" media feature tag as a UA characteristic [RFC3840]. This media feature tag is encoded in the Contact header field as the \"+sip.instance\" Contact header field parameter. One case where a UA could prefer to omit the \"sip.instance\" media feature tag is when it is making an anonymous request or some other privacy concern requires that the UA not reveal its identity.",
      "ja": "リクエストと応答の両方でそのInstance-IDを伝えるために、UAにはUA特性[RFC3840]として「sip.instance」メディア機能タグが含まれています。このメディア機能タグは、「sip.instance」コンタクトヘッダーフィールドパラメーターとしてコンタクトヘッダーフィールドにエンコードされています。UAが「sip.instance」メディア機能タグを省略することを好む可能性のあるケースの1つは、匿名のリクエストを行っている場合、または他のプライバシーの懸念を作成している場合、UAがそのアイデンティティを明らかにしないことが必要です。"
    },
    {
      "indent": 6,
      "text": "Note: [RFC3840] defines equality rules for callee capabilities parameters, and according to that specification, the \"sip.instance\" media feature tag will be compared by case-sensitive string comparison. This means that the URN will be encapsulated by angle brackets (\"<\" and \">\") when it is placed within the quoted string value of the \"+sip.instance\" Contact header field parameter. The case-sensitive matching rules apply only to the generic usages defined in the callee capabilities [RFC3840] and the caller preferences [RFC3841] specifications. When the instance ID is used in this specification, it is \"extracted\" from the value in the \"sip.instance\" media feature tag. Thus, equality comparisons are performed using the rules for URN equality that are specific to the scheme in the URN. If the element performing the comparisons does not understand the URN scheme, it performs the comparisons using the lexical equality rules defined in [RFC2141]. Lexical equality could result in two URNs being considered unequal when they are actually equal. In this specific usage of URNs, the only element that provides the URN is the SIP UA instance identified by that URN. As a result, the UA instance has to provide lexically equivalent URNs in each registration it generates. This is likely to be normal behavior in any case; clients are not likely to modify the value of the instance ID so that it remains functionally equivalent to (yet lexicographically different from) previous registrations.",
      "ja": "注：[RFC3840]は、Callee機能パラメーターの平等規則を定義し、その仕様に従って、「sip.instance」メディア機能タグは、ケースに敏感な文字列比較によって比較されます。これは、urnが「sip.instance」コンタクトヘッダーフィールドパラメーターの引用された文字列値内に配置されると、角度ブラケット（ \"<\"および \">\"）によってカプセル化されることを意味します。ケースに敏感なマッチングルールは、Callee機能[RFC3840]および発信者の好み[RFC3841]仕様で定義された一般的な使用法にのみ適用されます。この仕様でインスタンスIDが使用される場合、「sip.instance」メディア機能タグの値から「抽出」されます。したがって、平等比較は、urnのスキームに固有のurn等式のルールを使用して実行されます。比較を実行する要素がURNスキームを理解していない場合、[RFC2141]で定義された語彙等式規則を使用して比較を実行します。語彙的平等は、2つのurが実際に等しい場合、不平等であると見なされる可能性があります。urのこの特定の使用法では、urを提供する唯一の要素は、そのurnによって識別されるSIP UAインスタンスです。その結果、UAインスタンスは、生成する各登録で字句的に同等のURNを提供する必要があります。これは、いずれにしても通常の動作である可能性があります。クライアントは、インスタンスIDの値を変更する可能性が低いため、以前の登録と機能的に同等のままです（以前の登録とは異なります）。"
    },
    {
      "indent": 0,
      "text": "4.2. Registrations",
      "section_title": true,
      "ja": "4.2. 登録"
    },
    {
      "indent": 0,
      "text": "4.2.1. Initial Registrations",
      "section_title": true,
      "ja": "4.2.1. 初期登録"
    },
    {
      "indent": 3,
      "text": "At configuration time, UAs obtain one or more SIP URIs representing the default outbound-proxy-set. This specification assumes the set is determined via any of a number of configuration mechanisms, and future specifications can define additional mechanisms such as using DNS to discover this set. How the UA is configured is outside the scope of this specification. However, a UA MUST support sets with at least two outbound proxy URIs and SHOULD support sets with up to four URIs.",
      "ja": "構成時に、UASはデフォルトのアウトバウンドポストセットを表す1つ以上のSIP URIを取得します。この仕様では、セットが多くの構成メカニズムのいずれかを介して決定されると想定しており、将来の仕様では、DNSを使用してこのセットを発見するなどの追加のメカニズムを定義できます。UAの構成方法は、この仕様の範囲外です。ただし、UAは、少なくとも2つのアウトバウンドプロキシURIを持つセットをサポートする必要があり、最大4つのURIのセットをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "For each outbound proxy URI in the set, the User Agent Client (UAC) SHOULD send a REGISTER request using this URI as the default outbound proxy. (Alternatively, the UA could limit the number of flows formed to conserve battery power, for example). If the set has more than one URI, the UAC MUST send a REGISTER request to at least two of the default outbound proxies from the set. UAs that support this specification MUST include the outbound option tag in a Supported header field in a REGISTER request. Each of these REGISTER requests will use a unique Call-ID. Forming the route set for the request is outside the scope of this document, but typically results in sending the REGISTER such that the topmost Route header field contains a loose route to the outbound proxy URI.",
      "ja": "セット内の各アウトバウンドプロキシURIについて、ユーザーエージェントクライアント（UAC）は、このURIをデフォルトのアウトバウンドプロキシとしてレジスタリクエストを送信する必要があります。（または、UAは、たとえば、バッテリー電源を節約するために形成されたフローの数を制限する可能性があります）。セットに複数のURIがある場合、UACはセットから少なくとも2つのデフォルトのアウトバウンドプロキシにレジスタリクエストを送信する必要があります。この仕様をサポートするUASには、レジスタリクエストにサポートされているヘッダーフィールドにアウトバウンドオプションタグを含める必要があります。これらの各レジスタリクエストは、一意のCall-IDを使用します。リクエストのルートセットを形成することは、このドキュメントの範囲外ですが、通常、最上部のルートヘッダーフィールドにアウトバウンドプロキシURIへのゆるいルートが含まれるようにレジスタを送信します。"
    },
    {
      "indent": 3,
      "text": "REGISTER requests, other than those described in Section 4.2.3, MUST include an instance-id media feature tag as specified in Section 4.1.",
      "ja": "セクション4.2.3で説明されているもの以外の登録要求は、セクション4.1で指定されているように、Instance-IDメディア機能タグを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "A UAC conforming to this specification MUST include in the Contact header field, a \"reg-id\" parameter that is distinct from other \"reg-id\" parameters used in other registrations that use the same \"+sip.instance\" Contact header field parameter and AOR. Each one of these registrations will form a new flow from the UA to the proxy. The sequence of reg-id values does not have to be sequential but MUST be exactly the same sequence of reg-id values each time the UA instance power cycles or reboots, so that the reg-id values will collide with the previously used reg-id values. This is so the registrar can replace the older registrations.",
      "ja": "この仕様に準拠するUACには、同じ「sip.instance」コンタクトヘッダーフィールドパラメーターを使用する他の登録で使用される他の「reg-id」パラメーターとは異なる「reg-id」パラメーターとの「reg-id」パラメーターと接触ヘッダーフィールドに含める必要があります。aor。これらの登録のそれぞれは、UAからプロキシへの新しいフローを形成します。reg-id値のシーケンスは、順次である必要はありませんが、UAインスタンスの電源サイクルまたは再起動のたびにreg-id値のシーケンスである必要があります。ID値。これは、レジストラが古い登録を置き換えることができるようにするためです。"
    },
    {
      "indent": 6,
      "text": "Note: The UAC can situationally decide whether to request outbound behavior by including or omitting the \"reg-id\" Contact header field parameter. For example, imagine the outbound-proxy-set contains two proxies in different domains, EP1 and EP2. If an outbound-style registration succeeded for a flow through EP1, the UA might decide to include 'outbound' in its Require header field when registering with EP2, in order to ensure consistency. Similarly, if the registration through EP1 did not support outbound, the UA might not register with EP2 at all.",
      "ja": "注：UACは、「reg-id」連絡先ヘッダーフィールドパラメーターを含めるか省略して、アウトバウンド動作を要求するかどうかを状況的に決定できます。たとえば、アウトバウンド - プロキシセットには、異なるドメインの2つのプロキシ、EP1とEP2が含まれていることを想像してください。Autboundスタイルの登録がEP1を介したフローで成功した場合、UAは、一貫性を確保するために、EP2に登録するときに、ヘッダーの必要フィールドに「アウトバウンド」を含めることを決定する場合があります。同様に、EP1を介した登録がアウトバウンドをサポートしていない場合、UAはEP2にまったく登録されない可能性があります。"
    },
    {
      "indent": 3,
      "text": "The UAC MUST support the Path header [RFC3327] mechanism, and indicate its support by including the 'path' option-tag in a Supported header field value in its REGISTER requests. Other than optionally examining the Path vector in the response, this is all that is required of the UAC to support Path.",
      "ja": "UACは、パスヘッダー[RFC3327]メカニズムをサポートし、レジスタリクエストにサポートされているヘッダーフィールド値に「パス」オプションタグを含めることにより、サポートを示す必要があります。応答のパスベクトルをオプションで調べる以外に、これはパスをサポートするためにUACに必要なものです。"
    },
    {
      "indent": 3,
      "text": "The UAC examines successful registration responses for the presence of an outbound option-tag in a Require header field value. Presence of this option-tag indicates that the registrar is compliant with this specification, and that any edge proxies which needed to participate are also compliant. If the registrar did not support outbound, the UA has potentially registered an un-routable contact. It is the responsibility of the UA to remove any inappropriate Contacts.",
      "ja": "UACは、ヘッダーフィールド値を必要とするアウトバウンドオプションタグの存在に関する登録応答の成功を調べます。このオプションタグの存在は、レジストラがこの仕様に準拠していること、および参加に必要なエッジプロキシも準拠していることを示します。レジストラがアウトバウンドをサポートしていない場合、UAは潜在的に不可能な連絡先を登録しています。不適切な連絡先を削除するのはUAの責任です。"
    },
    {
      "indent": 3,
      "text": "If outbound registration succeeded, as indicated by the presence of the outbound option-tag in the Require header field of a successful registration response, the UA begins sending keep-alives as described in Section 4.4.",
      "ja": "アウトバウンド登録が成功した場合、登録応答が成功した必要のあるヘッダーフィールドにアウトバウンドオプションタグが存在することで示されたように、UAはセクション4.4で説明されているようにキープアリブの送信を開始します。"
    },
    {
      "indent": 6,
      "text": "Note: The UA needs to honor 503 (Service Unavailable) responses to registrations as described in [RFC3261] and [RFC3263]. In particular, implementors should note that when receiving a 503 (Service Unavailable) response with a Retry-After header field, the UA is expected to wait the indicated amount of time and retry the registration. A Retry-After header field value of 0 is valid and indicates the UA is expected to retry the REGISTER request immediately. Implementations need to ensure that when retrying the REGISTER request, they revisit the DNS resolution results such that the UA can select an alternate host from the one chosen the previous time the URI was resolved.",
      "ja": "注：UAは、[RFC3261]および[RFC3263]で説明されているように、登録に対する503（サービスの利用できない）応答を尊重する必要があります。特に、実装者は、再試行後のヘッダーフィールドを使用して503（サービスが利用できない）応答を受信する場合、UAは指定された時間を待って登録を再試行することが期待されることに注意する必要があります。0の再試行後のヘッダーフィールド値は有効であり、UAがすぐにレジスタリクエストを再試行することが期待されていることを示します。実装は、レジスタリクエストを再試行するときにDNS解像度の結果を再検討して、URIが以前に選択されたものから代替ホストを選択できるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "If the registering UA receives a 439 (First Hop Lacks Outbound Support) response to a REGISTER request, it MAY re-attempt registration without using the outbound mechanism (subject to local policy at the client). If the client has one or more alternate outbound proxies available, it MAY re-attempt registration through such outbound proxies. See Section 11.6 for more information on the 439 response code.",
      "ja": "登録UAがレジスタリクエストに対する439（First Hopにはアウトバウンドサポートが欠けている）応答を受信した場合、アウトバウンドメカニズムを使用せずに登録を再検討できます（クライアントのローカルポリシーの対象）。クライアントが利用可能な1つ以上の代替アウトバウンドプロキシを持っている場合、そのようなアウトバウンドプロキシを介して登録を再取り付けすることができます。439応答コードの詳細については、セクション11.6を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.2.2. Subsequent REGISTER Requests",
      "section_title": true,
      "ja": "4.2.2. 後続の登録リクエスト"
    },
    {
      "indent": 3,
      "text": "Registrations for refreshing a binding and for removing a binding use the same instance-id and reg-id values as the corresponding initial registration where the binding was added. Registrations that merely refresh an existing binding are sent over the same flow as the original registration where the binding was added.",
      "ja": "バインディングを更新し、バインディングを削除するための登録。バインディングが追加された対応する初期登録と同じInstance-IDとreg-ID値を使用します。既存のバインディングを単に更新する登録は、バインディングが追加された元の登録と同じフローで送信されます。"
    },
    {
      "indent": 3,
      "text": "If a re-registration is rejected with a recoverable error response, for example by a 503 (Service Unavailable) containing a Retry-After header, the UAC SHOULD NOT tear down the corresponding flow if the flow uses a connection-oriented transport such as TCP. As long as \"pongs\" are received in response to \"pings\", the flow SHOULD be kept active until a non-recoverable error response is received. This prevents unnecessary closing and opening of connections.",
      "ja": "再登録が回復可能なエラー応答で拒否された場合（たとえば、再試行後のヘッダーを含む503（サービスが利用できない）によって拒否された場合、フローがTCPなどの接続指向のトランスポートを使用する場合、UACは対応するフローを取り壊さないでください。「pong」が「ping」に応じて受信されている限り、回復不可能なエラー応答が受信されるまで、フローをアクティブに保つ必要があります。これにより、接続の不必要な閉鎖と開閉が防止されます。"
    },
    {
      "indent": 0,
      "text": "4.2.3. Third-Party Registrations",
      "section_title": true,
      "ja": "4.2.3. サードパーティの登録"
    },
    {
      "indent": 3,
      "text": "In an initial registration or re-registration, a UA MUST NOT include a \"reg-id\" header field parameter in the Contact header field if the registering UA is not the same instance as the UA referred to by the target Contact header field. (This practice is occasionally used to install forwarding policy into registrars.)",
      "ja": "最初の登録または再登録では、登録UAがターゲットコンタクトヘッダーフィールドで言及されているUAと同じインスタンスではない場合、UAにはコンタクトヘッダーフィールドに「reg-id」ヘッダーフィールドパラメーターを含めてはなりません。（このプラクティスは、レジストラへの転送ポリシーをインストールするために時々使用されます。）"
    },
    {
      "indent": 3,
      "text": "A UAC also MUST NOT include an instance-id feature tag or \"reg-id\" Contact header field parameter in a request to un-register all Contacts (a single Contact header field value with the value of \"*\").",
      "ja": "UACには、すべての連絡先（「*」の値を持つ単一の連絡先ヘッダーフィールド値）を解除するリクエストにインスタンスID機能タグまたは「reg-id」コンタクトヘッダーフィールドパラメーターを含めてはなりません。"
    },
    {
      "indent": 0,
      "text": "4.3. Sending Non-REGISTER Requests",
      "section_title": true,
      "ja": "4.3. 非登録リクエストの送信"
    },
    {
      "indent": 3,
      "text": "When a UAC is about to send a request, it first performs normal processing to select the next hop URI. The UA can use a variety of techniques to compute the route set and accordingly the next hop URI. Discussion of these techniques is outside the scope of this document. UAs that support this specification SHOULD include the outbound option tag in a Supported header field in a request that is not a REGISTER request.",
      "ja": "UACがリクエストを送信しようとしているとき、最初に通常の処理を実行して次のホップURIを選択します。UAは、さまざまなテクニックを使用してルートセットを計算できます。これらの手法の議論は、このドキュメントの範囲外です。この仕様をサポートするUASには、レジスタリクエストではないリクエストに、サポートされているヘッダーフィールドにアウトバウンドオプションタグを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "The UAC performs normal DNS resolution on the next hop URI (as described in [RFC3263]) to find a protocol, IP address, and port. For protocols that don't use TLS, if the UAC has an existing flow to this IP address, and port with the correct protocol, then the UAC MUST use the existing connection. For TLS protocols, there MUST also be a match between the host production in the next hop and one of the URIs contained in the subjectAltName in the peer certificate. If the UAC cannot use one of the existing flows, then it SHOULD form a new flow by sending a datagram or opening a new connection to the next hop, as appropriate for the transport protocol.",
      "ja": "UACは、次のホップURI（[RFC3263]に記載されているように）で通常のDNS解像度を実行して、プロトコル、IPアドレス、およびポートを見つけます。TLSを使用しないプロトコルの場合、UACがこのIPアドレスに既存のフローを持っている場合、正しいプロトコルを使用してポートする場合、UACは既存の接続を使用する必要があります。TLSプロトコルの場合、次のホップでのホスト制作と、ピア証明書のsumberaltaltnameに含まれるURIの1つとの間にも一致する必要があります。UACが既存のフローのいずれかを使用できない場合、輸送プロトコルに適した場合、データグラムを送信するか、次のホップへの新しい接続を開くことにより、新しいフローを形成する必要があります。"
    },
    {
      "indent": 3,
      "text": "Typically, a UAC using the procedures of this document and sending a dialog-forming request will want all subsequent requests in the dialog to arrive over the same flow. If the UAC is using a Globally Routable UA URI (GRUU) [RFC5627] that was instantiated using a Contact header field value that included an \"ob\" parameter, the UAC sends the request over the flow used for registration, and subsequent requests will arrive over that same flow. If the UAC is not using such a GRUU, then the UAC adds an \"ob\" parameter to its Contact header field value. This will cause all subsequent requests in the dialog to arrive over the flow instantiated by the dialog-forming request. This case is typical when the request is sent prior to registration, such as in the initial subscription dialog for the configuration framework [CONFIG-FMWK].",
      "ja": "通常、このドキュメントの手順を使用してダイアログ形成リクエストを送信するUACは、ダイアログ内のすべての後続のリクエストが同じフローに到着することを望みます。UACが「OB」パラメーターを含むコンタクトヘッダーフィールド値を使用してインスタンス化されたグローバルにルーティング可能なUA URI（GRUU）[RFC5627]を使用している場合、UACは登録に使用されるフローのリクエストを送信し、その後のリクエストが到着します同じフローの上。UACがそのようなGruuを使用していない場合、UACはコンタクトヘッダーフィールド値に「OB」パラメーターを追加します。これにより、ダイアログ内のすべての後続の要求が、ダイアログ形成リクエストによってインスタンス化されたフローを介して到着します。このケースは、構成フレームワークの最初のサブスクリプションダイアログ[config-fmwk]など、登録前にリクエストが送信される場合に典型的です。"
    },
    {
      "indent": 6,
      "text": "Note: If the UAC wants a UDP flow to work through NATs or firewalls, it still needs to put the 'rport' parameter [RFC3581] in its Via header field value, and send from the port it is prepared to receive on. More general information about NAT traversal in SIP is described in [NAT-SCEN].",
      "ja": "注：UACがUDPフローをNATまたはファイアウォールで動作させる必要がある場合、ヘッダーフィールド値を介して「rport」パラメーター[RFC3581]を配置し、受け取る準備ができているポートから送信する必要があります。SIPのNATトラバーサルに関するより一般的な情報は、[Nat-Scen]で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Keep-Alives and Detecting Flow Failure",
      "section_title": true,
      "ja": "4.4. アリブを維持し、流れの故障を検出します"
    },
    {
      "indent": 3,
      "text": "Keep-alives are used for refreshing NAT/firewall bindings and detecting flow failure. Flows can fail for many reasons including the rebooting of NATs and the crashing of edge proxies.",
      "ja": "Keep-Alivesは、NAT/ファイアウォールのバインディングを更新し、流れの故障を検出するために使用されます。NATの再起動やエッジプロキシのクラッシュなど、多くの理由でフローが失敗する可能性があります。"
    },
    {
      "indent": 3,
      "text": "As described in Section 4.2, a UA that registers will begin sending keep-alives after an appropriate registration response. A UA that does not register (for example, a PSTN gateway behind a firewall) can also send keep-alives under certain circumstances.",
      "ja": "セクション4.2で説明されているように、登録するUAは、適切な登録応答の後にキープアリブの送信を開始します。登録しないUA（たとえば、ファイアウォールの背後にあるPSTNゲートウェイ）は、特定の状況下でキープアリブを送信することもできます。"
    },
    {
      "indent": 3,
      "text": "Under specific circumstances, a UAC might be allowed to send STUN keep-alives even if the procedures in Section 4.2 were not completed, provided that there is an explicit indication that the target first-hop SIP node supports STUN keep-alives. For example, this applies to a non-registering UA or to a case where the UA registration succeeded, but the response did not include the outbound option-tag in the Require header field.",
      "ja": "特定の状況では、ターゲットの最初のホップSIPノードがStun Keep-Alivesをサポートしていることを明確に示す場合、セクション4.2の手順が完了していない場合でも、UACはStun Keep-Alivesを送信することが許可される場合があります。たとえば、これは、登録されていないUAまたはUA登録が成功した場合に適用されますが、応答には要求ヘッダーフィールドにアウトバウンドオプションタグが含まれていませんでした。"
    },
    {
      "indent": 6,
      "text": "Note: A UA can \"always\" send a double CRLF (a \"ping\") over connection-oriented transports as this is already allowed by Section 7.5 of [RFC3261]. However a UA that did not register using outbound registration cannot expect a CRLF in response (a \"pong\") unless the UA has an explicit indication that CRLF keep-alives are supported as described in this section. Likewise, a UA that did not successfully register with outbound procedures needs explicit indication that the target first-hop SIP node supports STUN keep-alives before it can send any STUN messages.",
      "ja": "注：UAは、[RFC3261]のセクション7.5ですでに許可されているため、接続指向のトランスポートにダブルCRLF（「ping」）を「常に」送信できます。ただし、アウトバウンド登録を使用して登録しなかったUAは、このセクションで説明されているようにCRLF Keep-Alivesがサポートされているという明示的な兆候がない限り、応答するCRLF（「ポン」）を期待することはできません。同様に、アウトバウンド手順に正常に登録しなかったUAには、ターゲットの最初のホップSIPノードがスタンメッセージを送信する前にStun Keep-Alivesをサポートすることを明示的に示す必要があります。"
    },
    {
      "indent": 3,
      "text": "A configuration option indicating keep-alive support for a specific target is considered an explicit indication. If these conditions are satisfied, the UA sends its keep-alives according to the same guidelines as those used when UAs register; these guidelines are described below.",
      "ja": "特定のターゲットのキープアライブサポートを示す構成オプションは、明示的な兆候と見なされます。これらの条件が満たされている場合、UAは、UASが登録されたときに使用されているガイドラインと同じガイドラインに従ってKeep-Alivesを送信します。これらのガイドラインについては、以下に説明します。"
    },
    {
      "indent": 3,
      "text": "The UA needs to detect when a specific flow fails. The UA actively tries to detect failure by periodically sending keep-alive messages using one of the techniques described in Sections 4.4.1 or 4.4.2. If a flow with a registration has failed, the UA follows the procedures in Section 4.2 to form a new flow to replace the failed one.",
      "ja": "UAは、特定のフローが失敗したときに検出する必要があります。UAは、セクション4.4.1または4.4.2で説明されている手法のいずれかを使用して、キープアライブメッセージを定期的に送信することにより、障害を積極的に検出しようとします。登録が失敗したフローが失敗した場合、UAはセクション4.2の手順に従って、失敗したフローを置き換える新しいフローを形成します。"
    },
    {
      "indent": 3,
      "text": "When a successful registration response contains the Flow-Timer header field, the value of this header field is the number of seconds the server is prepared to wait without seeing keep-alives before it could consider the corresponding flow dead. Note that the server would wait for an amount of time larger than the Flow-Timer in order to have a grace period to account for transport delay. The UA MUST send keep-alives at least as often as this number of seconds. If the UA uses the server-recommended keep-alive frequency it SHOULD send its keep-alives so that the interval between each keep-alive is randomly distributed between 80% and 100% of the server-provided time. For example, if the server suggests 120 seconds, the UA would send each keep-alive with a different frequency between 95 and 120 seconds.",
      "ja": "登録応答が成功した場合、フロータイマーヘッダーフィールドが含まれている場合、このヘッダーフィールドの値は、対応するフローが死んだと考える前に、サーバーがキープアリブを見ることなく待機する準備ができている秒数です。サーバーは、輸送遅延を考慮するための猶予期間を持つために、フロータイマーよりも長い時間待つことに注意してください。UAは、少なくともこの秒数と同じくらい頻繁にKeep-Alivesを送信する必要があります。UAがサーバーが推奨するKeep Alive周波数を使用している場合、各キープアライブ間の間隔がサーバーが提供する時間の80％から100％の間にランダムに分散するようにキープアリブを送信する必要があります。たとえば、サーバーが120秒を提案する場合、UAは95〜120秒の間の異なる周波数で各キープアライブを送信します。"
    },
    {
      "indent": 3,
      "text": "If no Flow-Timer header field was present in a register response for this flow, the UA can send keep-alives at its discretion. The sections below provide RECOMMENDED default values for these keep-alives.",
      "ja": "このフローのレジスタ応答にフロータイマーヘッダーフィールドが存在しなかった場合、UAはその裁量でKeep-Alivesを送信できます。以下のセクションでは、これらのKeep-Alivesの推奨デフォルト値を提供します。"
    },
    {
      "indent": 3,
      "text": "The client needs to perform normal [RFC3263] SIP DNS resolution on the URI from the outbound-proxy-set to pick a transport. Once a transport is selected, the UA selects the keep-alive approach that is recommended for that transport.",
      "ja": "クライアントは、輸送を選択するには、アウトバウンドポキシセットからURIで通常の[RFC3263] SIP DNS解像度を実行する必要があります。輸送が選択されると、UAはその輸送に推奨されるキープアライブアプローチを選択します。"
    },
    {
      "indent": 3,
      "text": "Section 4.4.1 describes a keep-alive mechanism for connection-oriented transports such as TCP or SCTP. Section 4.4.2 describes a keep-alive mechanism for connection-less transports such as UDP. Support for other transports such as DCCP [RFC4340] is for further study.",
      "ja": "セクション4.4.1では、TCPやSCTPなどの接続指向輸送のためのキープアライブメカニズムについて説明します。セクション4.4.2では、UDPなどの接続のない輸送のためのキープアライブメカニズムについて説明します。DCCP [RFC4340]などの他の輸送のサポートは、さらなる研究のためです。"
    },
    {
      "indent": 0,
      "text": "4.4.1. Keep-Alive with CRLF",
      "section_title": true,
      "ja": "4.4.1. CRLFを使用してください"
    },
    {
      "indent": 3,
      "text": "This approach MUST only be used with connection oriented transports such as TCP or SCTP; it MUST NOT be used with connection-less transports such as UDP.",
      "ja": "このアプローチは、TCPやSCTPなどの接続指向輸送でのみ使用する必要があります。UDPなどの接続のないトランスポートで使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "A User Agent that forms flows checks if the configured URI to which the UA is connecting resolves to a connection-oriented transport (e.g., TCP and TLS over TCP).",
      "ja": "フローを形成するユーザーエージェントは、UAが接続している構成されたURIが接続指向のトランスポート（TCPを超えるTCPおよびTLSなど）に解決するかどうかをチェックします。"
    },
    {
      "indent": 3,
      "text": "For this mechanism, the client \"ping\" is a double-CRLF sequence, and the server \"pong\" is a single CRLF, as defined in the ABNF below:",
      "ja": "このメカニズムでは、クライアント「ping」はダブルCRLFシーケンスであり、サーバー「pong」は以下のABNFで定義されているように単一のCRLFです。"
    },
    {
      "indent": 3,
      "text": "CRLF = CR LF\ndouble-CRLF = CR LF CR LF\nCR = %x0D\nLF = %x0A\n   The \"ping\" and \"pong\" need to be sent between SIP messages and cannot\nbe sent in the middle of a SIP message.  If sending over TLS, the\nCRLFs are sent inside the TLS protected channel.  If sending over a\nSigComp [RFC3320] compressed data stream, the CRLF keep-alives are\nsent inside the compressed stream.  The double CRLF is considered a\nsingle SigComp message.  The specific mechanism for representing\nthese characters is an implementation-specific matter to be handled\nby the SigComp compressor at the sending end.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If a pong is not received within 10 seconds after sending a ping (or immediately after processing any incoming message being received when that 10 seconds expires), then the client MUST treat the flow as failed. Clients MUST support this CRLF keep-alive.",
      "ja": "pingを送信してから10秒以内にポンが受信されない場合（または、その10秒の有効期限が切れたときに受信メッセージが受信される直後）、クライアントはフローを失敗したように扱う必要があります。クライアントは、このCRLFを維持することをサポートする必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: This value of 10-second timeout was selected to be long enough that it allows plenty of time for a server to send a response even if the server is temporarily busy with an administrative activity. At the same time, it was selected to be small enough that a UA registered to two redundant servers with unremarkable hardware uptime could still easily provide very high levels of overall reliability. Although some Internet protocols are designed for round-trip times over 10 seconds, SIP for real-time communications is not really usable in these type of environments as users often abandon calls before waiting much more than a few seconds.",
      "ja": "注：10秒のタイムアウトのこの値は、サーバーが管理アクティビティで一時的に忙しい場合でも、サーバーが応答を送信するのに十分な時間を確保できるほど十分に長くなるように選択されました。同時に、UAが目立たないハードウェアアップタイムを備えた2つの冗長サーバーに登録されているため、非常に高いレベルの全体的な信頼性を簡単に提供できるように、十分に小さくなるように選択されました。一部のインターネットプロトコルは10秒間の往復時間用に設計されていますが、リアルタイム通信のためのSIPは、このタイプの環境では、ユーザーが数秒以上待つ前に電話を放棄することが多いため、実際には使用できません。"
    },
    {
      "indent": 3,
      "text": "When a Flow-Timer header field is not provided in the most recent success registration response, the proper selection of keep-alive frequency is primarily a trade-off between battery usage and availability. The UA MUST select a random number between a fixed or configurable upper bound and a lower bound, where the lower bound is 20% less then the upper bound. The fixed upper bound or the default configurable upper bound SHOULD be 120 seconds (95 seconds for the lower bound) where battery power is not a concern and 840 seconds (672 seconds for the lower bound) where battery power is a concern. The random number will be different for each keep-alive \"ping\".",
      "ja": "フロータイマーヘッダーフィールドが最新の成功登録応答で提供されていない場合、キープアライブ周波数の適切な選択は、主にバッテリーの使用と可用性のトレードオフです。UAは、固定または構成可能な上限と下限の間の乱数を選択する必要があります。下限は上限より20％少ないです。固定された上限またはデフォルトの構成可能な上限は、バッテリー電力が懸念されない120秒（下限で95秒）、バッテリー電力が懸念事項である840秒（下限では672秒）である必要があります。乱数は、キープアライブ「ping」ごとに異なります。"
    },
    {
      "indent": 6,
      "text": "Note on selection of time values: the 120-second upper bound was chosen based on the idea that for a good user experience, failures normally will be detected in this amount of time and a new connection will be set up. The 14-minute upper bound for battery-powered devices was selected based on NATs with TCP timeouts as low as 15 minutes. Operators that wish to change the relationship between load on servers and the expected time that a user might not receive inbound communications will probably adjust this time. The 95-second lower bound was chosen so that the jitter introduced will result in a relatively even load on the servers after 30 minutes.",
      "ja": "時間値の選択に関する注意：120秒の上限は、優れたユーザーエクスペリエンスのために、この時間で通常障害が検出され、新しい接続が設定されるという考えに基づいて選択されました。バッテリー駆動のデバイス用の14分間の上限は、15分という低いTCPタイムアウトのNATに基づいて選択されました。サーバー上の負荷と、ユーザーがインバウンド通信を受信しない予定の時間との関係を変更したいオペレーターは、おそらく今回は調整されます。95秒の下限が選択されたため、ジッターが導入されると、30分後にサーバーに比較的均一な負荷が発生します。"
    },
    {
      "indent": 0,
      "text": "4.4.2. Keep-Alive with STUN",
      "section_title": true,
      "ja": "4.4.2. スタンで守ります"
    },
    {
      "indent": 3,
      "text": "This approach MUST only be used with connection-less transports, such as UDP; it MUST NOT be used for connection-oriented transports such as TCP and SCTP.",
      "ja": "このアプローチは、UDPなどの接続のないトランスポートでのみ使用する必要があります。TCPやSCTPなどの接続指向の輸送に使用してはなりません。"
    },
    {
      "indent": 3,
      "text": "A User Agent that forms flows checks if the configured URI to which the UA is connecting resolves to use the UDP transport. The UA can periodically perform keep-alive checks by sending STUN [RFC5389] Binding Requests over the flow as described in Section 8. Clients MUST support STUN-based keep-alives.",
      "ja": "フローを形成するユーザーエージェントは、UAが接続している構成されたURIがUDPトランスポートを使用することを解決するかどうかをチェックします。UAは、セクション8で説明されているように、フローに対するStun [RFC5389]のバインディング要求を送信することにより、定期的にキープアリブチェックを実行できます。クライアントは、スタンベースのキープアリブをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When a Flow-Timer header field is not included in a successful registration response, the time between each keep-alive request SHOULD be a random number between 24 and 29 seconds.",
      "ja": "フロータイマーヘッダーフィールドが登録応答の成功に含まれていない場合、各キープアライブリクエストの間の時間は24〜29秒の乱数である必要があります。"
    },
    {
      "indent": 6,
      "text": "Note on selection of time values: the upper bound of 29 seconds was selected, as many NATs have UDP timeouts as low as 30 seconds. The 24-second lower bound was selected so that after 10 minutes the jitter introduced by different timers will make the keep-alive requests unsynchronized to evenly spread the load on the servers. Note that the short NAT timeouts with UDP have a negative impact on battery life.",
      "ja": "時間値の選択に関する注意：29秒の上限が選択されました。多くのNATには30秒という低いUDPのタイムアウトがあります。24秒の下限が選択されたため、10分後に異なるタイマーによって導入されたジッターにより、キープアライブリクエストが無効化され、サーバーに負荷が均等に広がるようになります。UDPを使用した短いNATタイムアウトは、バッテリー寿命に悪影響を与えることに注意してください。"
    },
    {
      "indent": 3,
      "text": "If a STUN Binding Error Response is received, or if no Binding Response is received after 7 retransmissions (16 times the STUN \"RTO\" timer -- where RTO is an estimate of round-trip time), the UA considers the flow failed. If the XOR-MAPPED-ADDRESS in the STUN Binding Response changes, the UA MUST treat this event as a failure on the flow.",
      "ja": "スタンバインディングエラー応答が受信された場合、または7回の再送信（STUN \"RTO\"タイマーの16倍-RTOが往復時間の推定値）の後にバインディング応答が受信されない場合、UAはフローが失敗したと見なします。スタン結合応答のXOR-Mapped-Addressが変化する場合、UAはこのイベントをフローの障害として扱う必要があります。"
    },
    {
      "indent": 0,
      "text": "4.5. Flow Recovery",
      "section_title": true,
      "ja": "4.5. フローリカバリ"
    },
    {
      "indent": 3,
      "text": "When a flow used for registration (through a particular URI in the outbound-proxy-set) fails, the UA needs to form a new flow to replace the old flow and replace any registrations that were previously sent over this flow. Each new registration MUST have the same reg-id value as the registration it replaces. This is done in much the same way as forming a brand new flow as described in Section 4.2; however, if there is a failure in forming this flow, the UA needs to wait a certain amount of time before retrying to form a flow to this particular next hop.",
      "ja": "登録に使用されたフロー（アウトバウンドプロキシセットの特定のURIを介して）が失敗した場合、UAは古いフローを置き換えて、このフローに以前に送信された登録を置き換えるために新しいフローを形成する必要があります。新しい登録ごとに、それが置き換える登録と同じreg-id値を持つ必要があります。これは、セクション4.2で説明されているように、まったく新しいフローを形成するのとほぼ同じ方法で行われます。ただし、このフローの形成に障害がある場合、UAは、この特定の次のホップへのフローを形成するために再試行する前に一定の時間を待つ必要があります。"
    },
    {
      "indent": 3,
      "text": "The amount of time to wait depends if the previous attempt at establishing a flow was successful. For the purposes of this section, a flow is considered successful if outbound registration succeeded, and if keep-alives are in use on this flow, at least one subsequent keep-alive response was received.",
      "ja": "待機する時間は、フローを確立しようとする以前の試みが成功したかどうかによって異なります。このセクションの目的のために、アウトバウンド登録が成功した場合、フローは成功したと見なされ、このフローでキープアリブが使用されている場合、少なくとも1つの後続のキープアライブ応答が受信されました。"
    },
    {
      "indent": 3,
      "text": "The number of seconds to wait is computed in the following way. If all of the flows to every URI in the outbound proxy set have failed, the base-time is set to a lower value (with a default of 30 seconds); otherwise, in the case where at least one of the flows has not failed, the base-time is set to a higher value (with a default of 90 seconds). The upper-bound wait time (W) is computed by taking two raised to the power of the number of consecutive registration failures for that URI, and multiplying this by the base-time, up to a configurable maximum time (with a default of 1800 seconds).",
      "ja": "待機する秒数は、次の方法で計算されます。アウトバウンドプロキシセットのすべてのURIへのフローがすべて失敗した場合、ベースタイムはより低い値（デフォルトの30秒）に設定されます。それ以外の場合、フローの少なくとも1つが失敗していない場合、基本時間はより高い値に設定されています（デフォルトの90秒）。上部の待機時間（W）は、そのURIの連続登録障害の数のパワーに合わせて2つを引き上げ、これに基本時間を掛けて構成可能な最大時間（デフォルトのデフォルトで1800）まで増やすことで計算されます。秒）。"
    },
    {
      "indent": 3,
      "text": "W = min (max-time, (base-time * (2 ^ consecutive-failures)))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "These times MAY be configurable in the UA. The three times are:",
      "ja": "これらの時間は、UAで構成可能である場合があります。3回は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "o max-time with a default of 1800 seconds",
      "ja": "o デフォルトの1800秒の最大時間"
    },
    {
      "indent": 3,
      "text": "o base-time (if all failed) with a default of 30 seconds",
      "ja": "o デフォルトの30秒のベースタイム（すべて失敗した場合）"
    },
    {
      "indent": 3,
      "text": "o base-time (if all have not failed) with a default of 90 seconds",
      "ja": "o 90秒のデフォルトの基本時間（すべてが失敗していない場合）"
    },
    {
      "indent": 3,
      "text": "For example, if the base-time is 30 seconds, and there were three failures, then the upper-bound wait time is min(1800, 30*(2^3)) or 240 seconds. The actual amount of time the UA waits before retrying registration (the retry delay time) is computed by selecting a uniform random time between 50 and 100% of the upper-bound wait time. The UA MUST wait for at least the value of the retry delay time before trying another registration to form a new flow for that URI (a 503 response to an earlier failed registration attempt with a Retry-After header field value may cause the UA to wait longer).",
      "ja": "たとえば、ベースタイムが30秒で、3つの障害があった場合、上部の待ち時間は最小（1800、30*（2^3））または240秒です。登録を再試行する前にUAが待機する実際の時間（再試行遅延時間）は、上限待機時間の50〜100％の均一なランダム時間を選択することにより計算されます。UAは、そのURIの新しいフローを形成するために別の登録を試みる前に、少なくとも再試行遅延時間の値を待つ必要があります（再試行後のヘッダーフィールド値での以前の失敗した登録試行に対する503の応答により、UAはUAが待機する可能性がありますより長いです）。"
    },
    {
      "indent": 3,
      "text": "To be explicitly clear on the boundary conditions: when the UA boots, it immediately tries to register. If this fails and no registration on other flows succeed, the first retry happens somewhere between 30 and 60 seconds after the failure of the first registration request. If the number of consecutive-failures is large enough that the maximum of 1800 seconds is reached, the UA will keep trying indefinitely with a random time of 15 to 30 minutes between each attempt.",
      "ja": "境界条件を明示的にクリアするには：UAブーツがすぐに登録しようとします。これが失敗し、他のフローの登録が成功しない場合、最初の再試行は、最初の登録要求の障害から30秒から60秒の間に発生します。連続した故障の数が最大1800秒に達するほど十分に大きい場合、UAは各試行の間に15〜30分のランダムな時間で無期限に試し続けます。"
    },
    {
      "indent": 0,
      "text": "5. Edge Proxy Procedures",
      "section_title": true,
      "ja": "5. エッジプロキシ手順"
    },
    {
      "indent": 0,
      "text": "5.1. Processing Register Requests",
      "section_title": true,
      "ja": "5.1. レジスタリクエストの処理"
    },
    {
      "indent": 3,
      "text": "When an edge proxy receives a registration request with a \"reg-id\" header field parameter in the Contact header field, it needs to determine if it (the edge proxy) will have to be visited for any subsequent requests sent to the User Agent identified in the Contact header field, or not. If the edge proxy is the first hop, as indicated by the Via header field, it MUST insert its URI in a Path header field value as described in [RFC3327]. If it is not the first hop, it might still decide to add itself to the Path header based on local policy. In addition, if the edge proxy is the first SIP node after the UAC, the edge proxy either MUST store a \"flow token\" (containing information about the flow from the previous hop) in its Path URI or reject the request. The flow token MUST be an identifier that is unique to this network flow. The flow token MAY be placed in the userpart of the URI. In addition, the first node MUST include an \"ob\" URI parameter in its Path header field value. If the edge proxy is not the first SIP node after the UAC it MUST NOT place an \"ob\" URI parameter in a Path header field value. The edge proxy can determine if it is the first hop by examining the Via header field.",
      "ja": "EDGEプロキシがコンタクトヘッダーフィールドに「reg-id」ヘッダーフィールドパラメーターを含む登録要求を受信する場合、識別されたユーザーエージェントに送信された後続のリクエストのために（エッジプロキシ）がアクセスする必要があるかどうかを判断する必要があります。コンタクトヘッダーフィールドでは、かどうか。[RFC3327]に記載されているように、エッジプロキシが最初のホップである場合、Viaヘッダーフィールドで示されているように、URIをパスヘッダーフィールド値に挿入する必要があります。最初のホップではない場合、ローカルポリシーに基づいてパスヘッダーに追加することを決定する可能性があります。さらに、EdgeプロキシがUAC後の最初のSIPノードである場合、Edgeプロキシは、パスURIに「フロートークン」（前のホップからのフローに関する情報を含む）を保存するか、リクエストを拒否する必要があります。フロートークンは、このネットワークフローに固有の識別子でなければなりません。フロートークンは、URIのユーザーパートに配置できます。さらに、最初のノードには、パスヘッダーフィールド値に「OB」URIパラメーターを含める必要があります。EdgeプロキシがUAC後の最初のSIPノードではない場合、パスヘッダーフィールド値に「OB」URIパラメーターを配置してはなりません。Edgeプロキシは、Viaヘッダーフィールドを調べることにより、最初のホップかどうかを判断できます。"
    },
    {
      "indent": 0,
      "text": "5.2. Generating Flow Tokens",
      "section_title": true,
      "ja": "5.2. フロートークンの生成"
    },
    {
      "indent": 3,
      "text": "A trivial but impractical way to satisfy the flow token requirement in Section 5.1 involves storing a mapping between an incrementing counter and the connection information; however, this would require the edge proxy to keep an infeasible amount of state. It is unclear when this state could be removed, and the approach would have problems if the proxy crashed and lost the value of the counter. A stateless example is provided below. A proxy can use any algorithm it wants as long as the flow token is unique to a flow, the flow can be recovered from the token, and the token cannot be modified by attackers.",
      "ja": "セクション5.1のフロートークン要件を満たす些細なが非実用的な方法には、インクリメントカウンターと接続情報の間にマッピングを保存することが含まれます。ただし、これには、実行不可能な状態を維持するためにEDGEプロキシが必要になります。この状態をいつ削除できるかは不明であり、プロキシがクラッシュしてカウンターの価値を失った場合、アプローチは問題を抱えています。ステートレスの例を以下に示します。プロキシは、フロートークンがフローに固有のものであり、トークンからフローを回収できる限り、必要なアルゴリズムを使用できます。トークンは攻撃者によって変更できません。"
    },
    {
      "indent": 6,
      "text": "Example Algorithm: When the proxy boots, it selects a 20-octet crypto random key called K that only the edge proxy knows. A byte array, called S, is formed that contains the following information about the flow the request was received on: an enumeration indicating the protocol, the local IP address and port, the remote IP address and port. The HMAC of S is computed using the key K and the HMAC-SHA1-80 algorithm, as defined in [RFC2104]. The concatenation of the HMAC and S are base64 encoded, as defined in [RFC4648], and used as the flow identifier. When using IPv4 addresses, this will result in a 32-octet identifier.",
      "ja": "アルゴリズムの例：プロキシブーツの場合、エッジプロキシのみが知っているKと呼ばれる20オクテットの暗号ランダムキーを選択します。Sと呼ばれるバイト配列が形成されます。これには、リクエストが受信されたフローに関する次の情報が含まれています。プロトコル、ローカルIPアドレスとポート、リモートIPアドレスとポートを示す列挙。SのHMACは、[RFC2104]で定義されているように、キーKおよびHMAC-SHA1-80アルゴリズムを使用して計算されます。HMACとSの連結は、[RFC4648]で定義されているように、base64エンコードされ、フロー識別子として使用されます。IPv4アドレスを使用する場合、これにより32-OCTET識別子が生成されます。"
    },
    {
      "indent": 0,
      "text": "5.3. Forwarding Non-REGISTER Requests",
      "section_title": true,
      "ja": "5.3. 非登録リクエストの転送"
    },
    {
      "indent": 3,
      "text": "When an edge proxy receives a request, it applies normal routing procedures with the following additions. If the edge proxy receives a request where the edge proxy is the host in the topmost Route header field value, and the Route header field value contains a flow token, the proxy follows the procedures of this section. Otherwise the edge proxy skips the procedures in this section, removes itself from the Route header field, and continues processing the request.",
      "ja": "Edgeプロキシがリクエストを受信すると、次の追加で通常のルーティング手順を適用します。Edgeプロキシがエッジプロキシが最上部のルートヘッダーフィールド値のホストであるリクエストを受信し、ルートヘッダーフィールド値にフロートークンが含まれている場合、プロキシはこのセクションの手順に従います。それ以外の場合、Edgeプロキシはこのセクションの手順をスキップし、ルートヘッダーフィールドからそれ自体を削除し、リクエストの処理を続けます。"
    },
    {
      "indent": 3,
      "text": "The proxy decodes the flow token and compares the flow in the flow token with the source of the request to determine if this is an \"incoming\" or \"outgoing\" request.",
      "ja": "プロキシはフロートークンを解読し、フロートークンのフローをリクエストのソースと比較して、これが「着信」または「発信」要求であるかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "If the flow in the flow token identified by the topmost Route header field value matches the source IP address and port of the request, the request is an \"outgoing\" request; otherwise, it is an \"incoming\" request.",
      "ja": "最上部のルートヘッダーフィールド値によって識別されたフロートークンのフローが、リクエストのソースIPアドレスとポートと一致する場合、リクエストは「発信」リクエストです。それ以外の場合は、「着信」リクエストです。"
    },
    {
      "indent": 0,
      "text": "5.3.1. Processing Incoming Requests",
      "section_title": true,
      "ja": "5.3.1. 受信リクエストの処理"
    },
    {
      "indent": 3,
      "text": "If the Route header value contains an \"ob\" URI parameter, the Route header was probably copied from the Path header in a registration. If the Route header value contains an \"ob\" URI parameter, and the request is a new dialog-forming request, the proxy needs to adjust the route set to ensure that subsequent requests in the dialog can be delivered over a valid flow to the UA instance identified by the flow token.",
      "ja": "ルートヘッダー値に「OB」URIパラメーターが含まれている場合、ルートヘッダーはおそらく登録でパスヘッダーからコピーされました。ルートヘッダー値に「OB」URIパラメーターが含まれており、リクエストが新しいダイアログ形成リクエストである場合、プロキシはルートセットを調整して、ダイアログ内の後続のリクエストをUAへの有効なフローで配信できるようにする必要があります。フロートークンによって識別されたインスタンス。"
    },
    {
      "indent": 6,
      "text": "Note: A simple approach to satisfy this requirement is for the proxy to add a Record-Route header field value that contains the flow-token, by copying the URI in the Route header minus the \"ob\" parameter.",
      "ja": "注：この要件を満たすための簡単なアプローチは、プロキシがフロートークンを含むレコードルートヘッダーフィールド値を追加することです。これは、ルートヘッダーのURIを「OB」パラメーターからコピーすることにより、「OB」パラメーターを引いたものです。"
    },
    {
      "indent": 3,
      "text": "Next, whether the Route header field contained an \"ob\" URI parameter or not, the proxy removes the Route header field value and forwards the request over the 'logical flow' identified by the flow token, that is known to deliver data to the specific target UA instance. If the flow token has been tampered with, the proxy SHOULD send a 403 (Forbidden) response. If the flow no longer exists, the proxy SHOULD send a 430 (Flow Failed) response to the request.",
      "ja": "次に、ルートヘッダーフィールドに「OB」URIパラメーターが含まれているかどうかにかかわらず、プロキシはルートヘッダーフィールド値を削除し、フロートークンによって識別された「論理フロー」にリクエストを転送します。ターゲットUAインスタンス。フロートークンに改ざんされている場合、プロキシは403（禁止）応答を送信する必要があります。フローが存在しなくなった場合、プロキシはリクエストに430（Flow Failed）応答を送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Proxies that used the example algorithm described in Section 5.2 to form a flow token follow the procedures below to determine the correct flow. To decode the flow token, take the flow identifier in the user portion of the URI and base64 decode it, then verify the HMAC is correct by recomputing the HMAC and checking that it matches. If the HMAC is not correct, the request has been tampered with.",
      "ja": "セクション5.2で説明したアルゴリズムの例を使用してフロートークンを形成するプロキシは、以下の手順に従って正しいフローを決定します。フロートークンをデコードするには、URIのユーザー部分のフロー識別子とbase64デコードを取得し、HMACを再計算して一致することを確認することにより、HMACが正しいことを確認します。HMACが正しくない場合、リクエストは改ざんされています。"
    },
    {
      "indent": 0,
      "text": "5.3.2. Processing Outgoing Requests",
      "section_title": true,
      "ja": "5.3.2. 発信リクエストの処理"
    },
    {
      "indent": 3,
      "text": "For mid-dialog requests to work with outbound UAs, the requests need to be forwarded over some valid flow to the appropriate UA instance. If the edge proxy receives an outgoing dialog-forming request, the edge proxy can use the presence of the \"ob\" URI parameter in the UAC's Contact URI (or topmost Route header field) to determine if the edge proxy needs to assist in mid-dialog request routing.",
      "ja": "アウトバウンドUASと連携するための中間追放の場合、適切なUAインスタンスへの有効なフローを介してリクエストを転送する必要があります。Edgeプロキシが発信ダイアログ形成リクエストを受信した場合、EdgeプロキシはUACの連絡先URI（または最上部のルートヘッダーフィールド）の「OB」URIパラメーターの存在を使用して、Edgeプロキシが中間で支援する必要があるかどうかを判断できます。ダイアログ要求ルーティング。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Specific procedures at the edge proxy to ensure that mid-dialog requests are routed over an existing flow are not part of this specification. However, an approach such as having the edge proxy add a Record-Route header with a flow token is one way to ensure that mid-dialog requests are routed over the correct flow.",
      "ja": "実装注：既存のフローを介してミッドダイアログリクエストがこの仕様の一部ではないことを確認するために、エッジプロキシでの特定の手順。ただし、エッジプロキシにフロートークンを備えたレコードルートヘッダーを追加するなどのアプローチは、正しいフローの上でミッドダイアログリクエストがルーティングされるようにする1つの方法です。"
    },
    {
      "indent": 0,
      "text": "5.4. Edge Proxy Keep-Alive Handling",
      "section_title": true,
      "ja": "5.4. エッジプロキシキープアライブ処理"
    },
    {
      "indent": 3,
      "text": "All edge proxies compliant with this specification MUST implement support for STUN NAT keep-alives on their SIP UDP ports as described in Section 8.",
      "ja": "この仕様に準拠したすべてのエッジプロキシは、セクション8で説明されているように、SIP UDPポートのStun Nat Keep-Alivesのサポートを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "When a server receives a double CRLF sequence between SIP messages on a connection-oriented transport such as TCP or SCTP, it MUST immediately respond with a single CRLF over the same connection.",
      "ja": "サーバーが、TCPやSCTPなどの接続指向のトランスポート上のSIPメッセージ間のダブルCRLFシーケンスを受信する場合、同じ接続で単一のCRLFですぐに応答する必要があります。"
    },
    {
      "indent": 3,
      "text": "The last proxy to forward a successful registration response to a UA MAY include a Flow-Timer header field if the response contains the outbound option-tag in a Require header field value in the response. The reason a proxy would send a Flow-Timer is if it wishes to detect flow failures proactively and take appropriate action (e.g., log alarms, provide alternative treatment if incoming requests for the UA are received, etc.). The server MUST wait for an amount of time larger than the Flow-Timer in order to have a grace period to account for transport delay.",
      "ja": "UAに成功した登録応答を転送する最後のプロキシには、応答に応答に必要なヘッダーフィールド値にアウトバウンドオプションタグが含まれている場合、フロータイマーヘッダーフィールドが含まれる場合があります。プロキシがフロータイマーを送信する理由は、フロー障害を積極的に検出し、適切なアクションを実行することを希望する場合です（例：ログアラーム、UAの受信リクエストが受信された場合など）。サーバーは、輸送遅延を考慮するための猶予期間を持つために、フロータイマーよりも大きい時間を待つ必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Registrar Procedures",
      "section_title": true,
      "ja": "6. レジストラ手順"
    },
    {
      "indent": 3,
      "text": "This specification updates the definition of a binding in [RFC3261], Section 10 and [RFC3327], Section 5.3.",
      "ja": "この仕様では、[RFC3261]、セクション10および[RFC3327]、セクション5.3の結合の定義を更新します。"
    },
    {
      "indent": 3,
      "text": "Registrars that implement this specification MUST support the Path header mechanism [RFC3327].",
      "ja": "この仕様を実装するレジストラは、パスヘッダーメカニズム[RFC3327]をサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "When receiving a REGISTER request, the registrar MUST check from its Via header field if the registrar is the first hop or not. If the registrar is not the first hop, it MUST examine the Path header of the request. If the Path header field is missing or it exists but the first URI does not have an \"ob\" URI parameter, then outbound processing MUST NOT be applied to the registration. In this case, the following processing applies: if the REGISTER request contains the reg-id and the outbound option tag in a Supported header field, then the registrar MUST respond to the REGISTER request with a 439 (First Hop Lacks Outbound Support) response; otherwise, the registrar MUST ignore the \"reg-id\" parameter of the Contact header. See Section 11.6 for more information on the 439 response code.",
      "ja": "レジスタリクエストを受信するとき、レジストラはレジストラが最初のホップであるかどうかをヘッダーフィールドから確認する必要があります。レジストラが最初のホップではない場合、リクエストのパスヘッダーを調べる必要があります。パスヘッダーフィールドが欠落しているか、最初のURIに「OB」URIパラメーターがない場合、アウトバウンド処理を登録に適用してはなりません。この場合、次の処理が適用されます。レジスタリクエストにサポートされているヘッダーフィールドにreg-idとアウトバウンドオプションタグが含まれている場合、レジストラは439（最初のホップがアウトバウンドサポートを欠く）応答でレジスタリクエストに応答する必要があります。それ以外の場合、レジストラはコンタクトヘッダーの「reg-id」パラメーターを無視する必要があります。439応答コードの詳細については、セクション11.6を参照してください。"
    },
    {
      "indent": 3,
      "text": "A Contact header field value with an instance-id media feature tag but no \"reg-id\" header field parameter is valid (this combination will result in the creation of a GRUU, as described in the GRUU specification [RFC5627]), but one with a reg-id but no instance-id is not valid. If the registrar processes a Contact header field value with a reg-id but no instance-id, it simply ignores the reg-id parameter.",
      "ja": "インスタンスIDメディア機能タグを使用した接触ヘッダーフィールド値は、「reg-id」ヘッダーフィールドパラメーターは有効ではありません（この組み合わせは、Gruu仕様[RFC5627]で説明されているようにGruuの作成になります）が、1つは1つです）reg-idでは、Instance-IDは有効ではありません。レジストラがreg-idでコンタクトヘッダーフィールド値を処理するが、instance-idがない場合、reg-idパラメーターを単に無視します。"
    },
    {
      "indent": 3,
      "text": "A registration containing a \"reg-id\" header field parameter and a non-zero expiration is used to register a single UA instance over a single flow, and can also de-register any Contact header fields with zero expiration. Therefore, if the Contact header field contains more than one header field value with a non-zero expiration and any of these header field values contain a \"reg-id\" Contact header field parameter, the entire registration SHOULD be rejected with a 400 (Bad Request) response. The justification for recommending rejection versus making it mandatory is that the receiver is allowed by [RFC3261] to squelch (not respond to) excessively malformed or malicious messages.",
      "ja": "「reg-id」ヘッダーフィールドパラメーターと非ゼロ有効期限を含む登録を使用して、単一のフローに単一のUAインスタンスを登録し、有効期限がゼロで任意のコンタクトヘッダーフィールドを登録することもできます。したがって、コンタクトヘッダーフィールドに非ゼロ有効期限が伴われて複数のヘッダーフィールド値が含まれており、これらのヘッダーフィールド値に「reg-id」コンタクトヘッダーフィールドパラメーターが含まれている場合、登録全体を400で拒否する必要があります（悪いリクエスト）応答。拒否を推奨することと必須にすることを推奨する正当化は、[RFC3261]が過度に奇形または悪意のあるメッセージを抑制する（応答しない）ことを受信者が許可されることです。"
    },
    {
      "indent": 3,
      "text": "If the Contact header did not contain a \"reg-id\" Contact header field parameter or if that parameter was ignored (as described above), the registrar MUST NOT include the outbound option-tag in the Require header field of its response.",
      "ja": "コンタクトヘッダーに「reg-id」連絡先ヘッダーフィールドパラメーターが含まれていない場合、またはそのパラメーターが無視された場合（上記のように）、レジストラは、その応答の要求ヘッダーフィールドにアウトバウンドオプションタグを含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "The registrar MUST be prepared to receive, simultaneously for the same AOR, some registrations that use instance-id and reg-id and some registrations that do not. The registrar MAY be configured with local policy to reject any registrations that do not include the instance-id and reg-id, or with Path header field values that do not contain the \"ob\" URI parameter. If the Contact header field does not contain a \"+sip.instance\" Contact header field parameter, the registrar processes the request using the Contact binding rules in [RFC3261].",
      "ja": "レジストラは、同じAOR、Instance-IDおよびreg-IDを使用する一部の登録、およびそうでない登録を同時に受信する準備をする必要があります。レジストラは、Instance-IDとreg-IDを含まない登録、または「OB」URIパラメーターを含まないパスヘッダーフィールド値を拒否するために、ローカルポリシーで構成されている場合があります。コンタクトヘッダーフィールドに「sip.instance」に連絡したヘッダーフィールドパラメーターが含まれていない場合、レジストラは[RFC3261]の連絡先結合ルールを使用して要求を処理します。"
    },
    {
      "indent": 3,
      "text": "When a \"+sip.instance\" Contact header field parameter and a \"reg-id\" Contact header field parameter are present in a Contact header field of a REGISTER request (after the Contact header validation as described above), the corresponding binding is between an AOR and the combination of the instance-id (from the \"+sip.instance\" Contact header parameter) and the value of \"reg-id\" Contact header field parameter parameter. The registrar MUST store in the binding the Contact URI, all the Contact header field parameters, and any Path header field values. (Even though the Contact URI is not used for binding comparisons, it is still needed by the authoritative proxy to form the target set.) Provided that the UAC had included an outbound option-tag (defined in Section 11.4) in a Supported header field value in the REGISTER request, the registrar MUST include the outbound option-tag in a Require header field value in its response to that REGISTER request.",
      "ja": "「sip.instance」の連絡先ヘッダーフィールドパラメーターと「reg-id」連絡先ヘッダーフィールドパラメーターがレジスタリクエストのコンタクトヘッダーフィールドに存在する場合（上記の接触ヘッダー検証の後）、対応するバインディングはAORとインスタンスIDの組み合わせ（「sip.instance」接点ヘッダーパラメーターから）と「reg-id」コンタクトヘッダーフィールドパラメーターパラメーターの値。レジストラは、コンタクトURI、すべての連絡先ヘッダーフィールドパラメーター、およびパスヘッダーフィールド値をバインディングして保存する必要があります。（コンタクトURIはバインディング比較に使用されていませんが、ターゲットセットを形成するために権威あるプロキシによってまだ必要です。）UACに、サポートされているヘッダーフィールドにアウトバウンドオプションタグ（セクション11.4で定義）が含まれていたことを条件としてください。値レジスタリクエストでは、レジストラは、そのレジスタリクエストへの応答にヘッダーフィールド値を必要とするアウトバウンドオプションタグを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If the UAC has a direct flow with the registrar, the registrar MUST store enough information to uniquely identify the network flow over which the request arrived. For common operating systems with TCP, this would typically be just the handle to the file descriptor where the handle would become invalid if the TCP session was closed. For common operating systems with UDP this would typically be the file descriptor for the local socket that received the request, the local interface, and the IP address and port number of the remote side that sent the request. The registrar MAY store this information by adding itself to the Path header field with an appropriate flow token.",
      "ja": "UACにレジストラとの直接的なフローがある場合、レジストラは、リクエストが届いたネットワークフローを一意に識別するのに十分な情報を保存する必要があります。TCPを備えた一般的なオペレーティングシステムの場合、これは通常、TCPセッションが閉じた場合にハンドルが無効になるファイル記述子のハンドルにすぎません。UDPを備えた一般的なオペレーティングシステムの場合、これは通常、リクエスト、ローカルインターフェイス、およびリクエストを送信したリモート側のIPアドレスとポート番号を受け取ったローカルソケットのファイル記述子になります。レジストラは、適切なフロートークンを使用してパスヘッダーフィールドに自分自身を追加することにより、この情報を保存できます。"
    },
    {
      "indent": 3,
      "text": "If the registrar receives a re-registration for a specific combination of AOR, and instance-id and reg-id values, the registrar MUST update any information that uniquely identifies the network flow over which the request arrived if that information has changed, and SHOULD update the time the binding was last updated.",
      "ja": "レジストラがAORとInstance-IDおよびreg-ID値の特定の組み合わせの再登録を受信した場合、レジストラは、その情報が変更された場合にリクエストが到着したネットワークフローを一意に識別する情報を更新する必要があります。バインディングが最後に更新された時間を更新します。"
    },
    {
      "indent": 3,
      "text": "To be compliant with this specification, registrars that can receive SIP requests directly from a UAC without intervening edge proxies MUST implement the same keep-alive mechanisms as edge proxies (Section 5.4). Registrars with a direct flow with a UA MAY include a Flow-Timer header in a 2xx class registration response that includes the outbound option-tag in the Require header.",
      "ja": "この仕様に準拠するには、介在するエッジプロキシなしでUACから直接SIPリクエストを受信できるレジストラは、エッジプロキシと同じキープアライブメカニズムを実装する必要があります（セクション5.4）。UAを備えた直接フローを備えたレジストラには、2XXクラスの登録応答にフロータイマーヘッダーが含まれる場合があります。"
    },
    {
      "indent": 0,
      "text": "7. Authoritative Proxy Procedures: Forwarding Requests",
      "section_title": true,
      "ja": "7. 権威あるプロキシ手順：転送リクエスト"
    },
    {
      "indent": 3,
      "text": "When a proxy uses the location service to look up a registration binding and then proxies a request to a particular contact, it selects a contact to use normally, with a few additional rules:",
      "ja": "プロキシがロケーションサービスを使用して登録バインディングを検索し、特定の連絡先へのリクエストをプロキシングすると、いくつかの追加のルールを使用して、正常に使用する連絡先を選択します。"
    },
    {
      "indent": 3,
      "text": "o The proxy MUST NOT populate the target set with more than one contact with the same AOR and instance-id at a time.",
      "ja": "o プロキシは、一度に同じAORとInstance-IDと複数の接触でターゲットセットを入力してはなりません。"
    },
    {
      "indent": 3,
      "text": "o If a request for a particular AOR and instance-id fails with a 430 (Flow Failed) response, the proxy SHOULD replace the failed branch with another target (if one is available) with the same AOR and instance-id, but a different reg-id.",
      "ja": "o 特定のAORおよびInstance-IDのリクエストが430（フローの失敗）応答で失敗した場合、プロキシは失敗したブランチを別のターゲット（1つが利用可能な場合）に置き換える必要があります。-id。"
    },
    {
      "indent": 3,
      "text": "o If the proxy receives a final response from a branch other than a 408 (Request Timeout) or a 430 (Flow Failed) response, the proxy MUST NOT forward the same request to another target representing the same AOR and instance-id. The targeted instance has already provided its response.",
      "ja": "o プロキシが408（リクエストタイムアウト）または430（フロー障害）応答以外のブランチから最終的な応答を受信した場合、プロキシは同じリクエストを同じAORとInstance-IDを表す別のターゲットに転送してはなりません。ターゲットインスタンスはすでにその応答を提供しています。"
    },
    {
      "indent": 3,
      "text": "The proxy uses the next-hop target of the message and the value of any stored Path header field vector in the registration binding to decide how to forward and populate the Route header in the request. If the proxy is co-located with the registrar and stored information about the flow to the UA that created the binding, then the proxy MUST send the request over the same 'logical flow' saved with the binding, since that flow is known to deliver data to the specific target UA instance's network flow that was saved with the binding.",
      "ja": "プロキシは、メッセージの次のホップターゲットと、登録バインディング内の保存されたパスヘッダーフィールドベクトルの値を使用して、リクエストのルートヘッダーを転送して入力する方法を決定します。プロキシがレジストラと共同住宅され、バインディングを作成したUAへのフローに関する情報を保存した場合、プロキシはバインディングで保存された同じ「論理フロー」でリクエストを送信する必要があります。バインディングで保存された特定のターゲットUAインスタンスのネットワークフローへのデータ。"
    },
    {
      "indent": 6,
      "text": "Implementation note: Typically this means that for TCP, the request is sent on the same TCP socket that received the REGISTER request. For UDP, the request is sent from the same local IP address and port over which the registration was received, to the same IP address and port from which the REGISTER was received.",
      "ja": "実装注：通常、これはTCPの場合、レジスタリクエストを受け取った同じTCPソケットにリクエストが送信されることを意味します。UDPの場合、リクエストは、登録が受信された同じローカルIPアドレスとポートから、レジスタが受信された同じIPアドレスとポートに送信されます。"
    },
    {
      "indent": 3,
      "text": "If a proxy or registrar receives information from the network that indicates that no future messages will be delivered on a specific flow, then the proxy MUST invalidate all the bindings in the target set that use that flow (regardless of AOR). Examples of this are a TCP socket closing or receiving a destination unreachable ICMP error on a UDP flow. Similarly, if a proxy closes a file descriptor, it MUST invalidate all the bindings in the target set with flows that use that file descriptor.",
      "ja": "プロキシまたはレジストラが特定のフローで将来のメッセージが配信されないことを示すネットワークから情報を受信した場合、プロキシはそのフローを使用するターゲットセットのすべてのバインディングを（AORに関係なく）無効にする必要があります。これの例は、UDPフローで到達不可能なICMPエラーを閉じるか、TCPソケットを閉じたり、受信したりします。同様に、プロキシがファイル記述子を閉じる場合、そのファイル記述子を使用するフローでターゲットセットのすべてのバインディングを無効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "8. STUN Keep-Alive Processing",
      "section_title": true,
      "ja": "8. スタンキープアライブ処理"
    },
    {
      "indent": 3,
      "text": "This section describes changes to the SIP transport layer that allow SIP and STUN [RFC5389] Binding Requests to be mixed over the same flow. This constitutes a new STUN usage. The STUN messages are used to verify that connectivity is still available over a UDP flow, and to provide periodic keep-alives. These STUN keep-alives are always sent to the next SIP hop. STUN messages are not delivered end-to-end.",
      "ja": "このセクションでは、SIPおよびスタン[RFC5389]結合要求を同じフローで混合できるようにするSIP輸送層の変更について説明します。これは、新しいスタン使用量を構成します。スタンメッセージは、接続性がUDPフローでまだ利用可能であることを確認し、周期的なキープアリブを提供するために使用されます。これらのスタンキープアリブは、常に次のSIPホップに送信されます。スタンメッセージはエンドツーエンドで配信されません。"
    },
    {
      "indent": 3,
      "text": "The only STUN messages required by this usage are Binding Requests, Binding Responses, and Binding Error Responses. The UAC sends Binding Requests over the same UDP flow that is used for sending SIP messages. These Binding Requests do not require any STUN attributes. The corresponding Binding Responses do not require any STUN attributes except the XOR-MAPPED-ADDRESS. The UAS, proxy, or registrar responds to a valid Binding Request with a Binding Response that MUST include the XOR-MAPPED-ADDRESS attribute.",
      "ja": "この使用に必要な唯一のスタンメッセージは、拘束力のある要求、拘束力のある応答、および拘束力のあるエラー応答です。UACは、SIPメッセージの送信に使用される同じUDPフローのバインディングリクエストを送信します。これらのバインディングリクエストには、スタン属性は必要ありません。対応する結合応答は、XOR-Mapped-Addressを除いてスタン属性を必要としません。UAS、プロキシ、またはレジストラは、XOR-Mapp-Address属性を含む拘束力のある応答を使用して、有効なバインディングリクエストに応答します。"
    },
    {
      "indent": 3,
      "text": "If a server compliant to this section receives SIP requests on a given interface and UDP port, it MUST also provide a limited version of a STUN server on the same interface and UDP port.",
      "ja": "このセクションに準拠したサーバーが特定のインターフェイスとUDPポートでSIPリクエストを受信する場合、同じインターフェイスとUDPポートでSTUNサーバーの限られたバージョンを提供する必要があります。"
    },
    {
      "indent": 6,
      "text": "Note: It is easy to distinguish STUN and SIP packets sent over UDP, because the first octet of a STUN Binding method has a value of 0 or 1, while the first octet of a SIP message is never a 0 or 1.",
      "ja": "注：STUNバインディング方法の最初のオクテットの値は0または1であり、SIPメッセージの最初のオクテットは0または1ではないため、UDPを介して送信されるStunとSIPパケットを区別するのは簡単です。"
    },
    {
      "indent": 3,
      "text": "Because sending and receiving binary STUN data on the same ports used for SIP is a significant and non-backwards compatible change to RFC 3261, this section requires a number of checks before sending STUN messages to a SIP node. If a SIP node sends STUN requests (for example, due to incorrect configuration) despite these warnings, the node could be blacklisted for UDP traffic.",
      "ja": "SIPに使用される同じポートでバイナリスタンデータを送信および受信することは、RFC 3261への重要かつ非バックワード互換の変更であるため、このセクションでは、SIPノードにスタンメッセージを送信する前に多くのチェックが必要です。SIPノードがこれらの警告にもかかわらずスタン要求を送信する場合（たとえば、誤った構成のため）、これらの警告にもかかわらず、NodeをUDPトラフィック用にブラックリストに登録することができます。"
    },
    {
      "indent": 3,
      "text": "A SIP node MUST NOT send STUN requests over a flow unless it has an explicit indication that the target next-hop SIP server claims to support this specification. UACs MUST NOT use an ambiguous configuration option such as \"Work through NATs?\" or \"Do keep-alives?\" to imply next-hop STUN support. A UAC MAY use the presence of an \"ob\" URI parameter in the Path header in a registration response as an indication that its first edge proxy supports the keep-alives defined in this document.",
      "ja": "SIPノードは、ターゲットネクストホップSIPサーバーがこの仕様をサポートすると主張するという明示的な兆候がない限り、フローに対してスタン要求を送信してはなりません。UACは、「NATを介した作業」などの曖昧な構成オプションを使用してはなりません。または「キープアリーブをしますか？」ネクストホップスタンサポートを暗示する。UACは、最初のエッジプロキシがこのドキュメントで定義されているキープアリブをサポートすることを示すため、登録応答のパスヘッダーに「OB」URIパラメーターの存在を使用できます。"
    },
    {
      "indent": 6,
      "text": "Note: Typically, a SIP node first sends a SIP request and waits to receive a 2xx class response over a flow to a new target destination, before sending any STUN messages. When scheduled for the next NAT refresh, the SIP node sends a STUN request to the target.",
      "ja": "注：通常、SIPノードは最初にSIPリクエストを送信し、スタンメッセージを送信する前に、新しいターゲット宛先へのフローを介して2xxクラスの応答を受信するのを待ちます。次のNATリフレッシュがスケジュールされると、SIPノードはターゲットにスタンリクエストを送信します。"
    },
    {
      "indent": 3,
      "text": "Once a flow is established, failure of a STUN request (including its retransmissions) is considered a failure of the underlying flow. For SIP over UDP flows, if the XOR-MAPPED-ADDRESS returned over the flow changes, this indicates that the underlying connectivity has changed, and is considered a flow failure.",
      "ja": "フローが確立されると、スタンリクエストの失敗（再送信を含む）は、基礎となるフローの障害と見なされます。UDPフローのSIPの場合、XOR-Mapped-Addressがフローの変化に戻った場合、これは基礎となる接続性が変化し、フロー障害と見なされていることを示します。"
    },
    {
      "indent": 3,
      "text": "The SIP keep-alive STUN usage requires no backwards compatibility with [RFC3489].",
      "ja": "SIP Keep-Alive Stun使用は、[RFC3489]との後方互換性を必要としません。"
    },
    {
      "indent": 0,
      "text": "8.1. Use with SigComp",
      "section_title": true,
      "ja": "8.1. Sigcompで使用します"
    },
    {
      "indent": 3,
      "text": "When STUN is used together with SigComp [RFC3320] compressed SIP messages over the same flow, the STUN messages are simply sent uncompressed, \"outside\" of SigComp. This is supported by multiplexing STUN messages with SigComp messages by checking the two topmost bits of the message. These bits are always one for SigComp, or zero for STUN.",
      "ja": "SIGCOMP [RFC3320]と同じフローで圧縮されたSIPメッセージと一緒にSTUNを使用すると、STUNメッセージはSigCompの「外側」の「圧縮なし」に送信されます。これは、メッセージの2つの最上位ビットをチェックすることにより、SigCompメッセージを使用してStunメッセージをマルチプレックスすることでサポートされています。これらのビットは、常にSigcomp用の1つ、またはStunの場合はゼロです。"
    },
    {
      "indent": 6,
      "text": "Note: All SigComp messages contain a prefix (the five most significant bits of the first byte are set to one) that does not occur in UTF-8 [RFC3629] encoded text messages, so for applications that use this encoding (or ASCII encoding) it is possible to multiplex uncompressed application messages and SigComp messages on the same UDP port. The most significant two bits of every STUN Binding method are both zeroes. This, combined with the magic cookie, aids in differentiating STUN packets from other protocols when STUN is multiplexed with other protocols on the same port.",
      "ja": "注：すべてのSIGCOMPメッセージには、UTF-8 [RFC3629]エンコードされたテキストメッセージでは発生しないプレフィックス（最初のバイトの5つの最も重要なビットが1に設定されています）が含まれているため、このエンコード（またはASCIIエンコード）を使用するアプリケーションには同じUDPポートでマルチプレックス解除されていないアプリケーションメッセージとSigCompメッセージが可能です。すべてのスタン結合方法の最も重要な2ビットは、両方ともゼロです。これは、Magic Cookieと組み合わさって、Stunが同じポートの他のプロトコルで多重化された場合、他のプロトコルとスタンパケットの区別を支援します。"
    },
    {
      "indent": 0,
      "text": "9. Example Message Flow",
      "section_title": true,
      "ja": "9. メッセージのフローの例"
    },
    {
      "indent": 3,
      "text": "Below is an example message flow illustrating most of the concepts discussed in this specification. In many cases, Via, Content-Length, and Max-Forwards headers are omitted for brevity and readability.",
      "ja": "以下は、この仕様で説明した概念のほとんどを示すメッセージフローの例です。多くの場合、viaでは、コンテンツレングス、および最大形のヘッダーは、簡潔さと読みやすさのために省略されています。"
    },
    {
      "indent": 3,
      "text": "In these examples, \"EP1\" and \"EP2\" are outbound proxies, and \"Proxy\" is the authoritativeProxy.",
      "ja": "これらの例では、「EP1」と「EP2」はアウトバウンドプロキシであり、「プロキシ」はauthoritiveProxyです。"
    },
    {
      "indent": 3,
      "text": "The section is subdivided into independent calls flows; however, they are structured in sequential order of a hypothetical sequence of call flows.",
      "ja": "セクションは、独立したコールフローに細分されます。ただし、それらは、コールフローの仮想シーケンスの連続的な順序で構成されています。"
    },
    {
      "indent": 0,
      "text": "9.1. Subscription to Configuration Package",
      "section_title": true,
      "ja": "9.1. 構成パッケージのサブスクリプション"
    },
    {
      "indent": 3,
      "text": "If the outbound proxy set is already configured on Bob's UA, then this subsection can be skipped. Otherwise, if the outbound proxy set is learned through the configuration package, Bob's UA sends a SUBSCRIBE request for the UA profile configuration package [CONFIG-FMWK]. This request is a poll (Expires is zero). After receiving the NOTIFY request, Bob's UA fetches the external configuration using HTTPS (not shown) and obtains a configuration file that contains the outbound-proxy-set \"sip:ep1.example.com;lr\" and \"sip:ep2.example.com;lr\".",
      "ja": "アウトバウンドプロキシセットが既にBobのUAで構成されている場合、このサブセクションはスキップできます。それ以外の場合、アウトバウンドプロキシセットが構成パッケージを介して学習された場合、Bob's UAはUAプロファイル構成パッケージ[Config-FMWK]のサブスクライブリクエストを送信します。このリクエストは世論調査です（期限切れはゼロです）。Notifyリクエストを受信した後、BobのUAはHTTPSを使用して外部構成を取得し（表示していません）、アウトバウンドポキシセット「SIP：EP1.EXAMPLE.COM; LR」および「SIP：EP2.Exampleを含む構成ファイルを取得します。com; lr \"。"
    },
    {
      "indent": 4,
      "text": " [----example.com domain-------------------------]\n Bob         EP1   EP2     Proxy             Config\n  |           |     |        |                  |\n1)|SUBSCRIBE->|     |        |                  |\n2)|           |---SUBSCRIBE Event: ua-profile ->|\n3)|           |<--200 OK -----------------------|\n4)|<--200 OK--|     |        |                  |\n5)|           |<--NOTIFY------------------------|\n6)|<--NOTIFY--|     |        |                  |\n7)|---200 OK->|     |        |                  |\n8)|           |---200 OK ---------------------->|\n  |           |     |        |                  |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this example, the DNS server happens to be configured so that sip: example.com resolves to EP1 and EP2.",
      "ja": "この例では、DNSサーバーがたまたま構成されているため、SIP：Example.comがEP1およびEP2に解決します。"
    },
    {
      "indent": 3,
      "text": "Example Message #1:",
      "ja": "例メッセージ＃1："
    },
    {
      "indent": 3,
      "text": "SUBSCRIBE sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com\n  SIP/2.0\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnlsdkdj2\nMax-Forwards: 70\nFrom: <anonymous@example.com>;tag=23324\nTo: <sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com>\nCall-ID: nSz1TWN54x7My0GvpEBj\nCSeq: 1 SUBSCRIBE\nEvent: ua-profile ;profile-type=device\n ;vendor=\"example.com\";model=\"uPhone\";version=\"1.1\"\nExpires: 0\nSupported: path, outbound\nAccept: message/external-body, application/x-uPhone-config\nContact: <sip:192.0.2.2;transport=tcp;ob>\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #2, EP1 adds the following Record-Route header:",
      "ja": "メッセージ＃2で、EP1は次のレコードルートヘッダーを追加します。"
    },
    {
      "indent": 3,
      "text": "Record-Route:\n <sip:GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #5, the configuration server sends a NOTIFY with an external URL for Bob to fetch his configuration. The NOTIFY has a Subscription-State header that ends the subscription.",
      "ja": "メッセージ＃5では、構成サーバーは、BOBが構成を取得するための外部URLを使用して通知を送信します。Notifyには、サブスクリプションを終了するサブスクリプションステートヘッダーがあります。"
    },
    {
      "indent": 3,
      "text": "Message #5",
      "ja": "メッセージ＃5"
    },
    {
      "indent": 3,
      "text": "NOTIFY sip:192.0.2.2;transport=tcp;ob SIP/2.0\nVia: SIP/2.0/TCP 192.0.2.5;branch=z9hG4bKn81dd2\nMax-Forwards: 70\nTo: <anonymous@example.com>;tag=23324\nFrom: <sip:00000000-0000-1000-8000-AABBCCDDEEFF@example.com>;tag=0983\nCall-ID: nSz1TWN54x7My0GvpEBj\nCSeq: 1 NOTIFY\nRoute: <sip:GopIKSsn0oGLPXRdV9BAXpT3coNuiGKV@ep1.example.com;lr>\nSubscription-State: terminated;reason=timeout\nEvent: ua-profile\nContent-Type: message/external-body; access-type=\"URL\"\n ;expiration=\"Thu, 01 Jan 2009 09:00:00 UTC\"\n ;URL=\"http://example.com/uPhone.cfg\"\n ;size=9999;hash=10AB568E91245681AC1B\nContent-Length: 0\n   EP1 receives this NOTIFY request, strips off the Route header,\nextracts the flow-token, calculates the correct flow, and forwards\nthe request (message #6) over that flow to Bob.",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bob's UA fetches the configuration file and learns the outbound proxy set.",
      "ja": "Bob's UAは構成ファイルを取得し、アウトバウンドプロキシセットを学習します。"
    },
    {
      "indent": 0,
      "text": "9.2. Registration",
      "section_title": true,
      "ja": "9.2. 登録"
    },
    {
      "indent": 3,
      "text": "Now that Bob's UA is configured with the outbound-proxy-set whether through configuration or using the configuration framework procedures of the previous section, Bob's UA sends REGISTER requests through each edge proxy in the set. Once the registrations succeed, Bob's UA begins sending CRLF keep-alives about every 2 minutes.",
      "ja": "BobのUAが、構成を介した場合でも、前のセクションの構成フレームワーク手順を使用するかどうかにかかわらず、Autbound-Proxy-Setで構成されたため、Bob's UAはセットの各EDGEプロキシを介してレジスタリクエストを送信します。登録が成功すると、ボブのUAは約2分ごとにCRLF Keep-Alivesの送信を開始します。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n 9)|-REGISTER->|     |        |         |\n10)|           |---REGISTER-->|         |\n11)|           |<----200 OK---|         |\n12)|<-200 OK---|     |        |         |\n13)|----REGISTER---->|        |         |\n14)|           |     |--REG-->|         |\n15)|           |     |<-200---|         |\n16)|<----200 OK------|        |         |\n   |           |     |        |         |\n   |  about 120 seconds later...        |\n   |           |     |        |         |\n17)|--2CRLF--->|     |        |         |\n18)|<--CRLF----|     |        |         |\n19)|------2CRLF----->|        |         |\n20)|<------CRLF------|        |         |\n   |           |     |        |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #9, Bob's UA sends its first registration through the first edge proxy in the outbound-proxy-set by including a loose route. The UA includes an instance-id and reg-id in its Contact header field value. Note the option-tags in the Supported header.",
      "ja": "メッセージ＃9では、Bob's UAは、ルーズルートを含めることにより、アウトバウンドプロキシセットの最初のエッジプロキシを通じて最初の登録を送信します。UAには、コンタクトヘッダーフィールド値にInstance-IDとreg-IDが含まれています。サポートされているヘッダーのオプションタグに注意してください。"
    },
    {
      "indent": 3,
      "text": "Message #9",
      "ja": "メッセージ＃9"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnashds7\nMax-Forwards: 70\nFrom: Bob <sip:bob@example.com>;tag=7F94778B653B\nTo: Bob <sip:bob@example.com>\nCall-ID: 16CB75F21C70\nCSeq: 1 REGISTER\nSupported: path, outbound\nRoute: <sip:ep1.example.com;lr>\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #10 is similar. EP1 removes the Route header field value, decrements Max-Forwards, and adds its Via header field value. Since EP1 is the first edge proxy, it adds a Path header with a flow token and includes the \"ob\" parameter.",
      "ja": "メッセージ＃10は似ています。EP1は、ルートヘッダーフィールド値を削除し、最大値を減らし、ヘッダーフィールド値を介して追加します。EP1はFirst Edgeプロキシであるため、フロートークンを備えたパスヘッダーが追加され、「OB」パラメーターが含まれます。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Since the response to the REGISTER (message #11) contains the outbound option-tag in the Require header field, Bob's UA will know that the registrar used outbound binding rules. The response also contains the currently active Contacts, and the Path for the current registration.",
      "ja": "レジスタ（メッセージ＃11）への応答には、必要ヘッダーフィールドにアウトバウンドオプションタグが含まれているため、ボブのUAはレジストラがアウトバウンドバインディングルールを使用したことを知っています。応答には、現在アクティブな連絡先と、現在の登録のパスも含まれています。"
    },
    {
      "indent": 3,
      "text": "Message #11",
      "ja": "メッセージ＃11"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK\nVia: SIP/2.0/TCP 192.0.2.15;branch=z9hG4bKnuiqisi\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnashds7\nFrom: Bob <sip:bob@example.com>;tag=7F94778B653B\nTo: Bob <sip:bob@example.com>;tag=6AF99445E44A\nCall-ID: 16CB75F21C70\nCSeq: 1 REGISTER\nSupported: path, outbound\nRequire: outbound\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1;expires=3600\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nPath: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob>\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The second registration through EP2 (message #13) is similar except that the Call-ID has changed, the reg-id is 2, and the Route header goes through EP2.",
      "ja": "EP2（メッセージ＃13）を介した2番目の登録は、Call-IDが変更され、reg-IDが2、ルートヘッダーがEP2を通過することを除いて類似しています。"
    },
    {
      "indent": 3,
      "text": "Message #13",
      "ja": "メッセージ＃13"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnqr9bym\nMax-Forwards: 70\nFrom: Bob <sip:bob@example.com>;tag=755285EABDE2\nTo: Bob <sip:bob@example.com>\nCall-ID: E05133BD26DD\nCSeq: 1 REGISTER\nSupported: path, outbound\nRoute: <sip:ep2.example.com;lr>\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=2\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Likewise in message #14, EP2 adds a Path header with flow token and \"ob\" parameter.",
      "ja": "同様に、メッセージ＃14では、EP2はフロートークンと「OB」パラメーターを備えたパスヘッダーを追加します。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #16 tells Bob's UA that outbound registration was successful, and shows both Contacts. Note that only the Path corresponding to the current registration is returned.",
      "ja": "メッセージ＃16は、ボブのUAに、アウトバウンド登録が成功したことを伝え、両方の連絡先を示しています。現在の登録に対応するパスのみが返されることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Message #16",
      "ja": "メッセージ＃16"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK\nVia: SIP/2.0/TCP 192.0.2.2;branch=z9hG4bKnqr9bym\nFrom: Bob <sip:bob@example.com>;tag=755285EABDE2\nTo: Bob <sip:bob@example.com>;tag=49A9AD0B3F6A\nCall-ID: E05133BD26DD\nSupported: path, outbound\nRequire: outbound\nCSeq: 1 REGISTER\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1;expires=3600\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=2;expires=3600\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"\nPath: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob>\nContent-Length: 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.3. Incoming Call and Proxy Crash",
      "section_title": true,
      "ja": "9.3. 着信コールとプロキシクラッシュ"
    },
    {
      "indent": 3,
      "text": "In this example, after registration, EP1 crashes and reboots. Before Bob's UA notices that its flow to EP1 is no longer responding, Alice calls Bob. Bob's authoritative proxy first tries the flow to EP1, but EP1 no longer has a flow to Bob, so it responds with a 430 (Flow Failed) response. The proxy removes the stale registration and tries the next binding for the same instance.",
      "ja": "この例では、登録後、EP1はクラッシュして再起動します。ボブのUAがEP1へのフローがもはや反応していないことに気付く前に、アリスはボブに電話します。Bobの権威あるプロキシは最初にEP1へのフローを試みますが、EP1はBOBへのフローがなくなるため、430（フローが失敗した）応答で応答します。プロキシは古い登録を削除し、同じインスタンスの次のバインディングを試みます。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n   |    CRASH  X     |        |         |\n   |        Reboot   |        |         |\n   |           |     |        |         |\n21)|           |     |        |<-INVITE-|\n22)|           |<---INVITE----|         |\n23)|           |----430------>|         |\n24)|           |     |<-INVITE|         |\n25)|<---INVITE-------|        |         |\n26)|----200 OK------>|        |         |\n27)|           |     |200 OK->|         |\n28)|           |     |        |-200 OK->|\n29)|           |     |<----------ACK----|\n30)|<---ACK----------|        |         |\n   |           |     |        |         |\n31)|           |     |<----------BYE----|\n32)|<---BYE----------|        |         |\n33)|----200 OK------>|        |         |\n34)|           |     |--------200 OK--->|\n   |           |     |        |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #21",
      "ja": "メッセージ＃21"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@example.com SIP/2.0\nTo: Bob <sip:bob@example.com>\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 INVITE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bob's proxy rewrites the Request-URI to the Contact URI used in Bob's registration, and places the path for one of the registrations towards Bob's UA instance into a Route header field. This Route goes through EP1.",
      "ja": "Bobの代理人は、Bobの登録で使用されているURIの連絡先にリクエストURIを書き換え、BobのUAインスタンスへの登録の1つのパスをルートヘッダーフィールドに配置します。このルートはEP1を通過します。"
    },
    {
      "indent": 3,
      "text": "Message #22",
      "ja": "メッセージ＃22"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0 To: Bob <sip:bob@example.com> From: Alice <sip:alice@a.example>;tag=02935 Call-ID: klmvCxVWGp6MxJp2T2mb CSeq: 1 INVITE Route: <sip:VskztcQ/S8p4WPbOnHbuyh5iJvJIW3ib@ep1.example.com;lr;ob> Since EP1 just rebooted, it does not have the flow described in the flow token. It returns a 430 (Flow Failed) response.",
      "ja": "招待SIP：bob@192.0.2.2; Transport = tcp sip/2.0 to：bob <sip：bob@example.com> from：alice <sip：alice@a.example>; tag = 02935 call-id：klmvcxvwgp6mxjp2t2mb cseq：1招待ルート：<sip：vskztcq/s8p4wpbonhbuyh5ijvjiw3ib@ep1.example.com; lr; ob> ep1が再起動したので、フロートークンに記載されているフローはありません。430（フロー不全）応答を返します。"
    },
    {
      "indent": 3,
      "text": "Message #23",
      "ja": ""
    },
    {
      "indent": 3,
      "text": "SIP/2.0 430 Flow Failed\nTo: Bob <sip:bob@example.com>\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 INVITE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The proxy deletes the binding for this path and tries to forward the INVITE again, this time with the path through EP2.",
      "ja": "プロキシは、このパスのバインディングを削除し、今回はEP2を通るパスで招待を再び転送しようとします。"
    },
    {
      "indent": 3,
      "text": "Message #24",
      "ja": "メッセージ＃24"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0\nTo: Bob <sip:bob@example.com>\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 INVITE\nRoute: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #25, EP2 needs to add a Record-Route header field value, so that any subsequent in-dialog messages from Alice's UA arrive at Bob's UA. EP2 can determine it needs to Record-Route since the request is a dialog-forming request and the Route header contained a flow token and an \"ob\" parameter. This Record-Route information is passed back to Alice's UA in the responses (messages #26, 27, and 28).",
      "ja": "メッセージ＃25では、EP2はレコードルートヘッダーフィールド値を追加する必要があります。これにより、アリスのUAからのその後のダイアログメッセージがボブのUAに到着するようにする必要があります。リクエストはダイアログ形成リクエストであり、ルートヘッダーにはフロートークンと「OB」パラメーターが含まれているため、EP2は記録する必要があると判断できます。この記録的な情報は、応答でアリスのUAに渡されます（メッセージ＃26、27、および28）。"
    },
    {
      "indent": 3,
      "text": "Message #25",
      "ja": "メッセージ＃25"
    },
    {
      "indent": 3,
      "text": "INVITE sip:bob@192.0.2.2;transport=tcp SIP/2.0\nTo: Bob <sip:bob@example.com>\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 INVITE\nRecord-Route:\n  <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #26",
      "ja": "メッセージ＃26"
    },
    {
      "indent": 3,
      "text": "SIP/2.0 200 OK\nTo: Bob <sip:bob@example.com>;tag=skduk2\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 INVITE\nRecord-Route:\n  <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "At this point, both UAs have the correct route-set for the dialog. Any subsequent requests in this dialog will route correctly. For example, the ACK request in message #29 is sent from Alice's UA directly to EP2. The BYE request in message #31 uses the same route-set.",
      "ja": "この時点で、両方のUASにはダイアログの正しいルートセットがあります。このダイアログの後続の要求は、正しくルーティングされます。たとえば、メッセージ＃29のACK要求は、AliceのUAからEP2に直接送信されます。メッセージ＃31のさようなら要求は、同じルートセットを使用します。"
    },
    {
      "indent": 3,
      "text": "Message #29",
      "ja": "メッセージ＃29"
    },
    {
      "indent": 3,
      "text": "ACK sip:bob@192.0.2.2;transport=tcp SIP/2.0\nTo: Bob <sip:bob@example.com>;tag=skduk2\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 1 ACK\nRoute: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #31",
      "ja": "メッセージ＃31"
    },
    {
      "indent": 3,
      "text": "BYE sip:bob@192.0.2.2;transport=tcp SIP/2.0\nTo: Bob <sip:bob@example.com>;tag=skduk2\nFrom: Alice <sip:alice@a.example>;tag=02935\nCall-ID: klmvCxVWGp6MxJp2T2mb\nCSeq: 2 BYE\nRoute: <sip:wazHDLdIMtUg6r0I/oRZ15zx3zHE1w1Z@ep2.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.4. Re-Registration",
      "section_title": true,
      "ja": "9.4. 再登録"
    },
    {
      "indent": 3,
      "text": "Somewhat later, Bob's UA sends keep-alives to both its edge proxies, but it discovers that the flow with EP1 failed. Bob's UA re-registers through EP1 using the same reg-id and Call-ID it previously used.",
      "ja": "やや後に、ボブのUAは両方のエッジプロキシにキープアリブを送信しますが、EP1を搭載したフローが失敗したことを発見します。BobのUAは、以前に使用した同じreg-IDとCall-IDを使用してEP1を介して再び登録しています。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n35)|------2CRLF----->|        |         |\n36)|<------CRLF------|        |         |\n37)|--2CRLF->X |     |        |         |\n   |           |     |        |         |\n38)|-REGISTER->|     |        |         |\n39)|           |---REGISTER-->|         |\n40)|           |<----200 OK---|         |\n41)|<-200 OK---|     |        |         |\n   |           |     |        |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #38",
      "ja": "メッセージ＃38"
    },
    {
      "indent": 3,
      "text": "REGISTER sip:example.com SIP/2.0\nFrom: Bob <sip:bob@example.com>;tag=7F94778B653B\nTo: Bob <sip:bob@example.com>\nCall-ID: 16CB75F21C70\nCSeq: 2 REGISTER\nSupported: path, outbound\nRoute: <sip:ep1.example.com;lr>\nContact: <sip:bob@192.0.2.2;transport=tcp>;reg-id=1\n ;+sip.instance=\"<urn:uuid:00000000-0000-1000-8000-AABBCCDDEEFF>\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #39, EP1 inserts a Path header with a new flow token:",
      "ja": "メッセージ＃39では、EP1は新しいフロートークンでパスヘッダーを挿入します。"
    },
    {
      "indent": 3,
      "text": "Path: <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "9.5. Outgoing Call",
      "section_title": true,
      "ja": "9.5. 発信コール"
    },
    {
      "indent": 3,
      "text": "Finally, Bob makes an outgoing call to Alice. Bob's UA includes an \"ob\" parameter in its Contact URI in message #42. EP1 adds a Record-Route with a flow-token in message #43. The route-set is returned to Bob in the response (messages #45, 46, and 47), and either Bob or Alice can send in-dialog requests.",
      "ja": "最後に、ボブはアリスに発信します。ボブのUAには、メッセージ＃42の連絡先URIに「OB」パラメーターが含まれています。EP1は、メッセージ＃43にフロートークンを含むレコードルートを追加します。ルートセットは応答でボブに返され（メッセージ＃45、46、および47）、ボブまたはアリスのいずれかがダイアログ内リクエストを送信できます。"
    },
    {
      "indent": 3,
      "text": "  Bob         EP1   EP2     Proxy     Alice\n   |           |     |        |         |\n42)|--INVITE-->|     |        |         |\n43)|           |---INVITE---->|         |\n44)|           |     |        |-INVITE->|\n45)|           |     |        |<--200---|\n46)|           |<----200 OK---|         |\n47)|<-200 OK---|     |        |         |\n48)|--ACK----->|     |        |         |\n49)|           |-----ACK--------------->|\n   |           |     |        |         |\n50)|-- BYE---->|     |        |         |\n51)|           |-----------BYE--------->|\n52)|           |<----------200 OK-------|\n53)|<--200 OK--|     |        |         |\n   |           |     |        |         |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Message #42",
      "ja": "メッセージ＃42"
    },
    {
      "indent": 3,
      "text": "INVITE sip:alice@a.example SIP/2.0\nFrom: Bob <sip:bob@example.com>;tag=ldw22z\nTo: Alice <sip:alice@a.example>\nCall-ID: 95KGsk2V/Eis9LcpBYy3\nCSeq: 1 INVITE\nRoute: <sip:ep1.example.com;lr>\nContact: <sip:bob@192.0.2.2;transport=tcp;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In message #43, EP1 adds the following Record-Route header.",
      "ja": "メッセージ＃43では、EP1は次のレコードルートヘッダーを追加します。"
    },
    {
      "indent": 3,
      "text": "Record-Route:\n  <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When EP1 receives the BYE (message #50) from Bob's UA, it can tell that the request is an \"outgoing\" request (since the source of the request matches the flow in the flow token) and simply deletes its Route header field value and forwards the request on to Alice's UA.",
      "ja": "EP1がBobのUAからさようなら（メッセージ＃50）を受信すると、リクエストが「発信」要求であることがわかります（リクエストのソースはフロートークンのフローと一致するため）。リクエストをアリスのUAに転送します。"
    },
    {
      "indent": 3,
      "text": "Message #50",
      "ja": "メッセージ＃50"
    },
    {
      "indent": 3,
      "text": "BYE sip:alice@a.example SIP/2.0\nFrom: Bob <sip:bob@example.com>;tag=ldw22z\nTo: Alice <sip:alice@a.example>;tag=plqus8\nCall-ID: 95KGsk2V/Eis9LcpBYy3\nCSeq: 2 BYE\nRoute: <sip:3yJEbr1GYZK9cPYk5Snocez6DzO7w+AX@ep1.example.com;lr>\nContact: <sip:bob@192.0.2.2;transport=tcp;ob>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "10. Grammar",
      "section_title": true,
      "ja": "10. 文法"
    },
    {
      "indent": 3,
      "text": "This specification defines a new header field \"Flow-Timer\", and new Contact header field parameters, \"reg-id\" and \"+sip.instance\". The grammar includes the definitions from [RFC3261]. Flow-Timer is an extension-header from the message-header in the [RFC3261] ABNF.",
      "ja": "この仕様では、新しいヘッダーフィールド「フロータイマー」、および新しいコンタクトヘッダーフィールドパラメーター、「reg-id」および「sip.instance」を定義します。文法には、[RFC3261]の定義が含まれています。Flow-Timerは、[RFC3261] ABNFのメッセージヘッダーの拡張ヘッダーです。"
    },
    {
      "indent": 3,
      "text": "The ABNF [RFC5234] is:",
      "ja": "ABNF [RFC5234]は次のとおりです。"
    },
    {
      "indent": 4,
      "text": "Flow-Timer = \"Flow-Timer\" HCOLON 1*DIGIT",
      "ja": "flow-timer = \"flow-timer\" hcolon 1*桁"
    },
    {
      "indent": 4,
      "text": "contact-params =/ c-p-reg / c-p-instance",
      "ja": "contact-params = / c-p-reg / c-p-instance"
    },
    {
      "indent": 4,
      "text": "c-p-reg        = \"reg-id\" EQUAL 1*DIGIT ; 1 to (2^31 - 1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "c-p-instance   =  \"+sip.instance\" EQUAL\n                  DQUOTE \"<\" instance-val \">\" DQUOTE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "instance-val   = 1*uric ; defined in RFC 3261",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The value of the reg-id MUST NOT be 0 and MUST be less than 2^31.",
      "ja": "reg-idの値は0である必要はなく、2^31未満でなければなりません。"
    },
    {
      "indent": 0,
      "text": "11. IANA Considerations",
      "section_title": true,
      "ja": "11. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "11.1. Flow-Timer Header Field",
      "section_title": true,
      "ja": "11.1. フロータイマーヘッダーフィールド"
    },
    {
      "indent": 3,
      "text": "This specification defines a new SIP header field \"Flow-Timer\" whose syntax is defined in Section 10.",
      "ja": "この仕様では、構文がセクション10で定義されている新しいSIPヘッダーフィールド「フロータイマー」を定義します。"
    },
    {
      "indent": 5,
      "text": "Header Name        compact    Reference\n-----------------  -------    ---------\nFlow-Timer                    [RFC5626]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.2. \"reg-id\" Contact Header Field Parameter",
      "section_title": true,
      "ja": "11.2. 「reg-id」ヘッダーフィールドパラメーターに連絡します"
    },
    {
      "indent": 3,
      "text": "This specification defines a new Contact header field parameter called reg-id in the \"Header Field Parameters and Parameter Values\" sub-registry as per the registry created by [RFC3968]. The syntax is defined in Section 10. The required information is:",
      "ja": "この仕様は、[RFC3968]によって作成されたレジストリに従って、「ヘッダーフィールドパラメーターとパラメーター値」のサブレジストリで、reg-idと呼ばれる新しい連絡先ヘッダーフィールドパラメーターを定義します。構文はセクション10で定義されています。必要な情報は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "                                               Predefined\nHeader Field            Parameter Name         Values      Reference\n----------------------  ---------------------  ----------  ---------\nContact                 reg-id                 No          [RFC5626]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.3. SIP/SIPS URI Parameters",
      "section_title": true,
      "ja": "11.3. SIP/SIPS URIパラメーター"
    },
    {
      "indent": 3,
      "text": "This specification augments the \"SIP/SIPS URI Parameters\" sub-registry as per the registry created by [RFC3969]. The required information is:",
      "ja": "この仕様は、[RFC3969]によって作成されたレジストリに従って、「SIP/SIPS URIパラメーター」サブレジストリを補強します。必要な情報は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Parameter Name     Predefined Values     Reference\n--------------     -----------------     ---------\nob                 No                    [RFC5626]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.4. SIP Option Tag",
      "section_title": true,
      "ja": "11.4. SIPオプションタグ"
    },
    {
      "indent": 3,
      "text": "This specification registers a new SIP option tag, as per the guidelines in Section 27.1 of [RFC3261].",
      "ja": "この仕様は、[RFC3261]のセクション27.1のガイドラインに従って、新しいSIPオプションタグを登録します。"
    },
    {
      "indent": 3,
      "text": "Name: outbound",
      "ja": "名前：アウトバウンド"
    },
    {
      "indent": 3,
      "text": "Description: This option-tag is used to identify UAs and registrars that support extensions for Client-Initiated Connections. A UA places this option in a Supported header to communicate its support for this extension. A registrar places this option-tag in a Require header to indicate to the registering User Agent that the registrar used registrations using the binding rules defined in this extension.",
      "ja": "説明：このオプションタグは、クライアント開始接続の拡張機能をサポートするUASとレジストラを識別するために使用されます。UAは、このオプションをサポートされているヘッダーに配置して、この拡張機能のサポートを伝えます。レジストラは、このオプションタグを、この拡張機能で定義されているバインディングルールを使用してレジストラが登録を使用したことを登録ユーザーエージェントに示すための要求ヘッダーに配置します。"
    },
    {
      "indent": 0,
      "text": "11.5. 430 (Flow Failed) Response Code",
      "section_title": true,
      "ja": "11.5. 430（フロー障害）応答コード"
    },
    {
      "indent": 3,
      "text": "This document registers a new SIP response code (430 Flow Failed), as per the guidelines in Section 27.4 of [RFC3261]. This response code is used by an edge proxy to indicate to the Authoritative Proxy that a specific flow to a UA instance has failed. Other flows to the same instance could still succeed. The Authoritative Proxy SHOULD attempt to forward to another target (flow) with the same instance-id and AOR. Endpoints should never receive a 430 response. If an endpoint receives a 430 response, it should treat it as a 400 (Bad Request) per normal procedures, as in Section 8.1.3.2 of [RFC3261]. This response code is defined by the following information, which has been added to the method and response-code sub-registry under the SIP Parameters registry.",
      "ja": "このドキュメントは、[RFC3261]のセクション27.4のガイドラインに従って、新しいSIP応答コード（430フローが失敗した）を登録します。この応答コードは、UAインスタンスへの特定のフローが失敗したことを権威あるプロキシに示すために、Edgeプロキシによって使用されます。同じインスタンスへの他のフローは、まだ成功する可能性があります。権威あるプロキシは、同じInstance-IDとAORを使用して別のターゲット（フロー）に転送しようとする必要があります。エンドポイントは、430の応答を受け取らないでください。エンドポイントが430の応答を受信する場合、[RFC3261]のセクション8.1.3.2のように、通常の手順ごとに400（悪い要求）として扱う必要があります。この応答コードは、SIPパラメータレジストリの下でメソッドおよび応答コードサブレジストリに追加された次の情報によって定義されます。"
    },
    {
      "indent": 5,
      "text": "Response Code                               Reference\n------------------------------------------  ---------\nRequest Failure 4xx\n  430 Flow Failed                           [RFC5626]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.6. 439 (First Hop Lacks Outbound Support) Response Code",
      "section_title": true,
      "ja": "11.6. 439（最初のホップにはアウトバウンドサポートがありません）応答コード"
    },
    {
      "indent": 3,
      "text": "This document registers a new SIP response code (439 First Hop Lacks Outbound Support), as per the guidelines in Section 27.4 of [RFC3261]. This response code is used by a registrar to indicate that it supports the 'outbound' feature described in this specification, but that the first outbound proxy that the user is attempting to register through does not. Note that this response code is only appropriate in the case that the registering User Agent advertises support for outbound processing by including the outbound option tag in a Supported header field. Proxies MUST NOT send a 439 response to any requests that do not contain a \"reg-id\" parameter and an outbound option tag in a Supported header field. This response code is defined by the following information, which has been added to the method and response-code sub-registry under the SIP Parameters registry.",
      "ja": "このドキュメントは、[RFC3261]のセクション27.4のガイドラインに従って、新しいSIP応答コード（439の最初のホップにはアウトバウンドサポートがありません）を登録します。この応答コードは、この仕様で説明されている「アウトバウンド」機能をサポートしているが、ユーザーが登録しようとしている最初のアウトバウンドプロキシではそうではないことを示すためにレジストラによって使用されます。この応答コードは、登録ユーザーエージェントがサポートされているヘッダーフィールドにアウトバウンドオプションタグを含めることにより、アウトバウンド処理のサポートを宣伝する場合にのみ適切であることに注意してください。プロキシは、「reg-id」パラメーターとサポートされているヘッダーフィールドにアウトバウンドオプションタグを含まない要求に439の応答を送信してはなりません。この応答コードは、SIPパラメータレジストリの下でメソッドおよび応答コードサブレジストリに追加された次の情報によって定義されます。"
    },
    {
      "indent": 5,
      "text": "Response Code                               Reference\n------------------------------------------  ---------\nRequest Failure 4xx\n  439 First Hop Lacks Outbound Support      [RFC&rfc.number;]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "11.7. Media Feature Tag",
      "section_title": true,
      "ja": "11.7. メディア機能タグ"
    },
    {
      "indent": 3,
      "text": "This section registers a new media feature tag, per the procedures defined in [RFC2506]. The tag is placed into the sip tree, which is defined in [RFC3840].",
      "ja": "このセクションでは、[RFC2506]で定義されている手順に従って、新しいメディア機能タグを登録します。タグは、[RFC3840]で定義されているSIPツリーに配置されます。"
    },
    {
      "indent": 3,
      "text": "Media feature tag name: sip.instance",
      "ja": "メディア機能タグ名：sip.instance"
    },
    {
      "indent": 3,
      "text": "ASN.1 Identifier: 23",
      "ja": "ASN.1識別子：23"
    },
    {
      "indent": 3,
      "text": "Summary of the media feature indicated by this tag: This feature tag contains a string containing a URN that indicates a unique identifier associated with the UA instance registering the Contact.",
      "ja": "このタグで示されるメディア機能の概要：この機能タグには、連絡先を登録するUAインスタンスに関連付けられた一意の識別子を示すURNを含む文字列が含まれています。"
    },
    {
      "indent": 3,
      "text": "Values appropriate for use with this feature tag: String (equality relationship).",
      "ja": "この機能タグで使用するのに適した値：string（equality関係）。"
    },
    {
      "indent": 3,
      "text": "The feature tag is intended primarily for use in the following applications, protocols, services, or negotiation mechanisms: This feature tag is most useful in a communications application, for describing the capabilities of a device, such as a phone or PDA.",
      "ja": "機能タグは、主に以下のアプリケーション、プロトコル、サービス、またはネゴシエーションメカニズムで使用するためのものです。この機能タグは、電話やPDAなどのデバイスの機能を説明するために、通信アプリケーションで最も役立ちます。"
    },
    {
      "indent": 3,
      "text": "Examples of typical use: Routing a call to a specific device.",
      "ja": "典型的な使用の例：特定のデバイスへの呼び出しをルーティングします。"
    },
    {
      "indent": 3,
      "text": "Related standards or documents: RFC 5626",
      "ja": "関連標準または文書：RFC 5626"
    },
    {
      "indent": 3,
      "text": "Security Considerations: This media feature tag can be used in ways which affect application behaviors. For example, the SIP caller preferences extension [RFC3841] allows for call routing decisions to be based on the values of these parameters. Therefore, if an attacker can modify the values of this tag, they might be able to affect the behavior of applications. As a result, applications that utilize this media feature tag SHOULD provide a means for ensuring its integrity. Similarly, this feature tag should only be trusted as valid when it comes from the user or User Agent described by the tag. As a result, protocols for conveying this feature tag SHOULD provide a mechanism for guaranteeing authenticity.",
      "ja": "セキュリティ上の考慮事項：このメディア機能タグは、アプリケーションの動作に影響を与える方法で使用できます。たとえば、SIP発信者の設定拡張[RFC3841]により、これらのパラメーターの値に基づいて通話ルーティングの決定が可能になります。したがって、攻撃者がこのタグの値を変更できる場合、アプリケーションの動作に影響を与える可能性があります。その結果、このメディア機能タグを利用するアプリケーションは、その完全性を確保するための手段を提供するはずです。同様に、この機能タグは、タグで説明されているユーザーまたはユーザーエージェントからの場合にのみ有効であると信頼する必要があります。その結果、この機能タグを伝えるためのプロトコルは、信頼性を保証するメカニズムを提供するはずです。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "One of the key security concerns in this work is making sure that an attacker cannot hijack the sessions of a valid user and cause all calls destined to that user to be sent to the attacker. Note that the intent is not to prevent existing active attacks on SIP UDP and TCP traffic, but to ensure that no new attacks are added by introducing the outbound mechanism.",
      "ja": "この作業における主要なセキュリティの懸念の1つは、攻撃者が有効なユーザーのセッションをハイジャックして、そのユーザーが攻撃者に送られるようにするすべての呼び出しを引き起こすことを確認することです。意図は、SIP UDPおよびTCPトラフィックに対する既存のアクティブ攻撃を防ぐことではなく、アウトバウンドメカニズムを導入することで新しい攻撃が追加されないようにすることであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "The simple case is when there are no edge proxies. In this case, the only time an entry can be added to the routing for a given AOR is when the registration succeeds. SIP already protects against attackers being able to successfully register, and this scheme relies on that security. Some implementers have considered the idea of just saving the instance-id without relating it to the AOR with which it registered. This idea will not work because an attacker's UA can impersonate a valid user's instance-id and hijack that user's calls.",
      "ja": "簡単なケースは、エッジプロキシがない場合です。この場合、特定のAORのルーティングにエントリを追加できるのは、登録が成功したときです。SIPはすでに攻撃者が正常に登録できることから保護しており、このスキームはそのセキュリティに依存しています。一部の実装者は、インスタンスIDを登録したAORに関連付けることなく保存するという考えを考えています。攻撃者のUAが有効なユーザーのInstance-IDになりすまして、そのユーザーの呼び出しをハイジャックできるため、このアイデアは機能しません。"
    },
    {
      "indent": 3,
      "text": "The more complex case involves one or more edge proxies. When a UA sends a REGISTER request through an edge proxy on to the registrar, the edge proxy inserts a Path header field value. If the registration is successfully authenticated, the registrar stores the value of the Path header field. Later, when the registrar forwards a request destined for the UA, it copies the stored value of the Path header field into the Route header field of the request and forwards the request to the edge proxy.",
      "ja": "より複雑なケースには、1つ以上のエッジプロキシが含まれます。UAがエッジプロキシを介してレジスタラにレジスタリクエストを送信すると、Edgeプロキシはパスヘッダーフィールド値を挿入します。登録が正常に認証されている場合、レジストラはパスヘッダーフィールドの値を保存します。その後、レジストラがUAに向けられたリクエストを転送すると、パスヘッダーフィールドの保存された値をリクエストのルートヘッダーフィールドにコピーし、リクエストをエッジプロキシに転送します。"
    },
    {
      "indent": 3,
      "text": "The only time an edge proxy will route over a particular flow is when it has received a Route header that has the flow identifier information that it has created. An incoming request would have gotten this information from the registrar. The registrar will only save this information for a given AOR if the registration for the AOR has been successful; and the registration will only be successful if the UA can correctly authenticate. Even if an attacker has spoofed some bad information in the Path header sent to the registrar, the attacker will not be able to get the registrar to accept this information for an AOR that does not belong to the attacker. The registrar will not hand out this bad information to others, and others will not be misled into contacting the attacker.",
      "ja": "エッジプロキシが特定のフローにルーティングするのは、作成したフロー識別子情報を持つルートヘッダーを受信したときだけです。着信リクエストは、レジストラからこの情報を取得していたでしょう。登録官は、AORの登録が成功した場合にのみ、特定のAORに対してこの情報を保存します。また、UAが正しく認証できる場合にのみ登録が成功します。攻撃者がレジストラに送信されたパスヘッダーのいくつかの悪い情報をスプーフィングしたとしても、攻撃者はレジストラに攻撃者に属さないAORのこの情報を受け入れることができません。レジストラはこの悪い情報を他の人に配ることはなく、他の人は攻撃者に連絡することに惑わされません。"
    },
    {
      "indent": 3,
      "text": "The Security Considerations discussed in [RFC3261] and [RFC3327] are also relevant to this document. For the security considerations of generating flow tokens, please also see Section 5.2. A discussion of preventing the avalanche restart problem is in Section 4.5.",
      "ja": "[RFC3261]および[RFC3327]で説明されているセキュリティ上の考慮事項もこのドキュメントに関連しています。フロートークンの生成に関するセキュリティ上の考慮事項については、セクション5.2も参照してください。雪崩の再起動の問題を防ぐことに関する議論は、セクション4.5にあります。"
    },
    {
      "indent": 3,
      "text": "This document does not change the mandatory-to-implement security mechanisms in SIP. User Agents are already required to implement Digest authentication while support of TLS is recommended; proxy servers are already required to implement Digest and TLS.",
      "ja": "このドキュメントは、SIPの必須のセキュリティメカニズムを変更しません。ユーザーエージェントはすでに消化認証を実装する必要がありますが、TLSのサポートをお勧めします。DigestおよびTLSを実装するには、すでにプロキシサーバーが必要です。"
    },
    {
      "indent": 0,
      "text": "13. Operational Notes on Transports",
      "section_title": true,
      "ja": "13. 輸送に関する運用ノート"
    },
    {
      "indent": 3,
      "text": "This entire section is non-normative.",
      "ja": "このセクション全体は非規範的です。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] requires proxies, registrars, and User Agents to implement both TCP and UDP but deployments can chose which transport protocols they want to use. Deployments need to be careful in choosing what transports to use. Many SIP features and extensions, such as large presence notification bodies, result in SIP requests that can be too large to be reasonably transported over UDP. [RFC3261] states that when a request is too large for UDP, the device sending the request attempts to switch over to TCP. It is important to note that when using outbound, this will only work if the UA has formed both UDP and TCP outbound flows. This specification allows the UA to do so, but in most cases it will probably make more sense for the UA to form a TCP outbound connection only, rather than forming both UDP and TCP flows. One of the key reasons that many deployments choose not to use TCP has to do with the difficulty of building proxies that can maintain a very large number of active TCP connections. Many deployments today use SIP in such a way that the messages are small enough that they work over UDP but they can not take advantage of all the functionality SIP offers. Deployments that use only UDP outbound connections are going to fail with sufficiently large SIP messages.",
      "ja": "[RFC3261]は、TCPとUDPの両方を実装するためにプロキシ、レジストラ、およびユーザーエージェントを必要としますが、展開は使用する輸送プロトコルを選択できます。展開は、使用するトランスポートを選択する際に注意する必要があります。大規模な存在通知ボディなどの多くのSIP機能と拡張機能により、SIPリクエストが大きすぎてUDPを介して合理的に輸送できない場合があります。[RFC3261]は、リクエストがUDPに対して大きすぎると、リクエストを送信するデバイスがTCPに切り替えようとすると述べています。アウトバウンドを使用する場合、これはUAがUDPとTCPの両方のアウトバウンドフローを形成した場合にのみ機能することに注意することが重要です。この仕様により、UAはそうすることができますが、ほとんどの場合、UAがUDPフローとTCPフローの両方を形成するのではなく、UAがTCPアウトバウンド接続のみを形成する方が理にかなっているでしょう。多くの展開がTCPを使用しないことを選択する主な理由の1つは、非常に多くのアクティブなTCP接続を維持できるプロキシを構築することの難しさに関係しています。今日の多くの展開は、メッセージがUDPで動作するほど十分に小さくなるような方法でSIPを使用していますが、SIPが提供するすべての機能を利用することはできません。UDPアウトバウンド接続のみを使用する展開は、十分に大きなSIPメッセージで失敗するでしょう。"
    },
    {
      "indent": 0,
      "text": "14. Requirements",
      "section_title": true,
      "ja": "14. 要件"
    },
    {
      "indent": 3,
      "text": "This specification was developed to meet the following requirements:",
      "ja": "この仕様は、次の要件を満たすために開発されました。"
    },
    {
      "indent": 3,
      "text": "1. Must be able to detect that a UA supports these mechanisms.",
      "ja": "1. UAがこれらのメカニズムをサポートしていることを検出できる必要があります。"
    },
    {
      "indent": 3,
      "text": "2. Support UAs behind NATs.",
      "ja": "2. Natsの背後にあるUASをサポートします。"
    },
    {
      "indent": 3,
      "text": "3. Support TLS to a UA without a stable DNS name or IP address.",
      "ja": "3. 安定したDNS名またはIPアドレスなしでUAにTLSをサポートします。"
    },
    {
      "indent": 3,
      "text": "4. Detect failure of a connection and be able to correct for this.",
      "ja": "4. 接続の障害を検出し、これを修正できるようにします。"
    },
    {
      "indent": 3,
      "text": "5. Support many UAs simultaneously rebooting.",
      "ja": "5. 多くのUASを同時に再起動します。"
    },
    {
      "indent": 3,
      "text": "6. Support a NAT rebooting or resetting.",
      "ja": "6. NATの再起動またはリセットをサポートします。"
    },
    {
      "indent": 3,
      "text": "7. Minimize initial startup load on a proxy.",
      "ja": "7. プロキシの初期起動負荷を最小限に抑えます。"
    },
    {
      "indent": 3,
      "text": "8. Support architectures with edge proxies.",
      "ja": "8. エッジプロキシを備えたサポートアーキテクチャ。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgments",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "Francois Audet acted as document shepherd for this document, tracking hundreds of comments and incorporating many grammatical fixes as well as prodding the editors to \"get on with it\". Jonathan Rosenberg, Erkki Koivusalo, and Byron Campen provided many comments and useful text. Dave Oran came up with the idea of using the most recent registration first in the proxy. Alan Hawrylyshen co-authored the document that formed the initial text of this specification. Additionally, many of the concepts here originated at a connection reuse meeting at IETF 60 that included the authors, Jon Peterson, Jonathan Rosenberg, Alan Hawrylyshen, and Paul Kyzivat. The TCP design team consisting of Chris Boulton, Scott Lawrence, Rajnish Jain, Vijay K. Gurbani, and Ganesh Jayadevan provided input and text. Nils Ohlmeier provided many fixes and initial implementation experience. In addition, thanks to the following folks for useful comments: Francois Audet, Flemming Andreasen, Mike Hammer, Dan Wing, Srivatsa Srinivasan, Dale Worely, Juha Heinanen, Eric Rescorla, Lyndsay Campbell, Christer Holmberg, Kevin Johns, Jeroen van Bemmel, Derek MacDonald, Dean Willis, and Robert Sparks.",
      "ja": "Francois Audetは、この文書のドキュメントシェパードとして行動し、何百ものコメントを追跡し、多くの文法的な修正を組み込み、編集者に「それに取り組む」ように命じました。Jonathan Rosenberg、Erkki Koivusalo、およびByron Campenは、多くのコメントと有用なテキストを提供しました。デイブ・オランは、プロキシで最初に最新の登録を使用するというアイデアを思いつきました。Alan Hawrylyshenは、この仕様の最初のテキストを形成したドキュメントを共著しました。さらに、ここでの概念の多くは、著者、ジョン・ピーターソン、ジョナサン・ローゼンバーグ、アラン・ホーリー・シェン、ポール・キジバットを含むIETF 60での接続再利用会議で始まりました。Chris Boulton、Scott Lawrence、Rajnish Jain、Vijay K. Gurbani、Ganesh Jayadevanが入力とテキストを提供するTCPデザインチーム。Nils Ohlmeierは、多くの修正と初期実装の経験を提供しました。さらに、有用なコメントについては、次の人々に感謝します：フランソワ・オーデット、フレミング・アンドレアセン、マイク・ハンマー、ダン・ウィング、スリバツサ・スリニバサン、デール・ウーリー、ジュハ・ヘイナネン、エリック・レスコルラ、リンセイ・キャンベル、クリスター・ホルムバーグ、ケビン・ジョンズ、ジェロエン・ヴァン・ベメル、デレクマクドナルド、ディーン・ウィリス、ロバート・スパークス。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2141] Moats, R., \"URN Syntax\", RFC 2141, May 1997.",
      "ja": "[RFC2141] Moats、R。、「Urn Syntax」、RFC 2141、1997年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC2506] Holtman, K., Mutz, A., and T. Hardie, \"Media Feature Tag Registration Procedure\", BCP 31, RFC 2506, March 1999.",
      "ja": "[RFC2506] Holtman、K.、Mutz、A。、およびT. Hardie、「メディア機能タグ登録手順」、BCP 31、RFC 2506、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SESSION INTIANIATION Protocol」、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3263] Rosenberg, J. and H. Schulzrinne, \"Session Initiation Protocol (SIP): Locating SIP Servers\", RFC 3263, June 2002.",
      "ja": "[RFC3263] Rosenberg、J。およびH. Schulzrinne、「セッション開始プロトコル（SIP）：SIPサーバーの位置」、RFC 3263、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3327] Willis, D. and B. Hoeneisen, \"Session Initiation Protocol (SIP) Extension Header Field for Registering Non-Adjacent Contacts\", RFC 3327, December 2002.",
      "ja": "[RFC3327] Willis、D。およびB. Hoeneisen、「Addjacentコンタクトを登録するためのセッション開始プロトコル（SIP）拡張ヘッダーフィールド」、RFC 3327、2002年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3581] Rosenberg, J. and H. Schulzrinne, \"An Extension to the Session Initiation Protocol (SIP) for Symmetric Response Routing\", RFC 3581, August 2003.",
      "ja": "[RFC3581] Rosenberg、J。およびH. Schulzrinne、「対称応答ルーティングのセッション開始プロトコル（SIP）の拡張」、RFC 3581、2003年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3629] Yergeau, F., \"UTF-8, a transformation format of ISO 10646\", STD 63, RFC 3629, November 2003.",
      "ja": "[RFC3629] Yergeau、F。、「UTF-8、ISO 10646の変換形式」、STD 63、RFC 3629、2003年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3840] Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"Indicating User Agent Capabilities in the Session Initiation Protocol (SIP)\", RFC 3840, August 2004.",
      "ja": "[RFC3840] Rosenberg、J.、Schulzrinne、H。、およびP. Kyzivat、「セッション開始プロトコル（SIP）のユーザーエージェント機能を示す」、RFC 3840、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3841] Rosenberg, J., Schulzrinne, H., and P. Kyzivat, \"Caller Preferences for the Session Initiation Protocol (SIP)\", RFC 3841, August 2004.",
      "ja": "[RFC3841] Rosenberg、J.、Schulzrinne、H。、およびP. Kyzivat、「セッション開始プロトコル（SIP）の発信者の好み」、RFC 3841、2004年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3968] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Header Field Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 98, RFC 3968, December 2004.",
      "ja": "[RFC3968] Camarillo、G。、「インターネットは、セッション開始プロトコル（SIP）の番号が割り当てられたヘッダーフィールドパラメーターレジストリ」、BCP 98、RFC 3968、2004年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC3969] Camarillo, G., \"The Internet Assigned Number Authority (IANA) Uniform Resource Identifier (URI) Parameter Registry for the Session Initiation Protocol (SIP)\", BCP 99, RFC 3969, December 2004.",
      "ja": "[RFC3969] Camarillo、G。、「インターネットは、セッション開始プロトコル（SIP）の数字権権（IANA）のユニフォームリソース識別子（URI）パラメーターレジストリ」、BCP 99、RFC 3969、2004年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, July 2005.",
      "ja": "[RFC4122] Leach、P.、Mealling、M。、およびR. Salz、「普遍的にユニークな識別子（UUID）URNネームスペース」、RFC 4122、2005年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC5234] Crocker, D. and P. Overell, \"Augmented BNF for Syntax Specifications: ABNF\", STD 68, RFC 5234, January 2008.",
      "ja": "[RFC5234] Crocker、D。およびP. Overell、「構文仕様のためのBNFの増強：ABNF」、STD 68、RFC 5234、2008年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC5389] Rosenberg, J., Mahy, R., Matthews, P., and D. Wing, \"Session Traversal Utilities for NAT (STUN)\", RFC 5389, October 2008.",
      "ja": "[RFC5389] Rosenberg、J.、Mahy、R.、Matthews、P。、およびD. Wing、「NATのセッショントラバーサルユーティリティ（STUN）」、RFC 5389、2008年10月。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CONFIG-FMWK] Petrie, D. and S. Channabasappa, Ed., \"A Framework for Session Initiation Protocol User Agent Profile Delivery\", Work in Progress, February 2008.",
      "ja": "[config-fmwk] Petrie、D。and S. Channabasappa、ed。、「セッション開始プロトコルユーザーエージェントプロファイル配信のフレームワーク」、2008年2月の作業。"
    },
    {
      "indent": 3,
      "text": "[NAT-SCEN] Boulton, C., Rosenberg, J., Camarillo, G., and F. Audet, \"Best Current Practices for NAT Traversal for Client-Server SIP\", Work in Progress, September 2008.",
      "ja": "[Nat-scen] Boulton、C.、Rosenberg、J.、Camarillo、G。、およびF. Audet、「クライアントサーバーSIPのNat Traversalの最良の現在のプラクティス」、2008年9月に進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768] POSTEL、J。、「ユーザーデータグラムプロトコル」、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1035] Mockapetris, P., \"Domain names - implementation and specification\", STD 13, RFC 1035, November 1987.",
      "ja": "[RFC1035] Mockapetris、P。、「ドメイン名 - 実装と仕様」、STD 13、RFC 1035、1987年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, February 1997.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. CaNetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、1997年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC2131] Droms, R., \"Dynamic Host Configuration Protocol\", RFC 2131, March 1997.",
      "ja": "[RFC2131] DROMS、R。、「動的ホスト構成プロトコル」、RFC 2131、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2782] Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for specifying the location of services (DNS SRV)\", RFC 2782, February 2000.",
      "ja": "[RFC2782] Gulbrandsen、A.、Vixie、P。、およびL. Esibov、「サービスの場所を指定するためのDNS RR（DNS SRV）」、RFC 2782、2000年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3320] Price, R., Bormann, C., Christoffersson, J., Hannu, H., Liu, Z., and J. Rosenberg, \"Signaling Compression (SigComp)\", RFC 3320, January 2003.",
      "ja": "[RFC3320] Price、R.、Bormann、C.、Christoffersson、J.、Hannu、H.、Liu、Z。、およびJ. Rosenberg、「Signaling Compression（Sigcomp）」、RFC 3320、2003年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3489] Rosenberg, J., Weinberger, J., Huitema, C., and R. Mahy, \"STUN - Simple Traversal of User Datagram Protocol (UDP) Through Network Address Translators (NATs)\", RFC 3489, March 2003.",
      "ja": "[RFC3489] Rosenberg、J.、Weinberger、J.、Huitema、C。、およびR. Mahy、「スタン - ネットワークアドレス翻訳者（NAT）を介したユーザーデータグラムプロトコル（UDP）の単純なトラバーサル」、RFC 3489、2003年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340] Kohler、E.、Handley、M。、およびS. Floyd、「Datagram混雑制御プロトコル（DCCP）」、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4648] Josefsson, S., \"The Base16, Base32, and Base64 Data Encodings\", RFC 4648, October 2006.",
      "ja": "[RFC4648] Josefsson、S。、「Base16、Base32、およびBase64データエンコーディング」、RFC 4648、2006年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960] Stewart、R。、「Stream Control Transmission Protocol」、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security (TLS) Protocol Version 1.2\", RFC 5246, August 2008.",
      "ja": "[RFC5246] Dierks、T。およびE. Rescorla、「The Transport Layer Security（TLS）プロトコルバージョン1.2」、RFC 5246、2008年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5627] Rosenberg, J., \"Obtaining and Using Globally Routable User Agent URIs (GRUUs) in the Session Initiation Protocol (SIP)\", RFC 5627, October 2009.",
      "ja": "[RFC5627] Rosenberg、J。、「セッション開始プロトコル（SIP）でグローバルにルーティング可能なユーザーエージェントURIS（Gruus）の取得と使用」、RFC 5627、2009年10月。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Default Flow Registration Backoff Times",
      "section_title": true,
      "ja": "付録A. デフォルトのフロー登録バックオフタイム"
    },
    {
      "indent": 3,
      "text": "The base-time used for the flow re-registration backoff times described in Section 4.5 are configurable. If the base-time-all-fail value is set to the default of 30 seconds and the base-time-not-failed value is set to the default of 90 seconds, the following table shows the resulting amount of time the UA will wait to retry registration.",
      "ja": "セクション4.5で説明されているフローの再登録バックオフ時間に使用される基本時間は構成可能です。ベースタイムのすべての爪の値がデフォルトの30秒に設定され、ベースタイムなしの値が90秒のデフォルトに設定されている場合、次の表は、UAが待機する時間を示しています登録を再試行します。"
    },
    {
      "indent": 5,
      "text": "+-------------------+--------------------+---------------------+\n| # of reg failures | all flows unusable | > 1 non-failed flow |\n+-------------------+--------------------+---------------------+\n| 0                 | 0 s                | 0 s                 |\n| 1                 | 30-60 s            | 90-180 s            |\n| 2                 | 1-2 min            | 3-6 min             |\n| 3                 | 2-4 min            | 6-12 min            |\n| 4                 | 4-8 min            | 12-24 min           |\n| 5                 | 8-16 min           | 15-30 min           |\n| 6 or more         | 15-30 min          | 15-30 min           |\n+-------------------+--------------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Appendix B. ABNF",
      "section_title": true,
      "ja": "付録B. abnf"
    },
    {
      "indent": 3,
      "text": "This appendix contains the ABNF defined earlier in this document.",
      "ja": "この付録には、このドキュメントで前述したABNFが含まれています。"
    },
    {
      "indent": 6,
      "text": "CRLF = CR LF\ndouble-CRLF = CR LF CR LF\nCR = %x0D\nLF = %x0A",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Flow-Timer = \"Flow-Timer\" HCOLON 1*DIGIT",
      "ja": "flow-timer = \"flow-timer\" hcolon 1*桁"
    },
    {
      "indent": 6,
      "text": "contact-params =/ c-p-reg / c-p-instance",
      "ja": "contact-params = / c-p-reg / c-p-instance"
    },
    {
      "indent": 6,
      "text": "c-p-reg        = \"reg-id\" EQUAL 1*DIGIT ; 1 to (2^31 - 1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "c-p-instance   =  \"+sip.instance\" EQUAL\n                  DQUOTE \"<\" instance-val \">\" DQUOTE",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "instance-val   = 1*uric ; defined in RFC 3261",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Cullen Jennings (editor) Cisco Systems 170 West Tasman Drive Mailstop SJC-21/2 San Jose, CA 95134 USA",
      "ja": "Cullen Jennings（編集者）Cisco Systems 170 West Tasman Drive Mailstop SJC-21/2 San Jose、CA 95134 USA"
    },
    {
      "indent": 3,
      "text": "Phone: +1 408 902-3341\nEMail: fluffy@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Rohan Mahy (editor) Unaffiliated",
      "ja": "Rohan Mahy（編集者）無所有"
    },
    {
      "indent": 3,
      "text": "EMail: rohan@ekabal.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Francois Audet (editor) Skype Labs",
      "ja": "Francois Audet（編集者）Skype Labs"
    },
    {
      "indent": 3,
      "text": "EMail: francois.audet@skypelabs.com",
      "raw": true,
      "ja": ""
    }
  ]
}