{
  "title": {
    "text": "RFC 5405 - Unicast UDP Usage Guidelines for Application Designers",
    "ja": "RFC 5405 - アプリケーションデザイナーのユニキャストUDP使用ガイドライン"
  },
  "number": 5405,
  "created_at": "2023-03-26 19:18:06.510715+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          L. Eggert\nRequest for Comments: 5405                                         Nokia\nBCP: 145                                                    G. Fairhurst\nCategory: Best Current Practice                   University of Aberdeen\n                                                           November 2008",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "Unicast UDP Usage Guidelines for Application Designers",
      "ja": "アプリケーションデザイナーのユニキャストUDP使用ガイドライン"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネットの最良のプラクティスを指定し、改善のための議論と提案を要求します。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2008 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2008 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/ license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/ license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "The User Datagram Protocol (UDP) provides a minimal message-passing transport that has no inherent congestion control mechanisms. Because congestion control is critical to the stable operation of the Internet, applications and upper-layer protocols that choose to use UDP as an Internet transport must employ mechanisms to prevent congestion collapse and to establish some degree of fairness with concurrent traffic. This document provides guidelines on the use of UDP for the designers of unicast applications and upper-layer protocols. Congestion control guidelines are a primary focus, but the document also provides guidance on other topics, including message sizes, reliability, checksums, and middlebox traversal.",
      "ja": "ユーザーデータグラムプロトコル（UDP）は、固有の輻輳制御メカニズムを持たない最小限のメッセージパストランスポートを提供します。混雑制御はインターネットの安定した動作にとって重要であるため、UDPをインターネット輸送として使用することを選択したアプリケーションと上層層プロトコルは、混雑の崩壊を防ぎ、同時トラフィックである程度の公平性を確立するためにメカニズムを採用する必要があります。このドキュメントは、ユニキャストアプリケーションと上層層プロトコルの設計者にUDPの使用に関するガイドラインを提供します。混雑制御ガイドラインは主要な焦点ですが、このドキュメントは、メッセージサイズ、信頼性、チェックサム、ミドルボックストラバーサルなど、他のトピックに関するガイダンスも提供します。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n2.  Terminology  . . . . . . . . . . . . . . . . . . . . . . . . .  5\n3.  UDP Usage Guidelines . . . . . . . . . . . . . . . . . . . . .  5\n  3.1.  Congestion Control Guidelines  . . . . . . . . . . . . . .  6\n  3.2.  Message Size Guidelines  . . . . . . . . . . . . . . . . . 11\n  3.3.  Reliability Guidelines . . . . . . . . . . . . . . . . . . 12\n  3.4.  Checksum Guidelines  . . . . . . . . . . . . . . . . . . . 13\n  3.5.  Middlebox Traversal Guidelines . . . . . . . . . . . . . . 15\n  3.6.  Programming Guidelines . . . . . . . . . . . . . . . . . . 17\n  3.7.  ICMP Guidelines  . . . . . . . . . . . . . . . . . . . . . 18\n4.  Security Considerations  . . . . . . . . . . . . . . . . . . . 19\n5.  Summary  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n6.  Acknowledgments  . . . . . . . . . . . . . . . . . . . . . . . 22\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 22\n  7.1.  Normative References . . . . . . . . . . . . . . . . . . . 22\n  7.2.  Informative References . . . . . . . . . . . . . . . . . . 23",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "The User Datagram Protocol (UDP) [RFC0768] provides a minimal, unreliable, best-effort, message-passing transport to applications and upper-layer protocols (both simply called \"applications\" in the remainder of this document). Compared to other transport protocols, UDP and its UDP-Lite variant [RFC3828] are unique in that they do not establish end-to-end connections between communicating end systems. UDP communication consequently does not incur connection establishment and teardown overheads, and there is minimal associated end system state. Because of these characteristics, UDP can offer a very efficient communication transport to some applications.",
      "ja": "ユーザーデータグラムプロトコル（UDP）[RFC0768]は、アプリケーションと上層層プロトコルへの最小限の、信頼性の低い、ベストエフォルト、メッセージパストランスポート（このドキュメントの残りの「アプリケーション」と単純に呼ばれる）を提供します。他の輸送プロトコルと比較して、UDPとそのUDP-Liteバリアント[RFC3828]は、エンドシステムの通信間でエンドツーエンドの接続を確立しないという点でユニークです。したがって、UDP通信は接続の確立と分解のオーバーヘッドを負担せず、関連するエンドシステム状態は最小限です。これらの特性により、UDPは一部のアプリケーションへの非常に効率的な通信輸送を提供できます。"
    },
    {
      "indent": 3,
      "text": "A second unique characteristic of UDP is that it provides no inherent congestion control mechanisms. On many platforms, applications can send UDP datagrams at the line rate of the link interface, which is often much greater than the available path capacity, and doing so contributes to congestion along the path. [RFC2914] describes the best current practice for congestion control in the Internet. It identifies two major reasons why congestion control mechanisms are critical for the stable operation of the Internet:",
      "ja": "UDPの2番目のユニークな特徴は、固有の混雑制御メカニズムを提供しないことです。多くのプラットフォームでは、アプリケーションはリンクインターフェイスのラインレートでUDPデータグラムを送信できます。これは、利用可能なパス容量よりもはるかに大きいことが多く、パスに沿った輻輳に貢献します。[RFC2914]は、インターネットでの混雑制御の最良の現在の慣行について説明しています。それは、インターネットの安定した動作に輻輳制御メカニズムが重要である2つの主要な理由を特定します。"
    },
    {
      "indent": 3,
      "text": "1. The prevention of congestion collapse, i.e., a state where an increase in network load results in a decrease in useful work done by the network.",
      "ja": "1. 混雑の崩壊の防止、つまり、ネットワーク負荷の増加がネットワークによって行われる有用な作業の減少をもたらす状態です。"
    },
    {
      "indent": 3,
      "text": "2. The establishment of a degree of fairness, i.e., allowing multiple flows to share the capacity of a path reasonably equitably.",
      "ja": "2. ある程度の公平性の確立、つまり、複数のフローが合理的に公平にパスの能力を共有できるようにすることができます。"
    },
    {
      "indent": 3,
      "text": "Because UDP itself provides no congestion control mechanisms, it is up to the applications that use UDP for Internet communication to employ suitable mechanisms to prevent congestion collapse and establish a degree of fairness. [RFC2309] discusses the dangers of congestion-unresponsive flows and states that \"all UDP-based streaming applications should incorporate effective congestion avoidance mechanisms\". This is an important requirement, even for applications that do not use UDP for streaming. In addition, congestion-controlled transmission is of benefit to an application itself, because it can reduce self-induced packet loss, minimize retransmissions, and hence reduce delays. Congestion control is essential even at relatively slow transmission rates. For example, an application that generates five 1500-byte UDP datagrams in one second can already exceed the capacity of a 56 Kb/s path. For applications that can operate at higher, potentially unbounded data rates, congestion control becomes vital to prevent congestion collapse and establish some degree of fairness. Section 3 describes a number of simple guidelines for the designers of such applications.",
      "ja": "UDP自体は混雑制御メカニズムを提供していないため、インターネット通信にUDPを使用して適切なメカニズムを使用して、輻輳崩壊を防ぎ、ある程度の公平性を確立するアプリケーション次第です。[RFC2309]は、うっ血と応答性のある流れの危険性について議論し、「すべてのUDPベースのストリーミングアプリケーションには効果的な混雑回避メカニズムが組み込まれるべきである」と述べています。これは、ストリーミングにUDPを使用しないアプリケーションであっても、重要な要件です。さらに、自己誘発パケットの損失を減らし、再送信を最小限に抑え、したがって遅延を減らすことができるため、輻輳制御伝送自体にとって有益です。渋滞制御は、比較的遅い伝送速度でも不可欠です。たとえば、1秒で5つの1500バイトのUDPデータグラムを生成するアプリケーションは、すでに56 kb/sのパスの容量を超えることができます。潜在的に潜在的に無制限のデータレートで動作できるアプリケーションの場合、混雑制御は輻輳崩壊を防ぎ、ある程度の公平性を確立するために不可欠になります。セクション3では、このようなアプリケーションの設計者向けの多くの簡単なガイドラインについて説明します。"
    },
    {
      "indent": 3,
      "text": "A UDP datagram is carried in a single IP packet and is hence limited to a maximum payload of 65,507 bytes for IPv4 and 65,527 bytes for IPv6. The transmission of large IP packets usually requires IP fragmentation. Fragmentation decreases communication reliability and efficiency and should be avoided. IPv6 allows the option of transmitting large packets (\"jumbograms\") without fragmentation when all link layers along the path support this [RFC2675]. Some of the guidelines in Section 3 describe how applications should determine appropriate message sizes. Other sections of this document provide guidance on reliability, checksums, and middlebox traversal.",
      "ja": "UDPデータグラムは単一のIPパケットで運ばれるため、IPv4の場合は65,507バイト、IPv6で65,527バイトの最大ペイロードに制限されています。大規模なIPパケットの送信には通常、IP断片化が必要です。断片化により、コミュニケーションの信頼性と効率が低下し、避ける必要があります。IPv6は、パスに沿ったすべてのリンク層がこの[RFC2675]をサポートする場合、フラグメンテーションなしで大きなパケット（「ジャンボグラム」）を送信するオプションを許可します。セクション3のガイドラインの一部は、アプリケーションが適切なメッセージサイズを決定する方法について説明しています。このドキュメントの他のセクションは、信頼性、チェックサム、およびミドルボックストラバーサルに関するガイダンスを提供します。"
    },
    {
      "indent": 3,
      "text": "This document provides guidelines and recommendations. Although most unicast UDP applications are expected to follow these guidelines, there do exist valid reasons why a specific application may decide not to follow a given guideline. In such cases, it is RECOMMENDED that the application designers document the rationale for their design choice in the technical specification of their application or protocol.",
      "ja": "このドキュメントは、ガイドラインと推奨事項を提供します。ほとんどのユニキャストUDPアプリケーションはこれらのガイドラインに従うことが期待されていますが、特定のアプリケーションが特定のガイドラインに従わないことを決定する可能性がある正当な理由があります。そのような場合、アプリケーションデザイナーは、アプリケーションまたはプロトコルの技術的仕様における設計選択の理論的根拠を文書化することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "This document provides guidelines to designers of applications that use UDP for unicast transmission, which is the most common case. Specialized classes of applications use UDP for IP multicast [RFC1112], broadcast [RFC0919], or anycast [RFC1546] transmissions. The design of such specialized applications requires expertise that goes beyond the simple, unicast-specific guidelines given in this document. Multicast and broadcast senders may transmit to multiple receivers across potentially very heterogeneous paths at the same time, which significantly complicates congestion control, flow control, and reliability mechanisms. The IETF has defined a reliable multicast framework [RFC3048] and several building blocks to aid the designers of multicast applications, such as [RFC3738] or [RFC4654]. Anycast senders must be aware that successive messages sent to the same anycast IP address may be delivered to different anycast nodes, i.e., arrive at different locations in the topology. It is not intended that the guidelines in this document apply to multicast, broadcast, or anycast applications that use UDP.",
      "ja": "このドキュメントは、ユニキャスト送信にUDPを使用するアプリケーションの設計者にガイドラインを提供します。これは最も一般的なケースです。アプリケーションの特殊なクラスは、IPマルチキャスト[RFC1112]、放送[RFC0919]、またはAnycast [RFC1546]送信にUDPを使用します。このような専門的なアプリケーションの設計には、このドキュメントに記載されている単純でユニキャスト固有のガイドラインを超える専門知識が必要です。マルチキャストおよびブロードキャスト送信者は、潜在的に非常に不均一なパスを越えて複数の受信機に同時に送信する場合があり、混雑制御、フロー制御、および信頼性メカニズムを大幅に複雑にします。IETFは、[RFC3738]や[RFC4654]などのマルチキャストアプリケーションの設計者を支援するために、信頼性の高いマルチキャストフレームワーク[RFC3048]といくつかのビルディングブロックを定義しました。Anycast送信者は、同じAnycast IPアドレスに送信された連続したメッセージが異なるAnycastノードに配信される可能性があることを認識している必要があります。つまり、トポロジの異なる場所に到着します。このドキュメントのガイドラインが、UDPを使用するマルチキャスト、放送、またはAnycastアプリケーションに適用されることを意図していません。"
    },
    {
      "indent": 3,
      "text": "Finally, although this document specifically refers to unicast applications that use UDP, the spirit of some of its guidelines also applies to other message-passing applications and protocols (specifically on the topics of congestion control, message sizes, and reliability). Examples include signaling or control applications that choose to run directly over IP by registering their own IP protocol number with IANA. This document may provide useful background reading to the designers of such applications and protocols.",
      "ja": "最後に、このドキュメントはUDPを使用するユニキャストアプリケーションを具体的に言及していますが、そのガイドラインのいくつかの精神は、他のメッセージ通過アプリケーションとプロトコルにも適用されます（特に混雑制御、メッセージサイズ、信頼性のトピックに）。例には、IANAに独自のIPプロトコル番号を登録することにより、IPを直接実行することを選択するシグナリングまたは制御アプリケーションが含まれます。このドキュメントは、そのようなアプリケーションとプロトコルの設計者に有用な背景読み取りを提供する場合があります。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, RFC 2119 [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「「しない」、「そうでない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、BCP 14、RFC 2119 [RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "3. UDP Usage Guidelines",
      "section_title": true,
      "ja": "3. UDP使用ガイドライン"
    },
    {
      "indent": 3,
      "text": "Internet paths can have widely varying characteristics, including transmission delays, available bandwidths, congestion levels, reordering probabilities, supported message sizes, or loss rates. Furthermore, the same Internet path can have very different conditions over time. Consequently, applications that may be used on the Internet MUST NOT make assumptions about specific path characteristics. They MUST instead use mechanisms that let them operate safely under very different path conditions. Typically, this requires conservatively probing the current conditions of the Internet path they communicate over to establish a transmission behavior that it can sustain and that is reasonably fair to other traffic sharing the path.",
      "ja": "インターネットパスには、送信の遅延、利用可能な帯域幅、うっ血レベル、並べ替え確率、サポートされているメッセージサイズ、または損失率など、大きくさまざまな特性があります。さらに、同じインターネットパスは、時間の経過とともに非常に異なる条件を持つことができます。したがって、インターネットで使用される可能性のあるアプリケーションは、特定のパス特性について仮定してはなりません。代わりに、非常に異なる経路条件下で安全に動作させるメカニズムを使用する必要があります。通常、これには、維持できる伝送動作を確立するために通信するインターネットパスの現在の条件を控えめに調査する必要があります。これは、パスを共有する他のトラフィックにとって合理的に公平です。"
    },
    {
      "indent": 3,
      "text": "These mechanisms are difficult to implement correctly. For most applications, the use of one of the existing IETF transport protocols is the simplest method of acquiring the required mechanisms. Consequently, the RECOMMENDED alternative to the UDP usage described in the remainder of this section is the use of an IETF transport protocol such as TCP [RFC0793], Stream Control Transmission Protocol (SCTP) [RFC4960], and SCTP Partial Reliability Extension (SCTP-PR) [RFC3758], or Datagram Congestion Control Protocol (DCCP) [RFC4340] with its different congestion control types [RFC4341][RFC4342][CCID4].",
      "ja": "これらのメカニズムを正しく実装することは困難です。ほとんどのアプリケーションでは、既存のIETF輸送プロトコルの1つを使用することは、必要なメカニズムを取得する最も簡単な方法です。その結果、このセクションの残りの部分で説明されているUDP使用の推奨される代替手段は、TCP [RFC0793]、ストリーム制御透過プロトコル（SCTP）[RFC4960]、SCTP部分信頼性拡張などのIETF輸送プロトコルの使用です。PR）[RFC3758]、またはデータグラムの混雑制御プロトコル（DCCP）[RFC4340]は、異なる混雑制御タイプ[RFC4341] [RFC4342] [CCID4]を使用しています。"
    },
    {
      "indent": 3,
      "text": "If used correctly, these more fully-featured transport protocols are not as \"heavyweight\" as often claimed. For example, the TCP algorithms have been continuously improved over decades, and have reached a level of efficiency and correctness that custom application-layer mechanisms will struggle to easily duplicate. In addition, many TCP implementations allow connections to be tuned by an application to its purposes. For example, TCP's \"Nagle\" algorithm [RFC0896] can be disabled, improving communication latency at the expense of more frequent -- but still congestion-controlled -- packet transmissions. Another example is the TCP SYN cookie mechanism [RFC4987], which is available on many platforms. TCP with SYN cookies does not require a server to maintain per-connection state until the connection is established. TCP also requires the end that closes a connection to maintain the TIME-WAIT state that prevents delayed segments from one connection instance from interfering with a later one. Applications that are aware of and designed for this behavior can shift maintenance of the TIME-WAIT state to conserve resources by controlling which end closes a TCP connection [FABER]. Finally, TCP's built-in capacity-probing and awareness of the maximum transmission unit supported by the path (PMTU) results in efficient data transmission that quickly compensates for the initial connection setup delay, in the case of transfers that exchange more than a few segments.",
      "ja": "正しく使用すると、これらのより完全に機能する輸送プロトコルは、頻繁に主張するほど「ヘビー級」ではありません。たとえば、TCPアルゴリズムは数十年にわたって継続的に改善されており、カスタムアプリケーションレイヤーメカニズムが簡単に複製するのに苦労する効率と正確性のレベルに達しています。さらに、多くのTCP実装により、その目的へのアプリケーションによって接続を調整することができます。たとえば、TCPの「Nagle」アルゴリズム[RFC0896]は無効にすることができ、より頻繁に（まだ混雑制御されている）パケット送信を犠牲にして通信遅延を改善します。別の例は、TCP Syn Cookieメカニズム[RFC4987]です。これは、多くのプラットフォームで利用できます。Syn Cookieを使用したTCPでは、接続が確立されるまで、接続ごとの状態を維持するためのサーバーを必要としません。TCPでは、1つの接続インスタンスから遅延したセグメントが後のセグメントを妨害するのを防ぐためのタイムウェイト状態を維持するための接続を閉じる端を必要とします。この動作のために認識して設計されたアプリケーションは、TCP接続を閉じる端を制御することにより、リソースを保存するためにタイムウェイト状態のメンテナンスをシフトすることができます[Faber]。最後に、PATH（PMTU）によってサポートされる最大伝送ユニットのTCPの組み込みの容量プロビングと認識により、いくつかのセグメントを超える転送の場合、初期接続のセットアップ遅延を迅速に補正する効率的なデータ送信が得られます。。"
    },
    {
      "indent": 0,
      "text": "3.1. Congestion Control Guidelines",
      "section_title": true,
      "ja": "3.1. 混雑制御ガイドライン"
    },
    {
      "indent": 3,
      "text": "If an application or upper-layer protocol chooses not to use a congestion-controlled transport protocol, it SHOULD control the rate at which it sends UDP datagrams to a destination host, in order to fulfill the requirements of [RFC2914]. It is important to stress that an application SHOULD perform congestion control over all UDP traffic it sends to a destination, independently from how it generates this traffic. For example, an application that forks multiple worker processes or otherwise uses multiple sockets to generate UDP datagrams SHOULD perform congestion control over the aggregate traffic.",
      "ja": "アプリケーションまたは上層層プロトコルが輻輳制御輸送プロトコルを使用しないことを選択した場合、[RFC2914]の要件を満たすために、UDPデータグラムを宛先ホストに送信するレートを制御する必要があります。アプリケーションは、このトラフィックを生成する方法とは独立して、目的地に送信するすべてのUDPトラフィックを渋滞制御する必要があることを強調することが重要です。たとえば、複数のワーカープロセスを分岐したり、複数のソケットを使用してUDPデータグラムを生成するアプリケーションでは、集約トラフィックを渋滞制御する必要があります。"
    },
    {
      "indent": 3,
      "text": "Several approaches to perform congestion control are discussed in the remainder of this section. Not all approaches discussed below are appropriate for all UDP-transmitting applications. Section 3.1.1 discusses congestion control options for applications that perform bulk transfers over UDP. Such applications can employ schemes that sample the path over several subsequent RTTs during which data is exchanged, in order to determine a sending rate that the path at its current load can support. Other applications only exchange a few UDP datagrams with a destination. Section 3.1.2 discusses congestion control options for such \"low data-volume\" applications. Because they typically do not transmit enough data to iteratively sample the path to determine a safe sending rate, they need to employ different kinds of congestion control mechanisms. Section 3.1.3 discusses congestion control considerations when UDP is used as a tunneling protocol.",
      "ja": "このセクションの残りの部分では、混雑制御を実行するためのいくつかのアプローチについて説明します。以下で説明するすべてのアプローチが、すべてのUDPを伝達するアプリケーションに適しているわけではありません。セクション3.1.1では、UDPを介したバルク転送を実行するアプリケーションの輻輳制御オプションについて説明します。このようなアプリケーションは、現在の負荷のパスがサポートできる送信速度を決定するために、データが交換されるいくつかの後続のRTTにわたってパスをサンプリングするスキームを使用できます。他のアプリケーションは、宛先といくつかのUDPデータグラムのみを交換します。セクション3.1.2では、このような「データボリュームの低い」アプリケーションの混雑制御オプションについて説明します。通常、それらは十分なデータを送信して、安全な送信率を決定するためにパスを繰り返しサンプリングするため、さまざまな種類の輻輳制御メカニズムを使用する必要があります。セクション3.1.3は、UDPがトンネリングプロトコルとして使用される場合の混雑制御の考慮事項について説明します。"
    },
    {
      "indent": 3,
      "text": "It is important to note that congestion control should not be viewed as an add-on to a finished application. Many of the mechanisms discussed in the guidelines below require application support to operate correctly. Application designers need to consider congestion control throughout the design of their application, similar to how they consider security aspects throughout the design process.",
      "ja": "輻輳制御は、完成したアプリケーションへのアドオンと見なされるべきではないことに注意することが重要です。以下のガイドラインで説明されているメカニズムの多くは、正しく動作するためにアプリケーションサポートが必要です。アプリケーション設計者は、設計プロセス全体でセキュリティの側面を考慮する方法と同様に、アプリケーションの設計全体を通して混雑制御を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "In the past, the IETF has also investigated integrated congestion control mechanisms that act on the traffic aggregate between two hosts, i.e., a framework such as the Congestion Manager [RFC3124], where active sessions may share current congestion information in a way that is independent of the transport protocol. Such mechanisms have currently failed to see deployment, but would otherwise simplify the design of congestion control mechanisms for UDP sessions, so that they fulfill the requirements in [RFC2914].",
      "ja": "過去に、IETFは、2つのホスト間でトラフィックの集約に作用する統合された混雑制御メカニズム、つまり、渋滞マネージャー[RFC3124]などのフレームワークも調査しています。輸送プロトコルの。このようなメカニズムは現在展開を見ることができませんでしたが、それ以外の場合は、UDPセッションの輻輳制御メカニズムの設計を簡素化して、[RFC2914]の要件を満たすようにします。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Bulk Transfer Applications",
      "section_title": true,
      "ja": "3.1.1. バルク転送アプリケーション"
    },
    {
      "indent": 3,
      "text": "Applications that perform bulk transmission of data to a peer over UDP, i.e., applications that exchange more than a small number of UDP datagrams per RTT, SHOULD implement TCP-Friendly Rate Control (TFRC) [RFC5348], window-based, TCP-like congestion control, or otherwise ensure that the application complies with the congestion control principles.",
      "ja": "UDPを介したピアにデータのバルク送信を実行するアプリケーション、つまりRTTごとに少数のUDPデータグラムを超えるものを交換するアプリケーションでは、TCPに優しいレートコントロール（TFRC）[RFC5348]、ウィンドウベース、TCPリークを実装する必要があります。混雑制御、またはその他の方法では、アプリケーションが混雑制御原則に準拠していることを確認します。"
    },
    {
      "indent": 3,
      "text": "TFRC has been designed to provide both congestion control and fairness in a way that is compatible with the IETF's other transport protocols. If an application implements TFRC, it need not follow the remaining guidelines in Section 3.1.1, because TFRC already addresses them, but SHOULD still follow the remaining guidelines in the subsequent subsections of Section 3.",
      "ja": "TFRCは、IETFの他の輸送プロトコルと互換性のある方法で、混雑制御と公平性の両方を提供するように設計されています。アプリケーションがTFRCを実装する場合、TFRCはすでにそれらに対処しているため、セクション3.1.1の残りのガイドラインに従う必要はありませんが、セクション3の後続のサブセクションで残りのガイドラインに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "Bulk transfer applications that choose not to implement TFRC or TCP-like windowing SHOULD implement a congestion control scheme that results in bandwidth use that competes fairly with TCP within an order of magnitude. Section 2 of [RFC3551] suggests that applications SHOULD monitor the packet loss rate to ensure that it is within acceptable parameters. Packet loss is considered acceptable if a TCP flow across the same network path under the same network conditions would achieve an average throughput, measured on a reasonable timescale, that is not less than that of the UDP flow. The comparison to TCP cannot be specified exactly, but is intended as an \"order-of-magnitude\" comparison in timescale and throughput.",
      "ja": "TFRCまたはTCPのようなウィンドウを実装しないことを選択したバルク転送アプリケーションは、1桁以内にTCPと公正に競合する帯域幅使用をもたらす渋滞制御スキームを実装する必要があります。[RFC3551]のセクション2は、アプリケーションがパケットの損失率を監視して、許容可能なパラメーター内にあることを確認する必要があることを示唆しています。同じネットワーク条件下で同じネットワークパスを介したTCPフローが、UDPフローのそれ以上である合理的なタイムスケールで測定された平均スループットを達成する場合、パケット損失は許容されると見なされます。TCPとの比較は正確に指定することはできませんが、タイムスケールとスループットの「順序」比較として意図されています。"
    },
    {
      "indent": 3,
      "text": "Finally, some bulk transfer applications may choose not to implement any congestion control mechanism and instead rely on transmitting across reserved path capacity. This might be an acceptable choice for a subset of restricted networking environments, but is by no means a safe practice for operation in the Internet. When the UDP traffic of such applications leaks out on unprovisioned Internet paths, it can significantly degrade the performance of other traffic sharing the path and even result in congestion collapse. Applications that support an uncontrolled or unadaptive transmission behavior SHOULD NOT do so by default and SHOULD instead require users to explicitly enable this mode of operation.",
      "ja": "最後に、一部のバルク転送アプリケーションは、混雑制御メカニズムを実装しないことを選択し、代わりに予約されたパス容量を越えて送信に依存する場合があります。これは、制限されたネットワーキング環境のサブセットにとって許容可能な選択かもしれませんが、インターネットでの運用のための安全な慣行ではありません。このようなアプリケーションのUDPトラフィックが、未分解されていないインターネットパスに漏れている場合、パスを共有する他のトラフィックのパフォーマンスを大幅に低下させ、混雑の崩壊をもたらす可能性があります。制御されていないまたは適応性のない伝送動作をサポートするアプリケーションは、デフォルトではそうする必要はなく、代わりにユーザーがこの操作モードを明示的に有効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.2. Low Data-Volume Applications",
      "section_title": true,
      "ja": "3.1.2. 低データ式アプリケーション"
    },
    {
      "indent": 3,
      "text": "When applications that at any time exchange only a small number of UDP datagrams with a destination implement TFRC or one of the other congestion control schemes in Section 3.1.1, the network sees little benefit, because those mechanisms perform congestion control in a way that is only effective for longer transmissions.",
      "ja": "いつでも交換するアプリケーションが、宛先を実装したTFRCまたはセクション3.1.1の他の輻輳制御スキームのいずれかを実装している少数のUDPデータグラムのみを交換する場合、これらのメカニズムは渋滞制御を実行するため、ネットワークにはほとんど利点がありません。より長い送信に対してのみ有効です。"
    },
    {
      "indent": 3,
      "text": "Applications that at any time exchange only a small number of UDP datagrams with a destination SHOULD still control their transmission behavior by not sending on average more than one UDP datagram per round-trip time (RTT) to a destination. Similar to the recommendation in [RFC1536], an application SHOULD maintain an estimate of the RTT for any destination with which it communicates. Applications SHOULD implement the algorithm specified in [RFC2988] to compute a smoothed RTT (SRTT) estimate. They SHOULD also detect packet loss and exponentially back-off their retransmission timer when a loss event occurs. When implementing this scheme, applications need to choose a sensible initial value for the RTT. This value SHOULD generally be as conservative as possible for the given application. TCP uses an initial value of 3 seconds [RFC2988], which is also RECOMMENDED as an initial value for UDP applications. SIP [RFC3261] and GIST [GIST] use an initial value of 500 ms, and initial timeouts that are shorter than this are likely problematic in many cases. It is also important to note that the initial timeout is not the maximum possible timeout -- the RECOMMENDED algorithm in [RFC2988] yields timeout values after a series of losses that are much longer than the initial value.",
      "ja": "いつでも、宛先を持つ少数のUDPデータグラムのみを交換するアプリケーションは、往復時間（RTT）あたり平均複数のUDPデータグラムを宛先に送信しないことで、伝送動作を制御する必要があります。[RFC1536]の推奨と同様に、アプリケーションは、通信する目的地のRTTの推定値を維持する必要があります。アプリケーションは、[RFC2988]で指定されたアルゴリズムを実装して、平滑化されたRTT（SRTT）推定値を計算する必要があります。また、パケットの損失を検出し、損失イベントが発生したときに再送信タイマーを指数関数的にバックオフする必要があります。このスキームを実装する場合、アプリケーションはRTTの賢明な初期値を選択する必要があります。この値は、一般に、指定されたアプリケーションではできるだけ保守的である必要があります。TCPは3秒の初期値[RFC2988]を使用します。これは、UDPアプリケーションの初期値としても推奨されます。SIP [RFC3261]とGIST [GIST]は500ミリ秒の初期値を使用し、これよりも短い初期タイムアウトは多くの場合問題が発生する可能性があります。また、初期タイムアウトは可能な最大タイムアウトではないことに注意することも重要です。[RFC2988]の推奨アルゴリズムは、初期値よりもはるかに長い一連の損失の後にタイムアウト値を生成します。"
    },
    {
      "indent": 3,
      "text": "Some applications cannot maintain a reliable RTT estimate for a destination. The first case is that of applications that exchange too few UDP datagrams with a peer to establish a statistically accurate RTT estimate. Such applications MAY use a predetermined transmission interval that is exponentially backed-off when packets are lost. TCP uses an initial value of 3 seconds [RFC2988], which is also RECOMMENDED as an initial value for UDP applications. SIP [RFC3261] and GIST [GIST] use an interval of 500 ms, and shorter values are likely problematic in many cases. As in the previous case, note that the initial timeout is not the maximum possible timeout.",
      "ja": "一部のアプリケーションは、宛先の信頼できるRTT見積もりを維持できません。最初のケースは、統計的に正確なRTT推定値を確立するためにピアとUDPデータグラムを交換しすぎるアプリケーションのケースです。このようなアプリケーションは、パケットが失われたときに指数関数的にバックオフされる所定の伝送間隔を使用する場合があります。TCPは3秒の初期値[RFC2988]を使用します。これは、UDPアプリケーションの初期値としても推奨されます。SIP [RFC3261]とGIST [GIST]は500 msの間隔を使用し、多くの場合、より短い値が問題になる可能性があります。前のケースのように、初期タイムアウトは可能な最大タイムアウトではないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "A second class of applications cannot maintain an RTT estimate for a destination, because the destination does not send return traffic. Such applications SHOULD NOT send more than one UDP datagram every 3 seconds, and SHOULD use an even less aggressive rate when possible. The 3-second interval was chosen based on TCP's retransmission timeout when the RTT is unknown [RFC2988], and shorter values are likely problematic in many cases. Note that the sending rate in this case must be more conservative than in the two previous cases, because the lack of return traffic prevents the detection of packet loss, i.e., congestion events, and the application therefore cannot perform exponential back-off to reduce load.",
      "ja": "2番目のクラスのアプリケーションでは、宛先が返品トラフィックを送信しないため、宛先のRTT見積もりを維持できません。このようなアプリケーションは、3秒ごとに複数のUDPデータグラムを送信するべきではなく、可能な場合はさらに少ない積極的なレートを使用する必要があります。3秒の間隔は、RTTが不明[RFC2988]である場合にTCPの再送信タイムアウトに基づいて選択され、多くの場合、より短い値が問題になる可能性があります。この場合の送信率は、2つのケースよりも保守的でなければならないことに注意してください。リターントラフィックの欠如により、パケット損失、つまり混雑イベントの検出が妨げられ、したがってアプリケーションが指数関数的なバックオフを実行できないため、負荷を減らすことができないことに注意してください。。"
    },
    {
      "indent": 3,
      "text": "Applications that communicate bidirectionally SHOULD employ congestion control for both directions of the communication. For example, for a client-server, request-response-style application, clients SHOULD congestion-control their request transmission to a server, and the server SHOULD congestion-control its responses to the clients. Congestion in the forward and reverse direction is uncorrelated, and an application SHOULD either independently detect and respond to congestion along both directions, or limit new and retransmitted requests based on acknowledged responses across the entire round-trip path.",
      "ja": "双方向で通信するアプリケーションは、通信の両方向に輻輳制御を採用する必要があります。たとえば、クライアントサーバーのリクエストレスポンススタイルのアプリケーションの場合、クライアントは輻輳をサーバーにリクエスト送信する必要があり、サーバーはクライアントへの応答を混雑させる必要があります。前方方向と逆方向の混雑は無相関であり、アプリケーションは両方方向に沿って渋滞を独立して検出して応答するか、往復パス全体にわたる承認された応答に基づいて新しい再送信要求を制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.3. UDP Tunnels",
      "section_title": true,
      "ja": "3.1.3. UDPトンネル"
    },
    {
      "indent": 3,
      "text": "One increasingly popular use of UDP is as a tunneling protocol, where a tunnel endpoint encapsulates the packets of another protocol inside UDP datagrams and transmits them to another tunnel endpoint, which decapsulates the UDP datagrams and forwards the original packets contained in the payload. Tunnels establish virtual links that appear to directly connect locations that are distant in the physical Internet topology and can be used to create virtual (private) networks. Using UDP as a tunneling protocol is attractive when the payload protocol is not supported by middleboxes that may exist along the path, because many middleboxes support transmission using UDP.",
      "ja": "UDPのますます一般的に使用されている1つの使用は、トンネルプロトコルとしてです。トンネルエンドポイントがUDPデータグラム内の別のプロトコルのパケットをカプセル化し、それらを別のトンネルエンドポイントに送信します。トンネルは、物理的なインターネットトポロジで遠くにある場所を直接接続し、仮想（プライベート）ネットワークを作成するために使用できる仮想リンクを確立します。UDPをトンネリングプロトコルとして使用することは、多くのミドルボックスがUDPを使用した送信をサポートするため、パスに沿って存在する可能性のあるミドルボックスによってペイロードプロトコルがサポートされていない場合に魅力的です。"
    },
    {
      "indent": 3,
      "text": "Well-implemented tunnels are generally invisible to the endpoints that happen to transmit over a path that includes tunneled links. On the other hand, to the routers along the path of a UDP tunnel, i.e., the routers between the two tunnel endpoints, the traffic that a UDP tunnel generates is a regular UDP flow, and the encapsulator and decapsulator appear as regular UDP-sending and -receiving applications. Because other flows can share the path with one or more UDP tunnels, congestion control needs to be considered.",
      "ja": "よく実現されたトンネルは、一般に、トンネルリンクを含むパス上でたまたま伝達されるエンドポイントには見えません。一方、UDPトンネルの経路に沿ったルーター、つまり2つのトンネルエンドポイントの間のルーター、UDPトンネルが生成するトラフィックは通常のUDPフローであり、エンカプサプレーターと脱ッサーターは通常のUDP-sendingとして表示されますおよび - 受信アプリケーション。他のフローは1つ以上のUDPトンネルとパスを共有できるため、輻輳制御を考慮する必要があります。"
    },
    {
      "indent": 3,
      "text": "Two factors determine whether a UDP tunnel needs to employ specific congestion control mechanisms -- first, whether the payload traffic is IP-based; second, whether the tunneling scheme generates UDP traffic at a volume that corresponds to the volume of payload traffic carried within the tunnel.",
      "ja": "2つの要因は、UDPトンネルが特定の混雑制御メカニズムを使用する必要があるかどうかを決定します。まず、ペイロードトラフィックがIPベースであるかどうかです。第二に、トンネルスキームがトンネル内で運ばれるペイロードトラフィックの量に対応するボリュームでUDPトラフィックを生成するかどうか。"
    },
    {
      "indent": 3,
      "text": "IP-based traffic is generally assumed to be congestion-controlled, i.e., it is assumed that the transport protocols generating IP-based traffic at the sender already employ mechanisms that are sufficient to address congestion on the path. Consequently, a tunnel carrying IP-based traffic should already interact appropriately with other traffic sharing the path, and specific congestion control mechanisms for the tunnel are not necessary.",
      "ja": "IPベースのトラフィックは一般に、混雑制御されていると想定されています。つまり、送信者でのIPベースのトラフィックを生成するトランスポートプロトコルは、パスの混雑に対処するのに十分なメカニズムを既に使用していると想定されています。したがって、IPベースのトラフィックを運ぶトンネルは、パスを共有する他のトラフィックとすでに適切に相互作用する必要があり、トンネルの特定の混雑制御メカニズムは必要ありません。"
    },
    {
      "indent": 3,
      "text": "However, if the IP traffic in the tunnel is known to not be congestion-controlled, additional measures are RECOMMENDED in order to limit the impact of the tunneled traffic on other traffic sharing the path.",
      "ja": "ただし、トンネル内のIPトラフィックが混雑制御されていないことが知られている場合、パスを共有する他のトラフィックに対するトンネルトラフィックの影響を制限するために、追加の測定が推奨されます。"
    },
    {
      "indent": 3,
      "text": "The following guidelines define these possible cases in more detail:",
      "ja": "次のガイドラインでは、これらの可能なケースをより詳細に定義します。"
    },
    {
      "indent": 3,
      "text": "1. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is IP-based and congestion-controlled.",
      "ja": "1. トンネルは、ペイロードトラフィックの量に対応するボリュームでUDPトラフィックを生成し、ペイロードトラフィックはIPベースで渋滞制御されています。"
    },
    {
      "indent": 7,
      "text": "This is arguably the most common case for Internet tunnels. In this case, the UDP tunnel SHOULD NOT employ its own congestion control mechanism, because congestion losses of tunneled traffic will already trigger an appropriate congestion response at the original senders of the tunneled traffic.",
      "ja": "これは間違いなくインターネットトンネルの最も一般的なケースです。この場合、UDPトンネルは独自の混雑制御メカニズムを採用してはなりません。これは、トンネルトラフィックの混雑損失が、トンネル交通の元の送信者で適切な輻輳応答をすでに引き起こすためです。"
    },
    {
      "indent": 7,
      "text": "Note that this guideline is built on the assumption that most IP-based communication is congestion-controlled. If a UDP tunnel is used for IP-based traffic that is known to not be congestion-controlled, the next set of guidelines applies.",
      "ja": "このガイドラインは、ほとんどのIPベースの通信が混雑制御されているという仮定に基づいて構築されていることに注意してください。UDPトンネルが、混雑制御されていないことが知られているIPベースのトラフィックに使用されている場合、次の一連のガイドラインが適用されます。"
    },
    {
      "indent": 3,
      "text": "2. A tunnel generates UDP traffic at a volume that corresponds to the volume of payload traffic, and the payload traffic is not known to be IP-based, or is known to be IP-based but not congestion-controlled.",
      "ja": "2. トンネルは、ペイロードトラフィックの量に対応するボリュームでUDPトラフィックを生成し、ペイロードトラフィックはIPベースであることが知られていないか、IPベースであることが知られていますが、混雑制御されていないことが知られています。"
    },
    {
      "indent": 7,
      "text": "This can be the case, for example, when some link-layer protocols are encapsulated within UDP (but not all link-layer protocols; some are congestion-controlled). Because it is not known that congestion losses of tunneled non-IP traffic will trigger an appropriate congestion response at the senders, the UDP tunnel SHOULD employ an appropriate congestion control mechanism. Because tunnels are usually bulk-transfer applications as far as the intermediate routers are concerned, the guidelines in Section 3.1.1 apply.",
      "ja": "これは、たとえば、一部のリンク層プロトコルがUDP内でカプセル化されている場合（すべてのリンク層プロトコルではありません。一部は混雑制御されています）。Tunneled非IPトラフィックの混雑損失が送信者に適切な輻輳応答をトリガーすることがわからないため、UDPトンネルは適切な輻輳制御メカニズムを採用する必要があります。トンネルは通常、中間ルーターに関する限り、バルク移動アプリケーションであるため、セクション3.1.1のガイドラインが適用されます。"
    },
    {
      "indent": 3,
      "text": "3. A tunnel generates UDP traffic at a volume that does not correspond to the volume of payload traffic, independent of whether the payload traffic is IP-based or congestion-controlled.",
      "ja": "3. トンネルは、ペイロードトラフィックがIPベースか渋滞が制御されているかどうかに関係なく、ペイロードトラフィックの量に対応しないボリュームでUDPトラフィックを生成します。"
    },
    {
      "indent": 7,
      "text": "Examples of this class include UDP tunnels that send at a constant rate, increase their transmission rates under loss, for example, due to increasing redundancy when Forward Error Correction is used, or are otherwise constrained in their transmission behavior. These specialized uses of UDP for tunneling go beyond the scope of the general guidelines given in this document. The implementer of such specialized tunnels SHOULD carefully consider congestion control in the design of their tunneling mechanism.",
      "ja": "このクラスの例には、一定の速度で送信するUDPトンネル、たとえば、順方向エラー補正が使用された場合の冗長性の増加、またはその他の透過挙動に制約されているため、損失下での伝送速度を上げるUDPトンネルが含まれます。トンネリングのためのこれらの特殊な使用法は、このドキュメントに記載されている一般的なガイドラインの範囲を超えています。このような特殊なトンネルの実装者は、トンネルメカニズムの設計において混雑制御を慎重に検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "Designing a tunneling mechanism requires significantly more expertise than needed for many other UDP applications, because tunnels virtualize lower-layer components of the Internet, and the virtualized components need to correctly interact with the infrastructure at that layer. This document only touches upon the congestion control considerations for implementing UDP tunnels; a discussion of other required tunneling behavior is out of scope.",
      "ja": "トンネルメカニズムを設計するには、他の多くのUDPアプリケーションに必要なものよりもはるかに多くの専門知識が必要です。これは、トンネルがインターネットの低層コンポーネントを仮想化するため、仮想化されたコンポーネントがその層のインフラストラクチャと正しく相互作用する必要があるためです。このドキュメントは、UDPトンネルを実装するための輻輳制御の考慮事項にのみ触れています。他の必要なトンネル挙動の議論は範囲外です。"
    },
    {
      "indent": 0,
      "text": "3.2. Message Size Guidelines",
      "section_title": true,
      "ja": "3.2. メッセージサイズのガイドライン"
    },
    {
      "indent": 3,
      "text": "IP fragmentation lowers the efficiency and reliability of Internet communication. The loss of a single fragment results in the loss of an entire fragmented packet, because even if all other fragments are received correctly, the original packet cannot be reassembled and delivered. This fundamental issue with fragmentation exists for both IPv4 and IPv6. In addition, some network address translators (NATs) and firewalls drop IP fragments. The network address translation performed by a NAT only operates on complete IP packets, and some firewall policies also require inspection of complete IP packets. Even with these being the case, some NATs and firewalls simply do not implement the necessary reassembly functionality, and instead choose to drop all fragments. Finally, [RFC4963] documents other issues specific to IPv4 fragmentation.",
      "ja": "IPの断片化は、インターネット通信の効率と信頼性を低下させます。単一のフラグメントを失うと、他のすべてのフラグメントが正しく受信されたとしても、元のパケットを再組み立てして配信できないため、断片化されたパケット全体が失われます。断片化に関するこの基本的な問題は、IPv4とIPv6の両方に存在します。さらに、一部のネットワークアドレス翻訳者（NAT）とファイアウォールはIPフラグメントをドロップします。NATによって実行されるネットワークアドレス変換は、完全なIPパケットでのみ動作し、一部のファイアウォールポリシーでは完全なIPパケットの検査も必要です。これらが事実であっても、一部のNATとファイアウォールは、必要な再組み立て機能を実装しておらず、代わりにすべてのフラグメントをドロップすることを選択します。最後に、[RFC4963]は、IPv4の断片化に固有の他の問題を文書化します。"
    },
    {
      "indent": 3,
      "text": "Due to these issues, an application SHOULD NOT send UDP datagrams that result in IP packets that exceed the MTU of the path to the destination. Consequently, an application SHOULD either use the path MTU information provided by the IP layer or implement path MTU discovery itself [RFC1191][RFC1981][RFC4821] to determine whether the path to a destination will support its desired message size without fragmentation.",
      "ja": "これらの問題のため、アプリケーションは、宛先へのパスのMTUを超えるIPパケットをもたらすUDPデータグラムを送信してはなりません。したがって、アプリケーションは、IPレイヤーによって提供されるPATH MTU情報を使用するか、PATH MTU発見自体[RFC1191] [RFC1981] [RFC4821]を実装して、宛先へのパスが断片化なしで希望するメッセージサイズをサポートするかどうかを判断する必要があります。"
    },
    {
      "indent": 3,
      "text": "Applications that do not follow this recommendation to do PMTU discovery SHOULD still avoid sending UDP datagrams that would result in IP packets that exceed the path MTU. Because the actual path MTU is unknown, such applications SHOULD fall back to sending messages that are shorter than the default effective MTU for sending (EMTU_S in [RFC1122]). For IPv4, EMTU_S is the smaller of 576 bytes and the first-hop MTU [RFC1122]. For IPv6, EMTU_S is 1280 bytes [RFC2460]. The effective PMTU for a directly connected destination (with no routers on the path) is the configured interface MTU, which could be less than the maximum link payload size. Transmission of minimum-sized UDP datagrams is inefficient over paths that support a larger PMTU, which is a second reason to implement PMTU discovery.",
      "ja": "PMTU発見を行うためにこの推奨事項に従わないアプリケーションは、PATH MTUを超えるIPパケットを作成するUDPデータグラムの送信を避ける必要があります。実際のPATH MTUは不明であるため、そのようなアプリケーションは、送信するためのデフォルトの有効なMTUよりも短いメッセージを送信することに戻る必要があります（[RFC1122]のEMTU_S）。IPv4の場合、EMTU_Sは576バイトとファーストホップMTU [RFC1122]のうち小さいです。IPv6の場合、EMTU_Sは1280バイトです[RFC2460]。直接接続された宛先（パスにルーターがない）の有効なPMTUは、構成されたインターフェイスMTUであり、最大リンクペイロードサイズよりも少ない可能性があります。最小サイズのUDPデータグラムの送信は、より大きなPMTUをサポートするパス上で非効率的です。これは、PMTU発見を実装する2番目の理由です。"
    },
    {
      "indent": 3,
      "text": "To determine an appropriate UDP payload size, applications MUST subtract the size of the IP header (which includes any IPv4 optional headers or IPv6 extension headers) as well as the length of the UDP header (8 bytes) from the PMTU size. This size, known as the MMS_S, can be obtained from the TCP/IP stack [RFC1122].",
      "ja": "適切なUDPペイロードサイズを決定するには、アプリケーションがIPヘッダーのサイズ（IPv4オプションヘッダーまたはIPv6拡張ヘッダーを含む）とPMTUサイズのUDPヘッダー（8バイト）の長さを減算する必要があります。MMS_Sとして知られるこのサイズは、TCP/IPスタック[RFC1122]から取得できます。"
    },
    {
      "indent": 3,
      "text": "Applications that do not send messages that exceed the effective PMTU of IPv4 or IPv6 need not implement any of the above mechanisms. Note that the presence of tunnels can cause an additional reduction of the effective PMTU, so implementing PMTU discovery may be beneficial.",
      "ja": "IPv4またはIPv6の有効なPMTUを超えるメッセージを送信しないアプリケーションは、上記のメカニズムのいずれかを実装する必要はありません。トンネルの存在は、効果的なPMTUの追加の削減を引き起こす可能性があるため、PMTU発見を実装することが有益である可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Applications that fragment an application-layer message into multiple UDP datagrams SHOULD perform this fragmentation so that each datagram can be received independently, and be independently retransmitted in the case where an application implements its own reliability mechanisms.",
      "ja": "アプリケーション層メッセージを複数のUDPデータグラムに断片化するアプリケーションは、この断片化を実行して、各データグラムを独立して受信できるようにし、アプリケーションが独自の信頼性メカニズムを実装する場合に独立して再送信する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.3. Reliability Guidelines",
      "section_title": true,
      "ja": "3.3. 信頼性ガイドライン"
    },
    {
      "indent": 3,
      "text": "Application designers are generally aware that UDP does not provide any reliability, e.g., it does not retransmit any lost packets. Often, this is a main reason to consider UDP as a transport. Applications that do require reliable message delivery MUST implement an appropriate mechanism themselves.",
      "ja": "アプリケーションデザイナーは一般に、UDPが信頼性を提供しないことを認識しています。たとえば、失われたパケットを再送信しません。多くの場合、これがUDPを輸送と見なす主な理由です。信頼できるメッセージ配信が必要なアプリケーションは、適切なメカニズム自体を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "UDP also does not protect against datagram duplication, i.e., an application may receive multiple copies of the same UDP datagram. Application designers SHOULD verify that their application handles datagram duplication gracefully, and may consequently need to implement mechanisms to detect duplicates. Even if UDP datagram reception triggers idempotent operations, applications may want to suppress duplicate datagrams to reduce load.",
      "ja": "また、UDPはデータグラムの複製から保護しません。つまり、アプリケーションは同じUDPデータグラムの複数のコピーを受信する場合があります。アプリケーション設計者は、アプリケーションがデータグラムの複製を優雅に処理することを確認する必要があり、その結果、複製を検出するためのメカニズムを実装する必要がある場合があります。UDP Datagramの受信がiDempotent操作をトリガーする場合でも、アプリケーションは重複したデータグラムを抑制して負荷を減らすことを望む場合があります。"
    },
    {
      "indent": 3,
      "text": "In addition, the Internet can significantly delay some packets with respect to others, e.g., due to routing transients, intermittent connectivity, or mobility. This can cause reordering, where UDP datagrams arrive at the receiver in an order different from the transmission order. Applications that require ordered delivery MUST reestablish datagram ordering themselves.",
      "ja": "さらに、インターネットは、たとえば、ルーティングの過渡現象、断続的な接続、またはモビリティにより、他のパケットに関して一部のパケットを大幅に遅らせることができます。これにより、UDPデータグラムが送信順序とは異なる順序でレシーバーに到着する並べ替えを引き起こす可能性があります。注文された配信を必要とするアプリケーションは、自分自身を注文するデータグラムを再確立する必要があります。"
    },
    {
      "indent": 3,
      "text": "Finally, it is important to note that delay spikes can be very large. This can cause reordered packets to arrive many seconds after they were sent. [RFC0793] defines the maximum delay a TCP segment should experience -- the Maximum Segment Lifetime (MSL) -- as 2 minutes. No other RFC defines an MSL for other transport protocols or IP itself. This document clarifies that the MSL value to be used for UDP SHOULD be the same 2 minutes as for TCP. Applications SHOULD be robust to the reception of delayed or duplicate packets that are received within this 2-minute interval.",
      "ja": "最後に、遅延スパイクは非常に大きくなる可能性があることに注意することが重要です。これにより、並べ替えられたパケットが送信されてから数秒後に到着する可能性があります。[RFC0793] TCPセグメントが経験すべき最大遅延（最大セグメント寿命（MSL））を2分間定義します。他のRFCは、他の輸送プロトコルまたはIP自体のMSLを定義するものはありません。このドキュメントは、UDPに使用されるMSL値がTCPの場合と同じ2分であることを明確にしています。アプリケーションは、この2分間の間隔内で受信される遅延または重複パケットの受信に堅牢である必要があります。"
    },
    {
      "indent": 3,
      "text": "An application that requires reliable and ordered message delivery SHOULD choose an IETF standard transport protocol that provides these features. If this is not possible, it will need to implement a set of appropriate mechanisms itself.",
      "ja": "信頼できる順序付けられたメッセージ配信を必要とするアプリケーションは、これらの機能を提供するIETF標準輸送プロトコルを選択する必要があります。これが不可能な場合は、適切なメカニズムのセット自体を実装する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.4. Checksum Guidelines",
      "section_title": true,
      "ja": "3.4. チェックサムガイドライン"
    },
    {
      "indent": 3,
      "text": "The UDP header includes an optional, 16-bit one's complement checksum that provides an integrity check. This results in a relatively weak protection in terms of coding theory [RFC3819], and application developers SHOULD implement additional checks where data integrity is important, e.g., through a Cyclic Redundancy Check (CRC) included with the data to verify the integrity of an entire object/file sent over the UDP service.",
      "ja": "UDPヘッダーには、整合性チェックを提供するオプションの16ビットの補完チェックサムが含まれています。これにより、コーディング理論[RFC3819]の観点から比較的弱い保護が生じ、アプリケーション開発者は、データの整合性が重要な場合に追加のチェックを実装する必要があります。UDPサービスで送信されるオブジェクト/ファイル。"
    },
    {
      "indent": 3,
      "text": "The UDP checksum provides a statistical guarantee that the payload was not corrupted in transit. It also allows the receiver to verify that it was the intended destination of the packet, because it covers the IP addresses, port numbers, and protocol number, and it verifies that the packet is not truncated or padded, because it covers the size field. It therefore protects an application against receiving corrupted payload data in place of, or in addition to, the data that was sent. This check is not strong from a coding or cryptographic perspective, and is not designed to detect physical-layer errors or malicious modification of the datagram [RFC3819].",
      "ja": "UDPチェックサムは、輸送中にペイロードが破損していないという統計的保証を提供します。また、IPアドレス、ポート番号、およびプロトコル番号をカバーするため、受信者がパケットの意図された宛先であることを確認することもでき、サイズのフィールドをカバーするため、パケットが切り捨てられたりパッドで塗装されていないことを確認します。したがって、送信されたデータの代わりに、またはそれに加えて破損したペイロードデータを受信することからアプリケーションを保護します。このチェックは、コーディングや暗号化の観点からは強くなく、物理的層のエラーやデータグラムの悪意のある変更を検出するようには設計されていません[RFC3819]。"
    },
    {
      "indent": 3,
      "text": "Applications SHOULD enable UDP checksums, although [RFC0768] permits the option to disable their use. Applications that choose to disable UDP checksums when transmitting over IPv4 therefore MUST NOT make assumptions regarding the correctness of received data and MUST behave correctly when a UDP datagram is received that was originally sent to a different destination or is otherwise corrupted. The use of the UDP checksum is REQUIRED when applications transmit UDP over IPv6 [RFC2460].",
      "ja": "[RFC0768]は、使用を無効にするオプションを許可していますが、アプリケーションはUDPチェックサムを有効にする必要があります。したがって、IPv4を介して送信するときにUDPチェックサムを無効にすることを選択するアプリケーションは、受信したデータの正しさに関して仮定を立ててはなりません。また、元々別の宛先に送信された、または他の方法で破損しているUDPデータグラムを受信した場合に正しく動作する必要があります。UDPチェックサムの使用は、アプリケーションがIPv6を介してUDPを送信する場合に必要です[RFC2460]。"
    },
    {
      "indent": 0,
      "text": "3.4.1. UDP-Lite",
      "section_title": true,
      "ja": "3.4.1. UDPライト"
    },
    {
      "indent": 3,
      "text": "A special class of applications can derive benefit from having partially-damaged payloads delivered, rather than discarded, when using paths that include error-prone links. Such applications can tolerate payload corruption and MAY choose to use the Lightweight User Datagram Protocol (UDP-Lite) [RFC3828] variant of UDP instead of basic UDP. Applications that choose to use UDP-Lite instead of UDP should still follow the congestion control and other guidelines described for use with UDP in Section 3.",
      "ja": "特別なクラスのアプリケーションは、エラーが発生しやすいリンクを含むパスを使用する場合、破棄されるのではなく、部分的に損なわれたペイロードを配信することから利益を得ることができます。このようなアプリケーションは、ペイロードの破損に耐えることができ、基本的なUDPではなくUDPのLightweightユーザーデータグラムプロトコル（UDP-Lite）[RFC3828]バリアントを使用することを選択できます。UDPの代わりにUDP-Liteを使用することを選択したアプリケーションは、セクション3でUDPで使用するために説明されている輻輳制御およびその他のガイドラインに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "UDP-Lite changes the semantics of the UDP \"payload length\" field to that of a \"checksum coverage length\" field. Otherwise, UDP-Lite is semantically identical to UDP. The interface of UDP-Lite differs from that of UDP by the addition of a single (socket) option that communicates a checksum coverage length value: at the sender, this specifies the intended checksum coverage, with the remaining unprotected part of the payload called the \"error-insensitive part\". By default, the UDP-Lite checksum coverage extends across the entire datagram. If required, an application may dynamically modify this length value, e.g., to offer greater protection to some messages. UDP-Lite always verifies that a packet was delivered to the intended destination, i.e., always verifies the header fields. Errors in the insensitive part will not cause a UDP datagram to be discarded by the destination. Applications using UDP-Lite therefore MUST NOT make assumptions regarding the correctness of the data received in the insensitive part of the UDP-Lite payload.",
      "ja": "UDP-Liteは、UDP「ペイロード長」フィールドのセマンティクスを「チェックサムカバレッジ長」フィールドのセマンティクスに変更します。それ以外の場合、UDP-LiteはUDPと意味的に同一です。UDPライトのインターフェイスは、チェックサムカバレッジの長さ値を伝える単一（ソケット）オプションの追加により、UDPのインターフェイスとは異なります。送信者では、意図したチェックサムカバレッジを指定し、「エラーと感受性の部分」。デフォルトでは、UDP-Liteチェックサムのカバレッジは、データグラム全体に拡張されます。必要に応じて、アプリケーションは、この長さの値を動的に変更する場合があります。たとえば、一部のメッセージをより大きな保護を提供します。UDP-Liteは、パケットが意図した宛先に配信されたことを常に確認します。つまり、常にヘッダーフィールドを検証します。鈍感な部分のエラーは、宛先によってUDPデータグラムが破棄されることはありません。したがって、UDP-LITEを使用したアプリケーションは、UDP-Liteペイロードの鈍感な部分で受け取ったデータの正確性に関して仮定を立ててはなりません。"
    },
    {
      "indent": 3,
      "text": "The sending application SHOULD select the minimum checksum coverage to include all sensitive protocol headers. For example, applications that use the Real-Time Protocol (RTP) [RFC3550] will likely want to protect the RTP header against corruption. Applications, where appropriate, MUST also introduce their own appropriate validity checks for protocol information carried in the insensitive part of the UDP-Lite payload (e.g., internal CRCs).",
      "ja": "送信アプリケーションは、すべての機密プロトコルヘッダーを含めるために、最小チェックサムカバレッジを選択する必要があります。たとえば、リアルタイムプロトコル（RTP）[RFC3550]を使用するアプリケーションは、RTPヘッダーを汚職から保護する可能性があります。必要に応じて、アプリケーションは、UDP-LITEペイロード（内部CRCなど）の鈍感な部分にあるプロトコル情報の独自の適切な妥当性チェックも導入する必要があります。"
    },
    {
      "indent": 3,
      "text": "The receiver must set a minimum coverage threshold for incoming packets that is not smaller than the smallest coverage used by the sender [RFC3828]. The receiver SHOULD select a threshold that is sufficiently large to block packets with an inappropriately short coverage field. This may be a fixed value, or may be negotiated by an application. UDP-Lite does not provide mechanisms to negotiate the checksum coverage between the sender and receiver.",
      "ja": "受信者は、送信者が使用する最小のカバレッジよりも小さくない着信パケットの最小カバレッジしきい値を設定する必要があります[RFC3828]。受信者は、不適切に短いカバレッジフィールドでパケットをブロックするのに十分な大きさのしきい値を選択する必要があります。これは固定値であるか、アプリケーションによって交渉される場合があります。UDP-Liteは、送信者と受信機の間のチェックサムカバレッジを交渉するメカニズムを提供しません。"
    },
    {
      "indent": 3,
      "text": "Applications may still experience packet loss, rather than corruption, when using UDP-Lite. The enhancements offered by UDP-Lite rely upon a link being able to intercept the UDP-Lite header to correctly identify the partial coverage required. When tunnels and/or encryption are used, this can result in UDP-Lite datagrams being treated the same as UDP datagrams, i.e., result in packet loss. Use of IP fragmentation can also prevent special treatment for UDP-Lite datagrams, and this is another reason why applications SHOULD avoid IP fragmentation (Section 3.2).",
      "ja": "UDP-Liteを使用する場合、アプリケーションは腐敗ではなくパケット損失が発生する場合があります。UDP-Liteが提供する機能強化は、UDP-Liteヘッダーを傍受して、必要な部分的なカバレッジを正しく識別できるリンクに依存しています。トンネルや暗号化を使用すると、UDP-LITEデータグラムがUDPデータグラムと同じで扱われる可能性があります。つまり、パケット損失になります。IP断片化の使用は、UDP-Liteデータグラムの特別な治療を防ぐこともできます。これが、アプリケーションがIP断片化を回避する必要があるもう1つの理由です（セクション3.2）。"
    },
    {
      "indent": 0,
      "text": "3.5. Middlebox Traversal Guidelines",
      "section_title": true,
      "ja": "3.5. ミドルボックストラバーサルガイドライン"
    },
    {
      "indent": 3,
      "text": "Network address translators (NATs) and firewalls are examples of intermediary devices (\"middleboxes\") that can exist along an end-to-end path. A middlebox typically performs a function that requires it to maintain per-flow state. For connection-oriented protocols, such as TCP, middleboxes snoop and parse the connection-management traffic and create and destroy per-flow state accordingly. For a connectionless protocol such as UDP, this approach is not possible. Consequently, middleboxes may create per-flow state when they see a packet that indicates a new flow, and destroy the state after some period of time during which no packets belonging to the same flow have arrived.",
      "ja": "ネットワークアドレス翻訳者（NAT）とファイアウォールは、エンドツーエンドのパスに沿って存在できる中間デバイス（「ミドルボックス」）の例です。ミドルボックスは通常、流量あたりの状態を維持するために必要な関数を実行します。TCPなどの接続指向のプロトコルの場合、ミドルボックスはスヌープをsnoopし、接続管理トラフィックを解析し、それに応じて流量あたりの状態を作成および破壊します。UDPなどのコネクションレスプロトコルの場合、このアプローチは不可能です。したがって、ミドルボックスは、新しいフローを示すパケットを見ると流入あたり状態を作成し、同じフローに属するパケットが到着していない期間後に状態を破壊する場合があります。"
    },
    {
      "indent": 3,
      "text": "Depending on the specific function that the middlebox performs, this behavior can introduce a time-dependency that restricts the kinds of UDP traffic exchanges that will be successful across the middlebox. For example, NATs and firewalls typically define the partial path on one side of them to be interior to the domain they serve, whereas the partial path on their other side is defined to be exterior to that domain. Per-flow state is typically created when the first packet crosses from the interior to the exterior, and while the state is present, NATs and firewalls will forward return traffic. Return traffic that arrives after the per-flow state has timed out is dropped, as is other traffic that arrives from the exterior.",
      "ja": "Middleboxが実行する特定の機能に応じて、この動作は、ミドルボックス全体で成功するUDPトラフィック交換の種類を制限する時間依存性を導入できます。たとえば、NATとファイアウォールは通常、それらの片側の部分的なパスを提供するドメインの内部に定義しますが、反対側の部分的なパスはそのドメインの外側に定義されます。通常、流量状態は、最初のパケットが内部から外部に交差するときに作成され、状態が存在する間、NATとファイアウォールはトラフィックを転送します。外部から到着する他のトラフィックと同様に、フローごとの状態がタイムアウトした後に到着するリターントラフィックが削除されます。"
    },
    {
      "indent": 3,
      "text": "Many applications that use UDP for communication operate across middleboxes without needing to employ additional mechanisms. One example is the Domain Name System (DNS), which has a strict request-response communication pattern that typically completes within seconds.",
      "ja": "コミュニケーションにUDPを使用する多くのアプリケーションは、追加のメカニズムを使用する必要なく、ミドルボックス全体で動作します。1つの例はドメイン名システム（DNS）です。これには、通常数秒以内に完了する厳格なリクエスト応答通信パターンがあります。"
    },
    {
      "indent": 3,
      "text": "Other applications may experience communication failures when middleboxes destroy the per-flow state associated with an application session during periods when the application does not exchange any UDP traffic. Applications SHOULD be able to gracefully handle such communication failures and implement mechanisms to re-establish application-layer sessions and state.",
      "ja": "他のアプリケーションは、アプリケーションがUDPトラフィックを交換しない期間中に、アプリケーションセッションに関連するフローごとの状態をミドルボックスが破壊すると、通信障害が発生する場合があります。アプリケーションは、このような通信の障害を優雅に処理し、アプリケーション層セッションと状態を再確立するメカニズムを実装できる必要があります。"
    },
    {
      "indent": 3,
      "text": "For some applications, such as media transmissions, this re-synchronization is highly undesirable, because it can cause user-perceivable playback artifacts. Such specialized applications MAY send periodic keep-alive messages to attempt to refresh middlebox state. It is important to note that keep-alive messages are NOT RECOMMENDED for general use -- they are unnecessary for many applications and can consume significant amounts of system and network resources.",
      "ja": "メディアの送信などの一部のアプリケーションでは、この再同期は非常に望ましくありません。これは、ユーザーの知覚可能な再生アーティファクトを引き起こす可能性があるためです。このような専門的なアプリケーションは、ミドルボックス状態を更新しようとするために、定期的なキープアライブメッセージを送信する場合があります。キープアライブメッセージは一般的な使用には推奨されないことに注意することが重要です。多くのアプリケーションでは不要であり、かなりの量のシステムリソースとネットワークリソースを消費できることに注意することが重要です。"
    },
    {
      "indent": 3,
      "text": "An application that needs to employ keep-alives to deliver useful service over UDP in the presence of middleboxes SHOULD NOT transmit them more frequently than once every 15 seconds and SHOULD use longer intervals when possible. No common timeout has been specified for per-flow UDP state for arbitrary middleboxes. NATs require a state timeout of 2 minutes or longer [RFC4787]. However, empirical evidence suggests that a significant fraction of currently deployed middleboxes unfortunately use shorter timeouts. The timeout of 15 seconds originates with the Interactive Connectivity Establishment (ICE) protocol [ICE]. When applications are deployed in more controlled network environments, the deployers SHOULD investigate whether the target environment allows applications to use longer intervals, or whether it offers mechanisms to explicitly control middlebox state timeout durations, for example, using Middlebox Communications (MIDCOM) [RFC3303], Next Steps in Signaling (NSIS) [NSLP], or Universal Plug and Play (UPnP) [UPnP]. It is RECOMMENDED that applications apply slight random variations (\"jitter\") to the timing of keep-alive transmissions, to reduce the potential for persistent synchronization between keep-alive transmissions from different hosts.",
      "ja": "ミドルボックスの存在下でUDPを介して有用なサービスを提供するためにKeep-Alivesを採用する必要があるアプリケーションは、15秒ごとに1回よりも頻繁に送信してはならず、可能な場合はより長い間隔を使用する必要があります。任意のミドルボックス用のフローごとのUDP状態には一般的なタイムアウトは指定されていません。NATには、2分以上の状態のタイムアウトが必要です[RFC4787]。ただし、経験的証拠は、現在展開されているミドルボックスのかなりの部分が残念ながら短いタイムアウトを使用していることを示唆しています。15秒のタイムアウトは、インタラクティブな接続確立（ICE）プロトコル[ICE]に由来します。より制御されたネットワーク環境でアプリケーションが展開される場合、展開者は、ターゲット環境でアプリケーションがより長い間隔を使用できるかどうか、またはミドルボックス状態のタイムアウト期間を明示的に制御するメカニズムを提供するかどうかを調査する必要があります。、シグナリングの次のステップ（NSIS）[NSLP]、またはユニバーサルプラグアンドプレイ（UPNP）[UPNP]。アプリケーションは、異なるホストからのキープアライブ送信間の持続的な同期の可能性を減らして、キープアリブ送信のタイミングにわずかなランダム変動（「ジッター」）を適用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "Sending keep-alives is not a substitute for implementing robust connection handling. Like all UDP datagrams, keep-alives can be delayed or dropped, causing middlebox state to time out. In addition, the congestion control guidelines in Section 3.1 cover all UDP transmissions by an application, including the transmission of middlebox keep-alives. Congestion control may thus lead to delays or temporary suspension of keep-alive transmission.",
      "ja": "Keep-Alivesの送信は、堅牢な接続処理を実装する代わりではありません。すべてのUDPデータグラムと同様に、Keep-Alivesを遅延またはドロップすることができ、ミドルボックスの状態がタイムアウトします。さらに、セクション3.1の混雑制御ガイドラインは、Middlebox Keep-Alivesの送信を含むアプリケーションによるすべてのUDP送信をカバーしています。したがって、輻輳制御は、キープアライブ送信の遅延または一時的な停止につながる可能性があります。"
    },
    {
      "indent": 3,
      "text": "Keep-alive messages are NOT RECOMMENDED for general use. They are unnecessary for many applications and may consume significant resources. For example, on battery-powered devices, if an application needs to maintain connectivity for long periods with little traffic, the frequency at which keep-alives are sent can become the determining factor that governs power consumption, depending on the underlying network technology. Because many middleboxes are designed to require keep-alives for TCP connections at a frequency that is much lower than that needed for UDP, this difference alone can often be sufficient to prefer TCP over UDP for these deployments. On the other hand, there is anecdotal evidence that suggests that direct communication through middleboxes, e.g., by using ICE [ICE], does succeed less often with TCP than with UDP. The tradeoffs between different transport protocols -- especially when it comes to middlebox traversal -- deserve careful analysis.",
      "ja": "一般的な使用には、キープアライブメッセージは推奨されません。これらは多くのアプリケーションでは不要であり、重要なリソースを消費する場合があります。たとえば、バッテリー駆動のデバイスでは、アプリケーションがトラフィックが少ない長期にわたって接続を維持する必要がある場合、キープアリブが送信される頻度は、基礎となるネットワークテクノロジーに応じて、消費電力を支配する決定要因になります。多くのミドルボックスは、UDPに必要な周波数よりもはるかに低い周波数でTCP接続のキープアリブを必要とするように設計されているため、これらの展開にはUDPよりもTCPを好むのに十分な違いだけである可能性があります。一方、ミドルボックスを介した直接的な通信、たとえばICE [ICE]を使用することにより、UDPよりもTCPの方が少ないことを示唆する逸話的な証拠があります。特にミドルボックストラバーサルに関しては、異なる輸送プロトコル間のトレードオフは慎重な分析に値します。"
    },
    {
      "indent": 0,
      "text": "3.6. Programming Guidelines",
      "section_title": true,
      "ja": "3.6. プログラミングガイドライン"
    },
    {
      "indent": 3,
      "text": "The de facto standard application programming interface (API) for TCP/IP applications is the \"sockets\" interface [POSIX]. Some platforms also offer applications the ability to directly assemble and transmit IP packets through \"raw sockets\" or similar facilities. This is a second, more cumbersome method of using UDP. The guidelines in this document cover all such methods through which an application may use UDP. Because the sockets API is by far the most common method, the remainder of this section discusses it in more detail.",
      "ja": "TCP/IPアプリケーションの事実上の標準アプリケーションプログラミングインターフェイス（API）は、「ソケット」インターフェイス[POSIX]です。一部のプラットフォームは、「生のソケット」または同様の施設を介してIPパケットを直接組み立てて送信する機能をアプリケーションに提供しています。これは、UDPを使用する2番目の、より面倒な方法です。このドキュメントのガイドラインは、アプリケーションがUDPを使用する可能性のあるすべての方法をカバーしています。Sockets APIははるかに一般的な方法であるため、このセクションの残りの部分で詳細に説明します。"
    },
    {
      "indent": 3,
      "text": "Although the sockets API was developed for UNIX in the early 1980s, a wide variety of non-UNIX operating systems also implement this. The sockets API supports both IPv4 and IPv6 [RFC3493]. The UDP sockets API differs from that for TCP in several key ways. Because application programmers are typically more familiar with the TCP sockets API, the remainder of this section discusses these differences. [STEVENS] provides usage examples of the UDP sockets API.",
      "ja": "ソケットAPIは1980年代初頭にUNIX向けに開発されましたが、さまざまな非ユニックスオペレーティングシステムもこれを実装しています。Sockets APIは、IPv4とIPv6の両方をサポートしています[RFC3493]。UDPソケットAPIは、いくつかの重要な方法でTCPのAPIとは異なります。アプリケーションプログラマーは通常、TCPソケットAPIに精通しているため、このセクションの残りの部分ではこれらの違いについて説明します。[Stevens]は、UDPソケットAPIの使用例を提供します。"
    },
    {
      "indent": 3,
      "text": "UDP datagrams may be directly sent and received, without any connection setup. Using the sockets API, applications can receive packets from more than one IP source address on a single UDP socket. Some servers use this to exchange data with more than one remote host through a single UDP socket at the same time. Many applications need to ensure that they receive packets from a particular source address; these applications MUST implement corresponding checks at the application layer or explicitly request that the operating system filter the received packets.",
      "ja": "UDPデータグラムは、接続セットアップなしで直接送信および受信できます。Sockets APIを使用すると、アプリケーションは単一のUDPソケットの複数のIPソースアドレスからパケットを受信できます。一部のサーバーは、これを使用して、1つのUDPソケットを介して複数のリモートホストと同時にデータを交換します。多くのアプリケーションは、特定のソースアドレスからパケットを受け取るようにする必要があります。これらのアプリケーションは、アプリケーションレイヤーに対応するチェックを実装するか、オペレーティングシステムが受信パケットをフィルタリングすることを明示的に要求する必要があります。"
    },
    {
      "indent": 3,
      "text": "If a client/server application executes on a host with more than one IP interface, the application SHOULD send any UDP responses with an IP source address that matches the IP destination address of the UDP datagram that carried the request (see [RFC1122], Section 4.1.3.5). Many middleboxes expect this transmission behavior and drop replies that are sent from a different IP address, as explained in Section 3.5.",
      "ja": "クライアント/サーバーアプリケーションが複数のIPインターフェースを持つホストで実行される場合、アプリケーションは、リクエストを伝えたUDPデータグラムのIP宛先アドレスと一致するIPソースアドレスでUDP応答を送信する必要があります（[RFC1122]、セクションを参照してください。4.1.3.5）。セクション3.5で説明されているように、多くのミドルボックスは、別のIPアドレスから送信されるこの伝送動作とドロップ応答を期待しています。"
    },
    {
      "indent": 3,
      "text": "A UDP receiver can receive a valid UDP datagram with a zero-length payload. Note that this is different from a return value of zero from a read() socket call, which for TCP indicates the end of the connection.",
      "ja": "UDPレシーバーは、長さがゼロのペイロードで有効なUDPデータグラムを受信できます。これは、read（）ソケットコールのゼロの返品値とは異なることに注意してください。これは、TCPの接続の終了を示しています。"
    },
    {
      "indent": 3,
      "text": "Many operating systems also allow a UDP socket to be connected, i.e., to bind a UDP socket to a specific pair of addresses and ports. This is similar to the corresponding TCP sockets API functionality. However, for UDP, this is only a local operation that serves to simplify the local send/receive functions and to filter the traffic for the specified addresses and ports. Binding a UDP socket does not establish a connection -- UDP does not notify the remote end when a local UDP socket is bound. Binding a socket also allows configuring options that affect the UDP or IP layers, for example, use of the UDP checksum or the IP Timestamp option. On some stacks, a bound socket also allows an application to be notified when ICMP error messages are received for its transmissions [RFC1122].",
      "ja": "また、多くのオペレーティングシステムにより、UDPソケットを接続すること、つまり、UDPソケットを特定のアドレスとポートにバインドすることもできます。これは、対応するTCPソケットAPI機能に似ています。ただし、UDPの場合、これはローカルの送信/受信機能を簡素化し、指定されたアドレスとポートのトラフィックをフィルタリングするのに役立つローカル操作にすぎません。UDPソケットをバインドしても接続は確立されません。UDPは、ローカルUDPソケットがバインドされている場合にリモートエンドに通知しません。ソケットをバインドすると、UDPレイヤーまたはIPレイヤーに影響を与えるオプションを構成することもできます。たとえば、UDPチェックサムまたはIPタイムスタンプオプションの使用。一部のスタックでは、バインドされたソケットを使用すると、ICMPエラーメッセージが送信用に受信されたときにアプリケーションを通知することもできます[RFC1122]。"
    },
    {
      "indent": 3,
      "text": "UDP provides no flow-control. This is another reason why UDP-based applications need to be robust in the presence of packet loss. This loss can also occur within the sending host, when an application sends data faster than the line rate of the outbound network interface. It can also occur on the destination, where receive calls fail to return all the data that was sent when the application issues them too infrequently (i.e., such that the receive buffer overflows). Robust flow control mechanisms are difficult to implement, which is why applications that need this functionality SHOULD consider using a full-featured transport protocol.",
      "ja": "UDPはフロー制御を提供しません。これが、UDPベースのアプリケーションがパケット損失の存在下で堅牢である必要があるもう1つの理由です。この損失は、アプリケーションがアウトバウンドネットワークインターフェイスのラインレートよりも速くデータを送信する場合、送信ホスト内でも発生する可能性があります。また、宛先で発生する可能性があります。通話は、アプリケーションがあまりにも頻繁に発行したときに送信されたすべてのデータを返すことに失敗します（つまり、受信バッファーオーバーフロー）。堅牢なフロー制御メカニズムを実装することは困難です。そのため、この機能が必要なアプリケーションは、フル機能の輸送プロトコルの使用を検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "When an application closes a TCP, SCTP or DCCP socket, the transport protocol on the receiving host is required to maintain TIME-WAIT state. This prevents delayed packets from the closed connection instance from being mistakenly associated with a later connection instance that happens to reuse the same IP address and port pairs. The UDP protocol does not implement such a mechanism. Therefore, UDP-based applications need to be robust in this case. One application may close a socket or terminate, followed in time by another application receiving on the same port. This later application may then receive packets intended for the first application that were delayed in the network.",
      "ja": "アプリケーションがTCP、SCTP、またはDCCPソケットを閉じると、受信ホストの輸送プロトコルが時間待ち状態を維持するために必要です。これにより、閉じた接続インスタンスからの遅延パケットが、同じIPアドレスとポートペアを再利用することがある後の接続インスタンスと誤って関連付けられないようにします。UDPプロトコルは、このようなメカニズムを実装していません。したがって、この場合、UDPベースのアプリケーションは堅牢である必要があります。1つのアプリケーションがソケットを閉じたり、終了したり、同じポートで受信している別のアプリケーションが時間内に続きます。この後のアプリケーションは、ネットワークで遅延した最初のアプリケーション向けのパケットを受信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The Internet can provide service differentiation to applications based on IP-layer packet markings [RFC2475]. This facility can be used for UDP traffic. Different operating systems provide different interfaces for marking packets to applications. Differentiated services require support from the network, and application deployers need to discuss the provisioning of this functionality with their network operator.",
      "ja": "インターネットは、IP層パケットマーキング[RFC2475]に基づいてアプリケーションにサービスの差別化を提供できます。この施設は、UDPトラフィックに使用できます。異なるオペレーティングシステムは、アプリケーションにパケットをマークするために異なるインターフェイスを提供します。差別化されたサービスにはネットワークからのサポートが必要であり、アプリケーションの展開者は、この機能のプロビジョニングをネットワークオペレーターと議論する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7. ICMP Guidelines",
      "section_title": true,
      "ja": "3.7. ICMPガイドライン"
    },
    {
      "indent": 3,
      "text": "Applications can utilize information about ICMP error messages that the UDP layer passes up for a variety of purposes [RFC1122]. Applications SHOULD validate that the information in the ICMP message payload, e.g., a reported error condition, corresponds to a UDP datagram that the application actually sent. Note that not all APIs have the necessary functions to support this validation, and some APIs already perform this validation internally before passing ICMP information to the application.",
      "ja": "アプリケーションは、UDPレイヤーがさまざまな目的で渡すICMPエラーメッセージに関する情報を利用できます[RFC1122]。アプリケーションは、ICMPメッセージのペイロード、たとえば報告されたエラー条件の情報が、アプリケーションが実際に送信したUDPデータグラムに対応することを検証する必要があります。すべてのAPIがこの検証をサポートするために必要な機能を持っているわけではなく、一部のAPIはすでにこの検証を内部的に実行してから、ICMP情報をアプリケーションに渡す前に実行します。"
    },
    {
      "indent": 3,
      "text": "Any application response to ICMP error messages SHOULD be robust to temporary routing failures, i.e., transient ICMP \"unreachable\" messages should not normally cause a communication abort. Applications SHOULD appropriately process ICMP messages generated in response to transmitted traffic. A correct response often requires context, such as local state about communication instances to each destination, that although readily available in connection-oriented transport protocols is not always maintained by UDP-based applications.",
      "ja": "ICMPエラーメッセージに対するアプリケーション応答は、一時的なルーティング障害に対して堅牢である必要があります。つまり、一時的なICMP「到達不可能な」メッセージは通常通信中止を引き起こすべきではありません。アプリケーションは、送信されたトラフィックに応じて生成されたICMPメッセージを適切に処理する必要があります。多くの場合、正しい応答には、各宛先への通信インスタンスに関するローカル州などのコンテキストが必要です。これは、接続指向の輸送プロトコルで容易に利用できるものの、UDPベースのアプリケーションによって常に維持されるとは限りません。"
    },
    {
      "indent": 0,
      "text": "4. Security Considerations",
      "section_title": true,
      "ja": "4. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "UDP does not provide communications security. Applications that need to protect their communications against eavesdropping, tampering, or message forgery SHOULD employ end-to-end security services provided by other IETF protocols. Applications that respond to short requests with potentially large responses are vulnerable to amplification attacks, and SHOULD authenticate the sender before responding. The source IP address of a request is not a useful authenticator, because it can be spoofed.",
      "ja": "UDPは通信セキュリティを提供しません。盗聴、改ざん、またはメッセージ偽造から通信を保護する必要があるアプリケーションは、他のIETFプロトコルが提供するエンドツーエンドのセキュリティサービスを採用する必要があります。潜在的に大きな応答を持つ短い要求に応答するアプリケーションは、増幅攻撃に対して脆弱であり、応答する前に送信者を認証する必要があります。リクエストのソースIPアドレスは、スプーフィングできるため、有用な認証器ではありません。"
    },
    {
      "indent": 3,
      "text": "One option of securing UDP communications is with IPsec [RFC4301], which can provide authentication for flows of IP packets through the Authentication Header (AH) [RFC4302] and encryption and/or authentication through the Encapsulating Security Payload (ESP) [RFC4303]. Applications use the Internet Key Exchange (IKE) [RFC4306] to configure IPsec for their sessions. Depending on how IPsec is configured for a flow, it can authenticate or encrypt the UDP headers as well as UDP payloads. If an application only requires authentication, ESP with no encryption but with authentication is often a better option than AH, because ESP can operate across middleboxes. An application that uses IPsec requires the support of an operating system that implements the IPsec protocol suite.",
      "ja": "UDP通信を保護する1つのオプションは、IPSEC [RFC4301]を使用することです。これは、認証ヘッダー（AH）[RFC4302]を介したIPパケットのフローの認証を提供し、セキュリティペイロード（ESP）[RFC4303]をカプセル化することを介した暗号化および/または認証を提供できます。アプリケーションは、インターネットキーエクスチェンジ（IKE）[RFC4306]を使用して、セッションにIPSECを構成します。FlowにIPSECの構成方法によっては、UDPヘッダーとUDPペイロードを認証または暗号化できます。アプリケーションが認証のみを必要とする場合、ESPはAHよりも優れたオプションであることが多いため、暗号化なしでESPを使用することができます。ESPはミドルボックス間で動作する可能性があるためです。IPSECを使用するアプリケーションでは、IPSECプロトコルスイートを実装するオペレーティングシステムのサポートが必要です。"
    },
    {
      "indent": 3,
      "text": "Although it is possible to use IPsec to secure UDP communications, not all operating systems support IPsec or allow applications to easily configure it for their flows. A second option of securing UDP communications is through Datagram Transport Layer Security (DTLS) [RFC4347]. DTLS provides communication privacy by encrypting UDP payloads. It does not protect the UDP headers. Applications can implement DTLS without relying on support from the operating system.",
      "ja": "IPSECを使用してUDP通信を保護することは可能ですが、すべてのオペレーティングシステムがIPSECをサポートしたり、アプリケーションがフロー用に簡単に構成できるわけではありません。UDP通信を保護する2番目のオプションは、Datagram Transport Layer Security（DTLS）[RFC4347]を使用することです。DTLSは、UDPペイロードを暗号化することにより、通信プライバシーを提供します。UDPヘッダーを保護しません。アプリケーションは、オペレーティングシステムからのサポートに依存することなく、DTLを実装できます。"
    },
    {
      "indent": 3,
      "text": "Many other options for authenticating or encrypting UDP payloads exist. For example, the GSS-API security framework [RFC2743] or Cryptographic Message Syntax (CMS) [RFC3852] could be used to protect UDP payloads. The IETF standard for securing RTP [RFC3550] communication sessions over UDP is the Secure Real-time Transport Protocol (SRTP) [RFC3711]. In some applications, a better solution is to protect larger stand-alone objects, such as files or messages, instead of individual UDP payloads. In these situations, CMS [RFC3852], S/MIME [RFC3851] or OpenPGP [RFC4880] could be used. In addition, there are many non-IETF protocols in this area.",
      "ja": "UDPペイロードを認証または暗号化するための他の多くのオプションが存在します。たとえば、GSS-APIセキュリティフレームワーク[RFC2743]または暗号化メッセージ構文（CMS）[RFC3852]を使用してUDPペイロードを保護できます。UDPを介したRTP [RFC3550]通信セッションを保護するためのIETF標準は、安全なリアルタイム輸送プロトコル（SRTP）[RFC3711]です。一部のアプリケーションでは、より良い解決策は、個々のUDPペイロードの代わりに、ファイルやメッセージなどのより大きなスタンドアロンオブジェクトを保護することです。これらの状況では、CMS [RFC3852]、S/MIME [RFC3851]またはOpenPGP [RFC4880]を使用できます。さらに、この分野には多くの非ITETプロトコルがあります。"
    },
    {
      "indent": 3,
      "text": "Like congestion control mechanisms, security mechanisms are difficult to design and implement correctly. It is hence RECOMMENDED that applications employ well-known standard security mechanisms such as DTLS or IPsec, rather than inventing their own.",
      "ja": "混雑制御メカニズムと同様に、セキュリティメカニズムは正しく設計および実装することが困難です。したがって、アプリケーションは、独自の発明ではなく、DTLやIPSECなどのよく知られた標準セキュリティメカニズムを採用することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The Generalized TTL Security Mechanism (GTSM) [RFC5082] may be used with UDP applications (especially when the intended endpoint is on the same link as the sender). This is a lightweight mechanism that allows a receiver to filter unwanted packets.",
      "ja": "一般化されたTTLセキュリティメカニズム（GTSM）[RFC5082]は、UDPアプリケーションで使用できます（特に、意図したエンドポイントが送信者と同じリンクにある場合）。これは、レシーバーが不要なパケットをフィルタリングできる軽量メカニズムです。"
    },
    {
      "indent": 3,
      "text": "In terms of congestion control, [RFC2309] and [RFC2914] discuss the dangers of congestion-unresponsive flows to the Internet. This document provides guidelines to designers of UDP-based applications to congestion-control their transmissions, and does not raise any additional security concerns.",
      "ja": "混雑制御に関しては、[RFC2309]および[RFC2914]は、インターネットへの渋滞と応答性のある流れの危険性について議論します。このドキュメントは、UDPベースのアプリケーションのデザイナーに、渋滞制御の送信を提供し、追加のセキュリティ上の懸念を提起しません。"
    },
    {
      "indent": 0,
      "text": "5. Summary",
      "section_title": true,
      "ja": "5. まとめ"
    },
    {
      "indent": 3,
      "text": "This section summarizes the guidelines made in Sections 3 and 4 in a tabular format (Table 1) for easy referencing.",
      "ja": "このセクションでは、セクション3および4で作成されたガイドラインを形式形式（表1）で要約して、簡単に参照します。"
    },
    {
      "indent": 3,
      "text": "+---------------------------------------------------------+---------+\n| Recommendation                                          | Section |\n+---------------------------------------------------------+---------+\n| MUST tolerate a wide range of Internet path conditions  | 3       |\n| SHOULD use a full-featured transport (TCP, SCTP, DCCP)  |         |\n|                                                         |         |\n| SHOULD control rate of transmission                     | 3.1     |\n| SHOULD perform congestion control over all traffic      |         |\n|                                                         |         |\n| for bulk transfers,                                     | 3.1.1   |\n| SHOULD consider implementing TFRC                       |         |\n| else, SHOULD in other ways use bandwidth similar to TCP |         |\n|                                                         |         |\n| for non-bulk transfers,                                 | 3.1.2   |\n| SHOULD measure RTT and transmit max. 1 datagram/RTT     |         |\n| else, SHOULD send at most 1 datagram every 3 seconds    |         |\n| SHOULD back-off retransmission timers following loss    |         |\n|                                                         |         |\n| for tunnels carrying IP Traffic,                        | 3.1.3   |\n| SHOULD NOT perform congestion control                   |         |\n|                                                         |         |\n| for non-IP tunnels or rate not determined by traffic,   | 3.1.3   |\n| SHOULD perform congestion control                       |         |\n|                                                         |         |\n| SHOULD NOT send datagrams that exceed the PMTU, i.e.,   | 3.2     |\n| SHOULD discover PMTU or send datagrams < minimum PMTU   |         |\n|                                                         |         |\n| SHOULD handle datagram loss, duplication, reordering    | 3.3     |\n| SHOULD be robust to delivery delays up to 2 minutes     |         |\n|                                                         |         |\n| SHOULD enable IPv4 UDP checksum                         | 3.4     |\n| MUST enable IPv6 UDP checksum                           |         |\n| else, MAY use UDP-Lite with suitable checksum coverage  | 3.4.1   |\n|                                                         |         |\n| SHOULD NOT always send middlebox keep-alives            | 3.5     |\n| MAY use keep-alives when needed (min. interval 15 sec)  |         |\n|                                                         |         |\n| MUST check IP source address                            | 3.6     |\n| and, for client/server applications                     |         |\n| SHOULD send responses from src address matching request |         |\n|                                                         |         |\n| SHOULD use standard IETF security protocols when needed | 4       |\n+---------------------------------------------------------+---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 1: Summary of recommendations",
      "ja": "表1：推奨事項の概要"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgments",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "Thanks to Paul Aitken, Mark Allman, Francois Audet, Iljitsch van Beijnum, Stewart Bryant, Remi Denis-Courmont, Lisa Dusseault, Wesley Eddy, Pasi Eronen, Sally Floyd, Robert Hancock, Jeffrey Hutzelman, Cullen Jennings, Tero Kivinen, Peter Koch, Jukka Manner, Philip Matthews, Joerg Ott, Colin Perkins, Tom Petch, Carlos Pignataro, Pasi Sarolahti, Pascal Thubert, Joe Touch, Dave Ward, and Magnus Westerlund for their comments on this document.",
      "ja": "ポール・エイトケン、マーク・オールマン、フランソワ・オーデット、イルジッチ・ヴァン・ベイナム、スチュワート・ブライアント、レミ・デニス・コールモント、リサ・デスー、ウェスリー・エディ、パシ・エロネン、サリー・フロイド、ロバート・ハンコック、ジェフリー・ハッツェルマン、カレン・ジェニンニンズ、テロ・キビネン、ジュッカマナー、フィリップマシューズ、ジョーグオット、コリンパーキンス、トムペチン、カルロスピグナタロ、パシサロラティ、パスカルシューベルト、ジョータッチ、デイブウォード、マグナスウェスターランドは、この文書に関するコメントをしました。"
    },
    {
      "indent": 3,
      "text": "The middlebox traversal guidelines in Section 3.5 incorporate ideas from Section 5 of [BEHAVE-APP] by Bryan Ford, Pyda Srisuresh, and Dan Kegel.",
      "ja": "セクション3.5のミドルボックストラバーサルガイドラインには、Bryan Ford、Pyda Srisuresh、およびDan Kegelの[bevave-app]のセクション5のアイデアが組み込まれています。"
    },
    {
      "indent": 3,
      "text": "Lars Eggert is partly funded by [TRILOGY], a research project supported by the European Commission under its Seventh Framework Program. Gorry Fairhurst was partly funded by the EC SatNEx project.",
      "ja": "Lars Eggertは、7番目のフレームワークプログラムに基づいて欧州委員会がサポートする研究プロジェクトである[Trilogy]によって部分的に資金提供されています。Gorry Fairhurstは、EC SatNexプロジェクトによって部分的に資金提供されていました。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC0768] Postel, J., \"User Datagram Protocol\", STD 6, RFC 768, August 1980.",
      "ja": "[RFC0768] Postel、J。、「ユーザーデータグラムプロトコル」、STD 6、RFC 768、1980年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC0793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC0793] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC1981] McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery for IP version 6\", RFC 1981, August 1996.",
      "ja": "[RFC1981] McCann、J.、Deering、S。、およびJ. Mogul、「IPバージョン6のPath MTU Discovery」、RFC 1981、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2460] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6) Specification\", RFC 2460, December 1998.",
      "ja": "[RFC2460] Deering、S。およびR. Hinden、「インターネットプロトコル、バージョン6（IPv6）仕様」、RFC 2460、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2914] Floyd, S., \"Congestion Control Principles\", BCP 41, RFC 2914, September 2000.",
      "ja": "[RFC2914]フロイド、S。、「混雑制御原則」、BCP 41、RFC 2914、2000年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988] Paxson、V。およびM. Allman、「TCPの再送信タイマーのコンピューティング」、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3828] Larzon, L-A., Degermark, M., Pink, S., Jonsson, L-E., and G. Fairhurst, \"The Lightweight User Datagram Protocol (UDP-Lite)\", RFC 3828, July 2004.",
      "ja": "[RFC3828] Larzon、L-A。、Degermark、M.、Pink、S.、Jonsson、L-E。、およびG. Fairhurst、「The Lightweight User Datagram Protocol（UDP-Lite）」、RFC 3828、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4787] Audet, F. and C. Jennings, \"Network Address Translation (NAT) Behavioral Requirements for Unicast UDP\", BCP 127, RFC 4787, January 2007.",
      "ja": "[RFC4787] Audet、F。およびC. Jennings、「Unicast UDPのネットワークアドレス変換（NAT）行動要件」、BCP 127、RFC 4787、2007年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC5348] Floyd, S., Handley, M., Padhye, J., and J. Widmer, \"TCP Friendly Rate Control (TFRC): Protocol Specification\", RFC 5348, September 2008.",
      "ja": "[RFC5348] Floyd、S.、Handley、M.、Padhye、J。、およびJ. Widmer、「TCP Friendry Rate Control（TFRC）：プロトコル仕様」、RFC 5348、2008年9月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[BEHAVE-APP] Ford, B., \"Application Design Guidelines for Traversal through Network Address Translators\", Work in Progress, March 2007.",
      "ja": "[beave-app] Ford、B。、「ネットワークアドレス翻訳者を介したトラバーサルのアプリケーション設計ガイドライン」、2007年3月、Work in Progress。"
    },
    {
      "indent": 3,
      "text": "[CCID4] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion ID 4: TCP-Friendly Rate Control for Small Packets (TFRC-SP)\", Work in Progress, February 2008.",
      "ja": "[CCID4] Floyd、S。およびE. Kohler、「データグラムの混雑制御プロトコルのプロファイル（DCCP）混雑ID 4：TCPフレンドリーレートコントロール（TFRC-SP）」、2008年2月の作業。"
    },
    {
      "indent": 3,
      "text": "[FABER] Faber, T., Touch, J., and W. Yue, \"The TIME-WAIT State in TCP and Its Effect on Busy Servers\", Proc. IEEE Infocom, March 1999.",
      "ja": "[Faber] Faber、T.、Touch、J。、およびW. Yue、「TCPの時間待合状態と忙しいサーバーへの影響」、Proc。IEEE Infocom、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[GIST] Schulzrinne, H. and R. Hancock, \"GIST: General Internet Signalling Transport\", Work in Progress, July 2008.",
      "ja": "[GIST] Schulzrinne、H。およびR. Hancock、「Gist：General Internet Signing Transport」、2008年7月の作業。"
    },
    {
      "indent": 3,
      "text": "[ICE] Rosenberg, J., \"Interactive Connectivity Establishment (ICE): A Protocol for Network Address Translator (NAT) Traversal for Offer/Answer Protocols\", Work in Progress, October 2007.",
      "ja": "[ICE] Rosenberg、J。、「Interactive Connectivity Indecivity（ICE）：オファー/回答プロトコルのネットワークアドレス翻訳者（NAT）トラバーサルのプロトコル」、2007年10月の進行中。"
    },
    {
      "indent": 3,
      "text": "[NSLP] Stiemerling, M., Tschofenig, H., Aoun, C., and E. Davies, \"NAT/Firewall NSIS Signaling Layer Protocol (NSLP)\", Work in Progress, September 2008.",
      "ja": "[NSLP] Stiemerling、M.、Tschofenig、H.、Aoun、C。、およびE. Davies、「Nat/Firewall NSIS Signaling Layer Protocol（NSLP）」、2008年9月の作業。"
    },
    {
      "indent": 3,
      "text": "[POSIX] IEEE Std. 1003.1-2001, \"Standard for Information Technology - Portable Operating System Interface (POSIX)\", Open Group Technical Standard: Base Specifications Issue 6, ISO/IEC 9945:2002, December 2001.",
      "ja": "[posix] IEEE std。1003.1-2001、「情報技術の標準 - ポータブルオペレーティングシステムインターフェイス（POSIX）」、オープングループ技術標準：基本仕様問題6、ISO/IEC 9945：2002、2001年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC0896] Nagle, J., \"Congestion control in IP/TCP internetworks\", RFC 896, January 1984.",
      "ja": "[RFC0896] Nagle、J。、「IP/TCPインターネットワークスの混雑制御」、RFC 896、1984年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC0919] Mogul, J., \"Broadcasting Internet Datagrams\", STD 5, RFC 919, October 1984.",
      "ja": "[RFC0919] Mogul、J。、「インターネットデータグラムの放送」、STD 5、RFC 919、1984年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1112] Deering, S., \"Host extensions for IP multicasting\", STD 5, RFC 1112, August 1989.",
      "ja": "[RFC1112] Deering、S。、「IPマルチキャストのホスト拡張」、STD 5、RFC 1112、1989年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC1536] Kumar, A., Postel, J., Neuman, C., Danzig, P., and S. Miller, \"Common DNS Implementation Errors and Suggested Fixes\", RFC 1536, October 1993.",
      "ja": "[RFC1536] Kumar、A.、Postel、J.、Neuman、C.、Danzig、P。、およびS. Miller、「一般的なDNS実装エラーと提案された修正」、RFC 1536、1993年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1546] Partridge, C., Mendez, T., and W. Milliken, \"Host Anycasting Service\", RFC 1546, November 1993.",
      "ja": "[RFC1546] Partridge、C.、Mendez、T。、およびW. Milliken、「Host Anycasting Service」、RFC 1546、1993年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2309] Braden, B., Clark, D., Crowcroft, J., Davie, B., Deering, S., Estrin, D., Floyd, S., Jacobson, V., Minshall, G., Partridge, C., Peterson, L., Ramakrishnan, K., Shenker, S., Wroclawski, J., and L. Zhang, \"Recommendations on Queue Management and Congestion Avoidance in the Internet\", RFC 2309, April 1998.",
      "ja": "[RFC2309] Braden、B.、Clark、D.、Crowcroft、J.、Davie、B.、Deering、S.、Estrin、D.、Floyd、S.、Jacobson、V.、Minshall、G.、Partridge、C.、Peterson、L.、Ramakrishnan、K.、Shenker、S.、Wroclawski、J。、およびL. Zhang、「インターネットでのキュー管理と混雑回避に関する推奨事項」、RFC 2309、1998年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2475] Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z., and W. Weiss, \"An Architecture for Differentiated Services\", RFC 2475, December 1998.",
      "ja": "[RFC2475] Blake、S.、Black、D.、Carlson、M.、Davies、E.、Wang、Z.、およびW. Weiss、「差別化されたサービスの建築」、RFC 2475、1998年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC2675] Borman, D., Deering, S., and R. Hinden, \"IPv6 Jumbograms\", RFC 2675, August 1999.",
      "ja": "[RFC2675]ボーマン、D。、ディアリング、S。、およびR.ヒンデン、「IPv6ジャンボグラム」、RFC 2675、1999年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC2743] Linn, J., \"Generic Security Service Application Program Interface Version 2, Update 1\", RFC 2743, January 2000.",
      "ja": "[RFC2743] Linn、J。、「Generic Security Service Application Program Interfaceバージョン2、Update 1」、RFC 2743、2000年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3048] Whetten, B., Vicisano, L., Kermode, R., Handley, M., Floyd, S., and M. Luby, \"Reliable Multicast Transport Building Blocks for One-to-Many Bulk-Data Transfer\", RFC 3048, January 2001.",
      "ja": "[RFC3048] Whetten、B.、Vicisano、L.、Kermode、R.、Handley、M.、Floyd、S。、およびM. Luby、「1対Many Bulk-Data転送用の信頼できるマルチキャスト輸送ビルディングブロック」、RFC 3048、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3124] Balakrishnan, H. and S. Seshan, \"The Congestion Manager\", RFC 3124, June 2001.",
      "ja": "[RFC3124] Balakrishnan、H。およびS. Seshan、「ザ・ミッシェンマネージャー」、RFC 3124、2001年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3261] Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston, A., Peterson, J., Sparks, R., Handley, M., and E. Schooler, \"SIP: Session Initiation Protocol\", RFC 3261, June 2002.",
      "ja": "[RFC3261] Rosenberg、J.、Schulzrinne、H.、Camarillo、G.、Johnston、A.、Peterson、J.、Sparks、R.、Handley、M。、およびE. Schooler、「SIP：SESSION Intioniation Protocol」、RFC 3261、2002年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3303] Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A., and A. Rayhan, \"Middlebox communication architecture and framework\", RFC 3303, August 2002.",
      "ja": "[RFC3303] Srisuresh、P.、Kuthan、J.、Rosenberg、J.、Molitor、A。、およびA. Rayhan、「Middlebox Communication Architecture and Framework」、RFC 3303、2002年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC3493] Gilligan, R., Thomson, S., Bound, J., McCann, J., and W. Stevens, \"Basic Socket Interface Extensions for IPv6\", RFC 3493, February 2003.",
      "ja": "[RFC3493] Gilligan、R.、Thomson、S.、Bound、J.、McCann、J。、およびW. Stevens、「IPv6の基本ソケットインターフェイス拡張」、RFC 3493、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3550] Schulzrinne, H., Casner, S., Frederick, R., and V. Jacobson, \"RTP: A Transport Protocol for Real-Time Applications\", STD 64, RFC 3550, July 2003.",
      "ja": "[RFC3550] Schulzrinne、H.、Casner、S.、Frederick、R。、およびV. Jacobson、「RTP：リアルタイムアプリケーション用の輸送プロトコル」、STD 64、RFC 3550、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3551] Schulzrinne, H. and S. Casner, \"RTP Profile for Audio and Video Conferences with Minimal Control\", STD 65, RFC 3551, July 2003.",
      "ja": "[RFC3551] Schulzrinne、H。およびS. Casner、「最小限のコントロールを備えたオーディオおよびビデオ会議のRTPプロファイル」、STD 65、RFC 3551、2003年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3711] Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K. Norrman, \"The Secure Real-time Transport Protocol (SRTP)\", RFC 3711, March 2004.",
      "ja": "[RFC3711] Baugher、M.、McGrew、D.、Naslund、M.、Carrara、E。、およびK. Norrman、「安全なリアルタイム輸送プロトコル（SRTP）」、RFC 3711、2004年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3738] Luby, M. and V. Goyal, \"Wave and Equation Based Rate Control (WEBRC) Building Block\", RFC 3738, April 2004.",
      "ja": "[RFC3738] Luby、M。およびV. Goyal、「波と方程式ベースのレート制御（WEBRC）ビルディングブロック」、RFC 3738、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3758] Stewart, R., Ramalho, M., Xie, Q., Tuexen, M., and P. Conrad, \"Stream Control Transmission Protocol (SCTP) Partial Reliability Extension\", RFC 3758, May 2004.",
      "ja": "[RFC3758] Stewart、R.、Ramalho、M.、Xie、Q.、Tuexen、M.、およびP. Conrad、「ストリーム制御伝送プロトコル（SCTP）部分信頼性拡張」、RFC 3758、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC3819] Karn, P., Bormann, C., Fairhurst, G., Grossman, D., Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and L. Wood, \"Advice for Internet Subnetwork Designers\", BCP 89, RFC 3819, July 2004.",
      "ja": "[RFC3819] Karn、P.、Bormann、C.、Fairhurst、G.、Grossman、D.、Ludwig、R.、Mahdavi、J.、Montenegro、G.、Touch、J.、およびL. Wood、「アドバイス」アドバイスインターネットサブネットワークデザイナー向け」、BCP 89、RFC 3819、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3851] Ramsdell, B., \"Secure/Multipurpose Internet Mail Extensions (S/MIME) Version 3.1 Message Specification\", RFC 3851, July 2004.",
      "ja": "[RFC3851] Ramsdell、B。、「Secure/Multipurpose Internet Mail Extensions（S/MIME）バージョン3.1メッセージ仕様」、RFC 3851、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC3852] Housley, R., \"Cryptographic Message Syntax (CMS)\", RFC 3852, July 2004.",
      "ja": "[RFC3852] Housley、R。、「暗号化メッセージ構文（CMS）」、RFC 3852、2004年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4301] Kent, S. and K. Seo, \"Security Architecture for the Internet Protocol\", RFC 4301, December 2005.",
      "ja": "[RFC4301] Kent、S。およびK. SEO、「インターネットプロトコルのセキュリティアーキテクチャ」、RFC 4301、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302, December 2005.",
      "ja": "[RFC4302] Kent、S。、「IP認証ヘッダー」、RFC 4302、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\", RFC 4303, December 2005.",
      "ja": "[RFC4303] Kent、S。、「セキュリティペイロード（ESP）」、RFC 4303、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4306] Kaufman, C., \"Internet Key Exchange (IKEv2) Protocol\", RFC 4306, December 2005.",
      "ja": "[RFC4306] Kaufman、C。、「Internet Key Exchange（IKEV2）プロトコル」、RFC 4306、2005年12月。"
    },
    {
      "indent": 3,
      "text": "[RFC4340] Kohler, E., Handley, M., and S. Floyd, \"Datagram Congestion Control Protocol (DCCP)\", RFC 4340, March 2006.",
      "ja": "[RFC4340] Kohler、E.、Handley、M。、およびS. Floyd、「Datagramうっ血制御プロトコル（DCCP）」、RFC 4340、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4341] Floyd, S. and E. Kohler, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 2: TCP-like Congestion Control\", RFC 4341, March 2006.",
      "ja": "[RFC4341] Floyd、S。およびE. Kohler、「データグラムの混雑制御プロトコルのプロファイル（DCCP）混雑制御ID 2：TCP様渋滞制御」、RFC 4341、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4342] Floyd, S., Kohler, E., and J. Padhye, \"Profile for Datagram Congestion Control Protocol (DCCP) Congestion Control ID 3: TCP-Friendly Rate Control (TFRC)\", RFC 4342, March 2006.",
      "ja": "[RFC4342] Floyd、S.、Kohler、E。、およびJ. Padhye、「データグラムの混雑制御プロトコル（DCCP）混雑制御IDのプロファイル：TCPに優しいレート制御（TFRC）」、RFC 4342、2006年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer Security\", RFC 4347, April 2006.",
      "ja": "[RFC4347] Rescorla、E。およびN. Modadugu、「Datagram Transport Layer Security」、RFC 4347、2006年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4654] Widmer, J. and M. Handley, \"TCP-Friendly Multicast Congestion Control (TFMCC): Protocol Specification\", RFC 4654, August 2006.",
      "ja": "[RFC4654] Widmer、J。およびM. Handley、「TCPフレンドリーマルチキャスト輻輳制御（TFMCC）：プロトコル仕様」、RFC 4654、2006年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC4880] Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R. Thayer, \"OpenPGP Message Format\", RFC 4880, November 2007.",
      "ja": "[RFC4880] Callas、J.、Donnerhacke、L.、Finney、H.、Shaw、D。、およびR. Thayer、「OpenPGPメッセージ形式」、RFC 4880、2007年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC4960] Stewart, R., \"Stream Control Transmission Protocol\", RFC 4960, September 2007.",
      "ja": "[RFC4960] Stewart、R。、「Stream Control Transmission Protocol」、RFC 4960、2007年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC4963] Heffner, J., Mathis, M., and B. Chandler, \"IPv4 Reassembly Errors at High Data Rates\", RFC 4963, July 2007.",
      "ja": "[RFC4963] Heffner、J.、Mathis、M。、およびB. Chandler、「IPv4の高データレートでの再組み立てエラー」、RFC 4963、2007年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC4987] Eddy, W., \"TCP SYN Flooding Attacks and Common Mitigations\", RFC 4987, August 2007.",
      "ja": "[RFC4987] Eddy、W。、「TCP Syn Flooding Attacks and Common Mitigations」、RFC 4987、2007年8月。"
    },
    {
      "indent": 3,
      "text": "[RFC5082] Gill, V., Heasley, J., Meyer, D., Savola, P., and C. Pignataro, \"The Generalized TTL Security Mechanism (GTSM)\", RFC 5082, October 2007.",
      "ja": "[RFC5082] Gill、V.、Heasley、J.、Meyer、D.、Savola、P。、およびC. Pignataro、「一般化されたTTLセキュリティメカニズム（GTSM）」、RFC 5082、2007年10月。"
    },
    {
      "indent": 3,
      "text": "[STEVENS] Stevens, W., Fenner, B., and A. Rudoff, \"UNIX Network Programming, The sockets Networking API\", Addison-Wesley, 2004.",
      "ja": "[Stevens] Stevens、W.、Fenner、B。、およびA. Rudoff、「Unix Networkプログラミング、The Sockets Networking API」、Addison-Wesley、2004。"
    },
    {
      "indent": 3,
      "text": "[TRILOGY] \"Trilogy Project\", <http://www.trilogy-project.org>.",
      "ja": "[Trilogy]「Trilogy Project」、<http://www.trilogy-project.org>。"
    },
    {
      "indent": 3,
      "text": "[UPnP] UPnP Forum, \"Internet Gateway Device (IGD) Standardized Device Control Protocol V 1.0\", November 2001.",
      "ja": "[UPNP] UPNPフォーラム、「インターネットゲートウェイデバイス（IGD）標準化されたデバイス制御プロトコルV 1.0」、2001年11月。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Lars Eggert Nokia Research Center P.O. Box 407 Nokia Group 00045 Finland",
      "ja": "Lars Eggert Nokia Research Center P.O.Box 407 Nokia Group 00045フィンランド"
    },
    {
      "indent": 3,
      "text": "Phone: +358 50 48 24461\nEMail: lars.eggert@nokia.com\nURI:   http://people.nokia.net/~lars/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Godred Fairhurst University of Aberdeen Department of Engineering Fraser Noble Building Aberdeen AB24 3UE Scotland",
      "ja": "ゴッドレッドフェアハーストアバディーン大学工学部フレイザーノーブルビルアバディーンAB24 3Uスコットランド"
    },
    {
      "indent": 3,
      "text": "EMail: gorry@erg.abdn.ac.uk\nURI:   http://www.erg.abdn.ac.uk/",
      "raw": true,
      "ja": ""
    }
  ]
}