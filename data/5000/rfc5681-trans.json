{
  "title": {
    "text": "RFC 5681 - TCP Congestion Control",
    "ja": "RFC 5681 - TCP混雑制御"
  },
  "number": 5681,
  "created_at": "2023-02-20 07:17:46.278722+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Network Working Group                                          M. Allman\nRequest for Comments: 5681                                     V. Paxson\nObsoletes: 2581                                                     ICSI\nCategory: Standards Track                                     E. Blanton\n                                                       Purdue University\n                                                          September 2009",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "TCP Congestion Control",
      "ja": "TCP混雑制御"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines TCP's four intertwined congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery. In addition, the document specifies how TCP should begin transmission after a relatively long idle period, as well as discussing various acknowledgment generation methods. This document obsoletes RFC 2581.",
      "ja": "このドキュメントでは、TCPの4つの絡み合った混雑制御アルゴリズムを定義します。スロースタート、混雑回避、迅速な再送信、迅速な回復です。さらに、ドキュメントは、比較的長いアイドル期間後にTCPが送信を開始する方法を指定し、さまざまな承認生成方法について議論します。このドキュメントは、RFC 2581を廃止します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document specifies an Internet standards track protocol for the Internet community, and requests discussion and suggestions for improvements. Please refer to the current edition of the \"Internet Official Protocol Standards\" (STD 1) for the standardization state and status of this protocol. Distribution of this memo is unlimited.",
      "ja": "このドキュメントは、インターネットコミュニティのインターネット標準トラックプロトコルを指定し、改善のための議論と提案を要求します。このプロトコルの標準化状態とステータスについては、「インターネット公式プロトコル標準」（STD 1）の現在のエディションを参照してください。このメモの配布は無制限です。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2009 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2009 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents in effect on the date of publication of this document (http://trustee.ietf.org/license-info). Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびこのドキュメントの公開日（http://trustee.ietf.org/license-info）に有効なIETFドキュメントに関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの寄付からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得せずに、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版またはそれを英語以外の言語に翻訳するため。"
    },
    {
      "indent": 0,
      "text": "Table Of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................2\n2. Definitions .....................................................3\n3. Congestion Control Algorithms ...................................4\n   3.1. Slow Start and Congestion Avoidance ........................4\n   3.2. Fast Retransmit/Fast Recovery ..............................8\n4. Additional Considerations ......................................10\n   4.1. Restarting Idle Connections ...............................10\n   4.2. Generating Acknowledgments ................................11\n   4.3. Loss Recovery Mechanisms ..................................12\n5. Security Considerations ........................................13\n6. Changes between RFC 2001 and RFC 2581 ..........................13\n7. Changes Relative to RFC 2581 ...................................14\n8. Acknowledgments ................................................15\n9. References .....................................................15\n   9.1. Normative References ......................................15\n   9.2. Informative References ....................................16",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document specifies four TCP [RFC793] congestion control algorithms: slow start, congestion avoidance, fast retransmit and fast recovery. These algorithms were devised in [Jac88] and [Jac90]. Their use with TCP is standardized in [RFC1122]. Additional early work in additive-increase, multiplicative-decrease congestion control is given in [CJ89].",
      "ja": "このドキュメントは、4つのTCP [RFC793]混雑制御アルゴリズムを指定します。スロースタート、混雑回避、迅速な再送信、迅速な回復。これらのアルゴリズムは[JAC88]および[JAC90]で考案されました。TCPでの使用は[RFC1122]に標準化されています。追加の初期の作業は、追加の早期作業であり、[CJ89]には乗法廃棄物の混雑制御が示されています。"
    },
    {
      "indent": 3,
      "text": "Note that [Ste94] provides examples of these algorithms in action and [WS95] provides an explanation of the source code for the BSD implementation of these algorithms.",
      "ja": "[STE94]は、これらのアルゴリズムの動作の例を提供し、[WS95]がこれらのアルゴリズムのBSD実装のソースコードの説明を提供することに注意してください。"
    },
    {
      "indent": 3,
      "text": "In addition to specifying these congestion control algorithms, this document specifies what TCP connections should do after a relatively long idle period, as well as specifying and clarifying some of the issues pertaining to TCP ACK generation.",
      "ja": "これらの混雑制御アルゴリズムの指定に加えて、このドキュメントは、TCP接続が比較的長いアイドル期間後に行うべきことを指定し、TCP ACK生成に関する問題の一部を指定および明確にします。"
    },
    {
      "indent": 3,
      "text": "This document obsoletes [RFC2581], which in turn obsoleted [RFC2001].",
      "ja": "この文書は、[RFC2581]を廃止し、次に[RFC2001]を廃止しました。"
    },
    {
      "indent": 3,
      "text": "This document is organized as follows. Section 2 provides various definitions that will be used throughout the document. Section 3 provides a specification of the congestion control algorithms. Section 4 outlines concerns related to the congestion control algorithms and finally, section 5 outlines security considerations.",
      "ja": "このドキュメントは次のように整理されています。セクション2では、ドキュメント全体で使用されるさまざまな定義を提供します。セクション3では、輻輳制御アルゴリズムの仕様を示します。セクション4は、輻輳制御アルゴリズムに関連する懸念の概要を示し、最後にセクション5でセキュリティに関する考慮事項の概要を説明します。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 0,
      "text": "2. Definitions",
      "section_title": true,
      "ja": "2. 定義"
    },
    {
      "indent": 3,
      "text": "This section provides the definition of several terms that will be used throughout the remainder of this document.",
      "ja": "このセクションでは、このドキュメントの残りの部分で使用されるいくつかの用語の定義を提供します。"
    },
    {
      "indent": 3,
      "text": "SEGMENT: A segment is ANY TCP/IP data or acknowledgment packet (or both).",
      "ja": "セグメント：セグメントは、TCP/IPデータまたは確認パケット（またはその両方）です。"
    },
    {
      "indent": 3,
      "text": "SENDER MAXIMUM SEGMENT SIZE (SMSS): The SMSS is the size of the largest segment that the sender can transmit. This value can be based on the maximum transmission unit of the network, the path MTU discovery [RFC1191, RFC4821] algorithm, RMSS (see next item), or other factors. The size does not include the TCP/IP headers and options.",
      "ja": "送信者の最大セグメントサイズ（SMSS）：SMSSは、送信者が送信できる最大のセグメントのサイズです。この値は、ネットワークの最大送信ユニット、PATH MTU発見[RFC1191、RFC4821]アルゴリズム、RMSS（次のアイテムを参照）、またはその他の要因に基づいています。サイズには、TCP/IPヘッダーとオプションは含まれません。"
    },
    {
      "indent": 3,
      "text": "RECEIVER MAXIMUM SEGMENT SIZE (RMSS): The RMSS is the size of the largest segment the receiver is willing to accept. This is the value specified in the MSS option sent by the receiver during connection startup. Or, if the MSS option is not used, it is 536 bytes [RFC1122]. The size does not include the TCP/IP headers and options.",
      "ja": "受信機の最大セグメントサイズ（RMSS）：RMSSは、受信者が受け入れる最大セグメントのサイズです。これは、接続スタートアップ中に受信機が送信したMSSオプションで指定された値です。または、MSSオプションを使用していない場合、536バイト[RFC1122]です。サイズには、TCP/IPヘッダーとオプションは含まれません。"
    },
    {
      "indent": 3,
      "text": "FULL-SIZED SEGMENT: A segment that contains the maximum number of data bytes permitted (i.e., a segment containing SMSS bytes of data).",
      "ja": "フルサイズのセグメント：許可されているデータバイトの最大数を含むセグメント（つまり、SMSSバイトのデータを含むセグメント）。"
    },
    {
      "indent": 3,
      "text": "RECEIVER WINDOW (rwnd): The most recently advertised receiver window.",
      "ja": "レシーバーウィンドウ（RWND）：最近宣伝されたレシーバーウィンドウ。"
    },
    {
      "indent": 3,
      "text": "CONGESTION WINDOW (cwnd): A TCP state variable that limits the amount of data a TCP can send. At any given time, a TCP MUST NOT send data with a sequence number higher than the sum of the highest acknowledged sequence number and the minimum of cwnd and rwnd.",
      "ja": "輻輳ウィンドウ（CWND）：TCPが送信できるデータの量を制限するTCP状態変数。いつでも、TCPは、最高の認識されたシーケンス数とCWNDおよびRWNDの最小値の合計よりも高いシーケンス数を持つデータを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "INITIAL WINDOW (IW): The initial window is the size of the sender's congestion window after the three-way handshake is completed.",
      "ja": "初期ウィンドウ（IW）：最初のウィンドウは、3方向の握手が完了した後の送信者の混雑ウィンドウのサイズです。"
    },
    {
      "indent": 3,
      "text": "LOSS WINDOW (LW): The loss window is the size of the congestion window after a TCP sender detects loss using its retransmission timer.",
      "ja": "損失ウィンドウ（LW）：損失ウィンドウは、TCP送信者が再送信タイマーを使用して損失を検出した後の混雑ウィンドウのサイズです。"
    },
    {
      "indent": 3,
      "text": "RESTART WINDOW (RW): The restart window is the size of the congestion window after a TCP restarts transmission after an idle period (if the slow start algorithm is used; see section 4.1 for more discussion).",
      "ja": "再起動ウィンドウ（RW）：再起動ウィンドウは、TCPがアイドル期間の後に転送を再起動した後の混雑ウィンドウのサイズです（遅いスタートアルゴリズムを使用する場合。詳細についてはセクション4.1を参照）。"
    },
    {
      "indent": 3,
      "text": "FLIGHT SIZE: The amount of data that has been sent but not yet cumulatively acknowledged.",
      "ja": "飛行サイズ：送信されたがまだ累積的に認められていないデータの量。"
    },
    {
      "indent": 3,
      "text": "DUPLICATE ACKNOWLEDGMENT: An acknowledgment is considered a \"duplicate\" in the following algorithms when (a) the receiver of the ACK has outstanding data, (b) the incoming acknowledgment carries no data, (c) the SYN and FIN bits are both off, (d) the acknowledgment number is equal to the greatest acknowledgment received on the given connection (TCP.UNA from [RFC793]) and (e) the advertised window in the incoming acknowledgment equals the advertised window in the last incoming acknowledgment.",
      "ja": "重複する謝辞：（a）ACKの受信者に未解決のデータがある場合、次のアルゴリズムの「重複」と見なされます。（d）謝辞番号は、指定された接続（[RFC793]からのTCP.UNA）で受け取った最大の承認と等しく、（e）着信謝辞の宣伝されたウィンドウは、最後の着信謝辞の宣伝されたウィンドウに等しくなります。"
    },
    {
      "indent": 6,
      "text": "Alternatively, a TCP that utilizes selective acknowledgments (SACKs) [RFC2018, RFC2883] can leverage the SACK information to determine when an incoming ACK is a \"duplicate\" (e.g., if the ACK contains previously unknown SACK information).",
      "ja": "あるいは、選択的謝辞（SACKS）[RFC2018、RFC2883]を使用するTCPは、SACK情報を活用して、着信ACKが「複製」であるかを判断できます（ACKに以前は未知のサック情報が含まれている場合）。"
    },
    {
      "indent": 0,
      "text": "3. Congestion Control Algorithms",
      "section_title": true,
      "ja": "3. 混雑制御アルゴリズム"
    },
    {
      "indent": 3,
      "text": "This section defines the four congestion control algorithms: slow start, congestion avoidance, fast retransmit, and fast recovery, developed in [Jac88] and [Jac90]. In some situations, it may be beneficial for a TCP sender to be more conservative than the algorithms allow; however, a TCP MUST NOT be more aggressive than the following algorithms allow (that is, MUST NOT send data when the value of cwnd computed by the following algorithms would not allow the data to be sent).",
      "ja": "このセクションでは、[Jac88]および[JAC90]で開発された4つの輻輳制御アルゴリズム：スロースタート、輻輳回避、高速な再送信、および高速回復を定義します。状況によっては、TCP送信者がアルゴリズムが許可するよりも保守的であることが有益かもしれません。ただし、TCPは、次のアルゴリズムが許可するよりも積極的であってはなりません（つまり、次のアルゴリズムによって計算されたCWNDの値がデータの送信を許可しない場合はデータを送信してはなりません）。"
    },
    {
      "indent": 3,
      "text": "Also, note that the algorithms specified in this document work in terms of using loss as the signal of congestion. Explicit Congestion Notification (ECN) could also be used as specified in [RFC3168].",
      "ja": "また、このドキュメントで指定されたアルゴリズムは、輻輳の信号として損失を使用するという点で機能することに注意してください。明示的な混雑通知（ECN）は、[RFC3168]で指定されているように使用できます。"
    },
    {
      "indent": 0,
      "text": "3.1. Slow Start and Congestion Avoidance",
      "section_title": true,
      "ja": "3.1. スロースタートと混雑回避"
    },
    {
      "indent": 3,
      "text": "The slow start and congestion avoidance algorithms MUST be used by a TCP sender to control the amount of outstanding data being injected into the network. To implement these algorithms, two variables are added to the TCP per-connection state. The congestion window (cwnd) is a sender-side limit on the amount of data the sender can transmit into the network before receiving an acknowledgment (ACK), while the receiver's advertised window (rwnd) is a receiver-side limit on the amount of outstanding data. The minimum of cwnd and rwnd governs data transmission.",
      "ja": "スロースタートおよび輻輳回避アルゴリズムは、ネットワークに注入される未解決のデータの量を制御するために、TCP送信者によって使用する必要があります。これらのアルゴリズムを実装するには、2つの変数がTCP 1つの接続状態に追加されます。輻輳ウィンドウ（CWND）は、送信者が確認する前にネットワークに送信できるデータの量（ACK）の送信者側の制限であり、レシーバーの広告ウィンドウ（RWND）は、優れたデータ。CWNDおよびRWNDの最小はデータ送信を管理します。"
    },
    {
      "indent": 3,
      "text": "Another state variable, the slow start threshold (ssthresh), is used to determine whether the slow start or congestion avoidance algorithm is used to control data transmission, as discussed below.",
      "ja": "別の状態変数であるスロースタートしきい値（SSthresh）を使用して、以下で説明するように、データ送信を制御するためにスロースタートまたは輻輳回避アルゴリズムを使用するかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "Beginning transmission into a network with unknown conditions requires TCP to slowly probe the network to determine the available capacity, in order to avoid congesting the network with an inappropriately large burst of data. The slow start algorithm is used for this purpose at the beginning of a transfer, or after repairing loss detected by the retransmission timer. Slow start additionally serves to start the \"ACK clock\" used by the TCP sender to release data into the network in the slow start, congestion avoidance, and loss recovery algorithms.",
      "ja": "不明な条件を持つネットワークへの送信を開始するには、TCPがネットワークをゆっくりとプローブして利用可能な容量を決定する必要があります。スロースタートアルゴリズムは、転送の開始時、または再送信タイマーによって検出された損失を修復した後、この目的に使用されます。さらにスタートスタートは、TCP送信者が使用する「ACKクロック」を起動して、スロースタート、混雑回避、および損失回収アルゴリズムでネットワークにデータをリリースするようにします。"
    },
    {
      "indent": 3,
      "text": "IW, the initial value of cwnd, MUST be set using the following guidelines as an upper bound.",
      "ja": "CWNDの初期値であるIWは、以下のガイドラインを上限として使用して設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "If SMSS > 2190 bytes:\n    IW = 2 * SMSS bytes and MUST NOT be more than 2 segments\nIf (SMSS > 1095 bytes) and (SMSS <= 2190 bytes):\n    IW = 3 * SMSS bytes and MUST NOT be more than 3 segments\nif SMSS <= 1095 bytes:\n    IW = 4 * SMSS bytes and MUST NOT be more than 4 segments",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "As specified in [RFC3390], the SYN/ACK and the acknowledgment of the SYN/ACK MUST NOT increase the size of the congestion window. Further, if the SYN or SYN/ACK is lost, the initial window used by a sender after a correctly transmitted SYN MUST be one segment consisting of at most SMSS bytes.",
      "ja": "[rfc3390]で指定されているように、syn/ackとsyn/ackの承認は、うっ血ウィンドウのサイズを増やしてはなりません。さらに、synまたはsyn/ackが失われた場合、正しく送信されたsyn後に送信者が使用する最初のウィンドウは、ほとんどのSMSSバイトで構成される1つのセグメントでなければなりません。"
    },
    {
      "indent": 3,
      "text": "A detailed rationale and discussion of the IW setting is provided in [RFC3390].",
      "ja": "IW設定の詳細な根拠と議論は[RFC3390]に記載されています。"
    },
    {
      "indent": 3,
      "text": "When initial congestion windows of more than one segment are implemented along with Path MTU Discovery [RFC1191], and the MSS being used is found to be too large, the congestion window cwnd SHOULD be reduced to prevent large bursts of smaller segments. Specifically, cwnd SHOULD be reduced by the ratio of the old segment size to the new segment size.",
      "ja": "PATH MTU発見[RFC1191]とともに複数のセグメントの初期輻輳ウィンドウが実装され、使用されているMSSが大きすぎることがわかった場合、小さいセグメントの大きなバーストを防ぐために、CWNDを縮小する必要があります。具体的には、CWNDは、古いセグメントサイズの新しいセグメントサイズの比率によって減少する必要があります。"
    },
    {
      "indent": 3,
      "text": "The initial value of ssthresh SHOULD be set arbitrarily high (e.g., to the size of the largest possible advertised window), but ssthresh MUST be reduced in response to congestion. Setting ssthresh as high as possible allows the network conditions, rather than some arbitrary host limit, to dictate the sending rate. In cases where the end systems have a solid understanding of the network path, more carefully setting the initial ssthresh value may have merit (e.g., such that the end host does not create congestion along the path).",
      "ja": "SSthreshの初期値は、任意に高く設定する必要があります（たとえば、可能な限り最大の広告ウィンドウのサイズまで）が、SSThreshは混雑に応じて削減する必要があります。SSthreshをできるだけ高く設定することで、任意のホスト制限ではなく、ネットワーク条件を送信率を指示できます。最終システムがネットワークパスを確実に理解している場合、より慎重に最初のSSTHRESH値を設定することにメリットがある可能性があります（たとえば、エンドホストがパスに沿って混雑を作成しないように）。"
    },
    {
      "indent": 3,
      "text": "The slow start algorithm is used when cwnd < ssthresh, while the congestion avoidance algorithm is used when cwnd > ssthresh. When cwnd and ssthresh are equal, the sender may use either slow start or congestion avoidance.",
      "ja": "cwnd <ssthreshの場合はスロースタートアルゴリズムが使用されますが、cwnd> ssthreshの場合は輻輳回避アルゴリズムが使用されます。CWNDとSSTHRESHが等しい場合、送信者はスロースタートまたは混雑回避を使用する場合があります。"
    },
    {
      "indent": 3,
      "text": "During slow start, a TCP increments cwnd by at most SMSS bytes for each ACK received that cumulatively acknowledges new data. Slow start ends when cwnd exceeds ssthresh (or, optionally, when it reaches it, as noted above) or when congestion is observed. While traditionally TCP implementations have increased cwnd by precisely SMSS bytes upon receipt of an ACK covering new data, we RECOMMEND that TCP implementations increase cwnd, per:",
      "ja": "スロースタート中に、TCPが累積的に新しいデータを認めているACKごとにほとんどのSMSSバイトでCWNDを増加させます。CWNDがSSTHRESHを超えた場合（または、上記のように、それが到達したとき）、またはうっ血が観察されたときに、スロースタートが終了します。伝統的にTCP実装は、新しいデータをカバーするACKを受信すると正確にSMSSバイトによってCWNDを増加させてきましたが、TCP実装は次のことをCWND増加させることをお勧めします。"
    },
    {
      "indent": 6,
      "text": "cwnd += min (N, SMSS) (2)",
      "ja": "cwnd = min（n、smss）（2）"
    },
    {
      "indent": 3,
      "text": "where N is the number of previously unacknowledged bytes acknowledged in the incoming ACK. This adjustment is part of Appropriate Byte Counting [RFC3465] and provides robustness against misbehaving receivers that may attempt to induce a sender to artificially inflate cwnd using a mechanism known as \"ACK Division\" [SCWA99]. ACK Division consists of a receiver sending multiple ACKs for a single TCP data segment, each acknowledging only a portion of its data. A TCP that increments cwnd by SMSS for each such ACK will inappropriately inflate the amount of data injected into the network.",
      "ja": "ここで、nは、入ってくるACKで認められていた以前に未知のバイトの数です。この調整は、適切なバイトカウント[RFC3465]の一部であり、「ACK師団」[SCWA99]として知られるメカニズムを使用して、送信者に人工的にCWNDを膨張させるように送信者を誘導しようとする可能性のある不正な受信機に対して堅牢性を提供します。ACK部門は、単一のTCPデータセグメントに複数のACKを送信するレシーバーで構成されており、それぞれがデータの一部のみを認めています。このようなACKごとにSMSSによってCWNDを増加させるTCPは、ネットワークに注入されたデータの量を不適切に膨らませます。"
    },
    {
      "indent": 3,
      "text": "During congestion avoidance, cwnd is incremented by roughly 1 full-sized segment per round-trip time (RTT). Congestion avoidance continues until congestion is detected. The basic guidelines for incrementing cwnd during congestion avoidance are:",
      "ja": "混雑回避中、CWNDは、往復時間（RTT）ごとに約1つのフルサイズのセグメントによって増加します。混雑回避は、混雑が検出されるまで続きます。混雑回避中にCWNDを増やすための基本的なガイドラインは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "* MAY increment cwnd by SMSS bytes",
      "ja": "* SMSSバイトでCWNDを増加させることができます"
    },
    {
      "indent": 6,
      "text": "* SHOULD increment cwnd per equation (2) once per RTT",
      "ja": "* 方程式（2）ごとにcwndを1回RTTに1回増やす必要があります"
    },
    {
      "indent": 6,
      "text": "* MUST NOT increment cwnd by more than SMSS bytes",
      "ja": "* SMSSバイト以上のCWNDを増分してはなりません"
    },
    {
      "indent": 3,
      "text": "We note that [RFC3465] allows for cwnd increases of more than SMSS bytes for incoming acknowledgments during slow start on an experimental basis; however, such behavior is not allowed as part of the standard.",
      "ja": "[RFC3465]により、実験ベースでのスロースタート中に、着信の承認のためにSMSS以上のCWNDの増加が可能になることに注意してください。ただし、そのような動作は標準の一部として許可されていません。"
    },
    {
      "indent": 3,
      "text": "The RECOMMENDED way to increase cwnd during congestion avoidance is to count the number of bytes that have been acknowledged by ACKs for new data. (A drawback of this implementation is that it requires maintaining an additional state variable.) When the number of bytes acknowledged reaches cwnd, then cwnd can be incremented by up to SMSS bytes. Note that during congestion avoidance, cwnd MUST NOT be increased by more than SMSS bytes per RTT. This method both allows TCPs to increase cwnd by one segment per RTT in the face of delayed ACKs and provides robustness against ACK Division attacks.",
      "ja": "混雑回避中にCWNDを増やす推奨される方法は、新しいデータのACKによって認められたバイト数をカウントすることです。（この実装の欠点は、追加の状態変数を維持する必要があることです。）CWNDに到達するバイト数がCWNDに到達すると、CWNDはSMSSバイトまで増加できます。混雑回避中に、CWNDはRTTあたりSMSSバイト以上増加してはならないことに注意してください。この方法により、ACKの遅延に直面してTCPSがRTTごとに1つのセグメントによってCWNDを増加させ、ACK分割攻撃に対して堅牢性を提供することができます。"
    },
    {
      "indent": 3,
      "text": "Another common formula that a TCP MAY use to update cwnd during congestion avoidance is given in equation (3):",
      "ja": "TCPが混雑回避中にCWNDを更新するために使用する可能性のある別の一般的な式は、式（3）に示されています。"
    },
    {
      "indent": 6,
      "text": "cwnd += SMSS*SMSS/cwnd                     (3)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "This adjustment is executed on every incoming ACK that acknowledges new data. Equation (3) provides an acceptable approximation to the underlying principle of increasing cwnd by 1 full-sized segment per RTT. (Note that for a connection in which the receiver is acknowledging every-other packet, (3) is less aggressive than allowed -- roughly increasing cwnd every second RTT.)",
      "ja": "この調整は、新しいデータを認めるすべての着信ACKで実行されます。式（3）は、RTTごとに1つのフルサイズのセグメントを増加させるという根本原理の許容可能な近似を提供します。（レシーバーが他のすべてのパケットを認めている接続の場合、（3）許可されているよりも攻撃的ではありません。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Since integer arithmetic is usually used in TCP implementations, the formula given in equation (3) can fail to increase cwnd when the congestion window is larger than SMSS*SMSS. If the above formula yields 0, the result SHOULD be rounded up to 1 byte.",
      "ja": "実装注：整数算術は通常TCP実装で使用されるため、式（3）に示されている式は、輻輳ウィンドウがSMSS*SMSSよりも大きい場合、CWNDの増加に失敗する可能性があります。上記の式が0を生成する場合、結果は1バイトまで丸められる必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Older implementations have an additional additive constant on the right-hand side of equation (3). This is incorrect and can actually lead to diminished performance [RFC2525].",
      "ja": "実装注：古い実装には、式（3）の右側に追加の追加定数があります。これは正しくなく、実際にパフォーマンスの低下につながる可能性があります[RFC2525]。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: Some implementations maintain cwnd in units of bytes, while others in units of full-sized segments. The latter will find equation (3) difficult to use, and may prefer to use the counting approach discussed in the previous paragraph.",
      "ja": "実装注：いくつかの実装は、バイトの単位でCWNDを維持し、他の実装はフルサイズのセグメントの単位で維持しています。後者は、式（3）を使用するのが難しいことを発見し、前の段落で説明したカウントアプローチを使用することを好む場合があります。"
    },
    {
      "indent": 3,
      "text": "When a TCP sender detects segment loss using the retransmission timer and the given segment has not yet been resent by way of the retransmission timer, the value of ssthresh MUST be set to no more than the value given in equation (4):",
      "ja": "TCP送信者が再送信タイマーを使用してセグメントの損失を検出し、特定のセグメントが再送信タイマーによってまだresしていない場合、ssthreshの値は、式（4）に与えられた値にすぎないように設定する必要があります。"
    },
    {
      "indent": 6,
      "text": "ssthresh = max (FlightSize / 2, 2*SMSS)            (4)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where, as discussed above, FlightSize is the amount of outstanding data in the network.",
      "ja": "上記のように、フライトサイズはネットワーク内の未解決のデータの量です。"
    },
    {
      "indent": 3,
      "text": "On the other hand, when a TCP sender detects segment loss using the retransmission timer and the given segment has already been retransmitted by way of the retransmission timer at least once, the value of ssthresh is held constant.",
      "ja": "一方、TCP送信者が再送信タイマーを使用してセグメントの損失を検出し、特定のセグメントが少なくとも一度は再送信タイマーによってすでに再送信されている場合、SSthreshの値は一定に保たれます。"
    },
    {
      "indent": 3,
      "text": "Implementation Note: An easy mistake to make is to simply use cwnd, rather than FlightSize, which in some implementations may incidentally increase well beyond rwnd.",
      "ja": "実装注：簡単な間違いは、フライトサイズではなくCWNDを単純に使用することです。一部の実装では、偶然にもRWNDをはるかに超えて増加する可能性があります。"
    },
    {
      "indent": 3,
      "text": "Furthermore, upon a timeout (as specified in [RFC2988]) cwnd MUST be set to no more than the loss window, LW, which equals 1 full-sized segment (regardless of the value of IW). Therefore, after retransmitting the dropped segment the TCP sender uses the slow start algorithm to increase the window from 1 full-sized segment to the new value of ssthresh, at which point congestion avoidance again takes over.",
      "ja": "さらに、タイムアウト時に（[RFC2988]で指定されている）CWNDは、1つのフルサイズのセグメントに等しい（IWの値に関係なく）損失ウィンドウLWにすぎないように設定する必要があります。したがって、ドロップされたセグメントを再送信した後、TCP送信者はスロースタートアルゴリズムを使用して、1つのフルサイズのセグメントからSSThreshの新しい値にウィンドウを増加させ、その時点で混雑回避が再び引き継ぎます。"
    },
    {
      "indent": 3,
      "text": "As shown in [FF96] and [RFC3782], slow-start-based loss recovery after a timeout can cause spurious retransmissions that trigger duplicate acknowledgments. The reaction to the arrival of these duplicate ACKs in TCP implementations varies widely. This document does not specify how to treat such acknowledgments, but does note this as an area that may benefit from additional attention, experimentation and specification.",
      "ja": "[FF96]および[RFC3782]に示されているように、タイムアウト後のスロースタートベースの損失回復は、重複する謝辞を引き起こす偽の再送信を引き起こす可能性があります。TCP実装にこれらの複製Acksの到着に対する反応は、大きく異なります。このドキュメントでは、そのような謝辞の扱い方を指定するものではありませんが、これは、追加の注意、実験、仕様の恩恵を受ける可能性のある領域として注目しています。"
    },
    {
      "indent": 0,
      "text": "3.2. Fast Retransmit/Fast Recovery",
      "section_title": true,
      "ja": "3.2. 高速再送信/高速回復"
    },
    {
      "indent": 3,
      "text": "A TCP receiver SHOULD send an immediate duplicate ACK when an out-of-order segment arrives. The purpose of this ACK is to inform the sender that a segment was received out-of-order and which sequence number is expected. From the sender's perspective, duplicate ACKs can be caused by a number of network problems. First, they can be caused by dropped segments. In this case, all segments after the dropped segment will trigger duplicate ACKs until the loss is repaired. Second, duplicate ACKs can be caused by the re-ordering of data segments by the network (not a rare event along some network paths [Pax97]). Finally, duplicate ACKs can be caused by replication of ACK or data segments by the network. In addition, a TCP receiver SHOULD send an immediate ACK when the incoming segment fills in all or part of a gap in the sequence space. This will generate more timely information for a sender recovering from a loss through a retransmission timeout, a fast retransmit, or an advanced loss recovery algorithm, as outlined in section 4.3.",
      "ja": "TCPレシーバーは、オーダーアウトセグメントが到着したときに、すぐに重複するACKを送信する必要があります。このACKの目的は、セグメントが注文外で受信され、どのシーケンス番号が予想されるかを送信者に通知することです。送信者の観点からは、重複するAcksは、多くのネットワークの問題によって引き起こされる可能性があります。まず、それらはドロップされたセグメントによって引き起こされる可能性があります。この場合、ドロップされたセグメントの後のすべてのセグメントは、損失が修復されるまで重複したAcksをトリガーします。第二に、重複するACKは、ネットワークによるデータセグメントの再注文によって引き起こされる可能性があります（一部のネットワークパスに沿ったまれなイベントではありません[Pax97]）。最後に、重複するACKは、ネットワークによるACKまたはデータセグメントの複製によって引き起こされる可能性があります。さらに、TCPレシーバーは、着信セグメントがシーケンススペースのギャップのすべてまたは一部を埋めるときに即時ACKを送信する必要があります。これにより、セクション4.3で概説されているように、再送信タイムアウト、高速な再送信、または高度な損失回復アルゴリズムを介して損失から回復する送信者に対してよりタイムリーな情報が生成されます。"
    },
    {
      "indent": 3,
      "text": "The TCP sender SHOULD use the \"fast retransmit\" algorithm to detect and repair loss, based on incoming duplicate ACKs. The fast retransmit algorithm uses the arrival of 3 duplicate ACKs (as defined in section 2, without any intervening ACKs which move SND.UNA) as an indication that a segment has been lost. After receiving 3 duplicate ACKs, TCP performs a retransmission of what appears to be the missing segment, without waiting for the retransmission timer to expire.",
      "ja": "TCP送信者は、「高速再送信」アルゴリズムを使用して、着信の重複ACKに基づいて損失を検出および修復する必要があります。高速再送信アルゴリズムでは、セグメントが失われたことを示す兆候として、3つの重複アック（セクション2で定義されているように、セクション2で定義されています）を使用します。3つの重複したACKを受け取った後、TCPは、再送信タイマーが期限切れになるのを待つことなく、欠落しているセグメントのように見えるものの再送信を実行します。"
    },
    {
      "indent": 3,
      "text": "After the fast retransmit algorithm sends what appears to be the missing segment, the \"fast recovery\" algorithm governs the transmission of new data until a non-duplicate ACK arrives. The reason for not performing slow start is that the receipt of the duplicate ACKs not only indicates that a segment has been lost, but also that segments are most likely leaving the network (although a massive segment duplication by the network can invalidate this conclusion). In other words, since the receiver can only generate a duplicate ACK when a segment has arrived, that segment has left the network and is in the receiver's buffer, so we know it is no longer consuming network resources. Furthermore, since the ACK \"clock\" [Jac88] is preserved, the TCP sender can continue to transmit new segments (although transmission must continue using a reduced cwnd, since loss is an indication of congestion).",
      "ja": "高速再送信アルゴリズムが欠落しているセグメントのように見えるものを送信した後、「高速回復」アルゴリズムは、非複雑なACKが到着するまで新しいデータの送信を管理します。スロースタートを実行しない理由は、重複したACKの受領がセグメントが失われたことを示すだけでなく、セグメントがネットワークを離れる可能性が最も高いことです（ネットワークによる大規模なセグメントの複製はこの結論を無効にする可能性があります）。言い換えれば、セグメントが到着したときにレシーバーは重複したACKを生成できるため、そのセグメントはネットワークを離れ、レシーバーのバッファーに入っているため、ネットワークリソースを消費していないことがわかります。さらに、ACK「クロック」[JAC88]が保存されているため、TCP送信者は新しいセグメントを送信し続けることができます（ただし、損失はうっ血の兆候であるため、伝送は削減されたCWNDを使用し続ける必要があります）。"
    },
    {
      "indent": 3,
      "text": "The fast retransmit and fast recovery algorithms are implemented together as follows.",
      "ja": "高速再送信および高速回復アルゴリズムは、次のように一緒に実装されます。"
    },
    {
      "indent": 3,
      "text": "1. On the first and second duplicate ACKs received at a sender, a TCP SHOULD send a segment of previously unsent data per [RFC3042] provided that the receiver's advertised window allows, the total FlightSize would remain less than or equal to cwnd plus 2*SMSS, and that new data is available for transmission. Further, the TCP sender MUST NOT change cwnd to reflect these two segments [RFC3042]. Note that a sender using SACK [RFC2018] MUST NOT send new data unless the incoming duplicate acknowledgment contains new SACK information.",
      "ja": "1. 送信者で受信した1番目と2番目の複製ACKでは、TCPは、受信者の広告ウィンドウが許可されている場合、TCPが以前に安全でないデータのセグメントを送信する必要があります。そして、その新しいデータは送信に利用可能です。さらに、TCP送信者は、これら2つのセグメントを反映するためにCWNDを変更してはなりません[RFC3042]。SACK [RFC2018]を使用する送信者は、着信の重複確認に新しいサック情報が含まれていない限り、新しいデータを送信してはならないことに注意してください。"
    },
    {
      "indent": 3,
      "text": "2. When the third duplicate ACK is received, a TCP MUST set ssthresh to no more than the value given in equation (4). When [RFC3042] is in use, additional data sent in limited transmit MUST NOT be included in this calculation.",
      "ja": "2. 3番目の複製ACKを受信すると、TCPは式（4）で与えられた値にすぎないようにSSTHRESHを設定する必要があります。[RFC3042]が使用されている場合、限られた送信で送信された追加データをこの計算に含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "3. The lost segment starting at SND.UNA MUST be retransmitted and cwnd set to ssthresh plus 3*SMSS. This artificially \"inflates\" the congestion window by the number of segments (three) that have left the network and which the receiver has buffered.",
      "ja": "3. snd.unaで始まるロストセグメントは再送信し、cwndがssthreshプラス3*smssに設定する必要があります。これは、ネットワークを離れ、受信機がバッファリングしたセグメントの数（3）だけで、混雑ウィンドウを人為的に「膨らませる」。"
    },
    {
      "indent": 3,
      "text": "4. For each additional duplicate ACK received (after the third), cwnd MUST be incremented by SMSS. This artificially inflates the congestion window in order to reflect the additional segment that has left the network.",
      "ja": "4. 受信した追加の複製ACK（3回目以降）について、CWNDはSMSSによって増加する必要があります。これにより、ネットワークを去った追加セグメントを反映するために、混雑ウィンドウを人為的に膨らませます。"
    },
    {
      "indent": 7,
      "text": "Note: [SCWA99] discusses a receiver-based attack whereby many bogus duplicate ACKs are sent to the data sender in order to artificially inflate cwnd and cause a higher than appropriate sending rate to be used. A TCP MAY therefore limit the number of times cwnd is artificially inflated during loss recovery to the number of outstanding segments (or, an approximation thereof).",
      "ja": "注：[SCWA99]は、CWNDを人為的に膨らませ、使用される適切な送信率よりも高いものを引き起こすために、多くの偽の重複ACKがデータ送信者に送信されるレシーバーベースの攻撃について説明します。したがって、TCPは、損失回収中にCWNDが未発生セグメントの数（またはその近似）に人為的に膨らむ回数を制限する場合があります。"
    },
    {
      "indent": 7,
      "text": "Note: When an advanced loss recovery mechanism (such as outlined in section 4.3) is not in use, this increase in FlightSize can cause equation (4) to slightly inflate cwnd and ssthresh, as some of the segments between SND.UNA and SND.NXT are assumed to have left the network but are still reflected in FlightSize.",
      "ja": "注：高度な損失回復メカニズム（セクション4.3で概説されているなど）が使用されていない場合、このフライトサイズの増加により、式（4）がSND.UNAとSNDの間のセグメントの一部として、式（4）がCWNDとSSTHRESHをわずかに膨らませる可能性があります。NXTはネットワークを離れたと想定されていますが、まだフライトサイズに反映されています。"
    },
    {
      "indent": 3,
      "text": "5. When previously unsent data is available and the new value of cwnd and the receiver's advertised window allow, a TCP SHOULD send 1*SMSS bytes of previously unsent data.",
      "ja": "5. 以前に安全でないデータが利用可能で、CWNDの新しい値とレシーバーの広告ウィンドウが許可されている場合、TCPは以前に安全でないデータの1*SMSSバイトを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "6. When the next ACK arrives that acknowledges previously unacknowledged data, a TCP MUST set cwnd to ssthresh (the value set in step 2). This is termed \"deflating\" the window.",
      "ja": "6. 以前に承認されていないデータを認める次のACKが到着すると、TCPはcwndをSSthreshに設定する必要があります（ステップ2で設定された値）。これは、ウィンドウを「デフレ」と呼びます。"
    },
    {
      "indent": 7,
      "text": "This ACK should be the acknowledgment elicited by the retransmission from step 3, one RTT after the retransmission (though it may arrive sooner in the presence of significant out-of-order delivery of data segments at the receiver). Additionally, this ACK should acknowledge all the intermediate segments sent between the lost segment and the receipt of the third duplicate ACK, if none of these were lost.",
      "ja": "このACKは、再送信後のRTT 1つのRTTからの再送信によって引き出される承認である必要があります（ただし、受信者でのデータセグメントの大幅なオーダーアウト外配信の存在下で早く到着する可能性があります）。さらに、このACKは、失われたセグメントと3番目の重複ACKの受領との間に送信されるすべての中間セグメントを認める必要があります。"
    },
    {
      "indent": 3,
      "text": "Note: This algorithm is known to generally not recover efficiently from multiple losses in a single flight of packets [FF96]. Section 4.3 below addresses such cases.",
      "ja": "注：このアルゴリズムは、一般に、パケットの1回の飛行で複数の損失から効率的に回復しないことが知られています[FF96]。以下のセクション4.3では、そのようなケースについて説明します。"
    },
    {
      "indent": 0,
      "text": "4. Additional Considerations",
      "section_title": true,
      "ja": "4. 追加の考慮事項"
    },
    {
      "indent": 0,
      "text": "4.1. Restarting Idle Connections",
      "section_title": true,
      "ja": "4.1. アイドル接続の再起動"
    },
    {
      "indent": 3,
      "text": "A known problem with the TCP congestion control algorithms described above is that they allow a potentially inappropriate burst of traffic to be transmitted after TCP has been idle for a relatively long period of time. After an idle period, TCP cannot use the ACK clock to strobe new segments into the network, as all the ACKs have drained from the network. Therefore, as specified above, TCP can potentially send a cwnd-size line-rate burst into the network after an idle period. In addition, changing network conditions may have rendered TCP's notion of the available end-to-end network capacity between two endpoints, as estimated by cwnd, inaccurate during the course of a long idle period.",
      "ja": "上記のTCP混雑制御アルゴリズムの既知の問題は、TCPが比較的長い間アイドル状態になった後にトラフィックの不適切な潜在的なバーストを送信できることです。アイドル期間の後、TCPはACKクロックを使用して、すべてのACKがネットワークから排出されたため、新しいセグメントをネットワークにストロボで使用できません。したがって、上記で指定したように、TCPは、アイドル期間の後にCWNDサイズのラインレートバーがネットワークにバーストされる可能性があります。さらに、ネットワーク条件の変更により、CWNDによって推定されるように、長いアイドル期間中に不正確な2つのエンドポイント間で利用可能なエンドツーエンドネットワーク容量のTCPの概念が表示される可能性があります。"
    },
    {
      "indent": 3,
      "text": "[Jac88] recommends that a TCP use slow start to restart transmission after a relatively long idle period. Slow start serves to restart the ACK clock, just as it does at the beginning of a transfer. This mechanism has been widely deployed in the following manner. When TCP has not received a segment for more than one retransmission timeout, cwnd is reduced to the value of the restart window (RW) before transmission begins.",
      "ja": "[JAC88]は、TCPが比較的長いアイドル期間の後にゆっくりとスタートして送信を再起動することを推奨しています。スロースタートは、転送の先頭と同様に、ACKクロックを再起動するのに役立ちます。このメカニズムは、次の方法で広く展開されています。TCPが複数の再送信タイムアウトのセグメントを受信していない場合、CWNDは送信が開始される前に再起動ウィンドウ（RW）の値に縮小されます。"
    },
    {
      "indent": 3,
      "text": "For the purposes of this standard, we define RW = min(IW,cwnd).",
      "ja": "この標準の目的のために、RW = MIN（IW、CWND）を定義します。"
    },
    {
      "indent": 3,
      "text": "Using the last time a segment was received to determine whether or not to decrease cwnd can fail to deflate cwnd in the common case of persistent HTTP connections [HTH98]. In this case, a Web server receives a request before transmitting data to the Web client. The reception of the request makes the test for an idle connection fail, and allows the TCP to begin transmission with a possibly inappropriately large cwnd.",
      "ja": "最後にセグメントを使用して、CWNDを減少させるかどうかを判断して、永続的なHTTP接続の一般的なケースでCWNDを落とすことができないかどうかを判断しました[HTH98]。この場合、Webサーバーは、データをWebクライアントに送信する前にリクエストを受信します。リクエストの受信により、アイドル接続のテストが失敗し、TCPが不適切に大きなCWNDで送信を開始できます。"
    },
    {
      "indent": 3,
      "text": "Therefore, a TCP SHOULD set cwnd to no more than RW before beginning transmission if the TCP has not sent data in an interval exceeding the retransmission timeout.",
      "ja": "したがって、TCPが再送信タイムアウトを超える間隔でデータを送信していない場合、TCPは伝送を開始する前にCWNDをRW以前に設定する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2. Generating Acknowledgments",
      "section_title": true,
      "ja": "4.2. 謝辞を生成します"
    },
    {
      "indent": 3,
      "text": "The delayed ACK algorithm specified in [RFC1122] SHOULD be used by a TCP receiver. When using delayed ACKs, a TCP receiver MUST NOT excessively delay acknowledgments. Specifically, an ACK SHOULD be generated for at least every second full-sized segment, and MUST be generated within 500 ms of the arrival of the first unacknowledged packet.",
      "ja": "[RFC1122]で指定された遅延ACKアルゴリズムは、TCPレシーバーが使用する必要があります。遅延ACKを使用する場合、TCPレシーバーは承認を過度に遅らせることはできません。具体的には、少なくとも2秒ごとのフルサイズのセグメントごとにACKを生成し、最初の未溶接パケットの到着から500ミリ秒以内に生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "The requirement that an ACK \"SHOULD\" be generated for at least every second full-sized segment is listed in [RFC1122] in one place as a SHOULD and another as a MUST. Here we unambiguously state it is a SHOULD. We also emphasize that this is a SHOULD, meaning that an implementor should indeed only deviate from this requirement after careful consideration of the implications. See the discussion of \"Stretch ACK violation\" in [RFC2525] and the references therein for a discussion of the possible performance problems with generating ACKs less frequently than every second full-sized segment.",
      "ja": "ACKが少なくとも2秒ごとのフルサイズのセグメントについて「 \"が生成されるべき」という要件は、[RFC1122]に1つの場所にリストされ、別の場所で必須としてリストされています。ここで、私たちはそれがすべきであると明確に述べています。また、これは必要であることを強調します。つまり、実装者は、その意味を慎重に検討した後、実際にこの要件からのみ逸脱する必要があることを意味します。[RFC2525]の「Stretch ACK違反」の議論と、各2秒のフルサイズのセグメントよりも頻繁にACKを生成する可能性のあるパフォーマンスの問題の議論については、その参照を参照してください。"
    },
    {
      "indent": 3,
      "text": "In some cases, the sender and receiver may not agree on what constitutes a full-sized segment. An implementation is deemed to comply with this requirement if it sends at least one acknowledgment every time it receives 2*RMSS bytes of new data from the sender, where RMSS is the Maximum Segment Size specified by the receiver to the sender (or the default value of 536 bytes, per [RFC1122], if the receiver does not specify an MSS option during connection establishment). The sender may be forced to use a segment size less than RMSS due to the maximum transmission unit (MTU), the path MTU discovery algorithm or other factors. For instance, consider the case when the receiver announces an RMSS of X bytes but the sender ends up using a segment size of Y bytes (Y < X) due to path MTU discovery (or the sender's MTU size). The receiver will generate stretch ACKs if it waits for 2*X bytes to arrive before an ACK is sent. Clearly this will take more than 2 segments of size Y bytes. Therefore, while a specific algorithm is not defined, it is desirable for receivers to attempt to prevent this situation, for example, by acknowledging at least every second segment, regardless of size. Finally, we repeat that an ACK MUST NOT be delayed for more than 500 ms waiting on a second full-sized segment to arrive.",
      "ja": "場合によっては、送信者と受信者は、フルサイズのセグメントを構成するものに同意しない場合があります。実装は、送信者から2*RMSSバイトの新しいデータを受信するたびに少なくとも1つの確認を送信する場合、この要件に準拠するとみなされます。[RFC1122]ごとに、536バイト、受信機が接続確立中にMSSオプションを指定しない場合）。送信者は、最大透過ユニット（MTU）、PATH MTUディスカバリーアルゴリズム、またはその他の要因により、RMSより少ないセグメントサイズを使用することを余儀なくされる場合があります。たとえば、受信者がXバイトのRMSを発表したが、送信者は、PATH MTUディスカバリー（または送信者のMTUサイズ）のためにYバイト（Y <X）のセグメントサイズ（Y <X）を使用する場合を考慮してください。受信機は、ACKが送信される前に2*xバイトが到着するのを待つ場合、ストレッチACKを生成します。明らかに、これにはサイズYバイトの2つ以上のセグメントが必要です。したがって、特定のアルゴリズムは定義されていませんが、サイズに関係なく、少なくとも2秒のセグメントを認めることにより、受信機がこの状況を防止しようとすることが望ましいです。最後に、2番目のフルサイズのセグメントが到着するのを待って500ミリ秒以上遅延してはならないことを繰り返します。"
    },
    {
      "indent": 3,
      "text": "Out-of-order data segments SHOULD be acknowledged immediately, in order to accelerate loss recovery. To trigger the fast retransmit algorithm, the receiver SHOULD send an immediate duplicate ACK when it receives a data segment above a gap in the sequence space. To provide feedback to senders recovering from losses, the receiver SHOULD send an immediate ACK when it receives a data segment that fills in all or part of a gap in the sequence space.",
      "ja": "損失の回復を加速するために、秩序外のデータセグメントはすぐに確認する必要があります。高速再送信アルゴリズムをトリガーするには、受信者は、シーケンス空間のギャップの上にデータセグメントを受信したときに即時の複製ACKを送信する必要があります。損失から回復する送信者にフィードバックを提供するために、受信者は、シーケンススペースのギャップのすべてまたは一部を埋めるデータセグメントを受信したときに即時ACKを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "A TCP receiver MUST NOT generate more than one ACK for every incoming segment, other than to update the offered window as the receiving application consumes new data (see [RFC813] and page 42 of [RFC793]).",
      "ja": "TCPレシーバーは、受信アプリケーションが新しいデータを消費するため、提供されたウィンドウを更新する以外に、着信セグメントごとに複数のACKを生成してはなりません（[RFC813]および[RFC793]の42ページを参照）。"
    },
    {
      "indent": 0,
      "text": "4.3. Loss Recovery Mechanisms",
      "section_title": true,
      "ja": "4.3. 損失回復メカニズム"
    },
    {
      "indent": 3,
      "text": "A number of loss recovery algorithms that augment fast retransmit and fast recovery have been suggested by TCP researchers and specified in the RFC series. While some of these algorithms are based on the TCP selective acknowledgment (SACK) option [RFC2018], such as [FF96], [MM96a], [MM96b], and [RFC3517], others do not require SACKs, such as [Hoe96], [FF96], and [RFC3782]. The non-SACK algorithms use \"partial acknowledgments\" (ACKs that cover previously unacknowledged data, but not all the data outstanding when loss was detected) to trigger retransmissions. While this document does not standardize any of the specific algorithms that may improve fast retransmit/fast recovery, these enhanced algorithms are implicitly allowed, as long as they follow the general principles of the basic four algorithms outlined above.",
      "ja": "TCP研究者は、急速な再送信と迅速な回復を強化する多くの損失回復アルゴリズムが提案されており、RFCシリーズで指定されています。これらのアルゴリズムの一部は、[FF96]、[MM96A]、[MM96B]、[RFC3517]などのTCP選択的承認（SACK）オプション[RFC2018]に基づいていますが、[hoe96]などのサックは必要ありません。、[FF96]、および[RFC3782]。非サックアルゴリズムは、「部分的な承認」（以前は未把握されていないデータをカバーするACKを使用しますが、損失が検出されたときにすべてのデータを発行するわけではありません）を使用して、再送信をトリガーします。このドキュメントは、高速な再送信/高速回復を改善する可能性のある特定のアルゴリズムのいずれも標準化されていませんが、上記の基本的な4つのアルゴリズムの一般原則に従う限り、これらの強化されたアルゴリズムは暗黙的に許可されます。"
    },
    {
      "indent": 3,
      "text": "That is, when the first loss in a window of data is detected, ssthresh MUST be set to no more than the value given by equation (4). Second, until all lost segments in the window of data in question are repaired, the number of segments transmitted in each RTT MUST be no more than half the number of outstanding segments when the loss was detected. Finally, after all loss in the given window of segments has been successfully retransmitted, cwnd MUST be set to no more than ssthresh and congestion avoidance MUST be used to further increase cwnd. Loss in two successive windows of data, or the loss of a retransmission, should be taken as two indications of congestion and, therefore, cwnd (and ssthresh) MUST be lowered twice in this case.",
      "ja": "つまり、データのウィンドウで最初の損失が検出された場合、SSthreshは式（4）で与えられる値にすぎないように設定する必要があります。第二に、問題のデータのウィンドウ内のすべての失われたセグメントが修復されるまで、各RTTに送信されるセグメントの数は、損失が検出されたときに発行済みセグメントの半分以下でなければなりません。最後に、特定のセグメントのウィンドウでのすべての損失が正常に再送信された後、CWNDはCWNDをさらに増やすためにSSTHRESHを使用して使用する必要があります。2つの連続したデータの窓の損失、または再送信の損失は、この場合、CWND（およびSSthresh）を2回下げる必要があります。"
    },
    {
      "indent": 3,
      "text": "We RECOMMEND that TCP implementors employ some form of advanced loss recovery that can cope with multiple losses in a window of data. The algorithms detailed in [RFC3782] and [RFC3517] conform to the general principles outlined above. We note that while these are not the only two algorithms that conform to the above general principles these two algorithms have been vetted by the community and are currently on the Standards Track.",
      "ja": "TCP実装者は、データのウィンドウで複数の損失に対処できる何らかの形の高度な損失回復を採用することをお勧めします。[RFC3782]および[RFC3517]で詳述されているアルゴリズムは、上記の一般原則に準拠しています。上記の一般原則に準拠する2つのアルゴリズムはこれらの唯一のアルゴリズムではありませんが、これらの2つのアルゴリズムはコミュニティによって審査され、現在標準の軌跡に載っています。"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This document requires a TCP to diminish its sending rate in the presence of retransmission timeouts and the arrival of duplicate acknowledgments. An attacker can therefore impair the performance of a TCP connection by either causing data packets or their acknowledgments to be lost, or by forging excessive duplicate acknowledgments.",
      "ja": "このドキュメントでは、TCPが再送信のタイムアウトの存在下でその送信率を低下させ、重複謝辞の到着を必要とします。したがって、攻撃者は、データパケットまたはその謝辞を失うか、過度の重複謝辞を偽造することにより、TCP接続のパフォーマンスを損なう可能性があります。"
    },
    {
      "indent": 3,
      "text": "In response to the ACK division attack outlined in [SCWA99], this document RECOMMENDS increasing the congestion window based on the number of bytes newly acknowledged in each arriving ACK rather than by a particular constant on each arriving ACK (as outlined in section 3.1).",
      "ja": "[SCWA99]で概説されているACK分割攻撃に応じて、このドキュメントは、到着する各ACKの特定の定数ではなく、到着する各ACKで新たに認められているバイト数に基づいて混雑ウィンドウを増やすことを推奨しています（セクション3.1で概説されています）。"
    },
    {
      "indent": 3,
      "text": "The Internet, to a considerable degree, relies on the correct implementation of these algorithms in order to preserve network stability and avoid congestion collapse. An attacker could cause TCP endpoints to respond more aggressively in the face of congestion by forging excessive duplicate acknowledgments or excessive acknowledgments for new data. Conceivably, such an attack could drive a portion of the network into congestion collapse.",
      "ja": "インターネットは、かなりの程度に、ネットワークの安定性を維持し、うっ血の崩壊を避けるために、これらのアルゴリズムの正しい実装に依存しています。攻撃者は、TCPエンドポイントが、過度の重複謝辞または新しいデータの過度の謝辞を偽造することにより、混雑に直面してより積極的に応答する可能性があります。おそらく、そのような攻撃はネットワークの一部を渋滞の崩壊に駆り立てる可能性があります。"
    },
    {
      "indent": 0,
      "text": "6. Changes between RFC 2001 and RFC 2581",
      "section_title": true,
      "ja": "6. RFC 2001とRFC 2581の間の変化"
    },
    {
      "indent": 3,
      "text": "[RFC2001] was extensively rewritten editorially and it is not feasible to itemize the list of changes between [RFC2001] and [RFC2581]. The intention of [RFC2581] was to not change any of the recommendations given in [RFC2001], but to further clarify cases that were not discussed in detail in [RFC2001]. Specifically, [RFC2581] suggested what TCP connections should do after a relatively long idle period, as well as specified and clarified some of the issues pertaining to TCP ACK generation. Finally, the allowable upper bound for the initial congestion window was raised from one to two segments.",
      "ja": "[RFC2001]は編集上広範囲に書き直され、[RFC2001]と[RFC2581]の間の変更のリストを項目化することは不可能です。[RFC2581]の意図は、[RFC2001]で与えられた推奨事項のいずれも変更せず、[RFC2001]で詳細に説明されていないケースをさらに明確にすることでした。具体的には、[RFC2581]は、比較的長いアイドル期間の後にTCP接続が何をすべきかを提案し、TCP ACK生成に関する問題の一部を指定および明確にしました。最後に、初期輻輳ウィンドウの許容上限が1つから2つのセグメントから上昇しました。"
    },
    {
      "indent": 0,
      "text": "7. Changes Relative to RFC 2581",
      "section_title": true,
      "ja": "7. RFC 2581に関連する変更"
    },
    {
      "indent": 3,
      "text": "A specific definition for \"duplicate acknowledgment\" has been added, based on the definition used by BSD TCP.",
      "ja": "BSD TCPで使用される定義に基づいて、「重複確認」の特定の定義が追加されました。"
    },
    {
      "indent": 3,
      "text": "The document now notes that what to do with duplicate ACKs after the retransmission timer has fired is future work and explicitly unspecified in this document.",
      "ja": "ドキュメントは、再送信タイマーが起動した後に重複したAcksをどうするかを将来の作業であり、このドキュメントで明示的に特定されていないことを示しています。"
    },
    {
      "indent": 3,
      "text": "The initial window requirements were changed to allow Larger Initial Windows as standardized in [RFC3390]. Additionally, the steps to take when an initial window is discovered to be too large due to Path MTU Discovery [RFC1191] are detailed.",
      "ja": "[RFC3390]に標準化されたより大きな初期ウィンドウを許可するために、初期ウィンドウ要件が変更されました。さらに、パスMTU発見[RFC1191]により、初期ウィンドウが大きすぎることが発見されたときに取るべき手順が詳細になります。"
    },
    {
      "indent": 3,
      "text": "The recommended initial value for ssthresh has been changed to say that it SHOULD be arbitrarily high, where it was previously MAY. This is to provide additional guidance to implementors on the matter.",
      "ja": "SSthreshの推奨される初期値は、以前は5月であった場所で任意に高くすべきであると言うように変更されました。これは、問題に関する実装者に追加のガイダンスを提供することです。"
    },
    {
      "indent": 3,
      "text": "During slow start, the usage of Appropriate Byte Counting [RFC3465] with L=1*SMSS is explicitly recommended. The method of increasing cwnd given in [RFC2581] is still explicitly allowed. Byte counting during congestion avoidance is also recommended, while the method from [RFC2581] and other safe methods are still allowed.",
      "ja": "スロースタート中に、L = 1*SMSSを使用した適切なバイトカウント[RFC3465]の使用が明示的に推奨されます。[RFC2581]で与えられたCWNDを増加させる方法は、まだ明示的に許可されています。輻輳回避中にバイトカウントをカウントすることもお勧めしますが、[RFC2581]およびその他の安全な方法の方法はまだ許可されています。"
    },
    {
      "indent": 3,
      "text": "The treatment of ssthresh on retransmission timeout was clarified. In particular, ssthresh must be set to half the FlightSize on the first retransmission of a given segment and then is held constant on subsequent retransmissions of the same segment.",
      "ja": "再送信タイムアウトでのSSTHRESHの扱いは明らかにされました。特に、SSthreshは、特定のセグメントの最初の再送信時にフライトサイズの半分に設定する必要があり、その後の同じセグメントのその後の再送信で一定に保持されます。"
    },
    {
      "indent": 3,
      "text": "The description of fast retransmit and fast recovery has been clarified, and the use of Limited Transmit [RFC3042] is now recommended.",
      "ja": "高速な再送信と高速回復の説明が明確にされており、限られた送信[RFC3042]の使用が推奨されています。"
    },
    {
      "indent": 3,
      "text": "TCPs now MAY limit the number of duplicate ACKs that artificially inflate cwnd during loss recovery to the number of segments outstanding to avoid the duplicate ACK spoofing attack described in [SCWA99].",
      "ja": "TCPSは、[SCWA99]に記載されている重複ACKスプーフィング攻撃を避けるために、損失回復中にCWNDを人為的に膨張させる重複ACKの数を制限する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The restart window has been changed to min(IW,cwnd) from IW. This behavior was described as \"experimental\" in [RFC2581].",
      "ja": "再起動ウィンドウは、IWからMin（IW、CWND）に変更されました。この動作は、[RFC2581]で「実験的」と呼ばれていました。"
    },
    {
      "indent": 3,
      "text": "It is now recommended that TCP implementors implement an advanced loss recovery algorithm conforming to the principles outlined in this document.",
      "ja": "現在、TCP実装者は、このドキュメントに概説されている原則に準拠した高度な損失回復アルゴリズムを実装することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "The security considerations have been updated to discuss ACK division and recommend byte counting as a counter to this attack.",
      "ja": "セキュリティ上の考慮事項は、ACK部門について議論し、この攻撃のカウンターとしてBITTEカウントを推奨することを推奨するために更新されています。"
    },
    {
      "indent": 0,
      "text": "8. Acknowledgments",
      "section_title": true,
      "ja": "8. 謝辞"
    },
    {
      "indent": 3,
      "text": "The core algorithms we describe were developed by Van Jacobson [Jac88, Jac90]. In addition, Limited Transmit [RFC3042] was developed in conjunction with Hari Balakrishnan and Sally Floyd. The initial congestion window size specified in this document is a result of work with Sally Floyd and Craig Partridge [RFC2414, RFC3390].",
      "ja": "私たちが説明するコアアルゴリズムは、Van Jacobson [Jac88、Jac90]によって開発されました。さらに、限られた送信[RFC3042]は、Hari BalakrishnanおよびSally Floydと併せて開発されました。このドキュメントで指定された最初の混雑ウィンドウサイズは、Sally FloydおよびCraig Partridge [RFC2414、RFC3390]との作業の結果です。"
    },
    {
      "indent": 3,
      "text": "W. Richard (\"Rich\") Stevens wrote the first version of this document [RFC2001] and co-authored the second version [RFC2581]. This present version much benefits from his clarity and thoughtfulness of description, and we are grateful for Rich's contributions in elucidating TCP congestion control, as well as in more broadly helping us understand numerous issues relating to networking.",
      "ja": "W. Richard（ \"Rich\"）Stevensは、このドキュメント[RFC2001]の最初のバージョンを書き、2番目のバージョン[RFC2581]を共著しました。この現在のバージョンは、彼の説明の明快さと思慮深さから大きな恩恵を受けており、TCPの混雑制御の解明におけるリッチの貢献と、ネットワーキングに関する多くの問題をより広く理解するのに役立つことに感謝しています。"
    },
    {
      "indent": 3,
      "text": "We wish to emphasize that the shortcomings and mistakes of this document are solely the responsibility of the current authors.",
      "ja": "この文書の欠点と間違いは、現在の著者の責任のみであることを強調したいと思います。"
    },
    {
      "indent": 3,
      "text": "Some of the text from this document is taken from \"TCP/IP Illustrated, Volume 1: The Protocols\" by W. Richard Stevens (Addison-Wesley, 1994) and \"TCP/IP Illustrated, Volume 2: The Implementation\" by Gary R. Wright and W. Richard Stevens (Addison-Wesley, 1995). This material is used with the permission of Addison-Wesley.",
      "ja": "このドキュメントのテキストの一部は、W。RichardStevens（Addison-Wesley、1994）および「TCP/IP Illustrated、Volume 2：The Exprimentation」による「TCP/IP Illustrated、Volume 1：The Protocols」からGary Rによるものです。。ライトとW.リチャードスティーブンス（アディソンウェスリー、1995）。この資料は、Addison-Wesleyの許可を得て使用されます。"
    },
    {
      "indent": 3,
      "text": "Anil Agarwal, Steve Arden, Neal Cardwell, Noritoshi Demizu, Gorry Fairhurst, Kevin Fall, John Heffner, Alfred Hoenes, Sally Floyd, Reiner Ludwig, Matt Mathis, Craig Partridge, and Joe Touch contributed a number of helpful suggestions.",
      "ja": "Anil Agarwal、Steve Arden、Neal Cardwell、Noritoshi Demizu、Gorry Fairhurst、Kevin Fall、John Heffner、Alfred Hoenes、Sally Floyd、Reiner Ludwig、Matt Mathis、Craig Partridge、およびJoe Touchは、多くの有益な提案に貢献しました。"
    },
    {
      "indent": 0,
      "text": "9. References",
      "section_title": true,
      "ja": "9. 参考文献"
    },
    {
      "indent": 0,
      "text": "9.1. Normative References",
      "section_title": true,
      "ja": "9.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC793] Postel, J., \"Transmission Control Protocol\", STD 7, RFC 793, September 1981.",
      "ja": "[RFC793] Postel、J。、「トランスミッションコントロールプロトコル」、STD 7、RFC 793、1981年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC1122] Braden, R., Ed., \"Requirements for Internet Hosts - Communication Layers\", STD 3, RFC 1122, October 1989.",
      "ja": "[RFC1122] Braden、R.、ed。、「インターネットホストの要件 - 通信レイヤー」、STD 3、RFC 1122、1989年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC1191] Mogul, J. and S. Deering, \"Path MTU discovery\", RFC 1191, November 1990.",
      "ja": "[RFC1191] Mogul、J。およびS. Deering、「Path MTU Discovery」、RFC 1191、1990年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 0,
      "text": "9.2. Informative References",
      "section_title": true,
      "ja": "9.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CJ89] Chiu, D. and R. Jain, \"Analysis of the Increase/Decrease Algorithms for Congestion Avoidance in Computer Networks\", Journal of Computer Networks and ISDN Systems, vol. 17, no. 1, pp. 1-14, June 1989.",
      "ja": "[CJ89] Chiu、D。およびR. Jain、「コンピューターネットワークにおける混雑回避のための増加/減少アルゴリズムの分析」、Journal of Computer Networks and Isdn Systems、Vol。17、いいえ。1、pp。1-14、1989年6月。"
    },
    {
      "indent": 3,
      "text": "[FF96] Fall, K. and S. Floyd, \"Simulation-based Comparisons of Tahoe, Reno and SACK TCP\", Computer Communication Review, July 1996, ftp://ftp.ee.lbl.gov/papers/sacks.ps.Z.",
      "ja": "[FF96] Fall、K。およびS. Floyd、「Tahoe、RenoおよびSack TCPのシミュレーションベースの比較」、コンピューターコミュニケーションレビュー、1996年7月、ftp：//ftp.ee.lbl.gov/papers/sacks.ps.Z。"
    },
    {
      "indent": 3,
      "text": "[Hoe96] Hoe, J., \"Improving the Start-up Behavior of a Congestion Control Scheme for TCP\", In ACM SIGCOMM, August 1996.",
      "ja": "[Hoe96] Hoe、J。、「TCPの混雑制御スキームのスタートアップ動作の改善」、ACM Sigcomm、1996年8月。"
    },
    {
      "indent": 3,
      "text": "[HTH98] Hughes, A., Touch, J., and J. Heidemann, \"Issues in TCP Slow-Start Restart After Idle\", Work in Progress, March 1998.",
      "ja": "[HTH98] Hughes、A.、Touch、J。、およびJ. Heidemann、「Issure in TCP Slow-Start Restart after Idle」、1998年3月、進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[Jac88] Jacobson, V., \"Congestion Avoidance and Control\", Computer Communication Review, vol. 18, no. 4, pp. 314-329, Aug. 1988. ftp://ftp.ee.lbl.gov/papers/congavoid.ps.Z.",
      "ja": "[Jac88] Jacobson、V。、「混雑の回避と制御」、コンピューターコミュニケーションレビュー、Vol。18、いいえ。4、pp。314-329、1988年8月。ftp：//ftp.ee.lbl.gov/papers/congavoid.ps.z。"
    },
    {
      "indent": 3,
      "text": "[Jac90] Jacobson, V., \"Modified TCP Congestion Avoidance Algorithm\", end2end-interest mailing list, April 30, 1990. ftp://ftp.isi.edu/end2end/end2end-interest-1990.mail.",
      "ja": "[Jac90] Jacobson、V。、「修正されたTCP混雑回避アルゴリズム」、End2end-Interestメーリングリスト、1990年4月30日。ftp：//ftp.isi.edu/end2end/end2end-interest-1990.mail。"
    },
    {
      "indent": 3,
      "text": "[MM96a] Mathis, M. and J. Mahdavi, \"Forward Acknowledgment: Refining TCP Congestion Control\", Proceedings of SIGCOMM'96, August, 1996, Stanford, CA. Available from http://www.psc.edu/networking/papers/papers.html",
      "ja": "[MM96A] Mathis、M。およびJ. Mahdavi、「フォワード謝辞：TCP混雑制御の改良」、Sigcomm'96の議事録、1996年8月、カリフォルニア州スタンフォードhttp://www.psc.edu/networking/papers/papers.htmlから入手できます"
    },
    {
      "indent": 3,
      "text": "[MM96b] Mathis, M. and J. Mahdavi, \"TCP Rate-Halving with Bounding Parameters\", Technical report. Available from http://www.psc.edu/networking/papers/FACKnotes/current.",
      "ja": "[MM96B] Mathis、M。およびJ. Mahdavi、「境界パラメーターを備えたTCPレートハービング」、テクニカルレポート。http://www.psc.edu/networking/papers/facknotes/currentから入手できます。"
    },
    {
      "indent": 3,
      "text": "[Pax97] Paxson, V., \"End-to-End Internet Packet Dynamics\", Proceedings of SIGCOMM '97, Cannes, France, Sep. 1997.",
      "ja": "[Pax97] Paxson、V。、「エンドツーエンドのインターネットパケットダイナミクス」、Sigcomm '97の議事録、カンヌ、フランス、1997年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC813] Clark, D., \"Window and Acknowledgement Strategy in TCP\", RFC 813, July 1982.",
      "ja": "[RFC813]クラーク、D。、「TCPのウィンドウと承認戦略」、RFC 813、1982年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2001] Stevens, W., \"TCP Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery Algorithms\", RFC 2001, January 1997.",
      "ja": "[RFC2001] Stevens、W。、「TCPスロースタート、混雑回避、高速再送信、および高速回復アルゴリズム」、RFC 2001、1997年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC2018] Mathis, M., Mahdavi, J., Floyd, S., and A. Romanow, \"TCP Selective Acknowledgment Options\", RFC 2018, October 1996.",
      "ja": "[RFC2018] Mathis、M.、Mahdavi、J.、Floyd、S。、およびA. Romanow、「TCP選択的承認オプション」、RFC 2018、1996年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC2414] Allman, M., Floyd, S., and C. Partridge, \"Increasing TCP's Initial Window\", RFC 2414, September 1998.",
      "ja": "[RFC2414] Allman、M.、Floyd、S。、およびC. Partridge、「TCPの初期ウィンドウの増加」、RFC 2414、1998年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC2525] Paxson, V., Allman, M., Dawson, S., Fenner, W., Griner, J., Heavens, I., Lahey, K., Semke, J., and B. Volz, \"Known TCP Implementation Problems\", RFC 2525, March 1999.",
      "ja": "[RFC2525] Paxson、V.、Allman、M.、Dawson、S.、Fenner、W.、Griner、J.、Heavens、I.、Lahey、K.、Semke、J。、およびB. Volz、 \"TCP実装の問題」、RFC 2525、1999年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2581] Allman, M., Paxson, V., and W. Stevens, \"TCP Congestion Control\", RFC 2581, April 1999.",
      "ja": "[RFC2581] Allman、M.、Paxson、V。、およびW. Stevens、「TCP輻輳制御」、RFC 2581、1999年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC2883] Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An Extension to the Selective Acknowledgement (SACK) Option for TCP\", RFC 2883, July 2000.",
      "ja": "[RFC2883] Floyd、S.、Mahdavi、J.、Mathis、M。、およびM. Podolsky、「TCPの選択的承認（SACK）オプションの拡張」、RFC 2883、2000年7月。"
    },
    {
      "indent": 3,
      "text": "[RFC2988] Paxson, V. and M. Allman, \"Computing TCP's Retransmission Timer\", RFC 2988, November 2000.",
      "ja": "[RFC2988] Paxson、V。およびM. Allman、「TCPの再送信タイマーのコンピューティング」、RFC 2988、2000年11月。"
    },
    {
      "indent": 3,
      "text": "[RFC3042] Allman, M., Balakrishnan, H., and S. Floyd, \"Enhancing TCP's Loss Recovery Using Limited Transmit\", RFC 3042, January 2001.",
      "ja": "[RFC3042] Allman、M.、Balakrishnan、H。、およびS. Floyd、「限定送信を使用したTCPの損失回復の強化」、RFC 3042、2001年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC3168] Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of Explicit Congestion Notification (ECN) to IP\", RFC 3168, September 2001.",
      "ja": "[RFC3168] Ramakrishnan、K.、Floyd、S。、およびD. Black、「IPへの明示的な混雑通知（ECN）の追加」、RFC 3168、2001年9月。"
    },
    {
      "indent": 3,
      "text": "[RFC3390] Allman, M., Floyd, S., and C. Partridge, \"Increasing TCP's Initial Window\", RFC 3390, October 2002.",
      "ja": "[RFC3390] Allman、M.、Floyd、S。、およびC. Partridge、「TCPの初期ウィンドウの増加」、RFC 3390、2002年10月。"
    },
    {
      "indent": 3,
      "text": "[RFC3465] Allman, M., \"TCP Congestion Control with Appropriate Byte Counting (ABC)\", RFC 3465, February 2003.",
      "ja": "[RFC3465] Allman、M。、「適切なバイトカウント（ABC）によるTCP混雑制御」、RFC 3465、2003年2月。"
    },
    {
      "indent": 3,
      "text": "[RFC3517] Blanton, E., Allman, M., Fall, K., and L. Wang, \"A Conservative Selective Acknowledgment (SACK)-based Loss Recovery Algorithm for TCP\", RFC 3517, April 2003.",
      "ja": "[RFC3517] Blanton、E.、Allman、M.、Fall、K。、およびL. Wang、「TCPの保守的な選択的承認（SACK）ベースの損失回復アルゴリズム」、RFC 3517、2003年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC3782] Floyd, S., Henderson, T., and A. Gurtov, \"The NewReno Modification to TCP's Fast Recovery Algorithm\", RFC 3782, April 2004.",
      "ja": "[RFC3782] Floyd、S.、Henderson、T。、およびA. Gurtov、「TCPの高速回復アルゴリズムへのNewreno修正」、RFC 3782、2004年4月。"
    },
    {
      "indent": 3,
      "text": "[RFC4821] Mathis, M. and J. Heffner, \"Packetization Layer Path MTU Discovery\", RFC 4821, March 2007.",
      "ja": "[RFC4821] Mathis、M。およびJ. Heffner、「Packetization Layer Path MTU Discovery」、RFC 4821、2007年3月。"
    },
    {
      "indent": 3,
      "text": "[SCWA99] Savage, S., Cardwell, N., Wetherall, D., and T. Anderson, \"TCP Congestion Control With a Misbehaving Receiver\", ACM Computer Communication Review, 29(5), October 1999.",
      "ja": "[Scwa99] Savage、S.、Cardwell、N.、Wetherall、D。、およびT. Anderson、「不正行為レシーバーによるTCP混雑制御」、ACMコンピューター通信レビュー、29（5）、1999年10月。"
    },
    {
      "indent": 3,
      "text": "[Ste94] Stevens, W., \"TCP/IP Illustrated, Volume 1: The Protocols\", Addison-Wesley, 1994.",
      "ja": "[Ste94] Stevens、W。、「TCP/IP Illustrated、Volume 1：The Protocols」、Addison-Wesley、1994。"
    },
    {
      "indent": 3,
      "text": "[WS95] Wright, G. and W. Stevens, \"TCP/IP Illustrated, Volume 2: The Implementation\", Addison-Wesley, 1995.",
      "ja": "[WS95] Wright、G。and W. Stevens、「TCP/IP Illustrated、Volume 2：The Information」、Addison-Wesley、1995。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Mark Allman International Computer Science Institute (ICSI) 1947 Center Street Suite 600 Berkeley, CA 94704-1198 Phone: +1 440 235 1792 EMail: mallman@icir.org http://www.icir.org/mallman/",
      "ja": "マークオールマン国際コンピューターサイエンスインスティテュート（ICSI）1947センターストリートスイート600バークレー、カリフォルニア州94704-1198電話：1 440 235 1792メール：mallman@icir.org http://www.icir.org/mallman/"
    },
    {
      "indent": 3,
      "text": "Vern Paxson International Computer Science Institute (ICSI) 1947 Center Street Suite 600 Berkeley, CA 94704-1198 Phone: +1 510/642-4274 x302 EMail: vern@icir.org http://www.icir.org/vern/",
      "ja": "Vern Paxson International Computer Science Institute（ICSI）1947 Center Street Suite 600 Berkeley、CA 94704-1198電話：1 510/642-4274 X302メール：vern@icir.org http://www.icir.org/vern/"
    },
    {
      "indent": 3,
      "text": "Ethan Blanton Purdue University Computer Sciences 305 North University Street West Lafayette, IN 47907 EMail: eblanton@cs.purdue.edu http://www.cs.purdue.edu/homes/eblanton/",
      "ja": "イーサン・ブラントン・パーデュー大学コンピューター・サイエンス305ノースユニバーシティストリートウェストラファイエット、47907電子メール：eblanton@cs.purdue.edu http://www.cs.purdue.edu/homes/eblanton/"
    }
  ]
}