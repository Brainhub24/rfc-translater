{
  "title": {
    "text": "RFC 5842 - Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)",
    "ja": "RFC 5842 - Web分散オーサリングとバージョン化（WebDav）へのバインディング拡張機能"
  },
  "number": 5842,
  "created_at": "2023-02-04 09:17:46.326417+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                          G. Clemm\nRequest for Comments: 5842                                           IBM\nCategory: Experimental                                       J. Crawford\nISSN: 2070-1721                                             IBM Research\n                                                         J. Reschke, Ed.\n                                                              greenbytes\n                                                            J. Whitehead\n                                                         U.C. Santa Cruz\n                                                              April 2010",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": " Binding Extensions to Web Distributed Authoring and Versioning (WebDAV)",
      "ja": "Web分散オーサリングとバージョン化（WebDav）へのバインディング拡張機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This specification defines bindings, and the BIND method for creating multiple bindings to the same resource. Creating a new binding to a resource causes at least one new URI to be mapped to that resource. Servers are required to ensure the integrity of any bindings that they allow to be created.",
      "ja": "この仕様は、バインディングと、同じリソースに複数のバインディングを作成するためのバインド方法を定義します。リソースへの新しいバインディングを作成すると、少なくとも1つの新しいURIがそのリソースにマッピングされます。サーバーは、作成できるバインディングの完全性を確保するために必要です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。試験、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントは、インターネットコミュニティの実験プロトコルを定義しています。このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補者ではありません。RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc5842.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc5842で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2010 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2010 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "This document may contain material from IETF Documents or IETF Contributions published or made publicly available before November 10, 2008. The person(s) controlling the copyright in some of this material may not have granted the IETF Trust the right to allow modifications of such material outside the IETF Standards Process. Without obtaining an adequate license from the person(s) controlling the copyright in such materials, this document may not be modified outside the IETF Standards Process, and derivative works of it may not be created outside the IETF Standards Process, except to format it for publication as an RFC or to translate it into languages other than English.",
      "ja": "このドキュメントには、2008年11月10日までに公開または公開されたIETFドキュメントまたはIETFの寄付からの資料が含まれている場合があります。IETF標準プロセスの外。そのような資料の著作権を制御する人から適切なライセンスを取得せずに、このドキュメントはIETF標準プロセスの外側に変更されない場合があり、その派生作業は、ITF標準プロセスの外側で作成されない場合があります。RFCとしての出版またはそれを英語以外の言語に翻訳するため。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1. Introduction ....................................................4\n   1.1. Terminology ................................................5\n   1.2. Method Preconditions and Postconditions ....................6\n2. Overview of Bindings ............................................7\n   2.1. Bindings to Collections ....................................7\n        2.1.1. Bind Loops ..........................................8\n   2.2. URI Mappings Created by a New Binding ......................8\n   2.3. COPY and Bindings ..........................................9\n        2.3.1. Example: COPY with \"Depth: infinity\" in\n               Presence of Bind Loops .............................11\n        2.3.2. Example: COPY Updating Multiple Bindings ...........13\n        2.3.3. Example: COPY with \"Depth: infinity\" with\n               Multiple Bindings to a Leaf Resource ...............14\n   2.4. DELETE and Bindings .......................................15\n   2.5. MOVE and Bindings .........................................15\n        2.5.1. Example: Simple MOVE ...............................16\n        2.5.2. Example: MOVE Request Causing a Bind Loop ..........16\n   2.6. PROPFIND and Bindings .....................................18\n      2.7. Determining Whether Two Bindings Are to the Same\n        Resource ..................................................18\n   2.8. Discovering the Bindings to a Resource ....................19\n3. Properties .....................................................19\n   3.1. DAV:resource-id Property ..................................20\n   3.2. DAV:parent-set Property ...................................20\n        3.2.1. Example for DAV:parent-set Property ................20\n4. BIND Method ....................................................21\n   4.1. Example: BIND .............................................24\n5. UNBIND Method ..................................................24\n   5.1. Example: UNBIND ...........................................26\n6. REBIND Method ..................................................26\n   6.1. Example: REBIND ...........................................28\n   6.2. Example: REBIND in Presence of Locks and Bind Loops .......29\n7. Additional Status Codes ........................................31\n   7.1. 208 Already Reported ......................................31\n        7.1.1. Example: PROPFIND by Bind-Aware Client .............32\n        7.1.2. Example: PROPFIND by Non-Bind-Aware Client .........34\n   7.2. 508 Loop Detected .........................................34\n8. Capability Discovery ...........................................34\n   8.1. OPTIONS Method ............................................34\n   8.2. 'DAV' Request Header ......................................34\n9. Relationship to Locking in WebDAV ..............................35\n   9.1. Example: Locking and Multiple Bindings ....................36\n10. Relationship to WebDAV Access Control Protocol ................37\n11. Relationship to Versioning Extensions to WebDAV ...............37\n12. Security Considerations .......................................40\n   12.1. Privacy Concerns .........................................40\n   12.2. Bind Loops ...............................................40\n   12.3. Bindings and Denial of Service ...........................40\n   12.4. Private Locations May Be Revealed ........................40\n   12.5. DAV:parent-set and Denial of Service .....................41\n13. Internationalization Considerations ...........................41\n14. IANA Considerations ...........................................41\n15. Acknowledgements ..............................................41\n16. References ....................................................41\n   16.1. Normative References .....................................41\n   16.2. Informative References ...................................42\nIndex .............................................................42",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This specification extends the WebDAV Distributed Authoring Protocol ([RFC4918]) to enable clients to create new access paths to existing resources. This capability is useful for several reasons:",
      "ja": "この仕様により、WebDAV分散オーサリングプロトコル（[RFC4918]）が拡張され、クライアントが既存のリソースへの新しいアクセスパスを作成できるようにします。この機能は、いくつかの理由で役立ちます。"
    },
    {
      "indent": 3,
      "text": "URIs of WebDAV-compliant resources are hierarchical and correspond to a hierarchy of collections in resource space. The WebDAV Distributed Authoring Protocol makes it possible to organize these resources into hierarchies, placing them into groupings, known as collections, which are more easily browsed and manipulated than a single flat collection. However, hierarchies require categorization decisions that locate resources at a single location in the hierarchy, a drawback when a resource has multiple valid categories. For example, in a hierarchy of vehicle descriptions containing collections for cars and boats, a description of a combination car/boat vehicle could belong in either collection. Ideally, the description should be accessible from both. Allowing clients to create new URIs that access the existing resource lets them put that resource into multiple collections.",
      "ja": "WebDAVに準拠したリソースのURISは階層的であり、リソーススペースのコレクションの階層に対応しています。WebDAV分散オーサリングプロトコルにより、これらのリソースを階層に整理し、コレクションとして知られるグループに配置することができます。コレクションは、単一のフラットコレクションよりも簡単に閲覧および操作されます。ただし、階層には、階層内の単一の場所にリソースを配置する分類決定が必要です。これは、リソースに複数の有効なカテゴリがある場合の欠点です。たとえば、車やボートのコレクションを含む車両の説明の階層では、コンビネーション車/ボートの車両の説明がどちらのコレクションにも属している可能性があります。理想的には、説明には両方からアクセスできる必要があります。クライアントが既存のリソースにアクセスする新しいURIを作成できるようにすることで、そのリソースを複数のコレクションに入れることができます。"
    },
    {
      "indent": 3,
      "text": "Hierarchies also make resource sharing more difficult, since resources that have utility across many collections are still forced into a single collection. For example, the mathematics department at one university might create a collection of information on fractals that contains bindings to some local resources but also provides access to some resources at other universities. For many reasons, it may be undesirable to make physical copies of the shared resources on the local server, for example, to conserve disk space, to respect copyright constraints, or to make any changes in the shared resources visible automatically. Being able to create new access paths to existing resources in other collections or even on other servers is useful for this sort of case.",
      "ja": "階層は、多くのコレクションにわたってユーティリティを持つリソースがまだ単一のコレクションに強制されているため、リソース共有をより困難にします。たとえば、ある大学の数学部門は、いくつかの地元のリソースへのバインディングを含むが、他の大学のいくつかのリソースへのアクセスを提供するフラクタルに関する情報のコレクションを作成する場合があります。多くの理由で、たとえばディスクスペースを節約したり、著作権の制約を尊重したり、共有リソースを自動的に見えるように変更したりするために、ローカルサーバー上の共有リソースの物理的なコピーを作成することは望ましくない場合があります。他のコレクションや他のサーバーで既存のリソースへの新しいアクセスパスを作成できることは、この種のケースに役立ちます。"
    },
    {
      "indent": 3,
      "text": "The BIND method, defined here, provides a mechanism for allowing clients to create alternative access paths to existing WebDAV resources. HTTP [RFC2616] and WebDAV [RFC4918] methods are able to work because there are mappings between URIs and resources. A method is addressed to a URI, and the server follows the mapping from that URI to a resource, applying the method to that resource. Multiple URIs may be mapped to the same resource, but until now, there has been no way for clients to create additional URIs mapped to existing resources.",
      "ja": "ここで定義されているBINDメソッドは、クライアントが既存のWebDAVリソースへの代替アクセスパスを作成できるようにするためのメカニズムを提供します。HTTP [RFC2616]およびWebDav [RFC4918]メソッドは、URIとリソースの間にマッピングがあるため、動作する可能性があります。メソッドはURIに宛てられ、サーバーはそのURIからリソースへのマッピングに従い、そのメソッドをそのリソースに適用します。複数のURIが同じリソースにマッピングされる場合がありますが、これまで、クライアントが既存のリソースにマッピングされた追加のURIを作成する方法はありませんでした。"
    },
    {
      "indent": 3,
      "text": "BIND lets clients associate a new URI with an existing WebDAV resource, and this URI can then be used to submit requests to the resource. Since URIs of WebDAV resources are hierarchical, and correspond to a hierarchy of collections in resource space, the BIND method also has the effect of adding the resource to a collection. As new URIs are associated with the resource, it appears in additional collections.",
      "ja": "Bindにより、クライアントは新しいURIを既存のWebDAVリソースと関連付けることができ、このURIを使用してリクエストをリソースに送信できます。WebDAVリソースのURIは階層的であり、リソーススペースのコレクションの階層に対応するため、BINDメソッドはリソースをコレクションに追加する効果もあります。新しいURIがリソースに関連付けられているため、追加のコレクションに表示されます。"
    },
    {
      "indent": 3,
      "text": "A BIND request does not create a new resource, but simply makes a new URI for submitting requests to an existing resource available. The new URI is indistinguishable from any other URI when submitting a request to a resource. Only one round trip is needed to submit a request to the intended target. Servers are required to enforce the integrity of the relationships between the new URIs and the resources associated with them. Consequently, it may be very costly for servers to support BIND requests that cross server boundaries.",
      "ja": "BINDリクエストは新しいリソースを作成しませんが、利用可能な既存のリソースにリクエストを送信するための新しいURIを作成するだけです。新しいURIは、リソースにリクエストを送信する際に、他のURIと区別できません。意図したターゲットにリクエストを送信するには、1回の往復のみが必要です。サーバーは、新しいURIとそれらに関連するリソースとの関係の完全性を強制するために必要です。したがって、サーバーがサーバーの境界をクロスするバインドリクエストをサポートするのは非常に費用がかかる可能性があります。"
    },
    {
      "indent": 3,
      "text": "This specification is organized as follows. Section 1.1 defines terminology used in the rest of the specification, while Section 2 overviews bindings. Section 3 defines the new properties needed to support multiple bindings to the same resource. Section 4 specifies the BIND method, used to create multiple bindings to the same resource. Section 5 specifies the UNBIND method, used to remove a binding to a resource. Section 6 specifies the REBIND method, used to move a binding to another collection.",
      "ja": "この仕様は次のように編成されています。セクション1.1は、仕様の残りの部分で使用される用語を定義し、セクション2はバインディングを概要します。セクション3では、同じリソースへの複数のバインディングをサポートするために必要な新しいプロパティを定義しています。セクション4は、同じリソースに複数のバインディングを作成するために使用されるバインドメソッドを指定します。セクション5は、リソースへのバインディングを削除するために使用されるバインドメソッドを指定します。セクション6は、バインディングを別のコレクションに移動するために使用されるRebindメソッドを指定します。"
    },
    {
      "indent": 0,
      "text": "1.1. Terminology",
      "section_title": true,
      "ja": "1.1. 用語"
    },
    {
      "indent": 3,
      "text": "The terminology used here follows and extends that in the WebDAV Distributed Authoring Protocol specification [RFC4918].",
      "ja": "ここで使用される用語は、WebDAV分散オーサリングプロトコル仕様[RFC4918]に続き、拡張されます。"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "This document uses XML DTD fragments ([XML]) as a notational convention, using the rules defined in Section 17 of [RFC4918].",
      "ja": "このドキュメントでは、[RFC4918]のセクション17で定義されているルールを使用して、XML DTDフラグメント（[XML]）を表記規則として使用します。"
    },
    {
      "indent": 3,
      "text": "URI Mapping",
      "ja": "URIマッピング"
    },
    {
      "indent": 6,
      "text": "A relation between an absolute URI and a resource. For an absolute URI U and the resource it identifies R, the URI mapping can be thought of as (U => R). Since a resource can represent items that are not network retrievable as well as those that are, it is possible for a resource to have zero, one, or many URI mappings. Mapping a resource to an \"http\"-scheme URI makes it possible to submit HTTP requests to the resource using the URI.",
      "ja": "絶対URIとリソースの関係。絶対的なURI UとそれがRを識別するリソースの場合、URIマッピングは（u => r）と考えることができます。リソースは、ネットワーク取得可能ではないアイテムとそれであるアイテムを表すことができるため、リソースがゼロ、1つ、または多くのURIマッピングを持つことができます。リソースを「HTTP」-Scheme URIにマッピングすると、URIを使用してリソースにHTTPリクエストを送信できます。"
    },
    {
      "indent": 3,
      "text": "Path Segment",
      "ja": "パスセグメント"
    },
    {
      "indent": 6,
      "text": "Informally, the characters found between slashes (\"/\") in a URI. Formally, as defined in Section 3.3 of [RFC3986].",
      "ja": "非公式には、URIのスラッシュ（ \"/\"）の間に見られるキャラクター。正式には、[RFC3986]のセクション3.3で定義されています。"
    },
    {
      "indent": 3,
      "text": "Binding",
      "ja": "バインディング"
    },
    {
      "indent": 6,
      "text": "A relation between a single path segment (in a collection) and a resource. A binding is part of the state of a collection. If two different collections contain a binding between the same path segment and the same resource, these are two distinct bindings. So for a collection C, a path segment S, and a resource R, the binding can be thought of as C:(S -> R). Bindings create URI mappings, and hence allow requests to be sent to a single resource from multiple locations in a URI namespace. For example, given a collection C (accessible through the URI http://www.example.com/CollX), a path segment S (equal to \"foo.html\"), and a resource R, then creating the binding C: (S -> R) makes it possible to use the URI http://www.example.com/CollX/foo.html to access R.",
      "ja": "単一のパスセグメント（コレクション内）とリソースの関係。バインディングはコレクションの状態の一部です。2つの異なるコレクションに同じパスセグメントと同じリソースの間にバインディングが含まれている場合、これらは2つの異なるバインディングです。したがって、コレクションC、パスセグメントS、およびリソースRの場合、バインディングはC：（s-> r）と考えることができます。バインディングはURIマッピングを作成するため、URIネームスペースの複数の場所から単一のリソースにリクエストを送信できます。たとえば、コレクションC（URI http://www.example.com/collxからアクセス可能）、パスセグメントs（「foo.html」に等しい）、およびリソースrを指定し、バインディングCを作成します。（S-> r）URI http://www.example.com/collx/foo.htmlを使用してRを使用することを可能にします。"
    },
    {
      "indent": 3,
      "text": "Collection",
      "ja": "コレクション"
    },
    {
      "indent": 6,
      "text": "A resource that contains, as part of its state, a set of bindings that identify internal member resources.",
      "ja": "州の一部として、内部メンバーリソースを識別するバインディングのセットを含むリソース。"
    },
    {
      "indent": 3,
      "text": "Internal Member URI",
      "ja": "内部メンバーURI"
    },
    {
      "indent": 6,
      "text": "The URI that identifies an internal member of a collection and that consists of the URI for the collection, followed by a slash character ('/'), followed by the path segment of the binding for that internal member.",
      "ja": "コレクションの内部メンバーを識別し、コレクションのURIで構成されるURI、続いてスラッシュ文字（ '/'）が続き、その後にその内部メンバーのバインディングのパスセグメントが続きます。"
    },
    {
      "indent": 3,
      "text": "Binding Integrity",
      "ja": "結合の完全性"
    },
    {
      "indent": 6,
      "text": "The property of a binding that says that:",
      "ja": "次のような拘束力のある財産"
    },
    {
      "indent": 6,
      "text": "* the binding continues to exist, and",
      "ja": "* 結合は存在し続けています"
    },
    {
      "indent": 6,
      "text": "* the identity of the resource identified by that binding does not change,",
      "ja": "* そのバインディングによって識別されたリソースのアイデンティティは変わりません、"
    },
    {
      "indent": 6,
      "text": "unless an explicit request is executed that is defined to delete that binding (examples of requests that delete a binding are DELETE, MOVE, and -- defined later on -- UNBIND and REBIND).",
      "ja": "そのバインディングを削除するように定義された明示的な要求が実行されない限り（バインディングを削除するリクエストの例は、削除、移動、および後で定義されます - バインドと再バインド）。"
    },
    {
      "indent": 0,
      "text": "1.2. Method Preconditions and Postconditions",
      "section_title": true,
      "ja": "1.2. メソッドの前提条件と事後条件"
    },
    {
      "indent": 3,
      "text": "See Section 16 of [RFC4918] for the definitions of \"precondition\" and \"postcondition\".",
      "ja": "「前提条件」と「条件」の定義については、[RFC4918]のセクション16を参照してください。"
    },
    {
      "indent": 0,
      "text": "2. Overview of Bindings",
      "section_title": true,
      "ja": "2. バインディングの概要"
    },
    {
      "indent": 3,
      "text": "Bindings are part of the state of a collection. They define the internal members of the collection and the names of those internal members.",
      "ja": "バインディングはコレクションの状態の一部です。彼らは、コレクションの内部メンバーとそれらの内部メンバーの名前を定義します。"
    },
    {
      "indent": 3,
      "text": "Bindings are added and removed by a variety of existing HTTP methods. A method that creates a new resource, such as PUT, COPY, and MKCOL, adds a binding. A method that deletes a resource, such as DELETE, removes a binding. A method that moves a resource (e.g., MOVE) both adds a binding (in the destination collection) and removes a binding (in the source collection). The BIND method introduced here provides a mechanism for adding a second binding to an existing resource. There is no difference between an initial binding added by PUT, COPY, or MKCOL and additional bindings added with BIND.",
      "ja": "バインディングは、さまざまな既存のHTTPメソッドによって追加および削除されます。Put、Copy、MKCOLなどの新しいリソースを作成するメソッドは、バインディングを追加します。削除などのリソースを削除するメソッドは、バインディングを削除します。リソースを移動する方法（たとえば、移動）は、バインディング（宛先コレクション）を追加し、バインディング（ソースコレクションで）を削除します。ここで導入されたバインド方法は、既存のリソースに2番目のバインディングを追加するメカニズムを提供します。PUT、コピー、またはMKCOLによって追加された初期バインディングと、バインドで追加のバインディングに違いはありません。"
    },
    {
      "indent": 3,
      "text": "It would be very undesirable if one binding could be destroyed as a side effect of operating on the resource through a different binding. In particular, the removal of one binding to a resource (e.g., with a DELETE or a MOVE) MUST NOT disrupt another binding to that resource, e.g., by turning that binding into a dangling path segment. The server MUST NOT reclaim system resources after removing one binding, while other bindings to the resource remain. In other words, the server MUST maintain the integrity of a binding. It is permissible, however, for future method definitions (e.g., a DESTROY method) to have semantics that explicitly remove all bindings and/or immediately reclaim system resources.",
      "ja": "別のバインディングを介してリソースに操作する副作用として1つの結合を破壊できる場合、それは非常に望ましくありません。特に、リソースへの1つのバインディング（たとえば、削除や移動など）を削除することは、そのバインディングをぶら下げパスセグメントに変えることにより、そのリソースへの別のバインディングを破壊してはなりません。サーバーは、1つのバインディングを削除した後にシステムリソースを回収してはなりませんが、リソースへの他のバインディングは残ります。言い換えれば、サーバーはバインディングの完全性を維持する必要があります。ただし、将来のメソッド定義（たとえば、破壊方法）がすべてのバインディングを明示的に削除したり、すぐにシステムリソースを取り戻すセマンティクスを持つことは許可されています。"
    },
    {
      "indent": 6,
      "text": "Note: the collection model described herein is not compatible with systems in which resources inherit properties based solely on the access path, as the ability to create additional bindings will cause a single resource to appear as member of several different collections at the same time.",
      "ja": "注：本明細書に記載されているコレクションモデルは、リソースがアクセスパスのみに基づいてプロパティを継承するシステムと互換性がありません。追加のバインディングを作成する機能により、単一のリソースが複数の異なるコレクションのメンバーとして同時に表示されるためです。"
    },
    {
      "indent": 0,
      "text": "2.1. Bindings to Collections",
      "section_title": true,
      "ja": "2.1. コレクションへのバインディング"
    },
    {
      "indent": 3,
      "text": "Creating a new binding to a collection makes each resource associated with a binding in that collection accessible via a new URI, and thus creates new URI mappings to those resources but no new bindings.",
      "ja": "コレクションへの新しいバインディングを作成すると、新しいURIを介してアクセス可能なコレクションのバインディングに関連付けられた各リソースにより、これらのリソースに新しいURIマッピングが作成されますが、新しいバインディングはありません。"
    },
    {
      "indent": 3,
      "text": "For example, suppose a new binding CollY is created for collection C1 in the figure below. It immediately becomes possible to access resource R1 using the URI /CollY/x.gif and to access resource R2 using the URI /CollY/y.jpg, but no new bindings for these child resources were created. This is because bindings are part of the state of a collection, and they associate a URI that is relative to that collection with its target resource. No change to the bindings in Collection C1 is needed to make its children accessible using /CollY/x.gif and /CollY/y.jpg.",
      "ja": "たとえば、下の図にコレクションC1用にCollyが作成されたと仮定します。URI /Colly/x.gifを使用してリソースR1にアクセスし、URI /Colly/Y.jpgを使用してリソースR2にアクセスすることがすぐに可能になりますが、これらの子リソースの新しいバインディングは作成されませんでした。これは、バインディングがコレクションの状態の一部であり、そのコレクションに関連するURIをターゲットリソースと関連付けるためです。/colly/x.gifおよび/colly/y.jpgを使用して子供をアクセスできるようにするために、コレクションC1のバインディングに変更は必要ありません。"
    },
    {
      "indent": 21,
      "text": "+-------------------------+\n| Root Collection         |\n|  bindings:              |\n|  CollX          CollY   |\n+-------------------------+\n    |            /\n    |           /\n    |          /\n+------------------+\n| Collection C1    |\n| bindings:        |\n| x.gif     y.jpg  |\n+------------------+\n    |          \\\n    |           \\\n    |            \\\n+-------------+   +-------------+\n| Resource R1 |   | Resource R2 |\n+-------------+   +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.1.1. Bind Loops",
      "section_title": true,
      "ja": "2.1.1. バインドループ"
    },
    {
      "indent": 3,
      "text": "Bindings to collections can result in loops (\"cycles\"), which servers MUST detect when processing \"Depth: infinity\" requests. It is sometimes possible to complete an operation in spite of the presence of a loop. For instance, a PROPFIND can still succeed if the server uses the new status code 208 (Already Reported) defined in Section 7.1.",
      "ja": "コレクションへのバインディングは、ループ（「サイクル」）をもたらす可能性があります。これは、「深さ：無限」リクエストを処理するときにサーバーを検出する必要があります。ループが存在しているにもかかわらず、操作を完了することができる場合があります。たとえば、サーバーがセクション7.1で定義されている新しいステータスコード208（既に報告されている）を使用している場合、Propfindは引き続き成功する可能性があります。"
    },
    {
      "indent": 3,
      "text": "However, the 508 (Loop Detected) status code is defined in Section 7.2 for use in contexts where an operation is terminated because a loop was encountered.",
      "ja": "ただし、508（ループ検出）ステータスコードは、ループが発生したために操作が終了するコンテキストで使用するためにセクション7.2で定義されます。"
    },
    {
      "indent": 3,
      "text": "Support for loops is OPTIONAL: servers MAY reject requests that would lead to the creation of a bind loop (see DAV:cycle-allowed precondition defined in Section 4).",
      "ja": "ループのサポートはオプションです。サーバーは、バインドループの作成につながるリクエストを拒否する場合があります（DAV：セクション4で定義されているサイクルによる前提条件を参照）。"
    },
    {
      "indent": 0,
      "text": "2.2. URI Mappings Created by a New Binding",
      "section_title": true,
      "ja": "2.2. 新しいバインディングによって作成されたURIマッピング"
    },
    {
      "indent": 3,
      "text": "Suppose a binding from \"Binding-Name\" to resource R is to be added to a collection, C. Then if C-MAP is the set of URIs that were mapped to C before the BIND request, then for each URI \"C-URI\" in C-MAP, the URI \"C-URI/Binding-Name\" is mapped to resource R following the BIND request.",
      "ja": "「バインディングネーム」からリソースRへのバインディングがコレクションCに追加されるとします。C-Mapがバインド要求の前にCにマッピングされたURIのセットである場合、各URI \"C-uriについて「C-Mapでは、URI」C-URI/Binding-Name」は、バインド要求に従ってリソースRにマッピングされます。"
    },
    {
      "indent": 3,
      "text": "For example, if a binding from \"foo.html\" to R is added to a collection C, and if the following URIs are mapped to C:",
      "ja": "たとえば、「foo.html」からrへのバインディングがコレクションcに追加され、次のURIがcにマッピングされている場合："
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/ http://example.com/A/one/",
      "ja": "http://www.example.com/a/1/ http://example.com/a/one/"
    },
    {
      "indent": 3,
      "text": "then the following new mappings to R are introduced:",
      "ja": "次に、次のRへの新しいマッピングが導入されます。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/foo.html http://example.com/A/one/foo.html",
      "ja": "http://www.example.com/a/1/foo.html http://example.com/a/one/foo.html"
    },
    {
      "indent": 3,
      "text": "Note that if R is a collection, additional URI mappings are created to the descendents of R. Also, note that if a binding is made in collection C to C itself (or to a parent of C), an infinite number of mappings are introduced.",
      "ja": "Rがコレクションである場合、Rの子孫にも追加のURIマッピングが作成されることに注意してください。コレクションCでバインディングがC自体（またはCの親）に作成されている場合、無限の数のマッピングが導入されることに注意してください。。"
    },
    {
      "indent": 3,
      "text": "For example, if a binding from \"myself\" to C is then added to C, the following infinite number of additional mappings to C are introduced:",
      "ja": "たとえば、「自分」からCへのバインディングがCに追加されると、次の数の追加数の追加マッピングがCに導入されます。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/myself http://www.example.com/A/1/myself/myself ...",
      "ja": "http://www.example.com/a/1/myself http://www.example.com/a/1/myself/myself ..."
    },
    {
      "indent": 3,
      "text": "and the following infinite number of additional mappings to R are introduced:",
      "ja": "そして、Rへの追加の追加のマッピングの数が導入されています。"
    },
    {
      "indent": 3,
      "text": "http://www.example.com/A/1/myself/foo.html http://www.example.com/A/1/myself/myself/foo.html ...",
      "ja": "http://www.example.com/a/1/myself/foo.html http://www.example.com/a/1/myself/myself/foo.html ..."
    },
    {
      "indent": 0,
      "text": "2.3. COPY and Bindings",
      "section_title": true,
      "ja": "2.3. コピーとバインディング"
    },
    {
      "indent": 3,
      "text": "As defined in Section 9.8 of [RFC4918], COPY causes the resource identified by the Request-URI to be duplicated and makes the new resource accessible using the URI specified in the Destination header. Upon successful completion of a COPY, a new binding is created between the last path segment of the Destination header and the destination resource. The new binding is added to its parent collection, identified by the Destination header minus its final segment.",
      "ja": "[RFC4918]のセクション9.8で定義されているように、コピーはリクエスト-URIによって識別されたリソースを複製し、宛先ヘッダーで指定されたURIを使用して新しいリソースにアクセスできるようにします。コピーが正常に完了すると、宛先ヘッダーの最後のパスセグメントと宛先リソースの間に新しいバインディングが作成されます。新しいバインディングは、宛先ヘッダーから最終セグメントから識別される親コレクションに追加されます。"
    },
    {
      "indent": 3,
      "text": "The following figure shows an example: suppose that a COPY is issued to URI-3 for resource R (which is also mapped to URI-1 and URI-2), with the Destination header set to URI-X. After successful completion of the COPY operation, resource R is duplicated to create resource R', and a new binding has been created that creates at least the URI mapping between URI-X and the new resource (although other URI mappings may also have been created).",
      "ja": "次の図は、例を示しています。リソースR（URI-1およびURI-2にもマッピングされている）のコピーがURI-3に発行され、宛先ヘッダーがURI-Xに設定されていると仮定します。コピー操作が正常に完了した後、リソースRが複製されてリソースR 'が作成され、少なくともURI-Xと新しいリソースの間のURIマッピングが作成される新しいバインディングが作成されました（ただし、他のURIマッピングも作成されている可能性があります。）。"
    },
    {
      "indent": 5,
      "text": "URI-1   URI-2    URI-3                           URI-X\n   |       |        |                              |\n   |       |        |   <---- URI Mappings ---->   |\n   |       |        |                              |\n+---------------------+                 +------------------------+\n|     Resource R      |                 |     Resource R'        |\n+---------------------+                 +------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "It might be thought that a COPY request with \"Depth: 0\" on a collection would duplicate its bindings, since bindings are part of the collection's state. This is not the case, however. The definition of Depth in [RFC4918] makes it clear that a \"Depth: 0\" request does not apply to a collection's members. Consequently, a COPY with \"Depth: 0\" does not duplicate the bindings contained by the collection.",
      "ja": "バインディングはコレクションの状態の一部であるため、コレクションの「深さ：0」のコピー要求はバインディングを複製すると考えられるかもしれません。ただし、そうではありません。[RFC4918]の深さの定義により、「深さ：0」要求がコレクションのメンバーに適用されないことが明らかになります。その結果、「深さ：0」のコピーは、コレクションに含まれるバインディングを複製しません。"
    },
    {
      "indent": 3,
      "text": "If a COPY request causes an existing resource to be updated, the bindings to that resource MUST be unaffected by the COPY request. Using the preceding example, suppose that a COPY request is issued to URI-X for resource R', with the Destination header set to URI-2. The content and dead properties of resource R would be updated to be a copy of those of resource R', but the mappings from URI-1, URI-2, and URI-3 to resource R remain unaffected. If, because of multiple bindings to a resource, more than one source resource updates a single destination resource, the order of the updates is server defined (see Section 2.3.2 for an example).",
      "ja": "コピー要求が既存のリソースを更新する場合、そのリソースへのバインディングはコピーリクエストの影響を受けない必要があります。前の例を使用して、宛先ヘッダーがURI-2に設定されているため、リソースR 'に対してURI-Xにコピー要求が発行されたと仮定します。リソースRのコンテンツとデッドプロパティは、リソースR 'のコピーのコピーに更新されますが、URI-1、URI-2、およびURI-3のマッピングはリソースRへの依然として影響を受けません。リソースへの複数のバインディングのために、複数のソースリソースが単一の宛先リソースを更新する場合、更新の順序はサーバーが定義されています（例についてはセクション2.3.2を参照）。"
    },
    {
      "indent": 3,
      "text": "If a COPY request would cause a new resource to be created as a copy of an existing resource, and that COPY request has already created a copy of that existing resource, the COPY request instead creates another binding to the previous copy, instead of creating a new resource (see Section 2.3.3 for an example).",
      "ja": "コピー要求が既存のリソースのコピーとして新しいリソースを作成し、そのコピーリクエストが既存のリソースのコピーをすでに作成している場合、代わりにコピーリクエストは、以前のコピーに別のバインディングを作成します。新しいリソース（例についてはセクション2.3.3を参照）。"
    },
    {
      "indent": 0,
      "text": "2.3.1. Example: COPY with \"Depth: infinity\" in Presence of Bind Loops",
      "section_title": true,
      "ja": "2.3.1. 例：バインドループの存在下で「深さ：無限」でコピー"
    },
    {
      "indent": 3,
      "text": "As an example of how COPY with \"Depth: infinity\" would work in the presence of bindings, consider the following collection:",
      "ja": "「深さ：無限」を含むコピーがバインディングの存在下でどのように機能するかの例として、次のコレクションを検討してください。"
    },
    {
      "indent": 17,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX           |\n+------------------+\n    |\n    |\n+-------------------------------+\n| Collection C1                 |<-------+\n| bindings:                     |        |\n| x.gif      CollY              |        |\n+-------------------------------+        |\n    |            \\        (creates loop) |\n    |             \\                      |\n+-------------+   +------------------+   |\n| Resource R1 |   | Collection C2    |   |\n+-------------+   | bindings:        |   |\n                  | y.gif     CollZ  |   |\n                  +------------------+   |\n                      |         |        |\n                      |         +--------+\n                      |\n                  +-------------+\n                  | Resource R2 |\n                  +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If a COPY request with \"Depth: infinity\" is submitted to /CollX, with a destination of /CollA, the outcome of the copy operation is that a copy of the tree is replicated to the target /CollA:",
      "ja": "「Depth：Infinity」を含むコピー要求が /Collxに /Collaの目的地で提出された場合、コピー操作の結果は、ツリーのコピーがターゲット /コラに複製されることです。"
    },
    {
      "indent": 16,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX     CollA |\n+------------------+\n   |           |\n   |           +---------------------------+\n   |                                       |\n+-------------------+                      |\n| Collection C1     |<------------------+  |\n| bindings:         |                   |  |\n| x.gif      CollY  |                   |  |\n+-------------------+                   |  |\n   |            \\        (creates loop) |  |\n   |             \\                      |  |\n+-------------+   +-----------------+   |  |\n| Resource R1 |   | Collection C2   |   |  |\n+-------------+   | bindings:       |   |  |\n                  | y.gif     CollZ |   |  |\n                  +-----------------+   |  |\n                      |         |       |  |\n                      |         +-------+  |\n                      |                    |\n                  +-------------+          |\n                  | Resource R2 |          |\n                  +-------------+          |\n                                           |\n           +-------------------------------+\n           |\n+-------------------+\n| Collection C3     |<------------------+\n| bindings:         |                   |\n| x.gif      CollY  |                   |\n+-------------------+                   |\n   |            \\        (creates loop) |\n   |             \\                      |\n+-------------+   +-----------------+   |\n| Resource R3 |   | Collection C4   |   |\n+-------------+   | bindings:       |   |\n                  | y.gif     CollZ |   |\n                  +-----------------+   |\n                      |         |       |\n                      |         +-------+\n                      |\n                  +-------------+\n                  | Resource R4 |\n                  +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that the same would apply for more complex loops.",
      "ja": "より複雑なループにも同じことが当てはまることに注意してください。"
    },
    {
      "indent": 0,
      "text": "2.3.2. Example: COPY Updating Multiple Bindings",
      "section_title": true,
      "ja": "2.3.2. 例：複数のバインディングの更新をコピーします"
    },
    {
      "indent": 3,
      "text": "Given the following collection hierarchy:",
      "ja": "次のコレクション階層を考えると、"
    },
    {
      "indent": 12,
      "text": "                    +------------------+\n                    | Root Collection  |\n                    |  bindings:       |\n                    |  CollX     CollY |\n                    +------------------+\n                       /              \\\n                      /                \\\n                     /                  \\\n  +--------------------------+   +-----------------+\n  |      Collection C1       |   | Collection C2   |\n  |      bindings:           |   | bindings:       |\n  |     x.gif     y.gif      |   | x.gif     y.gif |\n  +--------------------------+   +-----------------+\n          |         |                |         |\n          |         |                |         |\n+-------------+  +-------------+   +-------------+\n| Resource R1 |  | Resource R2 |   | Resource R3 |\n+-------------+  +-------------+   +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A COPY of /CollX with \"Depth: infinity\" to /CollY will not result in a changed hierarchy, and Resource R3 will be updated with the content of either Resource R1 or Resource R2.",
      "ja": "/collxのコピー「深さ：Infinity」へのコピーは、 /collyに階層の変更されず、リソースR3はリソースR1またはリソースR2のコンテンツで更新されます。"
    },
    {
      "indent": 0,
      "text": "2.3.3. Example: COPY with \"Depth: infinity\" with Multiple Bindings to a Leaf Resource",
      "section_title": true,
      "ja": "2.3.3. 例：葉のリソースへの複数のバインディングを備えた「深さ：無限」でコピー"
    },
    {
      "indent": 3,
      "text": "Given the following collection hierarchy:",
      "ja": "次のコレクション階層を考えると、"
    },
    {
      "indent": 28,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX           |\n+------------------+\n   |\n   |\n   |\n+----------------+\n| Collection C1  |\n| bindings:      |\n| x.gif    y.gif |\n+----------------+\n   |         |\n   |         |\n +-------------+\n | Resource R1 |\n +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A COPY of /CollX with \"Depth: infinity\" to /CollY results in the following collection hierarchy:",
      "ja": "/collxのコピー「Depth：Infinity」から /Collyの結果、次のコレクション階層が得られます。"
    },
    {
      "indent": 18,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollX     CollY |\n+------------------+\n   |              \\\n   |               \\\n   |                \\\n+----------------+  +-----------------+\n| Collection C1  |  | Collection C2   |\n| bindings:      |  | bindings:       |\n| x.gif    y.gif |  | x.gif     y.gif |\n+----------------+  +-----------------+\n   |         |          |         |\n   |         |          |         |\n +-------------+      +-------------+\n | Resource R1 |      | Resource R2 |\n +-------------+      +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.4. DELETE and Bindings",
      "section_title": true,
      "ja": "2.4. 削除とバインディング"
    },
    {
      "indent": 3,
      "text": "When there are multiple bindings to a resource, a DELETE applied to that resource MUST NOT remove any bindings to that resource other than the one identified by the Request-URI. For example, suppose the collection identified by the URI \"/a\" has a binding named \"x\" to a resource R, and another collection identified by \"/b\" has a binding named \"y\" to the same resource R. Then, a DELETE applied to \"/a/x\" removes the binding named \"x\" from \"/a\" but MUST NOT remove the binding named \"y\" from \"/b\" (i.e., after the DELETE, \"/y/b\" continues to identify the resource R).",
      "ja": "リソースに複数のバインディングがある場合、そのリソースに適用される削除が、リクエスト-URIによって識別されたもの以外のリソースへのバインディングを削除してはなりません。たとえば、uri \"/a\"によって識別されたコレクションには、「x」という名前のバインディングがリソースrに、「/b」で識別された別のコレクションが同じリソースRに「y」という名前のバインディングがあるとします。「/a/x」に適用された削除は、「/a」から「x」という名前のバインディングを削除しますが、「/b」から「y」という名前のバインディングを削除してはなりません（つまり、削除、「/y/b」の後に削除してはなりません。リソースr）を識別し続けます。"
    },
    {
      "indent": 3,
      "text": "When DELETE is applied to a collection, it MUST NOT modify the membership of any other collection that is not itself a member of the collection being deleted. For example, if both \"/a/.../x\" and \"/b/.../y\" identify the same collection, C, then applying DELETE to \"/a\" must not delete an internal member from C or from any other collection that is a member of C, because that would modify the membership of \"/b\".",
      "ja": "削除がコレクションに適用される場合、それ自体が削除されているコレクションのメンバーではない他のコレクションのメンバーシップを変更してはなりません。たとえば、 \"/a /.../x\"と \"/b/.../y\"の両方が同じコレクションを識別する場合、cまたは \"に削除を適用しても、cまたはcまたはcまたはcまたは内部メンバーを削除してはなりません。Cのメンバーである他のコレクションから、「/b」のメンバーシップを変更するためです。"
    },
    {
      "indent": 3,
      "text": "If a collection supports the UNBIND method (see Section 5), a DELETE of an internal member of a collection MAY be implemented as an UNBIND request. In this case, applying DELETE to a Request-URI has the effect of removing the binding identified by the final segment of the Request-URI from the collection identified by the Request-URI minus its final segment. Although [RFC4918] allows a DELETE to be a non-atomic operation, when the DELETE operation is implemented as an UNBIND, the operation is atomic. In particular, a DELETE on a hierarchy of resources is simply the removal of a binding to the collection identified by the Request-URI.",
      "ja": "コレクションがUnbindメソッドをサポートする場合（セクション5を参照）、コレクションの内部メンバーの削除を非バインドリクエストとして実装できます。この場合、Request-URIにDeleteを適用すると、Request-URIが最終セグメントから識別されたコレクションからRequest-URIの最終セグメントによって識別されたバインディングを削除する効果があります。[RFC4918]は削除を非原子操作にすることを可能にしますが、削除操作がウンバインドとして実装されると、操作は原子です。特に、リソースの階層の削除は、単にリクエスト-URIによって識別されたコレクションへのバインディングの削除です。"
    },
    {
      "indent": 0,
      "text": "2.5. MOVE and Bindings",
      "section_title": true,
      "ja": "2.5. 移動してバインディングします"
    },
    {
      "indent": 3,
      "text": "When MOVE is applied to a resource, the other bindings to that resource MUST be unaffected; and if the resource being moved is a collection, the bindings to any members of that collection MUST be unaffected. Also, if MOVE is used with Overwrite:T to delete an existing resource, the constraints specified for DELETE apply.",
      "ja": "移動がリソースに適用される場合、そのリソースへの他のバインディングは影響を受けない必要があります。また、移動するリソースがコレクションである場合、そのコレクションのメンバーへのバインディングは影響を受けません。また、移動が上書きで使用される場合：t既存のリソースを削除するために、削除するために指定された制約が適用されます。"
    },
    {
      "indent": 3,
      "text": "If the destination collection of a MOVE request supports the REBIND method (see Section 6), a MOVE of a resource into that collection MAY be implemented as a REBIND request. Although [RFC4918] allows a MOVE to be a non-atomic operation, when the MOVE operation is implemented as a REBIND, the operation is atomic. In particular, applying a MOVE to a Request-URI and a Destination URI has the effect of removing a binding to a resource (at the Request-URI) and creating a new binding to that resource (at the Destination URI). Even when the Request-URI identifies a collection, the MOVE operation involves only removing one binding to that collection and adding another.",
      "ja": "移動要求の宛先コレクションがRebindメソッド（セクション6を参照）をサポートする場合、そのコレクションへのリソースの移動は、再生成要求として実装される場合があります。[RFC4918]は動きを非原子操作にすることを可能にしますが、移動操作が逆転として実装されると、操作は原子です。特に、リクエスト-URIと宛先URIへの移動を適用すると、リソースへのバインディング（リクエスト-URI）を削除し、そのリソース（宛先URI）への新しいバインディングを作成する効果があります。リクエスト-URIがコレクションを識別した場合でも、移動操作では、そのコレクションへの1つのバインディングを削除して別のコレクションを追加するだけです。"
    },
    {
      "indent": 0,
      "text": "2.5.1. Example: Simple MOVE",
      "section_title": true,
      "ja": "2.5.1. 例：単純な動き"
    },
    {
      "indent": 3,
      "text": "As an example, suppose that a MOVE is issued to URI-3 for resource R below (which is also mapped to URI-1 and URI-2), with the Destination header set to URI-X. After successful completion of the MOVE operation, a new binding has been created that creates the URI mapping between URI-X and resource R. The binding corresponding to the final segment of URI-3 has been removed, which also causes the URI mapping between URI-3 and R to be removed. If resource R were a collection, old URI-3-based mappings to members of R would have been removed, and new URI-X-based mappings to members of R would have been created.",
      "ja": "例として、宛先ヘッダーがURI-Xに設定された状態で、以下のリソースR（URI-1およびURI-2にマッピングされている）のURI-3に移動がURI-3に発行されたと仮定します。移動操作が正常に完了した後、URI-XとリソースRの間のURIマッピングを作成する新しいバインディングが作成されました。URI-3の最終セグメントに対応するバインディングが削除され、URI間のURIマッピングも引き起こします。-3およびrを削除します。リソースRがコレクションである場合、Rのメンバーへの古いURI-3ベースのマッピングが削除され、Rのメンバーへの新しいURI-Xベースのマッピングが作成されます。"
    },
    {
      "indent": 3,
      "text": ">> Before Request:",
      "ja": ">>リクエスト前："
    },
    {
      "indent": 15,
      "text": " URI-1   URI-2    URI-3\n   |       |        |\n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+\n|     Resource R      |\n+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> After Request:",
      "ja": ">>リクエスト後："
    },
    {
      "indent": 15,
      "text": " URI-1   URI-2    URI-X\n   |       |        |\n   |       |        |      <---- URI Mappings\n   |       |        |\n+---------------------+\n|     Resource R      |\n+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.5.2. Example: MOVE Request Causing a Bind Loop",
      "section_title": true,
      "ja": "2.5.2. 例：リクエストを移動して、バインドループを引き起こします"
    },
    {
      "indent": 3,
      "text": "Note that in the presence of collection bindings, a MOVE request can cause the creation of a bind loop.",
      "ja": "コレクションバインディングの存在下では、移動要求がバインドループの作成を引き起こす可能性があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Consider the top-level collections C1 and C2 with URIs \"/CollW/\" and \"/CollX/\". C1 also contains an additional binding named \"CollY\" to C2:",
      "ja": "uris \"/collw/\"および \"/collx/\"を使用したトップレベルのコレクションC1およびC2を考えてみましょう。C1には、C2への「Colly」という名前の追加のバインディングも含まれています。"
    },
    {
      "indent": 28,
      "text": "         +------------------+\n         | Root Collection  |\n         |  bindings:       |\n         |  CollW    CollX  |\n         +------------------+\n             |          |\n             |          |\n+------------------+    |\n| Collection C1    |    |\n|  bindings:       |    |\n|           CollY  |    |\n+------------------+    |\n             |          |\n             |          |\n         +------------------+\n         | Collection C2    |\n         |                  |\n         |                  |\n         +------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this case, the MOVE request below would cause a bind loop:",
      "ja": "この場合、以下の移動要求はバインドループを引き起こします。"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "MOVE /CollW HTTP/1.1 Host: example.com Destination: /CollX/CollZ If the request succeeded, the resulting state would be:",
      "ja": "move /collw http /1.1ホスト：example.com destination： /collx /collz要求が成功した場合、結果の状態は次のとおりです。"
    },
    {
      "indent": 21,
      "text": "                +------------------+\n                | Root Collection  |\n                |  bindings:       |\n                |           CollX  |\n                +------------------+\n                               |\n                               |\n       +------------------+    |\n       | Collection C1    |    |\n+----> |  bindings:       |    |\n|      |           CollY  |    |\n|      +------------------+    |\n|                   |          |\n|                   |          |\n|               +------------------+\n|               | Collection C2    |\n|               |  bindings:       |\n|               | CollZ            |\n|               +------------------+\n|                   |\n|                   |\n+-------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.6. PROPFIND and Bindings",
      "section_title": true,
      "ja": "2.6. プロップとバインディング"
    },
    {
      "indent": 3,
      "text": "Consistent with [RFC4918], the value of a dead property MUST be independent of the number of bindings to its host resource or of the path submitted to PROPFIND. On the other hand, the behavior for each live property depends on its individual definition (for example, see [RFC3744], Section 5, Paragraph 2 for a case where the value is independent of its path and bindings, and [RFC4918], Section 8.8 for a discussion about the live properties DAV:getetag and DAV: getlastmodified, which may behave differently).",
      "ja": "[RFC4918]と一致して、死んだプロパティの値は、ホストリソースまたはPropfindに提出されたパスのバインディングの数とは無関係でなければなりません。一方、各ライブプロパティの動作は、個々の定義に依存します（たとえば、[RFC3744]、セクション5、そのパスとバインディングに依存しない場合のパラグラフ2を参照、[RFC4918]、セクション8.8 Live Properties Davについての議論については、GetEtag and Dav：GetLastModified、これは異なる動作をするかもしれません）。"
    },
    {
      "indent": 0,
      "text": "2.7. Determining Whether Two Bindings Are to the Same Resource",
      "section_title": true,
      "ja": "2.7. 2つのバインディングが同じリソースにあるかどうかを判断します"
    },
    {
      "indent": 3,
      "text": "It is useful to have some way of determining whether two bindings are to the same resource. Two resources might have identical contents and properties, but not be the same resource (e.g., an update to one resource does not affect the other resource).",
      "ja": "2つのバインディングが同じリソースにあるかどうかを判断する方法があると便利です。2つのリソースには同じコンテンツとプロパティがある場合がありますが、同じリソースではありません（たとえば、1つのリソースの更新は他のリソースに影響しません）。"
    },
    {
      "indent": 3,
      "text": "The REQUIRED DAV:resource-id property defined in Section 3.1 is a resource identifier, which MUST be unique across all resources for all time. If the values of DAV:resource-id returned by PROPFIND requests through two bindings are identical character by character, the client can be assured that the two bindings are to the same resource.",
      "ja": "必要なDAV：セクション3.1で定義されているリソースIDプロパティはリソース識別子であり、これは常にすべてのリソースで一意でなければなりません。DAV：Resource-IDの値が2つのバインディングを介してPropfindリクエストによって返された場合、文字ごとに同じ文字である場合、クライアントは2つのバインディングが同じリソースにあることを保証できます。"
    },
    {
      "indent": 3,
      "text": "The DAV:resource-id property is created, and its value assigned, when the resource is created. The value of DAV:resource-id MUST NOT be changed. Even after the resource is no longer accessible through any URI, that value MUST NOT be reassigned to another resource's DAV: resource-id property.",
      "ja": "DAV：Resource-IDプロパティが作成され、リソースが作成されたときに割り当てられます。DAVの値：Resource-IDを変更してはなりません。リソースがURIを介してアクセスできない後でも、その値を別のリソースのDAVであるResource-IDプロパティに再割り当てしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Any method that creates a new resource MUST assign a new, unique value to its DAV:resource-id property. For example, a PUT applied to a null resource, COPY (when not overwriting an existing target) and CHECKIN (see [RFC3253], Section 4.4) must assign a new, unique value to the DAV:resource-id property of the new resource they create.",
      "ja": "新しいリソースを作成するすべての方法では、新しいユニークな値をそのDAV：Resource-IDプロパティに割り当てる必要があります。たとえば、ヌルリソースに適用されたプット、コピー（既存のターゲットを上書きしない場合）およびチェックイン（[RFC3253]、セクション4.4を参照）は、新しいリソースのDAV：Resource-IDプロパティに新しい一意の値を割り当てる必要があります。彼らは作成します。"
    },
    {
      "indent": 3,
      "text": "On the other hand, any method that affects an existing resource must not change the value of its DAV:resource-id property. Specifically, a PUT or a COPY that updates an existing resource must not change the value of its DAV:resource-id property. A REBIND, since it does not create a new resource, but only changes the location of an existing resource, must not change the value of the DAV:resource-id property.",
      "ja": "一方、既存のリソースに影響を与える方法は、DAVの価値を変更してはなりません。Resource-IDプロパティ。具体的には、既存のリソースを更新するプットまたはコピーは、DAVの値を変更してはなりません。Resource-IDプロパティ。新しいリソースを作成するのではなく、既存のリソースの場所を変更するだけであるため、DAV：Resource-IDプロパティの値を変更してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.8. Discovering the Bindings to a Resource",
      "section_title": true,
      "ja": "2.8. リソースへのバインディングを発見します"
    },
    {
      "indent": 3,
      "text": "An OPTIONAL DAV:parent-set property on a resource provides a list of the bindings that associate a collection and a URI segment with that resource. If the DAV:parent-set property exists on a given resource, it MUST contain a complete list of all bindings to that resource that the client is authorized to see. When deciding whether to support the DAV:parent-set property, server implementers / administrators should balance the benefits it provides against the cost of maintaining the property and the security risks enumerated in Sections 12.4 and 12.5.",
      "ja": "オプションのDAV：リソース上の親セットプロパティは、コレクションとURIセグメントをそのリソースに関連付けるバインディングのリストを提供します。DAV：Parent-Setプロパティが特定のリソースに存在する場合、クライアントが確認する権限を与えられているリソースのすべてのバインディングの完全なリストを含める必要があります。DAV：Parent-Setプロパティをサポートするかどうかを決定する場合、サーバーの実装者 /管理者は、プロパティを維持するコストとセクション12.4および12.5で列挙されているセキュリティリスクに対して提供する利点のバランスをとる必要があります。"
    },
    {
      "indent": 0,
      "text": "3. Properties",
      "section_title": true,
      "ja": "3. プロパティ"
    },
    {
      "indent": 3,
      "text": "The bind feature introduces the properties defined below.",
      "ja": "バインド機能は、以下に定義されているプロパティを紹介します。"
    },
    {
      "indent": 3,
      "text": "A DAV:allprop PROPFIND request SHOULD NOT return any of the properties defined by this document. This allows a binding server to perform efficiently when a naive client, which does not understand the cost of asking a server to compute all possible live properties, issues a DAV:allprop PROPFIND request.",
      "ja": "DAV：AllProp Propfindリクエストは、このドキュメントで定義されたプロパティのいずれを返さないでください。これにより、拘束力のあるサーバーは、可能なすべてのライブプロパティを計算するようサーバーに要求するコストを理解していないナイーブクライアントが、DAV：AllProp Propfindリクエストを発行する場合に効率的に実行できます。"
    },
    {
      "indent": 0,
      "text": "3.1. DAV:resource-id Property",
      "section_title": true,
      "ja": "3.1. DAV：Resource-IDプロパティ"
    },
    {
      "indent": 3,
      "text": "The DAV:resource-id property is a REQUIRED property that enables clients to determine whether two bindings are to the same resource. The value of DAV:resource-id is a URI, and may use any registered URI scheme that guarantees the uniqueness of the value across all resources for all time (e.g., the urn:uuid: URN namespace defined in [RFC4122] or the opaquelocktoken: URI scheme defined in [RFC4918]).",
      "ja": "DAV：Resource-IDプロパティは、クライアントが2つのバインディングが同じリソースにあるかどうかを判断できるようにする必要なプロパティです。DAVの値：Resource-IDはURIであり、すべてのリソースにわたって価値の一意性を保証する登録URIスキームを使用する場合があります（例：UUID：UUID：[RFC4122]またはOpquelockTokenで定義されています。：[RFC4918]で定義されたURIスキーム）。"
    },
    {
      "indent": 3,
      "text": "<!ELEMENT resource-id (href)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2. DAV:parent-set Property",
      "section_title": true,
      "ja": "3.2. DAV：親セットプロパティ"
    },
    {
      "indent": 3,
      "text": "The DAV:parent-set property is an OPTIONAL property that enables clients to discover what collections contain a binding to this resource (i.e., what collections have that resource as an internal member). It contains an href/segment pair for each collection that has a binding to the resource. The href identifies the collection, and the segment identifies the binding name of that resource in that collection.",
      "ja": "DAV：Parent-Setプロパティは、クライアントがこのリソースへのバインディングを含むコレクション（つまり、内部メンバーとしてそのリソースがあるコレクションを含むコレクションを発見できるようにするオプションのプロパティです。リソースにバインディングされた各コレクションのHREF/セグメントペアが含まれています。HREFはコレクションを識別し、セグメントはそのコレクションのそのリソースのバインディング名を識別します。"
    },
    {
      "indent": 3,
      "text": "A given collection MUST appear only once in the DAV:parent-set for any given binding, even if there are multiple URI mappings to that collection.",
      "ja": "特定のコレクションは、そのコレクションに複数のURIマッピングがある場合でも、DAV：任意のバインディングに対して親セットに1回だけ表示されなければなりません。"
    },
    {
      "indent": 3,
      "text": "<!ELEMENT parent-set (parent)*>\n<!ELEMENT parent (href, segment)>\n<!ELEMENT segment (#PCDATA)>\n<!-- PCDATA value: segment, as defined in Section 3.3 of\n     [RFC3986] -->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.2.1. Example for DAV:parent-set Property",
      "section_title": true,
      "ja": "3.2.1. DAVの例：親セットプロパティ"
    },
    {
      "indent": 3,
      "text": "For example, if collection C1 is mapped to both /CollX and /CollY, and C1 contains a binding named \"x.gif\" to a resource R1, then either [/CollX, x.gif] or [/CollY, x.gif] can appear in the DAV:parent-set of R1, but not both. But if C1 also had a binding named \"y.gif\" to R1, then there would be two entries for C1 in the DAV:parent-set of R1 (i.e., both [/CollX, x.gif] and [/CollX, y.gif] or, alternatively, both [/CollY, x.gif] and [/CollY, y.gif]).",
      "ja": "たとえば、C1が /collxと /collyの両方にマッピングされ、C1がリソースR1に「x.gif」という名前のバインディングが含まれている場合、[ /collx、x.gif]または[ /colly、x.gifのいずれかです。]は、DAV：R1の親セットに表示できますが、両方ではありません。しかし、C1がR1に「Y.GIF」という名前のバインディングも持っていた場合、DAVにはC1に2つのエントリがあります。Y.gif]または、あるいは、[/colly、x.gif]と[/colly、y.gif]の両方）。"
    },
    {
      "indent": 24,
      "text": "+-------------------------+\n| Root Collection         |\n|  bindings:              |\n|  CollX          CollY   |\n+-------------------------+\n    |            /\n    |           /\n    |          /\n+-----------------+\n| Collection C1   |\n| bindings:       |\n| x.gif    y.gif  |\n+-----------------+\n     |      |\n     |      |\n     |      |\n +-------------+\n | Resource R1 |\n +-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In this case, one possible value for the DAV:parent-set property on \"/CollX/x.gif\" would be:",
      "ja": "この場合、davの1つの可能な値：「/collx/x.gif」の親セットプロパティは次のとおりです。"
    },
    {
      "indent": 5,
      "text": "<parent-set xmlns=\"DAV:\">\n  <parent>\n    <href>/CollX</href>\n    <segment>x.gif</segment>\n  </parent>\n  <parent>\n    <href>/CollX</href>\n    <segment>y.gif</segment>\n  </parent>\n</parent-set>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. BIND Method",
      "section_title": true,
      "ja": "4. バインドメソッド"
    },
    {
      "indent": 3,
      "text": "The BIND method modifies the collection identified by the Request-URI, by adding a new binding from the segment specified in the BIND body to the resource identified in the BIND body.",
      "ja": "BINDメソッドは、バインド本体で指定されたセグメントからバインド本体で識別されたリソースに新しいバインディングを追加することにより、リクエスト-RIによって識別されたコレクションを変更します。"
    },
    {
      "indent": 3,
      "text": "If a server cannot guarantee the integrity of the binding, the BIND request MUST fail. Note that it is especially difficult to maintain the integrity of cross-server bindings. Unless the server where the resource resides knows about all bindings on all servers to that resource, it may unwittingly destroy the resource or make it inaccessible without notifying another server that manages a binding to the resource. For example, if server A permits the creation of a binding to a resource on server B, server A must notify server B about its binding and must have an agreement with B that B will not destroy the resource while A's binding exists. Otherwise, server B may receive a DELETE request that it thinks removes the last binding to the resource and destroy the resource while A's binding still exists. The precondition DAV:cross-server-binding is defined below for cases where servers fail cross-server BIND requests because they cannot guarantee the integrity of cross-server bindings.",
      "ja": "サーバーがバインディングの整合性を保証できない場合、バインド要求が失敗する必要があります。クロスサーバーバインディングの完全性を維持することは特に困難であることに注意してください。リソースが存在するサーバーがそのリソースのすべてのサーバー上のすべてのバインディングについて知っていない限り、リソースを無意識のうちに破壊するか、リソースへのバインディングを管理する別のサーバーに通知せずにアクセスできない場合があります。たとえば、サーバーAがサーバーB上のリソースへのバインディングの作成を許可する場合、サーバーAはそのバインディングについてサーバーBを通知する必要があり、Bとの合意が必要であり、BはAのバインディングが存在している間にリソースを破壊しないことです。それ以外の場合、サーバーBは、Aのバインディングがまだ存在している間にリソースへの最後のバインディングを削除し、リソースを破壊すると考える削除要求を受信する場合があります。Precondition DAV：サーバーバインディングは、サーバーがクロスサーバーバインディングの整合性を保証できないため、サーバーがクロスサーバーバインド要求に失敗する場合に以下に定義されています。"
    },
    {
      "indent": 3,
      "text": "By default, if there already is a binding for the specified segment in the collection, the new binding replaces the existing binding. This default binding replacement behavior can be overridden using the Overwrite header defined in Section 10.6 of [RFC4918].",
      "ja": "デフォルトでは、コレクションに指定されたセグメントのバインディングが既にある場合、新しいバインディングは既存のバインディングに置き換えられます。[RFC4918]のセクション10.6で定義されているオーバーライトヘッダーを使用して、このデフォルトの結合置換動作をオーバーライドできます。"
    },
    {
      "indent": 3,
      "text": "If a BIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "バインド要求が失敗した場合、リクエストの前のサーバー状態を復元する必要があります。この方法は安全ではなく、慣習性です（[RFC2616]、セクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request MAY include an Overwrite header.",
      "ja": "リクエストには、上書きヘッダーが含まれる場合があります。"
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:bind XML element.",
      "ja": "リクエスト本文は、XML要素をバインドするDAVでなければなりません。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT bind (segment, href)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "If the request succeeds, the server MUST return 201 (Created) when a new binding was created and 200 (OK) or 204 (No Content) when an existing binding was replaced.",
      "ja": "リクエストが成功した場合、サーバーは新しいバインディングが作成されたときに201（作成）を返す必要があり、既存のバインディングが交換されたときに200（OK）または204（コンテンツなし）が必要です。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:bind-response XML element. Note that this document does not define any elements for the BIND response body, but the DAV: bind-response element is defined to ensure interoperability between future extensions that do define elements for the BIND response body.",
      "ja": "リクエストを成功させるための応答本体が含まれている場合、それはdav：bind-response xml要素でなければなりません。このドキュメントは、BIND応答本体の要素を定義していませんが、DAV：BIND応答要素は、バインド応答ボディの要素を定義する将来の拡張機能間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT bind-response ANY>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:bind-into-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：Bind-Into-Collection）：リクエスト-URIはコレクションを特定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:bind-source-exists): The DAV:href element MUST identify a resource.",
      "ja": "（DAV：Bind-Source-Exists）：DAV：HREF要素はリソースを識別する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:binding-allowed): The resource identified by the DAV:href supports multiple bindings to it.",
      "ja": "（DAV：バインディングアロウ）：DAV：HREFによって識別されたリソースは、複数のバインディングをサポートしています。"
    },
    {
      "indent": 6,
      "text": "(DAV:cross-server-binding): If the resource identified by the DAV: href element in the request body is on another server from the collection identified by the Request-URI, the server MUST support cross-server bindings (servers that do not support cross-server bindings can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：Cross-Serverバインディング）：Request-URIによって識別されたコレクションの別のサーバーにDAV：HREF要素によって識別されたリソースがRequest-URIによって識別された場合、サーバーはクロスサーバーバインディング（サポートされていないクロスサーバーバインディングは、この条件コードを使用して、クライアントにリクエストが失敗した理由を正確に知らせることができます）。"
    },
    {
      "indent": 6,
      "text": "(DAV:name-allowed): The name specified by the DAV:segment is available for use as a new binding name.",
      "ja": "（dav：name-allowed）：DAV：セグメントで指定された名前は、新しいバインディング名として使用できます。"
    },
    {
      "indent": 6,
      "text": "(DAV:can-overwrite): If the collection already contains a binding with the specified path segment, and if an Overwrite header is included, the value of the Overwrite header MUST be \"T\".",
      "ja": "（DAV：Can-Overwrite）：コレクションに指定されたパスセグメントとのバインディングが既に含まれており、上書きヘッダーが含まれている場合、上書きヘッダーの値は「t」でなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:cycle-allowed): If the DAV:href element identifies a collection, and if the Request-URI identifies a collection that is a member of that collection, the server MUST support cycles in the URI namespace (servers that do not support cycles can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：Cycle-Allowed）：DAV：HREF要素がコレクションを識別し、リクエスト-URIがそのコレクションのメンバーであるコレクションを識別した場合、サーバーはURI Namespace（サポートしないサーバー）のサイクルをサポートする必要がありますサイクルは、この条件コードを使用して、クライアントにリクエストが失敗した理由を正確に知らせることができます）。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in an If request header.",
      "ja": "（DAV：ロックされたアップデートが許可されています）：リクエスト-URIによって識別されたコレクションが書き込みロックされている場合、適切なトークンをIFリクエストヘッダーで指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-overwrite-allowed): If the collection already contains a binding with the specified path segment, and if that binding is protected by a write lock, then the appropriate token MUST be specified in an If request header.",
      "ja": "（DAV：ロックされたオーバーワイトが許可）：コレクションに指定されたパスセグメントとのバインディングが既に含まれており、そのバインディングが書き込みロックによって保護されている場合、適切なトークンをIFリクエストヘッダーで指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:new-binding): The collection MUST have a binding that maps the segment specified in the DAV:segment element in the request body to the resource identified by the DAV:href element in the request body.",
      "ja": "（DAV：New Binding）：コレクションには、DAV：要求本体のセグメント要素で指定されたセグメントをマップするバインディングが必要です。"
    },
    {
      "indent": 0,
      "text": "4.1. Example: BIND",
      "section_title": true,
      "ja": "4.1. 例：バインド"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "BIND /CollY HTTP/1.1\nHost: www.example.com\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 172",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:bind xmlns:D=\"DAV:\">\n   <D:segment>bar.html</D:segment>\n   <D:href>http://www.example.com/CollX/foo.html</D:href>\n</D:bind>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created Location: http://www.example.com/CollY/bar.html",
      "ja": "http/1.1 201の作成場所：http：//www.example.com/colly/bar.html"
    },
    {
      "indent": 3,
      "text": "The server added a new binding to the collection, \"http://www.example.com/CollY\", associating \"bar.html\" with the resource identified by the URI \"http://www.example.com/CollX/foo.html\". Clients can now use the URI \"http://www.example.com/CollY/bar.html\" to submit requests to that resource.",
      "ja": "サーバーは、コレクションに新しいバインディングを追加しました。「http://www.example.com/colly」、「bar.html」をuri \"http://www.example.com/collx/によって識別されたリソースと関連付けますfoo.html \"。クライアントは、URI \"http://www.example.com/colly/bar.html\"を使用して、そのリソースにリクエストを送信できるようになりました。"
    },
    {
      "indent": 0,
      "text": "5. UNBIND Method",
      "section_title": true,
      "ja": "5. バインドメソッド"
    },
    {
      "indent": 3,
      "text": "The UNBIND method modifies the collection identified by the Request-URI by removing the binding identified by the segment specified in the UNBIND body.",
      "ja": "Unbindメソッドは、Unbind本体で指定されたセグメントによって識別されたバインディングを削除することにより、リクエスト-Riによって識別されたコレクションを変更します。"
    },
    {
      "indent": 3,
      "text": "Once a resource is unreachable by any URI mapping, the server MAY reclaim system resources associated with that resource. If UNBIND removes a binding to a resource, but there remain URI mappings to that resource, the server MUST NOT reclaim system resources associated with the resource.",
      "ja": "リソースがURIマッピングによって到達できなくなると、サーバーはそのリソースに関連付けられたシステムリソースを回収できます。Unbindがリソースへのバインディングを削除しているが、そのリソースにURIマッピングが残っている場合、サーバーはリソースに関連付けられたシステムリソースを回収してはなりません。"
    },
    {
      "indent": 3,
      "text": "If an UNBIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "バインドリクエストが失敗した場合、リクエストの前のサーバー状態を復元する必要があります。この方法は安全ではなく、慣習性です（[RFC2616]、セクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:unbind XML element.",
      "ja": "リクエスト本文は、DAV：Unbind XML要素でなければなりません。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT unbind (segment)> If the request succeeds, the server MUST return 200 (OK) or 204 (No Content) when the binding was successfully deleted.",
      "ja": "<！要素Unbind（セグメント）>リクエストが成功した場合、バインディングが正常に削除されたときにサーバーは200（OK）または204（コンテンツなし）を返す必要があります。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:unbind-response XML element. Note that this document does not define any elements for the UNBIND response body, but the DAV:unbind-response element is defined to ensure interoperability between future extensions that do define elements for the UNBIND response body.",
      "ja": "リクエストを成功させるための応答本体が含まれている場合、それはdav：unbind-response xml要素でなければなりません。このドキュメントは、非バインド応答本体の要素を定義していませんが、DAV：Unbind-Response要素は、Unbind応答ボディの要素を定義する将来の拡張機能間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT unbind-response ANY>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:unbind-from-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：bind-from-collection）：Request-uriはコレクションを特定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:unbind-source-exists): The DAV:segment element MUST identify a binding in the collection identified by the Request-URI.",
      "ja": "（DAV：Unbind-Source-Exists）：DAV：セグメント要素は、Request-URIによって識別されたコレクションのバインディングを識別する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロックされたアップデートが許可されています）：リクエスト-URIによって識別されたコレクションが書き込みロックされている場合、リクエストで適切なトークンを指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-url-deletion-allowed): If the binding identified by the segment is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：Protected-URL-DELITION-ALLOWED）：セグメントによって識別されたバインディングが書き込みロックによって保護されている場合、リクエストで適切なトークンを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:binding-deleted): The collection MUST NOT have a binding for the segment specified in the DAV:segment element in the request body.",
      "ja": "（DAV：バインディングデレート）：コレクションには、要求本体のDAV：セグメント要素で指定されたセグメントのバインディングが必要です。"
    },
    {
      "indent": 6,
      "text": "(DAV:lock-deleted): If the internal member URI of the binding specified by the Request-URI and the DAV:segment element in the request body was protected by a write lock at the time of the request, that write lock must have been deleted by the request.",
      "ja": "（DAV：ロックデレート）：リクエスト-URIおよびDAV：リクエスト本体のセグメント要素によって指定されたバインディングの内部メンバーURIが、リクエストの時点で書き込みロックによって保護されていた場合、その書き込みロックは持っていなければなりませんリクエストによって削除されました。"
    },
    {
      "indent": 0,
      "text": "5.1. Example: UNBIND",
      "section_title": true,
      "ja": "5.1. 例：バインド"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "UNBIND /CollX HTTP/1.1\nHost: www.example.com\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 117",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:unbind xmlns:D=\"DAV:\">\n   <D:segment>foo.html</D:segment>\n</D:unbind>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK",
      "ja": "HTTP/1.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The server removed the binding named \"foo.html\" from the collection, \"http://www.example.com/CollX\". A request to the resource named \"http://www.example.com/CollX/foo.html\" will return a 404 (Not Found) response.",
      "ja": "サーバーは、「foo.html」という名前のコレクション「http://www.example.com/collx」からバインディングを削除しました。「http://www.example.com/collx/foo.html」という名前のリソースへのリクエストは、404（見つからない）応答を返します。"
    },
    {
      "indent": 0,
      "text": "6. REBIND Method",
      "section_title": true,
      "ja": "6. Rebindメソッド"
    },
    {
      "indent": 3,
      "text": "The REBIND method removes a binding to a resource from a collection, and adds a binding to that resource into the collection identified by the Request-URI. The request body specifies the binding to be added (segment) and the old binding to be removed (href). It is effectively an atomic form of a MOVE request, and MUST be treated the same way as MOVE for the purpose of determining access permissions.",
      "ja": "Rebindメソッドは、コレクションからリソースへのバインディングを削除し、そのリソースへのバインディングをリクエストURIによって識別されたコレクションに追加します。要求本体は、追加するバインディング（セグメント）と除去する古いバインディング（HREF）を指定します。事実上、移動要求の原子形式であり、アクセス権限を決定する目的で移動と同じように扱う必要があります。"
    },
    {
      "indent": 3,
      "text": "If a REBIND request fails, the server state preceding the request MUST be restored. This method is unsafe and idempotent (see [RFC2616], Section 9.1).",
      "ja": "Rebind要求が失敗した場合、リクエストの前のサーバー状態を復元する必要があります。この方法は安全ではなく、慣習性です（[RFC2616]、セクション9.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Marshalling:",
      "ja": "マーシャリング："
    },
    {
      "indent": 6,
      "text": "The request MAY include an Overwrite header.",
      "ja": "リクエストには、上書きヘッダーが含まれる場合があります。"
    },
    {
      "indent": 6,
      "text": "The request body MUST be a DAV:rebind XML element.",
      "ja": "リクエスト本体はDAVでなければなりません：XML要素を逆転させます。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT rebind (segment, href)>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "If the request succeeds, the server MUST return 201 (Created) when a new binding was created and 200 (OK) or 204 (No Content) when an existing binding was replaced.",
      "ja": "リクエストが成功した場合、サーバーは新しいバインディングが作成されたときに201（作成）を返す必要があり、既存のバインディングが交換されたときに200（OK）または204（コンテンツなし）が必要です。"
    },
    {
      "indent": 6,
      "text": "If a response body for a successful request is included, it MUST be a DAV:rebind-response XML element. Note that this document does not define any elements for the REBIND response body, but the DAV:rebind-response element is defined to ensure interoperability between future extensions that do define elements for the REBIND response body.",
      "ja": "リクエストを成功させるための応答本体が含まれている場合、それはDAV：Rebind-Response XML要素でなければなりません。このドキュメントは、Rebind Responseボディの要素を定義していませんが、Dav：Rebind-Response要素は、Rebind Responseボディの要素を定義する将来の拡張機能間の相互運用性を確保するために定義されています。"
    },
    {
      "indent": 6,
      "text": "<!ELEMENT rebind-response ANY>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Preconditions:",
      "ja": "前提条件："
    },
    {
      "indent": 6,
      "text": "(DAV:rebind-into-collection): The Request-URI MUST identify a collection.",
      "ja": "（DAV：Rebind-Into-Collection）：リクエスト-URIはコレクションを特定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:rebind-source-exists): The DAV:href element MUST identify a resource.",
      "ja": "（DAV：Rebind-Source-Exists）：DAV：HREF要素はリソースを識別する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:cross-server-binding): If the resource identified by the DAV: href element in the request body is on another server from the collection identified by the Request-URI, the server MUST support cross-server bindings (servers that do not support cross-server bindings can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：Cross-Serverバインディング）：Request-URIによって識別されたコレクションの別のサーバーにDAV：HREF要素によって識別されたリソースがRequest-URIによって識別された場合、サーバーはクロスサーバーバインディング（サポートされていないクロスサーバーバインディングは、この条件コードを使用して、クライアントにリクエストが失敗した理由を正確に知らせることができます）。"
    },
    {
      "indent": 6,
      "text": "(DAV:name-allowed): The name specified by the DAV:segment is available for use as a new binding name.",
      "ja": "（dav：name-allowed）：DAV：セグメントで指定された名前は、新しいバインディング名として使用できます。"
    },
    {
      "indent": 6,
      "text": "(DAV:can-overwrite): If the collection already contains a binding with the specified path segment, and if an Overwrite header is included, the value of the Overwrite header MUST be \"T\".",
      "ja": "（DAV：Can-Overwrite）：コレクションに指定されたパスセグメントとのバインディングが既に含まれており、上書きヘッダーが含まれている場合、上書きヘッダーの値は「t」でなければなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:cycle-allowed): If the DAV:href element identifies a collection, and if the Request-URI identifies a collection that is a member of that collection, the server MUST support cycles in the URI namespace (servers that do not support cycles can use this condition code to signal the client exactly why the request failed).",
      "ja": "（DAV：Cycle-Allowed）：DAV：HREF要素がコレクションを識別し、リクエスト-URIがそのコレクションのメンバーであるコレクションを識別した場合、サーバーはURI Namespace（サポートしないサーバー）のサイクルをサポートする必要がありますサイクルは、この条件コードを使用して、クライアントにリクエストが失敗した理由を正確に知らせることができます）。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-update-allowed): If the collection identified by the Request-URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロックされたアップデートが許可されています）：リクエスト-URIによって識別されたコレクションが書き込みロックされている場合、リクエストで適切なトークンを指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-url-modification-allowed): If the collection identified by the Request-URI already contains a binding with the specified path segment, and if that binding is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：Protected-URL-Modification-Alowed）：リクエストURIによって識別されたコレクションには、指定されたパスセグメントとのバインディングが既に含まれている場合、その結合が書き込みロックによって保護されている場合、適切なトークンを指定する必要があります。リクエスト。"
    },
    {
      "indent": 6,
      "text": "(DAV:locked-source-collection-update-allowed): If the collection identified by the parent collection prefix of the DAV:href URI is write-locked, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：ロックソースコレクションアップデートが許可されています）：DAV：HREF URIの親コレクションのプレフィックスによって識別されたコレクションが書き込みロックされている場合、リクエストで適切なトークンを指定する必要があります。"
    },
    {
      "indent": 6,
      "text": "(DAV:protected-source-url-deletion-allowed): If the DAV:href URI is protected by a write lock, then the appropriate token MUST be specified in the request.",
      "ja": "（DAV：保護されたソース-URL-削除が許容）：DAV：HREF URIが書き込みロックによって保護されている場合、リクエストで適切なトークンを指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Postconditions:",
      "ja": "事後条件："
    },
    {
      "indent": 6,
      "text": "(DAV:new-binding): The collection MUST have a binding that maps the segment specified in the DAV:segment element in the request body, to the resource that was identified by the DAV:href element in the request body.",
      "ja": "（DAV：New Binding）：コレクションには、Request本体のDAV：セグメント要素で指定されたセグメントをマップするバインディングが必要です。"
    },
    {
      "indent": 6,
      "text": "(DAV:binding-deleted): The URL specified in the DAV:href element in the request body MUST NOT be mapped to a resource.",
      "ja": "（DAV：バインディングデレート）：要求本体のDAV：HREF要素で指定されたURLは、リソースにマッピングしてはなりません。"
    },
    {
      "indent": 6,
      "text": "(DAV:lock-deleted): If the URL specified in the DAV:href element in the request body was protected by a write lock at the time of the request, that write lock must have been deleted by the request.",
      "ja": "（DAV：ロックデレート）：リクエスト本体のDAV：HREF要素で指定されたURLが、リクエストの時点で書き込みロックによって保護されていた場合、その書き込みロックはリクエストによって削除されている必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1. Example: REBIND",
      "section_title": true,
      "ja": "6.1. 例：bind"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "REBIND /CollX HTTP/1.1\nHost: www.example.com\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 176",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:rebind xmlns:D=\"DAV:\">\n   <D:segment>foo.html</D:segment>\n   <D:href>http://www.example.com/CollY/bar.html</D:href>\n</D:rebind>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK",
      "ja": "HTTP/1.1 200 OK"
    },
    {
      "indent": 3,
      "text": "The server added a new binding to the collection, \"http://www.example.com/CollX\", associating \"foo.html\" with the resource identified by the URI \"http://www.example.com/CollY/bar.html\" and removes the binding named \"bar.html\" from the collection identified by the URI",
      "ja": "サーバーは、コレクションに新しいバインディングを追加しました。「http://www.example.com/collx」、「foo.html」をuri \"http://www.example.com/colly/によって識別されたリソースを「foo.html」と関連付けますbar.html \"\" uriによって識別されたコレクションから「bar.html」という名前のバインディングを削除します"
    },
    {
      "indent": 3,
      "text": "\"http://www.example.com/CollY\". Clients can now use the URI \"http://www.example.com/CollX/foo.html\" to submit requests to that resource, and requests on the URI \"http://www.example.com/CollY/bar.html\" will fail with a 404 (Not Found) response.",
      "ja": "「http://www.example.com/colly」。クライアントは、URI \"http://www.example.com/collx/foo.html\"を使用して、そのリソースにリクエストを送信できるようになりました。HTML \"は404（見つかりません）応答で失敗します。"
    },
    {
      "indent": 0,
      "text": "6.2. Example: REBIND in Presence of Locks and Bind Loops",
      "section_title": true,
      "ja": "6.2. 例：ロックとバインドループの存在下で塗り直します"
    },
    {
      "indent": 3,
      "text": "To illustrate the effects of locks and bind loops on a REBIND operation, consider the following collection:",
      "ja": "ロックとバインドループの再操作に対するバインドループの効果を説明するには、次のコレクションを検討してください。"
    },
    {
      "indent": 14,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollW           |\n+------------------+\n     |\n     |\n     |\n+-------------------------------+\n| Collection C1                 |<--------+\n| LOCKED infinity               |         |\n| (lock token L1)               |         |\n| bindings:                     |         |\n| CollX               CollY     |         |\n+-------------------------------+         |\n     |                  |                 |\n     |                  |  (creates loop) |\n     |                  |                 |\n+-----------------+  +------------------+ |\n| Collection C2   |  | Collection C3    | |\n| (inherit lock)  |  | (inherit lock)   | |\n| (lock token L1) |  | (lock token L1)  | |\n| bindings:       |  | bindings:        | |\n|  {none}         |  | y.gif     CollZ  | |\n+-----------------+  +------------------+ |\n                       |            |     |\n                       |            +-----+\n                       |\n                   +---------------------------+\n                   | Resource R2               |\n                   | (lock inherited from C1)  |\n                   | (lock token L1)           |\n                   +---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "(where L1 is \"urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9\").",
      "ja": "（ここで、L1は「urn：uuid：f92d4fae-7012-11ab-a765-00c0ca1f6bf9」です）。"
    },
    {
      "indent": 3,
      "text": "Note that the binding between CollZ and C1 creates a loop in the containment hierarchy. Servers are not required to support such loops, though the server in this example does.",
      "ja": "CollzとC1の間のバインディングは、封じ込め階層にループを作成することに注意してください。この例のサーバーはそうであるが、サーバーはそのようなループをサポートする必要はない。"
    },
    {
      "indent": 3,
      "text": "The REBIND request below will remove the segment \"CollZ\" from C3 and add a new binding from \"CollA\" to the collection C2.",
      "ja": "以下のRebindリクエストは、セグメント「Collz」をC3から削除し、「Colla」からCollection C2に新しいバインディングを追加します。"
    },
    {
      "indent": 3,
      "text": "REBIND /CollW/CollX HTTP/1.1\nHost: www.example.com\nIf: (<urn:uuid:f92d4fae-7012-11ab-a765-00c0ca1f6bf9>)\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 152",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?> <D:rebind xmlns:D=\"DAV:\"> <D:segment>CollA</D:segment> <D:href>/CollW/CollY/CollZ</D:href> </D:rebind> The outcome of the REBIND operation is:",
      "ja": "<？xml version = \"1.0\" encoding = \"utf-8\"？> <d：xmlns：d = \"dav：\"> <d：segment> colla </d：segment> <d：href>/collw/Colly/collz </d：href> </d：Rebind> Rebind操作の結果は次のとおりです。"
    },
    {
      "indent": 14,
      "text": "+------------------+\n| Root Collection  |\n|  bindings:       |\n|  CollW           |\n+------------------+\n     |\n     |\n     |\n+-------------------------------+\n| Collection C1                 |\n| LOCKED infinity               |\n| (lock token L1)               |\n| bindings:                     |\n| CollX                  CollY  |\n+-------------------------------+\n     |              ^      |\n     |              |      |\n+-----------------+ | +------------------+\n| Collection C2   | | | Collection C3    |\n|(inherited lock) | | | (inherited lock) |\n|(lock token L1)  | | | (lock token L1)  |\n| bindings:       | | | bindings:        |\n| CollA           | | | y.gif            |\n+-----------------+ | +------------------+\n    |               |    |\n    +---------------+    |\n     (creates loop)      |\n                   +---------------------------+\n                   | Resource R2               |\n                   | (inherited lock from C1)  |\n                   | (lock token L1)           |\n                   +---------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Additional Status Codes",
      "section_title": true,
      "ja": "7. 追加のステータスコード"
    },
    {
      "indent": 0,
      "text": "7.1. 208 Already Reported",
      "section_title": true,
      "ja": "7.1. 208はすでに報告されています"
    },
    {
      "indent": 3,
      "text": "The 208 (Already Reported) status code can be used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly. For each binding to a collection inside the request's scope, only one will be reported with a 200 status, while subsequent DAV:response elements for all other bindings will use the 208 status, and no DAV:response elements for their descendants are included.",
      "ja": "208（既に報告されている）ステータスコードは、DAV：PropStat応答要素内で使用できます。リクエストのスコープ内のコレクションへのバインディングごとに、200ステータスで報告されるのは1つだけで、その後のDAV：他のすべてのバインディングの応答要素は208ステータスを使用し、子孫のDAV：応答要素は含まれません。"
    },
    {
      "indent": 3,
      "text": "Note that the 208 status will only occur for \"Depth: infinity\" requests, and that it is of particular importance when the multiple collection bindings cause a bind loop as discussed in Section 2.2.",
      "ja": "208ステータスは「深さ：無限」要求に対してのみ発生し、セクション2.2で説明したように複数のコレクションバインディングがバインドループを引き起こす場合に特に重要であることに注意してください。"
    },
    {
      "indent": 3,
      "text": "A client can request the DAV:resource-id property in a PROPFIND request to guarantee that they can accurately reconstruct the binding structure of a collection with multiple bindings to a single resource.",
      "ja": "クライアントは、複数のバインディングを使用してコレクションのバインディング構造を単一のリソースに正確に再構築できることを保証するために、PropfindリクエストでDAV：Resource-IDプロパティを要求することができます。"
    },
    {
      "indent": 3,
      "text": "For backward compatibility with clients not aware of the 208 status code appearing in multistatus response bodies, it SHOULD NOT be used unless the client has signaled support for this specification using the \"DAV\" request header (see Section 8.2). Instead, a 508 status should be returned when a binding loop is discovered. This allows the server to return the 508 as the top-level return status, if it discovers it before it started the response, or in the middle of a multistatus, if it discovers it in the middle of streaming out a multistatus response.",
      "ja": "Multistatus Response Bodiesに表示される208ステータスコードを認識していないクライアントとの後方互換性の場合、クライアントが「DAV」要求ヘッダーを使用してこの仕様のサポートを信号していない限り、使用しないでください（セクション8.2を参照）。代わりに、バインディングループが発見されたときに508ステータスを返す必要があります。これにより、サーバーは、応答を開始する前に発見した場合、またはマルチスタスの中央でマルチスタス応答をストリーミングする中で発見した場合、508をトップレベルのリターンステータスとして返すことができます。"
    },
    {
      "indent": 0,
      "text": "7.1.1. Example: PROPFIND by Bind-Aware Client",
      "section_title": true,
      "ja": "7.1.1. 例：Bind-AwareクライアントによるPropfind"
    },
    {
      "indent": 3,
      "text": "For example, consider a PROPFIND request on /Coll (bound to collection C), where the members of /Coll are /Coll/Foo (bound to resource R) and /Coll/Bar (bound to collection C).",
      "ja": "たとえば、 /collのメンバーが /coll /foo（リソースrにバインド）および /coll /bar（コレクションCにバインド）である /coll（コレクションCにバインドされている）のプロパンドリクエストを検討してください。"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "PROPFIND /Coll/ HTTP/1.1\nHost: www.example.com\nDepth: infinity\nDAV: bind\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 152",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n  <D:prop>\n   <D:displayname/>\n   <D:resource-id/>\n  </D:prop>\n</D:propfind>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 207 Multi-Status\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 1241",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:multistatus xmlns:D=\"DAV:\">\n  <D:response>\n    <D:href>http://www.example.com/Coll/</D:href>\n    <D:propstat>\n      <D:prop>\n        <D:displayname>Loop Demo</D:displayname>\n        <D:resource-id>\n          <D:href\n>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>\n        </D:resource-id>\n      </D:prop>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n  </D:response>\n  <D:response>\n    <D:href>http://www.example.com/Coll/Foo</D:href>\n    <D:propstat>\n      <D:prop>\n        <D:displayname>Bird Inventory</D:displayname>\n        <D:resource-id>\n          <D:href\n>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf9</D:href>\n        </D:resource-id>\n      </D:prop>\n      <D:status>HTTP/1.1 200 OK</D:status>\n    </D:propstat>\n  </D:response>\n  <D:response>\n    <D:href>http://www.example.com/Coll/Bar</D:href>\n    <D:propstat>\n      <D:prop>\n        <D:displayname>Loop Demo</D:displayname>\n        <D:resource-id>\n          <D:href\n>urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf8</D:href>\n        </D:resource-id>\n      </D:prop>\n      <D:status>HTTP/1.1 208 Already Reported</D:status>\n    </D:propstat>\n  </D:response>\n</D:multistatus>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7.1.2. Example: PROPFIND by Non-Bind-Aware Client",
      "section_title": true,
      "ja": "7.1.2. 例：バインドされていないクライアントによる宣伝"
    },
    {
      "indent": 3,
      "text": "In this example, the client isn't aware of the 208 status code introduced by this specification. As the \"Depth: infinity\" PROPFIND request would cause a loop condition, the whole request is rejected with a 508 status.",
      "ja": "この例では、クライアントはこの仕様によって導入された208ステータスコードを認識していません。「深さ：Infinity」Propfindリクエストがループ条件を引き起こすため、要求全体が508ステータスで拒否されます。"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "PROPFIND /Coll/ HTTP/1.1\nHost: www.example.com\nDepth: infinity\nContent-Type: application/xml; charset=\"utf-8\"\nContent-Length: 125",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<D:propfind xmlns:D=\"DAV:\">\n   <D:prop> <D:displayname/> </D:prop>\n</D:propfind>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 508 Loop Detected",
      "ja": "HTTP/1.1 508ループが検出されました"
    },
    {
      "indent": 0,
      "text": "7.2. 508 Loop Detected",
      "section_title": true,
      "ja": "7.2. 508ループが検出されました"
    },
    {
      "indent": 3,
      "text": "The 508 (Loop Detected) status code indicates that the server terminated an operation because it encountered an infinite loop while processing a request with \"Depth: infinity\". This status indicates that the entire operation failed.",
      "ja": "508（ループが検出された）ステータスコードは、「深さ：無限」でリクエストを処理しながら無限ループに遭遇したため、サーバーが操作を終了したことを示します。このステータスは、操作全体が失敗したことを示しています。"
    },
    {
      "indent": 0,
      "text": "8. Capability Discovery",
      "section_title": true,
      "ja": "8. 能力の発見"
    },
    {
      "indent": 0,
      "text": "8.1. OPTIONS Method",
      "section_title": true,
      "ja": "8.1. オプション方法"
    },
    {
      "indent": 3,
      "text": "If the server supports bindings, it MUST return the compliance class name \"bind\" as a field in the \"DAV\" response header (see [RFC4918], Section 10.1) from an OPTIONS request on any resource implemented by that server. A value of \"bind\" in the \"DAV\" header MUST indicate that the server supports all MUST-level requirements and REQUIRED features specified in this document.",
      "ja": "サーバーがバインディングをサポートする場合、コンプライアンスクラス名「Bind」を「DAV」応答ヘッダー（[RFC4918]、セクション10.1を参照）のフィールドとして返す必要があります。「DAV」ヘッダーの「バインド」の値は、サーバーがこのドキュメントで指定されているすべての必須レベルの要件と必要な機能をサポートしていることを示す必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. 'DAV' Request Header",
      "section_title": true,
      "ja": "8.2. 「dav」要求ヘッダー"
    },
    {
      "indent": 3,
      "text": "Clients SHOULD signal support for all MUST-level requirements and REQUIRED features by submitting a \"DAV\" request header containing the compliance class name \"bind\". In particular, the client MUST understand the 208 status code defined in Section 7.1.",
      "ja": "クライアントは、コンプライアンスクラス名「バインド」を含む「DAV」要求ヘッダーを送信することにより、すべての必須レベルの要件と必要な機能のサポートを信号する必要があります。特に、クライアントはセクション7.1で定義されている208ステータスコードを理解する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Relationship to Locking in WebDAV",
      "section_title": true,
      "ja": "9. WebDavでのロックとの関係"
    },
    {
      "indent": 3,
      "text": "Locking is an optional feature of WebDAV ([RFC4918]). The base WebDAV specification and this protocol extension have been designed in parallel, making sure that all features of WebDAV can be implemented on a server that implements this protocol as well.",
      "ja": "ロックは、WebDAV（[RFC4918]）のオプション機能です。ベースWebDAV仕様とこのプロトコル拡張は並行して設計されており、WebDAVのすべての機能をこのプロトコルを実装するサーバーに実装できるようにしています。"
    },
    {
      "indent": 3,
      "text": "Unfortunately, WebDAV uses the term \"lock-root\" inconsistently. It is introduced in Section 6.1 of [RFC4918], point 2, as:",
      "ja": "残念ながら、WebDavは「ロックルート」という用語を一貫して使用しています。[RFC4918]のセクション6.1、ポイント2で紹介されています。"
    },
    {
      "indent": 6,
      "text": "2. A resource becomes directly locked when a LOCK request to a URL of that resource creates a new lock. The \"lock-root\" of the new lock is that URL. If at the time of the request, the URL is not mapped to a resource, a new empty resource is created and directly locked.",
      "ja": "2. そのリソースのURLへのロック要求が新しいロックを作成すると、リソースが直接ロックされます。新しいロックの「ロックルート」はそのURLです。リクエストの時点で、URLがリソースにマッピングされていない場合、新しい空のリソースが作成され、直接ロックされます。"
    },
    {
      "indent": 3,
      "text": "On the other hand, [RFC4918], Section 9.10.1 states:",
      "ja": "一方、[RFC4918]、セクション9.10.1は次のように述べています。"
    },
    {
      "indent": 6,
      "text": "A LOCK request to an existing resource will create a lock on the resource identified by the Request-URI, provided the resource is not already locked with a conflicting lock. The resource identified in the Request-URI becomes the root of the lock.",
      "ja": "既存のリソースへのロックリクエストは、リソースがまだ競合するロックでロックされていない場合、リクエスト-URIによって識別されるリソースにロックを作成します。リクエスト-URIで識別されたリソースは、ロックのルートになります。"
    },
    {
      "indent": 3,
      "text": "Servers that implement both WebDAV locking and support for multiple bindings MUST use the first interpretation: the lock-root is the URI through which the lock was created, not a resource. This URI, and potential aliases of this URI ([RFC4918], Section 5), are said to be \"protected\" by the lock.",
      "ja": "WebDAVロックと複数のバインディングのサポートの両方を実装するサーバーは、最初の解釈を使用する必要があります。ロックルートは、リソースではなく、ロックが作成されたURIです。このURI、およびこのURIの潜在的なエイリアス（[RFC4918]、セクション5）は、ロックによって「保護」されていると言われています。"
    },
    {
      "indent": 3,
      "text": "As defined in the introduction to Section 7 of [RFC4918], write operations that modify the state of a locked resource require that the lock token is submitted with the request. Consistent with WebDAV, the state of the resource consists of the content (\"any variant\"), dead properties, lockable live properties (item 1), plus, for a collection, all its bindings (item 2). Note that this, by definition, does not depend on the Request-URI to which the write operation is applied (the locked state is a property of the resource, not its URI).",
      "ja": "[RFC4918]のセクション7の概要で定義されているように、ロックされたリソースの状態を変更する操作を書き込み、ロックトークンがリクエストで送信される必要があります。WebDAVと一致して、リソースの状態は、コンテンツ（「任意のバリアント」）、デッドプロパティ、ロック可能なライブプロパティ（アイテム1）、さらにコレクションのすべてのバインディング（アイテム2）で構成されています。これは、定義上、書き込み操作が適用されるリクエストURIに依存していないことに注意してください（ロックされた状態は、そのURIではなくリソースのプロパティです）。"
    },
    {
      "indent": 3,
      "text": "However, the lock-root is the URI through which the lock was requested. Thus, the protection defined in item 3 of the list does not apply to additional URIs that may be mapped to the same resource due to the existence of multiple bindings.",
      "ja": "ただし、ロックルートは、ロックが要求されたURIです。したがって、リストの項目3で定義されている保護は、複数のバインディングの存在のために同じリソースにマッピングされる可能性のある追加のURIには適用されません。"
    },
    {
      "indent": 0,
      "text": "9.1. Example: Locking and Multiple Bindings",
      "section_title": true,
      "ja": "9.1. 例：ロックと複数のバインディング"
    },
    {
      "indent": 3,
      "text": "Consider a root collection \"/\", containing the two collections C1 and C2, named \"/CollX\" and \"/CollY\", and a child resource R, bound to C1 as \"/CollX/test\" and bound to C2 as \"/CollY/test\":",
      "ja": "「/collx」と「/colly」という名前の2つのコレクションC1とC2を含むルートコレクション「/」、およびC1に「/collx/test」としてc1にバインドされ、c2にバインドされた子どもリソースrを考えてみましょう。コリー/テスト \"："
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Root Collection         |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  | bindings:     |\n|     test      |  |     test      |\n+---------------+  +---------------+\n         |               |\n         |               |\n         |               |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Given a host name of \"www.example.com\", applying a depth-zero write lock to \"/CollX/test\" will lock the resource R, and the lock-root of this lock will be \"http://www.example.com/CollX/test\".",
      "ja": "「www.example.com」のホスト名が与えられると、「/collx/test」に深さゼロ書き込みロックを適用すると、リソースrがロックされ、このロックのロックルートは「http：// www」になります。Example.com/collx/test \"。"
    },
    {
      "indent": 3,
      "text": "Thus, the following operations will require that the associated lock token is submitted with the \"If\" request header ([RFC4918], Section 10.4):",
      "ja": "したがって、次の操作では、関連するロックトークンが「if」要求ヘッダー（[RFC4918]、セクション10.4）で送信される必要があります。"
    },
    {
      "indent": 3,
      "text": "o a PUT or PROPPATCH request modifying the content or lockable properties of resource R (as R is locked) -- no matter which URI is used as request target, and",
      "ja": "o リソースrのコンテンツまたはロック可能なプロパティを変更するプットまたはプロップパッチ要求（Rがロックされているとき） - どのURIが要求ターゲットとして使用されていても、"
    },
    {
      "indent": 3,
      "text": "o a MOVE, REBIND, UNBIND, or DELETE request causing \"/CollX/test\" not to be mapped to resource R anymore (be it addressed to \"/CollX\" or \"/CollX/test\").",
      "ja": "o 「/collx/test」がリソースrにマッピングされなくなった、「/collx/collx/test」にアドレス指定されないようにする「/collx/test」を引き起こすリクエストを削除する動き、削除、バインド、または削除。"
    },
    {
      "indent": 3,
      "text": "The following operations will not require submission of the lock token:",
      "ja": "次の操作では、ロックトークンの提出は必要ありません。"
    },
    {
      "indent": 3,
      "text": "o a DELETE request addressed to \"/CollY\" or \"/CollY/test\", as it does not affect the resource R, nor the lock-root,",
      "ja": "o リソースrやロックルートに影響しないため、「/colly」または「/colly/テスト」に宛てられた削除要求"
    },
    {
      "indent": 3,
      "text": "o for the same reason, an UNBIND request removing the binding \"test\" from collection C2, or the binding \"CollY\" from the root collection, and",
      "ja": "o 同じ理由で、コレクションC2からバインディング「テスト」、またはルートコレクションからのバインディング「Colly」を削除するバインドリクエスト、および"
    },
    {
      "indent": 3,
      "text": "o similarly, a MOVE or REBIND request causing \"/CollY/test\" not being mapped to resource R anymore.",
      "ja": "o 同様に、「/colly/test」を原因にする移動または再bindリクエストは、リソースRにマッピングされなくなりました。"
    },
    {
      "indent": 3,
      "text": "Note that despite the lock-root being \"http://www.example.com/CollX/test\", an UNLOCK request can be addressed through any URI mapped to resource R, as UNLOCK operates on the resource identified by the Request-URI, not that URI (see [RFC4918], Section 9.11).",
      "ja": "ロックルートは「http://www.example.com/collx/test」であるにもかかわらず、ロック解除がリクエスト-uriで識別されたリソースで動作するため、リソースRにマッピングされた任意のURIを介してロック解除リクエストに対処できることに注意してください。、そのURIではありません（[RFC4918]、セクション9.11を参照）。"
    },
    {
      "indent": 0,
      "text": "10. Relationship to WebDAV Access Control Protocol",
      "section_title": true,
      "ja": "10. WebDAVアクセス制御プロトコルとの関係"
    },
    {
      "indent": 3,
      "text": "Note that the WebDAV Access Control Protocol has been designed for compatibility with systems that allow multiple URIs to map to the same resource (see [RFC3744], Section 5):",
      "ja": "WebDAV Access Controlプロトコルは、複数のURIが同じリソースにマッピングできるシステムとの互換性のために設計されていることに注意してください（[RFC3744]、セクション5を参照）。"
    },
    {
      "indent": 6,
      "text": "Access control properties (especially DAV:acl and DAV:inherited-acl-set) are defined on the resource identified by the Request-URI of a PROPFIND request. A direct consequence is that if the resource is accessible via multiple URI, the value of access control properties is the same across these URI.",
      "ja": "アクセス制御プロパティ（特にDAV：ACLおよびDAV：継承ACL-SET）は、Propfind Requestのリクエスト-URIによって識別されたリソースで定義されます。直接的な結果は、複数のURIを介してリソースにアクセスできる場合、アクセス制御プロパティの値がこれらのURIで同じであることです。"
    },
    {
      "indent": 3,
      "text": "Furthermore, note that BIND and REBIND behave the same as MOVE with respect to the DAV:acl property (see [RFC3744], Section 7.3).",
      "ja": "さらに、Bind and Rebindは、DAV：ACLプロパティと同じように動作するのと同じように動作することに注意してください（[RFC3744]、セクション7.3を参照）。"
    },
    {
      "indent": 0,
      "text": "11. Relationship to Versioning Extensions to WebDAV",
      "section_title": true,
      "ja": "11. WebDavへのバージョン化拡張機能との関係"
    },
    {
      "indent": 3,
      "text": "Servers that implement Workspaces ([RFC3253], Section 6) and Version-Controlled Collections ([RFC3253], Section 14) already need to implement BIND-like behavior in order to handle UPDATE and UNCHECKOUT semantics.",
      "ja": "ワークスペース（[RFC3253]、セクション6）およびバージョン制御コレクション（[RFC3253]、セクション14）を実装するサーバーは、更新とチェックアウトのセマンティクスを処理するために、すでにバインド状の動作を実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Consider a workspace \"/ws1/\", containing the version-controlled, checked-out collections C1 and C2, named \"/ws1/CollX\" and \"/ws1/ CollY\", and a version-controlled resource R, bound to C1 as \"/ws1/ CollX/test\":",
      "ja": "「/ws1/collx」と「/ws1/colly」という名前のバージョン制御、チェックアウトコレクションC1およびC2、およびc1にバインドされたバージョン制御リソースrを含むワークスペース「/ws1/」を考えてみましょう。「/ws1/collx/test」："
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Workspace               |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  |               |\n|     test      |  |               |\n+---------------+  +---------------+\n         |\n         |\n         |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Moving \"/ws1/CollX/test\" into \"/ws1/CollY\", checking in C2, but undoing the checkout on C1 will undo part of the MOVE request, thus restoring the binding from C1 to R, but keeping the new binding from C2 to R:",
      "ja": "「/ws1/collx/テスト」を「/ws1/colly」に移動し、C2をチェックしますが、C1のチェックアウトを元に戻すと、移動要求の一部を元に戻すため、C1からRへのバインディングを復元しますが、新しいバインディングを維持します。C2からR："
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "MOVE /ws1/CollX/test HTTP/1.1 Host: www.example.com Destination: /ws1/CollY/test",
      "ja": "移動/WS1/COLLX/テストhttp/1.1ホスト：www.example.com宛先：/ws1/colly/test"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 204 No Content",
      "ja": "HTTP/1.1 204コンテンツなし"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "CHECKIN /ws1/CollY/ HTTP/1.1 Host: www.example.com",
      "ja": "checkin/ws1/colly/http/1.1ホスト：www.example.com"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 201 Created Cache-Control: no-cache Location: http://repo.example.com/his/17/ver/42",
      "ja": "http/1.1 201の作成キャッシュコントロールの作成：キャッシュなし場所：http：//repo.example.com/his/17/ver/42"
    },
    {
      "indent": 3,
      "text": ">> Request:",
      "ja": ">>リクエスト："
    },
    {
      "indent": 3,
      "text": "UNCHECKOUT /ws1/CollX/ HTTP/1.1 Host: www.example.com",
      "ja": "Uncheckout/ws1/collx/http/1.1ホスト：www.example.com"
    },
    {
      "indent": 3,
      "text": ">> Response:",
      "ja": ">>応答："
    },
    {
      "indent": 3,
      "text": "HTTP/1.1 200 OK Cache-Control: no-cache",
      "ja": "HTTP/1.1 200 OKキャッシュコントロール：ノーキャッシュ"
    },
    {
      "indent": 3,
      "text": "As a result, both C1 and C2 would have a binding to R:",
      "ja": "その結果、C1とC2の両方がRに結合します。"
    },
    {
      "indent": 20,
      "text": "     +-------------------------+\n     | Workspace               |\n     |  bindings:              |\n     |  CollX          CollY   |\n     +-------------------------+\n         |                |\n         |                |\n         |                |\n+---------------+  +---------------+\n| Collection C1 |  | Collection C2 |\n| bindings:     |  | bindings:     |\n|     test      |  |     test      |\n+---------------+  +---------------+\n         |                |\n         |                |\n         |                |\n        +------------------+\n        |    Resource R    |\n        +------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The MOVE semantics defined in Section 3.15 of [RFC3253] already require that \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will have the same version history (as exposed in the DAV:version-history property). Furthermore, the UNCHECKOUT semantics (which in this case is similar to UPDATE, see Section 14.11 of [RFC3253]) require:",
      "ja": "[RFC3253]のセクション3.15で定義されている動きセマンティクスは、「/WS1/COLLX/テスト」と「/WS1/Colly/テスト」に同じバージョンの履歴があることを既に要求しています（DAV：Version-History Propertyで公開されています）。さらに、Uncheckoutセマンティクス（この場合は更新に似ています。[RFC3253]のセクション14.11を参照）が必要です。"
    },
    {
      "indent": 6,
      "text": "If a new version-controlled member is in a workspace that already has a version-controlled resource for that version history, then the new version-controlled member MUST be just a binding (i.e., another name for) that existing version-controlled resource.",
      "ja": "新しいバージョン制御メンバーが、そのバージョン履歴のバージョン制御リソースを既に持っているワークスペースにある場合、新しいバージョン制御メンバーは、既存のバージョン制御リソースの単なるバインディング（つまり、別の名前）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Thus, \"/ws1/CollX/test\" and \"/ws1/CollY/test\" will be bindings to the same resource R, and have identical DAV:resource-id properties.",
      "ja": "したがって、「/ws1/collx/test」および「/ws1/colly/test」は同じリソースrにバインディングされ、同一のdav：resource-idプロパティがあります。"
    },
    {
      "indent": 0,
      "text": "12. Security Considerations",
      "section_title": true,
      "ja": "12. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "This section is provided to make WebDAV implementers aware of the security implications of this protocol.",
      "ja": "このセクションは、WebDAV実装者にこのプロトコルのセキュリティへの影響を認識させるために提供されます。"
    },
    {
      "indent": 3,
      "text": "All of the security considerations of HTTP/1.1 ([RFC2616], Section 15) and the WebDAV Distributed Authoring Protocol specification ([RFC4918], Section 20) also apply to this protocol specification. In addition, bindings introduce several new security concerns and increase the risk of some existing threats. These issues are detailed below.",
      "ja": "HTTP/1.1（[RFC2616]、セクション15）およびWebDAV分散オーサリングプロトコル仕様（[RFC4918]、セクション20）のセキュリティ上の考慮事項はすべて、このプロトコル仕様にも適用されます。さらに、Bindingはいくつかの新しいセキュリティ上の懸念を導入し、既存の脅威のリスクを高めます。これらの問題については、以下に詳しく説明しています。"
    },
    {
      "indent": 0,
      "text": "12.1. Privacy Concerns",
      "section_title": true,
      "ja": "12.1. プライバシーの問題"
    },
    {
      "indent": 3,
      "text": "In a context where cross-server bindings are supported, creating bindings on a trusted server may make it possible for a hostile agent to induce users to send private information to a target on a different server.",
      "ja": "クロスサーバーのバインディングがサポートされているコンテキストでは、信頼できるサーバーでバインディングを作成すると、敵対的なエージェントがユーザーに別のサーバーのターゲットに個人情報を送信するように誘導することが可能になります。"
    },
    {
      "indent": 0,
      "text": "12.2. Bind Loops",
      "section_title": true,
      "ja": "12.2. バインドループ"
    },
    {
      "indent": 3,
      "text": "Although bind loops were already possible in HTTP 1.1, the introduction of the BIND method creates a new avenue for clients to create loops accidentally or maliciously. If the binding and its target are on the same server, the server may be able to detect BIND requests that would create loops. Servers are required to detect loops that are caused by bindings to collections during the processing of any requests with \"Depth: infinity\".",
      "ja": "HTTP 1.1ではバインドループがすでに可能でしたが、BINDメソッドの導入により、クライアントが偶然または悪意を持ってループを作成するための新しい手段が作成されます。バインディングとそのターゲットが同じサーバー上にある場合、サーバーはループを作成するバインドリクエストを検出できる場合があります。サーバーは、「深さ：無限」のリクエストの処理中に、バインディングによって引き起こされるループを検出するために必要です。"
    },
    {
      "indent": 0,
      "text": "12.3. Bindings and Denial of Service",
      "section_title": true,
      "ja": "12.3. バインディングとサービスの拒否"
    },
    {
      "indent": 3,
      "text": "Denial-of-service attacks were already possible by posting URIs that were intended for limited use at heavily used Web sites. The introduction of BIND creates a new avenue for similar denial-of-service attacks. If cross-server bindings are supported, clients can now create bindings at heavily used sites to target locations that were not designed for heavy usage.",
      "ja": "サービス拒否攻撃は、頻繁に使用されるWebサイトでの使用が限られていることを目的としたURIを投稿することにより、すでに可能でした。Bindの導入は、同様のサービス拒否攻撃のための新しい道を作成します。クロスサーバーのバインディングがサポートされている場合、クライアントは、重い使用法のために設計されていない場所をターゲットにするために、重く使用されたサイトでバインディングを作成できるようになりました。"
    },
    {
      "indent": 0,
      "text": "12.4. Private Locations May Be Revealed",
      "section_title": true,
      "ja": "12.4. プライベートな場所が明らかになる場合があります"
    },
    {
      "indent": 3,
      "text": "If the DAV:parent-set property is maintained on a resource, the owners of the bindings risk revealing private locations. The directory structures where bindings are located are available to anyone who has access to the DAV:parent-set property on the resource. Moving a binding may reveal its new location to anyone with access to DAV:parent-set on its resource.",
      "ja": "DAV：Parent-Setプロパティがリソースに維持されている場合、バインディングの所有者がプライベートな場所を明らかにするリスクがあります。バインディングが配置されているディレクトリ構造は、RAV：リソース上の親セットプロパティにアクセスできる人なら誰でも利用できます。バインディングを移動すると、その新しい場所がDAVにアクセスできる人には、そのリソースの親セットが明らかになる可能性があります。"
    },
    {
      "indent": 0,
      "text": "12.5. DAV:parent-set and Denial of Service",
      "section_title": true,
      "ja": "12.5. DAV：親セットとサービス拒否"
    },
    {
      "indent": 3,
      "text": "If the server maintains the DAV:parent-set property in response to bindings created in other administrative domains, it is exposed to hostile attempts to make it devote resources to adding bindings to the list.",
      "ja": "サーバーが他の管理ドメインで作成されたバインディングに応じてDAV：Parent-Setプロパティを維持している場合、リストにバインディングを追加するためにリソースを専念させるための敵対的な試みにさらされます。"
    },
    {
      "indent": 0,
      "text": "13. Internationalization Considerations",
      "section_title": true,
      "ja": "13. 国際化の考慮事項"
    },
    {
      "indent": 3,
      "text": "All internationalization considerations mentioned in Section 19 of [RFC4918] also apply to this document.",
      "ja": "[RFC4918]のセクション19で言及されているすべての国際化に関する考慮事項も、この文書に適用されます。"
    },
    {
      "indent": 0,
      "text": "14. IANA Considerations",
      "section_title": true,
      "ja": "14. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "Section 7 defines the HTTP status codes 208 (Already Reported) and 508 (Loop Detected), which have been added to the HTTP Status Code Registry.",
      "ja": "セクション7では、HTTPステータスコードレジストリに追加されたHTTPステータスコード208（既に報告）および508（ループが検出されました）を定義しています。"
    },
    {
      "indent": 0,
      "text": "15. Acknowledgements",
      "section_title": true,
      "ja": "15. 謝辞"
    },
    {
      "indent": 3,
      "text": "This document is the collaborative product of the authors and Tyson Chihaya, Jim Davis, Chuck Fay and Judith Slein. It has benefited from thoughtful discussion by Jim Amsden, Peter Carlson, Steve Carter, Ken Coar, Ellis Cohen, Dan Connolly, Bruce Cragun, Cyrus Daboo, Spencer Dawkins, Mark Day, Werner Donne, Rajiv Dulepet, David Durand, Lisa Dusseault, Stefan Eissing, Roy Fielding, Yaron Goland, Joe Hildebrand, Fred Hitt, Alex Hopmann, James Hunt, Marcus Jager, Chris Kaler, Manoj Kasichainula, Rohit Khare, Brian Korver, Daniel LaLiberte, Steve Martin, Larry Masinter, Jeff McAffer, Alexey Melnikov, Surendra Koduru Reddy, Max Rible, Sam Ruby, Bradley Sergeant, Nick Shelness, John Stracke, John Tigue, John Turner, Kevin Wiggen, and other members of the concluded WebDAV working group.",
      "ja": "この文書は、著者とタイソン・チハヤ、ジム・デイビス、チャック・フェイ、ジュディス・スリーの共同製品です。ジム・アムスデン、ピーター・カールソン、スティーブ・カーター、ケン・コアー、エリス・コーエン、ダン・コノリー、ブルース・クラグン、サイラス・ダブー、スペンサー・ドーキンス、マーク・デイ、ワーナー・ドン、ラジブ・デュレペット、デビッド・デュランド、リサ・ドゥスー、ステファンアイシング、ロイ・フィールディング、ヤロン・ゴーランド、ジョー・ヒルデブランド、フレッド・ヒット、アレックス・ホップマン、ジェームズ・ハント、マーカス・ジェイガー、クリス・カラー、マノジ・カシチャイン、ロヒト・カレ、ブライアン・コルバー、ダニエル・ラリベル、スティーブ・マルティン、ラリー・マシン、ジェフ・マカファー、アレクシー・メルニコフ、Surendra Koduru Reddy、Max Rible、Sam Ruby、Bradley Sergeant、Nick Shelness、John Stracke、John Tigue、Johnターナー、Kevin Wiggen、および結論のあるWebdavワーキンググループの他のメンバー。"
    },
    {
      "indent": 0,
      "text": "16. References",
      "section_title": true,
      "ja": "16. 参考文献"
    },
    {
      "indent": 0,
      "text": "16.1. Normative References",
      "section_title": true,
      "ja": "16.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC2616] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.",
      "ja": "[RFC2616] Fielding、R.、Gettys、J.、Mogul、J.、Frystyk、H.、Masinter、L.、Leach、P。、およびT. Berners-Lee、「HyperText Transfer Protocol-HTTP/1.1」、RFC 2616、1999年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC3986] Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform Resource Identifier (URI): Generic Syntax\", STD 66, RFC 3986, January 2005.",
      "ja": "[RFC3986] Berners-Lee、T.、Fielding、R。、およびL. Masinter、「Uniform Resource Identifier（URI）：Generic Syntax」、Std 66、RFC 3986、2005年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC4918] Dusseault, L., Ed., \"HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)\", RFC 4918, June 2007.",
      "ja": "[RFC4918] Dusseault、L.、ed。、「Web分散オーサリングとバージョン（WebDAV）のHTTP拡張機能」、RFC 4918、2007年6月。"
    },
    {
      "indent": 3,
      "text": "[XML] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E., and F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fifth Edition)\", W3C REC-xml-20081126, November 2008, <http://www.w3.org/TR/2008/REC-xml-20081126/>.",
      "ja": "[XML] Bray、T.、Paoli、J.、Sperberg-Mcqueen、C.、Maler、E。、およびF. Yergeau、「拡張可能なマークアップ言語（XML）1.0（第5版）」、W3C REC-XML-20081126、2008年11月、<http://www.w3.org/tr/2008/rec-xml-20081126/>。"
    },
    {
      "indent": 0,
      "text": "16.2. Informative References",
      "section_title": true,
      "ja": "16.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC3253] Clemm, G., Amsden, J., Ellison, T., Kaler, C., and J. Whitehead, \"Versioning Extensions to WebDAV (Web Distributed Authoring and Versioning)\", RFC 3253, March 2002.",
      "ja": "[RFC3253] Clemm、G.、Amsden、J.、Ellison、T.、Kaler、C。、およびJ. Whitehead、「WebDavへのバージョン拡張機能（Web分散オーサリングとバージョン）」、RFC 3253、2002年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3744] Clemm, G., Reschke, J., Sedlar, E., and J. Whitehead, \"Web Distributed Authoring and Versioning (WebDAV) Access Control Protocol\", RFC 3744, May 2004.",
      "ja": "[RFC3744] Clemm、G.、Reschke、J.、Sedlar、E。、およびJ. Whitehead、「Web分散オーサリングおよびバージョン（WebDAV）アクセス制御プロトコル」、RFC 3744、2004年5月。"
    },
    {
      "indent": 3,
      "text": "[RFC4122] Leach, P., Mealling, M., and R. Salz, \"A Universally Unique IDentifier (UUID) URN Namespace\", RFC 4122, July 2005.",
      "ja": "[RFC4122] Leach、P.、Mealling、M。、およびR. Salz、「普遍的にユニークな識別子（UUID）URNネームスペース」、RFC 4122、2005年7月。"
    },
    {
      "indent": 0,
      "text": "Index",
      "ja": "索引"
    },
    {
      "indent": 3,
      "text": "2 208 Already Reported (status code) 31, 41",
      "ja": "2 208既に報告されている（ステータスコード）31、41"
    },
    {
      "indent": 3,
      "text": "5 508 Loop Detected (status code) 34, 41",
      "ja": "5 508ループ検出（ステータスコード）34、41"
    },
    {
      "indent": 3,
      "text": "B BIND method 21 Marshalling 22 Postconditions 23 Preconditions 22 Binding 6 Binding Integrity 6-7, 21",
      "ja": "bバインド方法21マーシャル22の事後条件23前提条件22バインディング6結合完全性6-7、21"
    },
    {
      "indent": 3,
      "text": "C Collection 6 Condition Names DAV:bind-into-collection (pre) 22 DAV:bind-source-exists (pre) 22 DAV:binding-allowed (pre) 23 DAV:binding-deleted (post) 25, 28 DAV:can-overwrite (pre) 23, 27 DAV:cross-server-binding (pre) 23, 27 DAV:cycle-allowed (pre) 23, 27 DAV:lock-deleted (post) 25, 28 DAV:locked-overwrite-allowed (pre) 23 DAV:locked-source-collection-update-allowed (pre) 28 DAV:locked-update-allowed (pre) 23, 25, 27 DAV:name-allowed (pre) 23, 27 DAV:new-binding (post) 23, 28 DAV:protected-source-url-deletion-allowed (pre) 28 DAV:protected-url-deletion-allowed (pre) 25 DAV:protected-url-modification-allowed (pre) 27 DAV:rebind-into-collection (pre) 27 DAV:rebind-source-exists (pre) 27 DAV:unbind-from-collection (pre) 25 DAV:unbind-source-exists (pre) 25",
      "ja": "cコレクション6条件名DAV：Bind-Into-Collection（Pre）22 Dav：Bind-Source-Exists（Pre）22 Dav：Binding-Allowed（Pre）23 Dav：Binding-Deleted（Post）25、28 Dav：Can Can-Write（Pre）23、27 Dav：Cross-Server Binding（Pre）23、27 Dav：Cycle-Allowed（Pre）23、27 Dav：Lock-Deleted（Post）25、28 Dav：Locked-Overwrite-Allowed（Pre）23 Dav：ロックソースコレクション-Update-Allowed（Pre）28 Dav：Locked-Update-Allowed（Pre）23、25、27 Dav：Name-Allowed（Pre）23、27 Dav：New Binding（POST）23、28 DAV：Protected-Source-URL-Deledion-Allowed（Pre）28 Dav：Protected-URL-Deledy-Allowed（Pre）25 DAV：Protected-URL-Modification-Allowed（Pre）27 DAV：Rebind-into-collection（pre）27 Dav：Rebind-Source-Exists（pre）27 Dav：Unbind-from-collection（pre）25 Dav：Unbind-Source-Exists（pre）25"
    },
    {
      "indent": 3,
      "text": "D DAV header compliance class 'bind' 34 DAV:bind-into-collection precondition 22 DAV:bind-source-exists precondition 22 DAV:binding-allowed precondition 23 DAV:binding-deleted postcondition 25, 28 DAV:can-overwrite precondition 23, 27 DAV:cross-server-binding precondition 23, 27 DAV:cycle-allowed precondition 23, 27 DAV:lock-deleted postcondition 25, 28 DAV:locked-overwrite-allowed precondition 23 DAV:locked-source-collection-update-allowed precondition 28 DAV:locked-update-allowed precondition 23, 25, 27 DAV:name-allowed precondition 23, 27 DAV:new-binding postcondition 23, 28 DAV:parent-set property 20 DAV:protected-source-url-deletion-allowed precondition 28 DAV:protected-url-deletion-allowed precondition 25 DAV:protected-url-modification-allowed precondition 27 DAV:rebind-into-collection precondition 27 DAV:rebind-source-exists precondition 27 DAV:resource-id property 19 DAV:unbind-from-collection precondition 25 DAV:unbind-source-exists precondition 25",
      "ja": "D DAVヘッダーコンプライアンスクラス「バインド」34 DAV：Bind-Into-Collection Precondition 22 Dav：Bind-Source-Exists Precondition 22 Dav：Binding-Allowed Precondition 23 Dav：Binding-Deleted Pustsontition 25、28 Dav：Can-Overwite Precondition 23、、27 DAV：クロスサーバーバインディングの前提条件23、27 DAV：サイクルアロー前処理23、27 DAV：ロックデレートポストコンディショナル25、28 DAV：ロックされたライトアラウド前条件23 DAV：ロックソースコレクションアップデート - 許可される前提条件28 Dav：ロックされたアップデートの前提条件23、25、27 Dav：名前が付いた前提条件23、27 Dav：新制限後のポストコンディショナル23、28 Dav：Parent-Set Property 20 Dav：Protected-Source-URL-DELETION-Alowed Precondition 28 Dav：Protected-URL-Delowed-Allowed Precondition 25 Dav：Protected-URL-Modification-Allowed Precondition 27 Dav：Rebind-Into-Collection Precondition 27 Dav：Rebind-Source-Exists Precondition 27 Dav：Resource-ID Property19 dav：bind-from-collection Precondition 25 Dav：Unbind-Source-Exists Precondition 25"
    },
    {
      "indent": 3,
      "text": "I Internal Member URI 6",
      "ja": "I内部メンバーURI 6"
    },
    {
      "indent": 3,
      "text": "L Locking 35",
      "ja": "Lロック35"
    },
    {
      "indent": 3,
      "text": "M Methods BIND 21 REBIND 26 UNBIND 24",
      "ja": "Mメソッドバインド21 Rebind 26 Unbind 24"
    },
    {
      "indent": 3,
      "text": "P Path Segment 5 Properties DAV:parent-set 20 DAV:resource-id 19",
      "ja": "Pパスセグメント5プロパティDAV：Parent-Set 20 Dav：Resource-ID 19"
    },
    {
      "indent": 3,
      "text": "R REBIND method 26 Marshalling 26 Postconditions 28 Preconditions 27",
      "ja": "R Rebind Method 26 Marshalling 26の事後条件28前提条件27"
    },
    {
      "indent": 3,
      "text": "S Status Codes 208 Already Reported 31, 41 508 Loop Detected 34, 41",
      "ja": "Sステータスコード208はすでに報告されている31、41 508ループが検出された34、41"
    },
    {
      "indent": 3,
      "text": "U UNBIND method 24 Marshalling 24 Postconditions 25 Preconditions 25 URI Mapping 5",
      "ja": "u Unbind Method 24 Marshalling 24のポストコンディショニング25前提条件25 URIマッピング5"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Geoffrey Clemm IBM 550 King Street Littleton, MA 01460",
      "ja": "Geoffrey Clemm IBM 550 King Street Littleton、MA 01460"
    },
    {
      "indent": 3,
      "text": "EMail: geoffrey.clemm@us.ibm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jason Crawford IBM Research P.O. Box 704 Yorktown Heights, NY 10598",
      "ja": "ジェイソンクロフォードIBM Research P.O.ボックス704ヨークタウンハイツ、ニューヨーク10598"
    },
    {
      "indent": 3,
      "text": "EMail: ccjason@us.ibm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Julian F. Reschke (editor) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 Germany",
      "ja": "Julian F. Reschke（編集者）Greenbytes Gmbh Hafenweg 16 Muenster、NW 48155ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: julian.reschke@greenbytes.de",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jim Whitehead UC Santa Cruz, Dept. of Computer Science 1156 High Street Santa Cruz, CA 95064",
      "ja": "ジムホワイトヘッドUCサンタクルーズ、コンピュータサイエンス部1156ハイストリートサンタクルス、カリフォルニア州95064"
    },
    {
      "indent": 3,
      "text": "EMail: ejw@cse.ucsc.edu",
      "raw": true,
      "ja": ""
    }
  ]
}