{
  "title": {
    "text": "RFC 6290 - A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)",
    "ja": "RFC 6290 - インターネットキーエクスチェンジプロトコル（IKE）のクイッククラッシュ検出方法"
  },
  "number": 6290,
  "created_at": "2022-12-16 09:17:11.834384+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       Y. Nir, Ed.\nRequest for Comments: 6290                                   Check Point\nCategory: Standards Track                                  D. Wierbowski\nISSN: 2070-1721                                                      IBM\n                                                             F. Detienne\n                                                                P. Sethi\n                                                                   Cisco\n                                                               June 2011",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "A Quick Crash Detection Method for the Internet Key Exchange Protocol (IKE)",
      "ja": "インターネットキーエクスチェンジプロトコル（IKE）のクイッククラッシュ検出方法"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes an extension to the Internet Key Exchange Protocol version 2 (IKEv2) that allows for faster detection of Security Association (SA) desynchronization using a saved token.",
      "ja": "このドキュメントでは、保存されたトークンを使用したセキュリティ協会（SA）の非同期化をより迅速に検出できるようにするインターネットキーエクスチェンジプロトコルバージョン2（IKEV2）への拡張について説明します。"
    },
    {
      "indent": 3,
      "text": "When an IPsec tunnel between two IKEv2 peers is disconnected due to a restart of one peer, it can take as much as several minutes for the other peer to discover that the reboot has occurred, thus delaying recovery. In this text, we propose an extension to the protocol that allows for recovery immediately following the restart.",
      "ja": "1つのピアの再起動のために2つのIKEV2ピアの間のIPSECトンネルが切断されると、他のピアが再起動が発生したことを発見するのに数分もかかる可能性があり、回復が遅れます。このテキストでは、再起動後すぐに回復できるプロトコルへの拡張を提案します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 5741.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 5741のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6290.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc6290で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2011 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Conventions Used in This Document  . . . . . . . . . . . .  3\n2.  RFC 5996 Crash Recovery  . . . . . . . . . . . . . . . . . . .  4\n3.  Protocol Outline . . . . . . . . . . . . . . . . . . . . . . .  5\n4.  Formats and Exchanges  . . . . . . . . . . . . . . . . . . . .  6\n  4.1.  Notification Format  . . . . . . . . . . . . . . . . . . .  6\n  4.2.  Passing a Token in the AUTH Exchange . . . . . . . . . . .  7\n  4.3.  Replacing Tokens after Rekey or Resumption . . . . . . . .  8\n  4.4.  Replacing the Token for an Existing SA . . . . . . . . . .  9\n  4.5.  Presenting the Token in an Unprotected Message . . . . . .  9\n5.  Token Generation and Verification  . . . . . . . . . . . . . . 10\n  5.1.  A Stateless Method of Token Generation . . . . . . . . . . 11\n  5.2.  A Stateless Method with IP Addresses . . . . . . . . . . . 11\n  5.3.  Token Lifetime . . . . . . . . . . . . . . . . . . . . . . 12\n6.  Backup Gateways  . . . . . . . . . . . . . . . . . . . . . . . 12\n7.  Interaction with Session Resumption  . . . . . . . . . . . . . 13\n8.  Operational Considerations . . . . . . . . . . . . . . . . . . 14\n  8.1.  Who Should Implement This Specification  . . . . . . . . . 14\n  8.2.  Response to Unknown Child SPI  . . . . . . . . . . . . . . 15\n9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 16\n  9.1.  QCD Token Generation and Handling  . . . . . . . . . . . . 16\n  9.2.  QCD Token Transmission . . . . . . . . . . . . . . . . . . 17\n  9.3.  QCD Token Enumeration  . . . . . . . . . . . . . . . . . . 18\n10. IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 18\n11. Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 18\n12. References . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n  12.1. Normative References . . . . . . . . . . . . . . . . . . . 19\n  12.2. Informative References . . . . . . . . . . . . . . . . . . 19\nAppendix A.  The Path Not Taken  . . . . . . . . . . . . . . . . . 20\n  A.1.  Initiating a New IKE SA  . . . . . . . . . . . . . . . . . 20\n  A.2.  SIR  . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n  A.3.  Birth Certificates . . . . . . . . . . . . . . . . . . . . 20\n  A.4.  Reducing Liveness Check Length . . . . . . . . . . . . . . 21",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "IKEv2, as described in [RFC5996] and its predecessor RFC 4306, has a method for recovering from a reboot of one peer. As long as traffic flows in both directions, the rebooted peer should re-establish the tunnels immediately. However, in many cases, the rebooted peer is a VPN gateway that protects only servers, so all traffic is inbound. In other cases, the non-rebooted peer has a dynamic IP address, so the rebooted peer cannot initiate IKE because its current IP address is unknown. In such cases, the rebooted peer will not be able to re-establish the tunnels. Section 2 describes how recovery works under RFC 5996, and explains why it may take several minutes.",
      "ja": "[RFC5996]とその前身RFC 4306で説明されているように、IKEV2には、1つのピアの再起動から回復する方法があります。トラフィックが両方向に流れる限り、再起動されたピアはすぐにトンネルを再確立するはずです。ただし、多くの場合、再起動されたピアはサーバーのみを保護するVPNゲートウェイであるため、すべてのトラフィックがインバウンドです。それ以外の場合、再弾丸のピアには動的なIPアドレスがあるため、現在のIPアドレスが不明であるため、再起動されたピアはIKEを開始できません。そのような場合、再起動されたピアはトンネルを再確立することができません。セクション2では、RFC 5996の下での回復の仕組みについて説明し、数分かかる理由について説明します。"
    },
    {
      "indent": 3,
      "text": "The method proposed here is to send an octet string, called a \"QCD token\", in the IKE_AUTH exchange that establishes the tunnel. That token can be stored on the peer as part of the IKE SA. After a reboot, the rebooted implementation can re-generate the token and send it to the peer, so as to delete the IKE SA. Deleting the IKE SA results in a quick establishment of new IPsec tunnels. This is described in Section 3.",
      "ja": "ここで提案されている方法は、トンネルを確立するIKE_AUTH Exchangeで、「QCDトークン」と呼ばれるOctet Stringを送信することです。そのトークンは、IKE SAの一部としてピアに保存できます。再起動した後、再起動した実装は、トークンを再発生してピアに送信して、IKE SAを削除することができます。IKE SAを削除すると、新しいIPSECトンネルが迅速に確立されます。これはセクション3で説明されています。"
    },
    {
      "indent": 0,
      "text": "1.1. Conventions Used in This Document",
      "section_title": true,
      "ja": "1.1. このドキュメントで使用されている規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in [RFC2119].",
      "ja": "「必須」、「そうしない」、「必須」、「必要」、「しない」、「そうしない」、「そうではない」、「そうでない」、「推奨」、「5月」、および「オプション」は、[RFC2119]に記載されているように解釈される。"
    },
    {
      "indent": 3,
      "text": "The term \"token\" refers to an octet string that an implementation can generate using only the properties of a protected IKE message (such as IKE Security Parameter Indexes (SPIs)) as input. A conforming implementation MUST be able to generate the same token from the same input even after rebooting.",
      "ja": "「トークン」という用語は、入力として保護されたIKEメッセージ（IKEセキュリティパラメーターインデックス（SPI）など）のプロパティのみを使用して実装が生成できるオクテット文字列を指します。適合実装は、再起動後でも同じ入力から同じトークンを生成できる必要があります。"
    },
    {
      "indent": 3,
      "text": "The term \"token maker\" refers to an implementation that generates a token and sends it to the peer as specified in this document.",
      "ja": "「トークンメーカー」という用語は、トークンを生成し、このドキュメントで指定されているようにピアに送信する実装を指します。"
    },
    {
      "indent": 3,
      "text": "The term \"token taker\" refers to an implementation that stores such a token or a digest thereof, in order to verify that a new token it receives is identical to the old token it has stored.",
      "ja": "「トークンテイカー」という用語は、そのようなトークンまたはそのダイジェストを保存する実装を指します。"
    },
    {
      "indent": 3,
      "text": "The term \"non-volatile storage\" in this document refers to a data storage module that persists across restarts of the token maker. Examples of such a storage module include an internal disk, an internal flash memory module, an external disk, and an external database. A small non-volatile storage module is required for a token maker, but a larger one can be used to enhance performance, as described in Section 8.2.",
      "ja": "このドキュメントの「不揮発性ストレージ」という用語は、トークンメーカーの再起動全体で持続するデータストレージモジュールを指します。このようなストレージモジュールの例には、内部ディスク、内部フラッシュメモリモジュール、外部ディスク、および外部データベースが含まれます。トークンメーカーには小さな不揮発性ストレージモジュールが必要ですが、セクション8.2で説明されているように、パフォーマンスを向上させるために、より大きなものを使用できます。"
    },
    {
      "indent": 0,
      "text": "2. RFC 5996 Crash Recovery",
      "section_title": true,
      "ja": "2. RFC 5996クラッシュ回復"
    },
    {
      "indent": 3,
      "text": "When one peer loses state or reboots, the other peer does not get any notification, so unidirectional IPsec traffic can still flow. The rebooted peer will not be able to decrypt it, however, and the only remedy is to send an unprotected INVALID_SPI notification as described in Section 3.10.1 of [RFC5996]. That section also describes the processing of such a notification:",
      "ja": "1つのピアが状態または再起動を失うと、もう1つのピアが通知を受け取らないため、単方向のIPSECトラフィックは引き続き流れる可能性があります。ただし、再起動されたピアはそれを復号化することはできません。唯一の救済策は、[RFC5996]のセクション3.10.1で説明されているように、保護されていない無効な_SPI通知を送信することです。そのセクションでは、そのような通知の処理についても説明します。"
    },
    {
      "indent": 6,
      "text": "If this Informational Message is sent outside the context of an IKE_SA, it should be used by the recipient only as a \"hint\" that something might be wrong (because it could easily be forged).",
      "ja": "この情報メッセージがIKE_SAのコンテキストの外で送信される場合、受信者は何かが間違っている可能性があるという「ヒント」としてのみ使用する必要があります（簡単に偽造できるため）。"
    },
    {
      "indent": 3,
      "text": "Since the INVALID_SPI can only be used as a hint, the non-rebooted peer has to determine whether the IPsec SA and indeed the parent IKE SA are still valid. The method of doing this is described in Section 2.4 of [RFC5996]. This method, called \"liveness check\", involves sending a protected empty INFORMATIONAL message, and awaiting a response. This procedure is sometimes referred to as \"Dead Peer Detection\" or DPD.",
      "ja": "Invalid_spiはヒントとしてのみ使用できるため、非再開のピアは、IPSEC SAと実際に親IKE SAがまだ有効かどうかを判断する必要があります。これを行う方法は、[RFC5996]のセクション2.4で説明されています。「livesing Check」と呼ばれるこの方法では、保護された空の情報メッセージを送信し、応答を待ちます。この手順は、「デッドピア検出」またはDPDと呼ばれることもあります。"
    },
    {
      "indent": 3,
      "text": "Section 2.4 does not mandate how many times the liveness check message should be retransmitted, or for how long, but does recommend the following:",
      "ja": "セクション2.4では、livenessチェックメッセージを再送信する回数、またはどのくらいの期間を義務付けていませんが、以下を推奨しています。"
    },
    {
      "indent": 6,
      "text": "It is suggested that messages be retransmitted at least a dozen times over a period of at least several minutes before giving up on an SA...",
      "ja": "SAをあきらめる前に、少なくとも数分間にわたって少なくとも数十回メッセージを再送信することが提案されています..."
    },
    {
      "indent": 3,
      "text": "Those \"at least several minutes\" are a time during part of which both peers are active, but IPsec cannot be used.",
      "ja": "これらの「少なくとも数分」は、両方のピアがアクティブな時期ですが、IPSECは使用できません。"
    },
    {
      "indent": 3,
      "text": "Especially in the case of a reboot (rather than fail-over or administrative clearing of state), the peer does not recover immediately. Reboot, depending on the system, may take from a few seconds to a few minutes. This means that at first the peer just goes silent, i.e., does not send or respond to any messages. IKEv2 implementations can detect this situation and follow the rules given in Section 2.4:",
      "ja": "特に、再起動の場合（州のフェールオーバーまたは管理上の清算ではなく）、ピアはすぐに回復しません。再起動は、システムに応じて、数秒から数分かかる場合があります。これは、最初はピアが沈黙していること、つまりメッセージを送信または応答しないことを意味します。IKEV2の実装は、この状況を検出し、セクション2.4に記載されているルールに従うことができます。"
    },
    {
      "indent": 6,
      "text": "If there has only been outgoing traffic on all of the SAs associated with an IKE SA, it is essential to confirm liveness of the other endpoint to avoid black holes. If no cryptographically protected messages have been received on an IKE SA or any of its Child SAs recently, the system needs to perform a liveness check in order to prevent sending messages to a dead peer.",
      "ja": "IKE SAに関連付けられたすべてのSASに発信トラフィックしかなかった場合、ブラックホールを避けるために他のエンドポイントの活性を確認することが不可欠です。最近、IKE SAまたはその子SASの暗号化されたメッセージを受信していない場合、システムは、デッドピアにメッセージを送信するのを防ぐために、活性チェックを実行する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] does not mandate any time limits, but it is possible that the peer will start liveness checks even before the other end is sending INVALID_SPI notification, as it detected that the other end is not sending any packets anymore while it is still rebooting or recovering from the situation.",
      "ja": "[RFC5996]は時間制限を義務付けていませんが、反対側が再起動または再起動中にパケットを送信しなくなっていることを検出したため、他の端がInvalid_Spi通知を送信する前に、ピアが快適なチェックを開始する可能性があります。状況から回復します。"
    },
    {
      "indent": 3,
      "text": "This means that the several minutes recovery period is overlapping the actual recover time of the other peer; i.e., if the security gateway requires several minutes to boot up from the crash, then the other peers have already finished their liveness checks before the crashing peer even has a chance to send INVALID_SPI notifications.",
      "ja": "これは、数分の回復期間が他のピアの実際の回復時間と重複していることを意味します。つまり、セキュリティゲートウェイがクラッシュから起動するために数分を必要とする場合、他のピアは、クラッシュするピアがInvalID_SPI通知を送信する機会さえある前に、すでに活気のチェックを終了しています。"
    },
    {
      "indent": 3,
      "text": "There are cases where the peer loses state and is able to recover immediately; in those cases it might take several minutes to recreate the IPsec SAs.",
      "ja": "ピアが状態を失い、すぐに回復できる場合があります。そのような場合、IPSEC SASを再現するには数分かかる場合があります。"
    },
    {
      "indent": 3,
      "text": "Note that the IKEv2 specification specifically gives no guidance for the number of retries or the length of timeouts, as these do not affect interoperability. This means that implementations are allowed to use the hints provided by the INVALID_SPI messages to shorten those timeouts (i.e., a different environment and situation requiring different rules).",
      "ja": "IKEV2仕様は、相互運用性に影響を与えないため、RETRIERの数またはタイムアウトの長さのガイダンスを特に提供しないことに注意してください。これは、実装がInvalID_SPIメッセージによって提供されるヒントを使用して、それらのタイムアウトを短縮することが許可されていることを意味します（つまり、異なるルールを必要とする異なる環境と状況）。"
    },
    {
      "indent": 3,
      "text": "Some existing IKEv2 implementations already do that (i.e., shorten timeouts or limit number of retries) based on these kinds of hints and also start liveness checks quickly after the other end goes silent. However, see Appendix A.4 for a discussion of why this may not be enough.",
      "ja": "既存のIKEV2実装の中には、これらの種類のヒントに基づいて既にそれを行っています（つまり、タイムアウトを短縮するか、レトリの数を制限します）。ただし、なぜこれで十分でない可能性があるのかについての議論については、付録A.4を参照してください。"
    },
    {
      "indent": 0,
      "text": "3. Protocol Outline",
      "section_title": true,
      "ja": "3. プロトコルの概要"
    },
    {
      "indent": 3,
      "text": "Supporting implementations will send a notification, called a \"QCD token\", as described in Section 4.1 in the first IKE_AUTH exchange messages. These are the first IKE_AUTH request and final IKE_AUTH response that contain the AUTH payloads. The generation of these tokens is a local matter for implementations, but considerations are described in Section 5. Implementations that send such a token will be called \"token makers\".",
      "ja": "実装をサポートすると、最初のIKE_AUTH Exchangeメッセージのセクション4.1で説明されているように、「QCDトークン」と呼ばれる通知が送信されます。これらは、認証ペイロードを含む最初のIKE_AUTHリクエストと最終的なIKE_AUTH応答です。これらのトークンの生成は実装のためのローカルな問題ですが、考慮事項はセクション5で説明されています。そのようなトークンを送信する実装は「トークンメーカー」と呼ばれます。"
    },
    {
      "indent": 3,
      "text": "A supporting implementation receiving such a token MUST store it (or a digest thereof) along with the IKE SA. Implementations that support this part of the protocol will be called \"token takers\". Section 8.1 has considerations for which implementations need to be token takers, and which should be token makers. Implementations that are not token takers will silently ignore QCD tokens.",
      "ja": "このようなトークンを受け取るサポート実装では、IKE SAとともにそれを保存（またはそのダイジェスト）が保存する必要があります。プロトコルのこの部分をサポートする実装は、「トークンテイカー」と呼ばれます。セクション8.1には、どの実装がトークンテイカーである必要があり、どの実装がトークンメーカーである必要があるかについての考慮事項があります。トークンテイカーではない実装は、QCDトークンを静かに無視します。"
    },
    {
      "indent": 3,
      "text": "When a token maker receives a protected IKE request message with unknown IKE SPIs, it SHOULD generate a new token that is identical to the previous token, and send it to the requesting peer in an unprotected IKE message as described in Section 4.5.",
      "ja": "トークンメーカーが未知のIKEスピスを使用して保護されたIKE要求メッセージを受信すると、前のトークンと同一の新しいトークンを生成し、セクション4.5で説明した保護されていないIKEメッセージでリクエストピアに送信します。"
    },
    {
      "indent": 3,
      "text": "When a token taker receives the QCD token in an unprotected notification, it MUST verify that the TOKEN_SECRET_DATA matches the token stored with the matching IKE SA. If the verification fails, or if the IKE SPIs in the message do not match any existing IKE SA, it SHOULD log the event. If it succeeds, it MUST silently delete the IKE SA associated with the IKE_SPI fields and all dependent child SAs. This event MAY also be logged. The token taker MUST accept such tokens from any IP address and port combination, so as to allow different kinds of high-availability configurations of the token maker.",
      "ja": "トークンテイカーが保護されていない通知でQCDトークンを受け取った場合、token_secret_dataが一致するIKE SAと保存されているトークンと一致することを確認する必要があります。検証が失敗した場合、またはメッセージ内のIKE SPIが既存のIKESAと一致しない場合、イベントを記録する必要があります。それが成功した場合、IKE_SPIフィールドとすべての依存した子SASに関連するIKE SAを静かに削除する必要があります。このイベントも記録される場合があります。トークンテイカーは、トークンメーカーのさまざまな種類の高可用性構成を可能にするために、任意のIPアドレスとポートの組み合わせからそのようなトークンを受け入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "A supporting token taker MAY immediately create new SAs using an Initial exchange, or it may wait for subsequent traffic to trigger the creation of new SAs.",
      "ja": "サポートするトークンテイカーは、初期交換を使用してすぐに新しいSASを作成するか、後続のトラフィックが新しいSASの作成をトリガーするのを待つ場合があります。"
    },
    {
      "indent": 3,
      "text": "See Section 7 for a short discussion about this extension's interaction with IKEv2 Session Resumption ([RFC5723]).",
      "ja": "この拡張機能とIKEV2セッションの再開（[RFC5723]）との相互作用についての短い議論については、セクション7を参照してください。"
    },
    {
      "indent": 0,
      "text": "4. Formats and Exchanges",
      "section_title": true,
      "ja": "4. フォーマットと交換"
    },
    {
      "indent": 0,
      "text": "4.1. Notification Format",
      "section_title": true,
      "ja": "4.1. 通知形式"
    },
    {
      "indent": 3,
      "text": "The notification payload called \"QCD token\" is formatted as follows:",
      "ja": "「QCDトークン」と呼ばれる通知ペイロードは、次のようにフォーマットされます。"
    },
    {
      "indent": 7,
      "text": "                     1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n! Next Payload  !C!  RESERVED   !         Payload Length        !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!  Protocol ID  !   SPI Size    ! QCD Token Notify Message Type !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n!                                                               !\n~                       TOKEN_SECRET_DATA                       ~\n!                                                               !\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "o Protocol ID (1 octet) MUST be 1, as this message is related to an IKE SA.",
      "ja": "o このメッセージはIKE SAに関連しているため、プロトコルID（1 Octet）は1でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o SPI Size (1 octet) MUST be zero, in conformance with Section 3.10 of [RFC5996].",
      "ja": "o [RFC5996]のセクション3.10に準拠して、SPIサイズ（1オクテット）はゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "o QCD Token Notify Message Type (2 octets) - MUST be 16419, the value assigned for QCD token notifications.",
      "ja": "o QCDトークン通知メッセージタイプ（2オクテット） -  QCDトークン通知に割り当てられた値は16419でなければなりません。"
    },
    {
      "indent": 3,
      "text": "o TOKEN_SECRET_DATA (variable) contains a generated token as described in Section 5.",
      "ja": "o token_secret_data（変数）には、セクション5で説明されているように生成されたトークンが含まれています。"
    },
    {
      "indent": 0,
      "text": "4.2. Passing a Token in the AUTH Exchange",
      "section_title": true,
      "ja": "4.2. 認証交換でトークンを渡します"
    },
    {
      "indent": 3,
      "text": "For brevity, only the Extensible Authentication Protocol (EAP) version of an AUTH exchange will be presented here. The non-EAP version is very similar. The figures below are based on Appendix C.3 of [RFC5996].",
      "ja": "簡潔にするために、認証交換の拡張可能な認証プロトコル（EAP）バージョンのみがここに表示されます。EAP以外のバージョンは非常に似ています。以下の図は、[RFC5996]の付録C.3に基づいています。"
    },
    {
      "indent": 4,
      "text": "first request --> IDi, [N(INITIAL_CONTACT)], [[N(HTTP_CERT_LOOKUP_SUPPORTED)], CERTREQ+], [IDr], [N(QCD_TOKEN)] [CP(CFG_REQUEST)], [N(IPCOMP_SUPPORTED)+], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [V+]",
      "ja": "最初のリクエスト - > idi、[n（initial_contact）]、[[n（http_cert_lookup_supported）]、certreq]、[idr]、[n（qcd_token）] [cfg_request）]]]、[n（ipcomp_supported）]、[n（use_transport_mode）]、[n（esp_tfc_padding_not_supported）]、[n（non_first_fragments_also）]、sa、tsi、tsr、[v]"
    },
    {
      "indent": 4,
      "text": "first response <-- IDr, [CERT+], AUTH, EAP, [V+]",
      "ja": "最初の応答<-idr、[cert]、auth、eap、[v]"
    },
    {
      "indent": 4,
      "text": " / --> EAP repeat 1..N times | \\ <-- EAP",
      "ja": "/  - > EAP Repeat 1..n times |\\ <-EAP"
    },
    {
      "indent": 4,
      "text": "last request --> AUTH",
      "ja": "最後のリクエスト - > auth"
    },
    {
      "indent": 4,
      "text": "last response <-- AUTH, [N(QCD_TOKEN)] [CP(CFG_REPLY)], [N(IPCOMP_SUPPORTED)], [N(USE_TRANSPORT_MODE)], [N(ESP_TFC_PADDING_NOT_SUPPORTED)], [N(NON_FIRST_FRAGMENTS_ALSO)], SA, TSi, TSr, [N(ADDITIONAL_TS_POSSIBLE)], [V+]",
      "ja": "最後の応答< -  auth、[n（qcd_token）] [cp（cfg_reply）]、[n（ipcomp_supported）]、[n（use_transport_mode）]、[n（esp_tfc_padding_not_supported）]、[n（non_first_fragments_also）、saTSI、TSR、[n（additional_ts_possible）]、[v]"
    },
    {
      "indent": 3,
      "text": "Note that the QCD_TOKEN notification is marked as optional because it is not required by this specification that every implementation be both token maker and token taker. If only one peer sends the QCD token, then a reboot of the other peer will not be recoverable by this method. This may be acceptable if traffic typically originates from the other peer.",
      "ja": "QCD_TOKEN通知は、すべての実装がトークンメーカーとトークンテイカーの両方であることをこの仕様では必須ではないため、オプションとしてマークされていることに注意してください。1つのピアのみがQCDトークンを送信する場合、他のピアの再起動はこの方法で回復できません。これは、通常、トラフィックが他のピアから発生する場合に受け入れられる場合があります。"
    },
    {
      "indent": 3,
      "text": "In any case, the lack of a QCD_TOKEN notification MUST NOT be taken as an indication that the peer does not support this standard. Conversely, if a peer does not understand this notification, it will simply ignore it. Therefore, a peer may send this notification freely, even if it does not know whether the other side supports it.",
      "ja": "いずれにせよ、QCD_TOKEN通知の欠如は、ピアがこの基準をサポートしていないことを示す兆候とみなす必要はありません。逆に、ピアがこの通知を理解していない場合、それは単にそれを無視します。したがって、ピアは、反対側がそれをサポートしているかどうかがわからない場合でも、この通知を自由に送信する場合があります。"
    },
    {
      "indent": 3,
      "text": "The QCD_TOKEN notification is related to the IKE SA and should follow the AUTH payload and precede the Configuration payload and all payloads related to the child SA.",
      "ja": "QCD_TOKEN通知はIKE SAに関連しており、認証ペイロードに従っており、構成ペイロードとChild SAに関連するすべてのペイロードに先行する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3. Replacing Tokens after Rekey or Resumption",
      "section_title": true,
      "ja": "4.3. Rekeyまたは再開後のトークンを交換します"
    },
    {
      "indent": 3,
      "text": "After rekeying an IKE SA, the IKE SPIs are replaced, so the new SA also needs to have a token. If only the responder in the rekey exchange is the token maker, this can be done within the CREATE_CHILD_SA exchange. If the initiator is a token maker, then we need an extra informational exchange.",
      "ja": "Ike SAを再キーした後、Ike Spisが交換されるため、新しいSAにはトークンも必要です。Reke ExchangeのResponderのみがトークンメーカーである場合、これはcreate_child_sa Exchange内で実行できます。イニシエーターがトークンメーカーの場合、追加の情報交換が必要です。"
    },
    {
      "indent": 3,
      "text": "The following figure shows the CREATE_CHILD_SA exchange for rekeying the IKE SA. Only the responder sends a QCD token.",
      "ja": "次の図は、IKE SAを再キーするためのcreate_child_sa Exchangeを示しています。応答者のみがQCDトークンを送信します。"
    },
    {
      "indent": 6,
      "text": "request --> SA, Ni, [KEi]",
      "ja": "リクエスト - > sa、ni、[kei]"
    },
    {
      "indent": 6,
      "text": "response <-- SA, Nr, [KEr], N(QCD_TOKEN)",
      "ja": "応答<-Sa、nr、[ker]、n（qcd_token）"
    },
    {
      "indent": 3,
      "text": "If the initiator is also a token maker, it SHOULD initiate an INFORMATIONAL exchange immediately after the CREATE_CHILD_SA exchange as follows:",
      "ja": "イニシエーターがトークンメーカーでもある場合、次のようにcreate_child_sa交換の直後に情報交換を開始する必要があります。"
    },
    {
      "indent": 6,
      "text": "request             --> N(QCD_TOKEN)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "response <--",
      "ja": "応答< - "
    },
    {
      "indent": 3,
      "text": "For session resumption, as specified in [RFC5723], the situation is similar. The responder, which is necessarily the peer that has crashed, SHOULD send a new ticket within the protected payload of the IKE_SESSION_RESUME exchange. If the Initiator is also a token maker, it needs to send a QCD_TOKEN in a separate INFORMATIONAL exchange.",
      "ja": "[RFC5723]で指定されているように、セッション再開の場合、状況は似ています。必然的にクラッシュしたピアであるレスポンダーは、IKE_SESSION_RESUME Exchangeの保護されたペイロード内で新しいチケットを送信する必要があります。イニシエーターがトークンメーカーでもある場合、別の情報交換でQCD_TOKENを送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "The INFORMATIONAL exchange described in this section can also be used if QCD tokens need to be replaced due to a key rollover. However, since token takers are required to verify at least 4 QCD tokens, this is only necessary if secret QCD keys are rolled over more than four times as often as IKE SAs are rekeyed. See Section 5.1 for an example method that uses secret keys that may require rollover.",
      "ja": "このセクションで説明する情報交換は、キーロールオーバーのためにQCDトークンを交換する必要がある場合にも使用できます。ただし、トークンテイカーは少なくとも4つのQCDトークンを検証する必要があるため、これは、Ike SASが再キーになっている程度の頻度で秘密のQCDキーが巻き込まれた場合にのみ必要です。ロールオーバーを必要とする可能性のある秘密キーを使用する例の方法については、セクション5.1を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.4. Replacing the Token for an Existing SA",
      "section_title": true,
      "ja": "4.4. 既存のSAのトークンを交換します"
    },
    {
      "indent": 3,
      "text": "With some token generation methods, such as that described in Section 5.2, a QCD token may sometimes become invalid, although the IKE SA is still perfectly valid.",
      "ja": "セクション5.2で説明したようなトークン生成方法では、QCDトークンが無効になることがありますが、IKE SAはまだ完全に有効です。"
    },
    {
      "indent": 3,
      "text": "In such a case, the token maker MUST send the new token in a protected message under that IKE SA. That exchange could be a simple INFORMATIONAL, such as in the last figure in the previous section, or else it can be part of a MOBIKE INFORMATIONAL exchange such as in the following figure taken from Section 2.2 of [RFC4555] and modified by adding a QCD_TOKEN notification:",
      "ja": "そのような場合、トークンメーカーは、そのIKE SAの下で保護されたメッセージで新しいトークンを送信する必要があります。その交換は、前のセクションの最後の図などの単純な情報である可能性があります。そうしないと、[RFC4555]のセクション2.2から取られ、QCD_TOKENを追加して修正されたような、モバイク情報交換の一部になる可能性があります。通知："
    },
    {
      "indent": 5,
      "text": "(IP_I2:4500 -> IP_R1:4500)\nHDR, SK { N(UPDATE_SA_ADDRESSES),\n          N(NAT_DETECTION_SOURCE_IP),\n          N(NAT_DETECTION_DESTINATION_IP) }  -->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "<-- (IP_R1:4500 -> IP_I2:4500)\n    HDR, SK { N(NAT_DETECTION_SOURCE_IP),\n         N(NAT_DETECTION_DESTINATION_IP) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "<-- (IP_R1:4500 -> IP_I2:4500)\n    HDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "(IP_I2:4500 -> IP_R1:4500)\nHDR, SK { N(COOKIE2), [N(QCD_TOKEN)] }  -->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "A token taker MUST accept such gratuitous QCD_TOKEN notifications as long as they are carried in protected exchanges. A token maker SHOULD NOT generate them unless it is no longer able to generate the old QCD_TOKEN.",
      "ja": "トークンテイカーは、保護された交換で運ばれている限り、そのような無償のQCD_TOKEN通知を受け入れる必要があります。トークンメーカーは、古いQCD_TOKENを生成できなくなっていない限り、それらを生成してはなりません。"
    },
    {
      "indent": 0,
      "text": "4.5. Presenting the Token in an Unprotected Message",
      "section_title": true,
      "ja": "4.5. 保護されていないメッセージでトークンを提示します"
    },
    {
      "indent": 3,
      "text": "This QCD_TOKEN notification is unprotected, and is sent as a response to a protected IKE request, which uses an IKE SA that is unknown.",
      "ja": "このQCD_TOKEN通知は保護されておらず、不明なIKE SAを使用する保護されたIKEリクエストへの応答として送信されます。"
    },
    {
      "indent": 12,
      "text": "message             --> N(INVALID_IKE_SPI), N(QCD_TOKEN)+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "If child SPIs are persistently mapped to IKE SPIs as described in Section 8.2, a token taker may get the following unprotected message in response to an Encapsulating Security Payload (ESP) or Authentication Header (AH) packet.",
      "ja": "セクション8.2で説明されているように、子供のスピスがIke SPIに永続的にマッピングされている場合、トークンテイカーは、カプセル化セキュリティペイロード（ESP）または認証ヘッダー（AH）パケットに応じて、次の保護されていないメッセージを取得する場合があります。"
    },
    {
      "indent": 12,
      "text": "message             --> N(INVALID_SPI), N(QCD_TOKEN)+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The QCD_TOKEN and INVALID_IKE_SPI notifications are sent together to support both implementations that conform to this specification and implementations that don't. Similar to the description in Section 2.21 of [RFC5996], the IKE SPI and message ID fields in the packet headers are taken from the protected IKE request.",
      "ja": "QCD_TOKENおよびINVALID_IKE_SPI通知は、この仕様とそうでない実装に準拠する両方の実装をサポートするために一緒に送信されます。[RFC5996]のセクション2.21の説明と同様に、パケットヘッダーのIKE SPIおよびメッセージIDフィールドは、保護されたIKEリクエストから取得されます。"
    },
    {
      "indent": 3,
      "text": "To support a periodic rollover of the secret used for token generation, the token taker MUST support at least four QCD_TOKEN notifications in a single packet. The token is considered verified if any of the QCD_TOKEN notifications matches. The token maker MAY generate up to four QCD_TOKEN notifications, based on several generations of keys.",
      "ja": "トークン生成に使用される秘密の定期的なロールオーバーをサポートするには、トークンテイカーは、単一のパケットで少なくとも4つのQCD_TOKEN通知をサポートする必要があります。トークンは、QCD_TOKEN通知のいずれかが一致する場合に確認されたと見なされます。トークンメーカーは、数世代のキーに基づいて、最大4つのQCD_TOKEN通知を生成する場合があります。"
    },
    {
      "indent": 3,
      "text": "If the QCD_TOKEN verifies OK, the receiver MUST silently discard the IKE SA and all associated child SAs. If the QCD_TOKEN cannot be validated, a response MUST NOT be sent, and the event may be logged. Section 5 defines token verification.",
      "ja": "QCD_TOKENがOKを検証した場合、受信者はIKE SAおよび関連するすべての子SASを静かに廃棄する必要があります。QCD_TOKENを検証できない場合、応答を送信する必要はなく、イベントを記録することもできます。セクション5では、トークンの検証を定義しています。"
    },
    {
      "indent": 0,
      "text": "5. Token Generation and Verification",
      "section_title": true,
      "ja": "5. トークンの生成と検証"
    },
    {
      "indent": 3,
      "text": "No token generation method is mandated by this document. Two methods are documented in the following sub-sections, but they only serve as examples.",
      "ja": "このドキュメントでは、トークン生成方法は義務付けられていません。次のサブセクションには2つの方法が文書化されていますが、それらは例としてのみ機能します。"
    },
    {
      "indent": 3,
      "text": "The following lists the requirements for a token generation mechanism:",
      "ja": "以下には、トークン生成メカニズムの要件をリストします。"
    },
    {
      "indent": 3,
      "text": "o Tokens MUST be at least 16 octets long, and no more than 128 octets long, to facilitate storage and transmission. Tokens SHOULD be indistinguishable from random data.",
      "ja": "o トークンは、ストレージとトランスミッションを容易にするために、少なくとも16オクテット、長さ128オクテット以下でなければなりません。トークンは、ランダムデータと区別できない必要があります。"
    },
    {
      "indent": 3,
      "text": "o It should not be possible for an external attacker to guess the QCD token generated by an implementation. Cryptographic mechanisms such as a pseudo-random number generator (PRNG) and hash functions are RECOMMENDED.",
      "ja": "o 外部攻撃者が実装によって生成されたQCDトークンを推測することは不可能です。擬似ランダム数ジェネレーター（PRNG）やハッシュ関数などの暗号化メカニズムが推奨されます。"
    },
    {
      "indent": 3,
      "text": "o The token maker MUST be able to re-generate or retrieve the token based on the IKE SPIs even after it reboots.",
      "ja": "o トークンメーカーは、再起動した後でもIke Spisに基づいてトークンを再生成または取得できる必要があります。"
    },
    {
      "indent": 3,
      "text": "o The method of token generation MUST be such that a collision of QCD tokens between different pairs of IKE SPI will be highly unlikely.",
      "ja": "o トークン生成の方法は、IKE SPIの異なるペア間のQCDトークンの衝突が非常にありそうにないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "For verification, the token taker makes a bitwise comparison of the token stored along with the IKE SA with the token sent in the unprotected message. Multihomed takers might flip back-and-forth between several addresses, and have their tokens replaced as described in Section 4.4. To help avoid the case where the latest stored token does not match the address used after the maker lost state, the token taker MAY store several earlier tokens associated with the IKE SA, and silently discard the SA if any of them matches.",
      "ja": "検証のために、トークンテイカーは、保護されていないトークンと一緒に保存されたトークンと保護されていないメッセージで送信されたトークンを少し比較します。マルチホームのテイカーは、いくつかのアドレスの間で前後に反転し、セクション4.4で説明されているようにトークンを交換する可能性があります。最新の保存されたトークンがメーカーの失われた状態後に使用されたアドレスと一致しない場合を避けるために、トークンテイカーはIKE SAに関連付けられたいくつかの初期のトークンを保存し、それらのいずれかが一致する場合はSAを静かに捨てることができます。"
    },
    {
      "indent": 0,
      "text": "5.1. A Stateless Method of Token Generation",
      "section_title": true,
      "ja": "5.1. トークン生成の無国籍方法"
    },
    {
      "indent": 3,
      "text": "The following describes a stateless method of generating a token. In this case, 'stateless' means not maintaining any per-tunnel state, although there is a small amount of non-volatile storage required.",
      "ja": "以下は、トークンを生成するステートレス方法について説明しています。この場合、「ステートレス」とは、トンネルあたりの状態を維持しないことを意味しますが、不揮発性のないストレージが少ないです。"
    },
    {
      "indent": 3,
      "text": "o At installation or immediately after the first boot of the token maker, 32 random octets are generated using a secure random number generator or a PRNG.",
      "ja": "o インストール時またはトークンメーカーの最初のブーツの直後に、安全な乱数ジェネレーターまたはPRNGを使用して32のランダムオクテットが生成されます。"
    },
    {
      "indent": 3,
      "text": "o Those 32 bytes, called the \"QCD_SECRET\", are stored in non-volatile storage on the machine, and kept indefinitely.",
      "ja": "o 「QCD_Secret」と呼ばれるこれらの32バイトは、マシン上の不揮発性ストレージに保存され、無期限に保存されます。"
    },
    {
      "indent": 3,
      "text": "o If key rollover is required by policy, the implementation MAY periodically generate a new QCD_SECRET and keep up to 3 previous generations. When sending an unprotected QCD_TOKEN, as many as 4 notification payloads may be sent, each from a different QCD_SECRET.",
      "ja": "o ポリシーでキーロールオーバーが必要な場合、実装は定期的に新しいQCD_Secretを生成し、以前の3世代まで維持することができます。保護されていないQCD_TOKENを送信すると、それぞれ異なるQCD_Secretから4つの通知ペイロードが送信される場合があります。"
    },
    {
      "indent": 3,
      "text": "o The TOKEN_SECRET_DATA is calculated as follows:",
      "ja": "o token_secret_dataは次のように計算されます。"
    },
    {
      "indent": 12,
      "text": "TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R)",
      "ja": "token_secret_data = hash（qcd_secret | spi-i | spi-r）"
    },
    {
      "indent": 0,
      "text": "5.2. A Stateless Method with IP Addresses",
      "section_title": true,
      "ja": "5.2. IPアドレスを備えたステートレスメソッド"
    },
    {
      "indent": 3,
      "text": "This method is similar to the one in the previous section, except that the IP address of the token taker is also added to the block being hashed. This has the disadvantage that the token needs to be replaced (as described in Section 4.4) whenever the token taker changes its address.",
      "ja": "この方法は、トークンテイカーのIPアドレスがハッシュされているブロックに追加されていることを除いて、前のセクションの方法に似ています。これには、トークンテイカーがアドレスを変更するたびに、トークンを交換する必要があるという欠点があります（セクション4.4で説明されているように）。"
    },
    {
      "indent": 3,
      "text": "See Section 9.2 for a discussion of a use-case for this method. When using this method, the TOKEN_SECRET_DATA field is calculated as follows:",
      "ja": "この方法のユースケースの議論については、セクション9.2を参照してください。この方法を使用する場合、token_secret_dataフィールドは次のように計算されます。"
    },
    {
      "indent": 9,
      "text": "TOKEN_SECRET_DATA = HASH(QCD_SECRET | SPI-I | SPI-R | IPaddr-T)",
      "ja": "token_secret_data = hash（qcd_secret | spi-i | spi-r | ipaddr-t）"
    },
    {
      "indent": 3,
      "text": "The IPaddr-T field specifies the IP address of the token taker. Secret rollover considerations are similar to those in the previous section.",
      "ja": "iPaddr-Tフィールドは、トークンテイカーのIPアドレスを指定します。秘密のロールオーバーの考慮事項は、前のセクションのものと似ています。"
    },
    {
      "indent": 3,
      "text": "Note that with a multihomed token taker, the QCD token matches just one of the token taker IP addresses. Usually this is not a problem, as packets sent to the token maker come out the same IP address. If for some reason this changes, then the token maker can replace the token as described in Section 4.4. If IKEv2 Mobility and Multihoming (MOBIKE) is used, replacing the tokens SHOULD be piggybacked on the INFORMATIONAL exchange with the UPDATE_SA_ADDRESSES notifications.",
      "ja": "マルチホームのトークンテイカーを使用すると、QCDトークンはトークンテイカーIPアドレスの1つだけと一致することに注意してください。通常、これは問題ではありません。トークンメーカーに送信されたパケットが同じIPアドレスを出しているためです。何らかの理由でこれが変更された場合、トークンメーカーはセクション4.4で説明されているようにトークンを置き換えることができます。IKEV2モビリティとマルチホミング（Mobike）を使用する場合、トークンを交換することは、update_sa_addresses通知と情報交換でピギーバックする必要があります。"
    },
    {
      "indent": 3,
      "text": "There is a corner case where the token taker begins using a new IP address (because of multihoming, roaming, or normal network operations) and the token maker loses state before replacing the token. In that case, it will send a correct QCD token, but the token taker will still have the old token. In that case, the extension will not work, and the peers will revert to RFC 5996 recovery.",
      "ja": "トークンテイカーが（マルチホミング、ローミング、または通常のネットワーク操作のため）新しいIPアドレスの使用を開始し、トークンメーカーがトークンを交換する前に状態を失うコーナーケースがあります。その場合、正しいQCDトークンを送信しますが、トークンテイカーにはまだ古いトークンがあります。その場合、拡張機能は機能せず、ピアはRFC 5996回復に戻ります。"
    },
    {
      "indent": 0,
      "text": "5.3. Token Lifetime",
      "section_title": true,
      "ja": "5.3. トークンライフタイム"
    },
    {
      "indent": 3,
      "text": "The token is associated with a single IKE SA and SHOULD be deleted by the token taker when the SA is deleted or expires. More formally, the token is associated with the pair (SPI-I, SPI-R).",
      "ja": "トークンは単一のIKE SAに関連付けられており、SAが削除されたり期限切れになったときにトークンテイカーによって削除される必要があります。より正式には、トークンはペア（SPI-I、SPI-R）に関連付けられています。"
    },
    {
      "indent": 0,
      "text": "6. Backup Gateways",
      "section_title": true,
      "ja": "6. バックアップゲートウェイ"
    },
    {
      "indent": 3,
      "text": "Making crash detection and recovery quick is a worthy goal, but since rebooting a gateway takes a non-zero amount of time, many implementations choose to have a standby gateway ready to take over as soon as the primary gateway fails for any reason. [RFC6027] describes considerations for such clusters of gateways with synchronized state, but the rest of this section is relevant even when there is no synchronized state.",
      "ja": "クラッシュの検出と回復を迅速に行うことは価値のある目標ですが、ゲートウェイの再起動にはゼロ以外の時間がかかるため、多くの実装は、何らかの理由でプライマリゲートウェイが失敗するとすぐにスタンバイゲートウェイを引き継ぐことができます。[RFC6027]は、同期された状態を持つゲートウェイのこのようなクラスターの考慮事項について説明しますが、このセクションの残りの部分は、同期された状態がない場合でも関連します。"
    },
    {
      "indent": 3,
      "text": "If such a configuration is available, it is RECOMMENDED that the standby gateway be able to generate the same token as the active gateway. If the method described in Section 5.1 is used, this means that the QCD_SECRET field is identical in both gateways. This has the effect of having the crash recovery available immediately.",
      "ja": "このような構成が利用可能な場合は、スタンバイゲートウェイがアクティブゲートウェイと同じトークンを生成できることをお勧めします。セクション5.1で説明した方法が使用されている場合、これは両方のゲートウェイでQCD_Secretフィールドが同一であることを意味します。これは、クラッシュ回復をすぐに利用できるようにする効果があります。"
    },
    {
      "indent": 3,
      "text": "Note that this refers to \"high-availability\" configurations, where only one gateway is active at any given moment. This is different from \"load sharing\" configurations where more than one gateway is active at the same time. For load sharing configurations, please see Section 9.2 for security considerations.",
      "ja": "これは、任意の瞬間に1つのゲートウェイのみがアクティブである「高可用性」構成を指すことに注意してください。これは、複数のゲートウェイが同時にアクティブになっている「負荷共有」構成とは異なります。負荷共有構成については、セキュリティに関する考慮事項については、セクション9.2を参照してください。"
    },
    {
      "indent": 0,
      "text": "7. Interaction with Session Resumption",
      "section_title": true,
      "ja": "7. セッション再開との相互作用"
    },
    {
      "indent": 3,
      "text": "Session resumption, specified in [RFC5723], allows the setting up of a new IKE SA to consume less computing resources. This is particularly useful in the case of a remote access gateway that has many tunnels. A failure of such a gateway requires all these many remote access clients to establish an IKE SA either with the rebooted gateway or with a backup. This tunnel re-establishment occurs within a short period of time, creating a burden on the remote access gateway. Session resumption addresses this problem by having the clients store an encrypted derivative of the IKE SA for quick re-establishment.",
      "ja": "[RFC5723]で指定されたセッション再開により、新しいIKE SAのセットアップにより、コンピューティングリソースが少なくなります。これは、多くのトンネルを備えたリモートアクセスゲートウェイの場合に特に役立ちます。このようなゲートウェイの障害には、これらの多くのリモートアクセスクライアントがすべて、再起動したゲートウェイまたはバックアップを使用してIKE SAを確立する必要があります。このトンネルの再確立は、短期間で発生し、リモートアクセスゲートウェイに負担がかかります。セッション再開は、クライアントにIKE SAの暗号化された派生物を迅速に再確立するために保存させることにより、この問題に対処します。"
    },
    {
      "indent": 3,
      "text": "What Session Resumption does not help is the problem of detecting that the peer gateway has failed. A failed gateway may go undetected for an arbitrarily long time, because IPsec does not have packet acknowledgement, and applications cannot signal the IPsec layer that the tunnel \"does not work\". Section 2.4 of RFC 5996 does not specify how long an implementation needs to wait before beginning a liveness check, and only says \"not recently\" (see full quote in Section 2). In practice, some mobile devices wait a very long time before beginning a liveness check, in order to extend battery life by allowing parts of the device to remain in low-power modes.",
      "ja": "セッション再開が役に立たないのは、ピアゲートウェイが失敗したことを検出する問題です。IPSECにはパケットの確認がなく、アプリケーションがトンネルが「機能しない」というIPSECレイヤーを信号することはできないため、失敗したゲートウェイは任意に長時間検出されない場合があります。RFC 5996のセクション2.4では、livensionチェックを開始する前に実装が待機する必要がある期間を指定しておらず、「最近ではない」としか言いません（セクション2の完全な引用を参照）。実際には、一部のモバイルデバイスは、デバイスの部品が低電力モードのままになることでバッテリー寿命を延ばすために、活性チェックを開始する前に非常に長い時間待ちます。"
    },
    {
      "indent": 3,
      "text": "QCD tokens provide a way to detect the failure of the peer in the case where a liveness check has not yet ended (or begun).",
      "ja": "QCDトークンは、活性チェックがまだ終了していない（または始めた）場合にピアの障害を検出する方法を提供します。"
    },
    {
      "indent": 3,
      "text": "A remote access client conforming to both specifications will store QCD tokens, as well as the Session Resumption ticket, if provided by the gateway. A remote access gateway conforming to both specifications will generate a QCD token for the client. When the gateway reboots, the client will discover this in either of two ways:",
      "ja": "両方の仕様に準拠しているリモートアクセスクライアントは、QCDトークンと、ゲートウェイによって提供される場合、セッション再開チケットを保存します。両方の仕様に準拠するリモートアクセスゲートウェイは、クライアント用のQCDトークンを生成します。ゲートウェイが再起動すると、クライアントは次の2つの方法のいずれかでこれを発見します。"
    },
    {
      "indent": 3,
      "text": "1. The client does regular liveness checks, or else the time for some other IKE exchange has come. Since the gateway is still down, the IKE exchange times out after several minutes. In this case, QCD does not help.",
      "ja": "1. クライアントは定期的な活性チェックを行います。そうしないと、他のIKE交換の時間が来ました。ゲートウェイはまだダウンしているため、ike交換は数分後に出ます。この場合、QCDは役に立ちません。"
    },
    {
      "indent": 3,
      "text": "2. Either the primary gateway or a backup gateway (see Section 6) is ready and sends a QCD token to the client. In that case, the client will quickly re-establish the IPsec tunnel, either with the rebooted primary gateway or the backup gateway as described in this document.",
      "ja": "2. プライマリゲートウェイまたはバックアップゲートウェイ（セクション6を参照）のいずれかが準備ができており、QCDトークンをクライアントに送信します。その場合、クライアントは、このドキュメントで説明されているように、再起動されたプライマリゲートウェイまたはバックアップゲートウェイのいずれかを使用して、IPSECトンネルをすばやく再確立します。"
    },
    {
      "indent": 3,
      "text": "The full combined protocol looks like this:",
      "ja": "完全な組み合わせプロトコルは次のようになります："
    },
    {
      "indent": 7,
      "text": " Initiator                Responder\n -----------              -----------\nHDR, SAi1, KEi, Ni  -->",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "<-- HDR, SAr1, KEr, Nr, [CERTREQ]",
      "ja": "<-HDR、sar1、ker、nr、[certreq]"
    },
    {
      "indent": 7,
      "text": "HDR, SK {IDi, [CERT,]\n[CERTREQ,] [IDr,]\nAUTH, N(QCD_TOKEN)\nSAi2, TSi, TSr,\nN(TICKET_REQUEST)}  -->\n                    <--    HDR, SK {IDr, [CERT,] AUTH,\n                           N(QCD_TOKEN), SAr2, TSi, TSr,\n                           N(TICKET_LT_OPAQUE) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "---- Reboot -----",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "HDR, {}             -->\n                    <--  HDR, N(QCD_TOKEN)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "HDR, [N(COOKIE),]\nNi, N(TICKET_OPAQUE)\n[,N+]               -->\n                    <--  HDR, Nr [,N+]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "8. Operational Considerations",
      "section_title": true,
      "ja": "8. 運用上の考慮事項"
    },
    {
      "indent": 0,
      "text": "8.1. Who Should Implement This Specification",
      "section_title": true,
      "ja": "8.1. 誰がこの仕様を実装する必要があります"
    },
    {
      "indent": 3,
      "text": "Throughout this document, we have referred to reboot time alternatingly as the time that the implementation crashes and the time when it is ready to process IPsec packets and IKE exchanges. Depending on the hardware and software platforms and the cause of the reboot, rebooting may take anywhere from a few seconds to several minutes. If the implementation is down for a long time, the benefit of this protocol extension is reduced. For this reason, critical systems should implement backup gateways as described in Section 6.",
      "ja": "このドキュメント全体を通して、実装がクラッシュする時間とIPSECパケットとIKE交換の処理準備ができた時間と交互に再起動することを参照しました。ハードウェアプラットフォームとソフトウェアプラットフォームと再起動の原因に応じて、再起動すると数秒から数分かかる場合があります。実装が長い間ダウンしている場合、このプロトコル拡張の利点は削減されます。このため、セクション6で説明されているように、重要なシステムがバックアップゲートウェイを実装する必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementing the \"token maker\" side of QCD makes sense for IKE implementation where protected connections originate from the peer, such as inter-domain VPNs and remote access gateways. Implementing the \"token taker\" side of QCD makes sense for IKE implementations where protected connections originate, such as inter-domain VPNs and remote access clients.",
      "ja": "QCDの「トークンメーカー」側を実装することは、ドメイン間VPNやリモートアクセスゲートウェイなど、保護された接続がピアに由来するIKE実装にとって理にかなっています。QCDの「トークンテイカー」側を実装することは、ドメイン間VPNやリモートアクセスクライアントなど、保護された接続が発生するIKE実装にとって理にかなっています。"
    },
    {
      "indent": 3,
      "text": "To clarify this discussion:",
      "ja": "この議論を明確にするには："
    },
    {
      "indent": 3,
      "text": "o For remote-access clients it makes sense to implement the token taker role.",
      "ja": "o リモートアクセスクライアントにとって、トークンテイカーの役割を実装することは理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o For remote-access gateways it makes sense to implement the token maker role.",
      "ja": "o リモートアクセスゲートウェイの場合、トークンメーカーの役割を実装することは理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o For inter-domain VPN gateways it makes sense to implement both roles, because it can't be known in advance where the traffic originates.",
      "ja": "o ドメイン間VPNゲートウェイの場合、トラフィックが発生する場所が事前に知られていないため、両方の役割を実装することは理にかなっています。"
    },
    {
      "indent": 3,
      "text": "o It is perfectly valid to implement both roles in any case, for example, when using a single library or a single gateway to perform several roles.",
      "ja": "o たとえば、単一のライブラリまたは単一のゲートウェイを使用していくつかのロールを実行する場合、どんな場合でも両方の役割を実装することは完全に有効です。"
    },
    {
      "indent": 3,
      "text": "In order to limit the effects of Denial-of-Service (DoS) attacks, a token taker SHOULD limit the rate of QCD_TOKENs verified from a particular source.",
      "ja": "サービス拒否（DOS）攻撃の影響を制限するために、トークンテイカーは特定のソースから検証されたQCD_TOKENSのレートを制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "If excessive amounts of IKE requests protected with unknown IKE SPIs arrive at a token maker, the IKE module SHOULD revert to the behavior described in Section 2.21 of [RFC5996] and either send an INVALID_IKE_SPI notification or ignore it entirely.",
      "ja": "未知のIKE Spisで保護された過剰な量のIKE要求がトークンメーカーに到着した場合、IKEモジュールは[RFC596]のセクション2.21で説明されている動作に戻り、Invalid_ike_spi通知を送信するか、完全に無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "Section 9.2 requires that token makers never send a QCD token in the clear for a valid IKE SA and describes some configurations where this could occur. Implementations that may be installed in such configurations SHOULD automatically detect this and disable this extension in unsafe configurations and MUST allow the user to control whether the extension is enabled or disabled.",
      "ja": "セクション9.2では、トークンメーカーが有効なIKE SAのQCDトークンをクリアに送信しないことを要求し、これが発生する可能性のある構成について説明します。このような構成にインストールされる可能性のある実装は、これを自動的に検出し、この拡張機能を安全でない構成で無効にし、ユーザーが拡張機能を有効にするか無効にしているかを制御できるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "8.2. Response to Unknown Child SPI",
      "section_title": true,
      "ja": "8.2. 未知の子SPIへの応答"
    },
    {
      "indent": 3,
      "text": "After a reboot, it is more likely that an implementation will receive IPsec packets than IKE packets. In that case, the rebooted implementation will send an INVALID_SPI notification, triggering a liveness check. The token will only be sent in a response to the liveness check, thus requiring an extra round trip.",
      "ja": "再起動した後、実装がIKEパケットよりもIPSECパケットを受信する可能性が高くなります。その場合、再起動された実装により、nivalid_spi通知が送信され、livensionチェックがトリガーされます。トークンは、活性チェックへの応答でのみ送信されるため、追加の往復が必要です。"
    },
    {
      "indent": 3,
      "text": "To avoid this, an implementation that has access to enough non-volatile storage MAY store a mapping of child SPIs to owning IKE SPIs, or to generated tokens. If such a mapping is available and persistent across reboots, the rebooted implementation SHOULD respond to the IPsec packet with an INVALID_SPI notification, along with the appropriate QCD_TOKEN notifications. A token taker SHOULD verify the QCD token that arrives with an INVALID_SPI notification the same as if it arrived with the IKE SPIs of the parent IKE SA.",
      "ja": "これを回避するために、十分な不揮発性ストレージにアクセスできる実装により、子供のスピスのマッピングがIke Spisまたは生成されたトークンのマッピングを保存できます。このようなマッピングが利用可能であり、再起動全体で永続的である場合、再起動された実装は、適切なQCD_TOKEN通知とともに、INVALID_SPI通知を使用してIPSECパケットに応答する必要があります。トークンテイカーは、親IKE SAのIKEスピスと到着した場合と同じように無効な_SPI通知で到着するQCDトークンを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "However, a persistent storage module might not be updated in a timely manner and could be populated with tokens relating to IKE SPIs that have already been rekeyed. A token taker MUST NOT take an invalid QCD token sent along with an INVALID_SPI notification as evidence that the peer is either malfunctioning or attacking, but it SHOULD limit the rate at which such notifications are processed.",
      "ja": "ただし、永続的なストレージモジュールはタイムリーに更新されない可能性があり、すでに再キーにされているIKE SPIに関連するトークンを入力できます。トークンテイカーは、ピアが誤動作または攻撃を行っているという証拠として無効なQCDトークンを無効なQCDトークンと一緒に送信してはなりませんが、そのような通知が処理されるレートを制限する必要があります。"
    },
    {
      "indent": 0,
      "text": "9. Security Considerations",
      "section_title": true,
      "ja": "9. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The extension described in this document must not reduce the security of IKEv2 or IPsec. Specifically, an eavesdropper must not learn any non-public information about the peers.",
      "ja": "このドキュメントで説明されている拡張機能は、IKEV2またはIPSECのセキュリティを減らしてはなりません。具体的には、盗聴者はピアに関する非公開情報を学習してはなりません。"
    },
    {
      "indent": 3,
      "text": "The proposed mechanism should be secure against attacks by a passive man in the middle (MITM) (eavesdropper). Such an attacker must not be able to disrupt an existing IKE session, either by resetting the session or by introducing significant delays. This requirement is especially significant, because this document introduces a new way to reset an IKE SA.",
      "ja": "提案されたメカニズムは、中央（MITM）（Eavesdropper）の受動的な男による攻撃に対して安全でなければなりません。このような攻撃者は、セッションをリセットするか、かなりの遅延を導入することにより、既存のIKEセッションを混乱させることができない必要があります。このドキュメントはIKE SAをリセットする新しい方法を導入するため、この要件は特に重要です。"
    },
    {
      "indent": 3,
      "text": "The mechanism need not be similarly secure against an active MITM, since this type of attacker is already able to disrupt IKE sessions.",
      "ja": "このタイプの攻撃者はすでにIKEセッションを破壊できるため、メカニズムはアクティブなMITMに対して同様に安全である必要はありません。"
    },
    {
      "indent": 0,
      "text": "9.1. QCD Token Generation and Handling",
      "section_title": true,
      "ja": "9.1. QCDトークンの生成と取り扱い"
    },
    {
      "indent": 3,
      "text": "Tokens MUST be hard to guess. This is critical, because if an attacker can guess the token associated with an IKE SA, they can tear down the IKE SA and associated tunnels at will. When the token is delivered in the IKE_AUTH exchange, it is encrypted. When it is sent again in an unprotected notification, it is not, but that is the last time this token is ever used.",
      "ja": "トークンは推測するのが難しいに違いありません。これは重要です。なぜなら、攻撃者がIKE SAに関連付けられたトークンを推測できれば、IKE SAと関連するトンネルを自由に取り壊すことができるからです。トークンがIKE_AUTH Exchangeで配信されると、暗号化されます。保護されていない通知で再び送信された場合、そうではありませんが、このトークンが使用されるのは最後です。"
    },
    {
      "indent": 3,
      "text": "An aggregation of some tokens generated by one maker together with the related IKE SPIs MUST NOT give an attacker the ability to guess other tokens. Specifically, if one taker does not properly secure the QCD tokens and an attacker gains access to them, this attacker MUST NOT be able to guess other tokens generated by the same maker. This is the reason that the QCD_SECRET in Section 5.1 needs to be sufficiently long.",
      "ja": "関連するIKE SPIと一緒に1つのメーカーによって生成されたいくつかのトークンの集約は、攻撃者に他のトークンを推測する能力を与えてはなりません。具体的には、1人のTakerがQCDトークンを適切に固定せず、攻撃者がアクセスを獲得している場合、この攻撃者は同じメーカーによって生成された他のトークンを推測できてはなりません。これが、セクション5.1のQCD_Secretが十分に長くする必要がある理由です。"
    },
    {
      "indent": 3,
      "text": "The token taker MUST store the token in a secure manner. No attacker should be able to gain access to a stored token.",
      "ja": "トークンテイカーは、トークンを安全な方法で保存する必要があります。攻撃者は、保存されたトークンにアクセスできるはずです。"
    },
    {
      "indent": 3,
      "text": "The QCD_SECRET MUST be protected from access by other parties. Anyone gaining access to this value will be able to delete all the IKE SAs for this token maker.",
      "ja": "QCD_Secretは、他の当事者によるアクセスから保護する必要があります。この値にアクセスできる人は誰でも、このトークンメーカーのすべてのIKE SASを削除できます。"
    },
    {
      "indent": 3,
      "text": "The QCD token is sent by the rebooted peer in an unprotected message. A message like that is subject to modification, deletion, and replay by an attacker. However, these attacks will not compromise the security of either side. Modification is meaningless because a modified token is simply an invalid token. Deletion will only cause the protocol not to work, resulting in a delay in tunnel re-establishment as described in Section 2. Replay is also meaningless, because the IKE SA has been deleted after the first transmission.",
      "ja": "QCDトークンは、保護されていないメッセージで再起動されたピアによって送信されます。そのようなメッセージは、攻撃者による変更、削除、およびリプレイの対象となります。ただし、これらの攻撃はどちらの側のセキュリティを妥協しません。変更されたトークンは単に無効なトークンであるため、変更は無意味です。削除はプロトコルのみに機能しないため、セクション2で説明されているようにトンネルの再確立が遅れます。リプレイも意味がありません。"
    },
    {
      "indent": 0,
      "text": "9.2. QCD Token Transmission",
      "section_title": true,
      "ja": "9.2. QCDトークン伝送"
    },
    {
      "indent": 3,
      "text": "A token maker MUST NOT send a valid QCD token in an unprotected message for an existing IKE SA.",
      "ja": "トークンメーカーは、既存のIKE SAに対して無防備なメッセージで有効なQCDトークンを送信してはなりません。"
    },
    {
      "indent": 3,
      "text": "This requirement is obvious and easy in the case of a single gateway. However, some implementations use a load balancer to divide the load between several physical gateways. It MUST NOT be possible even in such a configuration to trick one gateway into sending a valid QCD token for an IKE SA that is valid on another gateway. This is true whether the attempt to trick the gateway uses the token taker's IP address or a different IP address.",
      "ja": "この要件は、単一のゲートウェイの場合、明らかで簡単です。ただし、一部の実装では、ロードバランサーを使用して、いくつかの物理ゲートウェイ間で負荷を分割します。このような構成でさえ、1つのゲートウェイをトリックして、別のゲートウェイで有効なIKE SAの有効なQCDトークンを送信することはできません。これは、ゲートウェイをだまそうとする試みがトークンテイカーのIPアドレスまたは別のIPアドレスを使用するかどうかに当てはまります。"
    },
    {
      "indent": 3,
      "text": "IPsec failure detection is not applicable to deployments where the QCD secret is shared by multiple gateways and the gateways cannot assess whether the token can be legitimately sent in the clear while another gateway may actually still own the SA's. Load balancing configurations typically fall in this category. In order for a load balancing configuration of IPsec gateways to support this specification, all members MUST be able to tell whether a particular IKE SA is active anywhere in the cluster. One way to do this is to synchronize a list of active IKE SPIs among all the cluster members.",
      "ja": "IPSEC障害検出は、QCDシークレットが複数のゲートウェイで共有され、ゲートウェイがトークンをクリアで合法的に送信できるかどうかを評価できない場合、ゲートウェイが実際にSAを所有している展開には適用されません。通常、ロードバランシング構成はこのカテゴリに分類されます。この仕様をサポートするIPSecゲートウェイの負荷分散構成のために、すべてのメンバーは、特定のIKE SAがクラスター内のどこでもアクティブであるかどうかを判断できる必要があります。これを行う1つの方法は、すべてのクラスターメンバーの間でアクティブなIKEスピスのリストを同期することです。"
    },
    {
      "indent": 3,
      "text": "Because it includes the token taker's IP address in the token generation, the method in Section 5.2 can (under certain conditions) prevent revealing the QCD token for an existing pair of IKE SPIs to an attacker who is using a different IP address, even in a load-sharing cluster without state synchronization. That method does not prevent revealing the QCD token to an active attacker who is spoofing the token taker's IP address. Such an attacker may attempt to direct messages to a cluster member other than the member responsible for the IKE SA in an attempt to trick that gateway into sending a QCD token for a valid IKE SA. That method should not be used unless the load balancer guarantees that IKE packets from the same source IP address always go to the same cluster member.",
      "ja": "トークンの生成にトークンテイカーのIPアドレスが含まれているため、セクション5.2の方法は（特定の条件下で）、IKEスピスの既存のペアのQCDトークンを、別のIPアドレスを使用している攻撃者に明らかにすることを防ぐことができます。状態同期なしの負荷分担クラスター。その方法では、トークンテイカーのIPアドレスをスプーフィングしているアクティブな攻撃者にQCDトークンを明らかにすることを妨げません。このような攻撃者は、有効なIKE SAのQCDトークンの送信にそのゲートウェイをだまそうとして、IKE SAの責任者以外のメンバー以外のメンバーにメッセージを向けようとする場合があります。ロードバランサーが同じソースIPアドレスのIKEパケットが常に同じクラスターメンバーに移動することを保証しない限り、その方法は使用しないでください。"
    },
    {
      "indent": 0,
      "text": "9.3. QCD Token Enumeration",
      "section_title": true,
      "ja": "9.3. QCDトークン列挙"
    },
    {
      "indent": 3,
      "text": "An attacker may try to attack QCD if the generation algorithm described in Section 5.1 is used. The attacker will send several fake IKE requests to the gateway under attack, receiving and recording the QCD tokens in the responses. This will allow the attacker to create a dictionary of IKE SPIs to QCD tokens, which can later be used to tear down any IKE SA.",
      "ja": "攻撃者は、セクション5.1で説明されている生成アルゴリズムが使用されている場合、QCDを攻撃しようとする場合があります。攻撃者は、いくつかの偽のIKEリクエストを攻撃中のゲートウェイに送信し、応答のQCDトークンを受け取り、記録します。これにより、攻撃者はIke Spisの辞書をQCDトークンに作成することができ、後でIKE SAを取り壊すために使用できます。"
    },
    {
      "indent": 3,
      "text": "Three factors mitigate this threat:",
      "ja": "3つの要因がこの脅威を軽減します。"
    },
    {
      "indent": 3,
      "text": "o The space of all possible IKE SPI pairs is huge: 2^128, so making such a dictionary is impractical. Even if we assume that one implementation always generates predictable IKE SPIs, the space is still at least 2^64 entries, so making the dictionary is extremely hard. To ensure this, token makers MUST generate unpredictable IKE SPIs by using a cryptographically strong pseudo-random number generator.",
      "ja": "o 可能なすべてのIke Spiペアのスペースは巨大です：2^128なので、そのような辞書を作ることは実用的ではありません。1つの実装が常に予測可能なIke Spisを生成すると仮定したとしても、スペースはまだ少なくとも2^64のエントリであるため、辞書の作成は非常に困難です。これを確実にするために、トークンメーカーは、暗号的に強力な擬似ランダム数ジェネレーターを使用して、予測不可能なIke Spisを生成する必要があります。"
    },
    {
      "indent": 3,
      "text": "o Throttling the amount of QCD_TOKEN notifications sent out, as discussed in Section 8.1, especially when not soon after a crash will limit the attacker's ability to construct a dictionary.",
      "ja": "o セクション8.1で説明されているように、QCD_TOKEN通知の量を調整します。特に、クラッシュの直後に攻撃者の辞書を構築する能力が制限されない場合。"
    },
    {
      "indent": 3,
      "text": "o The methods in Section 5.1 and Section 5.2 allow for a periodic change of the QCD_SECRET. Any such change invalidates the entire dictionary.",
      "ja": "o セクション5.1およびセクション5.2の方法では、QCD_Secretの定期的な変更が可能です。このような変更は、辞書全体を無効にします。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has assigned a notify message type (16419) from the status types range (16406-40959) of the \"IKEv2 Notify Message Types\" registry with the name \"QUICK_CRASH_DETECTION\".",
      "ja": "IANAは、「IKEV2通知メッセージタイプ」のステータスタイプ範囲（16406-40959）から「Quick_Crash_Detection」という名前の[IKEV2通知]レジストリ」のnotifyメッセージタイプ（16419）を割り当てました。"
    },
    {
      "indent": 0,
      "text": "11. Acknowledgements",
      "section_title": true,
      "ja": "11. 謝辞"
    },
    {
      "indent": 3,
      "text": "We would like to thank Hannes Tschofenig and Yaron Sheffer for their comments about Session Resumption.",
      "ja": "セッション再開に関するコメントについて、Hannes TschofenigとYaron Shefferに感謝します。"
    },
    {
      "indent": 3,
      "text": "Others who have contributed valuable comments are, in alphabetical order, Lakshminath Dondeti, Paul Hoffman, Tero Kivinen, Scott C Moonen, Magnus Nystrom, and Keith Welter.",
      "ja": "貴重なコメントを提供した他の人々は、アルファベット順に、ラクシュミナート・ドンデティ、ポール・ホフマン、テロ・キビネン、スコット・C・ムーナン、マグナス・ナイストロム、キース・ウェルターです。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC4555] Eronen, P., \"IKEv2 Mobility and Multihoming Protocol (MOBIKE)\", RFC 4555, June 2006.",
      "ja": "[RFC4555] Eronen、P。、「IKEV2モビリティおよびマルチホームプロトコル（MOBIKE）」、RFC 4555、2006年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC5996] Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen, \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC 5996, September 2010.",
      "ja": "[RFC5996] Kaufman、C.、Hoffman、P.、Nir、Y。、およびP. Eronen、「Internet Key Exchange Protocolバージョン2（IKEV2）」、RFC 5996、2010年9月。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC5723] Sheffer, Y. and H. Tschofenig, \"Internet Key Exchange Protocol Version 2 (IKEv2) Session Resumption\", RFC 5723, January 2010.",
      "ja": "[RFC5723] Sheffer、Y。およびH. Tschofenig、「Internet Key Exchange Protocol 2（IKEV2）セッション再開」、RFC 5723、2010年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6027] Nir, Y., \"IPsec Cluster Problem Statement\", RFC 6027, October 2010.",
      "ja": "[RFC6027] NIR、Y。、「IPSECクラスター問題ステートメント」、RFC 6027、2010年10月。"
    },
    {
      "indent": 3,
      "text": "[recovery] Detienne, F., Sethi, P., and Y. Nir, \"Safe IKE Recovery\", Work in Progress, July 2009.",
      "ja": "[回復] Detienne、F.、Sethi、P。、およびY. Nir、「Safe Ike Recovery」、2009年7月、進行中の作業。"
    },
    {
      "indent": 0,
      "text": "Appendix A. The Path Not Taken",
      "section_title": true,
      "ja": "付録A. パスはとられていません"
    },
    {
      "indent": 0,
      "text": "A.1. Initiating a New IKE SA",
      "section_title": true,
      "ja": "A.1. 新しいIke SAを開始します"
    },
    {
      "indent": 3,
      "text": "Instead of sending a QCD token, we could have the rebooted implementation start an Initial exchange with the peer, including the INITIAL_CONTACT notification. This would have the same effect, instructing the peer to erase the old IKE SA, as well as establishing a new IKE SA with fewer rounds.",
      "ja": "QCDトークンを送信する代わりに、再起動した実装で、initial_contact通知を含むピアとの初期交換を開始することができます。これには同じ効果があり、ピアに古いIke SAを消去するように指示し、より少ないラウンドで新しいIke SAを確立します。"
    },
    {
      "indent": 3,
      "text": "The disadvantage here is that in IKEv2, an authentication exchange MUST have a piggybacked Child SA set up. Since our use-case is such that the rebooted implementation does not have traffic flowing to the peer, there are no good selectors for such a Child SA.",
      "ja": "ここでの欠点は、IKEV2では、認証交換がピギーバックされたチャイルドSAを設定する必要があることです。私たちのユースケースは、再起動された実装にピアへのトラフィックが流れないようなものであるため、そのような子SAの良いセレクターはありません。"
    },
    {
      "indent": 3,
      "text": "Additionally, when authentication is asymmetric, such as when EAP is used, it is not possible for the rebooted implementation to initiate IKE.",
      "ja": "さらに、EAPが使用される場合など、認証が非対称である場合、再起動された実装がIKEを開始することは不可能です。"
    },
    {
      "indent": 0,
      "text": "A.2. SIR",
      "section_title": true,
      "ja": "A.2. お客様"
    },
    {
      "indent": 3,
      "text": "Another proposal that was considered for this work item is the SIR extension, which is described in [recovery]. Under that proposal, the non-rebooted peer sends a non-protected query to the possibly rebooted peer, asking whether the IKE SA exists. The peer replies with either a positive or negative response, and the absence of a positive response, along with the existence of a negative response, is taken as proof that the IKE SA has really been lost.",
      "ja": "この作業項目で考慮された別の提案は、[Recovery]に記載されているSIR拡張です。その提案の下で、再訓練されていないピアは、IKE SAが存在するかどうかを尋ねる、再起動されていないピアに保護されていないクエリを送信します。ピアは、肯定的または否定的な反応のいずれかで答え、否定的な反応の存在とともに肯定的な反応がないことは、IKE SAが本当に失われたという証拠とみなされます。"
    },
    {
      "indent": 3,
      "text": "The working group preferred the QCD proposal to this one.",
      "ja": "ワーキンググループは、これよりもQCD提案を好みました。"
    },
    {
      "indent": 0,
      "text": "A.3. Birth Certificates",
      "section_title": true,
      "ja": "A.3. 出生証明書"
    },
    {
      "indent": 3,
      "text": "Birth Certificates is a method of crash detection that has never been formally defined. Bill Sommerfeld suggested this idea in a mail to the IPsec mailing list on August 7, 2000, in a thread discussing methods of crash detection:",
      "ja": "出生証明書は、正式に定義されていないクラッシュ検出の方法です。ビル・ソマーフェルドは、2000年8月7日にIPSECメーリングリストへのメールで、クラッシュ検出の方法を議論するスレッドでこのアイデアを提案しました。"
    },
    {
      "indent": 7,
      "text": "If we have the system sign a \"birth certificate\" when it reboots (including a reboot time or boot sequence number), we could include that with a \"bad spi\" ICMP error and in the negotiation of the IKE SA.",
      "ja": "再起動時にシステムに「出生証明書」に署名している場合（再起動時間またはブートシーケンス番号を含む）、「悪いSPI」ICMPエラーとIKE SAの交渉にそれを含めることができます。"
    },
    {
      "indent": 3,
      "text": "We believe that this method would have some problems. First, it requires Alice to store the certificate, so as to be able to compare the public keys. That requires more storage than does a QCD token. Additionally, the public key operations needed to verify the self-signed certificates are more expensive for Alice.",
      "ja": "この方法にはいくつかの問題があると考えています。まず、パブリックキーを比較できるように、アリスに証明書を保存する必要があります。QCDトークンよりも多くのストレージが必要です。さらに、自己署名証明書を確認するために必要な公開キー操作は、アリスにとってより高価です。"
    },
    {
      "indent": 3,
      "text": "We believe that a symmetric-key operation such as proposed here is more light-weight and simple than that implied by the Birth Certificate idea.",
      "ja": "ここで提案されているような対称キー操作は、出生証明書のアイデアが暗示しているものよりも軽量でシンプルであると考えています。"
    },
    {
      "indent": 0,
      "text": "A.4. Reducing Liveness Check Length",
      "section_title": true,
      "ja": "A.4. 活性チェックの長さを削減します"
    },
    {
      "indent": 3,
      "text": "Some implementations require fewer retransmissions over a shorter period of time for cases of liveness check started because of an INVALID_SPI or INVALID_IKE_SPI notification.",
      "ja": "いくつかの実装では、無効なことまたはInvalid_ike_spi通知が原因で起動されるlivensionチェックの場合には、短い期間にわたって再送信を減らす必要があります。"
    },
    {
      "indent": 3,
      "text": "We believe that the default retransmission policy should represent a good balance between the need for a timely discovery of a dead peer, and a low probability of false detection. We expect the policy to be set to take the shortest time such that this probability achieves a certain target. Therefore, we believe that reducing the elapsed time and retransmission count may create an unacceptably high probability of false detection, and this can be triggered by a single INVALID_IKE_SPI notification.",
      "ja": "デフォルトの再送信ポリシーは、死んだピアのタイムリーな発見の必要性と誤検出の可能性が低いこととの良いバランスを表すべきであると考えています。この確率が特定のターゲットを達成するように、ポリシーが最短時間を取るように設定されると予想しています。したがって、経過時間と再送信数を減らすと、誤検出の容認できないほど高い確率が生じる可能性があると考えられており、これは単一の無効な_ike_spi通知によって引き起こされる可能性があると考えています。"
    },
    {
      "indent": 3,
      "text": "Additionally, even if the retransmission policy is reduced to, say, one minute, it is still a very noticeable delay from a human perspective, from the time that the gateway has come up (i.e., is able to respond with an INVALID_SPI or INVALID_IKE_SPI notification) and until the tunnels are active, or from the time the backup gateway has taken over until the tunnels are active. The use of QCD tokens can reduce this delay.",
      "ja": "さらに、たとえば1分間に再送信ポリシーが削減されたとしても、ゲートウェイが上昇した時点から、人間の観点から非常に顕著な遅延です（つまり、Invalid_spiまたはInvalid_ike_spi通知で応答することができます。）そして、トンネルがアクティブになるまで、またはバックアップゲートウェイが引き継がれてからトンネルがアクティブになるまで。QCDトークンを使用すると、この遅延を減らすことができます。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Yoav Nir (editor) Check Point Software Technologies, Ltd. 5 Hasolelim st. Tel Aviv 67897 Israel",
      "ja": "Yoav Nir（編集者）チェックポイントソフトウェアテクノロジー、Ltd。5 Hasolelim St。Tel Aviv 67897イスラエル"
    },
    {
      "indent": 3,
      "text": "EMail: ynir@checkpoint.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "David Wierbowski International Business Machines 1701 North Street Endicott, New York 13760 United States",
      "ja": "DavidWierbowski International Business Machines 1701 North Street Endicott、ニューヨーク13760米国"
    },
    {
      "indent": 3,
      "text": "EMail: wierbows@us.ibm.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Frederic Detienne Cisco Systems, Inc. De Kleetlaan, 7 Diegem B-1831 Belgium",
      "ja": "Frederic Detienne Cisco Systems、Inc。De Kleetlaan、7 Diegem B-1831ベルギー"
    },
    {
      "indent": 3,
      "text": "Phone: +32 2 704 5681\nEMail: fd@cisco.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Pratima Sethi Cisco Systems, Inc. O'Shaugnessy Road, 11 Bangalore, Karnataka 560027 India",
      "ja": "Pratima Sethi Cisco Systems、Inc。O'Shaugnessy Road、11 Bangalore、Karnataka 560027 India"
    },
    {
      "indent": 3,
      "text": "Phone: +91 80 4154 1654\nEMail: psethi@cisco.com",
      "raw": true,
      "ja": ""
    }
  ]
}