{
  "title": {
    "text": "RFC 6095 - Extending YANG with Language Abstractions",
    "ja": "RFC 6095 - 言語の抽象化でヤンを拡張します"
  },
  "number": 6095,
  "created_at": "2023-01-11 07:17:12.053001+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                       B. Linowski\nRequest for Comments: 6095                    TCS/Nokia Siemens Networks\nCategory: Experimental                                          M. Ersue\nISSN: 2070-1721                                   Nokia Siemens Networks\n                                                               S. Kuryla\n                                                    360 Treasury Systems\n                                                              March 2011",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Extending YANG with Language Abstractions",
      "ja": "言語の抽象化でヤンを拡張します"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "YANG -- the Network Configuration Protocol (NETCONF) Data Modeling Language -- supports modeling of a tree of data elements that represent the configuration and runtime status of a particular network element managed via NETCONF. This memo suggests enhancing YANG with supplementary modeling features and language abstractions with the aim to improve the model extensibility and reuse.",
      "ja": "Yang-ネットワーク構成プロトコル（NetConf）データモデリング言語 - は、NetConfを介して管理された特定のネットワーク要素の構成とランタイムステータスを表すデータツリーのモデリングをサポートします。このメモは、モデルの拡張性と再利用を改善することを目的とした補足モデリング機能と言語抽象化を備えたYangを強化することを提案しています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。試験、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are a candidate for any level of Internet Standard; see Section 2 of RFC 5741.",
      "ja": "このドキュメントは、インターネットコミュニティの実験プロトコルを定義しています。このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、あらゆるレベルのインターネット標準の候補者ではありません。RFC 5741のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at http://www.rfc-editor.org/info/rfc6095.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、http：//www.rfc-editor.org/info/rfc6095で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "Copyright（c）2011 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（http://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、単純化されたBSDライセンスで説明されているように保証なしで提供される簡略化されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.1.  Key Words  . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.2.  Motivation . . . . . . . . . . . . . . . . . . . . . . . .  3\n  1.3.  Modeling Improvements with Language Abstractions . . . . .  5\n  1.4.  Design Approach  . . . . . . . . . . . . . . . . . . . . .  6\n  1.5.  Modeling Resource Models with YANG . . . . . . . . . . . .  6\n    1.5.1.  Example of a Physical Network Resource Model . . . . .  6\n    1.5.2.  Modeling Entity MIB Entries as Physical Resources  . . 12\n2.  Complex Types  . . . . . . . . . . . . . . . . . . . . . . . . 15\n  2.1.  Definition . . . . . . . . . . . . . . . . . . . . . . . . 15\n  2.2.  complex-type Extension Statement . . . . . . . . . . . . . 15\n  2.3.  instance Extension Statement . . . . . . . . . . . . . . . 17\n  2.4.  instance-list Extension Statement  . . . . . . . . . . . . 18\n  2.5.  extends Extension Statement  . . . . . . . . . . . . . . . 19\n  2.6.  abstract Extension Statement . . . . . . . . . . . . . . . 19\n  2.7.  XML Encoding Rules . . . . . . . . . . . . . . . . . . . . 20\n  2.8.  Type Encoding Rules  . . . . . . . . . . . . . . . . . . . 20\n  2.9.  Extension and Feature Definition Module  . . . . . . . . . 21\n  2.10. Example Model for Complex Types  . . . . . . . . . . . . . 24\n  2.11. NETCONF Payload Example  . . . . . . . . . . . . . . . . . 25\n  2.12. Update Rules for Modules Using Complex Types . . . . . . . 26\n  2.13. Using Complex Types  . . . . . . . . . . . . . . . . . . . 26\n    2.13.1. Overriding Complex Type Data Nodes . . . . . . . . . . 26\n    2.13.2. Augmenting Complex Types . . . . . . . . . . . . . . . 27\n    2.13.3. Controlling the Use of Complex Types . . . . . . . . . 28\n3.  Typed Instance Identifier  . . . . . . . . . . . . . . . . . . 29\n  3.1.  Definition . . . . . . . . . . . . . . . . . . . . . . . . 29\n  3.2.  instance-type Extension Statement  . . . . . . . . . . . . 29\n  3.3.  Typed Instance Identifier Example  . . . . . . . . . . . . 30\n4.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 31\n5.  Security Considerations  . . . . . . . . . . . . . . . . . . . 31\n   6.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 32\n7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n  7.1.  Normative References . . . . . . . . . . . . . . . . . . . 32\n  7.2.  Informative References . . . . . . . . . . . . . . . . . . 32\nAppendix A.  YANG Modules for Physical Network Resource Model\n             and Hardware Entities Model . . . . . . . . . . . . . 34\nAppendix B.  Example YANG Module for the IPFIX/PSAMP Model . . . . 40\n  B.1.  Modeling Improvements for the IPFIX/PSAMP Model with\n        Complex Types and Typed Instance Identifiers . . . . . . . 40\n  B.2.  IPFIX/PSAMP Model with Complex Types and Typed\n        Instance Identifiers . . . . . . . . . . . . . . . . . . . 41",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "YANG -- the NETCONF Data Modeling Language [RFC6020] -- supports modeling of a tree of data elements that represent the configuration and runtime status of a particular network element managed via NETCONF. This document defines extensions for the modeling language YANG as new language statements, which introduce language abstractions to improve the model extensibility and reuse. The document reports from modeling experience in the telecommunication industry and gives model examples from an actual network management system to highlight the value of proposed language extensions, especially class inheritance and recursiveness. The language extensions defined in this document have been implemented with two open source tools. These tools have been used to validate the model examples through the document. If this experimental specification results in successful usage, it is possible that the language extensions defined herein could be updated to incorporate implementation and deployment experience, then pursued on the Standards Track, possibly as part of a future version of YANG.",
      "ja": "Yang -NetConf Data Modeling Language [RFC6020]  - は、NetConfを介して管理された特定のネットワーク要素の構成とランタイムステータスを表すデータ要素のツリーのモデリングをサポートしています。このドキュメントでは、モデリング言語Yangの拡張機能を新しい言語ステートメントとして定義し、モデルの拡張と再利用を改善するための言語の抽象化を導入します。このドキュメントは、電気通信業界でのモデリングエクスペリエンスから報告し、実際のネットワーク管理システムのモデル例を示して、提案された言語拡張、特にクラスの継承と再帰の価値を強調します。このドキュメントで定義されている言語拡張機能は、2つのオープンソースツールで実装されています。これらのツールは、ドキュメントを介してモデルの例を検証するために使用されています。この実験仕様により、使用が成功した場合、本明細書で定義されている言語拡張機能を更新して、実装と展開エクスペリエンスを組み込むことができ、おそらくヤンの将来のバージョンの一部として標準トラックで追求される可能性があります。"
    },
    {
      "indent": 0,
      "text": "1.1. Key Words",
      "section_title": true,
      "ja": "1.1. キーワード"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14, [RFC2119].",
      "ja": "キーワードは「必須」、「必要」、「必須」、「shall」、「shall \"、\" bood \"、\" low \"of\" bould \"、\" becommended \"、\" bodement \"、\" may \"、\" optional「この文書では、BCP 14、[RFC2119]に記載されているように解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Motivation",
      "section_title": true,
      "ja": "1.2. 動機"
    },
    {
      "indent": 3,
      "text": "Following are non-exhaustive motivation examples highlighting usage scenarios for language abstractions.",
      "ja": "以下は、言語の抽象化の使用シナリオを強調する非網羅的な動機の例です。"
    },
    {
      "indent": 3,
      "text": "o Many systems today have a Management Information Base (MIB) that in effect is organized as a tree build of recursively nested container nodes. For example, the physical resources in the ENTITY-MIB conceptually form a containment tree. The index entPhysicalContainedIn points to the containing entity in a flat list. The ability to represent nested, recursive data structures of arbitrary depth would enable the representation of the primary containment hierarchy of physical entities as a node tree in the server MIB and in the NETCONF payload.",
      "ja": "o 現在、多くのシステムには、再帰的にネストされたコンテナノードのツリービルドとして編成されている管理情報ベース（MIB）があります。たとえば、エンティティミブの物理リソースは、概念的に封じ込めツリーを形成します。インデックスは、フラットリスト内の含有エンティティを指します。任意の深さのネストされた再帰データ構造を表す能力により、サーバーMIBおよびNetConfペイロードのノードツリーとしての物理エンティティの主要な封じ込め階層の表現が可能になります。"
    },
    {
      "indent": 3,
      "text": "o A manager scanning the network in order to update the state of an inventory management system might be only interested in data structures that represent a specific type of hardware. Such a manager would then look for entities that are of this specific type, including those that are an extension or specialization of this type. To support this use case, it is helpful to bear the corresponding type information within the data structures, which describe the network element hardware.",
      "ja": "o 在庫管理システムの状態を更新するためにネットワークをスキャンするマネージャーは、特定のタイプのハードウェアを表すデータ構造にのみ関心がある場合があります。そのようなマネージャーは、このタイプの拡張または専門化であるものを含む、このタイプのエンティティを探すでしょう。このユースケースをサポートするために、ネットワーク要素ハードウェアを説明するデータ構造内の対応するタイプ情報を担います。"
    },
    {
      "indent": 3,
      "text": "o A system that is managing network elements is concerned, e.g., with managed objects of type \"plug-in modules\" that have a name, a version, and an activation state. In this context, it is useful to define the \"plug-in module\" as a concept that is supposed to be further detailed and extended by additional concrete model elements. In order to realize such a system, it is worthwhile to model abstract entities, which enable reuse and ease concrete refinements of that abstract entity in a second step.",
      "ja": "o ネットワーク要素を管理しているシステムは、たとえば、名前、バージョン、アクティベーション状態を持つタイプ「プラグインモジュール」の管理されたオブジェクトを伴います。これに関連して、「プラグインモジュール」を、追加の具体的なモデル要素によってさらに詳細に拡張されるはずの概念として定義することが有用です。そのようなシステムを実現するためには、抽象的なエンティティをモデル化する価値があります。これにより、2番目のステップでその抽象的なエンティティの具体的な改良を再利用および緩和できます。"
    },
    {
      "indent": 3,
      "text": "o As particular network elements have specific types of components that need to be managed (OS images, plug-in modules, equipment, etc.), it should be possible to define concrete types, which describe the managed object precisely. By using type-safe extensions of basic concepts, a system in the manager role can safely and explicitly determine that e.g., the \"equipment\" is actually of type \"network card\".",
      "ja": "o 特定のネットワーク要素には、管理する必要がある特定のタイプのコンポーネント（OS画像、プラグインモジュール、機器など）があるため、管理されたオブジェクトを正確に記述するコンクリートタイプを定義できるはずです。基本概念のタイプセーフ拡張機能を使用することにより、マネージャーの役割のシステムは、「機器」が実際に「ネットワークカード」というタイプであることを安全かつ明示的に決定できます。"
    },
    {
      "indent": 3,
      "text": "o Currently, different SDOs are working on the harmonization of their management information models. Often, a model mapping or transformation between systems becomes necessary. The harmonization of the models is done e.g., by mapping of the two models on the object level or integrating an object hierarchy into an existing information model. On the one hand, extending YANG with language abstractions can simplify the adoption of IETF resource models by other SDOs and facilitate the alignment with other SDOs' resource models (e.g., TM Forum SID [SID_V8]). On the other hand, the proposed YANG extensions can enable the utilization of the YANG modeling language in other SDOs, which usually model complex management systems in a top-down manner and use high-level language features frequently.",
      "ja": "o 現在、さまざまなSDOが管理情報モデルの調和に取り組んでいます。多くの場合、システム間のモデルマッピングまたは変換が必要になります。モデルの調和は、たとえば、オブジェクトレベル上の2つのモデルをマッピングするか、オブジェクト階層を既存の情報モデルに統合することによって行われます。一方では、言語の抽象化でYangを拡張すると、他のSDOによるIETFリソースモデルの採用を簡素化し、他のSDOのリソースモデルとの整合を促進できます（たとえば、TMフォーラムSID [SID_V8]）。一方、提案されているヤン拡張は、他のSDOでヤンモデリング言語を利用できるようにすることができます。これは通常、複雑な管理システムをトップダウンの方法でモデル化し、高レベルの言語機能を頻繁に使用します。"
    },
    {
      "indent": 3,
      "text": "This memo specifies additional modeling features for the YANG language in the area of structured model abstractions, typed references, as well as recursive data structures, and it discusses how these new features can improve the modeling capabilities of YANG.",
      "ja": "このメモは、構造化されたモデルの抽象化、タイプされた参照、および再帰データ構造の分野におけるヤン言語の追加のモデリング機能を指定し、これらの新機能がヤンのモデリング機能を改善する方法について説明します。"
    },
    {
      "indent": 3,
      "text": "Section 1.5.1 contains a physical resource model that deals with some of the modeling challenges illustrated above. Section 1.5.2 gives an example that uses the base classes defined in the physical resource model and derives a model for physical entities defined in the Entity MIB.",
      "ja": "セクション1.5.1には、上記のモデリングの課題のいくつかを扱う物理リソースモデルが含まれています。セクション1.5.2は、物理リソースモデルで定義された基本クラスを使用し、エンティティMIBで定義された物理エンティティのモデルを導出する例を示します。"
    },
    {
      "indent": 0,
      "text": "1.3. Modeling Improvements with Language Abstractions",
      "section_title": true,
      "ja": "1.3. 言語の抽象化によるモデリングの改善"
    },
    {
      "indent": 3,
      "text": "As an enhancement to YANG 1.0, complex types and typed instance identifiers provide different technical improvements on the modeling level:",
      "ja": "Yang 1.0の強化として、複雑なタイプと型付けされたインスタンス識別子は、モデリングレベルで異なる技術的改善を提供します。"
    },
    {
      "indent": 3,
      "text": "o In case the model of a system that should be managed with NETCONF makes use of inheritance, complex types enable an almost one-to-one mapping between the classes in the original model and the YANG module.",
      "ja": "o NetConfで管理する必要があるシステムのモデルが継承を使用する場合、複雑なタイプにより、元のモデルとYangモジュールのクラス間のほぼ1対1のマッピングが可能になります。"
    },
    {
      "indent": 3,
      "text": "o Typed instance identifiers allow representing associations between the concepts in a type-safe way to prevent type errors caused by referring to data nodes of incompatible types. This avoids referring to a particular location in the MIB. Referring to a particular location in the MIB is not mandated by the domain model.",
      "ja": "o 型付けされたインスタンス識別子は、互換性のないタイプのデータノードを参照することによって引き起こされるタイプエラーを防ぐために、タイプセーフの方法で概念間の関連を表すことができます。これは、MIBの特定の場所を参照することを避けます。MIBの特定の場所を参照することは、ドメインモデルによって義務付けられていません。"
    },
    {
      "indent": 3,
      "text": "o Complex types allow defining complete, self-contained type definitions. It is not necessary to explicitly add a key statement to lists, which use a grouping that defines the data nodes.",
      "ja": "o 複雑なタイプにより、完全で自己完結型のタイプ定義を定義できます。データノードを定義するグループを使用するリストに重要なステートメントを明示的に追加する必要はありません。"
    },
    {
      "indent": 3,
      "text": "o Complex types simplify concept refinement by extending a base complex type and make it superfluous to represent concept refinements with workarounds such as huge choice-statements with complex branches.",
      "ja": "o 複雑なタイプは、ベースの複雑なタイプを拡張し、複雑な枝を持つ巨大な選択ステートメントなどの回避策を使用して概念の改良を表すように不必要にすることにより、概念の改良を簡素化します。"
    },
    {
      "indent": 3,
      "text": "o Abstract complex types ensure correct usage of abstract concepts by enforcing the refinement of a common set of properties before instantiation.",
      "ja": "o 抽象的な複雑なタイプにより、インスタンス化する前に共通のプロパティセットの改良を実施することにより、抽象概念の正しい使用法が保証されます。"
    },
    {
      "indent": 3,
      "text": "o Complex types allow defining recursive structures. This enables representing complex structures of arbitrary depth by nesting instances of basic complex types that may contain themselves.",
      "ja": "o 複雑なタイプにより、再帰構造を定義できます。これにより、自分自身を含む可能性のある基本的な複雑なタイプのインスタンスをネストすることにより、任意の深さの複雑な構造を表すことができます。"
    },
    {
      "indent": 3,
      "text": "o Complex types avoid introducing metadata types (e.g., type code enumerations) and metadata leafs (e.g., leafs containing a type code) to indicate which concrete type of object is actually represented by a generic container in the MIB. This also avoids explicitly ruling out illegal use of subtype-specific properties in generic containers.",
      "ja": "o 複雑なタイプは、メタデータタイプ（例：タイプコード列挙）とメタデータリーフ（タイプコードを含むリーフ）を導入して、どのコンクリートタイプのオブジェクトがMIBの一般的な容器で表されるかを示すことを避けます。これにより、ジェネリックコンテナでのサブタイプ固有の特性の違法使用を明示的に除外することも避けています。"
    },
    {
      "indent": 3,
      "text": "o Complex type instances include the type information in the NETCONF payload. This allows determining the actual type of an instance during the NETCONF payload parsing and avoids the use in the model of additional leafs, which provide the type information as content.",
      "ja": "o 複雑なタイプインスタンスには、NetConfペイロードのタイプ情報が含まれます。これにより、NetConfのペイロード解析中にインスタンスの実際のタイプを決定することができ、追加のリーフのモデルでの使用を避けることができます。"
    },
    {
      "indent": 3,
      "text": "o Complex types may be declared explicitly as optional features, which is not possible when the actual type of an entity represented by a generic container is indicated with a type code enumeration.",
      "ja": "o 複雑なタイプは、オプションの機能として明示的に宣言される場合があります。これは、一般的なコンテナで表されるエンティティの実際のタイプがタイプコード列挙で示されている場合は不可能です。"
    },
    {
      "indent": 3,
      "text": "Appendix B, \"Example YANG Module for the IPFIX/PSAMP Model\", lists technical improvements for modeling with complex types and typed instance identifiers and exemplifies the usage of the proposed YANG extensions based on the IP Flow Information Export (IPFIX) / Packet Sampling (PSAMP) configuration model in [IPFIXCONF].",
      "ja": "付録B、「IPFIX / PSAMPモデルのヤンモジュールの例」には、複雑なタイプとタイプされたインスタンス識別子を使用したモデリングの技術的改善をリストし、IPフロー情報エクスポート（IPFIX） /パケットサンプリング（psamp）[ipfixconf]の構成モデル。"
    },
    {
      "indent": 0,
      "text": "1.4. Design Approach",
      "section_title": true,
      "ja": "1.4. 設計アプローチ"
    },
    {
      "indent": 3,
      "text": "The proposed additional features for YANG in this memo are designed to reuse existing YANG statements whenever possible. Additional semantics is expressed by an extension that is supposed to be used as a substatement of an existing statement.",
      "ja": "このメモでYangの提案された追加機能は、可能な限り既存のYangステートメントを再利用するように設計されています。追加のセマンティクスは、既存のステートメントの代替として使用されるはずの拡張によって表されます。"
    },
    {
      "indent": 3,
      "text": "The proposed features don't change the semantics of models that is valid with respect to the YANG specification [RFC6020].",
      "ja": "提案された機能は、Yang仕様[RFC6020]に関して有効なモデルのセマンティクスを変更しません。"
    },
    {
      "indent": 0,
      "text": "1.5. Modeling Resource Models with YANG",
      "section_title": true,
      "ja": "1.5. Yangを使用したリソースモデルのモデリング"
    },
    {
      "indent": 0,
      "text": "1.5.1. Example of a Physical Network Resource Model",
      "section_title": true,
      "ja": "1.5.1. 物理ネットワークリソースモデルの例"
    },
    {
      "indent": 3,
      "text": "The diagram below depicts a portion of an information model for manageable network resources used in an actual network management system.",
      "ja": "以下の図は、実際のネットワーク管理システムで使用される管理可能なネットワークリソースの情報モデルの一部を示しています。"
    },
    {
      "indent": 3,
      "text": "Note: The referenced model (UDM, Unified Data Model) is based on key resource modeling concepts from [SID_V8] and is compliant with selected parts of SID Resource Abstract Business Entities domain [UDM].",
      "ja": "注：参照されたモデル（UDM、Unified Data Model）は、[SID_V8]の主要なリソースモデリングの概念に基づいており、SID Resource Abstract Business Entities Domain [UDM]の選択された部分に準拠しています。"
    },
    {
      "indent": 3,
      "text": "The class diagram in Figure 1 and the corresponding YANG module excerpt focus on basic resource (\"Resource\" and the distinction between logical and physical resources) and hardware abstractions (\"Hardware\", \"Equipment\", and \"EquipmentHolder\"). Class attributes were omitted to achieve decent readability.",
      "ja": "図1のクラス図と対応するYangモジュールの抜粋は、基本的なリソース（「リソース」と論理リソースと物理リソースの区別）とハードウェアの抽象化（「ハードウェア」、「機器」、「機器所有者」）に焦点を当てています。クラス属性は、適切な読みやすさを実現するために省略されました。"
    },
    {
      "indent": 0,
      "text": "+--------+\n|Resource|\n+--------+\n /\\   /\\\n --   --\n |    |\n |  +---------------+\n |  |LogicalResource|\n |  +---------------+\n |\n | +--------+\n | |Physical|      +-----------+\n '-|Resource|<|-+-|PhysicalLink|\n   +---- ---+   | +------------+\n                |     |0..* physicalLink\n                |     |                                       equipment\n                |     |                                       Holder\n                |     |                                       0..*\n                |     |                                       +-------+\n                |     |0..* hardware                          |       |\n                | +--------+     +---------------+     +---------+    |\n                '-|Hardware|<|-+-|ManagedHardware|<|-+-|Equipment|<>--+\n                  +--------+   | +---------------+   | | Holder  |0..1\n                      <>       |                     | +---------+\n                  0..1|        |                     |   <>\n                      |        |                     |   |0..* equipment\n                      |        |                     |   |     Holder\n                      |        |                     |   |\n                      |        |                     |   |0..* equipment\n                      |        |                     |   |\n                      |        |                     |   |    equipment\n                      |        |                     |   |    0..*\n                      |        |                     |   |    +-------+\n                      |        |                     |   |    |       |\n                      |        |                     | +---------+    |\n                      |        |                     '-|Equipment|<>--+\n                      |        |                       +---------+0..1\n                      |        |                    compositeEquipment\n                      |        |\n                      |        | +-----------------+\n                      |        '-|PhysicalConnector|----+0..* source\n                      '----------+-----------------+    |     Physical\n           physicalConnector 0..*           |           |     Connector\n                                            |           |\n                                            +-----------+\n                                            0..* targetPhysicalConnector",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 1: Physical Network Resource Model",
      "ja": "図1：物理ネットワークリソースモデル"
    },
    {
      "indent": 3,
      "text": "Since this model is an abstraction of network-element-specific MIB topologies, modeling it with YANG creates some challenges. Some of these challenges and how they can be addressed with complex types are explained below:",
      "ja": "このモデルはネットワーク要素固有のMIBトポロジの抽象化であるため、Yangでモデル化すると課題が生じます。これらの課題のいくつかと複雑なタイプでそれらに対処する方法を以下で説明します。"
    },
    {
      "indent": 3,
      "text": "o Modeling of abstract concepts: Classes like \"Resource\" represent concepts that primarily serve as a base class for derived classes. With complex types, such an abstract concept could be represented by an abstract complex type (see \"complex-type extension statement\" and \"abstract extension statement\").",
      "ja": "o 抽象的な概念のモデリング：「リソース」のようなクラスは、主に派生クラスの基本クラスとして機能する概念を表します。複雑なタイプでは、そのような抽象的な概念は、抽象的な複雑なタイプで表される可能性があります（「複雑なタイプの拡張ステートメント」および「抽象的拡張ステートメント」を参照）。"
    },
    {
      "indent": 3,
      "text": "o Class Inheritance: Information models for complex management domains often use class inheritance to create specialized classes like \"PhysicalConnector\" from a more generic base class (here, \"Hardware\"), which itself might inherit from another base class (\"PhysicalResource\"), etc. Complex types allow creating enhanced versions of an existing (abstract or concrete) base type via an extension (see \"extends extension statement\").",
      "ja": "o クラスの継承：複雑な管理ドメインの情報モデルは、クラス継承を使用して、より一般的なベースクラス（ここ、「ハードウェア」）から「物理的コネクタ」などの専門クラスを作成することがよくあります。。複雑なタイプにより、拡張機能を介して既存の（抽象またはコンクリート）ベースタイプの拡張バージョンを作成できます（「拡張ステートメント」を参照）。"
    },
    {
      "indent": 3,
      "text": "o Recursive containment: In order to specify containment hierarchies, models frequently contain different aggregation associations, in which the target (contained element) is either the containing class itself or a base class of the containing class. In the model above, the recursive containment of \"EquipmentHolder\" is an example of such a relationship (see the description for the \"complex-type EquipmentHolder\" in the example model \"udmcore\" below).",
      "ja": "o 再帰的封じ込め：封じ込め階層を指定するために、モデルは頻繁に異なる集約関連を含む。ターゲット（含まれる要素）は、含まれるクラス自体または含有クラスの基本クラスのいずれかです。上記のモデルでは、「機器所有者」の再帰的封じ込めは、そのような関係の例です（以下のモデル「UDMCore」の例の「複雑なタイプの機器所有者」の説明を参照）。"
    },
    {
      "indent": 3,
      "text": "o Complex types support such a containment by using a complex type (or one of its ancestor types) as the type of an instance or instance list that is part of its definition (see \"instance(-list) extension statement\").",
      "ja": "o 複雑なタイプは、その定義の一部であるインスタンスまたはインスタンスリストのタイプとして複雑なタイプ（またはその祖先タイプの1つ）を使用することにより、そのような封じ込めをサポートします（「インスタンス（-List）拡張ステートメント」を参照）。"
    },
    {
      "indent": 3,
      "text": "o Reference relationships: A key requirement on large models for network domains with many related managed objects is the ability to define inter-class associations that represent essential relationships between instances of such a class. For example, the relationship between \"PhysicalLink\" and \"Hardware\" tells which physical link is connecting which hardware resources. It is important to notice that this kind of relationship does not mandate any particular location of the two connected hardware instances in any MIB module. Such containment-agnostic relationships can be represented by a typed instance identifier that embodies one direction of such an association (see Section 3, \"Typed Instance Identifier\").",
      "ja": "o 参照関係：多くの関連する管理されたオブジェクトを持つネットワークドメインの大規模モデルの重要な要件は、そのようなクラスのインスタンス間の本質的な関係を表すクラス間関連を定義する機能です。たとえば、「PhysicAllink」と「ハードウェア」の関係は、どのハードウェアリソースを接続している物理リンクを示しています。この種の関係は、MIBモジュールの2つの接続されたハードウェアインスタンスの特定の場所を義務付けていないことに注意することが重要です。このような封じ込めと存在する関係は、そのような関連性の1つの方向を具体化する型付けされたインスタンス識別子で表すことができます（セクション3、「型インスタンス識別子」を参照）。"
    },
    {
      "indent": 3,
      "text": "The YANG module excerpt below shows how the challenges listed above can be addressed by the Complex Types extension (module import prefix \"ct:\"). The complete YANG module for the physical resource model in Figure 1 can be found in Appendix A, \"YANG Modules for Physical Network Resource Model and Hardware Entities Model\".",
      "ja": "以下のYangモジュールの抜粋は、上記の課題が複雑なタイプの拡張機能（モジュールインポートプレフィックス「CT：」）によってどのように対処できるかを示しています。図1の物理リソースモデルの完全なYangモジュールは、付録A、「物理ネットワークリソースモデルおよびハードウェアエンティティモデルのYangモジュール」にあります。"
    },
    {
      "indent": 3,
      "text": "Note: The YANG extensions proposed in this document have been implemented as the open source tools \"Pyang Extension for Complex Types\" [Pyang-ct], [Pyang], and \"Libsmi Extension for Complex Types\" [Libsmi]. All model examples in the document have been validated with the tools Pyang-ct and Libsmi.",
      "ja": "注：このドキュメントで提案されているYang拡張機能は、オープンソースツール「複雑なタイプのPyang拡張」[Pyang-Ct]、[Pyang]、および「複雑なタイプのLibsmi拡張」[libsmi]として実装されています。ドキュメント内のすべてのモデルの例は、Pyang-CTおよびLibsmiツールで検証されています。"
    },
    {
      "indent": 0,
      "text": "<CODE BEGINS>",
      "ja": "<code begins>"
    },
    {
      "indent": 0,
      "text": "module udmcore {",
      "ja": "モジュールudmcore {"
    },
    {
      "indent": 3,
      "text": "namespace \"http://example.com/udmcore\"; prefix \"udm\";",
      "ja": "namespace \"http://example.com/udmcore\";プレフィックス「udm」;"
    },
    {
      "indent": 3,
      "text": "import ietf-complex-types {prefix \"ct\"; }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "// Basic complex types...",
      "ja": "//基本的な複雑なタイプ..."
    },
    {
      "indent": 3,
      "text": "ct:complex-type PhysicalResource {\n   ct:extends Resource;\n     ct:abstract true;\n     // ...\n     leaf serialNumber {\n      type string;\n      description \"'Manufacturer-allocated part number' as\n        defined in SID, e.g., the part number of a fiber link\n        cable.\";\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   ct:complex-type Hardware {\n      ct:extends PhysicalResource;\n        ct:abstract true;\n        // ...\n       leaf-list physicalLink {\n          type instance-identifier {ct:instance-type PhysicalLink;}\n       }\n       ct:instance-list containedHardware {\n       ct:instance-type Hardware;\n}\n       ct:instance-list physicalConnector {\n       ct:instance-type PhysicalConnector;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "}\n   }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ct:complex-type PhysicalLink {\n    ct:extends PhysicalResource;\n    // ...\n    leaf-list hardware {\n       type instance-identifier {ct:instance-type Hardware;}\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ct:complex-type ManagedHardware {\n   ct:extends Hardware;\n     ct:abstract true;\n     // ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ct:complex-type PhysicalConnector {\n   ct:extends Hardware;\n     leaf location {type string;}\n     // ...\n   leaf-list sourcePhysicalConnector {\n      type instance-identifier {ct:instance-type PhysicalConnector;}\n   }\n   leaf-list targetPhysicalConnector {\n      type instance-identifier {ct:instance-type PhysicalConnector;}\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   ct:complex-type Equipment {\n      ct:extends ManagedHardware;\n        // ...\n      ct:instance-list equipment {\n    ct:instance-type Equipment;\n}\n   }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "   ct:complex-type EquipmentHolder {\n      ct:extends ManagedHardware;\n      description \"In the SID V8 definition, this is a class based on\n        the M.3100 specification.  A base class that represents physical\n        objects that are both manageable as well as able to host,\n        hold, or contain other physical objects.  Examples of physical\n        objects that can be represented by instances of this object\n        class are Racks, Chassis, Cards, and Slots.\n        A piece of equipment with the primary purpose of containing\n        other equipment.\";\n        leaf vendorName {type string;}\n        // ...\n      ct:instance-list equipment {\n       ct:instance-type Equipment;\n        }\n      ct:instance-list equipmentHolder {\n       ct:instance-type EquipmentHolder;\n       }\n   }\n   // ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "<CODE ENDS>",
      "ja": "<コードエンド>"
    },
    {
      "indent": 0,
      "text": "1.5.2. Modeling Entity MIB Entries as Physical Resources",
      "section_title": true,
      "ja": "1.5.2. エンティティMIBエントリを物理リソースとしてモデリングします"
    },
    {
      "indent": 3,
      "text": "The physical resource module described above can now be used to model physical entities as defined in the Entity MIB [RFC4133]. For each physical entity class listed in the \"PhysicalClass\" enumeration, a complex type is defined. Each of these complex types extends the most specific complex type already available in the physical resource module. For example, the type \"HWModule\" extends the complex type \"Equipment\" as a hardware module. Physical entity properties that should be included in a physical entity complex type are combined in a grouping, which is then used in each complex type definition of an entity.",
      "ja": "上記の物理リソースモジュールを使用して、エンティティMIB [RFC4133]で定義されている物理エンティティをモデル化できるようになりました。「物理クラス」列挙にリストされている各物理エンティティクラスについて、複雑なタイプが定義されています。これらの複雑なタイプのそれぞれは、物理リソースモジュールですでに利用可能な最も特定の複雑なタイプを拡張します。たとえば、タイプ「hwmodule」は、複雑なタイプの「機器」をハードウェアモジュールとして拡張します。物理エンティティの複雑なタイプに含める必要がある物理エンティティプロパティは、グループに組み合わされ、エンティティの各複雑なタイプ定義で使用されます。"
    },
    {
      "indent": 3,
      "text": "This approach has following benefits:",
      "ja": "このアプローチには次の利点があります。"
    },
    {
      "indent": 3,
      "text": "o The definition of the complex types for hardware entities becomes compact as many of the features can be reused from the basic complex type definition.",
      "ja": "o 多くの機能を基本的な複雑なタイプ定義から再利用できるため、ハードウェアエンティティの複雑なタイプの定義はコンパクトになります。"
    },
    {
      "indent": 3,
      "text": "o Physical entities are modeled in a consistent manner as predefined concepts are extended.",
      "ja": "o 定義された概念が拡張されるため、物理エンティティは一貫した方法でモデル化されます。"
    },
    {
      "indent": 3,
      "text": "o Entity-MIB-specific attributes as well as vendor-specific attributes can be added without having to define separate extension data nodes.",
      "ja": "o Entity-MIB固有の属性とベンダー固有の属性は、個別の拡張データノードを定義することなく追加できます。"
    },
    {
      "indent": 3,
      "text": "                         Module udmcore  :  Module hardware-entities\n                                         :\n                             equipment   :\n                             Holder      :\n                             0..*        :\n                             +-------+   :\n                             |       |   :\n+---------------+     +---------+    |   :\n|ManagedHardware|<|-+-|Equipment|<>--+   :\n+---------------+   | | Holder  |0..1    :     +-------+\n                    | |         |<|---------+--|Chassis|\n                    | +---------+        :  |  +-------+\n                    |   <>               :  |\n                    |   |0..* equipment  :  |  +---------+\n                    |   |     Holder     :  '--|Container|\n                    |   |                :     +---------+\n                    |   |0..* equipment  :\n                    |   |                :\n                    |   |    equipment   :\n                    |   |    0..*        :\n                    |   |    +-------+   :\n                    |   |    |       |   :\n                    | +---------+    |   :\n                    '-|Equipment|<>--+   :     +--------+\n                      |         |<|---------+--|HWModule|\n                      +---------+        :  |  +--------+\n                   compositeEquipment    :  |\n                                         :  |  +---------+\n                                         :  |--|Backplane|\n                                         :     +---------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 2: Hardware Entities Model",
      "ja": "図2：ハードウェアエンティティモデル"
    },
    {
      "indent": 3,
      "text": "Below is an excerpt of the corresponding YANG module using complex types to model hardware entities. The complete YANG module for the Hardware Entities model in Figure 2 can be found in Appendix A, \"YANG Modules for Physical Network Resource Model and Hardware Entities Model\".",
      "ja": "以下は、複雑なタイプを使用してハードウェアエンティティをモデル化する対応するYangモジュールの抜粋です。図2のハードウェアエンティティモデルの完全なYangモジュールは、付録A、「物理ネットワークリソースモデルおよびハードウェアエンティティモデルのYangモジュール」にあります。"
    },
    {
      "indent": 0,
      "text": "<CODE BEGINS>",
      "ja": "<code begins>"
    },
    {
      "indent": 0,
      "text": "module hardware-entities {",
      "ja": "モジュールハードウェアエンティティ{"
    },
    {
      "indent": 3,
      "text": "namespace \"http://example.com/hardware-entities\"; prefix \"hwe\";",
      "ja": "namespace \"http://example.com/hardware-entities\";プレフィックス「HWE」;"
    },
    {
      "indent": 3,
      "text": "import ietf-yang-types {prefix \"yt\";}\nimport ietf-complex-types {prefix \"ct\";}\nimport udmcore {prefix \"uc\";}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "grouping PhysicalEntityProperties {\n   // ...\n   leaf mfgDate {type yang:date-and-time; }\n   leaf-list uris {type string; }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// Physical entities representing equipment",
      "ja": "//機器を表す物理エンティティ"
    },
    {
      "indent": 3,
      "text": "ct:complex-type HWModule {\n   ct:extends uc:Equipment;\n   description \"Complex type representing module entries\n                (entPhysicalClass = module(9)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "// ...",
      "ja": "// ..."
    },
    {
      "indent": 3,
      "text": "// Physical entities representing equipment holders",
      "ja": "//機器保有者を表す物理エンティティ"
    },
    {
      "indent": 3,
      "text": "ct:complex-type Chassis {\n   ct:extends uc:EquipmentHolder;\n   description \"Complex type representing chassis entries\n                (entPhysicalClass = chassis(3)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": " // ... }",
      "ja": "// ...}"
    },
    {
      "indent": 0,
      "text": "<CODE ENDS>\u0007\u0007\u00072. Complex Types",
      "ja": "<コードエンド> 2。複雑なタイプ"
    },
    {
      "indent": 0,
      "text": "2.1. Definition",
      "section_title": true,
      "ja": "2.1. 意味"
    },
    {
      "indent": 3,
      "text": "YANG type concept is currently restricted to simple types, e.g., restrictions of primitive types, enumerations, or union of simple types.",
      "ja": "Yangタイプの概念は現在、単純なタイプ、例えば、原始的なタイプ、列挙、または単純なタイプの結合に制限されています。"
    },
    {
      "indent": 3,
      "text": "Complex types are types with a rich internal structure, which may be composed of substatements defined in Table 1 (e.g., lists, leafs, containers, choices). A new complex type may extend an existing complex type. This allows providing type-safe extensions to existing YANG models as instances of the new type.",
      "ja": "複雑なタイプは、豊富な内部構造を持つタイプであり、表1で定義されている置換で構成される場合があります（例：リスト、葉、容器、選択）。新しい複雑なタイプは、既存の複雑なタイプを拡張する場合があります。これにより、新しいタイプのインスタンスとして既存のYangモデルにタイプセーフ拡張機能を提供できます。"
    },
    {
      "indent": 3,
      "text": "Complex types have the following characteristics:",
      "ja": "複雑なタイプには次の特性があります。"
    },
    {
      "indent": 3,
      "text": "o Introduction of new types, as a named, formal description of a concrete manageable resource as well as abstract concepts.",
      "ja": "o 具体的な管理可能なリソースと抽象的な概念の名前の正式な説明として、新しいタイプの導入。"
    },
    {
      "indent": 3,
      "text": "o Types can be extended, i.e., new types can be defined by specializing existing types and adding new features. Instances of such an extended type can be used wherever instances of the base type may appear.",
      "ja": "o タイプを拡張できます。つまり、既存のタイプを専門化して新しい機能を追加することで、新しいタイプを定義できます。このような拡張タイプのインスタンスは、ベースタイプのインスタンスが表示される場合でも使用できます。"
    },
    {
      "indent": 3,
      "text": "o The type information is made part of the NETCONF payload in case a derived type substitutes a base type. This enables easy and efficient consumption of payload elements representing complex type instances.",
      "ja": "o タイプ情報は、派生タイプがベースタイプを置き換える場合に備えて、NetConfペイロードの一部になります。これにより、複雑なタイプインスタンスを表すペイロード要素を簡単かつ効率的に消費することができます。"
    },
    {
      "indent": 0,
      "text": "2.2. complex-type Extension Statement",
      "section_title": true,
      "ja": "2.2. 複雑なタイプの拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "The extension statement \"complex-type\" is introduced; it accepts an arbitrary number of statements that define node trees, among other common YANG statements (\"YANG Statements\", Section 7 of [RFC6020]).",
      "ja": "拡張ステートメント「complex-type」が導入されています。他の一般的なYangステートメントの中でも、ノードツリーを定義する任意の数のステートメントを受け入れます（「Yang Statements」、[RFC6020]のセクション7）。"
    },
    {
      "indent": 20,
      "text": "+------------------+-------------+\n|   substatement   | cardinality |\n+------------------+-------------+\n|     abstract     |     0..1    |\n|      anyxml      |     0..n    |\n|      choice      |     0..n    |\n|     container    |     0..n    |\n|    description   |     0..1    |\n|    ct:instance   |     0..n    |\n| ct:instance-list |     0..n    |\n|    ct:extends    |     0..1    |\n|     grouping     |     0..n    |\n|    if-feature    |     0..n    |\n|        key       |     0..1    |\n|       leaf       |     0..n    |\n|     leaf-list    |     0..n    |\n|       list       |     0..n    |\n|       must       |     0..n    |\n|    ordered-by    |     0..n    |\n|     reference    |     0..1    |\n|      refine      |     0..n    |\n|      status      |     0..1    |\n|      typedef     |     0..n    |\n|       uses       |     0..n    |\n+------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 1: complex-type's Substatements",
      "ja": "表1：複雑なタイプの置換"
    },
    {
      "indent": 3,
      "text": "Complex type definitions may appear at every place where a grouping may be defined. That includes the module, submodule, rpc, input, output, notification, container, and list statements.",
      "ja": "複雑なタイプの定義は、グループ化が定義されるすべての場所で表示される場合があります。これには、モジュール、サブモジュール、RPC、入力、出力、通知、コンテナ、およびリストステートメントが含まれます。"
    },
    {
      "indent": 3,
      "text": "Complex type names populate a distinct namespace. As with YANG groupings, it is possible to define a complex type and a data node (e.g., leaf, list, instance statements) with the same name in the same scope. All complex type names defined within a parent node or at the top level of the module or its submodules share the same type identifier namespace. This namespace is scoped to the parent node or module.",
      "ja": "複雑なタイプ名は、個別の名前空間を入力します。Yangグループと同様に、同じ範囲で同じ名前を持つ複雑なタイプとデータノード（葉、リスト、インスタンスステートメントなど）を定義することができます。親ノード内またはモジュールまたはそのサブモジュールの最上位レベルで定義されたすべての複雑なタイプ名は、同じタイプ識別子ネームスペースを共有します。この名前空間は、親ノードまたはモジュールにスコープされています。"
    },
    {
      "indent": 3,
      "text": "A complex type MAY have an instance key. An instance key is either defined with the \"key\" statement as part of the complex type or is inherited from the base complex type. It is not allowed to define an additional key if the base complex type or one of its ancestors already defines a key.",
      "ja": "複雑なタイプにはインスタンスキーがある場合があります。インスタンスキーは、複雑なタイプの一部として「キー」ステートメントで定義されるか、ベース複合タイプから継承されます。ベース複合体タイプまたはその祖先の1つがすでにキーを定義している場合、追加のキーを定義することはできません。"
    },
    {
      "indent": 3,
      "text": "Complex type definitions do not create nodes in the schema tree.",
      "ja": "複雑なタイプの定義は、スキーマツリーにノードを作成しません。"
    },
    {
      "indent": 0,
      "text": "2.3. instance Extension Statement",
      "section_title": true,
      "ja": "2.3. インスタンス拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"instance\" extension statement is used to instantiate a complex type by creating a subtree in the management information node tree. The instance statement takes one argument that is the identifier of the complex type instance. It is followed by a block of substatements.",
      "ja": "「インスタンス」拡張ステートメントは、管理情報ノードツリーにサブツリーを作成することにより、複雑なタイプをインスタンス化するために使用されます。インスタンスステートメントは、複雑なタイプインスタンスの識別子である1つの引数を取ります。その後、置換のブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The type of the instance is specified with the mandatory \"ct: instance-type\" substatement. The type of an instance MUST be a complex type. Common YANG statements may be used as substatements of the \"instance\" statement. An instance is optional by default. To make an instance mandatory, \"mandatory true\" has to be applied as a substatement.",
      "ja": "インスタンスのタイプは、必須の「CT：Instance-Type」サクセクトメントで指定されています。インスタンスのタイプは複雑なタイプでなければなりません。一般的なヤンステートメントは、「インスタンス」ステートメントの代替として使用できます。インスタンスはデフォルトでオプションです。インスタンスを必須にするには、「必須のtrue」を置換として適用する必要があります。"
    },
    {
      "indent": 20,
      "text": "+------------------+-------------+\n|   substatement   | cardinality |\n+------------------+-------------+\n|    description   |     0..1    |\n|      config      |     0..1    |\n| ct:instance-type |      1      |\n|    if-feature    |     0..n    |\n|     mandatory    |     0..1    |\n|       must       |     0..n    |\n|     reference    |     0..1    |\n|      status      |     0..1    |\n|       when       |     0..1    |\n|      anyxml      |     0..n    |\n|      choice      |     0..n    |\n|     container    |     0..n    |\n|    ct:instance   |     0..n    |\n| ct:instance-list |     0..n    |\n|       leaf       |     0..n    |\n|     leaf-list    |     0..n    |\n|       list       |     0..n    |\n+------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 2: instance's Substatements",
      "ja": "表2：インスタンスの置換"
    },
    {
      "indent": 3,
      "text": "The \"instance\" and \"instance-list\" extension statements (see Section 2.4, \"instance-list Extension Statement\") are similar to the existing \"leaf\" and \"leaf-list\" statements, with the exception that the content is composed of subordinate elements according to the instantiated complex type.",
      "ja": "「インスタンス」および「インスタンスリスト」拡張ステートメント（セクション2.4、「インスタンスリスト拡張ステートメント」を参照）は、既存の「リーフ」および「リーフリスト」ステートメントに似ています。インスタンス化された複雑なタイプに応じた下位要素。"
    },
    {
      "indent": 3,
      "text": "It is also possible to add additional data nodes by using the corresponding leaf, leaf-list, list, and choice-statements, etc., as substatements of the instance declaration. This is an in-place augmentation of the used complex type confined to a complex type instantiation (see also Section 2.13, \"Using Complex Types\", for details on augmenting complex types).",
      "ja": "また、インスタンス宣言の置換として、対応する葉、葉リスト、リスト、および選択ステートメントなどを使用して、追加のデータノードを追加することもできます。これは、複雑なタイプのインスタンス化に限定された使用済みの複雑なタイプのインプレース増強です（複雑なタイプの増強の詳細については、セクション2.13、「複雑なタイプの使用」も参照してください）。"
    },
    {
      "indent": 0,
      "text": "2.4. instance-list Extension Statement",
      "section_title": true,
      "ja": "2.4. インスタンスリスト拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"instance-list\" extension statement is used to instantiate a complex type by defining a sequence of subtrees in the management information node tree. In addition, the \"instance-list\" statement takes one argument that is the identifier of the complex type instances. It is followed by a block of substatements.",
      "ja": "「インスタンスリスト」拡張ステートメントは、管理情報ノードツリーにサブツリーのシーケンスを定義することにより、複雑なタイプをインスタンス化するために使用されます。さらに、「インスタンスリスト」ステートメントは、複雑なタイプインスタンスの識別子である1つの引数を取ります。その後、置換のブロックが続きます。"
    },
    {
      "indent": 3,
      "text": "The type of the instance is specified with the mandatory \"ct: instance-type\" substatement. In addition, it can be defined how often an instance may appear in the schema tree by using the \"min-elements\" and \"max-elements\" substatements. Common YANG statements may be used as substatements of the \"instance-list\" statement.",
      "ja": "インスタンスのタイプは、必須の「CT：Instance-Type」サクセクトメントで指定されています。さらに、「Min-Elements」および「Max-Elements」の置換を使用して、スキーマツリーにインスタンスが表示される頻度を定義できます。一般的なヤンステートメントは、「インスタンスリスト」ステートメントの代替として使用できます。"
    },
    {
      "indent": 3,
      "text": "In analogy to the \"instance\" statement, YANG substatements like \"list\", \"choice\", \"leaf\", etc., MAY be used to augment the \"instance-list\" elements at the root level with additional data nodes.",
      "ja": "「インスタンス」ステートメントに類似して、「リスト」、「選択」、「葉」などのYangの置換を使用して、追加のデータノードを使用してルートレベルの「インスタンスリスト」要素を拡張するために使用できます。"
    },
    {
      "indent": 20,
      "text": "+------------------+-------------+\n|   substatementc  | cardinality |\n+------------------+-------------+\n|    description   |     0..1    |\n|      config      |     0..1    |\n| ct:instance-type |      1      |\n|    if-feature    |     0..n    |\n|   max-elements   |     0..1    |\n|   min-elements   |     0..1    |\n|       must       |     0..n    |\n|    ordered-by    |     0..1    |\n|     reference    |     0..1    |\n|      status      |     0..1    |\n|       when       |     0..1    |\n|      anyxml      |     0..n    |\n|      choice      |     0..n    |\n|     container    |     0..n    |\n|    ct:instance   |     0..n    |\n| ct:instance-list |     0..n    |\n|       leaf       |     0..n    |\n|     leaf-list    |     0..n    |\n|       list       |     0..n    |\n+------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 3: instance-list's Substatements",
      "ja": "表3：インスタンスリストの代替"
    },
    {
      "indent": 3,
      "text": "In case the instance list represents configuration data, the used complex type of an instance MUST have an instance key.",
      "ja": "インスタンスリストが構成データを表す場合、インスタンスの使用されている複雑なタイプにインスタンスキーが必要です。"
    },
    {
      "indent": 3,
      "text": "Instances as well as instance lists may appear as arguments of the \"deviate\" statement.",
      "ja": "インスタンスとインスタンスリストは、「Deviate」ステートメントの引数として表示される場合があります。"
    },
    {
      "indent": 0,
      "text": "2.5. extends Extension Statement",
      "section_title": true,
      "ja": "2.5. 拡張ステートメントを拡張します"
    },
    {
      "indent": 3,
      "text": "A complex type MAY extend exactly one existing base complex type by using the \"extends\" extension statement. The keyword \"extends\" MAY occur as a substatement of the \"complex-type\" extension statement. The argument of the \"complex-type\" extension statement refers to the base complex type via its name. In case a complex type represents configuration data (the default), it MUST have a key; otherwise, it MAY have a key. A key is either defined with the \"key\" statement as part of the complex type or is inherited from the base complex type.",
      "ja": "複雑なタイプは、「拡張」拡張ステートメントを使用して、正確に1つの既存のベース複合体タイプを拡張できます。キーワード「拡張」は、「複雑なタイプ」拡張ステートメントの代替として発生する場合があります。「複雑なタイプ」拡張ステートメントの引数は、その名前を介したベース複合型を指します。複雑なタイプが構成データ（デフォルト）を表す場合、キーが必要です。それ以外の場合は、キーがある場合があります。キーは、複雑なタイプの一部として「キー」ステートメントで定義されるか、ベース複合タイプから継承されます。"
    },
    {
      "indent": 22,
      "text": "+--------------+-------------+\n| substatement | cardinality |\n+--------------+-------------+\n|  description |     0..1    |\n|   reference  |     0..1    |\n|    status    |     0..1    |\n+--------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 4: extends' Substatements",
      "ja": "表4：拡張の置換"
    },
    {
      "indent": 0,
      "text": "2.6. abstract Extension Statement",
      "section_title": true,
      "ja": "2.6. 抽象拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "Complex types may be declared to be abstract by using the \"abstract\" extension statement. An abstract complex type cannot be instantiated, meaning it cannot appear as the most specific type of an instance in the NETCONF payload. In case an abstract type extends a base type, the base complex type MUST be also abstract. By default, complex types are not abstract.",
      "ja": "「抽象」拡張ステートメントを使用して、複雑なタイプが抽象的であると宣言される場合があります。抽象的な複雑なタイプをインスタンス化することはできません。つまり、NetConfペイロードのインスタンスの最も特定のタイプとして表示されることはできません。抽象型がベースタイプを拡張する場合、ベース複合型も抽象的でなければなりません。デフォルトでは、複雑なタイプは抽象的ではありません。"
    },
    {
      "indent": 3,
      "text": "The abstract complex type serves only as a base type for derived concrete complex types and cannot be used as a type for an instance in the NETCONF payload.",
      "ja": "抽象的な複雑なタイプは、派生コンクリートの複雑なタイプのベースタイプとしてのみ機能し、NetConfペイロードのインスタンスのタイプとして使用することはできません。"
    },
    {
      "indent": 3,
      "text": "The \"abstract\" extension statement takes a single string argument, which is either \"true\" or \"false\". In case a \"complex-type\" statement does not contain an \"abstract\" statement as a substatement, the default is \"false\". The \"abstract\" statement does not support any substatements.",
      "ja": "「要約」拡張ステートメントは、「真」または「偽」のいずれかである単一の文字列引数を取ります。「複雑なタイプ」ステートメントには、次の「抽象的な」ステートメントが含まれていない場合、デフォルトは「false」です。「要約」ステートメントは、置換をサポートしていません。"
    },
    {
      "indent": 0,
      "text": "2.7. XML Encoding Rules",
      "section_title": true,
      "ja": "2.7. XMLエンコードルール"
    },
    {
      "indent": 3,
      "text": "An \"instance\" node is encoded as an XML element, where an \"instance-list\" node is encoded as a series of XML elements. The corresponding XML element names are the \"instance\" and \"instance-list\" identifiers, respectively, and they use the same XML namespace as the module.",
      "ja": "「インスタンス」ノードはXML要素としてエンコードされ、「インスタンスリスト」ノードは一連のXML要素としてエンコードされます。対応するXML要素名は、それぞれ「インスタンス」と「インスタンスリスト」識別子であり、モジュールと同じXMLネームスペースを使用します。"
    },
    {
      "indent": 3,
      "text": "Instance child nodes are encoded as subelements of the instance XML element. Subelements representing child nodes defined in the same complex type may appear in any order. However, child nodes of an extending complex type follow the child nodes of the extended complex type. As such, the XML encoding of lists is similar to the encoding of containers and lists in YANG.",
      "ja": "インスタンスチャイルドノードは、インスタンスXML要素のサブエレメントとしてエンコードされます。同じ複雑なタイプで定義された子ノードを表すサブエレメントは、任意の順序で表示される場合があります。ただし、拡張された複雑なタイプの子ノードは、拡張された複雑なタイプの子ノードに従います。そのため、リストのXMLエンコードは、ヤンのコンテナとリストのエンコードに似ています。"
    },
    {
      "indent": 3,
      "text": "Instance key nodes are encoded as subelements of the instance XML element. Instance key nodes must appear in the same order as they are defined within the \"key\" statement of the corresponding complex type definition and precede all other nodes defined in the same complex type. That is, if key nodes are defined in an extending complex type, XML elements representing key data precede all other XML elements representing child nodes. On the other hand, XML elements representing key data follow the XML elements representing data nodes of the base type.",
      "ja": "インスタンスキーノードは、インスタンスXML要素のサブエレメントとしてエンコードされます。インスタンスキーノードは、対応する複雑なタイプ定義の「キー」ステートメント内で定義され、同じ複雑なタイプで定義された他のすべてのノードの前に定義されているため、同じ順序で表示する必要があります。つまり、キーノードが拡張された複雑なタイプで定義されている場合、キーデータを表すXML要素は、子ノードを表す他のすべてのXML要素に先行します。一方、キーデータを表すXML要素は、ベースタイプのデータノードを表すXML要素に従います。"
    },
    {
      "indent": 3,
      "text": "The type of the actual complex type instance is encoded in a type element, which is put in front of all instance child elements, including key nodes, as described in Section 2.8 (\"Type Encoding Rules\").",
      "ja": "実際の複雑なタイプインスタンスのタイプは、セクション2.8（「タイプエンコーディングルール」）で説明されているように、キーノードを含むすべてのインスタンスの子要素の前に配置されます。"
    },
    {
      "indent": 3,
      "text": "The proposed XML encoding rules conform to the YANG XML encoding rules in [RFC6020]. Compared to YANG, enabling key definitions in derived hierarchies is a new feature introduced with the complex types extension. As a new language feature, complex types also introduce a new payload entry for the instance type identifier.",
      "ja": "提案されているXMLエンコードルールは、[RFC6020]のYang XMLエンコードルールに準拠しています。Yangと比較して、派生階層の重要な定義を有効にすることは、複雑なタイプの拡張機能で導入される新機能です。新しい言語機能として、複雑なタイプは、インスタンスタイプ識別子の新しいペイロードエントリも導入します。"
    },
    {
      "indent": 3,
      "text": "Based on our implementation experience, the proposed XML encoding rules support consistent mapping of YANG models with complex types to an XML schema using XML complex types.",
      "ja": "実装エクスペリエンスに基づいて、提案されているXMLエンコーディングルールは、XML複合タイプを使用してXMLスキーマへの複雑なタイプのYangモデルの一貫したマッピングをサポートします。"
    },
    {
      "indent": 0,
      "text": "2.8. Type Encoding Rules",
      "section_title": true,
      "ja": "2.8. タイプエンコーディングルール"
    },
    {
      "indent": 3,
      "text": "In order to encode the type of an instance in the NETCONF payload, XML elements named \"type\" belonging to the XML namespace \"urn:ietf:params:xml:ns:yang:ietf-complex-type-instance\" are added to the serialized form of instance and instance-list nodes in the payload. The suggested namespace prefix is \"cti\". The \"cti:type\" XML elements are inserted before the serialized form of all members that have been declared in the corresponding complex type definition.",
      "ja": "NetConfペイロードのインスタンスのタイプをエンコードするために、XMLネームスペースに属する「タイプ」という名前のXML要素 \"urn：ietf：params：xml：yang：ietf-complex-type-instance」が追加されます。ペイロード内のインスタンスとインスタンスリストノードのシリアル化された形式。推奨される名前空間プレフィックスは「CTI」です。「CTI：Type」XML要素は、対応する複雑なタイプ定義で宣言されたすべてのメンバーのシリアル化された形式の前に挿入されます。"
    },
    {
      "indent": 3,
      "text": "The \"cti:type\" element is inserted for each type in the extension chain to the actual type of the instance (most specific last). Each type name includes its corresponding namespace.",
      "ja": "「CTI：Type」要素は、拡張チェーン内の各タイプに対してインスタンスの実際のタイプに挿入されます（最も具体的な最後）。各タイプ名には、対応する名前空間が含まれています。"
    },
    {
      "indent": 3,
      "text": "The type of a complex type instance MUST be encoded in the reply to NETCONF <get> and <get-config> operations, and in the payload of a NETCONF <edit-config> operation if the operation is \"create\" or \"replace\". The type of the instance MUST also be specified in case <copy-config> is used to export a configuration to a resource addressed with an URI. The type of the instance has to be specified in user-defined remote procedure calls (RPCs).",
      "ja": "複雑なタイプのインスタンスのタイプは、netConf <get>および<get-config>操作への返信と、操作が「作成」または「置換」である場合はnetConf <edit-config>操作のペイロードでエンコードする必要があります。。インスタンスのタイプは、<copy-config>がURIでアドレス指定されたリソースに構成をエクスポートするために使用される場合にも指定する必要があります。インスタンスのタイプは、ユーザー定義のリモートプロシージャコール（RPC）で指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "The type of the instance MAY be specified in case the operation is \"merge\" (either because this is explicitly specified or no operation attribute is provided).",
      "ja": "インスタンスのタイプは、操作が「マージ」である場合に指定できます（これは明示的に指定されているか、操作属性が提供されていないため）。"
    },
    {
      "indent": 3,
      "text": "In case the node already exists in the target configuration and the type attribute (type of a complex type instance) is specified but differs from the data in the target, an <rpc-error> element is returned with an <error-app-tag> value of \"wrong-complex-type\". In case no such element is present in the target configuration but the type attribute is missing in the configuration data, an <rpc-error> element is returned with an <error-tag> value of \"missing-attribute\".",
      "ja": "ターゲット構成にノードが既に存在し、型属性（複雑なタイプインスタンスのタイプ）が指定されているが、ターゲットのデータとは異なる場合、<rpc-error>要素は<error-app-tagで返されます>「誤った複雑タイプ」の値。ターゲット構成にそのような要素が存在しないが、型属性が構成データに欠落している場合、<rpc-error>要素は<error-tag>値の「Missing-Attribute」の値で返されます。"
    },
    {
      "indent": 3,
      "text": "The type MUST NOT be specified in case the operation is \"delete\".",
      "ja": "操作が「削除」の場合、タイプを指定してはなりません。"
    },
    {
      "indent": 0,
      "text": "2.9. Extension and Feature Definition Module",
      "section_title": true,
      "ja": "2.9. 拡張および機能定義モジュール"
    },
    {
      "indent": 3,
      "text": "The module below contains all YANG extension definitions for complex types and typed instance identifiers. In addition, a \"complex-type\" feature is defined, which may be used to provide conditional or alternative modeling, depending on the support status of complex types in a NETCONF server. A NETCONF server that supports the modeling features for complex types and the XML encoding for complex types as defined in this document MUST advertise this as a feature. This is done by including the feature name \"complex-types\" in the feature parameter list as part of the NETCONF <hello> message as described in Section 5.6.4 in [RFC6020].",
      "ja": "以下のモジュールには、複雑なタイプとタイプ付きインスタンス識別子のすべてのYang拡張定義が含まれています。さらに、「複雑なタイプ」機能が定義されています。これは、NetConfサーバーの複雑なタイプのサポートステータスに応じて、条件付きまたは代替モデリングを提供するために使用できます。複雑なタイプのモデリング機能をサポートするNetConfサーバーと、このドキュメントで定義されているように複雑なタイプのXMLエンコードは、これを機能として宣伝する必要があります。これは、[RFC6020]のセクション5.6.4で説明されているように、NetConf <hello>メッセージの一部として、機能パラメーターリストに「complex-types」を含めることによって行われます。"
    },
    {
      "indent": 1,
      "text": "<CODE BEGINS> file \"ietf-complex-types@2011-03-15.yang\"",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "module ietf-complex-types {",
      "ja": "モジュールietf-complex-types {"
    },
    {
      "indent": 4,
      "text": "namespace \"urn:ietf:params:xml:ns:yang:ietf-complex-types\";\nprefix \"ct\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "organization",
      "ja": "組織"
    },
    {
      "indent": 6,
      "text": "\"NETMOD WG\";",
      "ja": "「NetMod WG」;"
    },
    {
      "indent": 4,
      "text": "contact\n  \"Editor:  Bernd Linowski\n            <bernd.linowski.ext@nsn.com>\n   Editor:  Mehmet Ersue\n            <mehmet.ersue@nsn.com>\n   Editor:  Siarhei Kuryla\n            <s.kuryla@gmail.com>\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "description \"YANG extensions for complex types and typed instance identifiers.",
      "ja": "説明「複雑なタイプと型付けされたインスタンス識別子のYang拡張機能。"
    },
    {
      "indent": 7,
      "text": "Copyright (c) 2011 IETF Trust and the persons identified as authors of the code. All rights reserved.",
      "ja": "Copyright（c）2011 IETF TrustおよびCodeの著者として特定された人。全著作権所有。"
    },
    {
      "indent": 7,
      "text": "Redistribution and use in source and binary forms, with or without modification, is permitted pursuant to, and subject to the license terms contained in, the Simplified BSD License set forth in Section 4.c of the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info).",
      "ja": "変更とバイナリ形式での再配布と使用は、変更の有無にかかわらず、IETF Trustの法的規定（IETFドキュメントに関する法的規定）のセクション4.Cに記載されている簡略化されたBSDライセンスに基づいて許可されており、ライセンス条件に従います。http://trustee.ietf.org/license-info）。"
    },
    {
      "indent": 7,
      "text": "This version of this YANG module is part of RFC 6095; see the RFC itself for full legal notices.\";",
      "ja": "このYangモジュールのこのバージョンは、RFC 6095の一部です。完全な法的通知については、RFC自体を参照してください。」;"
    },
    {
      "indent": 8,
      "text": "revision 2011-03-15 {\n    description \"Initial revision.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "extension complex-type {\n    description \"Defines a complex-type.\";\n    reference \"Section 2.2, complex-type Extension Statement\";\n    argument type-identifier {\n        yin-element true;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "extension extends {\n    description \"Defines the base type of a complex-type.\";\n    reference \"Section 2.5, extends Extension Statement\";\n    argument base-type-identifier {\n        yin-element true;\n    }\n}\n         extension abstract {\n    description \"Makes the complex-type abstract.\";\n    reference \"Section 2.6, abstract Extension Statement\";\n    argument status;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "extension instance {\n    description \"Declares an instance of the given\n         complex type.\";\n    reference \"Section 2.3, instance Extension Statement\";\n    argument ct-instance-identifier {\n        yin-element true;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "extension instance-list {\n    description \"Declares a list of instances of the given\n         complex type\";\n    reference \"Section 2.4, instance-list Extension Statement\";\n    argument ct-instance-identifier {\n        yin-element true;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "extension instance-type {\n    description \"Tells to which type instance the instance\n                 identifier refers.\";\n    reference \"Section 3.2, instance-type Extension Statement\";\n    argument target-type-identifier {\n        yin-element true;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 9,
      "text": "feature complex-types {\n    description \"Indicates that the server supports\n                 complex types and instance identifiers.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 1,
      "text": "<CODE ENDS>",
      "ja": "<コードエンド>"
    },
    {
      "indent": 0,
      "text": "2.10. Example Model for Complex Types",
      "section_title": true,
      "ja": "2.10. 複雑なタイプの例モデル"
    },
    {
      "indent": 3,
      "text": "The example model below shows how complex types can be used to represent physical equipment in a vendor-independent, abstract way. It reuses the complex types defined in the physical resource model in Section 1.5.1.",
      "ja": "以下の例モデルは、ベンダーに依存しない抽象的な方法で物理機器を表すために複雑なタイプを使用する方法を示しています。セクション1.5.1の物理リソースモデルで定義された複雑なタイプを再利用します。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<code begins>"
    },
    {
      "indent": 3,
      "text": "module hw {",
      "ja": "モジュールHW {"
    },
    {
      "indent": 6,
      "text": "namespace \"http://example.com/hw\"; prefix \"hw\";",
      "ja": "namespace \"http://example.com/hw\";プレフィックス「hw」;"
    },
    {
      "indent": 6,
      "text": "import ietf-complex-types {prefix \"ct\"; }\nimport udmcore {prefix \"uc\"; }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Holder types",
      "ja": "//ホルダータイプ"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Slot {\n        ct:extends uc:EquipmentHolder;\n        leaf slotNumber { type uint16; config false; }\n          // ...\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Chassis {\n        ct:extends uc:EquipmentHolder;\n        leaf numberOfChassisSlots { type uint32; config false; }\n          // ..\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Equipment types",
      "ja": "//機器の種類"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Card {\n        ct:extends uc:Equipment;\n        leaf position { type uint32; mandatory true; }\n          leaf slotsRequired {type unit32; }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Root Element\n ct:instance hardware { type uc:ManagedHardware; }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} // hw module",
      "ja": "} // HWモジュール"
    },
    {
      "indent": 3,
      "text": "<CODE ENDS>",
      "ja": "<コードエンド>"
    },
    {
      "indent": 0,
      "text": "2.11. NETCONF Payload Example",
      "section_title": true,
      "ja": "2.11. NetConfペイロードの例"
    },
    {
      "indent": 3,
      "text": "Following example shows the payload of a reply to a NETCONF <get> command. The actual type of managed hardware instances is indicated with the \"cti:type\" elements as required by the type encoding rules. The containment hierarchy in the NETCONF XML payload reflects the containment hierarchy of hardware instances. This makes filtering based on the containment hierarchy possible without having to deal with values of leafs of type leafref that represent the tree structure in a flattened hierarchy.",
      "ja": "次の例は、NetConf <get>コマンドへの返信のペイロードを示しています。マネージドハードウェアインスタンスの実際のタイプは、タイプエンコーディングルールで必要な「CTI：Type」要素で示されています。NetConf XMLペイロードの封じ込め階層は、ハードウェアインスタンスの封じ込め階層を反映しています。これにより、平坦化された階層内のツリー構造を表すタイプの葉の葉の値に対処することなく、封じ込め階層に基づいてフィルタリングが可能になります。"
    },
    {
      "indent": 1,
      "text": "<hardware>\n    <cti:type>uc:BasicObject</cti:type>\n    <distinguishedName>/R-T31/CH-2</distinguishedName>\n    <globalId>6278279001</globalId>\n    <cti:type>uc:Resource</cti:type>\n    <cti:type>uc:PhysicalResource</cti:type>\n    <otherIdentifier>Rack R322-1</otherIdentifier>\n    <serialNumber>R-US-3276279a</serialNumber>\n    <cti:type>uc:Hardware</cti:type>\n    <cti:type>uc:ManagedHardware</cti:type>\n    <cti:type>hw:EquipmentHolder</cti:type>\n    <equipmentHolder>\n        <cti:type>uc:BasicObject</cti:type>\n        <distinguishedName>/R-T31/CH-2/SL-1</distinguishedName>\n        <globalId>548872003</globalId>\n        <cti:type>uc:Resource</cti:type>\n        <cti:type>uc:PhysicalResource</cti:type>\n        <otherIdentifier>CU-Slot</otherIdentifier>\n        <serialNumber>T-K4733890x45</serialNumber>\n        <cti:type>uc:Hardware</cti:type>\n        <cti:type>uc:ManagedHardware</cti:type>\n        <cti:type>uc:EquipmentHolder</cti:type>\n        <equipment>\n            <cti:type>uc:BasicObject</cti:type>\n            <distinguishedName>/R-T31/CH-2/SL-1/C-3</distinguishedName>\n            <globalId>89772001</globalId>\n            <cti:type>uc:Resource</cti:type>\n            <cti:type>uc:PhysicalResource</cti:type>\n            <otherIdentifier>ATM-45252</otherIdentifier>\n            <serialNumber>A-778911-b</serialNumber>\n            <cti:type>uc:Hardware</cti:type>\n            <cti:type>uc:ManagedHardware</cti:type>\n            <cti:type>uc:Equipment</cti:type>\n            <installed>true</installed>\n            <version>A2</version>\n            <redundancy>1</redundancy>\n            <cti:type>hw:Card</cti:type>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 1,
      "text": "            <usedSlots>1</usedSlots>\n        </equipment>\n        <cti:type>hw:Slot</cti:type>\n        <slotNumber>1</slotNumber>\n    </equipmentHolder>\n    <cti:type>hw:Chassis</cti:type>\n    <numberOfChassisSlots>6</numberOfChassisSlots>\n    // ...\n</hardware>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.12. Update Rules for Modules Using Complex Types",
      "section_title": true,
      "ja": "2.12. 複雑なタイプを使用したモジュールのルールを更新します"
    },
    {
      "indent": 3,
      "text": "In addition to the module update rules specified in Section 10 in [RFC6020], modules that define complex types, instances of complex types, and typed instance identifiers must obey following rules:",
      "ja": "[RFC6020]のセクション10で指定されたモジュール更新ルールに加えて、複雑なタイプ、複雑なタイプのインスタンス、および入力されたインスタンス識別子を定義するモジュールは、次のルールに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "o New complex types MAY be added.",
      "ja": "o 新しい複雑なタイプが追加される場合があります。"
    },
    {
      "indent": 3,
      "text": "o A new complex type MAY extend an existing complex type.",
      "ja": "o 新しい複雑なタイプは、既存の複雑なタイプを拡張する場合があります。"
    },
    {
      "indent": 3,
      "text": "o New data definition statements MAY be added to a complex type only if:",
      "ja": "o 新しいデータ定義ステートメントは、以下の場合にのみ、複雑なタイプに追加される場合があります。"
    },
    {
      "indent": 6,
      "text": "* they are not mandatory or",
      "ja": "* それらは必須ではありません"
    },
    {
      "indent": 6,
      "text": "* they are not conditionally dependent on a new feature (i.e., they do not have an \"if-feature\" statement that refers to a new feature).",
      "ja": "* それらは条件付きで新しい機能に依存していません（つまり、新しい機能を指す「if-feature」ステートメントはありません）。"
    },
    {
      "indent": 3,
      "text": "o The type referred to by the instance-type statement may be changed to a type that derives from the original type only if the original type does not represent configuration data.",
      "ja": "o インスタンスタイプのステートメントで言及されるタイプは、元のタイプが構成データを表していない場合にのみ、元のタイプから派生するタイプに変更できます。"
    },
    {
      "indent": 0,
      "text": "2.13. Using Complex Types",
      "section_title": true,
      "ja": "2.13. 複雑なタイプを使用します"
    },
    {
      "indent": 3,
      "text": "All data nodes defined inside a complex type reside in the complex type namespace, which is their parent node namespace.",
      "ja": "複雑なタイプ内で定義されているすべてのデータノードは、親ノードネームスペースである複雑なタイプの名前空間にあります。"
    },
    {
      "indent": 0,
      "text": "2.13.1. Overriding Complex Type Data Nodes",
      "section_title": true,
      "ja": "2.13.1. 複雑なタイプデータノードをオーバーライドします"
    },
    {
      "indent": 3,
      "text": "It is not allowed to override a data node inherited from a base type. That is, it is an error if a type \"base\" with a leaf named \"foo\" is extended by another complex type (\"derived\") with a leaf named \"foo\" in the same module. In case they are derived in different modules, there are two distinct \"foo\" nodes that are mapped to the XML namespaces of the module, where the complex types are specified.",
      "ja": "ベースタイプから継承されたデータノードをオーバーライドすることは許可されていません。つまり、「foo」という名前の葉があるタイプ「ベース」が、同じモジュールに「foo」という名前の葉がある別の複雑なタイプ（「派生」）によって拡張された場合のエラーです。それらが異なるモジュールで導出される場合、複雑なタイプが指定されているモジュールのXML名空間にマッピングされる2つの異なる「Foo」ノードがあります。"
    },
    {
      "indent": 3,
      "text": "A complex type that extends a basic complex type may use the \"refine\" statement in order to improve an inherited data node. The target node identifier must be qualified by the module prefix to indicate clearly which inherited node is refined.",
      "ja": "基本的な複雑なタイプを拡張する複雑なタイプは、継承されたデータノードを改善するために「改良」ステートメントを使用する場合があります。ターゲットノード識別子は、どの継承されたノードが洗練されているかを明確に示すために、モジュールプレフィックスによって適格である必要があります。"
    },
    {
      "indent": 3,
      "text": "The following refinements can be done:",
      "ja": "次の改良を行うことができます。"
    },
    {
      "indent": 3,
      "text": "o A leaf or choice node may have a default value, or a new default value if it already had one.",
      "ja": "o リーフまたは選択ノードには、デフォルト値がある場合、または既にある場合は新しいデフォルト値があります。"
    },
    {
      "indent": 3,
      "text": "o Any node may have a different \"description\" or \"reference\" string.",
      "ja": "o 任意のノードには、別の「説明」または「参照」文字列がある場合があります。"
    },
    {
      "indent": 3,
      "text": "o A leaf, anyxml, or choice node may have a \"mandatory true\" statement. However, it is not allowed to change from \"mandatory true\" to \"mandatory false\".",
      "ja": "o リーフ、anyxml、または選択ノードには、「必須の真の」ステートメントがある場合があります。ただし、「必須の真の」から「必須偽」に変更することは許可されていません。"
    },
    {
      "indent": 3,
      "text": "o A leaf, leaf-list, list, container, or anyxml node may have additional \"must\" expressions.",
      "ja": "o 葉、葉のリスト、リスト、コンテナ、またはanyXMLノードには、追加の「必須」式がある場合があります。"
    },
    {
      "indent": 3,
      "text": "o A list, leaf-list, instance, or instance-list node may have a \"min-elements\" statement, if the base type does not have one or does not have one with a value that is greater than the minimum value of the base type.",
      "ja": "o リスト、リーフリスト、インスタンス、またはインスタンスリストノードには、ベースタイプにベースタイプがない場合、またはベースの最小値よりも大きい値を持つものがない場合、「最小要素」ステートメントがある場合があります。タイプ。"
    },
    {
      "indent": 3,
      "text": "o A list, leaf-list, instance, or instance-list node may have a \"max-elements\" statement, if the base type does not have one or does not have one with a value that is smaller than the maximum value of the base type.",
      "ja": "o リスト、リーフリスト、インスタンス、またはインスタンスリストノードには、ベースタイプにベースタイプがない場合、またはベースの最大値よりも小さい値を持たない場合、「最大要素」ステートメントがある場合があります。タイプ。"
    },
    {
      "indent": 3,
      "text": "It is not allowed to refine complex-type nodes inside \"instance\" or \"instance-list\" statements.",
      "ja": "「インスタンス」または「インスタンスリスト」ステートメント内の複雑なタイプのノードを改良することは許可されていません。"
    },
    {
      "indent": 0,
      "text": "2.13.2. Augmenting Complex Types",
      "section_title": true,
      "ja": "2.13.2. 複雑なタイプの拡張"
    },
    {
      "indent": 3,
      "text": "Augmenting complex types is only allowed if a complex type is instantiated in an \"instance\" or \"instance-list\" statement. This confines the effect of the augmentation to the location in the schema tree where the augmentation is done. The argument of the \"augment\" statement MUST be in the descendant form (as defined by the rule \"descendant-schema-nodeid\" in Section 12 in [RFC6020]).",
      "ja": "複雑なタイプの拡張は、複雑なタイプが「インスタンス」または「インスタンスリスト」ステートメントにインスタンス化されている場合にのみ許可されます。これにより、増強が行われているスキーマツリーの位置に増強の効果が限定されます。「Augment」声明の議論は、[RFC6020]のセクション12のルール「子孫 - 系統型」で定義されている子孫の形式でなければなりません。"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Chassis {\n        ct:extends EquipmentHolder;\n        container chassisInfo {\n               config false;\n               leaf numberOfSlots { type uint16; }\n               leaf occupiedSlots { type uint16; }\n               leaf height {type unit16;}\n               leaf width {type unit16;}\n          }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:instance-list chassis {\n        type Chassis;\n        augment \"chassisInfo\" {\n               leaf modelId { type string; }\n        }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When augmenting a complex type, only the \"container\", \"leaf\", \"list\", \"leaf-list\", \"choice\", \"instance\", \"instance-list\", and \"if-feature\" statements may be used within the \"augment\" statement. The nodes added by the augmentation MUST NOT be mandatory nodes. One or many \"augment\" statements may not cause the creation of multiple nodes with the same name from the same namespace in the target node.",
      "ja": "複雑なタイプを拡張する場合、「コンテナ」、「葉」、「リスト」、「リーフリスト」、「選択」、「インスタンス」、「インスタンスリスト」、および「if-feature」ステートメントのみを使用することができます。「Augment」ステートメント内。増強によって追加されたノードは、必須ノードであってはなりません。1つまたは多くの「Augment」ステートメントは、ターゲットノードの同じ名前空間から同じ名前の複数のノードの作成を引き起こさない場合があります。"
    },
    {
      "indent": 3,
      "text": "To achieve less-complex modeling, this document proposes the augmentation of complex type instances without recursion.",
      "ja": "複雑なモデリングを実現するために、このドキュメントでは、再帰なしで複雑なタイプインスタンスの増強を提案しています。"
    },
    {
      "indent": 0,
      "text": "2.13.3. Controlling the Use of Complex Types",
      "section_title": true,
      "ja": "2.13.3. 複雑なタイプの使用を制御します"
    },
    {
      "indent": 3,
      "text": "A server might not want to support all complex types defined in a supported module. This issue can be addressed with YANG features as follows:",
      "ja": "サーバーは、サポートされているモジュールで定義されているすべての複雑なタイプをサポートしたくない場合があります。この問題は、次のようにYangの機能で対処できます。"
    },
    {
      "indent": 3,
      "text": "o Features are defined that are used inside complex type definitions (by using \"if-feature\" as a substatement) to make them optional. In this case, such complex types may only be instantiated if the feature is supported (advertised as a capability in the NETCONF <hello> message).",
      "ja": "o 複雑なタイプの定義内で使用される機能（「if-feature」をサクセクトメントとして使用することにより）で使用してオプションにすることができます。この場合、このような複雑なタイプは、機能がサポートされている場合にのみインスタンス化される場合があります（NetConf <Hello>メッセージの機能として宣伝されています）。"
    },
    {
      "indent": 3,
      "text": "o The \"deviation\" statement may be applied to node trees, which are created by \"instance\" and \"instance-list\" statements. In this case, only the substatement \"deviate not-supported\" is allowed.",
      "ja": "o 「偏差」ステートメントは、「インスタンス」と「インスタンスリスト」ステートメントによって作成されるノードツリーに適用される場合があります。この場合、「サポートされていない逸脱」の代替のみが許可されます。"
    },
    {
      "indent": 3,
      "text": "o It is not allowed to apply the \"deviation\" statement to node tree elements that may occur because of the recursive use of a complex type. Other forms of deviations (\"deviate add\", \"deviate replace\", \"deviate delete\") are NOT supported inside node trees spanned by \"instance\" or \"instance-list\".",
      "ja": "o 複雑なタイプの再帰的使用のために発生する可能性のあるノードツリー要素に「偏差」ステートメントを適用することは許可されていません。他の形式の偏差（「Deviate add」、「Deviateの置き換え」、「Deviate Delete」）は、「インスタンス」または「インスタンスリスト」で及ぶノードツリー内ではサポートされていません。"
    },
    {
      "indent": 3,
      "text": "As complex type definitions do not contribute by themselves to the data node tree, data node declarations inside complex types cannot be the target of deviations.",
      "ja": "複雑なタイプの定義はデータノードツリーにそれ自体で貢献していないため、複雑なタイプ内のデータノード宣言は偏差のターゲットにはなりません。"
    },
    {
      "indent": 3,
      "text": "In the example below, client applications are informed that the leaf \"occupiedSlots\" is not supported in the top-level chassis. However, if a chassis contains another chassis, the contained chassis may support the leaf that reports the number of occupied slots.",
      "ja": "以下の例では、クライアントアプリケーションには、葉の「占領ストー」がトップレベルのシャーシではサポートされていないことが通知されます。ただし、シャーシに別のシャーシが含まれている場合、含まれているシャーシは、占有されたスロットの数を報告する葉をサポートする場合があります。"
    },
    {
      "indent": 5,
      "text": "deviation \"/chassis/chassisSpec/occupiedSlots\" {\n   deviate not-supported;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3. Typed Instance Identifier",
      "section_title": true,
      "ja": "3. 入力されたインスタンス識別子"
    },
    {
      "indent": 0,
      "text": "3.1. Definition",
      "section_title": true,
      "ja": "3.1. 意味"
    },
    {
      "indent": 3,
      "text": "Typed instance identifier relationships are an addition to the relationship types already defined in YANG, where the leafref relationship is location dependent, and the instance-identifier does not specify to which type of instances the identifier points.",
      "ja": "タイプ付きインスタンス識別子関係は、Yangで既に定義されている関係タイプに追加されています。ここでは、LeafRef関係が位置に依存し、Instance-Identifierは識別子ポイントのどのタイプのインスタンスを指定しません。"
    },
    {
      "indent": 3,
      "text": "A typed instance identifier represents a reference to an instance of a complex type without being restricted to a particular location in the containment tree. This is done by using the extension statement \"instance-type\" as a substatement of the existing \"type instance identifier\" statement.",
      "ja": "型付けされたインスタンス識別子は、封じ込めツリー内の特定の場所に制限されることなく、複雑なタイプのインスタンスへの参照を表します。これは、既存の「型インスタンス識別子」ステートメントの置換として、拡張ステートメント「インスタンスタイプ」を使用することによって行われます。"
    },
    {
      "indent": 3,
      "text": "Typed instance identifiers allow referring to instances of complex types that may be located anywhere in the schema tree. The \"type\" statement plays the role of a restriction that must be fulfilled by the target node, which is referred to with the instance identifier. The target node MUST be of a particular complex type, either the type itself or any type that extends this complex type.",
      "ja": "入力されたインスタンス識別子は、スキーマツリーのどこにでも配置できる複雑なタイプのインスタンスを参照することを許可します。「タイプ」ステートメントは、インスタンス識別子と呼ばれるターゲットノードによって満たされなければならない制限の役割を果たします。ターゲットノードは、タイプ自体またはこの複雑なタイプを拡張する任意のタイプのいずれかの特定の複雑なタイプでなければなりません。"
    },
    {
      "indent": 0,
      "text": "3.2. instance-type Extension Statement",
      "section_title": true,
      "ja": "3.2. インスタンスタイプの拡張ステートメント"
    },
    {
      "indent": 3,
      "text": "The \"instance-type\" extension statement specifies the complex type of the instance to which the instance-identifier refers. The referred instance may also instantiate any complex type that extends the specified complex type.",
      "ja": "「Instance-Type」拡張ステートメントは、インスタンスIdentifierが参照するインスタンスの複雑なタイプを指定します。参照されたインスタンスは、指定された複雑なタイプを拡張する複雑なタイプをインスタンスする場合があります。"
    },
    {
      "indent": 3,
      "text": "The instance complex type is identified by the single name argument. The referred complex type MUST have a key. This extension statement MUST be used as a substatement of the \"type instance-identifier\" statement. The \"instance-type\" extension statement does not support any substatements.",
      "ja": "インスタンスの複雑なタイプは、単一の名前引数によって識別されます。参照された複雑なタイプにはキーが必要です。この拡張ステートメントは、「型インスタンス識別子」ステートメントの置換として使用する必要があります。「インスタンスタイプ」拡張ステートメントは、置換をサポートしていません。"
    },
    {
      "indent": 0,
      "text": "3.3. Typed Instance Identifier Example",
      "section_title": true,
      "ja": "3.3. 入力されたインスタンス識別子の例"
    },
    {
      "indent": 3,
      "text": "In the example below, a physical link connects an arbitrary number of physical ports. Here, typed instance identifiers are used to denote which \"PhysicalPort\" instances (anywhere in the data tree) are connected by a \"PhysicalLink\".",
      "ja": "以下の例では、物理リンクが任意の数の物理ポートを接続します。ここでは、入力されたインスタンス識別子を使用して、「物理的ポート」インスタンス（データツリーのどこでも）が「物理的なもの」で接続されているかを示すものです。"
    },
    {
      "indent": 8,
      "text": "// Extended version of type Card\nct:complex-type Card {\n   ct:extends Equipment;\n   leaf usedSlot { type uint16; mandatory true; }\n   ct:instance-list port {\n       type PhysicalPort;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "ct:complex-type PhysicalPort {\n   ct:extends ManagedHardware;\n   leaf portNumber { type int32; mandatory true; }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "ct:complex-type PhysicalLink {\n   ct:extends ManagedHardware;\n   leaf media { type string; }\n   leaf-list connectedPort {\n      type instance-identifier {\n        ct:instance-type PhysicalPort;\n      }\n      min-elements 2;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Below is the XML encoding of an element named \"link\" of type \"PhysicalLink\":",
      "ja": "以下は、「PhysicAllink」タイプの「リンク」という名前の要素のXMLエンコードです。"
    },
    {
      "indent": 7,
      "text": "<link>\n    <objectId>FTCL-771</objectId>\n    <media>Fiber</media>\n    <connectedPort>/hw:hardware[objectId='R-11']\n      /hw:equipment[objectId='AT22']/hw:port[objectId='P12']\n    </connectedPort>\n    <connectedPort>/hw:hardware[objectId='R-42]\n      /hw:equipment[objectId='AT30']/hw:port[objectId='P3']\n    </connectedPort>\n    <serialNumber>F-7786828</serialNumber>\n    <commonName>FibCon 7</commonName>\n</link>",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. IANA Considerations",
      "section_title": true,
      "ja": "4. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document registers two URIs in the IETF XML registry. IANA registered the following URIs, according to [RFC3688]:",
      "ja": "このドキュメントは、IETF XMLレジストリに2つのURIを登録します。[RFC3688]によると、IANAは次のURIを登録しました。"
    },
    {
      "indent": 3,
      "text": "URI: urn:ietf:params:xml:ns:yang:ietf-complex-types\nURI: urn:ietf:params:xml:ns:yang:ietf-complex-type-instance",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Registrant Contact: Bernd Linowski (bernd.linowski.ext@nsn.com) Mehmet Ersue (mehmet.ersue@nsn.com) Siarhei Kuryla (s.kuryla@gmail.com)",
      "ja": "登録者の連絡先：Bernd Linowski（bernd.linowski.ext@nsn.com）Mehmet ersue（mehmet.ersue@nsn.com）Siarhei Kuryla（s.kuryla@gmail.com）"
    },
    {
      "indent": 3,
      "text": "XML: N/A, the requested URIs are XML namespaces.",
      "ja": "XML：n/a、要求されたurisはXMLネームスペースです。"
    },
    {
      "indent": 3,
      "text": "This document registers one module name in the \"YANG Module Names\" registry, defined in [RFC6020]. name: ietf-complex-types",
      "ja": "このドキュメントは、[RFC6020]で定義されている「Yangモジュール名」レジストリに1つのモジュール名を登録します。名前：ietf-complex-types"
    },
    {
      "indent": 6,
      "text": "namespace: urn:ietf:params:xml:ns:yang:ietf-complex-types",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "prefix: ct",
      "ja": "プレフィックス：CT"
    },
    {
      "indent": 6,
      "text": "RFC: 6095",
      "ja": "RFC：6095"
    },
    {
      "indent": 0,
      "text": "5. Security Considerations",
      "section_title": true,
      "ja": "5. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "The YANG module \"complex-types\" in this memo defines YANG extensions for complex types and typed instance identifiers as new language statements.",
      "ja": "このメモのYangモジュール「複雑なタイプ」は、複雑なタイプのYang拡張機能と、型付けされたインスタンス識別子のYang拡張機能を新しい言語声明として定義しています。"
    },
    {
      "indent": 3,
      "text": "Complex types and typed instance identifiers themselves do not have any security impact on the Internet.",
      "ja": "複雑なタイプとタイプされたインスタンス識別子自体は、インターネットにセキュリティの影響を与えません。"
    },
    {
      "indent": 3,
      "text": "The security considerations described throughout [RFC6020] apply here as well.",
      "ja": "[RFC6020]全体で説明されているセキュリティ上の考慮事項もここにも適用されます。"
    },
    {
      "indent": 0,
      "text": "6. Acknowledgements",
      "section_title": true,
      "ja": "6. 謝辞"
    },
    {
      "indent": 3,
      "text": "The authors would like to thank to Martin Bjorklund, Balazs Lengyel, Gerhard Muenz, Dan Romascanu, Juergen Schoenwaelder, and Martin Storch for their valuable review and comments on different versions of the document.",
      "ja": "著者は、Martin Bjorklund、Balazs Lengyel、Gerhard Muenz、Dan Romascanu、Juergen Schoenwaelder、Martin Storchに、文書のさまざまなバージョンに関する貴重なレビューとコメントに感謝します。"
    },
    {
      "indent": 0,
      "text": "7. References",
      "section_title": true,
      "ja": "7. 参考文献"
    },
    {
      "indent": 0,
      "text": "7.1. Normative References",
      "section_title": true,
      "ja": "7.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, March 1997.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、1997年3月。"
    },
    {
      "indent": 3,
      "text": "[RFC3688] Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688, January 2004.",
      "ja": "[RFC3688] Mealling、M。、「IETF XMLレジストリ」、BCP 81、RFC 3688、2004年1月。"
    },
    {
      "indent": 3,
      "text": "[RFC6020] Bjorklund, M., \"YANG - A Data Modeling Language for the Network Configuration Protocol (NETCONF)\", RFC 6020, October 2010.",
      "ja": "[RFC6020] Bjorklund、M。、「Yang-ネットワーク構成プロトコル（NetConf）のデータモデリング言語」、RFC 6020、2010年10月。"
    },
    {
      "indent": 0,
      "text": "7.2. Informative References",
      "section_title": true,
      "ja": "7.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[IPFIXCONF] Muenz, G., Claise, B., and P. Aitken, \"Configuration Data Model for IPFIX and PSAMP\", Work in Progress, March 2011.",
      "ja": "[IPFIXCONF] Muenz、G.、Claise、B。、およびP. Aitken、「IPFIXとPSAMPの構成データモデル」、2011年3月に進行中の作業。"
    },
    {
      "indent": 3,
      "text": "[Libsmi] Kuryla, S., \"Libsmi Extension for Complex Types\", April 2010, <http://www.ibr.cs.tu-bs.de/svn/libsmi>.",
      "ja": "[Libsmi] Kuryla、S。、「複雑なタイプのLibsmi拡張」、2010年4月、<http://www.ibr.cs.tu-bs.de/svn/libsmi>。"
    },
    {
      "indent": 3,
      "text": "[Pyang] Bjorklund, M., \"An extensible YANG validator and converter in python\", October 2010, <http://code.google.com/p/pyang/>.",
      "ja": "[Pyang] Bjorklund、M。、「Pythonの拡張可能なYang Valibator and Converter」、2010年10月、<http://code.google.com/p/pyang/>。"
    },
    {
      "indent": 3,
      "text": "[Pyang-ct] Kuryla, S., \"Complex type extension for an extensible YANG validator and converter in python\", April 2010, <http://code.google.com/p/pyang-ct/>.",
      "ja": "[Pyang-ct] Kuryla、S。、「Pythonの拡張可能なYang Valibator and Converterの複雑なタイプの拡張」、2010年4月、<http://code.google.com/p/pyang-ct/>。"
    },
    {
      "indent": 3,
      "text": "[RFC4133] Bierman, A. and K. McCloghrie, \"Entity MIB (Version 3)\", RFC 4133, August 2005.",
      "ja": "[RFC4133] Bierman、A。およびK. McCloghrie、「Entity MIB（バージョン3）」、RFC 4133、2005年8月。"
    },
    {
      "indent": 3,
      "text": "[SID_V8] TeleManagement Forum, \"GB922, Information Framework (SID) Solution Suite, Release 8.0\", July 2008, <http:// www.tmforum.org/DocumentsInformation/ GB922InformationFramework/35499/article.html>.",
      "ja": "[SID_V8] TeleManagement Forum、「GB922、情報フレームワーク（SID）ソリューションスイート、リリース8.0 \"、2008年7月、<http：// www.tmforum.org/documentsinformation/ gb922informationframework/35499/article.html>。"
    },
    {
      "indent": 3,
      "text": "[UDM] NSN, \"Unified Data Model SID Compliance Statement\", May 2010, <http://www.tmforum.org/InformationFramework/ NokiaSiemensNetworks/8815/home.html>.",
      "ja": "[UDM] NSN、「Unified Data Model SID Compliance Statement」、2010年5月、<http://www.tmforum.org/informationframework/ nokiasiemensnetworks/8815/home.html>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. YANG Modules for Physical Network Resource Model and Hardware Entities Model",
      "ja": "付録A. 物理ネットワークリソースモデルとハードウェアエンティティモデル用のYangモジュール"
    },
    {
      "indent": 3,
      "text": "YANG module for the 'Physical Network Resource Model':",
      "ja": "「物理ネットワークリソースモデル」のYangモジュール："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<code begins>"
    },
    {
      "indent": 3,
      "text": "module udmcore {",
      "ja": "モジュールudmcore {"
    },
    {
      "indent": 6,
      "text": "namespace \"http://example.com/udmcore\"; prefix \"udm\";",
      "ja": "namespace \"http://example.com/udmcore\";プレフィックス「udm」;"
    },
    {
      "indent": 6,
      "text": "import ietf-yang-types {prefix \"yang\";}\nimport ietf-complex-types {prefix \"ct\";}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type BasicObject {\n   ct:abstract true;\n   key \"distinguishedName\";\n     leaf globalId {type int64;}\n     leaf distinguishedName {type string; mandatory true;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type ManagedObject {\n   ct:extends BasicObject;\n   ct:abstract true;\n   leaf instance {type string;}\n   leaf objectState {type int32;}\n   leaf release {type string;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Resource {\n         ct:extends ManagedObject;\n         ct:abstract true;\n   leaf usageState {type int16;}\n   leaf managementMethodSupported {type string;}\n   leaf managementMethodCurrent {type string;}\n   leaf managementInfo {type string;}\n   leaf managementDomain {type string;}\n   leaf version {type string;}\n   leaf entityIdentification {type string;}\n   leaf description {type string;}\n   leaf rootEntityType {type string;}\n}\n      ct:complex-type LogicalResource {\n   ct:extends Resource;\n   ct:abstract true;\n   leaf lrStatus {type int32;}\n   leaf serviceState {type int32;}\n   leaf isOperational {type boolean;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type PhysicalResource {\n   ct:extends Resource;\n   ct:abstract true;\n   leaf manufactureDate {type string;}\n   leaf otherIdentifier {type string;}\n   leaf powerState {type int32;}\n   leaf serialNumber {type string;}\n   leaf versionNumber {type string;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Hardware {\n   ct:extends PhysicalResource;\n   ct:abstract true;\n   leaf width {type string;}\n   leaf height {type string;}\n   leaf depth {type string;}\n   leaf measurementUnits {type int32;}\n   leaf weight {type string;}\n   leaf weightUnits {type int32;}\n   leaf-list physicalLink {\n      type instance-identifier {\n         ct:instance-type PhysicalLink;\n      }\n   }\n   ct:instance-list containedHardware {\n      ct:instance-type Hardware;\n   }\n   ct:instance-list physicalConnector {\n      ct:instance-type PhysicalConnector;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type PhysicalLink {\n   ct:extends PhysicalResource;\n   leaf isWireless {type boolean;}\n   leaf currentLength {type string;}\n   leaf maximumLength {type string;}\n         leaf mediaType {type int32;}\n   leaf-list hardware {\n      type instance-identifier {\n         ct:instance-type Hardware;\n      }\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type ManagedHardware {\n   ct:extends Hardware;\n   leaf additionalinfo {type string;}\n   leaf physicalAlarmReportingEnabled {type boolean;}\n   leaf pyhsicalAlarmStatus {type int32;}\n   leaf coolingRequirements {type string;}\n   leaf hardwarePurpose {type string;}\n   leaf isPhysicalContainer {type boolean;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type AuxiliaryComponent {\n   ct:extends ManagedHardware;\n   ct:abstract true;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type PhysicalPort {\n   ct:extends ManagedHardware;\n   leaf portNumber {type int32;}\n   leaf duplexMode {type int32;}\n   leaf ifType {type int32;}\n   leaf vendorPortName {type string;}\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type PhysicalConnector {\n   ct:extends Hardware;\n   leaf location {type string;}\n   leaf cableType {type int32;}\n   leaf gender {type int32;}\n   leaf inUse {type boolean;}\n   leaf pinDescription {type string;}\n   leaf typeOfConnector {type int32;}\n   leaf-list sourcePhysicalConnector {\n      type instance-identifier {\n         ct:instance-type PhysicalConnector;\n      }\n   }\n         leaf-list targetPhysicalConnector {\n      type instance-identifier {\n         ct:instance-type PhysicalConnector;\n      }\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Equipment {\n   ct:extends ManagedHardware;\n   leaf installStatus {type int32;}\n   leaf expectedEquipmentType {type string;}\n   leaf installedEquipmentType {type string;}\n   leaf installedVersion {type string;}\n   leaf redundancy {type int32;}\n   leaf vendorName {type string;}\n   leaf dateOfLastService {type yang:date-and-time;}\n   leaf interchangeability {type string;}\n   leaf identificationCode {type string;}\n   ct:instance-list equipment {\n      ct:instance-type Equipment;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type EquipmentHolder {\n   ct:extends ManagedHardware;\n   leaf vendorName {type string;}\n   leaf locationName {type string;}\n   leaf dateOfLastService {type yang:date-and-time;}\n   leaf partNumber {type string;}\n   leaf availabilityStatus {type int16;}\n   leaf nameFromPlanningSystem {type string;}\n   leaf modelNumber {type string;}\n   leaf acceptableEquipmentList {type string;}\n   leaf isSolitaryHolder {type boolean;}\n   leaf holderStatus {type int16;}\n   leaf interchangeability {type string;}\n   leaf equipmentHolderSpecificType {type string; }\n   leaf position {type string;}\n   leaf atomicCompositeType {type int16;}\n   leaf uniquePhysical {type boolean;}\n   leaf physicalDescription {type string;}\n   leaf serviceApproach {type string;}\n   leaf mountingOptions {type int32;}\n   leaf cableManagementStrategy {type string;}\n   leaf isSecureHolder {type boolean;}\n   ct:instance-list equipment {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "      ct:instance-type Equipment;\n         }\n   ct:instance-list equipmentHolder {\n      ct:instance-type EquipmentHolder;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// ... other resource complex types ...",
      "ja": "// ...その他のリソース複雑なタイプ..."
    },
    {
      "indent": 3,
      "text": "} <CODE ENDS>",
      "ja": "} <Code End>"
    },
    {
      "indent": 3,
      "text": "YANG module for the 'Hardware Entities Model':",
      "ja": "「ハードウェアエンティティモデル」のYangモジュール："
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>",
      "ja": "<code begins>"
    },
    {
      "indent": 3,
      "text": "module hardware-entities {",
      "ja": "モジュールハードウェアエンティティ{"
    },
    {
      "indent": 6,
      "text": "namespace \"http://example.com/:hardware-entities\";\nprefix \"hwe\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "import ietf-yang-types {prefix \"yang\";}\nimport ietf-complex-types {prefix \"ct\";}\nimport udmcore {prefix \"uc\";}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "grouping PhysicalEntityProperties {\n   leaf hardwareRev {type string; }\n   leaf firmwareRev {type string; }\n   leaf softwareRev {type string; }\n   leaf serialNum {type string; }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "   leaf mfgName {type string; }\n   leaf modelName {type string; }\n   leaf alias {type string; }\n   leaf ssetID{type string; }\n   leaf isFRU {type boolean; }\n   leaf mfgDate {type yang:date-and-time; }\n   leaf-list uris {type string; }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Physical entities representing equipment",
      "ja": "//機器を表す物理エンティティ"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Module {\n   ct:extends uc:Equipment;\n   description \"Complex type representing module entries",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "      (entPhysicalClass = module(9)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Backplane {\n   ct:extends uc:Equipment;\n   description \"Complex type representing backplane entries\n      (entPhysicalClass = backplane(4)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Physical entities representing auxiliary hardware components",
      "ja": "//補助ハードウェアコンポーネントを表す物理エンティティ"
    },
    {
      "indent": 6,
      "text": "ct:complex-type PowerSupply {\n   ct:extends uc:AuxiliaryComponent;\n   description \"Complex type representing power supply entries\n      (entPhysicalClass = powerSupply(6)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Fan {\n   ct:extends uc:AuxiliaryComponent;\n   description \"Complex type representing fan entries\n      (entPhysicalClass = fan(7)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Sensor {\n   ct:extends uc:AuxiliaryComponent;\n   description \"Complex type representing sensor entries\n      (entPhysicalClass = sensor(8)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Physical entities representing equipment holders",
      "ja": "//機器保有者を表す物理エンティティ"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Chassis {\n   ct:extends uc:EquipmentHolder;\n   description \"Complex type representing chassis entries\n      (entPhysicalClass = chassis(3)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Container {\n   ct:extends uc:EquipmentHolder;\n   description \"Complex type representing container entries",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "      (entPhysicalClass = container(5)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type Stack {\n   ct:extends uc:EquipmentHolder;\n   description \"Complex type representing stack entries\n      (entPhysicalClass = stack(11)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "// Other kinds of physical entities",
      "ja": "//他の種類の物理エンティティ"
    },
    {
      "indent": 6,
      "text": "ct:complex-type Port {\n   ct:extends uc:PhysicalPort;\n   description \"Complex type representing port entries\n      (entPhysicalClass = port(10)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "ct:complex-type CPU {\n   ct:extends uc:Hardware;\n   description \"Complex type representing cpu entries\n      (entPhysicalClass = cpu(12)) in entPhysicalTable\";\n   uses PhysicalEntityProperties;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "} <CODE ENDS>",
      "ja": "} <Code End>"
    },
    {
      "indent": 0,
      "text": "Appendix B. Example YANG Module for the IPFIX/PSAMP Model",
      "ja": "付録B. IPFIX/PSAMPモデルのYangモジュールの例"
    },
    {
      "indent": 0,
      "text": "B.1. Modeling Improvements for the IPFIX/PSAMP Model with Complex Types and Typed Instance Identifiers",
      "section_title": true,
      "ja": "B.1. 複雑なタイプとタイプされたインスタンス識別子を使用したIPFIX/PSAMPモデルのモデリングの改善"
    },
    {
      "indent": 3,
      "text": "The module below is a variation of the IPFIX/PSAMP configuration model, which uses complex types and typed instance identifiers to model the concept outlined in [IPFIXCONF].",
      "ja": "以下のモジュールは、IPFIX/PSAMP構成モデルのバリエーションであり、複雑なタイプを使用し、[IPFIXCONF]で概説されている概念をモデル化するインスタンス識別子と入力されたインスタンス識別子を使用します。"
    },
    {
      "indent": 3,
      "text": "When looking at the YANG module with complex types and typed instance identifiers, various technical improvements on the modeling level become apparent.",
      "ja": "複雑なタイプとタイプされたインスタンス識別子を持つYangモジュールを見ると、モデリングレベルでのさまざまな技術的改善が明らかになります。"
    },
    {
      "indent": 3,
      "text": "o There is almost a one-to-one mapping between the domain concepts introduced in IPFIX and the complex types in the YANG module.",
      "ja": "o IPFIXで導入されたドメイン概念とYangモジュールに複雑なタイプの間には、ほぼ1対1のマッピングがあります。"
    },
    {
      "indent": 3,
      "text": "o All associations between the concepts (besides containment) are represented with typed identifiers. That avoids having to refer to a particular location in the tree. Referring to a particular in the tree is not mandated by the original model.",
      "ja": "o 概念間のすべての関連付け（封じ込め以外）は、型付けされた識別子で表されます。これは、木の特定の場所を参照する必要がないことを避けます。ツリー内の特定を参照することは、元のモデルによって義務付けられていません。"
    },
    {
      "indent": 3,
      "text": "o It is superfluous to represent concept refinement (class inheritance in the original model) with containment in the form of quite big choice-statements with complex branches. Instead, concept refinement is realized by complex types extending a base complex type.",
      "ja": "o 複雑な枝を持つ非常に大きな選択ステートメントの形で封じ込められている概念の改良（元のモデルのクラス継承）を表すことは不要です。代わりに、概念の洗練は、基本複合タイプを拡張する複雑なタイプによって実現されます。"
    },
    {
      "indent": 3,
      "text": "o It is unnecessary to introduce metadata identities and leafs (e.g., \"identity cacheMode\" and \"leaf cacheMode\" in \"grouping cacheParameters\") that just serve the purpose of indicating which concrete subtype of a generic type (modeled as grouping, which contains the union of all features of all subtypes) is actually represented in the MIB.",
      "ja": "o メタデータのアイデンティティと葉（例：「カチャパラメーターをグループ化する」の「アイデンティティカチモード」と「葉のカチョメード」を導入する必要はありません。すべてのサブタイプのすべての機能のうち）は、実際にはMIBで表されます。"
    },
    {
      "indent": 3,
      "text": "o Ruling out illegal use of subtype-specific properties (e.g., \"leaf maxFlows\") by using \"when\" statements that refer to a subtype discriminator is not necessary (e.g., when \"../cacheMode != 'immediate'\").",
      "ja": "o サブタイプの識別子を参照する「 \"../cachemode！= 'intierm'\"）を参照する「「葉のmaxflows」などのサブタイプ固有のプロパティの違法使用（例：「葉のmaxflows」など）を除外します。"
    },
    {
      "indent": 3,
      "text": "o Defining properties like the configuration status wherever a so called \"parameter grouping\" is used is not necessary. Instead, those definitions can be put inside the complex type definition itself.",
      "ja": "o いわゆる「パラメーターグループ」が使用されている場合は、構成ステータスのようなプロパティを定義する必要はありません。代わりに、これらの定義は、複雑なタイプ定義自体の内側に配置できます。"
    },
    {
      "indent": 3,
      "text": "o Separating the declaration of the key from the related data nodes definitions in a grouping (see use of \"grouping selectorParameters\") can be avoided.",
      "ja": "o キーの宣言を、グループ化の関連データノード定義から分離すること（「SelectorParametersのグループ」の使用を参照）を回避できます。"
    },
    {
      "indent": 3,
      "text": "o Complex types may be declared as optional features. If the type is indicated with an identity (e.g., \"identity immediate\"), this is not possible, since \"if-feature\" is not allowed as a substatement of \"identity\".",
      "ja": "o 複雑なタイプは、オプションの機能として宣言される場合があります。タイプがアイデンティティで示されている場合（たとえば、「アイデンティティ即時」）、「if-feature」が「アイデンティティ」の代替として許可されていないため、これは不可能です。"
    },
    {
      "indent": 0,
      "text": "B.2. IPFIX/PSAMP Model with Complex Types and Typed Instance Identifiers",
      "section_title": true,
      "ja": "B.2. 複雑なタイプとタイプ付きインスタンス識別子を備えたIPFIX/PSAMPモデル"
    },
    {
      "indent": 0,
      "text": "<CODE BEGINS>\nmodule ct-ipfix-psamp-example {\n     namespace \"http://example.com/ns/ct-ipfix-psamp-example\";\n     prefix ipfix;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "import ietf-yang-types { prefix yang; }\nimport ietf-inet-types { prefix inet; }\nimport ietf-complex-types {prefix \"ct\"; }\n     description \"Example IPFIX/PSAMP Configuration Data Model\n  with complex types and typed instance identifiers\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " revision 2011-03-15 {\n    description \"The YANG Module ('YANG Module of the IPFIX/PSAMP\n      Configuration Data Model') in [IPFIXCONF] modeled with\n      complex types and typed instance identifiers.\n      Disclaimer: This example model illustrates the use of the\n      language extensions defined in this document and does not\n      claim to be an exact reproduction of the original YANG\n      model referred above. The original description texts have\n      been shortened to increase the readability of the model\n      example.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Features\n*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature exporter {\n  description \"If supported, the Monitoring Device can be used as\n    an Exporter.  Exporting Processes can be configured.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature collector {\n  description \"If supported, the Monitoring Device can be used as\n    a Collector.  Collecting Processes can be configured.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature meter {\n  description \"If supported, Observation Points, Selection\n    Processes, and Caches can be configured.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature psampSampCountBased {\n  description \"If supported, the Monitoring Device supports\n    count-based Sampling...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature psampSampTimeBased {\n  description \"If supported, the Monitoring Device supports\n    time-based Sampling...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature psampSampRandOutOfN {\n  description \"If supported, the Monitoring Device supports\n    random n-out-of-N Sampling...\";\n}\n     feature psampSampUniProb {\n  description \"If supported, the Monitoring Device supports\n    uniform probabilistic Sampling...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature psampFilterMatch {\n  description \"If supported, the Monitoring Device supports\n    property match Filtering...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature psampFilterHash {\n  description \"If supported, the Monitoring Device supports\n    hash-based Filtering...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature cacheModeImmediate {\n  description \"If supported, the Monitoring Device supports\n    Cache Mode 'immediate'.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature cacheModeTimeout {\n  description \"If supported, the Monitoring Device supports\n    Cache Mode 'timeout'.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature cacheModeNatural {\n  description \"If supported, the Monitoring Device supports\n    Cache Mode 'natural'.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature cacheModePermanent {\n  description \"If supported, the Monitoring Device supports\n    Cache Mode 'permanent'.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature udpTransport {\n  description \"If supported, the Monitoring Device supports UDP\n    as transport protocol.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature tcpTransport {\n  description \"If supported, the Monitoring Device supports TCP\n    as transport protocol.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "feature fileReader { description \"If supported, the Monitoring Device supports the configuration of Collecting Processes as File Readers.\";",
      "ja": "feature fileReader {説明 \"サポートされている場合、監視デバイスは、ファイルリーダーとしての収集プロセスの構成をサポートします。\";"
    },
    {
      "indent": 5,
      "text": "}",
      "ja": "}"
    },
    {
      "indent": 5,
      "text": "feature fileWriter {\n  description \"If supported, the Monitoring Device supports the\n    configuration of Exporting Processes as File Writers.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Identities\n*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*** Hash function identities ***/\nidentity hashFunction {\n  description \"Base identity for all hash functions...\";\n}\nidentity BOB {\n  base \"hashFunction\";\n  description \"BOB hash function\";\n  reference \"RFC 5475, Section 6.2.4.1.\";\n}\nidentity IPSX {\n  base \"hashFunction\";\n  description \"IPSX hash function\";\n  reference \"RFC 5475, Section 6.2.4.1.\";\n}\nidentity CRC {\n  base \"hashFunction\";\n  description \"CRC hash function\";\n  reference \"RFC 5475, Section 6.2.4.1.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*** Export mode identities ***/\nidentity exportMode {\n  description \"Base identity for different usages of export\n    destinations configured for an Exporting Process...\";\n}\nidentity parallel {\n  base \"exportMode\";\n  description \"Parallel export of Data Records to all\n    destinations configured for the Exporting Process.\";\n}\nidentity loadBalancing {\n  base \"exportMode\";\n  description \"Load-balancing between the different\n    destinations...\";\n}\nidentity fallback {\n  base \"exportMode\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " description \"Export to the primary destination...\"; }",
      "ja": "説明「主要な目的地へのエクスポート...」;}"
    },
    {
      "indent": 5,
      "text": "/*** Options type identities ***/\nidentity optionsType {\n  description \"Base identity for report types exported\n     with options...\";\n}\nidentity meteringStatistics {\n  base \"optionsType\";\n  description \"Metering Process Statistics.\";\n  reference \"RFC 5101, Section 4.1.\";\n}\nidentity meteringReliability {\n  base \"optionsType\";\n  description \"Metering Process Reliability Statistics.\";\n  reference \"RFC 5101, Section 4.2.\";\n}\nidentity exportingReliability {\n  base \"optionsType\";\n  description \"Exporting Process Reliability\n    Statistics.\";\n  reference \"RFC 5101, Section 4.3.\";\n}\nidentity flowKeys {\n  base \"optionsType\";\n  description \"Flow Keys.\";\n  reference \"RFC 5101, Section 4.4.\";\n}\nidentity selectionSequence {\n  base \"optionsType\";\n  description \"Selection Sequence and Selector Reports.\";\n  reference \"RFC 5476, Sections 6.5.1 and 6.5.2.\";\n}\nidentity selectionStatistics {\n  base \"optionsType\";\n  description \"Selection Sequence Statistics Report.\";\n  reference \"RFC 5476, Sections 6.5.3.\";\n}\nidentity accuracy {\n  base \"optionsType\";\n  description \"Accuracy Report.\";\n  reference \"RFC 5476, Section 6.5.4.\";\n}\nidentity reducingRedundancy {\n  base \"optionsType\";\n  description \"Enables the utilization of Options Templates to\n    reduce redundancy in the exported Data Records.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  reference \"RFC 5473.\";\n}\nidentity extendedTypeInformation {\n  base \"optionsType\";\n  description \"Export of extended type information for\n    enterprise-specific Information Elements used in the\n    exported Templates.\";\n  reference \"RFC 5610.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Type definitions\n*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "typedef nameType {\n  type string {\n    length \"1..max\";\n    pattern \"\\S(.*\\S)?\";\n  }\n  description \"Type for 'name' leafs...\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "typedef direction {\n  type enumeration {\n    enum ingress {\n      description \"This value is used for monitoring incoming\n        packets.\";\n    }\n    enum egress {\n      description \"This value is used for monitoring outgoing\n        packets.\";\n    }\n    enum both {\n      description \"This value is used for monitoring incoming and\n        outgoing packets.\";\n    }\n  }\n  description \"Direction of packets going through an interface or\n    linecard.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "typedef transportSessionStatus {\n  type enumeration {\n    enum inactive {\n      description \"This value MUST be used for...\";\n    }\n    enum active {\n      description \"This value MUST be used for...\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    }\n    enum unknown {\n      description \"This value MUST be used if the status...\";\n    }\n  }\n  description \"Status of a Transport Session.\";\n  reference \"RFC 5815, Section 8 (ipfixTransportSessionStatus).\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Complex types\n*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type ObservationPoint {\n  description \"Observation Point\";\n  key name;\n  leaf name {\n    type nameType;\n    description \"Key of an observation point.\";\n  }\n  leaf observationPointId {\n    type uint32;\n    config false;\n    description \"Observation Point ID...\";\n    reference \"RFC 5102, Section 5.1.10.\";\n  }\n  leaf observationDomainId {\n    type uint32;\n    mandatory true;\n    description \"The Observation Domain ID associates...\";\n    reference \"RFC 5101.\";\n  }\n  choice OPLocation {\n    mandatory true;\n    description \"Location of the Observation Point.\";\n    leaf ifIndex {\n      type uint32;\n      description \"Index of an interface...\";\n      reference \"RFC 2863.\";\n    }\n    leaf ifName {\n      type string;\n      description \"Name of an interface...\";\n      reference \"RFC 2863.\";\n    }\n    leaf entPhysicalIndex {\n      type uint32;\n      description \"Index of a linecard...\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      reference \"RFC 4133.\";\n    }\n    leaf entPhysicalName {\n      type string;\n      description \"Name of a linecard...\";\n      reference \"RFC 4133.\";\n    }\n  }\n  leaf direction {\n    type direction;\n    default both;\n    description \"Direction of packets....\";\n  }\n  leaf-list selectionProcess {\n    type instance-identifier { ct:instance-type SelectionProcess; }\n    description \"Selection Processes in this list process packets\n      in parallel.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type Selector {\n  ct:abstract true;\n  description \"Abstract selector\";\n  key name;\n  leaf name {\n      type nameType;\n      description \"Key of a selector\";\n  }\n  leaf packetsObserved {\n    type yang:counter64;\n    config false;\n    description \"The number of packets observed ...\";\n    reference \"RFC 5815, Section 8\n      (ipfixSelectionProcessStatsPacketsObserved).\";\n  }\n  leaf packetsDropped {\n    type yang:counter64;\n    config false;\n    description \"The total number of packets discarded ...\";\n    reference \"RFC 5815, Section 8\n      (ipfixSelectionProcessStatsPacketsDropped).\";\n  }\n  leaf selectorDiscontinuityTime {\n    type yang:date-and-time;\n    config false;\n    description \"Timestamp of the most recent occasion at which\n      one or more of the Selector counters suffered a\n      discontinuity...\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    reference \"RFC 5815, Section 8\n      (ipfixSelectionProcessStatsDiscontinuityTime).\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SelectAllSelector {\n  ct:extends Selector;\n  description \"Method that selects all packets.\";\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SampCountBasedSelector {\n      if-feature psampSampCountBased;\n      ct:extends Selector;\n      description \"Selector applying systematic count-based\n        packet sampling to the packet stream.\";\n      reference \"RFC 5475, Section 5.1;\n        RFC 5476, Section 6.5.2.1.\";\n      leaf packetInterval {\n        type uint32;\n        units packets;\n        mandatory true;\n        description \"The number of packets that are consecutively\n          sampled between gaps of length packetSpace.\n          This parameter corresponds to the Information Element\n          samplingPacketInterval.\";\n        reference \"RFC 5477, Section 8.2.2.\";\n      }\n      leaf packetSpace {\n        type uint32;\n        units packets;\n        mandatory true;\n        description \"The number of unsampled packets between two\n          sampling intervals.\n          This parameter corresponds to the Information Element\n          samplingPacketSpace.\";\n        reference \"RFC 5477, Section 8.2.3.\";\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SampTimeBasedSelector {\n      if-feature psampSampTimeBased;\n      ct:extends Selector;\n      description \"Selector applying systematic time-based\n        packet sampling to the packet stream.\";\n      reference \"RFC 5475, Section 5.1;\n        RFC 5476, Section 6.5.2.2.\";\n      leaf timeInterval {\n        type uint32;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "        units microseconds;\n        mandatory true;\n        description \"The time interval in microseconds during\n          which all arriving packets are sampled between gaps\n          of length timeSpace.\n          This parameter corresponds to the Information Element\n          samplingTimeInterval.\";\n        reference \"RFC 5477, Section 8.2.4.\";\n      }\n      leaf timeSpace {\n        type uint32;\n        units microseconds;\n        mandatory true;\n        description \"The time interval in microseconds during\n          which no packets are sampled between two sampling\n          intervals specified by timeInterval.\n          This parameter corresponds to the Information Element\n          samplingTimeInterval.\";\n        reference \"RFC 5477, Section 8.2.5.\";\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SampRandOutOfNSelector {\n      if-feature psampSampRandOutOfN;\n      ct:extends Selector;\n      description \"This container contains the configuration\n        parameters of a Selector applying n-out-of-N packet\n        sampling to the packet stream.\";\n      reference \"RFC 5475, Section 5.2.1;\n        RFC 5476, Section 6.5.2.3.\";\n      leaf size {\n        type uint32;\n        units packets;\n        mandatory true;\n        description \"The number of elements taken from the parent\n          population.\n          This parameter corresponds to the Information Element\n          samplingSize.\";\n        reference \"RFC 5477, Section 8.2.6.\";\n      }\n      leaf population {\n        type uint32;\n        units packets;\n        mandatory true;\n        description \"The number of elements in the parent\n          population.\n          This parameter corresponds to the Information Element\n          samplingPopulation.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "        reference \"RFC 5477, Section 8.2.7.\";\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SampUniProbSelector {\n      if-feature psampSampUniProb;\n      ct:extends Selector;\n      description \"Selector applying uniform probabilistic\n        packet sampling (with equal probability per packet) to the\n        packet stream.\";\n      reference \"RFC 5475, Section 5.2.2.1;\n        RFC 5476, Section 6.5.2.4.\";\n      leaf probability {\n        type decimal64 {\n          fraction-digits 18;\n          range \"0..1\";\n        }\n        mandatory true;\n        description \"Probability that a packet is sampled,\n          expressed as a value between 0 and 1.  The probability\n          is equal for every packet.\n          This parameter corresponds to the Information Element\n          samplingProbability.\";\n        reference \"RFC 5477, Section 8.2.8.\";\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type FilterMatchSelector {\n      if-feature psampFilterMatch;\n      ct:extends Selector;\n      description \"This container contains the configuration\n        parameters of a Selector applying property match filtering\n        to the packet stream.\";\n      reference \"RFC 5475, Section 6.1;\n        RFC 5476, Section 6.5.2.5.\";\n      choice nameOrId {\n        mandatory true;\n        description \"The field to be matched is specified by\n          either the name or the ID of the Information\n          Element.\";\n        leaf ieName {\n          type string;\n          description \"Name of the Information Element.\";\n        }\n        leaf ieId {\n          type uint16 {\n            range \"1..32767\" {\n              description \"Valid range of Information Element",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "                  identifiers.\";\n              reference \"RFC 5102, Section 4.\";\n            }\n          }\n          description \"ID of the Information Element.\";\n        }\n      }\n      leaf ieEnterpriseNumber {\n        type uint32;\n        description \"If present, ... \";\n      }\n      leaf value {\n        type string;\n        mandatory true;\n        description \"Matching value of the Information Element.\";\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type FilterHashSelector {\n      if-feature psampFilterHash;\n      ct:extends Selector;\n      description \"This container contains the configuration\n        parameters of a Selector applying hash-based filtering\n        to the packet stream.\";\n      reference \"RFC 5475, Section 6.2;\n        RFC 5476, Section 6.5.2.6.\";\n      leaf hashFunction {\n        type identityref {\n          base \"hashFunction\";\n        }\n        default BOB;\n        description \"Hash function to be applied.  According to\n          RFC 5475, Section 6.2.4.1, BOB hash function must be\n          used in order to be compliant with PSAMP.\";\n      }\n      leaf ipPayloadOffset {\n        type uint64;\n        units octets;\n        default 0;\n        description \"IP payload offset ... \";\n        reference \"RFC 5477, Section 8.3.2.\";\n      }\n      leaf ipPayloadSize {\n        type uint64;\n        units octets;\n        default 8;\n        description \"Number of IP payload bytes ... \";\n        reference \"RFC 5477, Section 8.3.3.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      }\n      leaf digestOutput {\n        type boolean;\n        default false;\n        description \"If true, the output ... \";\n        reference \"RFC 5477, Section 8.3.8.\";\n      }\n      leaf initializerValue {\n        type uint64;\n        description \"Initializer value to the hash function.\n          If not configured by the user, the Monitoring Device\n          arbitrarily chooses an initializer value.\";\n        reference \"RFC 5477, Section 8.3.9.\";\n      }\n      list selectedRange {\n        key name;\n        min-elements 1;\n        description \"List of hash function return ranges for\n          which packets are selected.\";\n        leaf name {\n          type nameType;\n          description \"Key of this list.\";\n        }\n        leaf min {\n          type uint64;\n          description \"Beginning of the hash function's selected\n            range.\n            This parameter corresponds to the Information Element\n            hashSelectedRangeMin.\";\n          reference \"RFC 5477, Section 8.3.6.\";\n        }\n        leaf max {\n          type uint64;\n          description \"End of the hash function's selected range.\n            This parameter corresponds to the Information Element\n            hashSelectedRangeMax.\";\n          reference \"RFC 5477, Section 8.3.7.\";\n        }\n      }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type Cache {\n  ct:abstract true;\n  description \"Cache of a Monitoring Device.\";\n  key name;\n  leaf name {\n    type nameType;\n    description \"Key of a cache\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  }\n  leaf-list exportingProcess {\n    type leafref { path \"/ipfix/exportingProcess/name\"; }\n    description \"Records are exported by all Exporting Processes\n      in the list.\";\n  }\n  description \"Configuration and state parameters of a Cache.\";\n  container cacheLayout {\n    description \"Cache Layout.\";\n    list cacheField {\n      key name;\n      min-elements 1;\n      description \"List of fields in the Cache Layout.\";\n      leaf name {\n        type nameType;\n        description \"Key of this list.\";\n      }\n      choice nameOrId {\n        mandatory true;\n        description \"Name or ID of the Information Element.\";\n        reference \"RFC 5102.\";\n        leaf ieName {\n          type string;\n          description \"Name of the Information Element.\";\n        }\n        leaf ieId {\n          type uint16 {\n            range \"1..32767\" {\n              description \"Valid range of Information Element\n                  identifiers.\";\n              reference \"RFC 5102, Section 4.\";\n            }\n          }\n          description \"ID of the Information Element.\";\n        }\n      }\n      leaf ieLength {\n        type uint16;\n        units octets;\n        description \"Length of the field ... \";\n        reference \"RFC 5101, Section 6.2; RFC 5102.\";\n      }\n      leaf ieEnterpriseNumber {\n        type uint32;\n        description \"If present, the Information Element is\n          enterprise-specific. ... \";\n        reference \"RFC 5101; RFC 5102.\";\n      }\n           leaf isFlowKey {\n        when \"(../../../cacheMode != 'immediate')\n          and\n          ((count(../ieEnterpriseNumber) = 0)\n          or\n          (../ieEnterpriseNumber != 29305))\" {\n          description \"This parameter is not available\n            for Reverse Information Elements (which have\n            enterprise number 29305) or if the Cache Mode\n            is 'immediate'.\";\n        }\n        type empty;\n        description \"If present, this is a flow key.\";\n      }\n    }\n  }\n  leaf dataRecords {\n    type yang:counter64;\n    units \"Data Records\";\n    config false;\n    description \"The number of Data Records generated ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixMeteringProcessCacheDataRecords).\";\n  }\n  leaf cacheDiscontinuityTime {\n    type yang:date-and-time;\n    config false;\n    description \"Timestamp of the ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixMeteringProcessCacheDiscontinuityTime).\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type ImmediateCache {\n  if-feature cacheModeImmediate;\n  ct:extends Cache;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": " ct:complex-type NonImmediateCache {\n   ct:abstract true;\n   ct:extends Cache;\n   leaf maxFlows {\n     type uint32;\n     units flows;\n     description \"This parameter configures the maximum number of\n       Flows in the Cache ... \";\n   }\n       leaf activeFlows {\n     type yang:gauge32;\n     units flows;\n     config false;\n     description \"The number of Flows currently active in this\n       Cache.\";\n     reference \"RFC 5815, Section 8\n       (ipfixMeteringProcessCacheActiveFlows).\";\n   }\n   leaf unusedCacheEntries {\n     type yang:gauge32;\n     units flows;\n     config false;\n     description \"The number of unused Cache entries in this\n       Cache.\";\n     reference \"RFC 5815, Section 8\n       (ipfixMeteringProcessCacheUnusedCacheEntries).\";\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type NonPermanentCache {\n  ct:abstract true;\n  ct:extends NonImmediateCache;\n  leaf activeTimeout {\n    type uint32;\n    units milliseconds;\n    description \"This parameter configures the time in\n      milliseconds after which ... \";\n  }\n  leaf inactiveTimeout {\n    type uint32;\n    units milliseconds;\n    description \"This parameter configures the time in\n      milliseconds after which ... \";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type NaturalCache {\n  if-feature cacheModeNatural;\n  ct:extends NonPermanentCache;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type TimeoutCache {\n  if-feature cacheModeTimeout;\n  ct:extends NonPermanentCache;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type PermanentCache {",
      "ja": "CT：complex-type permanentCache {"
    },
    {
      "indent": 4,
      "text": "  if-feature cacheModePermanent;\n  ct:extends NonImmediateCache;\n  leaf exportInterval {\n    type uint32;\n    units milliseconds;\n    description \"This parameter configures the interval for\n      periodical export of Flow Records in milliseconds.\n      If not configured by the user, the Monitoring Device sets\n      this parameter.\";\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type ExportDestination {\n  ct:abstract true;\n  description \"Abstract export destination.\";\n  key name;\n  leaf name {\n    type nameType;\n    description \"Key of an export destination.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "ct:complex-type IpDestination {\n  ct:abstract true;\n  ct:extends ExportDestination;\n  description \"IP export destination.\";\n  leaf ipfixVersion {\n     type uint16;\n     default 10;\n     description \"IPFIX version number.\";\n   }\n   leaf destinationPort {\n     type inet:port-number;\n     description \"If not configured by the user, the Monitoring\n       Device uses the default port number for IPFIX, which is\n       4739 without Transport Layer Security, and 4740 if Transport\n       Layer Security is activated.\";\n   }\n   choice indexOrName {\n     description \"Index or name of the interface ... \";\n     reference \"RFC 2863.\";\n     leaf ifIndex {\n       type uint32;\n       description \"Index of an interface as stored in the ifTable\n         of IF-MIB.\";\n       reference \"RFC 2863.\";\n     }\n     leaf ifName {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "       type string;\n       description \"Name of an interface as stored in the ifTable\n         of IF-MIB.\";\n       reference \"RFC 2863.\";\n     }\n   }\n   leaf sendBufferSize {\n     type uint32;\n     units bytes;\n     description \"Size of the socket send buffer.\n       If not configured by the user, this parameter is set by\n       the Monitoring Device.\";\n   }\n   leaf rateLimit {\n     type uint32;\n     units \"bytes per second\";\n     description \"Maximum number of bytes per second ... \";\n     reference \"RFC 5476, Section 6.3\";\n   }\n   container transportLayerSecurity {\n     presence \"If transportLayerSecurity is present, DTLS is\n       enabled if the transport protocol is SCTP or UDP, and TLS\n       is enabled if the transport protocol is TCP.\";\n     description \"Transport Layer Security configuration.\";\n     uses transportLayerSecurityParameters;\n   }\n   container transportSession {\n     config false;\n     description \"State parameters of the Transport Session\n       directed to the given destination.\";\n     uses transportSessionParameters;\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SctpExporter {\n  ct:extends IpDestination;\n  description \"SCTP exporter.\";\n  leaf-list sourceIPAddress {\n    type inet:ip-address;\n    description \"List of source IP addresses used ... \";\n    reference \"RFC 4960, Section 6.4\n      (Multi-Homed SCTP Endpoints).\";\n  }\n  leaf-list destinationIPAddress {\n    type inet:ip-address;\n    min-elements 1;\n    description \"One or multiple IP addresses ... \";\n    reference \"RFC 4960, Section 6.4",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      (Multi-Homed SCTP Endpoints).\";\n  }\n  leaf timedReliability {\n    type uint32;\n    units milliseconds;\n    default 0;\n    description \"Lifetime in milliseconds ... \";\n    reference \"RFC 3758; RFC 4960.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type UdpExporter {\n  ct:extends IpDestination;\n  if-feature udpTransport;\n  description \"UDP parameters.\";\n  leaf sourceIPAddress {\n    type inet:ip-address;\n    description \"Source IP address used by the Exporting\n       Process ...\";\n  }\n  leaf destinationIPAddress {\n    type inet:ip-address;\n    mandatory true;\n    description \"IP address of the Collection Process to which\n      IPFIX Messages are sent.\";\n  }\n  leaf maxPacketSize {\n    type uint16;\n    units octets;\n    description \"This parameter specifies the maximum size of\n      IP packets ... \";\n  }\n  leaf templateRefreshTimeout {\n    type uint32;\n    units seconds;\n    default 600;\n    description \"Sets time after which Templates are resent in the\n      UDP Transport Session. ... \";\n    reference \"RFC 5101, Section 10.3.6; RFC 5815, Section 8\n      (ipfixTransportSessionTemplateRefreshTimeout).\";\n  }\n  leaf optionsTemplateRefreshTimeout {\n    type uint32;\n    units seconds;\n    default 600;\n    description \"Sets time after which Options Templates are\n      resent in the UDP Transport Session. ... \";\n    reference \"RFC 5101, Section 10.3.6; RFC 5815, Section 8",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 4,
      "text": "       (ipfixTransportSessionOptionsTemplateRefreshTimeout).\";\n   }\n   leaf templateRefreshPacket {\n     type uint32;\n     units \"IPFIX Messages\";\n     description \"Sets number of IPFIX Messages after which\n       Templates are resent in the UDP Transport Session. ... \";\n     reference \"RFC 5101, Section 10.3.6; RFC 5815, Section 8\n       (ipfixTransportSessionTemplateRefreshPacket).\";\n   }\n   leaf optionsTemplateRefreshPacket {\n     type uint32;\n     units \"IPFIX Messages\";\n     description \"Sets number of IPFIX Messages after which\n       Options Templates are resent in the UDP Transport Session\n       protocol. ... \";\n     reference \"RFC 5101, Section 10.3.6; RFC 5815, Section 8\n       (ipfixTransportSessionOptionsTemplateRefreshPacket).\";\n   }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type TcpExporter {\n  ct:extends IpDestination;\n  if-feature tcpTransport;\n  description \"TCP exporter\";\n  leaf sourceIPAddress {\n    type inet:ip-address;\n    description \"Source IP address used by the Exporting\n      Process...\";\n  }\n  leaf destinationIPAddress {\n    type inet:ip-address;\n    mandatory true;\n    description \"IP address of the Collection Process to which\n      IPFIX Messages are sent.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type FileWriter {\n  ct:extends ExportDestination;\n  if-feature fileWriter;\n  description \"File Writer.\";\n  leaf ipfixVersion {\n    type uint16;\n    default 10;\n    description \"IPFIX version number.\";\n  }\n  leaf file {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "  type inet:uri;\n  mandatory true;\n  description \"URI specifying the location of the file.\";\n}\nleaf bytes {\n  type yang:counter64;\n  units octets;\n  config false;\n  description \"The number of bytes written by the File\n    Writer...\";\n}\nleaf messages {\n  type yang:counter64;\n  units \"IPFIX Messages\";\n  config false;\n  description \"The number of IPFIX Messages written by the File\n    Writer. ... \";\n}\nleaf discardedMessages {\n  type yang:counter64;\n  units \"IPFIX Messages\";\n  config false;\n  description \"The number of IPFIX Messages that could not be\n    written by the File Writer ... \";\n}\nleaf records {\n  type yang:counter64;\n  units \"Data Records\";\n  config false;\n  description \"The number of Data Records written by the File\n    Writer. ... \";\n}\nleaf templates {\n  type yang:counter32;\n  units \"Templates\";\n  config false;\n  description \"The number of Template Records (excluding\n    Options Template Records) written by the File Writer.\n    ... \";\n}\nleaf optionsTemplates {\n  type yang:counter32;\n  units \"Options Templates\";\n  config false;\n  description \"The number of Options Template Records written\n    by the File Writer. ... \";\n}\nleaf fileWriterDiscontinuityTime {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    type yang:date-and-time;\n    config false;\n    description \"Timestamp of the most recent occasion at which\n      one or more File Writer counters suffered a discontinuity.\n      ... \";\n  }\n  list template {\n    config false;\n    description \"This list contains the Templates and Options\n      Templates that have been written by the File Reader. ... \";\n    uses templateParameters;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type ExportingProcess {\n  if-feature exporter;\n  description \"Exporting Process of the Monitoring Device.\";\n  key name;\n  leaf name {\n    type nameType;\n    description \"Key of this list.\";\n  }\n  leaf exportMode {\n    type identityref {\n      base \"exportMode\";\n    }\n    default parallel;\n    description \"This parameter determines to which configured\n      destination(s) the incoming Data Records are exported.\";\n  }\n  ct:instance-list destination {\n    ct:instance-type ExportDestination;\n    min-elements 1;\n    description \"Export destinations.\";\n  }\n  list options {\n    key name;\n    description \"List of options reported by the Exporting\n      Process.\";\n    leaf name {\n      type nameType;\n      description \"Key of this list.\";\n    }\n    leaf optionsType {\n      type identityref {\n        base \"optionsType\";\n      }\n      mandatory true;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      description \"Type of the exported options data.\";\n    }\n    leaf optionsTimeout {\n      type uint32;\n      units milliseconds;\n      description \"Time interval for periodic export of the options\n        data. ... \";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type CollectingProcess {\n  description \"A Collecting Process.\";\n  key name;\n  leaf name {\n    type nameType;\n    description \"Key of a collecing process.\";\n  }\n  ct:instance-list sctpCollector {\n    ct:instance-type SctpCollector;\n    description \"List of SCTP receivers (sockets) on which the\n      Collecting Process receives IPFIX Messages.\";\n  }\n  ct:instance-list udpCollector {\n    if-feature udpTransport;\n    ct:instance-type UdpCollector;\n    description \"List of UDP receivers (sockets) on which the\n      Collecting Process receives IPFIX Messages.\";\n  }\n  ct:instance-list tcpCollector {\n    if-feature tcpTransport;\n    ct:instance-type TcpCollector;\n    description \"List of TCP receivers (sockets) on which the\n      Collecting Process receives IPFIX Messages.\";\n  }\n  ct:instance-list fileReader {\n    if-feature fileReader;\n    ct:instance-type FileReader;\n    description \"List of File Readers from which the Collecting\n      Process reads IPFIX Messages.\";\n  }\n  leaf-list exportingProcess {\n    type instance-identifier { ct:instance-type ExportingProcess; }\n    description \"Export of received records without any\n      modifications.  Records are processed by all Exporting\n      Processes in the list.\";\n  }\n}\n     ct:complex-type Collector {\n    ct:abstract true;\n    description \"Abstract collector.\";\n    key name;\n    leaf name {\n      type nameType;\n      description \"Key of collectors\";\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type IpCollector {\n  ct:abstract true;\n  ct:extends Collector;\n  description \"Collector for IP transport protocols.\";\n  leaf localPort {\n    type inet:port-number;\n    description \"If not configured, the Monitoring Device uses the\n      default port number for IPFIX, which is 4739 without\n      Transport Layer Security, and 4740 if Transport Layer\n      Security is activated.\";\n  }\n  container transportLayerSecurity {\n    presence \"If transportLayerSecurity is present, DTLS is enabled\n      if the transport protocol is SCTP or UDP, and TLS is enabled\n      if the transport protocol is TCP.\";\n    description \"Transport Layer Security configuration.\";\n    uses transportLayerSecurityParameters;\n  }\n  list transportSession {\n    config false;\n    description \"This list contains the currently established\n      Transport Sessions terminating at the given socket.\";\n    uses transportSessionParameters;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SctpCollector {\n  ct:extends IpCollector;\n  description \"Collector listening on an SCTP socket\";\n  leaf-list localIPAddress {\n    type inet:ip-address;\n    description \"List of local IP addresses ... \";\n    reference \"RFC 4960, Section 6.4\n      (Multi-Homed SCTP Endpoints).\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type UdpCollector {",
      "ja": "CT：complex-type udpcollector {"
    },
    {
      "indent": 5,
      "text": "  ct:extends IpCollector;\n  description \"Parameters of a listening UDP socket at a\n    Collecting Process.\";\n  leaf-list localIPAddress {\n    type inet:ip-address;\n    description \"List of local IP addresses on which the Collecting\n      Process listens for IPFIX Messages.\";\n  }\n  leaf templateLifeTime {\n    type uint32;\n    units seconds;\n    default 1800;\n    description \"Sets the lifetime of Templates for all UDP\n      Transport Sessions ... \";\n    reference \"RFC 5101, Section 10.3.7; RFC 5815, Section 8\n      (ipfixTransportSessionTemplateRefreshTimeout).\";\n  }\n  leaf optionsTemplateLifeTime {\n    type uint32;\n    units seconds;\n    default 1800;\n    description \"Sets the lifetime of Options Templates for all\n      UDP Transport Sessions terminating at this UDP socket.\n      ... \";\n    reference \"RFC 5101, Section 10.3.7; RFC 5815, Section 8\n      (ipfixTransportSessionOptionsTemplateRefreshTimeout).\";\n  }\n  leaf templateLifePacket {\n    type uint32;\n    units \"IPFIX Messages\";\n    description \"If this parameter is configured, Templates\n      defined in a UDP Transport Session become invalid if ...\";\n    reference \"RFC 5101, Section 10.3.7; RFC 5815, Section 8\n      (ipfixTransportSessionTemplateRefreshPacket).\";\n  }\n  leaf optionsTemplateLifePacket {\n    type uint32;\n    units \"IPFIX Messages\";\n    description \"If this parameter is configured, Options\n      Templates defined in a UDP Transport Session become\n      invalid if ...\";\n    reference \"RFC 5101, Section 10.3.7; RFC 5815, Section 8\n      (ipfixTransportSessionOptionsTemplateRefreshPacket).\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type TcpCollector {\n  ct:extends IpCollector;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "  description \"Collector listening on a TCP socket.\";\n  leaf-list localIPAddress {\n    type inet:ip-address;\n    description \"List of local IP addresses on which the Collecting\n      Process listens for IPFIX Messages.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type FileReader {\n  ct:extends Collector;\n  description \"File Reading collector.\";\n  leaf file {\n    type inet:uri;\n    mandatory true;\n    description \"URI specifying the location of the file.\";\n  }\n  leaf bytes {\n    type yang:counter64;\n    units octets;\n    config false;\n    description \"The number of bytes read by the File Reader.\n      ... \";\n  }\n  leaf messages {\n    type yang:counter64;\n    units \"IPFIX Messages\";\n    config false;\n    description \"The number of IPFIX Messages read by the File\n      Reader. ... \";\n  }\n  leaf records {\n    type yang:counter64;\n    units \"Data Records\";\n    config false;\n    description \"The number of Data Records read by the File\n      Reader. ... \";\n  }\n  leaf templates {\n    type yang:counter32;\n    units \"Templates\";\n    config false;\n    description \"The number of Template Records (excluding\n      Options Template Records) read by the File Reader. ...\";\n  }\n  leaf optionsTemplates {\n    type yang:counter32;\n    units \"Options Templates\";\n    config false;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    description \"The number of Options Template Records read by\n      the File Reader. ... \";\n  }\n  leaf fileReaderDiscontinuityTime {\n    type yang:date-and-time;\n    config false;\n    description \"Timestamp of the most recent occasion ... \";\n  }\n  list template {\n    config false;\n    description \"This list contains the Templates and Options\n      Templates that have been read by the File Reader.\n      Withdrawn or invalidated (Options) Templates MUST be removed\n      from this list.\";\n    uses templateParameters;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "ct:complex-type SelectionProcess {\n    description \"Selection Process\";\n    key name;\n    leaf name {\n      type nameType;\n      description \"Key of a selection process.\";\n    }\n    ct:instance-list selector {\n      ct:instance-type Selector;\n      min-elements 1;\n      ordered-by user;\n      description \"List of Selectors that define the action of the\n        Selection Process on a single packet.  The Selectors are\n        serially invoked in the same order as they appear in this\n        list.\";\n    }\n    list selectionSequence {\n      config false;\n      description \"This list contains the Selection Sequence IDs\n        which are assigned by the Monitoring Device ... \";\n      reference \"RFC 5476.\";\n      leaf observationDomainId {\n        type uint32;\n        description \"Observation Domain ID for which the\n          Selection Sequence ID is assigned.\";\n      }\n      leaf selectionSequenceId {\n        type uint64;\n        description \"Selection Sequence ID used in the Selection\n          Sequence (Statistics) Report Interpretation.\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    }\n  }\n  leaf cache {\n    type instance-identifier { ct:instance-type Cache; }\n    description \"Cache which receives the output of the\n      Selection Process.\";\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Groupings\n*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "grouping transportLayerSecurityParameters {\n  description \"Transport layer security parameters.\";\n  leaf-list localCertificationAuthorityDN {\n    type string;\n    description \"Distinguished names of certification authorities\n      whose certificates may be used to identify the local\n      endpoint.\";\n  }\n  leaf-list localSubjectDN {\n    type string;\n    description \"Distinguished names that may be used in the\n      certificates to identify the local endpoint.\";\n  }\n  leaf-list localSubjectFQDN {\n    type inet:domain-name;\n    description \"Fully qualified domain names that may be used to\n      in the certificates to identify the local endpoint.\";\n  }\n  leaf-list remoteCertificationAuthorityDN {\n    type string;\n    description \"Distinguished names of certification authorities\n      whose certificates are accepted to authorize remote\n      endpoints.\";\n  }\n  leaf-list remoteSubjectDN {\n    type string;\n    description \"Distinguished names that are accepted in\n      certificates to authorize remote endpoints.\";\n  }\n  leaf-list remoteSubjectFQDN {\n    type inet:domain-name;\n    description \"Fully qualified domain names that are accepted in\n      certificates to authorize remote endpoints.\";\n  }\n}\n     grouping templateParameters {\n  description \"State parameters of a Template used by an Exporting\n    Process or received by a Collecting Process ... \";\n  reference \"RFC 5101; RFC 5815, Section 8 (ipfixTemplateEntry,\n    ipfixTemplateDefinitionEntry, ipfixTemplateStatsEntry)\";\n  leaf observationDomainId {\n    type uint32;\n    description \"The ID of the Observation Domain for which this\n      Template is defined.\";\n    reference \"RFC 5815, Section 8\n      (ipfixTemplateObservationDomainId).\";\n  }\n  leaf templateId {\n    type uint16 {\n      range \"256..65535\" {\n        description \"Valid range of Template Ids.\";\n        reference \"RFC 5101\";\n      }\n    }\n    description \"This number indicates the Template Id in the IPFIX\n      message.\";\n    reference \"RFC 5815, Section 8 (ipfixTemplateId).\";\n  }\n  leaf setId {\n    type uint16;\n    description \"This number indicates the Set Id of the Template.\n      ... \";\n    reference \"RFC 5815, Section 8 (ipfixTemplateSetId).\";\n  }\n  leaf accessTime {\n    type yang:date-and-time;\n    description \"Used for Exporting Processes, ... \";\n    reference \"RFC 5815, Section 8 (ipfixTemplateAccessTime).\";\n  }\n  leaf templateDataRecords {\n    type yang:counter64;\n    description \"The number of transmitted or received Data\n      Records ... \";\n    reference \"RFC 5815, Section 8 (ipfixTemplateDataRecords).\";\n  }\n  leaf templateDiscontinuityTime {\n    type yang:date-and-time;\n    description \"Timestamp of the most recent occasion at which\n      the counter templateDataRecords suffered a discontinuity.\n      ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTemplateDiscontinuityTime).\";\n  }\n       list field {\n    description \"This list contains the (Options) Template\n      fields of which the (Options) Template is defined.\n      ... \";\n    leaf ieId {\n      type uint16 {\n        range \"1..32767\" {\n          description \"Valid range of Information Element\n              identifiers.\";\n          reference \"RFC 5102, Section 4.\";\n        }\n      }\n      description \"This parameter indicates the Information\n        Element Id of the field.\";\n      reference \"RFC 5815, Section 8 (ipfixTemplateDefinitionIeId);\n        RFC 5102.\";\n    }\n    leaf ieLength {\n      type uint16;\n      units octets;\n      description \"This parameter indicates the length of the\n        Information Element of the field.\";\n      reference \"RFC 5815, Section 8\n        (ipfixTemplateDefinitionIeLength); RFC 5102.\";\n    }\n    leaf ieEnterpriseNumber {\n      type uint32;\n      description \"This parameter indicates the IANA enterprise\n        number of the authority ... \";\n      reference \"RFC 5815, Section 8\n        (ipfixTemplateDefinitionEnterpriseNumber).\";\n    }\n    leaf isFlowKey {\n      when \"../../setId = 2\" {\n        description \"This parameter is available for non-Options\n          Templates (Set Id is 2).\";\n      }\n      type empty;\n      description \"If present, this is a Flow Key field.\";\n      reference \"RFC 5815, Section 8\n        (ipfixTemplateDefinitionFlags).\";\n    }\n    leaf isScope {\n      when \"../../setId = 3\" {\n        description \"This parameter is available for Options\n          Templates (Set Id is 3).\";\n      }\n      type empty;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "      description \"If present, this is a scope field.\";\n      reference \"RFC 5815, Section 8\n        (ipfixTemplateDefinitionFlags).\";\n    }\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "grouping transportSessionParameters {\n  description \"State parameters of a Transport Session ... \";\n  reference \"RFC 5101; RFC 5815, Section 8\n    (ipfixTransportSessionEntry,\n     ipfixTransportSessionStatsEntry)\";\n  leaf ipfixVersion {\n    type uint16;\n    description \"Used for Exporting Processes, this parameter\n      contains the version number of the IPFIX protocol ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionIpfixVersion).\";\n  }\n  leaf sourceAddress {\n    type inet:ip-address;\n    description \"The source address of the Exporter of the\n      IPFIX Transport Session... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionSourceAddressType,\n      ipfixTransportSessionSourceAddress).\";\n  }\n  leaf destinationAddress {\n    type inet:ip-address;\n    description \"The destination address of the Collector of\n      the IPFIX Transport Session... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionDestinationAddressType,\n      ipfixTransportSessionDestinationAddress).\";\n  }\n  leaf sourcePort {\n    type inet:port-number;\n    description \"The transport protocol port number of the\n      Exporter of the IPFIX Transport Session.\";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionSourcePort).\";\n  }\n  leaf destinationPort {\n    type inet:port-number;\n    description \"The transport protocol port number of the\n      Collector of the IPFIX Transport Session... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionDestinationPort).\";",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "}\nleaf sctpAssocId {\n  type uint32;\n  description \"The association id used for the SCTP session\n    between the Exporter and the Collector ... \";\n  reference \"RFC 5815, Section 8\n    (ipfixTransportSessionSctpAssocId),\n    RFC 3871\";\n}\nleaf status {\n  type transportSessionStatus;\n  description \"Status of the Transport Session.\";\n  reference \"RFC 5815, Section 8 (ipfixTransportSessionStatus).\";\n}\nleaf rate {\n  type yang:gauge32;\n  units \"bytes per second\";\n  description \"The number of bytes per second transmitted by the\n    Exporting Process or received by the Collecting Process.\n    This parameter is updated every second.\";\n  reference \"RFC 5815, Section 8 (ipfixTransportSessionRate).\";\n}\nleaf bytes {\n  type yang:counter64;\n  units bytes;\n  description \"The number of bytes transmitted by the\n    Exporting Process or received by the Collecting\n    Process ... \";\n  reference \"RFC 5815, Section 8 (ipfixTransportSessionBytes).\";\n}\nleaf messages {\n  type yang:counter64;\n  units \"IPFIX Messages\";\n  description \"The number of messages transmitted by the\n    Exporting Process or received by the Collecting Process... \";\n  reference \"RFC 5815, Section 8\n    (ipfixTransportSessionMessages).\";\n}\nleaf discardedMessages {\n  type yang:counter64;\n  units \"IPFIX Messages\";\n  description \"Used for Exporting Processes, this parameter\n    indicates the number of messages that could not be\n    sent ...\";\n  reference \"RFC 5815, Section 8\n    (ipfixTransportSessionDiscardedMessages).\";\n}\nleaf records {",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "    type yang:counter64;\n    units \"Data Records\";\n    description \"The number of Data Records transmitted ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionRecords).\";\n  }\n  leaf templates {\n    type yang:counter32;\n    units \"Templates\";\n    description \"The number of Templates transmitted by the\n      Exporting Process or received by the Collecting Process.\n      ... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionTemplates).\";\n  }\n  leaf optionsTemplates {\n    type yang:counter32;\n    units \"Options Templates\";\n    description \"The number of Option Templates transmitted by the\n      Exporting Process or received by the Collecting Process...\";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionOptionsTemplates).\";\n  }\n  leaf transportSessionStartTime {\n    type yang:date-and-time;\n    description \"Timestamp of the start of the given Transport\n      Session... \";\n  }\n  leaf transportSessionDiscontinuityTime {\n    type yang:date-and-time;\n    description \"Timestamp of the most recent occasion at which\n      one or more of the Transport Session counters suffered a\n      discontinuity... \";\n    reference \"RFC 5815, Section 8\n      (ipfixTransportSessionDiscontinuityTime).\";\n  }\n  list template {\n    description \"This list contains the Templates and Options\n      Templates that are transmitted by the Exporting Process\n      or received by the Collecting Process.\n      Withdrawn or invalidated (Options) Templates MUST be removed\n      from this list.\";\n    uses templateParameters;\n  }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "/*****************************************************************\n* Main container",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "*****************************************************************/",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "container ipfix {\n  description \"Top-level node of the IPFIX/PSAMP configuration\n    data model.\";\n  ct:instance-list collectingProcess {\n    if-feature collector;\n    ct:instance-type CollectingProcess;\n  }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ct:instance-list observationPoint {\n  if-feature meter;\n  ct:instance-type ObservationPoint;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ct:instance-list selectionProcess {\n  if-feature meter;\n  ct:instance-type SelectionProcess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ct:instance-list cache {\n  if-feature meter;\n  description \"Cache of the Monitoring Device.\";\n  ct:instance-type Cache;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ct:instance-list exportingProcess {\n  if-feature exporter;\n  description \"Exporting Process of the Monitoring Device.\";\n  ct:instance-type ExportingProcess;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "     }\n}\n<CODE ENDS>\nAuthors' Addresses",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Bernd Linowski TCS/Nokia Siemens Networks Heltorfer Strasse 1 Duesseldorf 40472 Germany",
      "ja": "Bernd Linowski TCS/Nokia Siemens Networks Heltorfer Strasse 1 Duesseldorf 40472ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: bernd.linowski.ext@nsn.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Mehmet Ersue Nokia Siemens Networks St.-Martin-Strasse 76 Munich 81541 Germany",
      "ja": "Mehmet Ersue Nokia Siemens Networks St.-Martin-Strasse 76 Munich 81541ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: mehmet.ersue@nsn.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Siarhei Kuryla 360 Treasury Systems Grueneburgweg 16-18 Frankfurt am Main 60322 Germany",
      "ja": "Siarhei Kuryla 360 Treasury Systems Grueneburgweg 16-18 Frankfurt am Main 60322ドイツ"
    },
    {
      "indent": 3,
      "text": "EMail: s.kuryla@gmail.com",
      "raw": true,
      "ja": ""
    }
  ]
}