{
  "title": {
    "text": "RFC 9043 - FFV1 Video Coding Format Versions 0, 1, and 3",
    "ja": "RFC 9043 - FFV1ビデオコーディングフォーマットバージョン0,1、および3"
  },
  "number": 9043,
  "created_at": "2021-08-25 02:59:05.153988+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                    M. Niedermayer\nRequest for Comments: 9043\nCategory: Informational                                          D. Rice\nISSN: 2070-1721\n                                                             J. Martinez\n                                                             August 2021",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "FFV1 Video Coding Format Versions 0, 1, and 3",
      "ja": "FFV1ビデオコーディングフォーマットバージョン0,1、および3"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document defines FFV1, a lossless, intra-frame video encoding format. FFV1 is designed to efficiently compress video data in a variety of pixel formats. Compared to uncompressed video, FFV1 offers storage compression, frame fixity, and self-description, which makes FFV1 useful as a preservation or intermediate video format.",
      "ja": "このドキュメントはFFv1、ロスレス、フレーム内ビデオエンコードフォーマットを定義します。FFV1は、さまざまなピクセルフォーマットでビデオデータを効率的に圧縮するように設計されています。非圧縮ビデオと比較して、FFV1はストレージ圧縮、フレーム固定、および自己記述を提供します。これにより、FFV1は保存または中間ビデオフォーマットとして役立ちます。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準のトラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表します。それは公開レビューを受け、インターネットエンジニアリングステアリンググループ（IESG）による出版の承認を受けました。IESGによって承認されたすべての文書がすべてのレベルのインターネット規格の候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9043.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/frfc9043で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2021 IETF信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.",
      "ja": "このドキュメントは、このドキュメントの発行日に有効なBCP 78およびIETFドキュメントに関連するIETFトラストの法的規定（https://trustee.ietf.org/license-info）の対象となります。 これらのドキュメントは、このドキュメントに関するお客様の権利と制限について説明しているため、注意深く確認してください。 このドキュメントから抽出されたコードコンポーネントには、Trust LegalProvisionsのセクション4.eで説明されているSimplifiedBSD Licenseテキストが含まれている必要があり、Simplified BSDLicenseで説明されているように保証なしで提供されます。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Notation and Conventions\n  2.1.  Definitions\n  2.2.  Conventions\n    2.2.1.  Pseudocode\n    2.2.2.  Arithmetic Operators\n    2.2.3.  Assignment Operators\n    2.2.4.  Comparison Operators\n    2.2.5.  Mathematical Functions\n    2.2.6.  Order of Operation Precedence\n    2.2.7.  Range\n    2.2.8.  NumBytes\n    2.2.9.  Bitstream Functions\n3.  Sample Coding\n  3.1.  Border\n  3.2.  Samples\n  3.3.  Median Predictor\n    3.3.1.  Exception\n  3.4.  Quantization Table Sets\n  3.5.  Context\n  3.6.  Quantization Table Set Indexes\n  3.7.  Color Spaces\n    3.7.1.  YCbCr\n    3.7.2.  RGB\n  3.8.  Coding of the Sample Difference\n    3.8.1.  Range Coding Mode\n    3.8.2.  Golomb Rice Mode\n4.  Bitstream\n  4.1.  Quantization Table Set\n    4.1.1.  \"quant_tables\"\n    4.1.2.  \"context_count\"\n  4.2.  Parameters\n    4.2.1.  \"version\"\n    4.2.2.  \"micro_version\"\n    4.2.3.  \"coder_type\"\n    4.2.4.  \"state_transition_delta\"\n    4.2.5.  \"colorspace_type\"\n    4.2.6.  \"chroma_planes\"\n    4.2.7.  \"bits_per_raw_sample\"\n    4.2.8.  \"log2_h_chroma_subsample\"\n    4.2.9.  \"log2_v_chroma_subsample\"\n    4.2.10. \"extra_plane\"\n    4.2.11. \"num_h_slices\"\n    4.2.12. \"num_v_slices\"\n    4.2.13. \"quant_table_set_count\"\n    4.2.14. \"states_coded\"\n    4.2.15. \"initial_state_delta\"\n    4.2.16. \"ec\"\n    4.2.17. \"intra\"\n  4.3.  Configuration Record\n    4.3.1.  \"reserved_for_future_use\"\n    4.3.2.  \"configuration_record_crc_parity\"\n    4.3.3.  Mapping FFV1 into Containers\n  4.4.  Frame\n  4.5.  Slice\n  4.6.  Slice Header\n    4.6.1.  \"slice_x\"\n    4.6.2.  \"slice_y\"\n    4.6.3.  \"slice_width\"\n    4.6.4.  \"slice_height\"\n    4.6.5.  \"quant_table_set_index_count\"\n    4.6.6.  \"quant_table_set_index\"\n    4.6.7.  \"picture_structure\"\n    4.6.8.  \"sar_num\"\n    4.6.9.  \"sar_den\"\n  4.7.  Slice Content\n    4.7.1.  \"primary_color_count\"\n    4.7.2.  \"plane_pixel_height\"\n    4.7.3.  \"slice_pixel_height\"\n    4.7.4.  \"slice_pixel_y\"\n  4.8.  Line\n    4.8.1.  \"plane_pixel_width\"\n    4.8.2.  \"slice_pixel_width\"\n    4.8.3.  \"slice_pixel_x\"\n    4.8.4.  \"sample_difference\"\n  4.9.  Slice Footer\n    4.9.1.  \"slice_size\"\n    4.9.2.  \"error_status\"\n    4.9.3.  \"slice_crc_parity\"\n5.  Restrictions\n6.  Security Considerations\n7.  IANA Considerations\n  7.1.  Media Type Definition\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Multithreaded Decoder Implementation Suggestions\nAppendix B.  Future Handling of Some Streams Created by\n        Nonconforming Encoders\nAppendix C.  FFV1 Implementations\n  C.1.  FFmpeg FFV1 Codec\n  C.2.  FFV1 Decoder in Go\n  C.3.  MediaConch\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes FFV1, a lossless video encoding format. The design of FFV1 considers the storage of image characteristics, data fixity, and the optimized use of encoding time and storage requirements. FFV1 is designed to support a wide range of lossless video applications such as long-term audiovisual preservation, scientific imaging, screen recording, and other video encoding scenarios that seek to avoid the generational loss of lossy video encodings.",
      "ja": "この文書では、FFv1、無損失ビデオエンコーディング形式について説明します。FFV1の設計は、画像特性、データ固定、および符号化時間と記憶域要件の最適化された使用の記憶を考慮しています。FFV1は、長期的な視聴覚保存、科学的イメージング、スクリーン記録、および損失のあるビデオエンコーディングの世代損失を回避しようとする他のビデオエンコードシナリオなどの幅広いロスレスビデオアプリケーションをサポートするように設計されています。"
    },
    {
      "indent": 3,
      "text": "This document defines versions 0, 1, and 3 of FFV1. The distinctions of the versions are provided throughout the document, but in summary:",
      "ja": "この文書はFFV1のバージョン0,1、および3を定義します。バージョンの区別は文書全体にわたって提供されますが、概要："
    },
    {
      "indent": 3,
      "text": "* Version 0 of FFV1 was the original implementation of FFV1 and was flagged as stable on April 14, 2006 [FFV1_V0].",
      "ja": "* FFV1のバージョン0はFFV1の元の実装であり、2006年4月14日に安定してフラグが立てられました[FFV1_V0]。"
    },
    {
      "indent": 3,
      "text": "* Version 1 of FFV1 adds support of more video bit depths and was flagged as stable on April 24, 2009 [FFV1_V1].",
      "ja": "* FFV1のバージョン1は、より多くのビデオビット深さのサポートを追加し、2009年4月24日、[FFV1_v1]で安定したフラグを立てました。"
    },
    {
      "indent": 3,
      "text": "* Version 2 of FFV1 only existed in experimental form and is not described by this document, but it is available as a LyX file at <https://github.com/FFmpeg/FFV1/ blob/8ad772b6d61c3dd8b0171979a2cd9f11924d5532/ffv1.lyx>.",
      "ja": "* FFV1のバージョン2は実験形式でのみ存在しており、この文書では説明されていませんが、<https：//github.com/ffmpeg/ffv1/blob / 8ad772b6d61c3dd8b017979a2cd9f11924d5532 / ffv1.lyx>のLYXファイルとして入手できます。"
    },
    {
      "indent": 3,
      "text": "* Version 3 of FFV1 adds several features such as increased description of the characteristics of the encoding images and embedded Cyclic Redundancy Check (CRC) data to support fixity verification of the encoding. Version 3 was flagged as stable on August 17, 2013 [FFV1_V3].",
      "ja": "* FFV1のバージョン3は、符号化画像の特性の記述の詳細、埋め込み巡回冗長検査（CRC）データの記述など、エンコードの固定検証をサポートするいくつかの機能を追加します。バージョン3は、2013年8月17日に安定したフラグを付けられました[FFV1_v3]。"
    },
    {
      "indent": 3,
      "text": "This document assumes familiarity with mathematical and coding concepts such as Range encoding [Range-Encoding] and YCbCr color spaces [YCbCr].",
      "ja": "この文書は、範囲符号化[範囲符号化]やYCBCR色空間[YCBCR]などの数学的および符号化概念に精通している。"
    },
    {
      "indent": 3,
      "text": "This specification describes the valid bitstream and how to decode it. Nonconformant bitstreams and the nonconformant handling of bitstreams are outside this specification. A decoder can perform any action that it deems appropriate for an invalid bitstream: reject the bitstream, attempt to perform error concealment, or re-download or use a redundant copy of the invalid part.",
      "ja": "この仕様では、有効なビットストリームと復号方法について説明します。不適合ビットストリームとビットストリームの不適合的な処理はこの仕様の外側にあります。デコーダは、無効なビットストリームに適していると判断する任意の動作を実行できます。ビットストリームを拒否し、エラーの隠蔽を実行したり、無効な部分の冗長コピーを再ダウンロードしたりします。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Conventions",
      "section_title": true,
      "ja": "2. 表記法と規則"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2.1. Definitions",
      "section_title": true,
      "ja": "2.1. 定義"
    },
    {
      "indent": 3,
      "text": "FFV1: The chosen name of this video encoding format, which is the short version of \"FF Video 1\". The letters \"FF\" come from \"FFmpeg\", which is the name of the reference decoder whose first letters originally meant \"Fast Forward\".",
      "ja": "FFV1：このビデオエンコーディングフォーマットの選択された名前。 \"FFビデオ1\"の短版です。文字「FF」は「FFMPEG」から来ており、これは最初の文字が最初に「早送り」を意味している参照復号器の名前です。"
    },
    {
      "indent": 3,
      "text": "Container: A format that encapsulates Frames (see Section 4.4) and (when required) a \"Configuration Record\" into a bitstream.",
      "ja": "コンテナ：フレームをカプセル化するフォーマット（セクション4.4）と（必要な場合）ビットストリームへの「設定レコード」を参照してください。"
    },
    {
      "indent": 3,
      "text": "Sample: The smallest addressable representation of a color component or a luma component in a Frame. Examples of Sample are Luma (Y), Blue-difference Chroma (Cb), Red-difference Chroma (Cr), Transparency, Red, Green, and Blue.",
      "ja": "サンプル：フレーム内の色成分またはLUMA成分の最小のアドレス指定可能な表現。サンプルの例は、LUMA（Y）、青色差クロマ（CB）、赤色差クロマ（CR）、透明度、赤、緑、および青である。"
    },
    {
      "indent": 3,
      "text": "Symbol: A value stored in the bitstream, which is defined and decoded through one of the methods described in Table 4.",
      "ja": "シンボル：ビットストリームに格納されている値。表4に記載されている方法のうちの1つを通して定義および復号化されます。"
    },
    {
      "indent": 3,
      "text": "Line: A discrete component of a static image composed of Samples that represent a specific quantification of Samples of that image.",
      "ja": "線：その画像のサンプルの特定の定量化を表すサンプルからなる静的画像の離散成分。"
    },
    {
      "indent": 3,
      "text": "Plane: A discrete component of a static image composed of Lines that represent a specific quantification of Lines of that image.",
      "ja": "平面：その画像の線の特定の定量化を表す線からなる静的画像の離散的な構成要素。"
    },
    {
      "indent": 3,
      "text": "Pixel: The smallest addressable representation of a color in a Frame. It is composed of one or more Samples.",
      "ja": "ピクセル：フレーム内の色の最も小さいアドレス指定可能な表現。それは1つ以上のサンプルからなる。"
    },
    {
      "indent": 3,
      "text": "MSB: Most Significant Bit, the bit that can cause the largest change in magnitude of the symbol.",
      "ja": "MSB：最上位ビット、シンボルの大きさの最大の変更を引き起こす可能性があるビット。"
    },
    {
      "indent": 3,
      "text": "VLC: Variable Length Code, a code that maps source symbols to a variable number of bits.",
      "ja": "VLC：可変長コード、ソースシンボルを可変数のビット数にマッピングするコード。"
    },
    {
      "indent": 3,
      "text": "RGB: A reference to the method of storing the value of a pixel by using three numeric values that represent Red, Green, and Blue.",
      "ja": "RGB：赤、緑、青を表す3つの数値を用いて、画素の値を格納する方法への参照。"
    },
    {
      "indent": 3,
      "text": "YCbCr: A reference to the method of storing the value of a pixel by using three numeric values that represent the luma of the pixel (Y) and the chroma of the pixel (Cb and Cr). The term YCbCr is used for historical reasons and currently references any color space relying on one luma Sample and two chroma Samples, e.g., YCbCr (luma, blue-difference chroma, red-difference chroma), YCgCo, or ICtCp (intensity, blue-yellow, red-green).",
      "ja": "YCBCR：画素（Y）の輝度を表す3つの数値と画素の彩度（CBとCR）を用いて画素の値を格納する方法への参照。YCBCRという用語は歴史的な理由で使用されており、現在1つのLUMAサンプルと2つのクロマサンプル、例えばYCBCR（Luma、青色差クロマ、赤差彩度彩度）、YCGCO、またはICTCPの2つの任意の色空間を参照しています（強度、青 - 黄色、赤緑）。"
    },
    {
      "indent": 0,
      "text": "2.2. Conventions",
      "section_title": true,
      "ja": "2.2. 規約"
    },
    {
      "indent": 0,
      "text": "2.2.1. Pseudocode",
      "section_title": true,
      "ja": "2.2.1. 擬似コード"
    },
    {
      "indent": 3,
      "text": "The FFV1 bitstream is described in this document using pseudocode. Note that the pseudocode is used to illustrate the structure of FFV1 and is not intended to specify any particular implementation. The pseudocode used is based upon the C programming language [ISO.9899.2018] and uses its \"if/else\", \"while\", and \"for\" keywords as well as functions defined within this document.",
      "ja": "FFV1ビットストリームは、疑似コードを使用してこの文書に記載されています。疑似コードはFFV1の構造を説明するために使用され、特定の実装を指定することを意図していないことに注意してください。使用されている疑似コードは、Cプログラミング言語[ISO.9899.2018]に基づいており、その「if / else」、「while」、および「for」キーワード、およびこの文書内で定義された関数を使用しています。"
    },
    {
      "indent": 3,
      "text": "In some instances, pseudocode is presented in a two-column format such as shown in Figure 1. In this form, the \"type\" column provides a symbol as defined in Table 4 that defines the storage of the data referenced in that same line of pseudocode.",
      "ja": "場合によっては、疑似コードは図1に示すような2列の形式で表示されます。この形式では、「Type」列は表4に定義されているシンボルを表4に示します。擬似コード"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nExamplePseudoCode( ) {                                        |\n    value                                                     | ur\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 1: A depiction of type-labeled pseudocode used within this document.",
      "ja": "図1：この文書内で使用されているタイプラベル付き擬似コードの描写。"
    },
    {
      "indent": 0,
      "text": "2.2.2. Arithmetic Operators",
      "section_title": true,
      "ja": "2.2.2. 算術演算子"
    },
    {
      "indent": 3,
      "text": "Note: the operators and the order of precedence are the same as used in the C programming language [ISO.9899.2018], with the exception of \">>\" (removal of implementation-defined behavior) and \"^\" (power instead of XOR) operators, which are redefined within this section.",
      "ja": "注：演算子と優先順位の順序は、「>>」（実装定義の動作の取り外し）と \"^\"（XORの代わりに）を除いて、Cプログラミング言語[ISO.9899.2018]で使用されているものと同じです。このセクションで再定義されている演算子。"
    },
    {
      "indent": 3,
      "text": "\"a + b\" means a plus b.",
      "ja": "「A B」はプラスBを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a - b\" means a minus b.",
      "ja": "「A  -  B」はマイナスBを意味する。"
    },
    {
      "indent": 3,
      "text": "\"-a\" means negation of a.",
      "ja": "\"-a\"はaの否定を意味します。"
    },
    {
      "indent": 3,
      "text": "\"a * b\" means a multiplied by b.",
      "ja": "「a * b」とは、bを乗算したことを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a / b\" means a divided by b.",
      "ja": "「a / b」はbで割ったものを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a ^ b\" means a raised to the b-th power.",
      "ja": "「a ^ b」とは、b番目の電力に上昇することを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a & b\" means bitwise \"and\" of a and b.",
      "ja": "「A＆B」は、AとBのビットごとの「AND」を意味します。"
    },
    {
      "indent": 3,
      "text": "\"a | b\" means bitwise \"or\" of a and b.",
      "ja": "「A | B」は、AとBのビット単位「または」を意味する。"
    },
    {
      "indent": 3,
      "text": "\"a >> b\" means arithmetic right shift of the two's complement integer representation of a by b binary digits. This is equivalent to dividing a by 2, b times, with rounding toward negative infinity.",
      "ja": "「A >> B」は、B 2進数の2の補数整数表現の算術右シフトを意味します。これは、負の無限大に丸めて、2 B回、B倍を分割することと等価です。"
    },
    {
      "indent": 3,
      "text": "\"a << b\" means arithmetic left shift of the two's complement integer representation of a by b binary digits.",
      "ja": "「<< B」とは、B 2の2進数の2つの補数整数表現の算術左シフトを意味する。"
    },
    {
      "indent": 0,
      "text": "2.2.3. Assignment Operators",
      "section_title": true,
      "ja": "2.2.3. 代入演算子"
    },
    {
      "indent": 3,
      "text": "\"a = b\" means a is assigned b.",
      "ja": "「a = b」とは、aを割り当てられていることを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a++\" is equivalent to a is assigned a + 1.",
      "ja": "「a」がAに相当するA 1に相当する。"
    },
    {
      "indent": 3,
      "text": "\"a--\" is equivalent to a is assigned a - 1.",
      "ja": "\"a--\"がA  -  1に相当する。"
    },
    {
      "indent": 3,
      "text": "\"a += b\" is equivalent to a is assigned a + b.",
      "ja": "「a = b」はAに等価である。"
    },
    {
      "indent": 3,
      "text": "\"a -= b\" is equivalent to a is assigned a - b.",
      "ja": "「a  -  = b」がA  -  Bに相当する。"
    },
    {
      "indent": 3,
      "text": "\"a *= b\" is equivalent to a is assigned a * b.",
      "ja": "「a * = b」がA * Bに相当する。"
    },
    {
      "indent": 0,
      "text": "2.2.4. Comparison Operators",
      "section_title": true,
      "ja": "2.2.4. 比較演算子"
    },
    {
      "indent": 3,
      "text": "\"a > b\" is true when a is greater than b.",
      "ja": "AがBより大きい場合、「A> B」は真実です。"
    },
    {
      "indent": 3,
      "text": "\"a >= b\" is true when a is greater than or equal to b.",
      "ja": "aがb以上の場合、 \"A> = b\"は真です。"
    },
    {
      "indent": 3,
      "text": "\"a < b\" is true when a is less than b.",
      "ja": "A aがb未満の場合、「a <b」は当てはまる。"
    },
    {
      "indent": 3,
      "text": "\"a <= b\" is true when a is less than or equal b.",
      "ja": "A <= B」は、aがb以下の場合に該当する。"
    },
    {
      "indent": 3,
      "text": "\"a == b\" is true when a is equal to b.",
      "ja": "A aがbに等しい場合、 \"A == B\"は真です。"
    },
    {
      "indent": 3,
      "text": "\"a != b\" is true when a is not equal to b.",
      "ja": "\"a！= b\"は、aがbに等しくないときに該当です。"
    },
    {
      "indent": 3,
      "text": "\"a && b\" is true when both a is true and b is true.",
      "ja": "aが真実であり、bの両方が真実である場合は、「A && B」が真です。"
    },
    {
      "indent": 3,
      "text": "\"a || b\" is true when either a is true or b is true.",
      "ja": "\"A || b\"がtrueまたはbのどちらかがtrueの場合、trueです。"
    },
    {
      "indent": 3,
      "text": "\"!a\" is true when a is not true.",
      "ja": "\"！a\"が真実ではないときに真実です。"
    },
    {
      "indent": 3,
      "text": "\"a ? b : c\" if a is true, then b, otherwise c.",
      "ja": "Aが真実である場合は、「A？B：C」、B、そうでなければc。"
    },
    {
      "indent": 0,
      "text": "2.2.5. Mathematical Functions",
      "section_title": true,
      "ja": "2.2.5. 数学関数"
    },
    {
      "indent": 3,
      "text": "\"floor(a)\" means the largest integer less than or equal to a.",
      "ja": "「床（a）」は、それ以下の最大の整数を意味します。"
    },
    {
      "indent": 3,
      "text": "\"ceil(a)\" means the smallest integer greater than or equal to a.",
      "ja": "「CEIL（a）」は、それ以上の最小の整数を意味します。"
    },
    {
      "indent": 3,
      "text": "\"sign(a)\" extracts the sign of a number, i.e., if a < 0 then -1, else if a > 0 then 1, else 0.",
      "ja": "「サイン（a）」は、<0の場合、すなわち-1が> 0の場合、a> 0の場合は1、他の場合は0。"
    },
    {
      "indent": 3,
      "text": "\"abs(a)\" means the absolute value of a, i.e., \"abs(a)\" = \"sign(a) * a\".",
      "ja": "「ABS（a）」は、A、すなわち「ABS（a）」符号（a）* a」の絶対値を意味する。"
    },
    {
      "indent": 3,
      "text": "\"log2(a)\" means the base-two logarithm of a.",
      "ja": "「log2（a）」は、aの基本2対数を意味します。"
    },
    {
      "indent": 3,
      "text": "\"min(a,b)\" means the smaller of two values a and b.",
      "ja": "「min（a、b）」は、2つの値aとbの小さい方を意味します。"
    },
    {
      "indent": 3,
      "text": "\"max(a,b)\" means the larger of two values a and b.",
      "ja": "「最大（a、b）」は、2つの値AとBの大きいことを意味します。"
    },
    {
      "indent": 3,
      "text": "\"median(a,b,c)\" means the numerical middle value in a data set of a, b, and c, i.e., \"a+b+c-min(a,b,c)-max(a,b,c)\".",
      "ja": "「中央値（a、b、c）」は、A、B、Cのデータセット内の数値中間値、すなわち「AB C-Min（A、B、C）」-MAX（A、B、C）を意味する。\"。"
    },
    {
      "indent": 3,
      "text": "\"a ==> b\" means a implies b.",
      "ja": "「a ==> b」とは、意味bを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a <==> b\" means a ==> b, b ==> a.",
      "ja": "「a <==> b」は、==> b、b ==> aを意味する。"
    },
    {
      "indent": 3,
      "text": "\"a_b\" means the b-th value of a sequence of a.",
      "ja": "「a b」とは、aのシーケンスの値を意味する。"
    },
    {
      "indent": 3,
      "text": "\"a_(b,c)\" means the 'b,c'-th value of a sequence of a.",
      "ja": "「A_（B、C）」は、Aのシーケンスの「B」、C '番目の値を意味する。"
    },
    {
      "indent": 0,
      "text": "2.2.6. Order of Operation Precedence",
      "section_title": true,
      "ja": "2.2.6. 操作の優先順位の順序"
    },
    {
      "indent": 3,
      "text": "When order of precedence is not indicated explicitly by use of parentheses, operations are evaluated in the following order (from top to bottom, operations of same precedence being evaluated from left to right). This order of operations is based on the order of operations used in Standard C.",
      "ja": "優先順位が括弧を使用して明示的に示されていない場合、操作は次の順序で評価されます（上から下に、同じ優位の操作が左から右へと評価されます）。この操作の順序は、標準Cで使用される操作の順序に基づいています。"
    },
    {
      "indent": 3,
      "text": "a++, a--\n!a, -a\na ^ b\na * b, a / b\na + b, a - b\na << b, a >> b\na < b, a <= b, a > b, a >= b\na == b, a != b\na & b\na | b\na && b\na || b\na ? b : c\na = b, a += b, a -= b, a *= b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "2.2.7. Range",
      "section_title": true,
      "ja": "2.2.7. 範囲"
    },
    {
      "indent": 3,
      "text": "\"a...b\" means any value from a to b, inclusive.",
      "ja": "「A ... B」とは、AからBまでの値を意味します。"
    },
    {
      "indent": 0,
      "text": "2.2.8. NumBytes",
      "section_title": true,
      "ja": "2.2.8. num num"
    },
    {
      "indent": 3,
      "text": "\"NumBytes\" is a nonnegative integer that expresses the size in 8-bit octets of a particular FFV1 \"Configuration Record\" or \"Frame\". FFV1 relies on its container to store the \"NumBytes\" values; see Section 4.3.3.",
      "ja": "「NUMBYTES」は、特定のFFV1「構成レコード」または「フレーム」の8ビットオクテット内のサイズを表す非負整数です。FFV1は「NUMBYTES」の値を格納するためにコンテナに依存しています。セクション4.3.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "2.2.9. Bitstream Functions",
      "section_title": true,
      "ja": "2.2.9. ビットストリーム機能"
    },
    {
      "indent": 0,
      "text": "2.2.9.1. remaining_bits_in_bitstream",
      "section_title": true,
      "ja": "2.2.9.1. resment_bits_in_bitstream."
    },
    {
      "indent": 3,
      "text": "\"remaining_bits_in_bitstream( NumBytes )\" means the count of remaining bits after the pointer in that \"Configuration Record\" or \"Frame\". It is computed from the \"NumBytes\" value multiplied by 8 minus the count of bits of that \"Configuration Record\" or \"Frame\" already read by the bitstream parser.",
      "ja": "「lement_bits_in_bitstream（numbytes）」とは、その「構成レコード」または「フレーム」のポインタの後の残りのビットの数を意味します。「NUMBYTES」値から8マイナスの「構成レコード」または「フレーム」のビット数の数は、ビットストリームパーサーによって既に読み取られている。"
    },
    {
      "indent": 0,
      "text": "2.2.9.2. remaining_symbols_in_syntax",
      "section_title": true,
      "ja": "2.2.9.2. lement_symbols_in_syntax"
    },
    {
      "indent": 3,
      "text": "\"remaining_symbols_in_syntax( )\" is true as long as the range coder has not consumed all the given input bytes.",
      "ja": "\"lefent_symbols_in_syntax（）\"は、Range Coderが指定されたすべての入力バイトを消費していない限り、trueです。"
    },
    {
      "indent": 0,
      "text": "2.2.9.3. byte_aligned",
      "section_title": true,
      "ja": "2.2.9.3. byte_aligned"
    },
    {
      "indent": 3,
      "text": "\"byte_aligned( )\" is true if \"remaining_bits_in_bitstream( NumBytes )\" is a multiple of 8, otherwise false.",
      "ja": "\"rester_bits_in_bitstream（numbytes）\"が8の倍数、それ以外の場合はfalseの場合、 \"byte_aligned（）\"はtrueです。"
    },
    {
      "indent": 0,
      "text": "2.2.9.4. get_bits",
      "section_title": true,
      "ja": "2.2.9.4. get_bits."
    },
    {
      "indent": 3,
      "text": "\"get_bits( i )\" is the action to read the next \"i\" bits in the bitstream, from most significant bit to least significant bit, and to return the corresponding value. The pointer is increased by \"i\".",
      "ja": "\"get_bits（i）\"は、ビットストリーム内の次の \"i\"ビットを最上位ビットから最下位ビットに読み取るためのアクションで、対応する値を返します。ポインタは「i」だけ増加します。"
    },
    {
      "indent": 0,
      "text": "3. Sample Coding",
      "section_title": true,
      "ja": "3. サンプルコーディング"
    },
    {
      "indent": 3,
      "text": "For each \"Slice\" (as described in Section 4.5) of a Frame, the Planes, Lines, and Samples are coded in an order determined by the color space (see Section 3.7). Each Sample is predicted by the median predictor as described in Section 3.3 from other Samples within the same Plane, and the difference is stored using the method described in Section 3.8.",
      "ja": "フレームの「スライス」（セクション4.5に記載されているように）ごとに、平面、線、およびサンプルは、色空間によって決定された順序で符号化されている（セクション3.7を参照）。各サンプルは、同じ平面内の他のサンプルからのセクション3.3に記載されているように、中央値予測子によって予測され、その差はセクション3.8に記載された方法を使用して記憶される。"
    },
    {
      "indent": 0,
      "text": "3.1. Border",
      "section_title": true,
      "ja": "3.1. 国境"
    },
    {
      "indent": 3,
      "text": "A border is assumed for each coded \"Slice\" for the purpose of the median predictor and context according to the following rules:",
      "ja": "以下の規則に従って、中央値予測子とコンテキストの目的で、符号化された「スライス」について境界が想定されます。"
    },
    {
      "indent": 3,
      "text": "* One column of Samples to the left of the coded Slice is assumed as identical to the Samples of the leftmost column of the coded Slice shifted down by one row. The value of the topmost Sample of the column of Samples to the left of the coded Slice is assumed to be \"0\".",
      "ja": "* 符号化スライスの左側にあるサンプルの1つの列は、1行ずつシフトダウンされた符号化スライスの最左の列のサンプルと同一であると仮定される。符号化スライスの左側へのサンプルの列の最上部サンプルの値は「0」とする。"
    },
    {
      "indent": 3,
      "text": "* One column of Samples to the right of the coded Slice is assumed as identical to the Samples of the rightmost column of the coded Slice.",
      "ja": "* 符号化スライスの右側のサンプルの1列は、符号化スライスの右端の列のサンプルと同一であると仮定される。"
    },
    {
      "indent": 3,
      "text": "* An additional column of Samples to the left of the coded Slice and two rows of Samples above the coded Slice are assumed to be \"0\".",
      "ja": "* 符号化スライスの左側にあるサンプルの追加の列と、符号化スライスの上に2列のサンプルを「0」とする。"
    },
    {
      "indent": 3,
      "text": "Figure 2 depicts a Slice of nine Samples \"a,b,c,d,e,f,g,h,i\" in a three-by-three arrangement along with its assumed border.",
      "ja": "図2は、想定された境界線と共に3×3の配置における9個のサンプル「A、B、C、D、E、F、G、H、I」のスライスを示す。"
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+---+---+---+---+\n| 0 | 0 |   | 0 | 0 | 0 |   | 0 |\n+---+---+---+---+---+---+---+---+\n| 0 | 0 |   | 0 | 0 | 0 |   | 0 |\n+---+---+---+---+---+---+---+---+\n|   |   |   |   |   |   |   |   |\n+---+---+---+---+---+---+---+---+\n| 0 | 0 |   | a | b | c |   | c |\n+---+---+---+---+---+---+---+---+\n| 0 | a |   | d | e | f |   | f |\n+---+---+---+---+---+---+---+---+\n| 0 | d |   | g | h | i |   | i |\n+---+---+---+---+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 2: A depiction of FFV1's assumed border for a set of example Samples.",
      "ja": "図2：一連のサンプルのセットに対するFFV1の想定境界の描写。"
    },
    {
      "indent": 0,
      "text": "3.2. Samples",
      "section_title": true,
      "ja": "3.2. サンプル"
    },
    {
      "indent": 3,
      "text": "Relative to any Sample \"X\", six other relatively positioned Samples from the coded Samples and presumed border are identified according to the labels used in Figure 3. The labels for these relatively positioned Samples are used within the median predictor and context.",
      "ja": "任意のサンプル「X」と比較して、符号化サンプルおよび推定境界からの6つの他の比較的配置されたサンプルが、図3で使用されるラベルに従って識別される。これらの比較的配置されたサンプルのラベルは、中央の予測および文脈内で使用される。"
    },
    {
      "indent": 3,
      "text": "+---+---+---+---+\n|   |   | T |   |\n+---+---+---+---+\n|   |tl | t |tr |\n+---+---+---+---+\n| L | l | X |   |\n+---+---+---+---+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 3: A depiction of how relatively positioned Samples are referenced within this document.",
      "ja": "図3：この文書内で比較的配置されたサンプルがどのように参照されるかの描写。"
    },
    {
      "indent": 3,
      "text": "The labels for these relative Samples are made of the first letters of the words Top, Left, and Right.",
      "ja": "これらの相対サンプルのラベルは、左上、左右の単語の最初の文字でできています。"
    },
    {
      "indent": 0,
      "text": "3.3. Median Predictor",
      "section_title": true,
      "ja": "3.3. 中央値の予測"
    },
    {
      "indent": 3,
      "text": "The prediction for any Sample value at position \"X\" may be computed based upon the relative neighboring values of \"l\", \"t\", and \"tl\" via this equation:",
      "ja": "位置「X」における任意のサンプル値の予測は、この式を介して「L」、「T」、および「TL」の相対隣接値に基づいて計算されてもよい。"
    },
    {
      "indent": 3,
      "text": "median(l, t, l + t - tl)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this prediction template is also used in [ISO.14495-1.1999] and [HuffYUV].",
      "ja": "この予測テンプレートは[ISO.14495-1.1999]および[Huffyuv]でも使用されます。"
    },
    {
      "indent": 0,
      "text": "3.3.1. Exception",
      "section_title": true,
      "ja": "3.3.1. 例外"
    },
    {
      "indent": 3,
      "text": "If \"colorspace_type == 0 && bits_per_raw_sample == 16 && ( coder_type == 1 || coder_type == 2 )\" (see Sections 4.2.5, 4.2.7, and 4.2.3), the following median predictor MUST be used:",
      "ja": "\"colorspace_type == 0 && bits_per_raw_sample == 16 &&（coder_type == 2）\"（セクション4.2.5,4.2.7、および4.2.3を参照）、次の中央値予測子を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "median(left16s, top16s, left16s + top16s - diag16s)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where:",
      "ja": "ただし："
    },
    {
      "indent": 3,
      "text": "left16s = l  >= 32768 ? ( l  - 65536 ) : l\ntop16s  = t  >= 32768 ? ( t  - 65536 ) : t\ndiag16s = tl >= 32768 ? ( tl - 65536 ) : tl",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Background: a two's complement 16-bit signed integer was used for storing Sample values in all known implementations of FFV1 bitstream (see Appendix C). So in some circumstances, the most significant bit was wrongly interpreted (used as a sign bit instead of the 16th bit of an unsigned integer). Note that when the issue was discovered, the only impacted configuration of all known implementations was the 16-bit YCbCr with no pixel transformation and with the range coder coder type, as the other potentially impacted configurations (e.g., the 15/16-bit JPEG 2000 Reversible Color Transform (RCT) [ISO.15444-1.2019] with range coder or the 16-bit content with the Golomb Rice coder type) were not implemented. Meanwhile, the 16-bit JPEG 2000 RCT with range coder was deployed without this issue in one implementation and validated by one conformance checker. It is expected (to be confirmed) that this exception for the median predictor will be removed in the next version of the FFV1 bitstream.",
      "ja": "背景：FFV1ビットストリームのすべての既知の実装においてサンプル値を格納するために、2の補数16ビット符号付き整数を使用した（付録Cを参照）。したがって、状況によっては、最上位ビットが誤って解釈されました（符号なし整数の16ビットの代わりに符号ビットとして使用されます）。問題が発見されたときに、すべての既知の実装の唯一の影響は、ピクセル変換がない16ビットYCBCRであり、他の潜在的に影響された構成（例えば、15/16ビットJPEGなど）2000リバーシブルカラー変換（RCT）[ISO.1544-1.2019]レンジコーダーまたはゴロンライスコーダータイプの16ビット含有量が実装されていません。一方、Range Coderを持つ16ビットJPEG 2000 RCTは、この問題なしで1つの実装で展開され、1つの適合性チェッカーによって検証されました。中央値予測子のこの例外は、FFV1ビットストリームの次のバージョンで削除されることが予想されます。"
    },
    {
      "indent": 0,
      "text": "3.4. Quantization Table Sets",
      "section_title": true,
      "ja": "3.4. 量子化テーブルセット"
    },
    {
      "indent": 3,
      "text": "Quantization Tables are used on Sample Differences (see Section 3.8), so Quantized Sample Differences are stored in the bitstream.",
      "ja": "量子化テーブルはサンプルの違いに使用されます（セクション3.8を参照）、そのため、量子化されたサンプルの違いはビットストリームに格納されます。"
    },
    {
      "indent": 3,
      "text": "The FFV1 bitstream contains one or more Quantization Table Sets. Each Quantization Table Set contains exactly five Quantization Tables with each Quantization Table corresponding to one of the five Quantized Sample Differences. For each Quantization Table, both the number of quantization steps and their distribution are stored in the FFV1 bitstream; each Quantization Table has exactly 256 entries, and the eight least significant bits of the Quantized Sample Difference are used as an index:",
      "ja": "FFV1ビットストリームには、1つ以上の量子化テーブルセットが含まれています。各量子化テーブルセットは、5つの量子化サンプル差のうちの1つに対応する各量子化テーブルを有する正確に5つの量子化テーブルを含む。各量子化テーブルについて、量子化ステップ数とそれらの分布の両方がFFV1ビットストリームに格納されています。各量子化テーブルは正確に256のエントリを持ち、量子化されたサンプル差の8つの最下位ビットがインデックスとして使用されます。"
    },
    {
      "indent": 3,
      "text": "Q_j[k] = quant_tables[i][j][k&255]",
      "ja": "q_j [k] = quant_tables [i] [j] [k＆255]"
    },
    {
      "indent": 4,
      "text": "Figure 4: Description of the mapping from sample differences to the corresponding Quantized Sample Differences.",
      "ja": "図4：サンプルの違いから対応する量子化されたサンプルの違いに対するマッピングの説明。"
    },
    {
      "indent": 3,
      "text": "In this formula, \"i\" is the Quantization Table Set index, \"j\" is the Quantized Table index, and \"k\" is the Quantized Sample Difference (see Section 4.1.1).",
      "ja": "この式において、「i」は量子化テーブルセットインデックスである「j」は量子化テーブルインデックスであり、「K」は量子化されたサンプル差である（セクション4.1.1参照）。"
    },
    {
      "indent": 0,
      "text": "3.5. Context",
      "section_title": true,
      "ja": "3.5. 環境"
    },
    {
      "indent": 3,
      "text": "Relative to any Sample \"X\", the Quantized Sample Differences \"L-l\", \"l-tl\", \"tl-t\", \"T-t\", and \"t-tr\" are used as context:",
      "ja": "任意のサンプル「X」に対して、量子化されたサンプルの差「L-L」、「L-L」、「T-T」、「T-T」、および「T-T」、および「T-TR」は、状況として使用されます。"
    },
    {
      "indent": 3,
      "text": "context = Q_0[l - tl] +\n          Q_1[tl - t] +\n          Q_2[t - tr] +\n          Q_3[L - l]  +\n          Q_4[T - t]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 5: Description of the computing of the Context.",
      "ja": "図5：コンテキストのコンピューティングの説明。"
    },
    {
      "indent": 3,
      "text": "If \"context >= 0\" then \"context\" is used, and the difference between the Sample and its predicted value is encoded as is; else \"-context\" is used, and the difference between the Sample and its predicted value is encoded with a flipped sign.",
      "ja": "「CONTEXT> = 0」が「コンテキスト」が使用されている場合、サンプルとその予測値の差はそのままに符号化される。そうでなければ「-Context」が使用され、サンプルとその予測値の差は反転記号で符号化されています。"
    },
    {
      "indent": 0,
      "text": "3.6. Quantization Table Set Indexes",
      "section_title": true,
      "ja": "3.6. 量子化テーブルセットインデックス"
    },
    {
      "indent": 3,
      "text": "For each Plane of each Slice, a Quantization Table Set is selected from an index:",
      "ja": "各スライスの各面ごとに、量子化テーブルセットがインデックスから選択されます。"
    },
    {
      "indent": 3,
      "text": "* For Y Plane, \"quant_table_set_index[ 0 ]\" index is used.",
      "ja": "* y平面の場合、「quant_table_set_index [0]」インデックスが使用されます。"
    },
    {
      "indent": 3,
      "text": "* For Cb and Cr Planes, \"quant_table_set_index[ 1 ]\" index is used.",
      "ja": "* CBおよびCRプレーンの場合は、「QUATT_TABLE_SET_INDEX [1]」インデックスが使用されます。"
    },
    {
      "indent": 3,
      "text": "* For extra Plane, \"quant_table_set_index[ (version <= 3 || chroma_planes) ? 2 : 1 ]\" index is used.",
      "ja": "* 余分な平面の場合は、「QUANT_TABLE_SET_INDEX [（バージョン<= 3 || CHROMA_PLANES）？2：1]インデックスが使用されます。"
    },
    {
      "indent": 3,
      "text": "Background: in the first implementations of the FFV1 bitstream, the index for Cb and Cr Planes was stored even if it was not used (\"chroma_planes\" set to 0), this index is kept for \"version <= 3\" in order to keep compatibility with FFV1 bitstreams in the wild.",
      "ja": "背景：FFV1ビットストリームの最初の実装では、使用されていなくてもCBとCRプレーンのインデックスが格納されていました（ \"Chroma_planes\"が0に設定されています）、このインデックスは保持するために \"バージョン<= 3\"に保存されます。野生のFFV1ビットストリームとの互換性。"
    },
    {
      "indent": 0,
      "text": "3.7. Color Spaces",
      "section_title": true,
      "ja": "3.7. カラースペース"
    },
    {
      "indent": 3,
      "text": "FFV1 supports several color spaces. The count of allowed coded Planes and the meaning of the extra Plane are determined by the selected color space.",
      "ja": "FFV1はいくつかの色空間をサポートします。許容された符号化プレーンの数および余分な平面の意味は、選択された色空間によって決定される。"
    },
    {
      "indent": 3,
      "text": "The FFV1 bitstream interleaves data in an order determined by the color space. In YCbCr for each Plane, each Line is coded from top to bottom, and for each Line, each Sample is coded from left to right. In JPEG 2000 RCT for each Line from top to bottom, each Plane is coded, and for each Plane, each Sample is encoded from left to right.",
      "ja": "FFV1ビットストリームは、色空間によって決定された順序でデータをインターリーブする。各平面についてYCBCRでは、各行は上から下へ符号化され、各ラインについては各サンプルが左から右に符号化される。上から下への各行のJPEG 2000 RCTでは、各平面は符号化され、各平面について各サンプルは左から右に符号化されている。"
    },
    {
      "indent": 0,
      "text": "3.7.1. YCbCr",
      "section_title": true,
      "ja": "3.7.1. ycbcr."
    },
    {
      "indent": 3,
      "text": "This color space allows one to four Planes.",
      "ja": "この色空間は1つの平面を可能にします。"
    },
    {
      "indent": 3,
      "text": "The Cb and Cr Planes are optional, but if they are used, then they MUST be used together. Omitting the Cb and Cr Planes codes the frames in gray scale without color data.",
      "ja": "CBとCRプレーンはオプションですが、使用されている場合は、それらを一緒に使用する必要があります。CBおよびCRプレーンを省略すると、カラーデータなしでグレースケールでフレームを符号化する。"
    },
    {
      "indent": 3,
      "text": "An optional transparency Plane can be used to code transparency data.",
      "ja": "透明度データを符号化するために任意の透明面を使用することができる。"
    },
    {
      "indent": 3,
      "text": "An FFV1 Frame using YCbCr MUST use one of the following arrangements:",
      "ja": "YCBCRを使用したFFV1フレームは、次のいずれかの手配を使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Y",
      "ja": "* y"
    },
    {
      "indent": 3,
      "text": "* Y, Transparency",
      "ja": "* 透明度"
    },
    {
      "indent": 3,
      "text": "* Y, Cb, Cr",
      "ja": "* Y、CB、CR"
    },
    {
      "indent": 3,
      "text": "* Y, Cb, Cr, Transparency",
      "ja": "* y、cb、cr、透明度"
    },
    {
      "indent": 3,
      "text": "The Y Plane MUST be coded first. If the Cb and Cr Planes are used, then they MUST be coded after the Y Plane. If a transparency Plane is used, then it MUST be coded last.",
      "ja": "Y平面は最初に符号化されなければならない。CBとCRプレーンが使用されている場合、それらはY平面後にコーディングされなければなりません。透明面が使用されている場合は、最後にコーディングする必要があります。"
    },
    {
      "indent": 0,
      "text": "3.7.2. RGB",
      "section_title": true,
      "ja": "3.7.2. RGB."
    },
    {
      "indent": 3,
      "text": "This color space allows three or four Planes.",
      "ja": "この色空間は3つまたは4つの平面を可能にします。"
    },
    {
      "indent": 3,
      "text": "An optional transparency Plane can be used to code transparency data.",
      "ja": "透明度データを符号化するために任意の透明面を使用することができる。"
    },
    {
      "indent": 3,
      "text": "JPEG 2000 RCT is a Reversible Color Transform that codes RGB (Red, Green, Blue) Planes losslessly in a modified YCbCr color space [ISO.15444-1.2019]. Reversible pixel transformations between YCbCr and RGB use the following formulae:",
      "ja": "JPEG 2000 RCTは、RGB（赤、緑、青）が修正されたYCBCR色空間で損失を取り消す可逆色変換です[ISO.15444-1.2019]。YCBCRとRGBの間の可逆的なピクセル変換次の式を使用します。"
    },
    {
      "indent": 3,
      "text": "Cb = b - g\nCr = r - g\nY = g + (Cb + Cr) >> 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 6: Description of the transformation of pixels from RGB color space to coded, modified YCbCr color space.",
      "ja": "図6：RGB色空間から符号化された、修正されたYCBCR色空間へのピクセルの変換の説明。"
    },
    {
      "indent": 3,
      "text": "g = Y - (Cb + Cr) >> 2\nr = Cr + g\nb = Cb + g",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 7: Description of the transformation of pixels from coded, modified YCbCr color space to RGB color space.",
      "ja": "図7：符号化修正YCbCr色空間からRGB色空間へのピクセルの変換の説明。"
    },
    {
      "indent": 3,
      "text": "Cb and Cr are positively offset by \"1 << bits_per_raw_sample\" after the conversion from RGB to the modified YCbCr, and they are negatively offset by the same value before the conversion from the modified YCbCr to RGB in order to have only nonnegative values after the conversion.",
      "ja": "CBとCRは、RGBから修正YCBCRへの変換後に「1 << BITS_PER_RAW_SAMPLE」とは積極的にオフセットされており、それらは、修正されたYCBCRからRGBへの変換前の同じ値で負に相殺されています。会話。"
    },
    {
      "indent": 3,
      "text": "When FFV1 uses the JPEG 2000 RCT, the horizontal Lines are interleaved to improve caching efficiency since it is most likely that the JPEG 2000 RCT will immediately be converted to RGB during decoding. The interleaved coding order is also Y, then Cb, then Cr, and then, if used, transparency.",
      "ja": "FFV1がJPEG 2000 RCTを使用すると、JPEG 2000 RCTが復号化中にすぐにRGBに変換される可能性が最も高いため、水平線はインターリーブされてキャッシング効率を向上させます。インターリーブ符号化順序もy、次にCB、次にCR、そして使用されている場合は透明度である。"
    },
    {
      "indent": 3,
      "text": "As an example, a Frame that is two pixels wide and two pixels high could comprise the following structure:",
      "ja": "一例として、2つのピクセル幅と2つのピクセルのフレームは、次の構造を構成することができます。"
    },
    {
      "indent": 3,
      "text": "+------------------------+------------------------+\n| Pixel(1,1)             | Pixel(2,1)             |\n| Y(1,1) Cb(1,1) Cr(1,1) | Y(2,1) Cb(2,1) Cr(2,1) |\n+------------------------+------------------------+\n| Pixel(1,2)             | Pixel(2,2)             |\n| Y(1,2) Cb(1,2) Cr(1,2) | Y(2,2) Cb(2,2) Cr(2,2) |\n+------------------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "In JPEG 2000 RCT, the coding order is left to right and then top to bottom, with values interleaved by Lines and stored in this order:",
      "ja": "JPEG 2000 RCTでは、コーディング順序は右に左にあり、次に下から下に、値は行によってインターリーブされ、この順序で保存されます。"
    },
    {
      "indent": 3,
      "text": "Y(1,1) Y(2,1) Cb(1,1) Cb(2,1) Cr(1,1) Cr(2,1) Y(1,2) Y(2,2) Cb(1,2)\nCb(2,2) Cr(1,2) Cr(2,2)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.7.2.1. RGB Exception",
      "section_title": true,
      "ja": "3.7.2.1. RGBの例外"
    },
    {
      "indent": 3,
      "text": "If \"bits_per_raw_sample\" is between 9 and 15 inclusive and \"extra_plane\" is 0, the following formulae for reversible conversions between YCbCr and RGB MUST be used instead of the ones above:",
      "ja": "\"bits_per_raw_sample\"が9から15の間で \"extrant_plane\"の場合は、上記のものの代わりにycbcrとRGB間のリバーシブル変換のための次の式を使用する必要がある場合は、次のようにしてください。"
    },
    {
      "indent": 3,
      "text": "Cb = g - b\nCr = r - b\nY = b + (Cb + Cr) >> 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 8: Description of the transformation of pixels from RGB color space to coded, modified YCbCr color space (in case of exception).",
      "ja": "図8：RGBカラースペースから符号化された修正YCBCR色空間へのピクセルの変換（例外の場合）。"
    },
    {
      "indent": 3,
      "text": "b = Y - (Cb + Cr) >> 2\nr = Cr + b\ng = Cb + b",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 9: Description of the transformation of pixels from coded, modified YCbCr color space to RGB color space (in case of exception).",
      "ja": "図9：符号化修正YCbCr色空間からRGB色空間へのピクセルの変換の説明（例外の場合）。"
    },
    {
      "indent": 3,
      "text": "Background: At the time of this writing, in all known implementations of the FFV1 bitstream, when \"bits_per_raw_sample\" was between 9 and 15 inclusive and \"extra_plane\" was 0, Green Blue Red (GBR) Planes were used as Blue Green Red (BGR) Planes during both encoding and decoding. Meanwhile, 16-bit JPEG 2000 RCT was implemented without this issue in one implementation and validated by one conformance checker. Methods to address this exception for the transform are under consideration for the next version of the FFV1 bitstream.",
      "ja": "背景：この書き込み時に、FFV1ビットストリームのすべての既知の実装では、「BITS_PER_RAW_SAMPLE」が9~15の間で、「Extrant_plane」が0の場合、緑色の赤（GBR）平面が青緑色の赤（BGR）として使用されていました。符号化と復号化の両方の間にプレーン。一方、16ビットJPEG 2000 RCTはこの問題なく1つの実装で実装され、1つの適合性チェッカーによって検証されました。変換のこの例外に対処するための方法は、FFV1ビットストリームの次のバージョンについて考慮しています。"
    },
    {
      "indent": 0,
      "text": "3.8. Coding of the Sample Difference",
      "section_title": true,
      "ja": "3.8. サンプル差の符号化"
    },
    {
      "indent": 3,
      "text": "Instead of coding the n+1 bits of the Sample Difference with Huffman or Range coding (or n+2 bits, in the case of JPEG 2000 RCT), only the n (or n+1, in the case of JPEG 2000 RCT) least significant bits are used, since this is sufficient to recover the original Sample. In Figure 10, the term \"bits\" represents \"bits_per_raw_sample + 1\" for JPEG 2000 RCT or \"bits_per_raw_sample\" otherwise:",
      "ja": "ハフマンまたは範囲符号化（JPEG2000 RCTの場合はN 2ビット）とのサンプル差のN 1ビット（またはN 2ビット）を符号化する代わりに、N（またはN 1、JPEG 2000 RCTの場合）最下位ビットこれは元のサンプルを回復するのに十分であるので使用されます。図10では、「ビット」という用語は、JPEG 2000 RCTまたは「BITS_PER_RAW_SAMPLE」についての「BITS_PER_RAW_SAMPLE 1」を表します。"
    },
    {
      "indent": 3,
      "text": "coder_input = ((sample_difference + 2 ^ (bits - 1)) &\n              (2 ^ bits - 1)) - 2 ^ (bits - 1)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 10: Description of the coding of the Sample Difference in the bitstream.",
      "ja": "図10：ビットストリームのサンプル差の符号化の説明。"
    },
    {
      "indent": 0,
      "text": "3.8.1. Range Coding Mode",
      "section_title": true,
      "ja": "3.8.1. 範囲符号化モード"
    },
    {
      "indent": 3,
      "text": "Early experimental versions of FFV1 used the Context-Adaptive Binary Arithmetic Coding (CABAC) coder from H.264 as defined in [ISO.14496-10.2020], but due to the uncertain patent/royalty situation, as well as its slightly worse performance, CABAC was replaced by a range coder based on an algorithm defined by G. Nigel N. Martin in 1979 [Range-Encoding].",
      "ja": "FFV1の初期の実験的バージョンは、[ISO.14496-10.2020]で定義されているが、不確実な特許/ロイヤリティの状況、そしてそのわずかに悪いパフォーマンスのために、CANTECT対応バイナリ算術符号化（CABAC）コーディャー（CABAC）コーディング（CABAC）コーディャーを使用した。CABACは、1979年のG. Nigel N. Martinによって定義されたアルゴリズムに基づいて距離コーダに置き換えられた[Range-Encoding]。"
    },
    {
      "indent": 0,
      "text": "3.8.1.1. Range Binary Values",
      "section_title": true,
      "ja": "3.8.1.1. 範囲のバイナリ値"
    },
    {
      "indent": 3,
      "text": "To encode binary digits efficiently, a range coder is used. A range coder encodes a series of binary symbols by using a probability estimation within each context. The sizes of each of the two subranges are proportional to their estimated probability. The Quantization Table is used to choose the context used from the surrounding image sample values for the case of coding the Sample Differences. The coding of integers is done by coding multiple binary values. The range decoder will read bytes until it can determine into which subrange the input falls to return the next binary symbol.",
      "ja": "2進数桁を効率的にエンコードするために、範囲コーダが使用されます。範囲コーダは、各コンテキスト内の確率推定を使用することによって一連の2進記号を符号化する。2つのサブレンジのそれぞれのサイズは、それらの推定確率に比例します。量子化テーブルは、サンプルの違いをコーディングする場合について、周囲の画像サンプル値から使用されるコンテキストを選択するために使用されます。整数の符号化は、複数のバイナリ値を符号化することによって行われる。範囲デコーダは、入力が次の2値記号を返すために入力が落ちるサブレンジに決定されるまでバイトを読み取ります。"
    },
    {
      "indent": 3,
      "text": "To describe Range coding for FFV1, the following values are used:",
      "ja": "FFV1の範囲符号化を説明するために、以下の値が使用されます。"
    },
    {
      "indent": 3,
      "text": "C_i the i-th context.",
      "ja": "c_i i番目の文脈"
    },
    {
      "indent": 3,
      "text": "B_i the i-th byte of the bytestream.",
      "ja": "b_i byteStreamのi番目のバイト。"
    },
    {
      "indent": 3,
      "text": "R_i the Range at the i-th symbol.",
      "ja": "r_i i番目のシンボルの範囲。"
    },
    {
      "indent": 3,
      "text": "r_i the boundary between two subranges of R_i: a subrange of r_i values and a subrange R_i - r_i values.",
      "ja": "R_I R_Iの2つのサブレンジ間の境界：R_I値のサブレンジとサブレンジR_I  -  R_I値。"
    },
    {
      "indent": 3,
      "text": "L_i the Low value of the Range at the i-th symbol.",
      "ja": "l_i i番目のシンボルの範囲の低い値。"
    },
    {
      "indent": 3,
      "text": "l_i a temporary variable to carry over or adjust the Low value of the Range between range coding operations.",
      "ja": "l_i範囲符号化操作間の範囲の低い値を搬送するかまたは調整するための一時変数。"
    },
    {
      "indent": 3,
      "text": "t_i a temporary variable to transmit subranges between range coding operations.",
      "ja": "T_I範囲符号化操作間のサブレンジを送信するための一時変数。"
    },
    {
      "indent": 3,
      "text": "b_i the i-th range-coded binary value.",
      "ja": "b_i範囲符号化バイナリ値。"
    },
    {
      "indent": 3,
      "text": "S_(0, i) the i-th initial state.",
      "ja": "S_（0、i）i番目の初期状態。"
    },
    {
      "indent": 3,
      "text": "j_n the length of the bytestream encoding n binary symbols.",
      "ja": "j_nバイナリシンボルを符号化するbyteStreamの長さ。"
    },
    {
      "indent": 3,
      "text": "The following range coder state variables are initialized to the following values. The Range is initialized to a value of 65,280 (expressed in base 16 as 0xFF00) as depicted in Figure 11. The Low is initialized according to the value of the first two bytes as depicted in Figure 12. j_i tracks the length of the bytestream encoding while incrementing from an initial value of j_0 to a final value of j_n. j_0 is initialized to 2 as depicted in Figure 13.",
      "ja": "以下の範囲のコーダ状態変数が次の値に初期化されます。図11に示すように、範囲は65,280の値（0xFF00として表される）に初期化されます。図12に示すように、最初の2バイトの値に従って初期化されます.J_Iはバイトストリームエンコーディングの長さを追跡j_0の初期値からj_nの最終値までインクリメントしながら。図13に示すように、J_0が2に初期化されます。"
    },
    {
      "indent": 3,
      "text": "R_0 = 65280",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 11: The initial value for the Range.",
      "ja": "図11：範囲の初期値。"
    },
    {
      "indent": 3,
      "text": "L_0 = 2 ^ 8 * B_0 + B_1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 12: The initial value for Low is set according to the first two bytes of the bytestream.",
      "ja": "図12：LOWの初期値は、BYTESTREAMの最初の2バイトに従って設定されます。"
    },
    {
      "indent": 3,
      "text": "j_0 = 2",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Figure 13: The initial value for \"j\", the length of the bytestream encoding.",
      "ja": "図13：「j」の初期値、バイトストリームエンコーディングの長さ。"
    },
    {
      "indent": 3,
      "text": "The following equations define how the range coder variables evolve as it reads or writes symbols.",
      "ja": "次の式は、シンボルを読み書きするときに範囲コーダの変数がどのように進化するかを定義します。"
    },
    {
      "indent": 3,
      "text": "r_i = floor( ( R_i * S_(i, C_i) ) / 2 ^ 8 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 14: This formula shows the positioning of range split based on the state.",
      "ja": "図14：この式は、状態に基づく範囲分割の位置決めを示しています。"
    },
    {
      "indent": 6,
      "text": "        b_i =  0                        <==>\n        L_i <  R_i - r_i                ==>\nS_(i+1,C_i) =  zero_state_(S_(i, C_i))  AND\n        l_i =  L_i                      AND\n        t_i =  R_i - r_i",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "        b_i =  1                        <==>\n        L_i >= R_i - r_i                ==>\nS_(i+1,C_i) =  one_state_(S_(i, C_i))   AND\n        l_i =  L_i - R_i + r_i          AND\n        t_i =  r_i",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 6,
      "text": "Figure 15: This formula shows the linking of the decoded symbol (represented as b_i), the updated state (represented as S_(i+1,C_i)), and the updated range (represented as a range from l_i to t_i).",
      "ja": "図15：この式は、復号化されたシンボル（b_iとして表される）、更新された状態（s_（i 1、c_i）として表されます）、および更新された範囲（L_iからT_iの範囲として表されます）のリンクを示しています。"
    },
    {
      "indent": 3,
      "text": "C_i != k ==> S_(i + 1, k) = S_(i, k)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": " Figure 16: If the value of \"k\" is unequal to the i-th value of context, in other words, if the state is unchanged from the last symbol coding, then the value of the state is carried over to the next symbol coding.",
      "ja": "図16：「k」の値がコンテキストのi番目の値とは異なる場合、言い換えれば、状態が最後のシンボル符号化から変化しない場合、状態の値は次のシンボル符号化に伝送される。。"
    },
    {
      "indent": 3,
      "text": "t_i       <  2 ^ 8                         ==>\nR_(i + 1) =  2 ^ 8 * t_i                   AND\nL_(i + 1) =  2 ^ 8 * l_i + B_(j_i)         AND\nj_(i + 1) =  j_i + 1",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "t_i       >= 2 ^ 8                         ==>\nR_(i + 1) =  t_i                           AND\nL_(i + 1) =  l_i                           AND\nj_(i + 1) =  j_i",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 17: This formula shows the linking of the range coder with the reading or writing of the bytestream.",
      "ja": "図17：この式は、範囲コーダのリンクを示しており、バイトストリームの読み書きを示しています。"
    },
    {
      "indent": 7,
      "text": "range = 0xFF00;\nend   = 0;\nlow   = get_bits(16);\nif (low >= range) {\n    low = range;\n    end = 1;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 18: A pseudocode description of the initialization of range coder variables in Range binary mode.",
      "ja": "図18：範囲バイナリモードにおける範囲コーダ変数の初期化の擬似コード記述。"
    },
    {
      "indent": 3,
      "text": "refill() {\n    if (range < 256) {\n        range = range * 256;\n        low   = low * 256;\n        if (!end) {\n            c.low += get_bits(8);\n            if (remaining_bits_in_bitstream( NumBytes ) == 0) {\n                end = 1;\n            }\n        }\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 19: A pseudocode description of refilling the binary value buffer of the range coder.",
      "ja": "図19：範囲コーダのバイナリ値バッファを補充するという擬似コード記述。"
    },
    {
      "indent": 3,
      "text": "get_rac(state) {\n    rangeoff  = (range * state) / 256;\n    range    -= rangeoff;\n    if (low < range) {\n        state = zero_state[state];\n        refill();\n        return 0;\n    } else {\n        low   -= range;\n        state  = one_state[state];\n        range  = rangeoff;\n        refill();\n        return 1;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "Figure 20: A pseudocode description of the read of a binary value in Range binary mode.",
      "ja": "図20：範囲バイナリモードにおける2進値の読み取りの疑似コード記述。"
    },
    {
      "indent": 0,
      "text": "3.8.1.1.1. Termination",
      "section_title": true,
      "ja": "3.8.1.1.1. 終了"
    },
    {
      "indent": 3,
      "text": "The range coder can be used in three modes:",
      "ja": "範囲コーダは3つのモードで使用できます。"
    },
    {
      "indent": 3,
      "text": "* In Open mode when decoding, every symbol the reader attempts to read is available. In this mode, arbitrary data can have been appended without affecting the range coder output. This mode is not used in FFV1.",
      "ja": "* デコード時にオープンモードでは、読者が読み込もうとするすべてのシンボルが利用可能です。このモードでは、範囲コーダ出力に影響を与えることなく任意のデータが追加されています。このモードはFFv1では使用されません。"
    },
    {
      "indent": 3,
      "text": "* In Closed mode, the length in bytes of the bytestream is provided to the range decoder. Bytes beyond the length are read as 0 by the range decoder. This is generally one byte shorter than the Open mode.",
      "ja": "* 閉モードでは、バイトストリームのバイト数が範囲デコーダに提供される。長さを超えるバイトは範囲デコーダによって0として読み込まれます。これは一般にオープンモードより1バイト短いです。"
    },
    {
      "indent": 3,
      "text": "* In Sentinel mode, the exact length in bytes is not known, and thus the range decoder MAY read into the data that follows the range-coded bytestream by one byte. In Sentinel mode, the end of the range-coded bytestream is a binary symbol with state 129, which value SHALL be discarded. After reading this symbol, the range decoder will have read one byte beyond the end of the range-coded bytestream. This way the byte position of the end can be determined. Bytestreams written in Sentinel mode can be read in Closed mode if the length can be determined. In this case, the last (sentinel) symbol will be read uncorrupted and be of value 0.",
      "ja": "* センチネルモードでは、正確な長さが正確な長さが知られていないため、範囲デコーダは1バイトで範囲で符号化された範囲に続くデータに読み込まれます。センチネルモードでは、範囲符号化された範囲の終わりは状態129を有する2値記号であり、その値は廃棄される。このシンボルを読み取った後、範囲デコーダは範囲コード化された範囲の終わりを超えて1バイトを読み取っています。このようにして、端部のバイト位置を決定することができる。長さを決定できる場合は、Sentinelモードで書かれたバイトストリームをクローズモードで読み取ることができます。この場合、最後の（Sentinel）シンボルは不正外に読み取られ、値0になります。"
    },
    {
      "indent": 3,
      "text": "The above describes the range decoding. Encoding is defined as any process that produces a decodable bytestream.",
      "ja": "上記は範囲復号化について説明する。符号化は、復号可能なByTeStreamを生成する任意のプロセスとして定義されます。"
    },
    {
      "indent": 3,
      "text": "There are three places where range coder termination is needed in FFV1. The first is in the \"Configuration Record\", which in this case the size of the range-coded bytestream is known and handled as Closed mode. The second is the switch from the \"Slice Header\", which is range coded to Golomb-coded Slices as Sentinel mode. The third is the end of range-coded Slices, which need to terminate before the CRC at their end. This can be handled as Sentinel mode or as Closed mode if the CRC position has been determined.",
      "ja": "FFV1に範囲コーダ終了が必要な3つの場所があります。1つ目は「構成レコード」にあります。この場合、この場合、範囲コード化された範囲のサイズは既知であり、閉モードとして扱われます。2つ目は、 \"スライスヘッダー\"からのスイッチです。これは、Sentinelモードとしてゴローム符号化スライスに符号化された範囲です。3つ目は、範囲コード化スライスの終わりです。これは、CRCの前に終了する必要があります。これは、CRC位置が決定されている場合は、センチネルモードまたはクローズモードとして処理できます。"
    },
    {
      "indent": 0,
      "text": "3.8.1.2. Range Nonbinary Values",
      "section_title": true,
      "ja": "3.8.1.2. 範囲の非バイナリ値"
    },
    {
      "indent": 3,
      "text": "To encode scalar integers, it would be possible to encode each bit separately and use the past bits as context. However, that would mean 255 contexts per 8-bit symbol, which is not only a waste of memory but also requires more past data to reach a reasonably good estimate of the probabilities. Alternatively, it would also be possible to assume a Laplacian distribution and only deal with its variance and mean (as in Huffman coding). However, for maximum flexibility and simplicity, the chosen method uses a single symbol to encode if a number is 0, and if the number is nonzero, it encodes the number using its exponent, mantissa, and sign. The exact contexts used are best described by Figure 21.",
      "ja": "スカラー整数をエンコードするためには、各ビットを別々にエンコードし、コンテキストとして過去のビットを使用することが可能になります。ただし、8ビットシンボルあたり255のコンテキストを意味します。これは、メモリの無駄だけでなく、確率の合理的に良好な推定値に達するためにもっと過去のデータも必要とします。あるいは、ラプラシアン分布を想定し、その分散と平均を扱うことも可能であろう（ハフマン符号化のように）。ただし、最大限の柔軟性と単純さのために、選択されたメソッドは、数値が0の場合に符号化するために単一のシンボルを使用し、その数がゼロ以外の場合、その指数、仮数、および符号を使用して番号を符号化します。使用される正確なコンテキストは、図21で最もよく説明されています。"
    },
    {
      "indent": 3,
      "text": "int get_symbol(RangeCoder *c, uint8_t *state, int is_signed) {\n    if (get_rac(c, state + 0) {\n        return 0;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int e = 0;\nwhile (get_rac(c, state + 1 + min(e, 9)) { //1..10\n    e++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "int a = 1;\nfor (int i = e - 1; i >= 0; i--) {\n    a = a * 2 + get_rac(c, state + 22 + min(i, 9));  // 22..31\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (!is_signed) {\n    return a;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    if (get_rac(c, state + 11 + min(e, 10))) { //11..21\n        return -a;\n    } else {\n        return a;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 21: A pseudocode description of the contexts of Range nonbinary values.",
      "ja": "図21：範囲非バイナリ値のコンテキストの擬似コード記述。"
    },
    {
      "indent": 3,
      "text": "\"get_symbol\" is used for the read out of \"sample_difference\" indicated in Figure 10.",
      "ja": "図10に示す「sample_difference」の読み出しには「GET_SYMBOL」が使用されます。"
    },
    {
      "indent": 3,
      "text": "\"get_rac\" returns a boolean computed from the bytestream as described by the formula found in Figure 14 and by the pseudocode found in Figure 20.",
      "ja": "\"get_rac\"は、図14にある式と図20に見つかった疑似コードによって説明されているように、Bytestreamから計算されたブール値を返します。"
    },
    {
      "indent": 0,
      "text": "3.8.1.3. Initial Values for the Context Model",
      "section_title": true,
      "ja": "3.8.1.3. コンテキストモデルの初期値"
    },
    {
      "indent": 3,
      "text": "When the \"keyframe\" value (see Section 4.4) is 1, all range coder state variables are set to their initial state.",
      "ja": "「キーフレーム」の値（セクション4.4を参照）が1の場合、すべての範囲コーダ状態変数が初期状態に設定されます。"
    },
    {
      "indent": 0,
      "text": "3.8.1.4. State Transition Table",
      "section_title": true,
      "ja": "3.8.1.4. 状態遷移表"
    },
    {
      "indent": 3,
      "text": "In Range Coding Mode, a state transition table is used, indicating to which state the decoder will move based on the current state and the value extracted from Figure 20.",
      "ja": "範囲符号化モードでは、現在の状態に基づいてデコーダが移動する状態と図20から抽出された値とを示す状態遷移テーブルが使用される。"
    },
    {
      "indent": 3,
      "text": "one_state_i = default_state_transition_i + state_transition_delta_i",
      "ja": "one_state_i = default_state_transition_i state_transition_delta_i"
    },
    {
      "indent": 8,
      "text": "Figure 22: Description of the coding of the state transition table for a \"get_rac\" readout value of 1.",
      "ja": "図22：「GET_RAC」読み出し値1の状態遷移表の符号化の説明。"
    },
    {
      "indent": 3,
      "text": "zero_state_i = 256 - one_state_(256-i)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 23: Description of the coding of the state transition table for a \"get_rac\" readout value of 0.",
      "ja": "\"GET_RAC\"読み出し値0の状態遷移表の符号化の説明。"
    },
    {
      "indent": 0,
      "text": "3.8.1.5. default_state_transition",
      "section_title": true,
      "ja": "3.8.1.5. default_state_transition"
    },
    {
      "indent": 3,
      "text": "By default, the following state transition table is used:",
      "ja": "デフォルトでは、次の状態遷移表が使用されます。"
    },
    {
      "indent": 5,
      "text": "0, 0, 0, 0, 0, 0, 0, 0, 20, 21, 22, 23, 24, 25, 26, 27,",
      "ja": "0,0,0,0,0,0,0,0,20,21,22,23,25,26,27、"
    },
    {
      "indent": 4,
      "text": "28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42,",
      "ja": "28,29,30,31,32,33,34,35,36,37,37,37,34,42、40,41,42、"
    },
    {
      "indent": 4,
      "text": "43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 56, 57,",
      "ja": "43,44,45,46,47,48,49,50,51,52,53,54,55,56,56,57、"
    },
    {
      "indent": 4,
      "text": "58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,",
      "ja": "58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73、"
    },
    {
      "indent": 4,
      "text": "74, 75, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88,",
      "ja": "74,75,75,76,77,78,79,80,81,82,83,84,85,86,87,88、"
    },
    {
      "indent": 4,
      "text": "89, 90, 91, 92, 93, 94, 94, 95, 96, 97, 98, 99,100,101,102,103,",
      "ja": "89,90,91,92,93,94,94,95,96,97,98,99,100,101,102,103"
    },
    {
      "indent": 3,
      "text": "104,105,106,107,108,109,110,111,112,113,114,114,115,116,117,118,",
      "ja": "【0072】"
    },
    {
      "indent": 3,
      "text": "119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,133,",
      "ja": "119,20,120,13,125,129,129,129,129,129,129,129,129,129,129,129,129,129,129,129,127,129,129,129,129,127,131,129,130,131,129,132,133,133"
    },
    {
      "indent": 3,
      "text": "134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,",
      "ja": "134,135,136,144,142,144,147,146,144,147,147,147,146,147,146,147,147,147,142,146,144,147,146,147,146,149"
    },
    {
      "indent": 3,
      "text": "150,151,152,152,153,154,155,156,157,158,159,160,161,162,163,164,",
      "ja": "【請求項15】【請求項51」目）150,197,197,199,199,199,199,199"
    },
    {
      "indent": 3,
      "text": "165,166,167,168,169,170,171,171,172,173,174,175,176,177,178,179,",
      "ja": "【特徴】"
    },
    {
      "indent": 3,
      "text": "180,181,182,183,184,185,186,187,188,189,190,190,191,192,194,194,",
      "ja": "【】【00028】"
    },
    {
      "indent": 3,
      "text": "195,196,197,198,199,200,201,202,202,204,205,206,207,208,209,209,",
      "ja": "【0002】【】【0009】"
    },
    {
      "indent": 3,
      "text": "210,211,212,213,215,215,216,217,218,219,220,220,222,223,224,225,",
      "ja": "【】【0002】【0002】"
    },
    {
      "indent": 3,
      "text": "226,227,227,229,229,230,231,232,234,234,235,236,237,238,239,240,",
      "ja": "【228,237,238,237,237,238,236,237,238,237,237,238,236,237,236,236,237,238,236,237,230,238,233ページ"
    },
    {
      "indent": 3,
      "text": "241,242,243,244,245,246,247,248,248, 0, 0, 0, 0, 0, 0, 0,",
      "ja": "0,0,0,0,0,0,0,0,0,0"
    },
    {
      "indent": 8,
      "text": "Figure 24: Default state transition table for Range coding.",
      "ja": "図24：範囲符号化のデフォルト状態遷移表"
    },
    {
      "indent": 0,
      "text": "3.8.1.6. Alternative State Transition Table",
      "section_title": true,
      "ja": "3.8.1.6. 代替状態遷移表"
    },
    {
      "indent": 3,
      "text": "The alternative state transition table has been built using iterative minimization of frame sizes and generally performs better than the default. To use it, the \"coder_type\" (see Section 4.2.3) MUST be set to 2, and the difference to the default MUST be stored in the \"Parameters\", see Section 4.2. At the time of this writing, the reference implementation of FFV1 in FFmpeg uses Figure 25 by default when Range coding is used.",
      "ja": "代替状態遷移表は、フレームサイズの反復最小化を使用して構築されており、一般にデフォルトよりも優れている。それを使用するには、 \"coder_type\"（セクション4.2.3を参照）を2に設定する必要があり、デフォルトとの差は「パラメータ」に保存する必要があります。セクション4.2を参照してください。この書き込み時に、FFMPEGにおけるFFV1の基準実装は、範囲符号化が使用されている場合には、デフォルトで図25を使用します。"
    },
    {
      "indent": 5,
      "text": "0, 10, 10, 10, 10, 16, 16, 16, 28, 16, 16, 29, 42, 49, 20, 49,",
      "ja": "0,10,10,10,10,16,16,16,28,16,16,29,42,49,20,49、"
    },
    {
      "indent": 4,
      "text": "59, 25, 26, 26, 27, 31, 33, 33, 33, 34, 34, 37, 67, 38, 39, 39,",
      "ja": "59,25,26,26,27,31,33,33,33,34,34,34,37,67,38,39,39、"
    },
    {
      "indent": 4,
      "text": "40, 40, 41, 79, 43, 44, 45, 45, 48, 48, 64, 50, 51, 52, 88, 52,",
      "ja": "40,40,41,79,43,44,45,45,48,48,64,50,51,52,88,52、"
    },
    {
      "indent": 4,
      "text": "53, 74, 55, 57, 58, 58, 74, 60,101, 61, 62, 84, 66, 66, 68, 69,",
      "ja": "53,74,55,57,58,58,74,60,101,61,62,84,66,66,68,69、"
    },
    {
      "indent": 4,
      "text": "87, 82, 71, 97, 73, 73, 82, 75,111, 77, 94, 78, 87, 81, 83, 97,",
      "ja": "87,82,71,97,73,73,82,75,111,77,94,78,87,81,83,97、"
    },
    {
      "indent": 4,
      "text": "85, 83, 94, 86, 99, 89, 90, 99,111, 92, 93,134, 95, 98,105, 98,",
      "ja": "85,83,94,86,99,89,90,99,111,92,93,134,95,98,105,98、"
    },
    {
      "indent": 3,
      "text": "105,110,102,108,102,118,103,106,106,113,109,112,114,112,116,125,",
      "ja": "【0002】,10,92,102,94,108,102,92,117,103,109,116,113,109,109,116,113,109,102,116,103,109,110"
    },
    {
      "indent": 3,
      "text": "115,116,117,117,126,119,125,121,121,123,145,124,126,131,127,129,",
      "ja": "【特徴】"
    },
    {
      "indent": 3,
      "text": "165,130,132,138,133,135,145,136,137,139,146,141,143,142,144,148,",
      "ja": "【】"
    },
    {
      "indent": 3,
      "text": "147,155,151,149,151,150,152,157,153,154,156,168,158,162,161,160,",
      "ja": "【0002】,199,199,197,19,149,197,197,19,14,162,161,160、"
    },
    {
      "indent": 3,
      "text": "172,163,169,164,166,184,167,170,177,174,171,173,182,176,180,178,",
      "ja": "【】"
    },
    {
      "indent": 3,
      "text": "175,189,179,181,186,183,192,185,200,187,191,188,190,197,193,196,",
      "ja": "【】【0002】"
    },
    {
      "indent": 3,
      "text": "197,194,195,196,198,202,199,201,210,203,207,204,205,206,208,214,",
      "ja": "【】【00028】"
    },
    {
      "indent": 3,
      "text": "209,211,221,212,213,215,224,216,217,218,219,220,222,228,223,225,",
      "ja": "【202】"
    },
    {
      "indent": 3,
      "text": "226,224,227,229,240,230,231,232,233,234,235,236,238,239,237,242,",
      "ja": "【22222,240,242,243,237,242,239,233,233,233,239,236,234,233,236,236,238,238,233,236,238,236,236,238,238,233,236,233ページ"
    },
    {
      "indent": 3,
      "text": "241,243,242,244,245,246,247,248,249,250,251,252,252,253,254,255,",
      "ja": "【220】【22,250,248,248,250,240,248,248,250,240,248,253,250,250,253,248,250,248,248,254ページ"
    },
    {
      "indent": 6,
      "text": "Figure 25: Alternative state transition table for Range coding.",
      "ja": "範囲符号化用の代替状態遷移表"
    },
    {
      "indent": 0,
      "text": "3.8.2. Golomb Rice Mode",
      "section_title": true,
      "ja": "3.8.2. ゴロームライスモード"
    },
    {
      "indent": 3,
      "text": "The end of the bitstream of the Frame is padded with zeroes until the bitstream contains a multiple of eight bits.",
      "ja": "ビットストリームが8ビットの倍数を含むまで、フレームのビットストリームの終わりにはゼロが埋め込まれています。"
    },
    {
      "indent": 0,
      "text": "3.8.2.1. Signed Golomb Rice Codes",
      "section_title": true,
      "ja": "3.8.2.1. 署名されたゴローム米コード"
    },
    {
      "indent": 3,
      "text": "This coding mode uses Golomb Rice codes. The VLC is split into two parts: the prefix and suffix. The prefix stores the most significant bits or indicates if the symbol is too large to be stored (this is known as the ESC case, see Section 3.8.2.1.1). The suffix either stores the k least significant bits or stores the whole number in the ESC case.",
      "ja": "この符号化モードはゴローム米コードを使用しています。VLCは2つの部分に分割されます。プレフィックスとサフィックス。接頭辞は最も重要なビットを保存するか、記憶が大きすぎるかどうかを示します（これはESCケースとして知られています。セクション3.8.2.1.1を参照）。接尾辞は、K個の最下位ビットを記憶するか、または整数をESCケースに格納する。"
    },
    {
      "indent": 3,
      "text": "int get_ur_golomb(k) {\n    for (prefix = 0; prefix < 12; prefix++) {\n        if (get_bits(1)) {\n            return get_bits(k) + (prefix << k);\n        }\n    }\n    return get_bits(bits) + 11;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 26: A pseudocode description of the read of an unsigned integer in Golomb Rice mode.",
      "ja": "図26：ゴロームライスモードにおける符号なし整数の読み取りの擬似コード記述"
    },
    {
      "indent": 3,
      "text": "int get_sr_golomb(k) {\n    v = get_ur_golomb(k);\n    if (v & 1) return - (v >> 1) - 1;\n    else       return   (v >> 1);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 27: A pseudocode description of the read of a signed integer in Golomb Rice mode.",
      "ja": "図27：ゴロームライスモードにおける符号付き整数の読み取りの擬似コード記述。"
    },
    {
      "indent": 0,
      "text": "3.8.2.1.1. Prefix",
      "section_title": true,
      "ja": "3.8.2.1.1. プレフィックス"
    },
    {
      "indent": 24,
      "text": "+================+=======+\n| bits           | value |\n+================+=======+\n| 1              | 0     |\n+----------------+-------+\n| 01             | 1     |\n+----------------+-------+\n| ...            | ...   |\n+----------------+-------+\n| 0000 0000 01   | 9     |\n+----------------+-------+\n| 0000 0000 001  | 10    |\n+----------------+-------+\n| 0000 0000 0001 | 11    |\n+----------------+-------+\n| 0000 0000 0000 | ESC   |\n+----------------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 27,
      "text": "Table 1: Description of the coding of the prefix of signed Golomb Rice codes.",
      "ja": "表1：署名されたゴローム米の符号の接頭辞のコーディングの説明。"
    },
    {
      "indent": 3,
      "text": "ESC is an ESCape symbol to indicate that the symbol to be stored is too large for normal storage and that an alternate storage method is used.",
      "ja": "ESCは、保存されるシンボルが通常の保存に大きすぎ、代替の記憶方法が使用されていることを示すためのエスケープシンボルです。"
    },
    {
      "indent": 0,
      "text": "3.8.2.1.2. Suffix",
      "section_title": true,
      "ja": "3.8.2.1.2. サフィックス"
    },
    {
      "indent": 11,
      "text": "+---------+----------------------------------------+\n| non-ESC | the k least significant bits MSB first |\n+---------+----------------------------------------+\n| ESC     | the value - 11, in MSB first order     |\n+---------+----------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 2: Description of the coding of the suffix of signed Golomb Rice codes.",
      "ja": "表2：署名されたゴローム米の符号の接尾辞のコーディングの説明。"
    },
    {
      "indent": 3,
      "text": "ESC MUST NOT be used if the value can be coded as non-ESC.",
      "ja": "値が非ESCとしてコーディングできる場合は、ESCを使用しないでください。"
    },
    {
      "indent": 0,
      "text": "3.8.2.1.3. Examples",
      "section_title": true,
      "ja": "3.8.2.1.3. 例"
    },
    {
      "indent": 3,
      "text": "Table 3 shows practical examples of how signed Golomb Rice codes are decoded based on the series of bits extracted from the bitstream as described by the method above:",
      "ja": "上記の方法で説明したように、ビットストリームから抽出された一連のビットに基づいて、署名されたゴローム米コードがどのように復号されるかの実例の実例を示す。"
    },
    {
      "indent": 18,
      "text": "+=====+=======================+=======+\n|  k  | bits                  | value |\n+=====+=======================+=======+\n|  0  | 1                     |     0 |\n+-----+-----------------------+-------+\n|  0  | 001                   |     2 |\n+-----+-----------------------+-------+\n|  2  | 1 00                  |     0 |\n+-----+-----------------------+-------+\n|  2  | 1 10                  |     2 |\n+-----+-----------------------+-------+\n|  2  | 01 01                 |     5 |\n+-----+-----------------------+-------+\n| any | 000000000000 10000000 |   139 |\n+-----+-----------------------+-------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 3: Examples of decoded, signed Golomb Rice codes.",
      "ja": "表3：復号化されたゴロン米の命令の例。"
    },
    {
      "indent": 0,
      "text": "3.8.2.2. Run Mode",
      "section_title": true,
      "ja": "3.8.2.2. 実行モード"
    },
    {
      "indent": 3,
      "text": "Run mode is entered when the context is 0 and left as soon as a nonzero difference is found. The Sample Difference is identical to the predicted one. The run and the first different Sample Difference are coded as defined in Section 3.8.2.4.1.",
      "ja": "実行モードは、ゼロ以外の差が見つかったらすぐにコンテキストが0のときに入力されます。サンプル差は予測されたものと同じです。実行と最初の異なるサンプル差は、3.8.2.4.1項で定義されているように符号化されています。"
    },
    {
      "indent": 0,
      "text": "3.8.2.2.1. Run Length Coding",
      "section_title": true,
      "ja": "3.8.2.2.1. ランレングスコーディング"
    },
    {
      "indent": 3,
      "text": "The run value is encoded in two parts. The prefix part stores the more significant part of the run as well as adjusting the \"run_index\" that determines the number of bits in the less significant part of the run. The second part of the value stores the less significant part of the run as it is. The \"run_index\" is reset to zero for each Plane and Slice.",
      "ja": "実行値は2つの部分でエンコードされます。プレフィックス部分は、実行のより重要な部分を記憶していても、ランの有意な部分ではかなりの部分のビット数を決定する「RUN_INDEX」を調整するだけでなく、「RUN_INDEX」を調整します。値の2番目の部分には、実行の有意な部分がそのままになります。「run_index」は、各平面とスライスについてゼロにリセットされます。"
    },
    {
      "indent": 3,
      "text": "log2_run[41] = {\n 0, 0, 0, 0, 1, 1, 1, 1,\n 2, 2, 2, 2, 3, 3, 3, 3,\n 4, 4, 5, 5, 6, 6, 7, 7,\n 8, 9,10,11,12,13,14,15,\n16,17,18,19,20,21,22,23,\n24,\n};",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "if (run_count == 0 && run_mode == 1) {\n    if (get_bits(1)) {\n        run_count = 1 << log2_run[run_index];\n        if (x + run_count <= w) {\n            run_index++;\n        }\n    } else {\n        if (log2_run[run_index]) {\n            run_count = get_bits(log2_run[run_index]);\n        } else {\n            run_count = 0;\n        }\n        if (run_index) {\n            run_index--;\n        }\n        run_mode = 2;\n    }\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The \"log2_run\" array is also used within [ISO.14495-1.1999].",
      "ja": "「LOG2_RUN」アレイは[ISO.14495-1.1999]内でも使用されます。"
    },
    {
      "indent": 0,
      "text": "3.8.2.3. Sign Extension",
      "section_title": true,
      "ja": "3.8.2.3. 拡張子記号"
    },
    {
      "indent": 3,
      "text": "\"sign_extend\" is the function of increasing the number of bits of an input binary number in two's complement signed number representation while preserving the input number's sign (positive/negative) and value, in order to fit in the output bit width. It MAY be computed with the following:",
      "ja": "\"sign_extend\"は、出力ビット幅にフィットするために、入力番号の符号（正/負）と値を保持しながら、2の補数符号付き数表現で入力2進数のビット数を増やす機能です。それは次のように計算されるかもしれません："
    },
    {
      "indent": 3,
      "text": "sign_extend(input_number, input_bits) {\n    negative_bias = 1 << (input_bits - 1);\n    bits_mask = negative_bias - 1;\n    output_number = input_number & bits_mask; // Remove negative bit\n    is_negative = input_number & negative_bias; // Test negative bit\n    if (is_negative)\n        output_number -= negative_bias;\n    return output_number\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.8.2.4. Scalar Mode",
      "section_title": true,
      "ja": "3.8.2.4. スカラーモード"
    },
    {
      "indent": 3,
      "text": "Each difference is coded with the per context mean prediction removed and a per context value for \"k\".",
      "ja": "各差は、コンテキストごとの平均予測が削除され、「K」の間のコンテキスト値で符号化される。"
    },
    {
      "indent": 3,
      "text": "get_vlc_symbol(state) {\n    i = state->count;\n    k = 0;\n    while (i < state->error_sum) {\n        k++;\n        i += i;\n    }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "v = get_sr_golomb(k);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (2 * state->drift < -state->count) {\n    v = -1 - v;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "ret = sign_extend(v + state->bias, bits);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "state->error_sum += abs(v);\nstate->drift     += v;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "if (state->count == 128) {\n    state->count     >>= 1;\n    state->drift     >>= 1;\n    state->error_sum >>= 1;\n}\nstate->count++;\nif (state->drift <= -state->count) {\n    state->bias = max(state->bias - 1, -128);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    state->drift = max(state->drift + state->count,\n                       -state->count + 1);\n} else if (state->drift > 0) {\n    state->bias = min(state->bias + 1, 127);",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "    state->drift = min(state->drift - state->count, 0);\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "    return ret;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "3.8.2.4.1. Golomb Rice Sample Difference Coding",
      "section_title": true,
      "ja": "3.8.2.4.1. ゴローム米の差分符号化"
    },
    {
      "indent": 3,
      "text": "Level coding is identical to the normal difference coding with the exception that the 0 value is removed as it cannot occur:",
      "ja": "レベル符号化は、0値が発生することができないので、0値が削除されたことを除いて、通常の差分符号化と同じである。"
    },
    {
      "indent": 7,
      "text": "diff = get_vlc_symbol(context_state);\nif (diff >= 0) {\n    diff++;\n}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Note that this is different from JPEG-LS (lossless JPEG), which doesn't use prediction in run mode and uses a different encoding and context model for the last difference. On a small set of test Samples, the use of prediction slightly improved the compression rate.",
      "ja": "これはJPEG-LS（ロスレスJPEG）とは異なるため、ランモードで予測は使用されず、最後の違いには異なるエンコードとコンテキストモデルを使用します。小さな試験サンプルのセットでは、予測の使用は圧縮率をわずかに改善した。"
    },
    {
      "indent": 0,
      "text": "3.8.2.5. Initial Values for the VLC Context State",
      "section_title": true,
      "ja": "3.8.2.5. VLCコンテキスト状態の初期値"
    },
    {
      "indent": 3,
      "text": "When \"keyframe\" (see Section 4.4) value is 1, all VLC coder state variables are set to their initial state.",
      "ja": "「キーフレーム」（セクション4.4を参照）の値が1のとき、すべてのVLCコーダ状態変数は初期状態に設定されます。"
    },
    {
      "indent": 7,
      "text": "drift     = 0;\nerror_sum = 4;\nbias      = 0;\ncount     = 1;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4. Bitstream",
      "section_title": true,
      "ja": "4. ビットストリーム"
    },
    {
      "indent": 3,
      "text": "An FFV1 bitstream is composed of a series of one or more Frames and (when required) a \"Configuration Record\".",
      "ja": "FFV1ビットストリームは、一連の1つ以上のフレームと（必要な場合） \"構成レコード\"で構成されています。"
    },
    {
      "indent": 3,
      "text": "Within the following subsections, pseudocode as described in Section 2.2.1 is used to explain the structure of each FFV1 bitstream component. Table 4 lists symbols used to annotate that pseudocode in order to define the storage of the data referenced in that line of pseudocode.",
      "ja": "以下のサブセクションの中で、セクション2.2.1に記載されている疑似コードを使用して、各FFV1ビットストリームコンポーネントの構造を説明する。表4に、その擬似コードの行で参照されているデータの格納を定義するために、疑似コードを注釈に付すために使用される記号を示します。"
    },
    {
      "indent": 7,
      "text": "+========+==================================================+\n| symbol | definition                                       |\n+========+==================================================+\n| u(n)   | Unsigned, big-endian integer symbol using n bits |\n+--------+--------------------------------------------------+\n| br     | Boolean (1-bit) symbol that is range coded with  |\n|        | the method described in Section 3.8.1.1          |\n+--------+--------------------------------------------------+\n| ur     | Unsigned scalar symbol that is range coded with  |\n|        | the method described in Section 3.8.1.2          |\n+--------+--------------------------------------------------+\n| sr     | Signed scalar symbol that is range coded with    |\n|        | the method described in Section 3.8.1.2          |\n+--------+--------------------------------------------------+\n| sd     | Sample Difference symbol that is coded with the  |\n|        | method described in Section 3.8                  |\n+--------+--------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Table 4: Definition of pseudocode symbols for this document.",
      "ja": "表4：この文書の擬似コードシンボルの定義。"
    },
    {
      "indent": 3,
      "text": "The following MUST be provided by external means during the initialization of the decoder:",
      "ja": "次のことは、デコーダの初期化中に外部手段によって提供されなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"frame_pixel_width\" is defined as Frame width in pixels.",
      "ja": "「frame_pixel_width」は、フレーム幅としてピクセル単位で定義されています。"
    },
    {
      "indent": 3,
      "text": "\"frame_pixel_height\" is defined as Frame height in pixels.",
      "ja": "\"frame_pixel_height\"はピクセル単位のフレームの高さとして定義されています。"
    },
    {
      "indent": 3,
      "text": "Default values at the decoder initialization phase:",
      "ja": "デコーダ初期化フェーズでのデフォルト値"
    },
    {
      "indent": 3,
      "text": "\"ConfigurationRecordIsPresent\" is set to 0.",
      "ja": "\"ConfigurationRecordSpresent\"は0に設定されています。"
    },
    {
      "indent": 0,
      "text": "4.1. Quantization Table Set",
      "section_title": true,
      "ja": "4.1. 量子化テーブルセット"
    },
    {
      "indent": 3,
      "text": "The Quantization Table Sets store a sequence of values that are equal to one less than the count of equal concurrent entries for each set of equal concurrent entries within the first half of the table (represented as \"len - 1\" in the pseudocode below) using the method described in Section 3.8.1.2. The second half doesn't need to be stored as it is identical to the first with flipped sign. \"scale\" and \"len_count[ i ][ j ]\" are temporary values used for the computing of \"context_count[ i ]\" and are not used outside Quantization Table Set pseudocode.",
      "ja": "量子化テーブルセットは、テーブルの前半内の等しい同時エントリの各セットについて、等しい同時エントリの数よりも1つ以下の一連の値を格納します（下の疑似コードの「LEN-1」として表した）。3.8.1.2項に記載されている方法。第1の半分は最初の符号付きの最初のものと同じであるので保存する必要はありません。「スケール」と「LEN_COUNT [i] [j] \"は、「context_count [i]」の計算に使用される一時的な値であり、汎用テーブルセット疑似コードでは使用されません。"
    },
    {
      "indent": 3,
      "text": "Example:",
      "ja": "例："
    },
    {
      "indent": 3,
      "text": "Table: 0 0 1 1 1 1 2 2 -2 -2 -2 -1 -1 -1 -1 0",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Stored values: 1, 3, 1",
      "ja": "保存値：1,3,1"
    },
    {
      "indent": 3,
      "text": "\"QuantizationTableSet\" has its own initial states, all set to 128.",
      "ja": "\"QuantizationTableset\"はそれ自身の初期状態を持ち、すべて128に設定されています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nQuantizationTableSet( i ) {                                   |\n    scale = 1                                                 |\n    for (j = 0; j < MAX_CONTEXT_INPUTS; j++) {                |\n        QuantizationTable( i, j, scale )                      |\n        scale *= 2 * len_count[ i ][ j ] - 1                  |\n    }                                                         |\n    context_count[ i ] = ceil( scale / 2 )                    |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "\"MAX_CONTEXT_INPUTS\" is 5.",
      "ja": "\"max_context_inputs\"は5です。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nQuantizationTable(i, j, scale) {                              |\n    v = 0                                                     |\n    for (k = 0; k < 128;) {                                   |\n        len - 1                                               | ur\n        for (n = 0; n < len; n++) {                           |\n            quant_tables[ i ][ j ][ k ] = scale * v           |\n            k++                                               |\n        }                                                     |\n        v++                                                   |\n    }                                                         |\n    for (k = 1; k < 128; k++) {                               |\n        quant_tables[ i ][ j ][ 256 - k ] = \\                 |\n        -quant_tables[ i ][ j ][ k ]                          |\n    }                                                         |\n    quant_tables[ i ][ j ][ 128 ] = \\                         |\n    -quant_tables[ i ][ j ][ 127 ]                            |\n    len_count[ i ][ j ] = v                                   |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.1.1. \"quant_tables\"",
      "section_title": true,
      "ja": "4.1.1. \"quant_tables\""
    },
    {
      "indent": 3,
      "text": "\"quant_tables[ i ][ j ][ k ]\" indicates the Quantization Table value of the Quantized Sample Difference \"k\" of the Quantization Table \"j\" of the Quantization Table Set \"i\".",
      "ja": "「QUANT_TABLES [i] [j] [k]は、量子化テーブルセット「i」の量子化テーブル「j」の量子化サンプル差「k」の量子化テーブル値を示す。"
    },
    {
      "indent": 0,
      "text": "4.1.2. \"context_count\"",
      "section_title": true,
      "ja": "4.1.2. \"context_count\""
    },
    {
      "indent": 3,
      "text": "\"context_count[ i ]\" indicates the count of contexts for Quantization Table Set \"i\". \"context_count[ i ]\" MUST be less than or equal to 32768.",
      "ja": "\"context_count [i]\"は、量子化テーブルセット \"i\"のコンテキストの数を示します。\"context_count [i]\"は32768以下でなければなりません。"
    },
    {
      "indent": 0,
      "text": "4.2. Parameters",
      "section_title": true,
      "ja": "4.2. パラメーター"
    },
    {
      "indent": 3,
      "text": "The \"Parameters\" section, which could be in a global header of a container file that may or may not be considered to be part of the bitstream, contains significant characteristics about the decoding configuration used for all instances of Frame (in FFV1 versions 0 and 1) or the whole FFV1 bitstream (other versions), including the stream version, color configuration, and Quantization Tables. Figure 28 describes the contents of the bitstream.",
      "ja": "ビットストリームの一部であると考えることができる、または考慮されていてもいなくてもよく、フレームのすべてのインスタンスに使用されるデコード構成に関する重要な特性（FFV1バージョン0では、パラメータ \"セクションは、（FFV1バージョン0と）。1）またはストリームバージョン、カラー構成、および量子化テーブルを含む、FFV1ビットストリーム全体（他のバージョン）。図28は、ビットストリームの内容を説明しています。"
    },
    {
      "indent": 3,
      "text": "\"Parameters\" has its own initial states, all set to 128.",
      "ja": "「パラメータ」には独自の初期状態があり、すべて128に設定されています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nParameters( ) {                                               |\n    version                                                   | ur\n    if (version >= 3) {                                       |\n        micro_version                                         | ur\n    }                                                         |\n    coder_type                                                | ur\n    if (coder_type > 1) {                                     |\n        for (i = 1; i < 256; i++) {                           |\n            state_transition_delta[ i ]                       | sr\n        }                                                     |\n    }                                                         |\n    colorspace_type                                           | ur\n    if (version >= 1) {                                       |\n        bits_per_raw_sample                                   | ur\n    }                                                         |\n    chroma_planes                                             | br\n    log2_h_chroma_subsample                                   | ur\n    log2_v_chroma_subsample                                   | ur\n    extra_plane                                               | br\n    if (version >= 3) {                                       |\n        num_h_slices - 1                                      | ur\n        num_v_slices - 1                                      | ur\n        quant_table_set_count                                 | ur\n    }                                                         |\n    for (i = 0; i < quant_table_set_count; i++) {             |\n        QuantizationTableSet( i )                             |\n    }                                                         |\n    if (version >= 3) {                                       |\n        for (i = 0; i < quant_table_set_count; i++) {         |\n            states_coded                                      | br\n            if (states_coded) {                               |\n                for (j = 0; j < context_count[ i ]; j++) {    |\n                    for (k = 0; k < CONTEXT_SIZE; k++) {      |\n                        initial_state_delta[ i ][ j ][ k ]    | sr\n                    }                                         |\n                }                                             |\n            }                                                 |\n        }                                                     |\n        ec                                                    | ur\n        intra                                                 | ur\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 7,
      "text": "Figure 28: A pseudocode description of the bitstream contents.",
      "ja": "ビットストリームコンテンツの擬似コードの説明。"
    },
    {
      "indent": 3,
      "text": "CONTEXT_SIZE is 32.",
      "ja": "context_sizeは32です。"
    },
    {
      "indent": 0,
      "text": "4.2.1. \"version\"",
      "section_title": true,
      "ja": "4.2.1. \"バージョン\""
    },
    {
      "indent": 3,
      "text": "\"version\" specifies the version of the FFV1 bitstream.",
      "ja": "\"version\" ffv1ビットストリームのバージョンを指定します。"
    },
    {
      "indent": 3,
      "text": "Each version is incompatible with other versions: decoders SHOULD reject FFV1 bitstreams due to an unknown version.",
      "ja": "各バージョンは他のバージョンと互換性がありません。デコーダは、未知のバージョンのためにFFV1ビットストリームを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Decoders SHOULD reject FFV1 bitstreams with \"version <= 1 && ConfigurationRecordIsPresent == 1\".",
      "ja": "デコーダは、「バージョン<= 1 && configurationRecordPresent == 1」でFFV1ビットストリームを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "Decoders SHOULD reject FFV1 bitstreams with \"version >= 3 && ConfigurationRecordIsPresent == 0\".",
      "ja": "デコーダは、「バージョン> = 3 && configurationRecordSpresent == 0」でFFV1ビットストリームを拒否する必要があります。"
    },
    {
      "indent": 20,
      "text": "+=======+=========================+\n| value | version                 |\n+=======+=========================+\n| 0     | FFV1 version 0          |\n+-------+-------------------------+\n| 1     | FFV1 version 1          |\n+-------+-------------------------+\n| 2     | reserved*               |\n+-------+-------------------------+\n| 3     | FFV1 version 3          |\n+-------+-------------------------+\n| Other | reserved for future use |\n+-------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 5: The definitions for \"version\" values.",
      "ja": "表5：「バージョン」値の定義。"
    },
    {
      "indent": 3,
      "text": "* Version 2 was experimental and this document does not describe it.",
      "ja": "* バージョン2は実験的で、この文書はそれを説明していません。"
    },
    {
      "indent": 0,
      "text": "4.2.2. \"micro_version\"",
      "section_title": true,
      "ja": "4.2.2. \"micro_version\""
    },
    {
      "indent": 3,
      "text": "\"micro_version\" specifies the micro-version of the FFV1 bitstream.",
      "ja": "\"micro_version\"は、FFV1ビットストリームのマイクロバージョンを指定します。"
    },
    {
      "indent": 3,
      "text": "After a version is considered stable (a micro-version value is assigned to be the first stable variant of a specific version), each new micro-version after this first stable variant is compatible with the previous micro-version: decoders SHOULD NOT reject FFV1 bitstreams due to an unknown micro-version equal or above the micro-version considered as stable.",
      "ja": "バージョンが安定した後（マイクロバージョン値が特定のバージョンの最初のバージョンの最初のバリアントに割り当てられます）、この最初の安定したバリアントの後の新しいマイクロバージョンは、前のマイクロバージョンと互換性があります。デコーダはFFV1を拒否しないでください。セットストリームは、マイクロバージョンが安定していると考えられるマイクロバージョン以上のものによるビットストリームです。"
    },
    {
      "indent": 3,
      "text": "Meaning of \"micro_version\" for \"version\" 3:",
      "ja": "\"バージョン\" 3の \"micro_version\"の意味："
    },
    {
      "indent": 20,
      "text": "+=======+=========================+\n| value | micro_version           |\n+=======+=========================+\n| 0...3 | reserved*               |\n+-------+-------------------------+\n| 4     | first stable variant    |\n+-------+-------------------------+\n| Other | reserved for future use |\n+-------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": " Table 6: The definitions for \"micro_version\" values for FFV1 version 3.",
      "ja": "表6：FFv1バージョン3の \"micro_version\"値の定義。"
    },
    {
      "indent": 3,
      "text": "* Development versions may be incompatible with the stable variants.",
      "ja": "* 開発バージョンは安定した変種と互換性がないかもしれません。"
    },
    {
      "indent": 0,
      "text": "4.2.3. \"coder_type\"",
      "section_title": true,
      "ja": "4.2.3. \"coder_type\""
    },
    {
      "indent": 3,
      "text": "\"coder_type\" specifies the coder used.",
      "ja": "\"coder_type\"さんのコーダを指定します。"
    },
    {
      "indent": 8,
      "text": "+=======+=================================================+\n| value | coder used                                      |\n+=======+=================================================+\n| 0     | Golomb Rice                                     |\n+-------+-------------------------------------------------+\n| 1     | Range coder with default state transition table |\n+-------+-------------------------------------------------+\n| 2     | Range coder with custom state transition table  |\n+-------+-------------------------------------------------+\n| Other | reserved for future use                         |\n+-------+-------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 13,
      "text": "Table 7: The definitions for \"coder_type\" values.",
      "ja": "表7： \"coder_type\"値の定義。"
    },
    {
      "indent": 3,
      "text": "Restrictions:",
      "ja": "制限："
    },
    {
      "indent": 3,
      "text": "If \"coder_type\" is 0, then \"bits_per_raw_sample\" SHOULD NOT be > 8.",
      "ja": "\"coder_type\"が0の場合は、 \"bits_per_raw_sample\"を見つけません> 8。"
    },
    {
      "indent": 3,
      "text": "Background: At the time of this writing, there is no known implementation of FFV1 bitstream supporting the Golomb Rice algorithm with \"bits_per_raw_sample\" greater than eight, and range coder is preferred.",
      "ja": "背景：この書き込み時には、8倍を超える「BITS_PER_RAW_SAMPLE」を用いてゴロン米アルゴリズムをサポートするFFV1ビットストリームの既知の実施はなく、範囲コーダが好ましい。"
    },
    {
      "indent": 0,
      "text": "4.2.4. \"state_transition_delta\"",
      "section_title": true,
      "ja": "4.2.4. \"state_transition_delta\""
    },
    {
      "indent": 3,
      "text": "\"state_transition_delta\" specifies the range coder custom state transition table.",
      "ja": "\"state_transition_delta\"は、範囲コーダカスタム状態遷移テーブルを指定します。"
    },
    {
      "indent": 3,
      "text": "If \"state_transition_delta\" is not present in the FFV1 bitstream, all range coder custom state transition table elements are assumed to be 0.",
      "ja": "FFV1ビットストリームに \"STATE_TRANSITION_DELTA\"が存在しない場合、すべての範囲コーダーカスタム遷移表要素は0となると仮定されます。"
    },
    {
      "indent": 0,
      "text": "4.2.5. \"colorspace_type\"",
      "section_title": true,
      "ja": "4.2.5. \"colorspace_type\""
    },
    {
      "indent": 3,
      "text": "\"colorspace_type\" specifies the color space encoded, the pixel transformation used by the encoder, the extra Plane content, as well as interleave method.",
      "ja": "「colorspace_type」は、エンコーダによって使用される色空間、エンコーダによって使用されるピクセル変換、ならびにインターリーブ方法を指定します。"
    },
    {
      "indent": 3,
      "text": "+=======+==============+================+==============+============+\n| value | color space  | pixel          | extra Plane  | interleave |\n|       | encoded      | transformation | content      | method     |\n+=======+==============+================+==============+============+\n| 0     | YCbCr        | None           | Transparency | Plane then |\n|       |              |                |              | Line       |\n+-------+--------------+----------------+--------------+------------+\n| 1     | RGB          | JPEG 2000 RCT  | Transparency | Line then  |\n|       |              |                |              | Plane      |\n+-------+--------------+----------------+--------------+------------+\n| Other | reserved     | reserved for   | reserved for | reserved   |\n|       | for future   | future use     | future use   | for future |\n|       | use          |                |              | use        |\n+-------+--------------+----------------+--------------+------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Table 8: The definitions for \"colorspace_type\" values.",
      "ja": "表8：「ColorSpace_Type」の値の定義。"
    },
    {
      "indent": 3,
      "text": "FFV1 bitstreams with \"colorspace_type == 1 && (chroma_planes != 1 || log2_h_chroma_subsample != 0 || log2_v_chroma_subsample != 0)\" are not part of this specification.",
      "ja": "\"colorspace_type == 1 &&（chroma_planes！|| log2_h_chroma_subsample！= 0 || log2_v_chroma_subsample！= 0）\"がこの仕様の一部ではありません。"
    },
    {
      "indent": 0,
      "text": "4.2.6. \"chroma_planes\"",
      "section_title": true,
      "ja": "4.2.6. \"chroma_planes\""
    },
    {
      "indent": 3,
      "text": "\"chroma_planes\" indicates if chroma (color) Planes are present.",
      "ja": "「Chroma_planes」は、Chroma（Color）プレーンが存在するかどうかを示します。"
    },
    {
      "indent": 17,
      "text": "+=======+===============================+\n| value | presence                      |\n+=======+===============================+\n| 0     | chroma Planes are not present |\n+-------+-------------------------------+\n| 1     | chroma Planes are present     |\n+-------+-------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 9: The definitions for \"chroma_planes\" values.",
      "ja": "表9：「Chroma_Planes」の値の定義。"
    },
    {
      "indent": 0,
      "text": "4.2.7. \"bits_per_raw_sample\"",
      "section_title": true,
      "ja": "4.2.7. \"bits_per_raw_sample\""
    },
    {
      "indent": 3,
      "text": "\"bits_per_raw_sample\" indicates the number of bits for each Sample. Inferred to be 8 if not present.",
      "ja": "「bits_per_raw_sample」は、各サンプルのビット数を示します。存在しない場合は8と推測されています。"
    },
    {
      "indent": 16,
      "text": "+=======+=================================+\n| value | bits for each Sample            |\n+=======+=================================+\n| 0     | reserved*                       |\n+-------+---------------------------------+\n| Other | the actual bits for each Sample |\n+-------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 10: The definitions for \"bits_per_raw_sample\" values.",
      "ja": "表10：「bits_per_raw_sample」値の定義。"
    },
    {
      "indent": 3,
      "text": "* Encoders MUST NOT store \"bits_per_raw_sample = 0\". Decoders SHOULD accept and interpret \"bits_per_raw_sample = 0\" as 8.",
      "ja": "* エンコーダは「bits_per_raw_sample = 0」を保存してはいけません。デコーダは、「BITS_PER_RAW_SAMPLE = 0」を受け入れ、解釈する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.8. \"log2_h_chroma_subsample\"",
      "section_title": true,
      "ja": "4.2.8. \"log2_h_chroma_subsample\""
    },
    {
      "indent": 3,
      "text": "\"log2_h_chroma_subsample\" indicates the subsample factor, stored in powers to which the number 2 is raised, between luma and chroma width (\"chroma_width = 2 ^ -log2_h_chroma_subsample * luma_width\").",
      "ja": "\"log2_h_chroma_subSample\"はサブサンプル要因を示し、LumaとChroma幅の間で数値2が上昇している電力に格納されています（ \"chroma_width = 2 ^ -log2_h_chroma_subsample * luma_width\"）。"
    },
    {
      "indent": 0,
      "text": "4.2.9. \"log2_v_chroma_subsample\"",
      "section_title": true,
      "ja": "4.2.9. \"log2_v_chroma_subsample\""
    },
    {
      "indent": 3,
      "text": "\"log2_v_chroma_subsample\" indicates the subsample factor, stored in powers to which the number 2 is raised, between luma and chroma height (\"chroma_height = 2 ^ -log2_v_chroma_subsample * luma_height\").",
      "ja": "\"log2_v_chroma_subsample\"はサブサンプルファクタを示し、ルーマ2が発生し、LumaとChromaの高さの間に、数2が発生した電力に格納されています（ \"chroma_height = 2 ^ -log2_v_chroma_subsample * luma_height\"）。"
    },
    {
      "indent": 0,
      "text": "4.2.10. \"extra_plane\"",
      "section_title": true,
      "ja": "4.2.10. \"extra_plane\""
    },
    {
      "indent": 3,
      "text": "\"extra_plane\" indicates if an extra Plane is present.",
      "ja": "「Extra_Plane」は、余分な平面が存在するかどうかを示します。"
    },
    {
      "indent": 18,
      "text": "+=======+============================+\n| value | presence                   |\n+=======+============================+\n| 0     | extra Plane is not present |\n+-------+----------------------------+\n| 1     | extra Plane is present     |\n+-------+----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 11: The definitions for \"extra_plane\" values.",
      "ja": "表11：「Extra_Plane」値の定義。"
    },
    {
      "indent": 0,
      "text": "4.2.11. \"num_h_slices\"",
      "section_title": true,
      "ja": "4.2.11. \"num_h_slices\""
    },
    {
      "indent": 3,
      "text": "\"num_h_slices\" indicates the number of horizontal elements of the Slice raster.",
      "ja": "「NUM_H_SLICES」は、スライスラスタの水平要素数を示す。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 1 if not present.",
      "ja": "存在しない場合は1になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.2.12. \"num_v_slices\"",
      "section_title": true,
      "ja": "4.2.12. \"num_v_slices\""
    },
    {
      "indent": 3,
      "text": "\"num_v_slices\" indicates the number of vertical elements of the Slice raster.",
      "ja": "「NUM_V_SLICES」は、スライスラスタの垂直要素の数を示す。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 1 if not present.",
      "ja": "存在しない場合は1になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.2.13. \"quant_table_set_count\"",
      "section_title": true,
      "ja": "4.2.13. \"quant_table_set_count\""
    },
    {
      "indent": 3,
      "text": "\"quant_table_set_count\" indicates the number of Quantization Table Sets. \"quant_table_set_count\" MUST be less than or equal to 8.",
      "ja": "\"quant_table_set_count\"は、量子化テーブルセットの数を示します。\"quant_table_set_count\"は8以下でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 1 if not present.",
      "ja": "存在しない場合は1になると推論されます。"
    },
    {
      "indent": 3,
      "text": "MUST NOT be 0.",
      "ja": "0にしてはいけません。"
    },
    {
      "indent": 0,
      "text": "4.2.14. \"states_coded\"",
      "section_title": true,
      "ja": "4.2.14. \"states_coded\""
    },
    {
      "indent": 3,
      "text": "\"states_coded\" indicates if the respective Quantization Table Set has the initial states coded.",
      "ja": "「state_coded」は、それぞれの量子化テーブルセットに初期状態が符号化されているかどうかを示す。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 16,
      "text": "+=======+================================+\n| value | initial states                 |\n+=======+================================+\n| 0     | initial states are not present |\n|       | and are assumed to be all 128  |\n+-------+--------------------------------+\n| 1     | initial states are present     |\n+-------+--------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 12: The definitions for \"states_coded\" values.",
      "ja": "表12： \"state_coded\"値の定義。"
    },
    {
      "indent": 0,
      "text": "4.2.15. \"initial_state_delta\"",
      "section_title": true,
      "ja": "4.2.15. \"initial_state_delta\""
    },
    {
      "indent": 3,
      "text": "\"initial_state_delta[ i ][ j ][ k ]\" indicates the initial range coder state, and it is encoded using \"k\" as context index for the range coder and the following pseudocode:",
      "ja": "\"Initial_State_Delta [i] [j] [k]\"は初期範囲コーダ状態を示し、範囲コーダのコンテキストインデックスとして \"k\"を使用して符号化され、次の擬似コードが符号化される。"
    },
    {
      "indent": 3,
      "text": "pred = j ? initial_states[ i ][j - 1][ k ] : 128",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 29: Predictor value for the coding of \"initial_state_delta[ i ][ j ][ k ]\".",
      "ja": "図29：「INITIAL_STATE_DELTA [i] [j] [k]の符号化の予測値。"
    },
    {
      "indent": 3,
      "text": "initial_state[ i ][ j ][ k ] = ( pred + initial_state_delta[ i ][ j ][ k ] ) & 255",
      "ja": "initial_state [i] [j] [k] =（Pred Initial_State_Delta [i] [j] [k]）＆255"
    },
    {
      "indent": 18,
      "text": "Figure 30: Description of the coding of \"initial_state_delta[ i ][ j ][ k ]\".",
      "ja": "図30： \"Initial_State_Delta [i] [j] [k]\"のコーディングの説明。"
    },
    {
      "indent": 0,
      "text": "4.2.16. \"ec\"",
      "section_title": true,
      "ja": "4.2.16. \"EC\""
    },
    {
      "indent": 3,
      "text": "\"ec\" indicates the error detection/correction type.",
      "ja": "「EC」は、誤り検出/補正タイプを示す。"
    },
    {
      "indent": 8,
      "text": "+=======+=================================================+\n| value | error detection/correction type                 |\n+=======+=================================================+\n| 0     | 32-bit CRC in \"ConfigurationRecord\"             |\n+-------+-------------------------------------------------+\n| 1     | 32-bit CRC in \"Slice\" and \"ConfigurationRecord\" |\n+-------+-------------------------------------------------+\n| Other | reserved for future use                         |\n+-------+-------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Table 13: The definitions for \"ec\" values.",
      "ja": "表13：「EC」値の定義。"
    },
    {
      "indent": 0,
      "text": "4.2.17. \"intra\"",
      "section_title": true,
      "ja": "4.2.17. \"イントラ\""
    },
    {
      "indent": 3,
      "text": "\"intra\" indicates the constraint on \"keyframe\" in each instance of Frame.",
      "ja": "「イントラ」は、フレームの各インスタンス内の「キーフレーム」の制約を示します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 5,
      "text": "+=======+=======================================================+\n| value | relationship                                          |\n+=======+=======================================================+\n| 0     | \"keyframe\" can be 0 or 1 (non keyframes or keyframes) |\n+-------+-------------------------------------------------------+\n| 1     | \"keyframe\" MUST be 1 (keyframes only)                 |\n+-------+-------------------------------------------------------+\n| Other | reserved for future use                               |\n+-------+-------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 14: The definitions for \"intra\" values.",
      "ja": "表14：「イントラ」値の定義。"
    },
    {
      "indent": 0,
      "text": "4.3. Configuration Record",
      "section_title": true,
      "ja": "4.3. 構成レコード"
    },
    {
      "indent": 3,
      "text": "In the case of a FFV1 bitstream with \"version >= 3\", a \"Configuration Record\" is stored in the underlying container as described in Section 4.3.3. It contains the \"Parameters\" used for all instances of Frame. The size of the \"Configuration Record\", \"NumBytes\", is supplied by the underlying container.",
      "ja": "「バージョン> = 3」のFFv1ビットストリームの場合、セクション4.3.3で説明されているように、基礎となるコンテナに「構成レコード」が格納されています。フレームのすべてのインスタンスに使用される「パラメータ」が含まれています。「構成レコード」、「NUMBYTES」のサイズは、基礎となるコンテナによって提供されます。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                 | type\n-----------------------------------------------------------|-----\nConfigurationRecord( NumBytes ) {                          |\n    ConfigurationRecordIsPresent = 1                       |\n    Parameters( )                                          |\n    while (remaining_symbols_in_syntax(NumBytes - 4)) {    |\n        reserved_for_future_use                            | br/ur/sr\n    }                                                      |\n    configuration_record_crc_parity                        | u(32)\n}                                                          |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.3.1. \"reserved_for_future_use\"",
      "section_title": true,
      "ja": "4.3.1. \"reserved_for_future_use\""
    },
    {
      "indent": 3,
      "text": "\"reserved_for_future_use\" is a placeholder for future updates of this specification.",
      "ja": "\"reserved_for_future_use\"は、この仕様の将来の更新のためのプレースホルダーです。"
    },
    {
      "indent": 3,
      "text": "Encoders conforming to this version of this specification SHALL NOT write \"reserved_for_future_use\".",
      "ja": "この仕様のこのバージョンに準拠したエンコーダは、 \"reserved_for_future_use\"を書いてはいけません。"
    },
    {
      "indent": 3,
      "text": "Decoders conforming to this version of this specification SHALL ignore \"reserved_for_future_use\".",
      "ja": "この仕様のこのバージョンに準拠したデコーダは、 \"reserved_for_future_use\"を無視します。"
    },
    {
      "indent": 0,
      "text": "4.3.2. \"configuration_record_crc_parity\"",
      "section_title": true,
      "ja": "4.3.2. \"configuration_record_crc_parity\""
    },
    {
      "indent": 3,
      "text": "\"configuration_record_crc_parity\" is 32 bits that are chosen so that the \"Configuration Record\" as a whole has a CRC remainder of zero.",
      "ja": "\"configuration_record_crc_parity\"は、全体としての「設定レコード」にCRCの残りのゼロを持つように選択された32ビットです。"
    },
    {
      "indent": 3,
      "text": "This is equivalent to storing the CRC remainder in the 32-bit parity.",
      "ja": "これは、CRCの残りを32ビットパリティに格納することと同じです。"
    },
    {
      "indent": 3,
      "text": "The CRC generator polynomial used is described in Section 4.9.3.",
      "ja": "使用されているCRCジェネレータ多項式は4.9.3節で説明されています。"
    },
    {
      "indent": 0,
      "text": "4.3.3. Mapping FFV1 into Containers",
      "section_title": true,
      "ja": "4.3.3. FFV1をコンテナにマッピングする"
    },
    {
      "indent": 3,
      "text": "This \"Configuration Record\" can be placed in any file format that supports \"Configuration Records\", fitting as much as possible with how the file format stores \"Configuration Records\". The \"Configuration Record\" storage place and \"NumBytes\" are currently defined and supported for the following formats:",
      "ja": "この「構成レコード」は、ファイルのフォーマットに「構成レコード」をどのように保存するかをできるだけできる限り、できるだけ適合させるファイル形式で配置できます。「構成レコード」の記憶場所と「NUMBYTES」は現在定義され、次の形式でサポートされています。"
    },
    {
      "indent": 0,
      "text": "4.3.3.1. Audio Video Interleave (AVI) File Format",
      "section_title": true,
      "ja": "4.3.3.1. オーディオビデオインターリーブ（AVI）ファイル形式"
    },
    {
      "indent": 3,
      "text": "The \"Configuration Record\" extends the stream format chunk (\"AVI \", \"hdlr\", \"strl\", \"strf\") with the \"ConfigurationRecord\" bitstream.",
      "ja": "「構成レコード」は、「ConfigurationRecord」ビットストリームでストリームフォーマットチャンク（ \"AVI\"、 \"HDLR\"、 \"STRL\"、 \"STRF\"）を拡張します。"
    },
    {
      "indent": 3,
      "text": "See [AVI] for more information about chunks.",
      "ja": "チャンクの詳細については[AVI]を参照してください。"
    },
    {
      "indent": 3,
      "text": "\"NumBytes\" is defined as the size, in bytes, of the \"strf\" chunk indicated in the chunk header minus the size of the stream format structure.",
      "ja": "「NUMBYTES」は、チャンクヘッダに示されている「STRF」チャンクのサイズ（バイト単位）として定義されている。"
    },
    {
      "indent": 0,
      "text": "4.3.3.2. ISO Base Media File Format",
      "section_title": true,
      "ja": "4.3.3.2. ISOベースメディアファイルフォーマット"
    },
    {
      "indent": 3,
      "text": "The \"Configuration Record\" extends the sample description box (\"moov\", \"trak\", \"mdia\", \"minf\", \"stbl\", \"stsd\") with a \"glbl\" box that contains the \"ConfigurationRecord\" bitstream. See [ISO.14496-12.2020] for more information about boxes.",
      "ja": "「構成レコード」は、「ConfigurationRecord」ビットストリームを含む「GLBL」ボックスで、サンプル記述ボックス（ \"moov\"、 \"trak\"、 \"minf\"、 \"stbl\"、 \"stsd\"）を拡張します。ボックスの詳細については[ISO.14496-12.2020]を参照してください。"
    },
    {
      "indent": 3,
      "text": "\"NumBytes\" is defined as the size, in bytes, of the \"glbl\" box indicated in the box header minus the size of the box header.",
      "ja": "「NUMBYTES」は、ボックスヘッダに表示されている「GLBL」ボックスのサイズ（BYS）として定義されています。"
    },
    {
      "indent": 0,
      "text": "4.3.3.3. NUT File Format",
      "section_title": true,
      "ja": "4.3.3.3. ナットファイル形式"
    },
    {
      "indent": 3,
      "text": "The \"codec_specific_data\" element (in \"stream_header\" packet) contains the \"ConfigurationRecord\" bitstream. See [NUT] for more information about elements.",
      "ja": "\"SODEC_SPECIFIC_DATA\"要素（ \"stream_header\"パケット）には \"ConfigurationRecord\"ビットストリームが含まれています。要素の詳細については、[ナット]を参照してください。"
    },
    {
      "indent": 3,
      "text": "\"NumBytes\" is defined as the size, in bytes, of the \"codec_specific_data\" element as indicated in the \"length\" field of \"codec_specific_data\".",
      "ja": "「NUMBYTES」は、「codec_specific_data」の「length」フィールドに示されているように、 \"codec_specific_data\"要素のサイズ（バイト単位）として定義されています。"
    },
    {
      "indent": 0,
      "text": "4.3.3.4. Matroska File Format",
      "section_title": true,
      "ja": "4.3.3.4. Matroskaファイル形式"
    },
    {
      "indent": 3,
      "text": "FFV1 SHOULD use \"V_FFV1\" as the Matroska \"Codec ID\". For FFV1 versions 2 or less, the Matroska \"CodecPrivate\" Element SHOULD NOT be used. For FFV1 versions 3 or greater, the Matroska \"CodecPrivate\" Element MUST contain the FFV1 \"Configuration Record\" structure and no other data. See [Matroska] for more information about elements.",
      "ja": "FFV1はMatroska \"Codec ID\"として \"v_ffv1\"を使用する必要があります。FFV1バージョン2以下の場合、Matroska \"codecprivate\"要素は使用しないでください。FFV1バージョン3以上の場合、Matroska \"codecprivate\"要素には、FFV1 \"構成レコード\"構造と他のデータが含まれていなければなりません。要素の詳細については[Matrioska]を参照してください。"
    },
    {
      "indent": 3,
      "text": "\"NumBytes\" is defined as the \"Element Data Size\" of the \"CodecPrivate\" Element.",
      "ja": "「NUMBYTES」は、「codecprivate」要素の「要素データサイズ」として定義されています。"
    },
    {
      "indent": 0,
      "text": "4.4. Frame",
      "section_title": true,
      "ja": "4.4. フレーム"
    },
    {
      "indent": 3,
      "text": "A \"Frame\" is an encoded representation of a complete static image. The whole \"Frame\" is provided by the underlying container.",
      "ja": "「フレーム」は、完全な静的画像の符号化表現である。全体の「フレーム」は、基礎となるコンテナによって提供されます。"
    },
    {
      "indent": 3,
      "text": "A \"Frame\" consists of the \"keyframe\" field, \"Parameters\" (if \"version <= 1\"), and a sequence of independent Slices. The pseudocode below describes the contents of a \"Frame\".",
      "ja": "「フレーム」は、「キーフレーム」フィールド「パラメータ」（「バージョン<= 1」）、および一連の独立スライスで構成されています。以下の擬似コードは「フレーム」の内容を表しています。"
    },
    {
      "indent": 3,
      "text": "The \"keyframe\" field has its own initial state, set to 128.",
      "ja": "「キーフレーム」フィールドには独自の初期状態があり、128に設定されています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nFrame( NumBytes ) {                                           |\n    keyframe                                                  | br\n    if (keyframe && !ConfigurationRecordIsPresent {           |\n        Parameters( )                                         |\n    }                                                         |\n    while (remaining_bits_in_bitstream( NumBytes )) {         |\n        Slice( )                                              |\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The following is an architecture overview of Slices in a Frame:",
      "ja": "以下は、フレーム内のスライスのアーキテクチャの概要です。"
    },
    {
      "indent": 4,
      "text": "+-----------------------------------------------------------------+\n| first Slice header                                              |\n+-----------------------------------------------------------------+\n| first Slice content                                             |\n+-----------------------------------------------------------------+\n| first Slice footer                                              |\n+-----------------------------------------------------------------+\n| --------------------------------------------------------------- |\n+-----------------------------------------------------------------+\n| second Slice header                                             |\n+-----------------------------------------------------------------+\n| second Slice content                                            |\n+-----------------------------------------------------------------+\n| second Slice footer                                             |\n+-----------------------------------------------------------------+\n| --------------------------------------------------------------- |\n+-----------------------------------------------------------------+\n| ...                                                             |\n+-----------------------------------------------------------------+\n| --------------------------------------------------------------- |\n+-----------------------------------------------------------------+\n| last Slice header                                               |\n+-----------------------------------------------------------------+\n| last Slice content                                              |\n+-----------------------------------------------------------------+\n| last Slice footer                                               |\n+-----------------------------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.5. Slice",
      "section_title": true,
      "ja": "4.5. スライス"
    },
    {
      "indent": 3,
      "text": "A \"Slice\" is an independent, spatial subsection of a Frame that is encoded separately from another region of the same Frame. The use of more than one \"Slice\" per Frame provides opportunities for taking advantage of multithreaded encoding and decoding.",
      "ja": "「スライス」は、同じフレームの他の領域とは別に符号化されているフレームの独立した空間サブセクションです。フレームごとに複数の「スライス」を使用することは、マルチスレッド符号化および復号化を利用する機会を提供する。"
    },
    {
      "indent": 3,
      "text": "A \"Slice\" consists of a \"Slice Header\" (when relevant), a \"Slice Content\", and a \"Slice Footer\" (when relevant). The pseudocode below describes the contents of a \"Slice\".",
      "ja": "「スライス」は、「スライスヘッダー」（関連する場合）、「スライスコンテンツ」、「スライスフッター」（関連する場合）で構成されています。以下の擬似コードは「スライス」の内容を説明しています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nSlice( ) {                                                    |\n    if (version >= 3) {                                       |\n        SliceHeader( )                                        |\n    }                                                         |\n    SliceContent( )                                           |\n    if (coder_type == 0) {                                    |\n        while (!byte_aligned()) {                             |\n            padding                                           | u(1)\n        }                                                     |\n    }                                                         |\n    if (version <= 1) {                                       |\n        while (remaining_bits_in_bitstream( NumBytes ) != 0) {|\n            reserved                                          | u(1)\n        }                                                     |\n    }                                                         |\n    if (version >= 3) {                                       |\n        SliceFooter( )                                        |\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "\"padding\" specifies a bit without any significance and used only for byte alignment. \"padding\" MUST be 0.",
      "ja": "\"Padding\"は重要なことなくビットを指定し、バイトアライメントにのみ使用されます。「パディング」は0でなければなりません。"
    },
    {
      "indent": 3,
      "text": "\"reserved\" specifies a bit without any significance in this specification but may have a significance in a later revision of this specification.",
      "ja": "「予約済み」は、この仕様において重要なことなくビットを指定しますが、この仕様の後のリビジョンにおいて重要性があります。"
    },
    {
      "indent": 3,
      "text": "Encoders SHOULD NOT fill \"reserved\".",
      "ja": "エンコーダは「予約」を記入してはいけません。"
    },
    {
      "indent": 3,
      "text": "Decoders SHOULD ignore \"reserved\".",
      "ja": "デコーダは「予約済み」を無視する必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6. Slice Header",
      "section_title": true,
      "ja": "4.6. スライスヘッダー"
    },
    {
      "indent": 3,
      "text": "A \"Slice Header\" provides information about the decoding configuration of the \"Slice\", such as its spatial position, size, and aspect ratio. The pseudocode below describes the contents of the \"Slice Header\".",
      "ja": "「スライスヘッダ」は、その空間位置、サイズ、およびアスペクト比などの「スライス」の復号化構成に関する情報を提供する。以下の疑似コードは、「スライスヘッダー」の内容を説明しています。"
    },
    {
      "indent": 3,
      "text": "\"Slice Header\" has its own initial states, all set to 128.",
      "ja": "「スライスヘッダ」はそれ自身の初期状態を持ち、すべて128に設定されています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nSliceHeader( ) {                                              |\n    slice_x                                                   | ur\n    slice_y                                                   | ur\n    slice_width - 1                                           | ur\n    slice_height - 1                                          | ur\n    for (i = 0; i < quant_table_set_index_count; i++) {       |\n        quant_table_set_index[ i ]                            | ur\n    }                                                         |\n    picture_structure                                         | ur\n    sar_num                                                   | ur\n    sar_den                                                   | ur\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.1. \"slice_x\"",
      "section_title": true,
      "ja": "4.6.1. \"slice_x\""
    },
    {
      "indent": 3,
      "text": "\"slice_x\" indicates the x position on the Slice raster formed by \"num_h_slices\".",
      "ja": "「SLICE_X」は、「NUM_H_SLICES」によって形成されたスライスラスタ上のX位置を示す。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.6.2. \"slice_y\"",
      "section_title": true,
      "ja": "4.6.2. \"slice_y\""
    },
    {
      "indent": 3,
      "text": "\"slice_y\" indicates the y position on the Slice raster formed by \"num_v_slices\".",
      "ja": "「SLICE_Y」は、「NUM_V_SLICES」によって形成されたスライスラスタ上のY位置を示す。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.6.3. \"slice_width\"",
      "section_title": true,
      "ja": "4.6.3. \"slice_width\""
    },
    {
      "indent": 3,
      "text": "\"slice_width\" indicates the width on the Slice raster formed by \"num_h_slices\".",
      "ja": "\"slice_width\"は、 \"num_h_slices\"によって形成されたスライスラスタ上の幅を示します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 1 if not present.",
      "ja": "存在しない場合は1になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.6.4. \"slice_height\"",
      "section_title": true,
      "ja": "4.6.4. \"slice_height\""
    },
    {
      "indent": 3,
      "text": "\"slice_height\" indicates the height on the Slice raster formed by \"num_v_slices\".",
      "ja": "\"slice_height\"は、 \"num_v_slices\"によって形成されたスライスラスタ上の高さを示します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 1 if not present.",
      "ja": "存在しない場合は1になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.6.5. \"quant_table_set_index_count\"",
      "section_title": true,
      "ja": "4.6.5. \"quant_table_set_index_count\""
    },
    {
      "indent": 3,
      "text": "\"quant_table_set_index_count\" is defined as the following:",
      "ja": "\"quant_table_set_index_count\"は次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "1 + ( ( chroma_planes || version <= 3 ) ? 1 : 0 )\n    + ( extra_plane ? 1 : 0 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.6.6. \"quant_table_set_index\"",
      "section_title": true,
      "ja": "4.6.6. \"quant_table_set_index\""
    },
    {
      "indent": 3,
      "text": "\"quant_table_set_index\" indicates the Quantization Table Set index to select the Quantization Table Set and the initial states for the \"Slice Content\".",
      "ja": "\"quant_table_set_index\"は、量子化テーブルセットと「スライスコンテンツ」の初期状態を選択するための量子化テーブルセットインデックスを示します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 0,
      "text": "4.6.7. \"picture_structure\"",
      "section_title": true,
      "ja": "4.6.7. \"picture_structure\""
    },
    {
      "indent": 3,
      "text": "\"picture_structure\" specifies the temporal and spatial relationship of each Line of the Frame.",
      "ja": "「picture_structure」フレームの各行の時間的および空間的関係を指定します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 20,
      "text": "+=======+=========================+\n| value | picture structure used  |\n+=======+=========================+\n| 0     | unknown                 |\n+-------+-------------------------+\n| 1     | top field first         |\n+-------+-------------------------+\n| 2     | bottom field first      |\n+-------+-------------------------+\n| 3     | progressive             |\n+-------+-------------------------+\n| Other | reserved for future use |\n+-------+-------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 15: The definitions for \"picture_structure\" values.",
      "ja": "表15：「picture_structure」の値の定義。"
    },
    {
      "indent": 0,
      "text": "4.6.8. \"sar_num\"",
      "section_title": true,
      "ja": "4.6.8. \"SAR_NUM\""
    },
    {
      "indent": 3,
      "text": "\"sar_num\" specifies the Sample aspect ratio numerator.",
      "ja": "「SAR_NUM」は、サンプルアスペクト比分子を指定します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 3,
      "text": "A value of 0 means that aspect ratio is unknown.",
      "ja": "値0は、アスペクト比が不明であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Encoders MUST write 0 if the Sample aspect ratio is unknown.",
      "ja": "サンプルアスペクト比が不明の場合は、エンコーダが0を書き込む必要があります。"
    },
    {
      "indent": 3,
      "text": "If \"sar_den\" is 0, decoders SHOULD ignore the encoded value and consider that \"sar_num\" is 0.",
      "ja": "\"sar_den\"が0の場合、デコーダはエンコードされた値を無視し、 \"sar_num\"が0であると考える必要があります。"
    },
    {
      "indent": 0,
      "text": "4.6.9. \"sar_den\"",
      "section_title": true,
      "ja": "4.6.9. \"SAR_DEN\""
    },
    {
      "indent": 3,
      "text": "\"sar_den\" specifies the Sample aspect ratio denominator.",
      "ja": "「SAR_DEN」は、サンプルアスペクト比分母を指定します。"
    },
    {
      "indent": 3,
      "text": "Inferred to be 0 if not present.",
      "ja": "存在しない場合は0になると推論されます。"
    },
    {
      "indent": 3,
      "text": "A value of 0 means that aspect ratio is unknown.",
      "ja": "値0は、アスペクト比が不明であることを意味します。"
    },
    {
      "indent": 3,
      "text": "Encoders MUST write 0 if the Sample aspect ratio is unknown.",
      "ja": "サンプルアスペクト比が不明の場合は、エンコーダが0を書き込む必要があります。"
    },
    {
      "indent": 3,
      "text": "If \"sar_num\" is 0, decoders SHOULD ignore the encoded value and consider that \"sar_den\" is 0.",
      "ja": "\"sar_num\"が0の場合、デコーダはエンコードされた値を無視し、 \"sar_den\"が0であると考える必要があります。"
    },
    {
      "indent": 0,
      "text": "4.7. Slice Content",
      "section_title": true,
      "ja": "4.7. スライスコンテンツ"
    },
    {
      "indent": 3,
      "text": "A \"Slice Content\" contains all Line elements part of the \"Slice\".",
      "ja": "「スライスコンテンツ」には、「スライス」のすべての行要素部分が含まれています。"
    },
    {
      "indent": 3,
      "text": "Depending on the configuration, Line elements are ordered by Plane then by row (YCbCr) or by row then by Plane (RGB).",
      "ja": "構成に応じて、線要素は平面によって行（YCBCR）によって、または平面（RGB）によって平面によって順序付けされます。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nSliceContent( ) {                                             |\n    if (colorspace_type == 0) {                               |\n        for (p = 0; p < primary_color_count; p++) {           |\n            for (y = 0; y < plane_pixel_height[ p ]; y++) {   |\n                Line( p, y )                                  |\n            }                                                 |\n        }                                                     |\n    } else if (colorspace_type == 1) {                        |\n        for (y = 0; y < slice_pixel_height; y++) {            |\n            for (p = 0; p < primary_color_count; p++) {       |\n                Line( p, y )                                  |\n            }                                                 |\n        }                                                     |\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.7.1. \"primary_color_count\"",
      "section_title": true,
      "ja": "4.7.1. \"primary_color_count\""
    },
    {
      "indent": 3,
      "text": "\"primary_color_count\" is defined as the following:",
      "ja": "\"primary_color_count\"は次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "1 + ( chroma_planes ? 2 : 0 ) + ( extra_plane ? 1 : 0 )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.7.2. \"plane_pixel_height\"",
      "section_title": true,
      "ja": "4.7.2. \"PLANGE_PIXEL_HEIGHT\""
    },
    {
      "indent": 3,
      "text": "\"plane_pixel_height[ p ]\" is the height in pixels of Plane p of the \"Slice\". It is defined as the following:",
      "ja": "「PLANGE_PIXEL_HEIGHT [P] \"は、「スライス」の平面Pのピクセルの高さです。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "chroma_planes == 1 && (p == 1 || p == 2)\n    ? ceil(slice_pixel_height / (1 << log2_v_chroma_subsample))\n    : slice_pixel_height",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.7.3. \"slice_pixel_height\"",
      "section_title": true,
      "ja": "4.7.3. \"slice_pixel_height\""
    },
    {
      "indent": 3,
      "text": "\"slice_pixel_height\" is the height in pixels of the Slice. It is defined as the following:",
      "ja": "\"slice_pixel_height\"はスライスのピクセル単位の高さです。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "floor( ( slice_y + slice_height ) * slice_pixel_height / num_v_slices ) - slice_pixel_y.",
      "ja": "フロア（（slice_y slice_height）* slice_pixel_height / num_v_slices） -  slice_pixel_y。"
    },
    {
      "indent": 0,
      "text": "4.7.4. \"slice_pixel_y\"",
      "section_title": true,
      "ja": "4.7.4. \"slice_pixel_y\""
    },
    {
      "indent": 3,
      "text": "\"slice_pixel_y\" is the Slice vertical position in pixels. It is defined as the following:",
      "ja": "\"slice_pixel_y\"は、ピクセル単位のスライス垂直位置です。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "floor( slice_y * frame_pixel_height / num_v_slices )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.8. Line",
      "section_title": true,
      "ja": "4.8. ライン"
    },
    {
      "indent": 3,
      "text": "A \"Line\" is a list of the Sample Differences (relative to the predictor) of primary color components. The pseudocode below describes the contents of the \"Line\".",
      "ja": "「線」は、一次色成分の（予測因子に対する）サンプル差のリストです。以下の疑似コードは「行」の内容を表しています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nLine( p, y ) {                                                |\n    if (colorspace_type == 0) {                               |\n        for (x = 0; x < plane_pixel_width[ p ]; x++) {        |\n            sample_difference[ p ][ y ][ x ]                  | sd\n        }                                                     |\n    } else if (colorspace_type == 1) {                        |\n        for (x = 0; x < slice_pixel_width; x++) {             |\n            sample_difference[ p ][ y ][ x ]                  | sd\n        }                                                     |\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.8.1. \"plane_pixel_width\"",
      "section_title": true,
      "ja": "4.8.1. \"PLANGE_PIXEL_WIDTH\""
    },
    {
      "indent": 3,
      "text": "\"plane_pixel_width[ p ]\" is the width in pixels of Plane p of the \"Slice\". It is defined as the following:",
      "ja": "「PLANGE_PIXEL_WIDTH [P] \"は、「スライス」の平面Pのピクセル単位である。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "chroma_planes == 1 && (p == 1 || p == 2) ? ceil( slice_pixel_width / (1 << log2_h_chroma_subsample) ) : slice_pixel_width.",
      "ja": "chroma_planes == 1 &&（p == 1 || p == 2）？CEIL（SLICE_PIXEL_WIDTH /（1 << LOG2_H_HROMA_SUBSAMPLE））：slice_pixel_width。"
    },
    {
      "indent": 0,
      "text": "4.8.2. \"slice_pixel_width\"",
      "section_title": true,
      "ja": "4.8.2. \"slice_pixel_width\""
    },
    {
      "indent": 3,
      "text": "\"slice_pixel_width\" is the width in pixels of the Slice. It is defined as the following:",
      "ja": "\"slice_pixel_width\"はスライスのピクセル単位の幅です。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "floor( ( slice_x + slice_width ) * slice_pixel_width / num_h_slices ) - slice_pixel_x",
      "ja": "Floor（（SLICE_X SLICE_WIDTH）* SLICE_PIXEL_WIDTH / NUM_H_SLICES） -  SLICE_PIXEL_X"
    },
    {
      "indent": 0,
      "text": "4.8.3. \"slice_pixel_x\"",
      "section_title": true,
      "ja": "4.8.3. \"slice_pixel_x\""
    },
    {
      "indent": 3,
      "text": "\"slice_pixel_x\" is the Slice horizontal position in pixels. It is defined as the following:",
      "ja": "\"slice_pixel_x\"は、ピクセル単位のスライス水平位置です。これは次のように定義されています。"
    },
    {
      "indent": 3,
      "text": "floor( slice_x * frame_pixel_width / num_h_slices )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.8.4. \"sample_difference\"",
      "section_title": true,
      "ja": "4.8.4. \"sample_difference\""
    },
    {
      "indent": 3,
      "text": "\"sample_difference[ p ][ y ][ x ]\" is the Sample Difference for Sample at Plane \"p\", y position \"y\", and x position \"x\". The Sample value is computed based on median predictor and context described in Section 3.2.",
      "ja": "「sample_difference [p] [y] [x]は、平面「P」、Y位置「Y」、X位置「X」のサンプルのサンプル差である。サンプル値は、セクション3.2で説明されている中央値およびコンテキストに基づいて計算されます。"
    },
    {
      "indent": 0,
      "text": "4.9. Slice Footer",
      "section_title": true,
      "ja": "4.9. スライスフッター"
    },
    {
      "indent": 3,
      "text": "A \"Slice Footer\" provides information about Slice size and (optionally) parity. The pseudocode below describes the contents of the \"Slice Footer\".",
      "ja": "「スライスフッター」は、スライスサイズと（オプションで）パリティに関する情報を提供します。以下の疑似コードは、「スライスフッター」の内容を表しています。"
    },
    {
      "indent": 3,
      "text": "Note: \"Slice Footer\" is always byte aligned.",
      "ja": "注：「スライスフッター」は常にバイト整列しています。"
    },
    {
      "indent": 3,
      "text": "pseudocode                                                    | type\n--------------------------------------------------------------|-----\nSliceFooter( ) {                                              |\n    slice_size                                                | u(24)\n    if (ec) {                                                 |\n        error_status                                          | u(8)\n        slice_crc_parity                                      | u(32)\n    }                                                         |\n}                                                             |",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "4.9.1. \"slice_size\"",
      "section_title": true,
      "ja": "4.9.1. \"slice_size\""
    },
    {
      "indent": 3,
      "text": "\"slice_size\" indicates the size of the Slice in bytes.",
      "ja": "\"slice_size\"はスライスのサイズをバイト単位で示します。"
    },
    {
      "indent": 3,
      "text": "Note: this allows finding the start of Slices before previous Slices have been fully decoded and allows parallel decoding as well as error resilience.",
      "ja": "注：これにより、以前のスライスが完全に復号されている前にスライスの開始を見つけることができ、エラー回復力だけでなく並列復号化を可能にします。"
    },
    {
      "indent": 0,
      "text": "4.9.2. \"error_status\"",
      "section_title": true,
      "ja": "4.9.2. \"error_status\""
    },
    {
      "indent": 3,
      "text": "\"error_status\" specifies the error status.",
      "ja": "\"error_status\"エラーステータスを指定します。"
    },
    {
      "indent": 13,
      "text": "+=======+=======================================+\n| value | error status                          |\n+=======+=======================================+\n| 0     | no error                              |\n+-------+---------------------------------------+\n| 1     | Slice contains a correctable error    |\n+-------+---------------------------------------+\n| 2     | Slice contains an uncorrectable error |\n+-------+---------------------------------------+\n| Other | reserved for future use               |\n+-------+---------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Table 16: The definitions for \"error_status\" values.",
      "ja": "表16： \"error_status\"値の定義。"
    },
    {
      "indent": 0,
      "text": "4.9.3. \"slice_crc_parity\"",
      "section_title": true,
      "ja": "4.9.3. \"slice_crc_parity\""
    },
    {
      "indent": 3,
      "text": "\"slice_crc_parity\" is 32 bits that are chosen so that the Slice as a whole has a CRC remainder of 0.",
      "ja": "\"slice_crc_parity\"は、スライス全体がCRCの残りを持つように選択された32ビットです。"
    },
    {
      "indent": 3,
      "text": "This is equivalent to storing the CRC remainder in the 32-bit parity.",
      "ja": "これは、CRCの残りを32ビットパリティに格納することと同じです。"
    },
    {
      "indent": 3,
      "text": "The CRC generator polynomial used is the standard IEEE CRC polynomial (0x104C11DB7) with initial value 0, without pre-inversion, and without post-inversion.",
      "ja": "使用されるCRCジェネレータ多項式は、標準のIEEE CRC多項式（0x104C11DB7）であり、初期値0、プリインバイダンスがなく、転倒後もあります。"
    },
    {
      "indent": 0,
      "text": "5. Restrictions",
      "section_title": true,
      "ja": "5. 制限"
    },
    {
      "indent": 3,
      "text": "To ensure that fast multithreaded decoding is possible, starting with version 3 and if \"frame_pixel_width * frame_pixel_height\" is more than 101376, \"slice_width * slice_height\" MUST be less or equal to \"num_h_slices * num_v_slices / 4\". Note: 101376 is the frame size in pixels of a 352x288 frame also known as CIF (Common Intermediate Format) frame size format.",
      "ja": "バージョン3から始まり、 \"frame_pixel_width * frame_pixel_height\"が101376を超える場合は、 \"slice_width * slice_height\"が \"slice_width * num_v_slices / 4\"にしてください。注：101376は、CIF（Common Intermate Format）フレームサイズフォーマットとも呼ばれ、352 x 288フレームのピクセル単位です。"
    },
    {
      "indent": 3,
      "text": "For each Frame, each position in the Slice raster MUST be filled by one and only one Slice of the Frame (no missing Slice position and no Slice overlapping).",
      "ja": "各フレームについて、スライスラスタ内の各位置は、フレームのスライス（欠けていないスライス位置とスライスの重なりなし）を1つだけ充填する必要があります。"
    },
    {
      "indent": 3,
      "text": "For each Frame with a \"keyframe\" value of 0, each Slice MUST have the same value of \"slice_x\", \"slice_y\", \"slice_width\", and \"slice_height\" as a Slice in the previous Frame.",
      "ja": "「キーフレーム」値が0の各フレームに対して、各スライスは、前のフレームのスライスとして、同じ値 \"SLICE_X\"、 \"slice_y\"、 \"slice_width\"、および \"slice_height\"の値を持たなければなりません。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "Like any other codec (such as [RFC6716]), FFV1 should not be used with insecure ciphers or cipher modes that are vulnerable to known plaintext attacks. Some of the header bits as well as the padding are easily predictable.",
      "ja": "他のコーデック（RFC6716]など）と同様に、FFV1は、既知の平文攻撃に対して脆弱な不安な暗号または暗号モードで使用しないでください。ヘッダービットのいくつかとパディングは簡単に予測できます。"
    },
    {
      "indent": 3,
      "text": "Implementations of the FFV1 codec need to take appropriate security considerations into account. Those related to denial of service are outlined in Section 2.1 of [RFC4732]. It is extremely important for the decoder to be robust against malicious payloads. Malicious payloads MUST NOT cause the decoder to overrun its allocated memory or to take an excessive amount of resources to decode. An overrun in allocated memory could lead to arbitrary code execution by an attacker. The same applies to the encoder, even though problems in encoders are typically rarer. Malicious video streams MUST NOT cause the encoder to misbehave because this would allow an attacker to attack transcoding gateways. A frequent security problem in image and video codecs is failure to check for integer overflows. An example is allocating \"frame_pixel_width * frame_pixel_height\" in pixel count computations without considering that the multiplication result may have overflowed the range of the arithmetic type. The range coder could, if implemented naively, read one byte over the end. The implementation MUST ensure that no read outside allocated and initialized memory occurs.",
      "ja": "FFV1コーデックの実装は、適切なセキュリティ上の考慮事項を考慮に入れる必要があります。サービス拒否に関連するものは、[RFC4732]のセクション2.1で概説されています。デコーダが悪意のあるペイロードに対して堅牢であることは非常に重要です。悪意のあるペイロードは、デコーダに割り当てられたメモリをオーバーランさせること、またはデコードするために過剰なリソースを取り除く必要があります。割り当てられたメモリのオーバーランは、攻撃者による任意のコード実行につながる可能性があります。エンコーダ内の問題が典型的にはRARERであっても、エンコーダについても同様である。悪意のあるビデオストリームは、攻撃者がトランスコーディングゲートウェイを攻撃することを可能にするので、エンコーダに不正行為を引き起こさないでください。画像およびビデオコーデックの頻繁なセキュリティ問題は、整数オーバーフローをチェックできないことです。例は、乗算結果が算術型の範囲をオーバーフローした可能性があることを考慮せずに、ピクセルカウント計算で「frame_pixel_width * frame_pixel_height」を割り当てています。範囲コーダは、不自由に実装された場合に、最後に1バイトを読み取ることができる。実装は、読み取られた読み出しおよび初期化メモリが発生しないようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "None of the content carried in FFV1 is intended to be executable.",
      "ja": "FFV1で実行されているコンテンツはどれも実行可能であることを意図していません。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has registered the following values.",
      "ja": "IANAは以下の値を登録しました。"
    },
    {
      "indent": 0,
      "text": "7.1. Media Type Definition",
      "section_title": true,
      "ja": "7.1. メディアタイプの定義"
    },
    {
      "indent": 3,
      "text": "This registration is done using the template defined in [RFC6838] and following [RFC4855].",
      "ja": "この登録は、[RFC6838]で定義されているテンプレートを使用して[RFC4855]を使用して行われます。"
    },
    {
      "indent": 3,
      "text": "Type name: video",
      "ja": "タイプ名：ビデオ"
    },
    {
      "indent": 3,
      "text": "Subtype name: FFV1",
      "ja": "サブタイプ名：FFv1"
    },
    {
      "indent": 3,
      "text": "Required parameters: None.",
      "ja": "必要なパラメータ：なし。"
    },
    {
      "indent": 3,
      "text": "Optional parameters: These parameters are used to signal the capabilities of a receiver implementation. These parameters MUST NOT be used for any other purpose.",
      "ja": "オプションのパラメータ：これらのパラメータは、受信側実装の機能を知らせるために使用されます。これらのパラメータは他の目的には使用しないでください。"
    },
    {
      "indent": 6,
      "text": "\"version\": The \"version\" of the FFV1 encoding as defined by Section 4.2.1.",
      "ja": "\"バージョン\"：4.2.1項で定義されているFFV1エンコーディングの \"バージョン\"。"
    },
    {
      "indent": 6,
      "text": "\"micro_version\": The \"micro_version\" of the FFV1 encoding as defined by Section 4.2.2.",
      "ja": "\"micro_version\"：セクション4.2.2で定義されているFFV1エンコーディングの \"micro_version\"。"
    },
    {
      "indent": 6,
      "text": "\"coder_type\": The \"coder_type\" of the FFV1 encoding as defined by Section 4.2.3.",
      "ja": "\"coder_type\"：セクション4.2.3で定義されているFFv1エンコーディングの \"coder_type\"。"
    },
    {
      "indent": 6,
      "text": "\"colorspace_type\": The \"colorspace_type\" of the FFV1 encoding as defined by Section 4.2.5.",
      "ja": "\"colorspace_type\"：セクション4.2.5で定義されているFFv1エンコーディングの \"colorspace_type\"。"
    },
    {
      "indent": 6,
      "text": "\"bits_per_raw_sample\": The \"bits_per_raw_sample\" of the FFV1 encoding as defined by Section 4.2.7.",
      "ja": "\"bits_per_raw_sample\"：セクション4.2.7で定義されているFFv1エンコーディングの \"bits_per_raw_sample\"。"
    },
    {
      "indent": 6,
      "text": "\"max_slices\": The value of \"max_slices\" is an integer indicating the maximum count of Slices within a Frame of the FFV1 encoding.",
      "ja": "\"max_slices\"： \"max_slices\"の値は、FFV1エンコーディングのフレーム内のスライスの最大数を示す整数です。"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This media type is defined for encapsulation in several audiovisual container formats and contains binary data; see Section 4.3.3. This media type is framed binary data; see Section 4.8 of [RFC6838].",
      "ja": "エンコードに関する考慮事項：このメディアタイプは、いくつかの視聴覚コンテナフォーマットでのカプセル化に対して定義されており、バイナリデータが含まれています。セクション4.3.3を参照してください。このメディアタイプは2値データです。[RFC6838]のセクション4.8を参照してください。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See Section 6 of this document.",
      "ja": "セキュリティに関する考慮事項：この文書の6章を参照してください。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: None.",
      "ja": "相互運用性の考慮事項：なし。"
    },
    {
      "indent": 3,
      "text": "Published specification: RFC 9043.",
      "ja": "公開仕様：RFC 9043。"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: Any application that requires the transport of lossless video can use this media type. Some examples are, but not limited to, screen recording, scientific imaging, and digital video preservation.",
      "ja": "このメディアタイプを使用するアプリケーション：ロスレスビデオのトランスポートが必要なアプリケーションは、このメディアタイプを使用できます。いくつかの例は、スクリーン記録、科学的イメージング、およびデジタルビデオの保存に限定されない。"
    },
    {
      "indent": 3,
      "text": "Fragment identifier considerations: N/A.",
      "ja": "フラグメント識別子の考慮事項：N / A。"
    },
    {
      "indent": 3,
      "text": "Additional information: None.",
      "ja": "追加情報：なし。"
    },
    {
      "indent": 3,
      "text": "Person & email address to contact for further information: Michael Niedermayer (mailto:michael@niedermayer.cc)",
      "ja": "詳細については、お問い合わせ先：Michael Niedermayer（mailto：michael@niedermayer.cc）"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：一般的な"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: None.",
      "ja": "使用制限：なし。"
    },
    {
      "indent": 3,
      "text": "Author:  Dave Rice (mailto:dave@dericed.com)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Change controller: IETF CELLAR Working Group delegated from the IESG.",
      "ja": "変更コントローラ：IESGから委任されたIETF Cellarワーキンググループ。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[ISO.9899.2018] International Organization for Standardization, \"Information technology - Programming languages - C\", ISO/ IEC 9899:2018, June 2018.",
      "ja": "[ISO.9899.2018]国際標準化組織「情報技術 - プログラミング言語 -  C」、ISO / IEC 9899：2018、2018年6月。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4732] Handley, M., Ed., Rescorla, E., Ed., and IAB, \"Internet Denial-of-Service Considerations\", RFC 4732, DOI 10.17487/RFC4732, December 2006, <https://www.rfc-editor.org/info/rfc4732>.",
      "ja": "[RFC4732]ハンドリー、M.、ED。、RESCORLA、E.、ED。、およびIAB、「インターネット拒否サービス考慮事項」、RFC 4732、DOI 10.17487 / RFC4732、2006年12月、<https：// www。rfc-editor.org/info/rfc4732>。"
    },
    {
      "indent": 3,
      "text": "[RFC4855] Casner, S., \"Media Type Registration of RTP Payload Formats\", RFC 4855, DOI 10.17487/RFC4855, February 2007, <https://www.rfc-editor.org/info/rfc4855>.",
      "ja": "[RFC4855] Casner、S.、RTPペイロードフォーマットの「メディアタイプ登録」、RFC 4855、DOI 10.17487 / RFC4855、2007年2月、<https：//www.rfc-editor.org/info/rfc4855>。"
    },
    {
      "indent": 3,
      "text": "[RFC6838] Freed, N., Klensin, J., and T. Hansen, \"Media Type Specifications and Registration Procedures\", BCP 13, RFC 6838, DOI 10.17487/RFC6838, January 2013, <https://www.rfc-editor.org/info/rfc6838>.",
      "ja": "[RFC6838] Freed、N.、Klensin、J.、およびT.Hansen、「メディアタイプの仕様および登録手順」、BCP 13、RFC 6838、DOI 10.17487 / RFC6838、2013年1月、<https：///www.rfc-editor.org/info/rfc6838>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AddressSanitizer] Clang Project, \"AddressSanitizer\", Clang 12 documentation, <https://clang.llvm.org/docs/AddressSanitizer.html>.",
      "ja": "[addressSAnitizer] clangプロジェクト、 \"addresssAnitizer\"、clang 12のドキュメント、<https：//clang.llvm.org/docs/addresssanitizer.html>。"
    },
    {
      "indent": 3,
      "text": "[AVI] Microsoft, \"AVI RIFF File Reference\", <https://docs.microsoft.com/en-us/windows/win32/directshow/avi-riff-file-reference>.",
      "ja": "[AVI]マイクロソフト、「AVI RIFFファイルリファレンス」、<https：//docs.microsoft.com/en-us/windows/win32/directshow/avi-riff-file-reference>。"
    },
    {
      "indent": 3,
      "text": "[FFV1GO] Buitenhuis, D., \"FFV1 Decoder in Go\", 2019, <https://github.com/dwbuiten/go-ffv1>.",
      "ja": "[FFV1GO] Buitenhuis、D.、 \"FFV1デコーダin Go\"、2019、<https：//github.com/dwbuiten/go-ffv1>。"
    },
    {
      "indent": 3,
      "text": "[FFV1_V0] Niedermayer, M., \"Commit to mark FFV1 version 0 as non-experimental\", April 2006, <https://git.videolan.org/?p=ff mpeg.git;a=commit;h=b548f2b91b701e1235608ac882ea6df915167c 7e>.",
      "ja": "[FFV1_v0] Niedermayer、M.、2006年4月、2006年4月、<https://git.videolan.org/?p=ff mpeg.git; a = commit; h = b548f2b701e1235608Ac882J701J1235608AC882B701E1235608AC882JJ16DF91560882JJ12J1235608AC882AJ16DF915682J16DF915682062J16DF9156082JJ16DF91567C7e>。"
    },
    {
      "indent": 3,
      "text": "[FFV1_V1] Niedermayer, M., \"Commit to release FFV1 version 1\", April 2009, <https://git.videolan.org/?p=ffmpeg.git;a=commit;h=6 8f8d33becbd73b4d0aa277f472a6e8e72ea6849>.",
      "ja": "[FFV1_v1] Niedermayer、M.、2009年4月、<https://git.videolan.org/?p=ffmpeg.git.A=Commit.h=68D33BeCBD73B4D0AA277F472A6E8B4D0A277F472A6E8B4D0AA277F472A6E8B4D0AA277F472A6E8B4D0AA277F472A6E8E72277F472A6E8E72277F472A6E8E72277F472A6E8E72277F472A6E8E722JA277F472A6E8E72JA6849>。"
    },
    {
      "indent": 3,
      "text": "[FFV1_V3] Niedermayer, M., \"Commit to mark FFV1 version 3 as non-experimental\", August 2013, <https://git.videolan.org/?p=f fmpeg.git;a=commit;h=abe76b851c05eea8743f6c899cbe5f7409b0f 301>.",
      "ja": "【FFV1_V3]Niedermayer、M.、2013年8月、<https://git.videolan.org/?p=ffmpeg.git\"非実験としてFFV1バージョン3をマークするためにコミット\";=コミット; H=abe76b851c05eea8743f6c899cbe5f7409b0f301>。"
    },
    {
      "indent": 3,
      "text": "[HuffYUV] Rudiak-Gould, B., \"HuffYUV revisited\", December 2003, <https://web.archive.org/web/20040402121343/ http://cultact-server.novi.dk/kpo/huffyuv/huffyuv.html>.",
      "ja": "[Huffyuv] Rudiak-Gould、B.、 \"Huffyuv Revisited\"、2003年12月、<https://web.archive.org/web/20040402121343/ http://cultact-server.novi.dk/kpo/huffyuv/huffyuv.html>。"
    },
    {
      "indent": 3,
      "text": "[ISO.14495-1.1999] International Organization for Standardization, \"Information technology -- Lossless and near-lossless compression of continuous-tone still images: Baseline\", ISO/IEC 14495-1:1999, December 1999.",
      "ja": "[ISO.14495-1999]国際標準化、「情報技術 - 連続階調静止画の無損失、無損失圧縮：ベースライン」、ISO / IEC 14495-1：1999年12月、1999年12月。"
    },
    {
      "indent": 3,
      "text": "[ISO.14496-10.2020] International Organization for Standardization, \"Information technology -- Coding of audio-visual objects -- Part 10: Advanced Video Coding\", ISO/IEC 14496-10:2020, December 2020.",
      "ja": "[ISO.14496-10.2020]国際標準化のための国際機関「情報技術 - オーディオビジュアルオブジェクトの符号化 - 第10回：Advanced Video Coding」、ISO / IEC 14496-10：2020、2020年12月。"
    },
    {
      "indent": 3,
      "text": "[ISO.14496-12.2020] International Organization for Standardization, \"Information technology -- Coding of audio-visual objects -- Part 12: ISO base media file format\", ISO/IEC 14496-12:2020, December 2020.",
      "ja": "[ISO.14496-12.2020]国際標準化のための国際機関「情報技術 - オーディオビジュアルオブジェクトの符号化 - 第12報、ISO基本メディアファイル形式」、ISO / IEC 14496-12：2020年12月、2020年12月。"
    },
    {
      "indent": 3,
      "text": "[ISO.15444-1.2019] International Organization for Standardization, \"Information technology -- JPEG 2000 image coding system: Core coding system\", ISO/IEC 15444-1:2019, October 2019.",
      "ja": "[ISO.15444-1.2019]国際標準化のための国際機構「情報技術 -  JPEG 2000画像符号化システム：コアコーディングシステム」、ISO / IEC 15444-1：2019年10月、2019年10月。"
    },
    {
      "indent": 3,
      "text": "[Matroska] Lhomme, S., Bunkus, M., and D. Rice, \"Matroska Media Container Format Specifications\", Work in Progress, Internet-Draft, draft-ietf-cellar-matroska-07, 12 April 2021, <https://datatracker.ietf.org/doc/html/draft-ietf-cellar-matroska-07>.",
      "ja": "[Matroska] Lhomme、S.、Bunkus、M.、D.米、「Matroska Media Container形式の仕様」、進行中の作業、インターネットドラフト、ドラフト -  IETF-Cellar-Matroska-07,12 4月12日、<HTTPS：//datatracker.ietf.org/doc/html/draft-ietf-cellar-matroska-07>。"
    },
    {
      "indent": 3,
      "text": "[MediaConch] MediaArea.net, \"MediaConch\", 2018, <https://mediaarea.net/MediaConch>.",
      "ja": "[Mediaconch] MediaAra.net、 \"MediaConch\"、2018、<https://mediaarea.net/mediaconch>。"
    },
    {
      "indent": 3,
      "text": "[NUT] Niedermayer, M., \"NUT Open Container Format\", December 2013, <https://ffmpeg.org/~michael/nut.txt>.",
      "ja": "[ナット] Niedermayer、M。、「ナットオープンコンテナフォーマット」、2013年12月、<https：//ffmpeg.org/~michael/nut.txt>。"
    },
    {
      "indent": 3,
      "text": "[Range-Encoding] Martin, G. N. N., \"Range encoding: an algorithm for removing redundancy from a digitised message\", Proceedings of the Conference on Video and Data Recording, Institution of Electronic and Radio Engineers, Hampshire, England, July 1979.",
      "ja": "[Range-encoding] Martin、G. N. N. N. N.、「デジタル化されたメッセージからの冗長性を除去するためのアルゴリズム」、ビデオデータの記録会議、電子電子およびラジオエンジニア、ハンプシャー州、イギリス、1979年7月。"
    },
    {
      "indent": 3,
      "text": "[REFIMPL] Niedermayer, M., \"The reference FFV1 implementation / the FFV1 codec in FFmpeg\", <https://ffmpeg.org/doxygen/trunk/ffv1_8h.html>.",
      "ja": "[Refimpl] Niedermayer、M.、FFMPEGのFFV1の実装/ FFV1コーデック \"、<https：//ffmpeg.org/doxygen/trunk/ffv1_8h.html>。"
    },
    {
      "indent": 3,
      "text": "[RFC6716] Valin, JM., Vos, K., and T. Terriberry, \"Definition of the Opus Audio Codec\", RFC 6716, DOI 10.17487/RFC6716, September 2012, <https://www.rfc-editor.org/info/rfc6716>.",
      "ja": "[RFC6716] Valin、JM、VOS、K.、およびT.Treiberry、「Opus Audio Codecの定義」、RFC 6716、DOI 10.17487 / RFC6716、2012年9月、<https：//www.rfc-editor.org/ info / rfc6716>。"
    },
    {
      "indent": 3,
      "text": "[Valgrind] Valgrind Developers, \"Valgrind website\", <https://valgrind.org/>.",
      "ja": "[Valgrind] Valgrind開発者、「Valgrind Webサイト」、<https：//valgrind.org/>。"
    },
    {
      "indent": 3,
      "text": "[YCbCr] Wikipedia, \"YCbCr\", 25 May 2021, <https://en.wikipedia.org/w/ index.php?title=YCbCr&oldid=1025097882>.",
      "ja": "[YCBCR]ウィキペディア、「YCBCR」、2021年5月25日、<https：//en.wikipedia.org/w/ index.php？title = YCBCR＆Oldid = 1025097882>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Multithreaded Decoder Implementation Suggestions",
      "section_title": true,
      "ja": "付録A.マルチスレッドデコーダ実装提案"
    },
    {
      "indent": 3,
      "text": "This appendix is informative.",
      "ja": "この付録は有益です。"
    },
    {
      "indent": 3,
      "text": "The FFV1 bitstream is parsable in two ways: in sequential order as described in this document or with the pre-analysis of the footer of each Slice. Each Slice footer contains a \"slice_size\" field so the boundary of each Slice is computable without having to parse the Slice content. That allows multithreading as well as independence of Slice content (a bitstream error in a Slice header or Slice content has no impact on the decoding of the other Slices).",
      "ja": "FFV1ビットストリームは、この文書に記載されているような順序で、または各スライスのフッターの事前分析を行っている2つの方法で解析可能です。各スライスフッタは「スライス」フィールドを含み、各スライスの境界はスライスコンテンツを解析する必要なしに計算可能である。これにより、マルチスレッドとスライスコンテンツの独立性を可能にします（スライスヘッダーまたはスライスコンテンツ内のビットストリームエラーは、他のスライスの復号に影響を与えません）。"
    },
    {
      "indent": 3,
      "text": "After having checked the \"keyframe\" field, a decoder should parse \"slice_size\" fields, from \"slice_size\" of the last Slice at the end of the \"Frame\" up to \"slice_size\" of the first Slice at the beginning of the \"Frame\" before parsing Slices, in order to have Slice boundaries. A decoder may fall back on sequential order e.g., in case of a corrupted \"Frame\" (e.g., frame size unknown or \"slice_size\" of Slices not coherent) or if there is no possibility of seeking into the stream.",
      "ja": "「キーフレーム」フィールドをチェックした後、デコーダは、「フレーム」の最後のスライスの「slice_size」から「フレーム」の終わりに「SLICE_SIZE」から「SLICE_SIZE」から解析する必要があります。スライスを解析する前にスライス境界を持つために。デコーダは、破損した「フレーム」の場合（例えば、コヒーレントではないフレームサイズ不明または「スライス」」の場合、またはストリームに求める可能性がない場合には、順次順序で立ち上げてもよい。"
    },
    {
      "indent": 0,
      "text": "Appendix B. Future Handling of Some Streams Created by Nonconforming Encoders",
      "ja": "付録B.不適合エンコーダによって作成されたいくつかのストリームの将来の処理"
    },
    {
      "indent": 3,
      "text": "This appendix is informative.",
      "ja": "この付録は有益です。"
    },
    {
      "indent": 3,
      "text": "Some bitstreams were found with 40 extra bits corresponding to \"error_status\" and \"slice_crc_parity\" in the \"reserved\" bits of \"Slice\". Any revision of this specification should avoid adding 40 bits of content after \"SliceContent\" if \"version == 0\" or \"version == 1\", otherwise a decoder conforming to the revised specification could not distinguish between a revised bitstream and such buggy bitstream in the wild.",
      "ja": "「スライス」の「Reserved」ビットの「error_status」と「slice_crc_parity」に対応する40の追加ビットが見つかりました。「バージョン== 0」または「version == 1」の場合、この仕様の改訂は40ビットのコンテンツを追加しないでください。そうしないと、改訂された仕様に準拠したデコーダが改訂されたビットストリームとそのようなバグのビットストリームを区別できませんでした。野生で。"
    },
    {
      "indent": 0,
      "text": "Appendix C. FFV1 Implementations",
      "section_title": true,
      "ja": "付録C. FFv1実装"
    },
    {
      "indent": 3,
      "text": "This appendix provides references to a few notable implementations of FFV1.",
      "ja": "この付録では、FFv1のいくつかの注目すべき実装への参照を提供します。"
    },
    {
      "indent": 0,
      "text": "C.1. FFmpeg FFV1 Codec",
      "section_title": true,
      "ja": "C.1. FFMPEG FFV1コーデック"
    },
    {
      "indent": 3,
      "text": "This reference implementation [REFIMPL] contains no known buffer overflow or cases where a specially crafted packet or video segment could cause a significant increase in CPU load.",
      "ja": "このリファレンス実装[Refimpl]には、特別に細工されたパケットまたはビデオセグメントがCPU負荷の大幅な増加を引き起こす可能性がある既知のバッファオーバーフローまたはケースが含まれていません。"
    },
    {
      "indent": 3,
      "text": "The reference implementation [REFIMPL] was validated in the following conditions:",
      "ja": "参照実装[refimpl]は、次の条件で検証されました。"
    },
    {
      "indent": 3,
      "text": "* Sending the decoder valid packets generated by the reference encoder and verifying that the decoder's output matches the encoder's input.",
      "ja": "* リファレンスエンコーダによって生成されたデコーダ有効なパケットを送信し、デコーダの出力がエンコーダの入力と一致することを確認します。"
    },
    {
      "indent": 3,
      "text": "* Sending the decoder packets generated by the reference encoder and then subjected to random corruption.",
      "ja": "* 参照エンコーダによって生成されたデコーダパケットを送信してから、ランダムな破損を受ける。"
    },
    {
      "indent": 3,
      "text": "* Sending the decoder random packets that are not FFV1.",
      "ja": "* FFV1ではないデコーダのランダムパケットを送信します。"
    },
    {
      "indent": 3,
      "text": "In all of the conditions above, the decoder and encoder was run inside the Valgrind memory debugger [Valgrind] as well as the Clang AddressSanitizer [AddressSanitizer], which tracks reads and writes to invalid memory regions as well as the use of uninitialized memory. There were no errors reported on any of the tested conditions.",
      "ja": "上記のすべての条件では、デコーダとエンコーダは、バルグランドメモリデバッガ[valgrind]とClang AddressSanitizer [AddentsAnitizer]の内部で実行されていました。これは、不可能なメモリ領域への読み書きと未初期化メモリの使用を追跡します。テストされた条件のいずれにも報告されていませんでした。"
    },
    {
      "indent": 0,
      "text": "C.2. FFV1 Decoder in Go",
      "section_title": true,
      "ja": "C.2. GOのFFV1デコーダ"
    },
    {
      "indent": 3,
      "text": "An FFV1 decoder [FFV1GO] was written in Go by Derek Buitenhuis during the work to develop this document.",
      "ja": "この文書を開発するために、仕事中にDerek BuitenhuisによってFFV1デコーダ[FFV1GO]が書かれました。"
    },
    {
      "indent": 0,
      "text": "C.3. MediaConch",
      "section_title": true,
      "ja": "C.3. メディコンチ"
    },
    {
      "indent": 3,
      "text": "The developers of the MediaConch project [MediaConch] created an independent FFV1 decoder as part of that project to validate FFV1 bitstreams. This work led to the discovery of three conflicts between existing FFV1 implementations and draft versions of this document. These issues are addressed by Section 3.3.1, Section 3.7.2.1, and Appendix B.",
      "ja": "MediaConchプロジェクトの開発者[Mediaconch]は、FFV1ビットストリームを検証するためにそのプロジェクトの一部として独立したFFV1デコーダを作成しました。この作業により、この文書の既存のFFV1実装とドラフトバージョンの間の3つの矛盾が発見されました。これらの問題はセクション3.3.1、セクション3.7.2.1、および付録Bによって対処されています。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Michael Niedermayer",
      "ja": "Michael Niedermayer"
    },
    {
      "indent": 3,
      "text": "Email: michael@niedermayer.cc",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dave Rice",
      "ja": "デイブライト"
    },
    {
      "indent": 3,
      "text": "Email: dave@dericed.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Jérôme Martinez",
      "ja": "JérômeMartinez"
    },
    {
      "indent": 3,
      "text": "Email: jerome@mediaarea.net",
      "raw": true,
      "ja": ""
    }
  ]
}