{
  "title": {
    "text": "RFC 9053 - CBOR Object Signing and Encryption (COSE): Initial Algorithms",
    "ja": "RFC 9053 - CBORオブジェクトの署名と暗号化（COSE）：初期アルゴリズム"
  },
  "number": 9053,
  "created_at": "2022-09-02 02:47:45.235703+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                         J. Schaad\nRequest for Comments: 9053                                August Cellars\nObsoletes: 8152                                              August 2022\nCategory: Informational\nISSN: 2070-1721",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 5,
      "text": "CBOR Object Signing and Encryption (COSE): Initial Algorithms",
      "ja": "CBORオブジェクトの署名と暗号化（COSE）：初期アルゴリズム"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "Concise Binary Object Representation (CBOR) is a data format designed for small code size and small message size. There is a need to be able to define basic security services for this data format. This document defines a set of algorithms that can be used with the CBOR Object Signing and Encryption (COSE) protocol (RFC 9052).",
      "ja": "簡潔なバイナリオブジェクト表現（CBOR）は、小さなコードサイズと小さなメッセージサイズに合わせて設計されたデータ形式です。このデータ形式の基本的なセキュリティサービスを定義できる必要があります。このドキュメントでは、CBORオブジェクトの署名および暗号化（COSE）プロトコル（RFC 9052）で使用できるアルゴリズムのセットを定義します。"
    },
    {
      "indent": 3,
      "text": "This document, along with RFC 9052, obsoletes RFC 8152.",
      "ja": "このドキュメントは、RFC 9052とともに、Obsoletes RFC 8152です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。情報目的で公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Not all documents approved by the IESG are candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。IESGによって承認されたすべてのドキュメントが、インターネット標準のあらゆるレベルの候補者であるわけではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9053.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9053で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Terminology\n  1.2.  Changes from RFC 8152\n  1.3.  Document Terminology\n  1.4.  CDDL Grammar for CBOR Data Structures\n  1.5.  Examples\n2.  Signature Algorithms\n  2.1.  ECDSA\n    2.1.1.  Security Considerations for ECDSA\n  2.2.  Edwards-Curve Digital Signature Algorithm (EdDSA)\n    2.2.1.  Security Considerations for EdDSA\n3.  Message Authentication Code (MAC) Algorithms\n  3.1.  Hash-Based Message Authentication Codes (HMACs)\n    3.1.1.  Security Considerations for HMAC\n  3.2.  AES Message Authentication Code (AES-CBC-MAC)\n    3.2.1.  Security Considerations for AES-CBC-MAC\n4.  Content Encryption Algorithms\n  4.1.  AES-GCM\n    4.1.1.  Security Considerations for AES-GCM\n  4.2.  AES-CCM\n    4.2.1.  Security Considerations for AES-CCM\n  4.3.  ChaCha20 and Poly1305\n    4.3.1.  Security Considerations for ChaCha20/Poly1305\n5.  Key Derivation Functions (KDFs)\n  5.1.  HMAC-Based Extract-and-Expand Key Derivation Function\n        (HKDF)\n  5.2.  Context Information Structure\n6.  Content Key Distribution Methods\n  6.1.  Direct Encryption\n    6.1.1.  Direct Key\n    6.1.2.  Direct Key with KDF\n  6.2.  Key Wrap\n    6.2.1.  AES Key Wrap\n  6.3.  Direct Key Agreement\n    6.3.1.  Direct ECDH\n  6.4.  Key Agreement with Key Wrap\n    6.4.1.  ECDH with Key Wrap\n7.  Key Object Parameters\n  7.1.  Elliptic Curve Keys\n    7.1.1.  Double Coordinate Curves\n  7.2.  Octet Key Pair\n  7.3.  Symmetric Keys\n8.  COSE Capabilities\n  8.1.  Assignments for Existing Algorithms\n  8.2.  Assignments for Existing Key Types\n  8.3.  Examples\n9.  CBOR Encoding Restrictions\n10. IANA Considerations\n  10.1.  Changes to the \"COSE Key Types\" Registry\n  10.2.  Changes to the \"COSE Algorithms\" Registry\n  10.3.  Changes to the \"COSE Key Type Parameters\" Registry\n  10.4.  Expert Review Instructions\n11. Security Considerations\n12. References\n  12.1.  Normative References\n  12.2.  Informative References\nAcknowledgments\nAuthor's Address",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "There has been an increased focus on small, constrained devices that make up the Internet of Things (IoT). One of the standards that has come out of this process is \"Concise Binary Object Representation (CBOR)\" [STD94]. CBOR extended the data model of JavaScript Object Notation (JSON) [STD90] by allowing for binary data, among other changes. CBOR has been adopted by several of the IETF working groups dealing with the IoT world as their method of encoding data structures. CBOR was designed specifically to be small in terms of both messages transported and implementation size and to have a schema-free decoder. A need exists to provide message security services for IoT, and using CBOR as the message-encoding format makes sense.",
      "ja": "モノのインターネット（IoT）を構成する小さな制約付きデバイスに焦点が当てられています。このプロセスから生まれた基準の1つは、「簡潔なバイナリオブジェクト表現（CBOR）」[STD94]です。CBORは、他の変更などのバイナリデータを許可することにより、JavaScriptオブジェクト表記（JSON）[STD90]のデータモデルを拡張しました。CBORは、データ構造をエンコードする方法としてIoTの世界を扱うIETFワーキンググループのいくつかに採用されています。CBORは、輸送されたメッセージと実装サイズの両方の観点から、およびスキーマフリーデコーダーの両方の観点から小さいように特別に設計されました。IoTにメッセージセキュリティサービスを提供する必要があり、メッセージをコードする形式としてCBORを使用することは理にかなっています。"
    },
    {
      "indent": 3,
      "text": "The core COSE specification consists of two documents. [RFC9052] contains the serialization structures and the procedures for using the different cryptographic algorithms. This document provides an initial set of algorithms for use with those structures.",
      "ja": "コアCOSE仕様は、2つのドキュメントで構成されています。[RFC9052]には、シリアル化構造と、異なる暗号化アルゴリズムを使用する手順が含まれています。このドキュメントは、それらの構造で使用するアルゴリズムの初期セットを提供します。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Terminology",
      "section_title": true,
      "ja": "1.1. 要件用語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "1.2. Changes from RFC 8152",
      "section_title": true,
      "ja": "1.2. RFC 8152からの変更"
    },
    {
      "indent": 3,
      "text": "* Extracted the sections dealing with specific algorithms and placed them into this document. The sections dealing with structure and general processing rules are placed in [RFC9052].",
      "ja": "* 特定のアルゴリズムを扱うセクションを抽出し、それらをこのドキュメントに入れました。構造と一般的な処理ルールを扱うセクションは、[RFC9052]に配置されています。"
    },
    {
      "indent": 3,
      "text": "* Made text clarifications and changes in terminology.",
      "ja": "* テキストの明確化と用語の変更を作成しました。"
    },
    {
      "indent": 3,
      "text": "* Removed all of the details relating to countersignatures and placed them in [COUNTERSIGN].",
      "ja": "* countersignaturesに関連するすべての詳細を削除し、[countersign]に配置しました。"
    },
    {
      "indent": 0,
      "text": "1.3. Document Terminology",
      "section_title": true,
      "ja": "1.3. 文書用語"
    },
    {
      "indent": 3,
      "text": "In this document, we use the following terminology:",
      "ja": "このドキュメントでは、次の用語を使用します。"
    },
    {
      "indent": 3,
      "text": "Byte: A synonym for octet.",
      "ja": "バイト：Octetの同義語。"
    },
    {
      "indent": 3,
      "text": "Constrained Application Protocol (CoAP): A specialized web transfer protocol for use in constrained systems. It is defined in [RFC7252].",
      "ja": "制約付きアプリケーションプロトコル（COAP）：制約されたシステムで使用する専門的なWeb転送プロトコル。[RFC7252]で定義されています。"
    },
    {
      "indent": 3,
      "text": "Authenticated Encryption (AE) algorithms [RFC5116]: Encryption algorithms that provide an authentication check of the contents along with the encryption service. An example of an AE algorithm used in COSE is AES Key Wrap [RFC3394]. These algorithms are used for key encryption, but Authenticated Encryption with Associated Data (AEAD) algorithms would be preferred.",
      "ja": "認証された暗号化（AE）アルゴリズム[RFC5116]：暗号化サービスとともにコンテンツの認証チェックを提供する暗号化アルゴリズム。COSEで使用されるAEアルゴリズムの例は、AESキーラップ[RFC3394]です。これらのアルゴリズムはキー暗号化に使用されますが、関連するデータ（AEAD）アルゴリズムを使用した認証された暗号化が推奨されます。"
    },
    {
      "indent": 3,
      "text": "AEAD algorithms [RFC5116]: Encryption algorithms that provide the same authentication service of the content as AE algorithms do, and also allow associated data that is not part of the encrypted body to be included in the authentication service. An example of an AEAD algorithm used in COSE is AES-GCM [RFC5116]. These algorithms are used for content encryption and can be used for key encryption as well.",
      "ja": "AEADアルゴリズム[RFC5116]：AEアルゴリズムと同じコンテンツの認証サービスを提供する暗号化アルゴリズムは、暗号化された本体の一部ではない関連データを認証サービスに含めることもできます。COSEで使用されるAEADアルゴリズムの例は、AES-GCM [RFC5116]です。これらのアルゴリズムは、コンテンツ暗号化に使用され、キー暗号化にも使用できます。"
    },
    {
      "indent": 3,
      "text": "The term \"byte string\" is used for sequences of bytes, while the term \"text string\" is used for sequences of characters.",
      "ja": "「バイト文字列」という用語はバイトのシーケンスに使用され、「テキスト文字列」という用語は文字のシーケンスに使用されます。"
    },
    {
      "indent": 3,
      "text": "The tables for algorithms contain the following columns:",
      "ja": "アルゴリズムのテーブルには、次の列が含まれています。"
    },
    {
      "indent": 3,
      "text": "* A name for the algorithm for use in documents.",
      "ja": "* ドキュメントで使用するアルゴリズムの名前。"
    },
    {
      "indent": 3,
      "text": "* The value used on the wire for the algorithm. One place this is used is the algorithm header parameter of a message.",
      "ja": "* アルゴリズムのワイヤで使用される値。これが使用される場所の1つは、メッセージのアルゴリズムヘッダーパラメーターです。"
    },
    {
      "indent": 3,
      "text": "* A short description so that the algorithm can be easily identified when scanning the IANA registry.",
      "ja": "* IANAレジストリをスキャンするときにアルゴリズムを簡単に識別できるように、簡単な説明。"
    },
    {
      "indent": 3,
      "text": "Additional columns may be present in a table depending on the algorithms.",
      "ja": "アルゴリズムに応じて、テーブルに追加の列が存在する場合があります。"
    },
    {
      "indent": 0,
      "text": "1.4. CDDL Grammar for CBOR Data Structures",
      "section_title": true,
      "ja": "1.4. CBORデータ構造のCDDL文法"
    },
    {
      "indent": 3,
      "text": "When COSE was originally written, the Concise Data Definition Language (CDDL) [RFC8610] had not yet been published in an RFC, so it could not be used as the data description language to normatively describe the CBOR data structures employed by COSE. For that reason, the CBOR data objects defined here are described in prose. Additional (non-normative) descriptions of the COSE data objects are provided in a subset of CDDL, described in [RFC9052].",
      "ja": "COSEが当初書かれたとき、簡潔なデータ定義言語（CDDL）[RFC8610]はまだRFCに公開されていなかったため、COSEが採用しているCBORデータ構造を規範的に説明するためのデータ説明言語として使用できませんでした。そのため、ここで定義されているCBORデータオブジェクトは散文で説明されています。[RFC9052]で説明されているCDDLのサブセットで、COSEデータオブジェクトの追加（非規範的な）説明が提供されています。"
    },
    {
      "indent": 0,
      "text": "1.5. Examples",
      "section_title": true,
      "ja": "1.5. 例"
    },
    {
      "indent": 3,
      "text": "A GitHub project has been created at [GitHub-Examples] that contains a set of testing examples. Each example is found in a JSON file that contains the inputs used to create the example, some of the intermediate values that can be used for debugging, and the output of the example. The results are encoded using both hexadecimal and CBOR diagnostic notation format.",
      "ja": "GitHubプロジェクトは、一連のテスト例を含む[GitHub-Examples]で作成されています。各例は、例を作成するために使用される入力、デバッグに使用できる中間値の一部、および例の出力を含むJSONファイルにあります。結果は、16進数とCBOR診断表記形式の両方を使用してエンコードされます。"
    },
    {
      "indent": 3,
      "text": "Some of the examples are designed to be failure-testing cases; these are clearly marked as such in the JSON file.",
      "ja": "いくつかの例は、故障テストのケースとして設計されています。これらは、JSONファイルで明らかにそのようにマークされています。"
    },
    {
      "indent": 0,
      "text": "2. Signature Algorithms",
      "section_title": true,
      "ja": "2. 署名アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.1 of [RFC9052] contains a generic description of signature algorithms. This document defines signature algorithm identifiers for two signature algorithms.",
      "ja": "[RFC9052]のセクション8.1には、署名アルゴリズムの一般的な説明が含まれています。このドキュメントは、2つの署名アルゴリズムの署名アルゴリズム識別子を定義します。"
    },
    {
      "indent": 0,
      "text": "2.1. ECDSA",
      "section_title": true,
      "ja": "2.1. ecdsa"
    },
    {
      "indent": 3,
      "text": "The Elliptic Curve Digital Signature Algorithm (ECDSA) [DSS] defines a signature algorithm using Elliptic Curve Cryptography (ECC). Implementations SHOULD use a deterministic version of ECDSA such as the one defined in [RFC6979]. The use of a deterministic signature algorithm allows systems to avoid relying on random number generators in order to avoid generating the same value of \"k\" (the per-message random value). Biased generation of the value \"k\" can be attacked, and collisions of this value lead to leaked keys. It additionally allows performing deterministic tests for the signature algorithm. The use of deterministic ECDSA does not lessen the need to have good random number generation when creating the private key.",
      "ja": "楕円曲線デジタル署名アルゴリズム（ECDSA）[DSS]は、楕円曲線暗号化（ECC）を使用して署名アルゴリズムを定義します。実装は、[RFC6979]で定義されているものなど、ECDSAの決定論的バージョンを使用する必要があります。決定論的な署名アルゴリズムを使用すると、システムは乱数ジェネレーターに依存しないようにして、同じ値の「k」（メッセージごとのランダム値）を生成しないようにすることができます。値「k」の偏った生成を攻撃することができ、この値の衝突は漏れたキーにつながります。さらに、署名アルゴリズムの決定論的テストを実行することができます。決定論的ECDSAの使用は、秘密鍵を作成するときに良好な乱数生成を行う必要性を軽減することはありません。"
    },
    {
      "indent": 3,
      "text": "The ECDSA signature algorithm is parameterized with a hash function (h). In the event that the length of the hash function output is greater than the group of the key, the leftmost bytes of the hash output are used.",
      "ja": "ECDSA署名アルゴリズムは、ハッシュ関数（H）でパラメーター化されます。ハッシュ関数出力の長さがキーのグループよりも大きい場合、ハッシュ出力の左端バイトが使用されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 1.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表1にあります。"
    },
    {
      "indent": 14,
      "text": "+=======+=======+=========+==================+\n| Name  | Value | Hash    | Description      |\n+=======+=======+=========+==================+\n| ES256 |   -7  | SHA-256 | ECDSA w/ SHA-256 |\n+-------+-------+---------+------------------+\n| ES384 |  -35  | SHA-384 | ECDSA w/ SHA-384 |\n+-------+-------+---------+------------------+\n| ES512 |  -36  | SHA-512 | ECDSA w/ SHA-512 |\n+-------+-------+---------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 1: ECDSA Algorithm Values",
      "ja": "表1：ECDSAアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "This document defines ECDSA as working only with the curves P-256, P-384, and P-521. This document requires that the curves be encoded using the \"EC2\" (two coordinate elliptic curve) key type. Implementations need to check that the key type and curve are correct when creating and verifying a signature. Future documents may define it to work with other curves and key types in the future.",
      "ja": "このドキュメントでは、ECDSAが曲線P-256、P-384、およびP-521でのみ動作すると定義しています。このドキュメントでは、曲線を「EC2」（2つの座標楕円曲線）キータイプを使用してエンコードする必要があります。実装は、署名を作成および検証するときにキータイプと曲線が正しいことを確認する必要があります。将来の文書は、将来、他の曲線や重要なタイプで動作するように定義する場合があります。"
    },
    {
      "indent": 3,
      "text": "In order to promote interoperability, it is suggested that SHA-256 be used only with curve P-256, SHA-384 be used only with curve P-384, and SHA-512 be used only with curve P-521. This is aligned with the recommendation in Section 4 of [RFC5480].",
      "ja": "相互運用性を促進するために、SHA-256は曲線P-256でのみ使用し、SHA-384は曲線P-384でのみ使用し、SHA-512は曲線P-521でのみ使用することが推奨されます。これは、[RFC5480]のセクション4の推奨事項と一致しています。"
    },
    {
      "indent": 3,
      "text": "The signature algorithm results in a pair of integers (R, S). These integers will be the same length as the length of the key used for the signature process. The signature is encoded by converting the integers into byte strings of the same length as the key size. The length is rounded up to the nearest byte and is left padded with zero bits to get to the correct length. The two integers are then concatenated together to form a byte string that is the resulting signature.",
      "ja": "署名アルゴリズムは、整数（R、S）のペアになります。これらの整数は、署名プロセスに使用されるキーの長さと同じ長さになります。署名は、整数をキーサイズと同じ長さのバイト文字列に変換することによってエンコードされます。長さは最寄りのバイトまで丸められ、正しい長さに到達するためにゼロビットでパッドで埋められます。次に、2つの整数を連結して、結果の署名であるバイト文字列を形成します。"
    },
    {
      "indent": 3,
      "text": "Using the function defined in [RFC8017], the signature is:",
      "ja": "[RFC8017]で定義された関数を使用すると、署名は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "Signature = I2OSP(R, n) | I2OSP(S, n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "where n = ceiling(key_length / 8)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「ec2」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the ECDSA signature algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているECDSA署名アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"sign\" when creating an ECDSA signature.",
      "ja": "* 「key_ops」フィールドが存在する場合、ECDSA署名を作成するときに「サイン」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"verify\" when verifying an ECDSA signature.",
      "ja": "* 「key_ops」フィールドが存在する場合、ECDSA署名を検証するときに「検証」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "2.1.1. Security Considerations for ECDSA",
      "section_title": true,
      "ja": "2.1.1. ECDSAのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The security strength of the signature is no greater than the minimum of the security strength associated with the bit length of the key and the security strength of the hash function.",
      "ja": "署名のセキュリティ強度は、キーのビット長とハッシュ関数のセキュリティ強度に関連するセキュリティ強度の最小値よりも大きくありません。"
    },
    {
      "indent": 3,
      "text": "Note: Use of a deterministic signature technique is a good idea even when good random number generation exists. Doing so both reduces the possibility of having the same value of \"k\" in two signature operations and allows for reproducible signature values, which helps testing. There have been recent attacks involving faulting the device in order to extract the key. This can be addressed by combining both randomness and determinism [CFRG-DET-SIGS].",
      "ja": "注：決定論的な署名手法の使用は、良好な乱数生成が存在する場合でも良い考えです。そうすることで、2つの署名操作で同じ値「k」を持つ可能性が減り、再現可能な署名値が可能になり、テストに役立ちます。キーを抽出するために、デバイスの障害を含む最近の攻撃がありました。これは、ランダム性と決定論の両方を組み合わせることで対処できます[CFRG-det-sigs]。"
    },
    {
      "indent": 3,
      "text": "There are two substitution attacks that can theoretically be mounted against the ECDSA signature algorithm.",
      "ja": "ECDSA署名アルゴリズムに対して理論的にマウントできる2つの置換攻撃があります。"
    },
    {
      "indent": 3,
      "text": "* Changing the curve used to validate the signature: If one changes the curve used to validate the signature, then potentially one could have two messages with the same signature, each computed under a different curve. The only requirements on the new curve are that its order be the same as the old one and that it be acceptable to the client. An example would be to change from using the curve secp256r1 (aka P-256) to using secp256k1. (Both are 256-bit curves.) We currently do not have any way to deal with this version of the attack except to restrict the overall set of curves that can be used.",
      "ja": "* 署名の検証に使用される曲線の変更：署名の検証に使用される曲線を変更すると、潜在的には、それぞれが異なる曲線の下で計算された同じ署名を持つ2つのメッセージを持つことができます。新しい曲線の唯一の要件は、その順序が古い曲線と同じであり、クライアントに受け入れられることです。例は、曲線SECP256R1（別名P-256）の使用からSECP256K1の使用に変更することです。（両方とも256ビット曲線です。）現在、使用できる曲線全体を制限することを除いて、このバージョンの攻撃に対処する方法はありません。"
    },
    {
      "indent": 3,
      "text": "* Changing the hash function used to validate the signature: If one either has two different hash functions of the same length or can truncate a hash function, then one could potentially find collisions between the hash functions rather than within a single hash function. For example, truncating SHA-512 to 256 bits might collide with a SHA-256 bit hash value. As the hash algorithm is part of the signature algorithm identifier, this attack is mitigated by including a signature algorithm identifier in the protected-header bucket.",
      "ja": "* 署名の検証に使用されるハッシュ関数の変更：同じ長さの2つの異なるハッシュ関数がある場合、またはハッシュ関数を切り捨てることができる場合、単一のハッシュ関数内ではなくハッシュ関数間の衝突を見つける可能性があります。たとえば、SHA-512から256ビットの切り捨ては、SHA-256ビットハッシュ値と衝突する可能性があります。ハッシュアルゴリズムは署名アルゴリズム識別子の一部であるため、この攻撃は、保護されたヘッダーバケットに署名アルゴリズム識別子を含めることにより緩和されます。"
    },
    {
      "indent": 0,
      "text": "2.2. Edwards-Curve Digital Signature Algorithm (EdDSA)",
      "section_title": true,
      "ja": "2.2. Edwards-Curve Digital Signature Algorithm（EDDSA）"
    },
    {
      "indent": 3,
      "text": "[RFC8032] describes the elliptic curve signature scheme Edwards-curve Digital Signature Algorithm (EdDSA). In that document, the signature algorithm is instantiated using parameters for the edwards25519 and edwards448 curves. The document additionally describes two variants of the EdDSA algorithm: Pure EdDSA, where no hash function is applied to the content before signing, and HashEdDSA, where a hash function is applied to the content before signing and the result of that hash function is signed. For EdDSA, the content to be signed (either the message or the prehash value) is processed twice inside of the signature algorithm. For use with COSE, only the pure EdDSA version is used. This is because it is not expected that extremely large contents are going to be needed and, based on the arrangement of the message structure, the entire message is going to need to be held in memory in order to create or verify a signature. Therefore, there does not appear to be a need to be able to do block updates of the hash, followed by eliminating the message from memory. Applications can provide the same features by defining the content of the message as a hash value and transporting the COSE object (with the hash value) and the content as separate items.",
      "ja": "[RFC8032]は、楕円曲線署名スキームEdwards-Curve Digital Signature Algorithm（EDDSA）を説明しています。そのドキュメントでは、署名アルゴリズムは、Edwards25519およびEdwards448曲線のパラメーターを使用してインスタンス化されます。このドキュメントでは、eDDSAアルゴリズムの2つのバリエーションを記述しています。これは、署名する前にコンテンツにハッシュ関数が適用されない純粋なEDDSAと、署名前にハッシュ関数がコンテンツに適用され、そのハッシュ関数の結果が署名されているHashedDSAについて説明します。 EDDSAの場合、署名されるコンテンツ（メッセージまたはプレハッシュ値のいずれか）が署名アルゴリズムの内部で2回処理されます。 COSEで使用するためには、純粋なEDDSAバージョンのみが使用されます。これは、非常に大きな内容が必要になると予想されていないため、メッセージ構造の配置に基づいて、署名を作成または検証するためにメッセージ全体をメモリに保持する必要があるためです。したがって、ハッシュのブロック更新を実行できる必要はないように思われ、その後、メモリからメッセージを排除します。アプリケーションは、メッセージのコンテンツをハッシュ値として定義し、COSEオブジェクト（ハッシュ値）とコンテンツを個別のアイテムとして輸送することにより、同じ機能を提供できます。"
    },
    {
      "indent": 3,
      "text": "The algorithm defined in this document can be found in Table 2. A single signature algorithm is defined, which can be used for multiple curves.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表2に記載されています。単一の署名アルゴリズムが定義されており、複数の曲線に使用できます。"
    },
    {
      "indent": 22,
      "text": "+=======+=======+=============+\n| Name  | Value | Description |\n+=======+=======+=============+\n| EdDSA |   -8  | EdDSA       |\n+-------+-------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 2: EdDSA Algorithm Value",
      "ja": "表2：EDDSAアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "[RFC8032] describes the method of encoding the signature value.",
      "ja": "[RFC8032]は、署名値をエンコードする方法を説明しています。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"OKP\" (Octet Key Pair).",
      "ja": "* 「kty」フィールドが存在する必要があり、「okp」（occet keyペア）でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The \"crv\" field MUST be present, and it MUST be a curve defined for this signature algorithm.",
      "ja": "* 「CRV」フィールドが存在する必要があり、この署名アルゴリズムで定義された曲線でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match \"EdDSA\".",
      "ja": "* 「アルグ」フィールドが存在する場合、「eddsa」と一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"sign\" when creating an EdDSA signature.",
      "ja": "* 「key_ops」フィールドが存在する場合、EDDSA署名を作成するときに「サイン」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"verify\" when verifying an EdDSA signature.",
      "ja": "* 「key_ops」フィールドが存在する場合、EDDSA署名を検証するときに「検証」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "2.2.1. Security Considerations for EdDSA",
      "section_title": true,
      "ja": "2.2.1. EDDSAのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Public values are computed differently in EdDSA and Elliptic Curve Diffie-Hellman (ECDH); for this reason, the public key from one should not be used with the other algorithm.",
      "ja": "パブリック値は、EDDSAおよび楕円曲線Diffie-Hellman（ECDH）で異なる方法で計算されます。このため、1つの公開キーを他のアルゴリズムで使用しないでください。"
    },
    {
      "indent": 3,
      "text": "If batch signature verification is performed, a well-seeded cryptographic random number generator is REQUIRED (Section 8.2 of [RFC8032]). Signing and nonbatch signature verification are deterministic operations and do not need random numbers of any kind.",
      "ja": "バッチ署名検証が実行される場合、適切にシードされた暗号乱数ジェネレーターが必要です（[RFC8032]のセクション8.2）。署名および非バッチの署名検証は決定論的な操作であり、いかなる種類の乱数も必要ありません。"
    },
    {
      "indent": 0,
      "text": "3. Message Authentication Code (MAC) Algorithms",
      "section_title": true,
      "ja": "3. メッセージ認証コード（MAC）アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.2 of [RFC9052] contains a generic description of MAC algorithms. This section defines the conventions for two MAC algorithms.",
      "ja": "[RFC9052]のセクション8.2には、MACアルゴリズムの一般的な説明が含まれています。このセクションでは、2つのMACアルゴリズムの規則を定義します。"
    },
    {
      "indent": 0,
      "text": "3.1. Hash-Based Message Authentication Codes (HMACs)",
      "section_title": true,
      "ja": "3.1. ハッシュベースのメッセージ認証コード（HMACS）"
    },
    {
      "indent": 3,
      "text": "HMAC [RFC2104] [RFC4231] was designed to deal with length extension attacks. The HMAC algorithm was also designed to allow new hash functions to be directly plugged in without changes to the hash function. The HMAC design process has been shown to be solid; although the security of hash functions such as MD5 has decreased over time, the security of HMAC combined with MD5 has not yet been shown to be compromised [RFC6151].",
      "ja": "HMAC [RFC2104] [RFC4231]は、長さの拡張攻撃に対処するように設計されています。HMACアルゴリズムは、ハッシュ関数を変更せずに新しいハッシュ関数を直接プラグインできるように設計されています。HMAC設計プロセスは固体であることが示されています。MD5などのハッシュ関数のセキュリティは時間とともに減少していますが、MD5と組み合わせたHMACのセキュリティはまだ損なわれていないことが示されていません[RFC6151]。"
    },
    {
      "indent": 3,
      "text": "The HMAC algorithm is parameterized by an inner and outer padding, a hash function (h), and an authentication tag value length. For this specification, the inner and outer padding are fixed to the values set in [RFC2104]. The length of the authentication tag corresponds to the difficulty of producing a forgery. For use in constrained environments, we define one HMAC algorithm that is truncated. There are currently no known issues with truncation; however, the security strength of the message tag is correspondingly reduced in strength. When truncating, the leftmost tag-length bits are kept and transmitted.",
      "ja": "HMACアルゴリズムは、内側と外側のパディング、ハッシュ関数（H）、および認証タグ値の長さによってパラメーター化されます。この仕様では、内側と外側のパディングは[RFC2104]に設定された値に固定されています。認証タグの長さは、偽造を作成することの難しさに対応しています。制約付き環境で使用するために、切り捨てられた1つのHMACアルゴリズムを定義します。現在、切り捨てに関する既知の問題はありません。ただし、メッセージタグのセキュリティ強度の強度はそれに応じて減少します。切り捨てられると、左端のタグ長ビットが保持され、送信されます。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document can be found in Table 3.",
      "ja": "このドキュメントで定義されているアルゴリズムは、表3にあります。"
    },
    {
      "indent": 3,
      "text": "+=============+=======+=========+============+======================+\n| Name        | Value | Hash    | Tag Length | Description          |\n+=============+=======+=========+============+======================+\n| HMAC        |   4   | SHA-256 |     64     | HMAC w/ SHA-256      |\n| 256/64      |       |         |            | truncated to 64 bits |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   5   | SHA-256 |    256     | HMAC w/ SHA-256      |\n| 256/256     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   6   | SHA-384 |    384     | HMAC w/ SHA-384      |\n| 384/384     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+\n| HMAC        |   7   | SHA-512 |    512     | HMAC w/ SHA-512      |\n| 512/512     |       |         |            |                      |\n+-------------+-------+---------+------------+----------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 3: HMAC Algorithm Values",
      "ja": "表3：HMACアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Some recipient algorithms transport the key, while others derive a key from secret data. For those algorithms that transport the key (such as AES Key Wrap), the size of the HMAC key SHOULD be the same size as the output of the underlying hash function. For those algorithms that derive the key (such as ECDH), the derived key MUST be the same size as the output of the underlying hash function.",
      "ja": "一部の受信者アルゴリズムはキーを輸送し、他のレシピエントアルゴリズムは秘密データからキーを導き出します。キー（AESキーラップなど）を輸送するアルゴリズムの場合、HMACキーのサイズは、基礎となるハッシュ関数の出力と同じサイズでなければなりません。キー（ECDHなど）を導出するアルゴリズムの場合、導出されたキーは、基礎となるハッシュ関数の出力と同じサイズでなければなりません。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the HMAC algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているHMACアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC create\" when creating an HMAC authentication tag.",
      "ja": "* 「key_ops」フィールドが存在する場合、HMAC認証タグを作成するときに「Mac Create」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC verify\" when verifying an HMAC authentication tag.",
      "ja": "* 「key_ops」フィールドが存在する場合、HMAC認証タグを検証するときに「MAC検証」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "MAC値の作成と検証の実装では、キータイプ、キー長、およびアルゴリズムが関係するエンティティにとって正しく適切であることを検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "3.1.1. Security Considerations for HMAC",
      "section_title": true,
      "ja": "3.1.1. HMACのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "HMAC has proved to be resistant to attack even when used with weakened hash algorithms. The current best known attack is to brute force the key. This means that key size is going to be directly related to the security of an HMAC operation.",
      "ja": "HMACは、弱体化したハッシュアルゴリズムで使用しても攻撃に耐性があることが証明されています。現在最もよく知られている攻撃は、キーを強制的に強制的にすることです。これは、キーサイズがHMAC操作のセキュリティに直接関連することを意味します。"
    },
    {
      "indent": 0,
      "text": "3.2. AES Message Authentication Code (AES-CBC-MAC)",
      "section_title": true,
      "ja": "3.2. AESメッセージ認証コード（AES-CBC-MAC）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is the instantiation of the CBC-MAC construction (defined in [MAC]) using AES as the block cipher. For brevity, we also use \"AES-MAC\" to refer to AES-CBC-MAC. (Note that this is not the same algorithm as AES Cipher-Based Message Authentication Code (AES-CMAC) [RFC4493].)",
      "ja": "AES-CBC-MACは、AESをブロック暗号として使用して、CBC-MAC構造（[MAC]で定義）のインスタンス化です。簡潔にするために、「AES-MAC」も使用してAES-CBC-MACを参照します。（これは、AES暗号ベースのメッセージ認証コード（AES-CMAC）[RFC4493]と同じアルゴリズムではないことに注意してください。）"
    },
    {
      "indent": 3,
      "text": "AES-CBC-MAC is parameterized by the key length, the authentication tag length, and the Initialization Vector (IV) used. For all of these algorithms, the IV is fixed to all zeros. We provide an array of algorithms for various key and tag lengths. The algorithms defined in this document are found in Table 4.",
      "ja": "AES-CBC-MACは、キー長、認証タグの長さ、および使用される初期化ベクトル（IV）によってパラメーター化されます。これらのすべてのアルゴリズムについて、IVはすべてのゼロに固定されています。さまざまなキーとタグの長さのアルゴリズムの配列を提供します。このドキュメントで定義されているアルゴリズムを表4に示します。"
    },
    {
      "indent": 5,
      "text": "+=========+=======+============+============+==================+\n| Name    | Value | Key Length | Tag Length | Description      |\n+=========+=======+============+============+==================+\n| AES-MAC |   14  |    128     |     64     | AES-MAC 128-bit  |\n| 128/64  |       |            |            | key, 64-bit tag  |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   15  |    256     |     64     | AES-MAC 256-bit  |\n| 256/64  |       |            |            | key, 64-bit tag  |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   25  |    128     |    128     | AES-MAC 128-bit  |\n| 128/128 |       |            |            | key, 128-bit tag |\n+---------+-------+------------+------------+------------------+\n| AES-MAC |   26  |    256     |    128     | AES-MAC 256-bit  |\n| 256/128 |       |            |            | key, 128-bit tag |\n+---------+-------+------------+------------+------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 4: AES-MAC Algorithm Values",
      "ja": "表4：AES-MACアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations creating and validating MAC values MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造のいずれかから取得できます。MAC値の作成と検証の実装では、キータイプ、キー長、およびアルゴリズムが関係するエンティティにとって正しく適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the AES-MAC algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているAES-MACアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC create\" when creating an AES-MAC authentication tag.",
      "ja": "* 「key_ops」フィールドが存在する場合、AES-MAC認証タグを作成するときに「Mac Create」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"MAC verify\" when verifying an AES-MAC authentication tag.",
      "ja": "* 「key_ops」フィールドが存在する場合、AES-MAC認証タグを検証するときに「MAC検証」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "3.2.1. Security Considerations for AES-CBC-MAC",
      "section_title": true,
      "ja": "3.2.1. AES-CBC-MACのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "A number of attacks exist against Cipher Block Chaining Message Authentication Code (CBC-MAC) that need to be considered.",
      "ja": "考慮する必要があるCipherブロックチェーンメッセージ認証コード（CBC-MAC）に対して多くの攻撃が存在します。"
    },
    {
      "indent": 3,
      "text": "* A single key must only be used for messages of a fixed or known length. If this is not the case, an attacker will be able to generate a message with a valid tag given two message and tag pairs. This can be addressed by using different keys for messages of different lengths. The current structure mitigates this problem, as a specific encoding structure that includes lengths is built and signed. (CMAC also addresses this issue.)",
      "ja": "* 単一のキーは、固定または既知の長さのメッセージにのみ使用する必要があります。そうでない場合、攻撃者は、2つのメッセージとタグペアが与えられた有効なタグを使用してメッセージを生成できます。これは、異なる長さのメッセージに異なるキーを使用することで対処できます。現在の構造は、長さを含む特定のエンコード構造が構築および署名されているため、この問題を軽減します。（CMACもこの問題に対処しています。）"
    },
    {
      "indent": 3,
      "text": "* In Cipher Block Chaining (CBC) mode, if the same key is used for both encryption and authentication operations, an attacker can produce messages with a valid authentication code.",
      "ja": "* 暗号ブロックチェーン（CBC）モードでは、暗号化と認証操作の両方に同じキーが使用されている場合、攻撃者は有効な認証コードでメッセージを作成できます。"
    },
    {
      "indent": 3,
      "text": "* If the IV can be modified, then messages can be forged. This is addressed by fixing the IV to all zeros.",
      "ja": "* IVを変更できる場合、メッセージを偽造できます。これは、IVをすべてのゼロに固定することによって対処されます。"
    },
    {
      "indent": 0,
      "text": "4. Content Encryption Algorithms",
      "section_title": true,
      "ja": "4. コンテンツ暗号化アルゴリズム"
    },
    {
      "indent": 3,
      "text": "Section 8.3 of [RFC9052] contains a generic description of content encryption algorithms. This document defines the identifier and usages for three content encryption algorithms.",
      "ja": "[RFC9052]のセクション8.3には、コンテンツ暗号化アルゴリズムの一般的な説明が含まれています。このドキュメントでは、3つのコンテンツ暗号化アルゴリズムの識別子と使用法を定義します。"
    },
    {
      "indent": 0,
      "text": "4.1. AES-GCM",
      "section_title": true,
      "ja": "4.1. AES-GCM"
    },
    {
      "indent": 3,
      "text": "The Galois/Counter Mode (GCM) mode is a generic AEAD block cipher mode defined in [AES-GCM]. The GCM mode is combined with the AES block encryption algorithm to define an AEAD cipher.",
      "ja": "Galois/Counter Mode（GCM）モードは、[AES-GCM]で定義された一般的なAEADブロック暗号モードです。GCMモードは、AESブロック暗号化アルゴリズムと組み合わされて、AEAD暗号を定義します。"
    },
    {
      "indent": 3,
      "text": "The GCM mode is parameterized by the size of the authentication tag and the size of the nonce. This document fixes the size of the nonce at 96 bits. The size of the authentication tag is limited to a small set of values. For this document, however, the size of the authentication tag is fixed at 128 bits.",
      "ja": "GCMモードは、認証タグのサイズと非CEのサイズによってパラメーター化されます。このドキュメントでは、96ビットでNonCEのサイズを修正します。認証タグのサイズは、小さな値のセットに制限されています。ただし、このドキュメントでは、認証タグのサイズは128ビットに固定されています。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document is in Table 5.",
      "ja": "このドキュメントで定義されているアルゴリズムのセットは、表5にあります。"
    },
    {
      "indent": 6,
      "text": "+=========+=======+==========================================+\n| Name    | Value | Description                              |\n+=========+=======+==========================================+\n| A128GCM |   1   | AES-GCM mode w/ 128-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+\n| A192GCM |   2   | AES-GCM mode w/ 192-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+\n| A256GCM |   3   | AES-GCM mode w/ 256-bit key, 128-bit tag |\n+---------+-------+------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 5: Algorithm Values for AES-GCM",
      "ja": "表5：AES-GCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造のいずれかから取得できます。暗号化または復号化されている実装は、キータイプ、キーの長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the AES-GCM algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているAES-GCMアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合は、暗号化時に「暗号化」または「ラップキー」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合、復号化時に「decrypt」または「wrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.1.1. Security Considerations for AES-GCM",
      "section_title": true,
      "ja": "4.1.1. AES-GCMのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-GCM, the following restrictions MUST be enforced:",
      "ja": "AES-GCMを使用する場合、次の制限を実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The key and nonce pair MUST be unique for every message encrypted.",
      "ja": "* キーとノンセのペアは、暗号化されたすべてのメッセージに対して一意でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The total number of messages encrypted for a single key MUST NOT exceed 2^32 [SP800-38D]. An explicit check is required only in environments where it is expected that this limit might be exceeded.",
      "ja": "* 単一のキーに対して暗号化されたメッセージの総数は、2^32 [SP800-38D]を超えてはなりません。明示的なチェックは、この制限を超えると予想される環境でのみ必要です。"
    },
    {
      "indent": 3,
      "text": "* [RFC8446] contains an analysis on the use of AES-CGM for its environment. Based on that recommendation, one should restrict the number of messages encrypted to 2^24.5.",
      "ja": "* [RFC8446]には、AES-CGMの環境の使用に関する分析が含まれています。その推奨に基づいて、暗号化されたメッセージの数を2^24.5に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "* A more recent analysis in [ROBUST] indicates that the number of failed decryptions needs to be taken into account as part of determining when a key rollover is to be done. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^36.",
      "ja": "* [Robust]のより最近の分析は、キーロールオーバーがいつ行われるかを決定する一環として、失敗した復号の数を考慮に入れる必要があることを示しています。DTLS（[RFC9147]のセクション4.5.3）の推奨に続いて、故障したメッセージ復号の数は2^36に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to supporting smaller tag values; the constrained community would desire tag sizes in the 64-bit range. Such use drastically changes both the maximum message size (generally not an issue) and the number of times that a key can be used. Given that Counter with CBC-MAC (CCM) is the usual mode for constrained environments, restricted modes are not supported.",
      "ja": "より小さなタグ値をサポートすることを考慮しました。制約されたコミュニティは、64ビット範囲のタグサイズを望んでいます。このような使用は、最大メッセージサイズ（通常は問題ではない）とキーを使用できる回数の両方を劇的に変更します。CBC-MAC（CCM）のカウンターは、制約された環境の通常のモードであるため、制限されたモードはサポートされていません。"
    },
    {
      "indent": 0,
      "text": "4.2. AES-CCM",
      "section_title": true,
      "ja": "4.2. AES-CCM"
    },
    {
      "indent": 3,
      "text": "CCM is a generic authentication encryption block cipher mode defined in [RFC3610]. The CCM mode is combined with the AES block encryption algorithm to define an AEAD cipher that is commonly used in constrained devices.",
      "ja": "CCMは、[RFC3610]で定義された一般的な認証暗号化ブロック暗号モードです。CCMモードはAESブロック暗号化アルゴリズムと組み合わされて、制約付きデバイスで一般的に使用されるAEAD暗号を定義します。"
    },
    {
      "indent": 3,
      "text": "The CCM mode has two parameter choices. The first choice is M, the size of the authentication field. The choice of the value for M involves a trade-off between message growth (from the tag) and the probability that an attacker can undetectably modify a message. The second choice is L, the size of the length field. This value requires a trade-off between the maximum message size and the size of the nonce.",
      "ja": "CCMモードには2つのパラメーターの選択肢があります。最初の選択は、認証フィールドのサイズであるmです。Mの値の選択には、メッセージの成長（タグから）と攻撃者がメッセージを検出可能に変更できる確率との間のトレードオフが含まれます。2番目の選択はL、長さフィールドのサイズです。この値には、最大メッセージサイズとノンセのサイズとの間のトレードオフが必要です。"
    },
    {
      "indent": 3,
      "text": "It is unfortunate that the specification for CCM specified L and M as a count of bytes rather than a count of bits. This leads to possible misunderstandings where AES-CCM-8 is frequently used to refer to a version of CCM mode where the size of the authentication is 64 bits and not 8 bits. In most cryptographic algorithm specifications, these values have traditionally been specified as bit counts rather than byte counts. This document will follow the convention of using bit counts so that it is easier to compare the different algorithms presented in this document.",
      "ja": "CCMの仕様により、LとMがビットのカウントではなくバイトのカウントとして指定されたことは残念です。これにより、AES-CCM-8が8ビットではなく64ビットであるCCMモードのバージョンを参照するためにAES-CCM-8が頻繁に使用される可能性のある誤解につながります。ほとんどの暗号化アルゴリズムの仕様では、これらの値は伝統的にバイトカウントではなくビットカウントとして指定されてきました。このドキュメントは、ビットカウントを使用するという慣習に従っているため、このドキュメントに示されているさまざまなアルゴリズムを簡単に比較できます。"
    },
    {
      "indent": 3,
      "text": "We define a matrix of algorithms in this document over the values of L and M. Constrained devices are usually operating in situations where they use short messages and want to avoid doing recipient-specific cryptographic operations. This favors smaller values of both L and M. Less-constrained devices will want to be able to use larger messages and are more willing to generate new keys for every operation. This favors larger values of L and M.",
      "ja": "このドキュメントのアルゴリズムのマトリックスを、LとMの値を上回って定義します。制約付きデバイスは通常、短いメッセージを使用し、受信者固有の暗号操作を避けたい状況で動作します。これにより、LとMの両方の値が優先されます。これは、制約の少ないデバイスが、より大きなメッセージを使用できるようになり、すべての操作に新しいキーを生成することを望んでいます。これは、LとMのより大きな値を支持します"
    },
    {
      "indent": 3,
      "text": "The following values are used for L:",
      "ja": "次の値はLに使用されます。"
    },
    {
      "indent": 3,
      "text": "16 bits (2): This limits messages to 2^16 bytes (64 KiB) in length. This is sufficiently long for messages in the constrained world. The nonce length is 13 bytes allowing for 2^104 possible values of the nonce without repeating.",
      "ja": "16ビット（2）：これにより、メッセージは長さが2^16バイト（64キブ）に制限されます。これは、制約された世界のメッセージには十分に長いです。NonCeの長さは13バイトで、繰り返すことなく2^104のNonCeの値が可能になります。"
    },
    {
      "indent": 3,
      "text": "64 bits (8): This limits messages to 2^64 bytes in length. The nonce length is 7 bytes, allowing for 2^56 possible values of the nonce without repeating.",
      "ja": "64ビット（8）：これにより、メッセージは2^64バイトの長さに制限されます。NonCeの長さは7バイトで、繰り返すことなく2^56のNonCeの値が可能になります。"
    },
    {
      "indent": 3,
      "text": "The following values are used for M:",
      "ja": "次の値はMに使用されます。"
    },
    {
      "indent": 3,
      "text": "64 bits (8): This produces a 64-bit authentication tag. This implies that there is a 1 in 2^64 chance that a modified message will authenticate.",
      "ja": "64ビット（8）：これにより、64ビット認証タグが生成されます。これは、修正されたメッセージが認証される2^64に1つのチャンスがあることを意味します。"
    },
    {
      "indent": 3,
      "text": "128 bits (16): This produces a 128-bit authentication tag. This implies that there is a 1 in 2^128 chance that a modified message will authenticate.",
      "ja": "128ビット（16）：これにより、128ビット認証タグが生成されます。これは、修正されたメッセージが認証されるという2^128の可能性が1にあることを意味します。"
    },
    {
      "indent": 4,
      "text": "+====================+=======+====+=====+========+===============+\n| Name               | Value | L  | M   |  Key   | Description   |\n|                    |       |    |     | Length |               |\n+====================+=======+====+=====+========+===============+\n| AES-CCM-16-64-128  |   10  | 16 | 64  |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-64-256  |   11  | 16 | 64  |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-64-128  |   12  | 64 | 64  |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-64-256  |   13  | 64 | 64  |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 64-bit tag,   |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-128-128 |   30  | 16 | 128 |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-16-128-256 |   31  | 16 | 128 |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 13-byte nonce |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-128-128 |   32  | 64 | 128 |  128   | AES-CCM mode  |\n|                    |       |    |     |        | 128-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+\n| AES-CCM-64-128-256 |   33  | 64 | 128 |  256   | AES-CCM mode  |\n|                    |       |    |     |        | 256-bit key,  |\n|                    |       |    |     |        | 128-bit tag,  |\n|                    |       |    |     |        | 7-byte nonce  |\n+--------------------+-------+----+-----+--------+---------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 6: Algorithm Values for AES-CCM",
      "ja": "表6：AES-CCMのアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造のいずれかから取得できます。暗号化または復号化されている実装は、キータイプ、キーの長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the AES-CCM algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているAES-CCMアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合は、暗号化時に「暗号化」または「ラップキー」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合、復号化時に「decrypt」または「wrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Security Considerations for AES-CCM",
      "section_title": true,
      "ja": "4.2.1. AES-CCMのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "When using AES-CCM, the following restrictions MUST be enforced:",
      "ja": "AES-CCMを使用する場合、次の制限を実施する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The key and nonce pair MUST be unique for every message encrypted. Note that the value of L influences the number of unique nonces.",
      "ja": "* キーとノンセのペアは、暗号化されたすべてのメッセージに対して一意でなければなりません。Lの値は、一意のノンセの数に影響することに注意してください。"
    },
    {
      "indent": 3,
      "text": "* The total number of times the AES block cipher is used MUST NOT exceed 2^61 operations. This limit is the sum of times the block cipher is used in computing the MAC value and performing stream encryption operations. An explicit check is required only in environments where it is expected that this limit might be exceeded.",
      "ja": "* 使用されるAESブロック暗号の合計回数は、2^61操作を超えてはなりません。この制限は、ブロック暗号がMAC値の計算とストリーム暗号化操作の実行に使用される回数の合計です。明示的なチェックは、この制限を超えると予想される環境でのみ必要です。"
    },
    {
      "indent": 3,
      "text": "* [RFC9147] contains an analysis on the use of AES-CCM for its environment. Based on that recommendation, one should restrict the number of messages encrypted to 2^23.",
      "ja": "* [RFC9147]には、AES-CCMの環境の使用に関する分析が含まれています。その推奨に基づいて、暗号化されたメッセージの数を2^23に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "* In addition to the number of messages successfully decrypted, the number of failed decryptions needs to be tracked as well. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^23.5. If one is using the 64-bit tag, then the limits are significantly smaller if one wants to keep the same integrity limits. A protocol recommending this needs to analyze what level of integrity is acceptable for the smaller tag size. It may be that, to keep the desired level of integrity, one needs to rekey as often as every 2^7 messages.",
      "ja": "* 正常に復号化されたメッセージの数に加えて、故障した故障の数も追跡する必要があります。DTLS（[RFC9147]のセクション4.5.3）の推奨に続いて、故障したメッセージ復号の数は2^23.5に制限する必要があります。64ビットタグを使用している場合、同じ整合性の制限を維持したい場合、制限は大幅に小さくなります。これを推奨するプロトコルは、タグのサイズが小さい場合、どのレベルの整合性が許容できるかを分析する必要があります。目的のレベルの完全性を維持するには、2^7のメッセージごとに頻繁に再キーを再キーする必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] additionally calls out one other consideration of note. It is possible to do a precomputation attack against the algorithm in cases where portions of the plaintext are highly predictable. This reduces the security of the key size by half. Ways to deal with this attack include adding a random portion to the nonce value and/or increasing the key size used. Using a portion of the nonce for a random value will decrease the number of messages that a single key can be used for. Increasing the key size may require more resources in the constrained device. See Sections 5 and 10 of [RFC3610] for more information.",
      "ja": "[RFC3610]さらに、もう1つのメモの考慮事項を呼び出します。プレーンテキストの一部が非常に予測可能な場合、アルゴリズムに対して事前計算攻撃を行うことができます。これにより、キーサイズのセキュリティが半分に減少します。この攻撃に対処する方法には、NonCe値にランダム部分を追加したり、使用したキーサイズを増やしたりすることが含まれます。ランダムな値にNonCEの一部を使用すると、単一のキーを使用できるメッセージの数が減少します。キーサイズを増やすと、制約付きデバイスでより多くのリソースが必要になる場合があります。詳細については、[RFC3610]のセクション5および10を参照してください。"
    },
    {
      "indent": 0,
      "text": "4.3. ChaCha20 and Poly1305",
      "section_title": true,
      "ja": "4.3. Chacha20およびPoly1305"
    },
    {
      "indent": 3,
      "text": "ChaCha20 and Poly1305 combined together is an AEAD mode that is defined in [RFC8439]. This is an algorithm defined using a cipher that is not AES and thus would not suffer from any future weaknesses found in AES. These cryptographic functions are designed to be fast in software-only implementations.",
      "ja": "Chacha20とPoly1305を組み合わせることは、[RFC8439]で定義されているAEADモードです。これは、AESではないため、AESに見られる将来の弱点に悩まされない暗号を使用して定義されるアルゴリズムです。これらの暗号化関数は、ソフトウェアのみの実装で高速になるように設計されています。"
    },
    {
      "indent": 3,
      "text": "The ChaCha20/Poly1305 AEAD construction defined in [RFC8439] has no parameterization. It takes as inputs a 256-bit key and a 96-bit nonce, as well as the plaintext and additional data, and produces the ciphertext as an output. We define one algorithm identifier for this algorithm in Table 7.",
      "ja": "[RFC8439]で定義されているChacha20/Poly1305 AEAD構造には、パラメーター化はありません。入力として256ビットキーと96ビットのNonCE、およびプレーンテキストと追加データを使用し、出力として暗号文を生成します。このアルゴリズムの1つのアルゴリズム識別子を表7に定義します。"
    },
    {
      "indent": 9,
      "text": "+===================+=======+==========================+\n| Name              | Value | Description              |\n+===================+=======+==========================+\n| ChaCha20/Poly1305 |   24  | ChaCha20/Poly1305 w/     |\n|                   |       | 256-bit key, 128-bit tag |\n+-------------------+-------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 14,
      "text": "Table 7: Algorithm Value for ChaCha20/Poly1305",
      "ja": "表7：Chacha20/Poly1305のアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造のいずれかから取得できます。暗号化または復号化されている実装は、キータイプ、キーの長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the ChaCha20/Poly1305 algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているChacha20/Poly1305アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合は、暗号化時に「暗号化」または「ラップキー」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合、復号化時に「decrypt」または「wrap key」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "4.3.1. Security Considerations for ChaCha20/Poly1305",
      "section_title": true,
      "ja": "4.3.1. Chacha20/Poly1305のセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The key and nonce values MUST be a unique pair for every invocation of the algorithm. Nonce counters are considered to be an acceptable way of ensuring that they are unique.",
      "ja": "キーとノンセの値は、アルゴリズムの呼び出しごとに一意のペアでなければなりません。ノンセカウンターは、それらがユニークであることを保証する許容可能な方法であると考えられています。"
    },
    {
      "indent": 3,
      "text": "A more recent analysis in [ROBUST] indicates that the number of failed decryptions needs to be taken into account as part of determining when a key rollover is to be done. Following the recommendation in DTLS (Section 4.5.3 of [RFC9147]), the number of failed message decryptions should be limited to 2^36.",
      "ja": "[Robust]のより最近の分析は、キーロールオーバーがいつ行われるかを決定する一環として、失敗した復号の数を考慮に入れる必要があることを示しています。DTLS（[RFC9147]のセクション4.5.3）の推奨に続いて、故障したメッセージ復号の数は2^36に制限する必要があります。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] notes that the (64-bit) record sequence number would wrap before the safety limit is reached for ChaCha20/Poly1305. COSE implementations should not send more than 2^64 messages encrypted using a single ChaCha20/Poly1305 key.",
      "ja": "[RFC8446]は、Chacha20/Poly1305の安全限界に達する前に、（64ビット）レコードシーケンス番号がラップすることに注意してください。COSEの実装は、単一のChacha20/Poly1305キーを使用して暗号化された2^64以上のメッセージを送信してはなりません。"
    },
    {
      "indent": 0,
      "text": "5. Key Derivation Functions (KDFs)",
      "section_title": true,
      "ja": "5. キー派生関数（KDFS）"
    },
    {
      "indent": 3,
      "text": "Section 8.4 of [RFC9052] contains a generic description of key derivation functions. This document defines a single context structure and a single KDF. These elements are used for all of the recipient algorithms defined in this document that require a KDF process. These algorithms are defined in Sections 6.1.2, 6.3.1, and 6.4.1.",
      "ja": "[RFC9052]のセクション8.4には、キー派生関数の一般的な説明が含まれています。このドキュメントは、単一のコンテキスト構造と単一のKDFを定義します。これらの要素は、KDFプロセスを必要とするこのドキュメントで定義されているすべての受信者アルゴリズムに使用されます。これらのアルゴリズムは、セクション6.1.2、6.3.1、および6.4.1で定義されています。"
    },
    {
      "indent": 0,
      "text": "5.1. HMAC-Based Extract-and-Expand Key Derivation Function (HKDF)",
      "section_title": true,
      "ja": "5.1. HMACベースの抽出および拡張キー派生関数（HKDF）"
    },
    {
      "indent": 3,
      "text": "The HKDF key derivation algorithm is defined in [RFC5869] and [HKDF].",
      "ja": "HKDFキー派生アルゴリズムは[RFC5869]および[HKDF]で定義されています。"
    },
    {
      "indent": 3,
      "text": "The HKDF algorithm takes these inputs:",
      "ja": "HKDFアルゴリズムはこれらの入力を取得します。"
    },
    {
      "indent": 3,
      "text": "secret: A shared value that is secret. Secrets may be either previously shared or derived from operations like a Diffie-Hellman (DH) key agreement.",
      "ja": "秘密：秘密の共有価値。秘密は、以前に共有されているか、diffie-hellman（DH）キー契約のような操作から派生した場合があります。"
    },
    {
      "indent": 3,
      "text": "salt: An optional value that is used to change the generation process. The salt value can be either public or private. If the salt is public and carried in the message, then the \"salt\" algorithm header parameter defined in Table 9 is used. While [RFC5869] suggests that the length of the salt be the same as the length of the underlying hash value, any positive salt length will improve the security, as different key values will be generated. This parameter is protected by being included in the key computation and does not need to be separately authenticated. The salt value does not need to be unique for every message sent.",
      "ja": "塩：生成プロセスを変更するために使用されるオプションの値。塩の値は、パブリックまたはプライベートにすることができます。塩が公開され、メッセージに含まれている場合、表9で定義されている「塩」アルゴリズムヘッダーパラメーターが使用されます。[RFC5869]は、塩の長さが基礎となるハッシュ値の長さと同じであることを示唆していますが、異なるキー値が生成されるため、正の塩の長さはセキュリティを改善します。このパラメーターは、キー計算に含まれることによって保護されており、個別に認証する必要はありません。塩の値は、送信されるメッセージごとに一意である必要はありません。"
    },
    {
      "indent": 3,
      "text": "length: The number of bytes of output that need to be generated.",
      "ja": "長さ：生成する必要がある出力のバイト数。"
    },
    {
      "indent": 3,
      "text": "context information: Information that describes the context in which the resulting value will be used. Making this information specific to the context in which the material is going to be used ensures that the resulting material will always be tied to that usage. The context structure defined in Section 5.2 is used by the KDFs in this document.",
      "ja": "コンテキスト情報：結果の値が使用されるコンテキストを説明する情報。素材を使用するコンテキストに固有のこの情報を作成することにより、結果の素材が常にその使用に関連することが保証されます。セクション5.2で定義されているコンテキスト構造は、このドキュメントのKDFSによって使用されます。"
    },
    {
      "indent": 3,
      "text": "PRF: The underlying pseudorandom function to be used in the HKDF algorithm. The PRF is encoded into the HKDF algorithm selection.",
      "ja": "PRF：HKDFアルゴリズムで使用される基礎となる擬似ランダム機能。PRFは、HKDFアルゴリズムの選択にエンコードされています。"
    },
    {
      "indent": 3,
      "text": "HKDF is defined to use HMAC as the underlying PRF. However, it is possible to use other functions in the same construct to provide a different KDF that is more appropriate in the constrained world. Specifically, one can use AES-CBC-MAC as the PRF for the expand step, but not for the extract step. When using a good random shared secret of the correct length, the extract step can be skipped. For the AES algorithm versions, the extract step is always skipped.",
      "ja": "HKDFは、HMACを基礎となるPRFとして使用するように定義されています。ただし、同じ構成要素の他の機能を使用して、制約された世界でより適切な異なるKDFを提供することができます。具体的には、拡張ステップのPRFとしてAES-CBC-MACを使用できますが、抽出ステップでは使用できません。正しい長さの良好なランダム共有秘密を使用する場合、抽出ステップをスキップできます。AESアルゴリズムバージョンの場合、抽出ステップは常にスキップされます。"
    },
    {
      "indent": 3,
      "text": "The extract step cannot be skipped if the secret is not uniformly random -- for example, if it is the result of an ECDH key agreement step. This implies that the AES HKDF version cannot be used with ECDH. If the extract step is skipped, the \"salt\" value is not used as part of the HKDF functionality.",
      "ja": "秘密が均一にランダムでない場合、たとえばECDHキー契約ステップの結果である場合、抽出ステップをスキップできません。これは、AES HKDFバージョンをECDHで使用できないことを意味します。抽出ステップがスキップされている場合、「塩」値はHKDF機能の一部として使用されません。"
    },
    {
      "indent": 3,
      "text": "The algorithms defined in this document are found in Table 8.",
      "ja": "このドキュメントで定義されているアルゴリズムを表8に示します。"
    },
    {
      "indent": 7,
      "text": "+==============+===================+========================+\n| Name         | PRF               | Description            |\n+==============+===================+========================+\n| HKDF SHA-256 | HMAC with SHA-256 | HKDF using HMAC        |\n|              |                   | SHA-256 as the PRF     |\n+--------------+-------------------+------------------------+\n| HKDF SHA-512 | HMAC with SHA-512 | HKDF using HMAC        |\n|              |                   | SHA-512 as the PRF     |\n+--------------+-------------------+------------------------+\n| HKDF AES-    | AES-CBC-MAC-128   | HKDF using AES-MAC as  |\n| MAC-128      |                   | the PRF w/ 128-bit key |\n+--------------+-------------------+------------------------+\n| HKDF AES-    | AES-CBC-MAC-256   | HKDF using AES-MAC as  |\n| MAC-256      |                   | the PRF w/ 256-bit key |\n+--------------+-------------------+------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Table 8: HKDF Algorithms",
      "ja": "表8：HKDFアルゴリズム"
    },
    {
      "indent": 4,
      "text": "+======+=======+======+============================+=============+\n| Name | Label | Type | Algorithm                  | Description |\n+======+=======+======+============================+=============+\n| salt | -20   | bstr | direct+HKDF-SHA-256,       | Random salt |\n|      |       |      | direct+HKDF-SHA-512,       |             |\n|      |       |      | direct+HKDF-AES-128,       |             |\n|      |       |      | direct+HKDF-AES-256, ECDH- |             |\n|      |       |      | ES+HKDF-256, ECDH-ES+HKDF- |             |\n|      |       |      | 512, ECDH-SS+HKDF-256,     |             |\n|      |       |      | ECDH-SS+HKDF-512, ECDH-    |             |\n|      |       |      | ES+A128KW, ECDH-ES+A192KW, |             |\n|      |       |      | ECDH-ES+A256KW, ECDH-      |             |\n|      |       |      | SS+A128KW, ECDH-SS+A192KW, |             |\n|      |       |      | ECDH-SS+A256KW             |             |\n+------+-------+------+----------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 9: HKDF Algorithm Parameters",
      "ja": "表9：HKDFアルゴリズムパラメーター"
    },
    {
      "indent": 0,
      "text": "5.2. Context Information Structure",
      "section_title": true,
      "ja": "5.2. コンテキスト情報構造"
    },
    {
      "indent": 3,
      "text": "The context information structure is used to ensure that the derived keying material is \"bound\" to the context of the transaction. The context information structure used here is based on that defined in [SP800-56A]. By using CBOR for the encoding of the context information structure, we automatically get the same type and length separation of fields that is obtained by the use of ASN.1. This means that there is no need to encode the lengths for the base elements, as it is done by the encoding used in JSON Object Signing and Encryption (JOSE) (Section 4.6.2 of [RFC7518]).",
      "ja": "コンテキスト情報構造は、導出されたキーイング材料がトランザクションのコンテキストに「バインド」されるようにするために使用されます。ここで使用されるコンテキスト情報構造は、[SP800-56A]で定義されているものに基づいています。コンテキスト情報構造のエンコードにCBORを使用することにより、ASN.1の使用によって得られるフィールドの同じタイプと長さの分離を自動的に取得します。これは、JSONオブジェクトの署名と暗号化（ホセ）で使用されるエンコード（[RFC7518]のセクション4.6.2）で使用されるように、ベース要素の長さをエンコードする必要がないことを意味します。"
    },
    {
      "indent": 3,
      "text": "The context information structure refers to PartyU and PartyV as the two parties that are doing the key derivation. Unless the application protocol defines differently, we assign PartyU to the entity that is creating the message and PartyV to the entity that is receiving the message. By defining this association, different keys will be derived for each direction, as the context information is different in each direction.",
      "ja": "コンテキスト情報構造は、Key Derivationを行っている2つのパーティーとPartyuとPartyvを指します。アプリケーションプロトコルが異なる方法で定義されていない限り、メッセージとpartyvを作成しているエンティティにpartyUを、メッセージを受信しているエンティティに割り当てます。この関連付けを定義することにより、コンテキスト情報が各方向で異なるため、各方向に異なるキーが導出されます。"
    },
    {
      "indent": 3,
      "text": "The context structure is built from information that is known to both entities. This information can be obtained from a variety of sources:",
      "ja": "コンテキスト構造は、両方のエンティティに知られている情報から構築されています。この情報は、さまざまなソースから取得できます。"
    },
    {
      "indent": 3,
      "text": "* Fields can be defined by the application. This is commonly used to assign fixed names to parties, but it can be used for other items such as nonces.",
      "ja": "* フィールドはアプリケーションで定義できます。これは一般に、固定名をパーティーに割り当てるために使用されますが、Noncesなどの他のアイテムに使用できます。"
    },
    {
      "indent": 3,
      "text": "* Fields can be defined by usage of the output. Examples of this are the algorithm and key size that are being generated.",
      "ja": "* フィールドは、出力の使用によって定義できます。この例は、生成されているアルゴリズムとキーサイズです。"
    },
    {
      "indent": 3,
      "text": "* Fields can be defined by parameters from the message. We define a set of header parameters in Table 10 that can be used to carry the values associated with the context structure. Examples of this are identities and nonce values. These header parameters are designed to be placed in the unprotected bucket of the recipient structure; they do not need to be in the protected bucket, since they are already included in the cryptographic computation by virtue of being included in the context structure.",
      "ja": "* フィールドは、メッセージのパラメーターによって定義できます。表10のヘッダーパラメーターのセットを定義します。これは、コンテキスト構造に関連付けられた値を運ぶために使用できます。この例は、アイデンティティとノンセの値です。これらのヘッダーパラメーターは、レシピエント構造の保護されていないバケツに配置されるように設計されています。コンテキスト構造に含まれているため、すでに暗号化計算に含まれているため、保護されたバケットにいる必要はありません。"
    },
    {
      "indent": 3,
      "text": "+==========+=======+======+===========================+=============+\n| Name     | Label | Type | Algorithm                 | Description |\n+==========+=======+======+===========================+=============+\n| PartyU   | -21   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyU   | -22   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyU   | -23   | bstr | direct+HKDF-SHA-256,      | PartyU      |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -24   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| identity |       |      | direct+HKDF-SHA-512,      | identity    |\n|          |       |      | direct+HKDF-AES-128,      | information |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -25   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| nonce    |       | /    | direct+HKDF-SHA-512,      | provided    |\n|          |       | int  | direct+HKDF-AES-128,      | nonce       |\n|          |       |      | direct+HKDF-AES-256,      |             |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+\n| PartyV   | -26   | bstr | direct+HKDF-SHA-256,      | PartyV      |\n| other    |       |      | direct+HKDF-SHA-512,      | other       |\n|          |       |      | direct+HKDF-AES-128,      | provided    |\n|          |       |      | direct+HKDF-AES-256,      | information |\n|          |       |      | ECDH-ES+HKDF-256,         |             |\n|          |       |      | ECDH-ES+HKDF-512,         |             |\n|          |       |      | ECDH-SS+HKDF-256,         |             |\n|          |       |      | ECDH-SS+HKDF-512,         |             |\n|          |       |      | ECDH-ES+A128KW,           |             |\n|          |       |      | ECDH-ES+A192KW,           |             |\n|          |       |      | ECDH-ES+A256KW,           |             |\n|          |       |      | ECDH-SS+A128KW,           |             |\n|          |       |      | ECDH-SS+A192KW,           |             |\n|          |       |      | ECDH-SS+A256KW            |             |\n+----------+-------+------+---------------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 10: Context Algorithm Parameters",
      "ja": "表10：コンテキストアルゴリズムパラメーター"
    },
    {
      "indent": 3,
      "text": "We define a CBOR object to hold the context information. This object is referred to as COSE_KDF_Context. The object is based on a CBOR array type. The fields in the array are:",
      "ja": "CBORオブジェクトを定義して、コンテキスト情報を保持します。このオブジェクトは、cose_kdf_contextと呼ばれます。オブジェクトは、CBORアレイタイプに基づいています。配列内のフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "AlgorithmID: This field indicates the algorithm for which the key material will be used. This normally is either a key wrap algorithm identifier or a content encryption algorithm identifier. The values are from the \"COSE Algorithms\" registry. This field is required to be present. The field exists in the context information so that a different key is generated for each algorithm even if all of the other context information is the same. In practice, this means if algorithm A is broken and thus finding the key is relatively easy, the key derived for algorithm B will not be the same as the key derived for algorithm A.",
      "ja": "アルゴリズム：このフィールドは、キーマテリアルが使用されるアルゴリズムを示します。これは通常、キーラップアルゴリズム識別子またはコンテンツ暗号化アルゴリズム識別子のいずれかです。値は、「COSEアルゴリズム」レジストリからのものです。このフィールドは存在する必要があります。フィールドはコンテキスト情報に存在するため、他のすべてのコンテキスト情報が同じであっても、各アルゴリズムに対して別のキーが生成されます。実際には、これはアルゴリズムAが壊れているため、キーを見つけることが比較的簡単である場合、アルゴリズムBに導出されたキーはアルゴリズムAの導出されたキーと同じではないことを意味します。"
    },
    {
      "indent": 3,
      "text": "PartyUInfo: This field holds information about PartyU. The PartyUInfo is encoded as a CBOR array. The elements of PartyUInfo are encoded in the order presented below. The elements of the PartyUInfo array are:",
      "ja": "PartyUinfo：このフィールドには、Partyuに関する情報が保持されています。PartyUINFOはCBORアレイとしてエンコードされています。Partyuinfoの要素は、以下に示す順序でエンコードされています。partyuinfoアレイの要素は次のとおりです。"
    },
    {
      "indent": 6,
      "text": "identity: This contains the identity information for PartyU. The identities can be assigned in one of two manners. First, a protocol can assign identities based on roles. For example, the roles of \"client\" and \"server\" may be assigned to different entities in the protocol. Each entity would then use the correct label for the data it sends or receives. The second way for a protocol to assign identities is to use a name based on a naming system (i.e., DNS or X.509 names).",
      "ja": "ID：これには、partyuのID情報が含まれています。アイデンティティは、2つのマナーのいずれかで割り当てることができます。まず、プロトコルは役割に基づいてアイデンティティを割り当てることができます。たとえば、「クライアント」と「サーバー」の役割は、プロトコル内のさまざまなエンティティに割り当てられる場合があります。各エンティティは、送信または受信するデータに正しいラベルを使用します。プロトコルがIDを割り当てる2番目の方法は、命名システム（つまり、DNSまたはX.509名）に基づいて名前を使用することです。"
    },
    {
      "indent": 9,
      "text": "We define an algorithm parameter, \"PartyU identity\", that can be used to carry identity information in the message. However, identity information is often known as part of the protocol and can thus be inferred rather than made explicit. If identity information is carried in the message, applications SHOULD have a way of validating the supplied identity information. The identity information does not need to be specified and is set to nil in that case.",
      "ja": "メッセージ内のアイデンティティ情報を伝達するために使用できるアルゴリズムパラメーター「partyu ID」を定義します。ただし、アイデンティティ情報はしばしばプロトコルの一部として知られているため、明示的にするのではなく推測できます。ID情報がメッセージに掲載されている場合、アプリケーションには提供されたID情報を検証する方法が必要です。ID情報を指定する必要はなく、その場合はゼロに設定されています。"
    },
    {
      "indent": 6,
      "text": "nonce: This contains a nonce value. The nonce can be either implicit from the protocol or carried as a value in the unprotected header bucket.",
      "ja": "NONCE：これには、nonce値が含まれています。NonCeは、プロトコルから暗黙的であるか、保護されていないヘッダーバケットの値として伝えることができます。"
    },
    {
      "indent": 9,
      "text": "We define an algorithm parameter, \"PartyU nonce\", that can be used to carry this value in the message; however, the nonce value could be determined by the application and its value obtained in a different manner.",
      "ja": "この値をメッセージに伝えるために使用できるアルゴリズムパラメーター「partyu nonce」を定義します。ただし、NonCE値は、アプリケーションとその値が異なる方法で取得したことによって決定できます。"
    },
    {
      "indent": 9,
      "text": "This option does not need to be specified; if not needed, it is set to nil.",
      "ja": "このオプションを指定する必要はありません。必要でない場合は、ゼロに設定されています。"
    },
    {
      "indent": 6,
      "text": "other: This contains other information that is defined by the protocol. This option does not need to be specified; if not needed, it is set to nil.",
      "ja": "その他：これには、プロトコルによって定義される他の情報が含まれています。このオプションを指定する必要はありません。必要でない場合は、ゼロに設定されています。"
    },
    {
      "indent": 3,
      "text": "PartyVInfo: This field holds information about PartyV. The content of the structure is the same as for the PartyUInfo but for PartyV.",
      "ja": "PARTYVINFO：このフィールドには、partyvに関する情報が保持されています。構造の内容は、partyuinfoの場合と同じですが、partyvの場合と同じです。"
    },
    {
      "indent": 3,
      "text": "SuppPubInfo: This field contains public information that is mutually known to both parties, and is encoded as a CBOR array.",
      "ja": "Suppbubinfo：このフィールドには、両当事者に相互に知られており、CBORアレイとしてエンコードされている公開情報が含まれています。"
    },
    {
      "indent": 6,
      "text": "keyDataLength: This is set to the number of bits of the desired output value. This practice means if algorithm A can use two different key lengths, the key derived for the longer key size will not contain the key for the shorter key size as a prefix.",
      "ja": "KeyDatalength：これは、目的の出力値のビット数に設定されます。このプラクティスは、アルゴリズムAが2つの異なるキー長を使用できる場合、キーサイズの長いキーがプレフィックスとして短いキーサイズのキーを含めないことを意味します。"
    },
    {
      "indent": 6,
      "text": "protected: This field contains the protected parameter field. If there are no elements in the \"protected\" field, then use a zero-length bstr.",
      "ja": "保護：このフィールドには、保護されたパラメーターフィールドが含まれています。「保護された」フィールドに要素がない場合は、ゼロ長BSTRを使用します。"
    },
    {
      "indent": 6,
      "text": "other: This field is for free-form data defined by the application. For example, an application could define two different byte strings to be placed here to generate different keys for a data stream versus a control stream. This field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "その他：このフィールドは、アプリケーションによって定義された自由形式のデータ用です。たとえば、アプリケーションは、ここに配置する2つの異なるバイト文字列を定義して、データストリームとコントロールストリームの異なるキーを生成することができます。このフィールドはオプションであり、アプリケーションがこの情報の構造を定義している場合にのみ存在します。これを定義するアプリケーションは、CBORを使用してデータをエンコードして、タイプと長さが正しく含まれるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "SuppPrivInfo: This field contains private information that is mutually known private information. An example of this information would be a pre-existing shared secret. (This could, for example, be used in combination with an ECDH key agreement to provide a secondary proof of identity.) The field is optional and will only be present if the application defines a structure for this information. Applications that define this SHOULD use CBOR to encode the data so that types and lengths are correctly included.",
      "ja": "suppprivinfo：このフィールドには、相互に知られている個人情報である個人情報が含まれています。この情報の例は、既存の共有秘密です。（これは、たとえば、ECDHの重要な合意と組み合わせて使用することができます。二次的なアイデンティティの証明を提供します。）フィールドはオプションであり、アプリケーションがこの情報の構造を定義している場合にのみ存在します。これを定義するアプリケーションは、CBORを使用してデータをエンコードして、タイプと長さが正しく含まれるようにする必要があります。"
    },
    {
      "indent": 3,
      "text": "The following CDDL fragment corresponds to the text above.",
      "ja": "次のCDDLフラグメントは、上記のテキストに対応しています。"
    },
    {
      "indent": 3,
      "text": "PartyInfo = (\n    identity : bstr / nil,\n    nonce : bstr / int / nil,\n    other : bstr / nil\n)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "COSE_KDF_Context = [\n    AlgorithmID : int / tstr,\n    PartyUInfo : [ PartyInfo ],\n    PartyVInfo : [ PartyInfo ],\n    SuppPubInfo : [\n        keyDataLength : uint,\n        protected : empty_or_serialized_map,\n        ? other : bstr\n    ],\n    ? SuppPrivInfo : bstr\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "6. Content Key Distribution Methods",
      "section_title": true,
      "ja": "6. コンテンツキーディストリビューション方法"
    },
    {
      "indent": 3,
      "text": "Section 8.5 of [RFC9052] contains a generic description of content key distribution methods. This document defines the identifiers and usage for a number of content key distribution methods.",
      "ja": "[RFC9052]のセクション8.5には、コンテンツの重要な分布方法の一般的な説明が含まれています。このドキュメントでは、多くのコンテンツキーディストリビューション方法の識別子と使用法を定義します。"
    },
    {
      "indent": 0,
      "text": "6.1. Direct Encryption",
      "section_title": true,
      "ja": "6.1. 直接暗号化"
    },
    {
      "indent": 3,
      "text": "A direct encryption algorithm is defined in Section 8.5.1 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "直接暗号化アルゴリズムは、[RFC9052]のセクション8.5.1で定義されています。COSE_RECIPIENT構造を入力する方法に関する情報が詳細に説明されています。"
    },
    {
      "indent": 0,
      "text": "6.1.1. Direct Key",
      "section_title": true,
      "ja": "6.1.1. 直接キー"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm is the simplest; the identified key is directly used as the key for the next layer down in the message. There are no algorithm parameters defined for this algorithm. The algorithm identifier value is assigned in Table 11.",
      "ja": "このレシピエントアルゴリズムは最も単純です。識別されたキーは、メッセージの次のレイヤーのキーとして直接使用されます。このアルゴリズムに対して定義されたアルゴリズムパラメーターはありません。アルゴリズム識別子値は表11に割り当てられています。"
    },
    {
      "indent": 3,
      "text": "When this algorithm is used, the \"protected\" field MUST be zero length. The key type MUST be \"Symmetric\".",
      "ja": "このアルゴリズムを使用する場合、「保護された」フィールドはゼロの長さでなければなりません。キータイプは「対称」でなければなりません。"
    },
    {
      "indent": 6,
      "text": "+========+=======+============================================+\n| Name   | Value | Description                                |\n+========+=======+============================================+\n| direct |   -6  | Direct use of content encryption key (CEK) |\n+--------+-------+--------------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Table 11: Direct Key",
      "ja": "表11：直接キー"
    },
    {
      "indent": 0,
      "text": "6.1.1.1. Security Considerations for Direct Key",
      "section_title": true,
      "ja": "6.1.1.1. Direct Keyのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "This recipient algorithm has several potential problems that need to be considered:",
      "ja": "このレシピエントアルゴリズムには、考慮する必要があるいくつかの潜在的な問題があります。"
    },
    {
      "indent": 3,
      "text": "* These keys need to have some method of being regularly updated over time. All of the content encryption algorithms specified in this document have limits on how many times a key can be used without significant loss of security.",
      "ja": "* これらのキーは、時間の経過とともに定期的に更新される方法が必要です。このドキュメントで指定されているすべてのコンテンツ暗号化アルゴリズムには、セキュリティの大幅な損失なしにキーを使用できる回数に制限があります。"
    },
    {
      "indent": 3,
      "text": "* These keys need to be dedicated to a single algorithm. There have been a number of attacks developed over time when a single key is used for multiple different algorithms. One example of this is the use of a single key for both the CBC encryption mode and the CBC-MAC authentication mode.",
      "ja": "* これらのキーは、単一のアルゴリズムに専念する必要があります。複数の異なるアルゴリズムに単一のキーが使用される場合、時間の経過とともに開発された多くの攻撃がありました。この1つの例は、CBC暗号化モードとCBC-MAC認証モードの両方に単一のキーを使用することです。"
    },
    {
      "indent": 3,
      "text": "* Breaking one message means all messages are broken. If an adversary succeeds in determining the key for a single message, then the key for all messages is also determined.",
      "ja": "* 1つのメッセージを破ることは、すべてのメッセージが壊れることを意味します。敵が単一のメッセージのキーを決定することに成功した場合、すべてのメッセージのキーも決定されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Direct Key with KDF",
      "section_title": true,
      "ja": "6.1.2. KDFを使用した直接キー"
    },
    {
      "indent": 3,
      "text": "These recipient algorithms take a common shared secret between the two parties and apply the HKDF function (Section 5.1), using the context structure defined in Section 5.2 to transform the shared secret into the CEK. The \"protected\" field can be of nonzero length. Either the \"salt\" parameter for HKDF (Table 9) or the \"PartyU nonce\" parameter for the context structure (Table 10) MUST be present (both can be present if desired). The value in the \"salt\"/\"nonce\" parameter can be generated either randomly or deterministically. The requirement is that it be a unique value for the shared secret in question.",
      "ja": "これらのレシピエントアルゴリズムは、2つの当事者間で共通の共有秘密を取り、セクション5.2で定義されたコンテキスト構造を使用して共有秘密をCEKに変換するHKDF関数（セクション5.1）を適用します。「保護された」フィールドは、ゼロ以外の長さになります。HKDFの「塩」パラメーター（表9）またはコンテキスト構造の「partyu nonce」パラメーター（表10）が存在する必要があります（両方とも必要に応じて存在することができます）。「salt」/「nonce」パラメーターの値は、ランダムにまたは決定論的に生成できます。要件は、問題の共有秘密にとってユニークな価値であることです。"
    },
    {
      "indent": 3,
      "text": "If the salt/nonce value is generated randomly, then it is suggested that the length of the random value be the same length as the output of the hash function underlying HKDF. While there is no way to guarantee that it will be unique, there is a high probability that it will be unique. If the salt/nonce value is generated deterministically, it can be guaranteed to be unique, and thus there is no length requirement.",
      "ja": "SALT/NONCE値がランダムに生成された場合、ランダム値の長さはHKDFの根底にあるハッシュ関数の出力と同じ長さであることが示唆されています。それがユニークになることを保証する方法はありませんが、それがユニークになる可能性が高いでしょう。SALT/NONCE値が決定論的に生成された場合、それは一意であることが保証される可能性があるため、長さの要件はありません。"
    },
    {
      "indent": 3,
      "text": "A new IV must be used for each message if the same key is used. The IV can be modified in a predictable manner, a random manner, or an unpredictable manner (e.g., encrypting a counter).",
      "ja": "同じキーが使用されている場合、各メッセージに新しいIVを使用する必要があります。IVは、予測可能な方法、ランダムな方法、または予測不可能な方法（例：カウンターの暗号化）で変更できます。"
    },
    {
      "indent": 3,
      "text": "The IV used for a key can also be generated using the same HKDF functionality used to generate the key. If HKDF is used for generating the IV, the algorithm identifier is set to 34 (\"IV-GENERATION\").",
      "ja": "キーに使用されるIVは、キーを生成するために使用される同じHKDF機能を使用して生成することもできます。HKDFがIVの生成に使用される場合、アルゴリズム識別子は34（「IV世代」）に設定されます。"
    },
    {
      "indent": 3,
      "text": "The set of algorithms defined in this document can be found in Table 12.",
      "ja": "このドキュメントで定義されているアルゴリズムのセットは、表12にあります。"
    },
    {
      "indent": 3,
      "text": "+=====================+=======+==============+=====================+\n| Name                | Value | KDF          | Description         |\n+=====================+=======+==============+=====================+\n| direct+HKDF-SHA-256 |  -10  | HKDF SHA-256 | Shared secret w/    |\n|                     |       |              | HKDF and SHA-256    |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-SHA-512 |  -11  | HKDF SHA-512 | Shared secret w/    |\n|                     |       |              | HKDF and SHA-512    |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-AES-128 |  -12  | HKDF AES-    | Shared secret w/    |\n|                     |       | MAC-128      | AES-MAC 128-bit key |\n+---------------------+-------+--------------+---------------------+\n| direct+HKDF-AES-256 |  -13  | HKDF AES-    | Shared secret w/    |\n|                     |       | MAC-256      | AES-MAC 256-bit key |\n+---------------------+-------+--------------+---------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 12: Direct Key with KDF",
      "ja": "表12：KDFを使用した直接キー"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\".",
      "ja": "* 「key_ops」フィールドが存在する場合、「キー」または「派生ビット」を含める必要があります。"
    },
    {
      "indent": 0,
      "text": "6.1.2.1. Security Considerations for Direct Key with KDF",
      "section_title": true,
      "ja": "6.1.2.1. KDFを使用したDirect Keyのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method of being regularly updated over time. The shared secret forms the basis of trust. Although not used directly, it should still be subject to scheduled rotation.",
      "ja": "共有された秘密には、時間とともに定期的に更新される方法が必要です。共有された秘密は、信頼の基礎を形成します。直接使用していませんが、スケジュールされた回転の対象となるはずです。"
    },
    {
      "indent": 3,
      "text": "These methods do not provide for perfect forward secrecy, as the same shared secret is used for all of the keys generated; however, if the key for any single message is discovered, only the message or series of messages using that derived key are compromised. A new key derivation step will generate a new key that requires the same amount of work to get the key.",
      "ja": "これらの方法は、生成されたすべてのキーに同じ共有秘密が使用されているため、完全な前方秘密を提供するものではありません。ただし、単一のメッセージのキーが発見された場合、その派生キーを使用したメッセージまたは一連のメッセージのみが損なわれます。新しいキー派生ステップは、キーを取得するために同じ量の作業を必要とする新しいキーを生成します。"
    },
    {
      "indent": 0,
      "text": "6.2. Key Wrap",
      "section_title": true,
      "ja": "6.2. キーラップ"
    },
    {
      "indent": 3,
      "text": "Key wrap is defined in Section 8.5.2 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "キーラップは、[RFC9052]のセクション8.5.2で定義されています。COSE_RECIPIENT構造を入力する方法に関する情報が詳細に説明されています。"
    },
    {
      "indent": 0,
      "text": "6.2.1. AES Key Wrap",
      "section_title": true,
      "ja": "6.2.1. AESキーラップ"
    },
    {
      "indent": 3,
      "text": "The AES Key Wrap algorithm is defined in [RFC3394]. This algorithm uses an AES key to wrap a value that is a multiple of 64 bits. As such, it can be used to wrap a key for any of the content encryption algorithms defined in this document. The algorithm requires a single fixed parameter, the initial value. This is fixed to the value specified in Section 2.2.3.1 of [RFC3394]. There are no public key parameters that vary on a per-invocation basis. The protected header bucket MUST be empty.",
      "ja": "AESキーラップアルゴリズムは[RFC3394]で定義されています。このアルゴリズムは、AESキーを使用して、64ビットの倍数の値をラップします。そのため、このドキュメントで定義されているコンテンツ暗号化アルゴリズムのキーをラップするために使用できます。アルゴリズムには、単一の固定パラメーター、初期値が必要です。これは、[RFC3394]のセクション2.2.3.1で指定された値に固定されています。侵入ごとに異なる公開キーパラメーターはありません。保護されたヘッダーバケットは空でなければなりません。"
    },
    {
      "indent": 3,
      "text": "Keys may be obtained from either a key structure or a recipient structure. Implementations that are encrypting or decrypting MUST validate that the key type, key length, and algorithm are correct and appropriate for the entities involved.",
      "ja": "キーは、キー構造または受信者構造のいずれかから取得できます。暗号化または復号化されている実装は、キータイプ、キーの長さ、およびアルゴリズムが正しく、関係するエンティティに適切であることを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"Symmetric\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「対称」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the AES Key Wrap algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されているAESキーラップアルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"encrypt\" or \"wrap key\" when encrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合は、暗号化時に「暗号化」または「ラップキー」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"decrypt\" or \"unwrap key\" when decrypting.",
      "ja": "* 「key_ops」フィールドが存在する場合、復号化時に「decrypt」または「wrap key」を含める必要があります。"
    },
    {
      "indent": 8,
      "text": "+========+=======+==========+=============================+\n| Name   | Value | Key Size | Description                 |\n+========+=======+==========+=============================+\n| A128KW |   -3  |   128    | AES Key Wrap w/ 128-bit key |\n+--------+-------+----------+-----------------------------+\n| A192KW |   -4  |   192    | AES Key Wrap w/ 192-bit key |\n+--------+-------+----------+-----------------------------+\n| A256KW |   -5  |   256    | AES Key Wrap w/ 256-bit key |\n+--------+-------+----------+-----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Table 13: AES Key Wrap Algorithm Values",
      "ja": "表13：AESキーラップアルゴリズム値"
    },
    {
      "indent": 0,
      "text": "6.2.1.1. Security Considerations for AES Key Wrap",
      "section_title": true,
      "ja": "6.2.1.1. AESキーラップのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "The shared secret needs to have some method of being regularly updated over time. The shared secret is the basis of trust.",
      "ja": "共有された秘密には、時間とともに定期的に更新される方法が必要です。共有された秘密は信頼の基礎です。"
    },
    {
      "indent": 0,
      "text": "6.3. Direct Key Agreement",
      "section_title": true,
      "ja": "6.3. 直接キー契約"
    },
    {
      "indent": 3,
      "text": "Direct Key Agreement is defined in Section 8.5.4 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "直接キー契約は、[RFC9052]のセクション8.5.4で定義されています。COSE_RECIPIENT構造を入力する方法に関する情報が詳細に説明されています。"
    },
    {
      "indent": 0,
      "text": "6.3.1. Direct ECDH",
      "section_title": true,
      "ja": "6.3.1. 直接ECDH"
    },
    {
      "indent": 3,
      "text": "The mathematics for ECDH can be found in [RFC6090]. In this document, the algorithm is extended to be used with the two curves defined in [RFC7748].",
      "ja": "ECDHの数学は[RFC6090]に記載されています。このドキュメントでは、アルゴリズムは[RFC7748]で定義された2つの曲線で使用されるように拡張されています。"
    },
    {
      "indent": 3,
      "text": "ECDH is parameterized by the following:",
      "ja": "ECDHは以下によってパラメーター化されます。"
    },
    {
      "indent": 3,
      "text": "Curve Type/Curve: The curve selected controls not only the size of the shared secret, but the mathematics for computing the shared secret. The curve selected also controls how a point in the curve is represented and what happens for the identity points on the curve. In this specification, we allow for a number of different curves to be used. A set of curves is defined in Table 18.",
      "ja": "曲線タイプ/曲線：選択された曲線は、共有された秘密のサイズだけでなく、共有された秘密を計算するための数学を制御します。選択された曲線は、曲線内のポイントがどのように表現されるか、および曲線上のIDポイントで何が起こるかを制御します。この仕様では、さまざまな曲線を使用できます。曲線のセットを表18に定義しています。"
    },
    {
      "indent": 6,
      "text": "The math used to obtain the computed secret is based on the curve selected and not on the ECDH algorithm. For this reason, a new algorithm does not need to be defined for each of the curves.",
      "ja": "計算された秘密を取得するために使用される数学は、ECDHアルゴリズムではなく選択された曲線に基づいています。このため、各曲線について新しいアルゴリズムを定義する必要はありません。"
    },
    {
      "indent": 3,
      "text": "Computed Secret to Shared Secret: Once the computed secret is known, the resulting value needs to be converted to a byte string to run the KDF. The x-coordinate is used for all of the curves defined in this document. For curves X25519 and X448, the resulting value is used directly, as it is a byte string of a known length. For the P-256, P-384, and P-521 curves, the x-coordinate is run through the Integer-to-Octet-String primitive (I2OSP) function defined in [RFC8017], using the same computation for n as is defined in Section 2.1.",
      "ja": "共有秘密の計算秘密：計算された秘密がわかったら、結果の値をバイト文字列に変換してKDFを実行する必要があります。X座標は、このドキュメントで定義されているすべての曲線に使用されます。曲線X25519およびX448の場合、既知の長さのバイト文字列であるため、結果の値は直接使用されます。P-256、P-384、およびP-521曲線の場合、X座標は[RFC8017]で定義された整数からオクセットの原始（I2OSP）関数を介して実行されます。セクション2.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "Ephemeral-Static or Static-Static: The key agreement process may be done using either a static or an ephemeral key for the sender's side. When using ephemeral keys, the sender MUST generate a new ephemeral key for every key agreement operation. The ephemeral key is placed in the \"ephemeral key\" parameter and MUST be present for all algorithm identifiers that use ephemeral keys. When using static keys, the sender MUST either generate a new random value or create a unique value for use as a KDF input. For the KDFs used, this means that either the \"salt\" parameter for HKDF (Table 9) or the \"PartyU nonce\" parameter for the context structure (Table 10) MUST be present (both can be present if desired). The value in the parameter MUST be unique for the pair of keys being used. It is acceptable to use a global counter that is incremented for every Static-Static operation and use the resulting value. Care must be taken that the counter is saved to permanent storage in a way that avoids reuse of that counter value. When using static keys, the static key should be identified to the recipient. The static key can be identified by providing either the key (\"static key\") or a key identifier for the static key (\"static key id\"). Both of these header parameters are defined in Table 15.",
      "ja": "はかない静的または静的な静的：キー契約プロセスは、送信者側の静的またははかないキーのいずれかを使用して行うことができます。短命キーを使用する場合、送信者は、キー契約操作ごとに新しい一時的なキーを生成する必要があります。短命キーは「はかないキー」パラメーターに配置され、一時的なキーを使用するすべてのアルゴリズム識別子に存在する必要があります。静的キーを使用する場合、送信者は新しいランダム値を生成するか、KDF入力として使用するための一意の値を作成する必要があります。使用するKDFSの場合、これは、HKDF（表9）の「塩」パラメーターまたはコンテキスト構造の「partyu nonce」パラメーター（表10）のいずれかが存在する必要があることを意味します（両方とも必要に応じて存在することができます）。パラメーターの値は、使用されているキーのペアにとって一意でなければなりません。静的静的操作ごとに増加するグローバルカウンターを使用し、結果の値を使用することは許容されます。そのカウンター価値の再利用を避ける方法で、カウンターが恒久的なストレージに保存されるように注意する必要があります。静的キーを使用する場合、静的キーを受信者に識別する必要があります。静的キーは、キー（「静的キー」）または静的キー（「静的キーID」）のキー識別子を提供することで識別できます。これらのヘッダーパラメーターは両方とも表15に定義されています。"
    },
    {
      "indent": 3,
      "text": "Key Derivation Algorithm: The result of an ECDH key agreement process does not provide a uniformly random secret. As such, it needs to be run through a KDF in order to produce a usable key. Processing the secret through a KDF also allows for the introduction of context material: how the key is going to be used and one-time material for Static-Static key agreement. All of the algorithms defined in this document use one of the HKDF algorithms defined in Section 5.1 with the context structure defined in Section 5.2.",
      "ja": "キー派生アルゴリズム：ECDHキー契約プロセスの結果は、均一にランダムな秘密を提供しません。そのため、使用可能なキーを作成するには、KDFを介して実行する必要があります。KDFを介して秘密を処理することで、コンテキスト資料：キーをどのように使用するか、静的静的キー契約のために1回限りの資料を導入することもできます。このドキュメントで定義されているすべてのアルゴリズムは、セクション5.1で定義されたHKDFアルゴリズムの1つを使用して、セクション5.2で定義されたコンテキスト構造を使用します。"
    },
    {
      "indent": 3,
      "text": "Key Wrap Algorithm: No key wrap algorithm is used. This is represented in Table 14 as \"none\". The key size for the context structure is the content layer encryption algorithm size.",
      "ja": "キーラップアルゴリズム：キーラップアルゴリズムは使用されていません。これは、表14に「なし」として表されています。コンテキスト構造の重要なサイズは、コンテンツレイヤー暗号化アルゴリズムサイズです。"
    },
    {
      "indent": 3,
      "text": "COSE does not have an Ephemeral-Ephemeral version defined. The reason for this is that COSE is not an online protocol by itself and thus does not have a method of establishing ephemeral secrets on both sides. The expectation is that a protocol would establish the secrets for both sides, and then they would be used as Static-Static for the purposes of COSE, or that the protocol would generate a shared secret and a direct encryption would be used.",
      "ja": "COSEには、一時的な著しいバージョンが定義されていません。この理由は、COSEはそれ自体ではオンラインプロトコルではないため、両側にはかない秘密を確立する方法がないためです。期待は、プロトコルが双方の秘密を確立し、それらはCOSEの目的のために静的状態として使用されるか、プロトコルが共有秘密を生成し、直接暗号化が使用されることです。"
    },
    {
      "indent": 3,
      "text": "The set of direct ECDH algorithms defined in this document is found in Table 14.",
      "ja": "このドキュメントで定義されている直接ECDHアルゴリズムのセットを表14に示します。"
    },
    {
      "indent": 3,
      "text": "+==========+=======+=========+==================+=====+=============+\n|Name      | Value | KDF     | Ephemeral-Static |Key  |Description  |\n|          |       |         |                  |Wrap |             |\n+==========+=======+=========+==================+=====+=============+\n|ECDH-ES + | -25   | HKDF -- | yes              |none |ECDH ES w/   |\n|HKDF-256  |       | SHA-256 |                  |     |HKDF --      |\n|          |       |         |                  |     |generate key |\n|          |       |         |                  |     |directly     |\n+----------+-------+---------+------------------+-----+-------------+\n|ECDH-ES + | -26   | HKDF -- | yes              |none |ECDH ES w/   |\n|HKDF-512  |       | SHA-512 |                  |     |HKDF --      |\n|          |       |         |                  |     |generate key |\n|          |       |         |                  |     |directly     |\n+----------+-------+---------+------------------+-----+-------------+\n|ECDH-SS + | -27   | HKDF -- | no               |none |ECDH SS w/   |\n|HKDF-256  |       | SHA-256 |                  |     |HKDF --      |\n|          |       |         |                  |     |generate key |\n|          |       |         |                  |     |directly     |\n+----------+-------+---------+------------------+-----+-------------+\n|ECDH-SS + | -28   | HKDF -- | no               |none |ECDH SS w/   |\n|HKDF-512  |       | SHA-512 |                  |     |HKDF --      |\n|          |       |         |                  |     |generate key |\n|          |       |         |                  |     |directly     |\n+----------+-------+---------+------------------+-----+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Table 14: ECDH Algorithm Values",
      "ja": "表14：ECDHアルゴリズム値"
    },
    {
      "indent": 4,
      "text": "+===========+=======+==========+===================+=============+\n| Name      | Label | Type     | Algorithm         | Description |\n+===========+=======+==========+===================+=============+\n| ephemeral | -1    | COSE_Key | ECDH-ES+HKDF-256, | Ephemeral   |\n| key       |       |          | ECDH-ES+HKDF-512, | public key  |\n|           |       |          | ECDH-ES+A128KW,   | for the     |\n|           |       |          | ECDH-ES+A192KW,   | sender      |\n|           |       |          | ECDH-ES+A256KW    |             |\n+-----------+-------+----------+-------------------+-------------+\n| static    | -2    | COSE_Key | ECDH-SS+HKDF-256, | Static      |\n| key       |       |          | ECDH-SS+HKDF-512, | public key  |\n|           |       |          | ECDH-SS+A128KW,   | for the     |\n|           |       |          | ECDH-SS+A192KW,   | sender      |\n|           |       |          | ECDH-SS+A256KW    |             |\n+-----------+-------+----------+-------------------+-------------+\n| static    | -3    | bstr     | ECDH-SS+HKDF-256, | Static      |\n| key id    |       |          | ECDH-SS+HKDF-512, | public key  |\n|           |       |          | ECDH-SS+A128KW,   | identifier  |\n|           |       |          | ECDH-SS+A192KW,   | for the     |\n|           |       |          | ECDH-SS+A256KW    | sender      |\n+-----------+-------+----------+-------------------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 19,
      "text": "Table 15: ECDH Algorithm Parameters",
      "ja": "表15：ECDHアルゴリズムパラメーター"
    },
    {
      "indent": 3,
      "text": "This document defines these algorithms to be used with the curves P-256, P-384, P-521, X25519, and X448. Implementations MUST verify that the key type and curve are correct. Different curves are restricted to different key types. Implementations MUST verify that the curve and algorithm are appropriate for the entities involved.",
      "ja": "このドキュメントでは、曲線P-256、P-384、P-521、X25519、およびX448で使用するこれらのアルゴリズムを定義しています。実装は、キータイプと曲線が正しいことを確認する必要があります。さまざまな曲線が異なるキータイプに制限されています。実装では、曲線とアルゴリズムが関係するエンティティに適していることを確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\" or \"OKP\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「ec2」または「okp」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the key agreement algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されている主要な合意アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\" for the private key.",
      "ja": "* 「key_ops」フィールドが存在する場合、秘密鍵の「キー」または「派生ビット」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST be empty for the public key.",
      "ja": "* 「key_ops」フィールドが存在する場合、公開キーの場合は空でなければなりません。"
    },
    {
      "indent": 0,
      "text": "6.3.1.1. Security Considerations for ECDH",
      "section_title": true,
      "ja": "6.3.1.1. ECDHのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "There is a method of checking that points provided from external entities are valid. For the \"EC2\" key format, this can be done by checking that the x and y values form a point on the curve. For the \"OKP\" format, there is no simple way to perform point validation.",
      "ja": "外部エンティティから提供されるポイントが有効であることを確認する方法があります。「EC2」キー形式の場合、これはxとyの値が曲線上のポイントを形成することを確認することで実行できます。「OKP」形式の場合、ポイント検証を実行する簡単な方法はありません。"
    },
    {
      "indent": 3,
      "text": "Consideration was given to requiring that the public keys of both entities be provided as part of the key derivation process (as recommended in Section 6.1 of [RFC7748]). This was not done, because COSE is used in a store-and-forward format rather than in online key exchange. In order for this to be a problem, either the receiver public key has to be chosen maliciously or the sender has to be malicious. In either case, all security evaporates anyway.",
      "ja": "両方のエンティティのパブリックキーがキー派生プロセスの一部として提供されることを要求することを考慮しました（[RFC7748]のセクション6.1で推奨されているように）。COSEはオンラインキー交換ではなく、店舗とフォワード形式で使用されるため、これは行われませんでした。これが問題になるためには、受信者の公開キーを悪意を持って選択する必要があるか、送信者が悪意を持っている必要があります。どちらの場合でも、とにかくすべてのセキュリティが蒸発します。"
    },
    {
      "indent": 3,
      "text": "A proof of possession of the private key associated with the public key is recommended when a key is moved from untrusted to trusted (either by the end user or by the entity that is responsible for making trust statements on keys).",
      "ja": "公開鍵に関連付けられた秘密鍵の所有の証明は、キーが信頼されていないものから信頼できるものに移動するときに推奨されます（エンドユーザーまたはキーに関する信頼声明の作成を担当するエンティティによって）。"
    },
    {
      "indent": 0,
      "text": "6.4. Key Agreement with Key Wrap",
      "section_title": true,
      "ja": "6.4. キーラップとのキー契約"
    },
    {
      "indent": 3,
      "text": "Key Agreement with Key Wrap is defined in Section 8.5.5 of [RFC9052]. Information about how to fill in the COSE_Recipient structure is detailed there.",
      "ja": "キーラップとのキー一致は、[RFC9052]のセクション8.5.5で定義されています。COSE_RECIPIENT構造を入力する方法に関する情報が詳細に説明されています。"
    },
    {
      "indent": 0,
      "text": "6.4.1. ECDH with Key Wrap",
      "section_title": true,
      "ja": "6.4.1. キーラップ付きECDH"
    },
    {
      "indent": 3,
      "text": "These algorithms are defined in Table 16.",
      "ja": "これらのアルゴリズムは、表16に定義されています。"
    },
    {
      "indent": 3,
      "text": "ECDH with Key Agreement is parameterized by the same header parameters as for ECDH; see Section 6.3.1, with the following modifications:",
      "ja": "重要な一致を持つECDHは、ECDHと同じヘッダーパラメーターによってパラメーター化されます。次の変更を含むセクション6.3.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Key Wrap Algorithm: Any of the key wrap algorithms defined in Section 6.2 are supported. The size of the key used for the key wrap algorithm is fed into the KDF. The set of identifiers is found in Table 16.",
      "ja": "キーラップアルゴリズム：セクション6.2で定義されているキーラップアルゴリズムのいずれかがサポートされています。キーラップアルゴリズムに使用されるキーのサイズは、KDFに供給されます。識別子のセットを表16に示します。"
    },
    {
      "indent": 3,
      "text": "+=========+=====+=========+==================+========+=============+\n|Name     |Value| KDF     | Ephemeral-Static |Key Wrap|Description  |\n+=========+=====+=========+==================+========+=============+\n|ECDH-ES +|-29  | HKDF -- | yes              |A128KW  |ECDH ES w/   |\n|A128KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |128-bit key  |\n+---------+-----+---------+------------------+--------+-------------+\n|ECDH-ES +|-30  | HKDF -- | yes              |A192KW  |ECDH ES w/   |\n|A192KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |192-bit key  |\n+---------+-----+---------+------------------+--------+-------------+\n|ECDH-ES +|-31  | HKDF -- | yes              |A256KW  |ECDH ES w/   |\n|A256KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |256-bit key  |\n+---------+-----+---------+------------------+--------+-------------+\n|ECDH-SS +|-32  | HKDF -- | no               |A128KW  |ECDH SS w/   |\n|A128KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |128-bit key  |\n+---------+-----+---------+------------------+--------+-------------+\n|ECDH-SS +|-33  | HKDF -- | no               |A192KW  |ECDH SS w/   |\n|A192KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |192-bit key  |\n+---------+-----+---------+------------------+--------+-------------+\n|ECDH-SS +|-34  | HKDF -- | no               |A256KW  |ECDH SS w/   |\n|A256KW   |     | SHA-256 |                  |        |HKDF and AES |\n|         |     |         |                  |        |Key Wrap w/  |\n|         |     |         |                  |        |256-bit key  |\n+---------+-----+---------+------------------+--------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 15,
      "text": "Table 16: ECDH Algorithm Values with Key Wrap",
      "ja": "表16：キーラップ付きECDHアルゴリズム値"
    },
    {
      "indent": 3,
      "text": "When using a COSE key for this algorithm, the following checks are made:",
      "ja": "このアルゴリズムにCOSEキーを使用する場合、次のチェックが行われます。"
    },
    {
      "indent": 3,
      "text": "* The \"kty\" field MUST be present, and it MUST be \"EC2\" or \"OKP\".",
      "ja": "* 「kty」フィールドが存在する必要があり、「ec2」または「okp」でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* If the \"alg\" field is present, it MUST match the key agreement algorithm being used.",
      "ja": "* 「アルグ」フィールドが存在する場合、使用されている主要な合意アルゴリズムと一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST include \"derive key\" or \"derive bits\" for the private key.",
      "ja": "* 「key_ops」フィールドが存在する場合、秘密鍵の「キー」または「派生ビット」を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* If the \"key_ops\" field is present, it MUST be empty for the public key.",
      "ja": "* 「key_ops」フィールドが存在する場合、公開キーの場合は空でなければなりません。"
    },
    {
      "indent": 0,
      "text": "7. Key Object Parameters",
      "section_title": true,
      "ja": "7. キーオブジェクトパラメーター"
    },
    {
      "indent": 3,
      "text": "The COSE_Key object defines a way to hold a single key object. It is still required that the members of individual key types be defined. This section of the document is where we define an initial set of members for specific key types.",
      "ja": "cose_keyオブジェクトは、単一のキーオブジェクトを保持する方法を定義します。個々のキータイプのメンバーを定義する必要があります。ドキュメントのこのセクションは、特定のキータイプのメンバーの初期セットを定義する場所です。"
    },
    {
      "indent": 3,
      "text": "For each of the key types, we define both public and private members. The public members are what is transmitted to others for their usage. Private members allow individuals to archive keys. However, there are some circumstances in which private keys may be distributed to entities in a protocol. Examples include: entities that have poor random number generation, centralized key creation for multicast-type operations, and protocols in which a shared secret is used as a bearer token for authorization purposes.",
      "ja": "主要なタイプのそれぞれについて、パブリックメンバーとプライベートメンバーの両方を定義します。パブリックメンバーは、その使用のために他の人に送信されるものです。プライベートメンバーは、個人がキーをアーカイブできるようにします。ただし、プロトコル内のプライベートキーをエンティティに配布できる状況がいくつかあります。例には、乱数が不十分なエンティティ、マルチキャストタイプの操作のための集中化された主要な作成、および共有秘密が承認目的のためにベアラートークンとして使用されるプロトコルが含まれます。"
    },
    {
      "indent": 3,
      "text": "Key types are identified by the \"kty\" member of the COSE_Key object. In this document, we define four values for the member:",
      "ja": "キータイプは、COSE_KEYオブジェクトの「KTY」メンバーによって識別されます。このドキュメントでは、メンバーの4つの値を定義します。"
    },
    {
      "indent": 13,
      "text": "+===========+=======+==========================+\n| Name      | Value | Description              |\n+===========+=======+==========================+\n| OKP       |   1   | Octet Key Pair           |\n+-----------+-------+--------------------------+\n| EC2       |   2   | Elliptic Curve Keys w/   |\n|           |       | x- and y-coordinate pair |\n+-----------+-------+--------------------------+\n| Symmetric |   4   | Symmetric Keys           |\n+-----------+-------+--------------------------+\n| Reserved  |   0   | This value is reserved   |\n+-----------+-------+--------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 17: Key Type Values",
      "ja": "表17：キータイプの値"
    },
    {
      "indent": 0,
      "text": "7.1. Elliptic Curve Keys",
      "section_title": true,
      "ja": "7.1. 楕円曲線キー"
    },
    {
      "indent": 3,
      "text": "Two different key structures are defined for elliptic curve keys. One version uses both an x-coordinate and a y-coordinate, potentially with point compression (\"EC2\"). This is the conventional elliptic curve (EC) point representation that is used in [RFC5480]. The other version uses only the x-coordinate, as the y-coordinate is either to be recomputed or not needed for the key agreement operation (\"OKP\").",
      "ja": "楕円曲線キーに対して2つの異なるキー構造が定義されています。1つのバージョンは、X座標とY座標の両方を使用し、潜在的にポイント圧縮（ \"EC2\"）を使用します。これは、[RFC5480]で使用される従来の楕円曲線（EC）ポイント表現です。他のバージョンはX座標のみを使用します。なぜなら、Y座標は、主要な契約操作（「OKP」）に再計算されるか、必要ではないためです。"
    },
    {
      "indent": 3,
      "text": "Applications MUST check that the curve and the key type are consistent and reject a key if they are not.",
      "ja": "アプリケーションは、曲線とキータイプが一貫していることを確認し、そうでない場合はキーを拒否する必要があります。"
    },
    {
      "indent": 3,
      "text": "+=========+=======+==========+=====================================+\n| Name    | Value | Key Type | Description                         |\n+=========+=======+==========+=====================================+\n| P-256   |   1   |   EC2    | NIST P-256, also known as secp256r1 |\n+---------+-------+----------+-------------------------------------+\n| P-384   |   2   |   EC2    | NIST P-384, also known as secp384r1 |\n+---------+-------+----------+-------------------------------------+\n| P-521   |   3   |   EC2    | NIST P-521, also known as secp521r1 |\n+---------+-------+----------+-------------------------------------+\n| X25519  |   4   |   OKP    | X25519 for use w/ ECDH only         |\n+---------+-------+----------+-------------------------------------+\n| X448    |   5   |   OKP    | X448 for use w/ ECDH only           |\n+---------+-------+----------+-------------------------------------+\n| Ed25519 |   6   |   OKP    | Ed25519 for use w/ EdDSA only       |\n+---------+-------+----------+-------------------------------------+\n| Ed448   |   7   |   OKP    | Ed448 for use w/ EdDSA only         |\n+---------+-------+----------+-------------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Table 18: Elliptic Curves",
      "ja": "表18：楕円曲線"
    },
    {
      "indent": 0,
      "text": "7.1.1. Double Coordinate Curves",
      "section_title": true,
      "ja": "7.1.1. ダブルコーディネート曲線"
    },
    {
      "indent": 3,
      "text": "Generally, protocols transmit elliptic-curve points as either the x-coordinate and y-coordinate or the x-coordinate and a sign bit for the y-coordinate. The latter encoding has not been recommended by the IETF due to potential IPR issues. However, for operations in constrained environments, the ability to shrink a message by not sending the y-coordinate is potentially useful.",
      "ja": "一般に、プロトコルは楕円曲線ポイントをX座標およびY座標またはX座標のいずれかとして送信し、Y座標の標識ビットです。後者のエンコードは、IPRの問題の可能性があるため、IETFによって推奨されていません。ただし、制約された環境での操作の場合、Y座標を送信しないことでメッセージを縮小する能力は潜在的に有用です。"
    },
    {
      "indent": 3,
      "text": "For EC keys with both coordinates, the \"kty\" member is set to 2 (EC2). The key parameters defined in this section are summarized in Table 19. The members that are defined for this key type are:",
      "ja": "両方の座標を持つECキーの場合、「kty」メンバーは2（EC2）に設定されます。このセクションで定義されている重要なパラメーターは、表19にまとめられています。このキータイプで定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv: This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 18. Other curves may be registered in the future, and private curves can be used as well.",
      "ja": "CRV：これには、キーとともに使用される曲線の識別子が含まれています。このキータイプのこのドキュメントで定義されている曲線は、表18に記載されています。その他の曲線は将来登録され、プライベート曲線も使用できます。"
    },
    {
      "indent": 3,
      "text": "x: This contains the x-coordinate for the EC point. The integer is converted to a byte string as defined in [SEC1]. Leading-zero octets MUST be preserved.",
      "ja": "X：これには、ECポイントのX座標が含まれています。整数は[SEC1]で定義されているように、バイト文字列に変換されます。リーディングゼロオクテットを保存する必要があります。"
    },
    {
      "indent": 3,
      "text": "y: This contains either the sign bit or the value of the y-coordinate for the EC point. When encoding the value y, the integer is converted to a byte string (as defined in [SEC1]) and encoded as a CBOR bstr. Leading-zero octets MUST be preserved. Compressed point encoding is also supported. Compute the sign bit as laid out in the Elliptic-Curve-Point-to-Octet-String Conversion function of [SEC1]. If the sign bit is zero, then encode y as a CBOR false value; otherwise, encode y as a CBOR true value. The encoding of the infinity point is not supported.",
      "ja": "Y：これには、ECポイントのY座標の符号ビットまたは値のいずれかが含まれます。値yをエンコードすると、整数はバイト文字列（[SEC1]で定義されている）に変換され、CBOR BSTRとしてエンコードされます。リーディングゼロオクテットを保存する必要があります。圧縮点エンコードもサポートされています。[SEC1]の楕円曲線ポイントからオクテット弦の変換関数でレイアウトされているように、サインビットを計算します。記号ビットがゼロの場合、yをCBOR false値としてエンコードします。それ以外の場合、yをCborの真の値としてエンコードします。インフィニティポイントのエンコードはサポートされていません。"
    },
    {
      "indent": 3,
      "text": "d: This contains the private key.",
      "ja": "D：これには秘密鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that \"crv\", \"x\", and \"y\" be present in the structure. For private keys, it is REQUIRED that \"crv\" and \"d\" be present in the structure. For private keys, it is RECOMMENDED that \"x\" and \"y\" also be present, but they can be recomputed from the required elements, and omitting them saves on space.",
      "ja": "パブリックキーの場合、「CRV」、「X」、および「Y」が構造に存在する必要があります。プライベートキーの場合、「CRV」と「D」が構造に存在する必要があります。プライベートキーの場合、「x」と「y」も存在することをお勧めしますが、必要な要素から再計算され、スペースを省くことができます。"
    },
    {
      "indent": 4,
      "text": "+======+======+=======+========+=================================+\n| Key  | Name | Label | CBOR   | Description                     |\n| Type |      |       | Type   |                                 |\n+======+======+=======+========+=================================+\n|  2   | crv  |   -1  | int /  | EC identifier -- Taken from the |\n|      |      |       | tstr   | \"COSE Elliptic Curves\" registry |\n+------+------+-------+--------+---------------------------------+\n|  2   |  x   |   -2  | bstr   | x-coordinate                    |\n+------+------+-------+--------+---------------------------------+\n|  2   |  y   |   -3  | bstr / | y-coordinate                    |\n|      |      |       | bool   |                                 |\n+------+------+-------+--------+---------------------------------+\n|  2   |  d   |   -4  | bstr   | Private key                     |\n+------+------+-------+--------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 23,
      "text": "Table 19: EC Key Parameters",
      "ja": "表19：ECキーパラメーター"
    },
    {
      "indent": 0,
      "text": "7.2. Octet Key Pair",
      "section_title": true,
      "ja": "7.2. オクテットキーペア"
    },
    {
      "indent": 3,
      "text": "A new key type is defined for Octet Key Pairs (OKPs). Do not assume that keys using this type are elliptic curves. This key type could be used for other curve types (for example, mathematics based on hyper-elliptic surfaces).",
      "ja": "Octetキーペア（OKPS）には、新しいキータイプが定義されています。このタイプを使用するキーが楕円曲線であると仮定しないでください。このキータイプは、他の曲線タイプに使用できます（たとえば、高楕円表面に基づく数学）。"
    },
    {
      "indent": 3,
      "text": "The key parameters defined in this section are summarized in Table 20. The members that are defined for this key type are:",
      "ja": "このセクションで定義されている重要なパラメーターは、表20に要約されています。このキータイプで定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "crv: This contains an identifier of the curve to be used with the key. The curves defined in this document for this key type can be found in Table 18. Other curves may be registered in the future, and private curves can be used as well.",
      "ja": "CRV：これには、キーとともに使用される曲線の識別子が含まれています。このキータイプのこのドキュメントで定義されている曲線は、表18に記載されています。その他の曲線は将来登録され、プライベート曲線も使用できます。"
    },
    {
      "indent": 3,
      "text": "x: This contains the public key. The byte string contains the public key as defined by the algorithm. (For X25519, internally it is a little-endian integer.)",
      "ja": "X：これには公開キーが含まれています。バイト文字列には、アルゴリズムで定義されている公開キーが含まれています。（x25519の場合、内部的には小さなエンディアンの整数です。）"
    },
    {
      "indent": 3,
      "text": "d: This contains the private key.",
      "ja": "D：これには秘密鍵が含まれています。"
    },
    {
      "indent": 3,
      "text": "For public keys, it is REQUIRED that \"crv\" and \"x\" be present in the structure. For private keys, it is REQUIRED that \"crv\" and \"d\" be present in the structure. For private keys, it is RECOMMENDED that \"x\" also be present, but it can be recomputed from the required elements, and omitting it saves on space.",
      "ja": "パブリックキーの場合、「CRV」と「X」が構造に存在する必要があります。プライベートキーの場合、「CRV」と「D」が構造に存在する必要があります。プライベートキーの場合、「X」も存在することをお勧めしますが、必要な要素から再計算し、省略するとスペースを省くことができます。"
    },
    {
      "indent": 3,
      "text": "+======+==========+=======+=======+=================================+\n| Name |   Key    | Label | Type  | Description                     |\n|      |   Type   |       |       |                                 |\n+======+==========+=======+=======+=================================+\n| crv  |    1     |   -1  | int / | EC identifier -- Taken from the |\n|      |          |       | tstr  | \"COSE Elliptic Curves\" registry |\n+------+----------+-------+-------+---------------------------------+\n| x    |    1     |   -2  | bstr  | Public Key                      |\n+------+----------+-------+-------+---------------------------------+\n| d    |    1     |   -4  | bstr  | Private key                     |\n+------+----------+-------+-------+---------------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 20: Octet Key Pair Parameters",
      "ja": "表20：オクテットのキーペアパラメーター"
    },
    {
      "indent": 0,
      "text": "7.3. Symmetric Keys",
      "section_title": true,
      "ja": "7.3. 対称キー"
    },
    {
      "indent": 3,
      "text": "Occasionally, it is required that a symmetric key be transported between entities. This key structure allows for that to happen.",
      "ja": "場合によっては、対称キーをエンティティ間で輸送する必要があります。この重要な構造により、それが起こることができます。"
    },
    {
      "indent": 3,
      "text": "For symmetric keys, the \"kty\" member is set to 4 (\"Symmetric\"). The member that is defined for this key type is:",
      "ja": "対称キーの場合、「kty」メンバーは4（「対称」）に設定されます。このキータイプで定義されているメンバーは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "k: This contains the value of the key.",
      "ja": "K：これにはキーの値が含まれています。"
    },
    {
      "indent": 3,
      "text": "This key structure does not have a form that contains only public members. As it is expected that this key structure is going to be transmitted, care must be taken that it is never transmitted accidentally or insecurely. For symmetric keys, it is REQUIRED that \"k\" be present in the structure.",
      "ja": "この重要な構造には、パブリックメンバーのみを含むフォームはありません。この重要な構造が送信されると予想されるため、誤ってまたは不安になることはないことに注意する必要があります。対称キーの場合、「k」が構造に存在する必要があります。"
    },
    {
      "indent": 13,
      "text": "+======+==========+=======+======+=============+\n| Name | Key Type | Label | Type | Description |\n+======+==========+=======+======+=============+\n|  k   |    4     |   -1  | bstr | Key Value   |\n+------+----------+-------+------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Table 21: Symmetric Key Parameters",
      "ja": "表21：対称キーパラメーター"
    },
    {
      "indent": 0,
      "text": "8. COSE Capabilities",
      "section_title": true,
      "ja": "8. COSE機能"
    },
    {
      "indent": 3,
      "text": "The capabilities of an algorithm or key type need to be specified in some situations. This has a counterpart in the S/MIME specifications, where SMIMECapabilities is defined in Section 2.5.2 of [RFC8551]. This document defines the same concept for COSE.",
      "ja": "ある状況では、アルゴリズムまたはキータイプの機能を指定する必要があります。これには、S/MIME仕様に対応するものがあり、SmimeCapabilityは[RFC8551]のセクション2.5.2で定義されています。このドキュメントは、COSEの同じ概念を定義しています。"
    },
    {
      "indent": 3,
      "text": "The algorithm identifier is not included in the capabilities data, as it should be encoded elsewhere in the message. The key type identifier is included in the capabilities data, as it is not expected to be encoded elsewhere.",
      "ja": "アルゴリズム識別子は、メッセージの他の場所でエンコードする必要があるため、機能データに含まれていません。キータイプ識別子は、他の場所でエンコードされるとは予想されていないため、機能データに含まれています。"
    },
    {
      "indent": 3,
      "text": "Two different types of capabilities are defined: capabilities for algorithms and capabilities for key type. Once defined by registration with IANA, the list of capabilities for an algorithm or key type is immutable. If it is later found that a new capability is needed for a key type or algorithm, it will require that a new code point be assigned to deal with that. As a general rule, the capabilities are going to map to algorithm-specific header parameters or key parameters, but they do not need to do so. An example of this is the HSS-LMS key type capabilities defined below, where the hash algorithm used is included.",
      "ja": "2つの異なるタイプの機能が定義されています。アルゴリズムの機能とキータイプの機能。IANAへの登録によって定義されると、アルゴリズムまたはキータイプの機能のリストは不可能です。キータイプまたはアルゴリズムに新しい機能が必要であることが後で発見された場合、それに対処するために新しいコードポイントを割り当てる必要があります。一般的なルールとして、機能はアルゴリズム固有のヘッダーパラメーターまたは重要なパラメーターにマッピングされますが、それを行う必要はありません。この例は、以下に定義されたHSS-LMSキータイプの機能で、使用されるハッシュアルゴリズムが含まれています。"
    },
    {
      "indent": 3,
      "text": "The capability structure is an array of values; the values included in the structure are dependent on a specific algorithm or key type. For algorithm capabilities, the first element should always be a key type value if applicable, but the items that are specific to a key (for example, a curve) should not be included in the algorithm capabilities. This means that if one wishes to enumerate all of the capabilities for a device that implements ECDH, it requires that all of the combinations of algorithms and key pairs be specified. The last example of Section 8.3 provides a case where this is done by allowing for a cross product to be specified between an array of algorithm capabilities and key type capabilities (see the ECDH-ES+A25KW element). For a key, the first element should be the key type value. While this means that the key type value will be duplicated if both an algorithm and key capability are used, the key type is needed in order to understand the rest of the values.",
      "ja": "機能構造は値の配列です。構造に含まれる値は、特定のアルゴリズムまたはキータイプに依存します。アルゴリズム機能の場合、最初の要素は該当する場合は常にキータイプの値である必要がありますが、キー（たとえば、曲線）に固有のアイテムは、アルゴリズム機能に含めるべきではありません。これは、ECDHを実装するデバイスのすべての機能を列挙したい場合、アルゴリズムとキーペアのすべての組み合わせを指定する必要があることを意味します。セクション8.3の最後の例は、アルゴリズム機能の配列とキータイプ機能の間でクロス製品を指定できるようにすることにより、これが行われるケースを提供します（ECDH-ES A25KW要素を参照）。キーの場合、最初の要素はキータイプの値である必要があります。これは、アルゴリズムとキー機能の両方が使用される場合、キータイプの値が複製されることを意味しますが、残りの値を理解するためにキータイプが必要です。"
    },
    {
      "indent": 0,
      "text": "8.1. Assignments for Existing Algorithms",
      "section_title": true,
      "ja": "8.1. 既存のアルゴリズムの割り当て"
    },
    {
      "indent": 3,
      "text": "For the current set of algorithms in the registry other than IV-GENERATION (those in this document as well as those in [RFC8230], [RFC8778], and [RFC9021]), the capabilities list is an array with one element, the key type (from the \"COSE Key Types\" Registry). It is expected that future registered algorithms could have zero, one, or multiple elements.",
      "ja": "IV世代以外のレジストリ内の現在のアルゴリズムのセット（このドキュメントのものと[RFC8230]、[RFC8778]、および[RFC9021]）のセットでは、機能リストは1つの要素を持つ配列です。タイプ（「COSEキータイプ」レジストリから）。将来の登録アルゴリズムは、ゼロ、1つ、または複数の要素を持つことが期待されています。"
    },
    {
      "indent": 0,
      "text": "8.2. Assignments for Existing Key Types",
      "section_title": true,
      "ja": "8.2. 既存のキータイプの割り当て"
    },
    {
      "indent": 3,
      "text": "There are a number of pre-existing key types; the following deals with creating the capability definition for those structures:",
      "ja": "既存のキータイプが多数あります。これらの構造の機能定義の作成に関する以下の扱い："
    },
    {
      "indent": 3,
      "text": "* OKP, EC2: The list of capabilities is:",
      "ja": "* OKP、EC2：機能のリストは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- The key type value. (1 for OKP or 2 for EC2.)",
      "ja": "- キータイプの値。（OKPの場合は1、EC2の場合は2）"
    },
    {
      "indent": 6,
      "text": "- One curve for that key type from the \"COSE Elliptic Curves\" registry.",
      "ja": "- 「COSE Elliptic Curves」レジストリからのキータイプの1つの曲線。"
    },
    {
      "indent": 3,
      "text": "* RSA: The list of capabilities is:",
      "ja": "* RSA：機能のリストは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- The key type value (3).",
      "ja": "- キータイプ値（3）。"
    },
    {
      "indent": 3,
      "text": "* Symmetric: The list of capabilities is:",
      "ja": "* 対称：機能のリストは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- The key type value (4).",
      "ja": "- キータイプ値（4）。"
    },
    {
      "indent": 3,
      "text": "* HSS-LMS: The list of capabilities is:",
      "ja": "* HSS-LMS：機能のリストは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- The key type value (5).",
      "ja": "- キータイプ値（5）。"
    },
    {
      "indent": 6,
      "text": "- Algorithm identifier for the underlying hash function from the \"COSE Algorithms\" registry.",
      "ja": "- 「COSEアルゴリズム」レジストリの基礎となるハッシュ関数のアルゴリズム識別子。"
    },
    {
      "indent": 3,
      "text": "* WalnutDSA: The list of capabilities is:",
      "ja": "* Walnutdsa：機能のリストは次のとおりです。"
    },
    {
      "indent": 6,
      "text": "- The key type value (6).",
      "ja": "- キータイプ値（6）。"
    },
    {
      "indent": 6,
      "text": "- The N value (group and matrix size) for the key, a uint.",
      "ja": "- キーのn値（グループとマトリックスサイズ）、a uint。"
    },
    {
      "indent": 6,
      "text": "- The q value (finite field order) for the key, a uint.",
      "ja": "- キーのq値（有限フィールド順序）、uint。"
    },
    {
      "indent": 0,
      "text": "8.3. Examples",
      "section_title": true,
      "ja": "8.3. 例"
    },
    {
      "indent": 3,
      "text": "Capabilities can be used in a key derivation process to make sure that both sides are using the same parameters. The three examples below show different ways that one might utilize parameters in specifying an application protocol:",
      "ja": "キー派生プロセスで機能を使用して、双方が同じパラメーターを使用していることを確認できます。以下の3つの例は、アプリケーションプロトコルを指定する際にパラメーターを利用する可能性のあるさまざまな方法を示しています。"
    },
    {
      "indent": 3,
      "text": "* Only an algorithm capability: This is useful if the protocol wants to require a specific algorithm, such as ES256, but it is agnostic about which curve is being used. This requires that the algorithm identifier be specified in the protocol. See the first example.",
      "ja": "* アルゴリズム機能のみ：これは、プロトコルがES256などの特定のアルゴリズムを要求したい場合に役立ちますが、どの曲線が使用されているかについては不可知論です。これには、プロトコルでアルゴリズム識別子を指定する必要があります。最初の例を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Only a key type capability: This is useful if the protocol wants to require a specific key type and curve, such as P-256, but will accept any algorithm using that curve (e.g., both ECDSA and ECDH). See the second example.",
      "ja": "* キータイプの機能のみ：これは、プロトコルがP-256などの特定のキータイプと曲線を必要とする場合に役立ちますが、その曲線を使用してアルゴリズムを受け入れます（例：ECDSAとECDHの両方）。2番目の例を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Both algorithm and key type capabilities: This is used if the protocol needs to nail down all of the options surrounding an algorithm -- e.g., EdDSA with the curve Ed25519. As with the first example, the algorithm identifier needs to be specified in the protocol. See the third example, which just concatenates the two capabilities together.",
      "ja": "* アルゴリズムとキータイプの機能の両方：これは、プロトコルがアルゴリズムを取り巻くすべてのオプション（例えば、EDDSAを搭載したEDSA ED25519などのすべてのオプションを特定する必要がある場合に使用されます。最初の例と同様に、アルゴリズム識別子をプロトコルで指定する必要があります。2つの機能を連結するだけで、3番目の例を参照してください。"
    },
    {
      "indent": 3,
      "text": "Algorithm ES256",
      "ja": "アルゴリズムES256"
    },
    {
      "indent": 3,
      "text": "0x8102 / [2 \\ EC2 \\ ] /",
      "ja": "0x8102 / [2 \\ ec2 \\] /"
    },
    {
      "indent": 3,
      "text": "Key type EC2 with P-256 curve:",
      "ja": "P-256曲線を備えたキータイプEC2："
    },
    {
      "indent": 3,
      "text": "0x820201 / [2 \\ EC2 \\, 1 \\ P-256 \\] /",
      "ja": "0x820201 / [2 \\ ec2 \\、1 \\ p-256 \\] /"
    },
    {
      "indent": 3,
      "text": "ECDH-ES + A256KW with an X25519 curve:",
      "ja": "x25519曲線を持つECDH-ES A256KW："
    },
    {
      "indent": 3,
      "text": "0x8101820104 / [1 \\ OKP \\],[1 \\ OKP \\, 4 \\ X25519 \\] /",
      "ja": "0x8101820104 / [1 \\ okp \\]、[1 \\ okp \\、4 \\ x25519 \\] /"
    },
    {
      "indent": 3,
      "text": "The capabilities can also be used by an entity to advertise what it is capable of doing. The decoded example below is one of many encodings that could be used for that purpose. Each array element includes three fields: the algorithm identifier, one or more algorithm capabilities, and one or more key type capabilities.",
      "ja": "この機能は、エンティティが行うことができることを宣伝するために使用することもできます。以下のデコードされた例は、その目的に使用できる多くのエンコーディングの1つです。各配列要素には、アルゴリズム識別子、1つ以上のアルゴリズム機能、1つ以上のキータイプ機能の3つのフィールドが含まれます。"
    },
    {
      "indent": 3,
      "text": "[\n [-8 / EdDSA /,\n   [1 / OKP key type /],\n   [\n     [1 / OKP /, 6 / Ed25519 / ],\n     [1 /OKP/, 7 /Ed448 /]\n   ]\n ],\n [-7 / ECDSA with SHA-256/,\n   [2 /EC2 key type/],\n   [\n     [2 /EC2/, 1 /P-256/],\n     [2 /EC2/, 3 /P-521/]\n   ]\n ],\n [ -31 / ECDH-ES+A256KW/,\n   [\n     [ 2 /EC2/],\n     [1 /OKP/ ]\n   ],\n   [\n     [2 /EC2/, 1 /P-256/],\n     [1 /OKP/, 4 / X25519/ ]\n   ]\n ],\n [ 1 / A128GCM /,\n   [ 4 / Symmetric / ],\n   [ 4 / Symmetric /]\n ]\n]",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Examining the above:",
      "ja": "上記を調べる："
    },
    {
      "indent": 3,
      "text": "* The first element indicates that the entity supports EdDSA with curves Ed25519 and Ed448.",
      "ja": "* 最初の要素は、エンティティが曲線ED25519およびED448を使用してEDDSAをサポートしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "* The second element indicates that the entity supports ECDSA with SHA-256 with curves P-256 and P-521.",
      "ja": "* 2番目の要素は、エンティティが曲線P-256とP-521を備えたSHA-256でECDSAをサポートしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "* The third element indicates that the entity supports Ephemeral-Static ECDH using AES256 key wrap. The entity can support the P-256 curve with an EC2 key type and the X25519 curve with an OKP key type.",
      "ja": "* 3番目の要素は、エンティティがAES256キーラップを使用してはかな静的ECDHをサポートしていることを示しています。エンティティは、EC2キータイプのP-256曲線とOKPキータイプのx25519曲線をサポートできます。"
    },
    {
      "indent": 3,
      "text": "* The last element indicates that the entity supports AES-GCM of 128 bits for content encryption.",
      "ja": "* 最後の要素は、エンティティがコンテンツ暗号化のために128ビットのAES-GCMをサポートしていることを示しています。"
    },
    {
      "indent": 3,
      "text": "The entity does not advertise that it supports any MAC algorithms.",
      "ja": "エンティティは、Macアルゴリズムをサポートしていることを宣伝していません。"
    },
    {
      "indent": 0,
      "text": "9. CBOR Encoding Restrictions",
      "section_title": true,
      "ja": "9. CBORエンコード制限"
    },
    {
      "indent": 3,
      "text": "This document limits the restrictions it imposes on how the CBOR Encoder needs to work. The new encoding restrictions are aligned with the Core Deterministic Encoding Requirements specified in Section 4.2.1 of RFC 8949 [STD94]. It has been narrowed down to the following restrictions:",
      "ja": "このドキュメントは、CBORエンコーダーがどのように機能するかに課す制限を制限しています。新しいエンコード制限は、RFC 8949 [STD94]のセクション4.2.1で指定されたコア決定論的エンコード要件と一致しています。それは次の制限に絞り込まれました："
    },
    {
      "indent": 3,
      "text": "* The restriction applies to the encoding of the COSE_KDF_Context.",
      "ja": "* 制限は、cose_kdf_contextのエンコードに適用されます。"
    },
    {
      "indent": 3,
      "text": "* Encoding MUST be done using definite lengths, and the length of the (encoded) argument MUST be the minimum possible length. This means that the integer 1 is encoded as \"0x01\" and not \"0x1801\".",
      "ja": "* エンコードは明確な長さを使用して行う必要があり、（エンコードされた）引数の長さは最小可能な長さでなければなりません。これは、整数1が「0x1801」ではなく「0x01」としてエンコードされることを意味します。"
    },
    {
      "indent": 3,
      "text": "* Applications MUST NOT generate messages with the same label used twice as a key in a single map. Applications MUST NOT parse and process messages with the same label used twice as a key in a single map. Applications can enforce the parse-and-process requirement by using parsers that will fail the parse step or by using parsers that will pass all keys to the application, and the application can perform the check for duplicate keys.",
      "ja": "* アプリケーションは、単一のマップでキーとして2回使用される同じラベルでメッセージを生成してはなりません。アプリケーションは、単一のマップでキーとして2回使用される同じラベルでメッセージを解析および処理してはなりません。アプリケーションは、パースステップに失敗するパーサーを使用して、またはアプリケーションにすべてのキーを渡すパーサーを使用して、アプリケーションが複製キーのチェックを実行できます。"
    },
    {
      "indent": 0,
      "text": "10. IANA Considerations",
      "section_title": true,
      "ja": "10. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "IANA has updated all COSE registries except for \"COSE Header Parameters\" and \"COSE Key Common Parameters\" to point to this document instead of [RFC8152].",
      "ja": "IANAは、[RFC8152]ではなくこのドキュメントを指す「COSEヘッダーパラメーター」と「COSEキー共通パラメーター」を除くすべてのCOSEレジストリを更新しました。"
    },
    {
      "indent": 0,
      "text": "10.1. Changes to the \"COSE Key Types\" Registry",
      "section_title": true,
      "ja": "10.1. 「COSEキータイプ」レジストリの変更"
    },
    {
      "indent": 3,
      "text": "IANA has added a new column in the \"COSE Key Types\" registry. The new column is labeled \"Capabilities\" and has been populated according to the entries in Table 22.",
      "ja": "IANAは、「COSEキータイプ」レジストリに新しい列を追加しました。新しい列には「機能」というラベルが付けられており、表22のエントリに従って入力されています。"
    },
    {
      "indent": 12,
      "text": "+=======+===========+============================+\n| Value | Name      | Capabilities               |\n+=======+===========+============================+\n| 1     | OKP       | [kty(1), crv]              |\n+-------+-----------+----------------------------+\n| 2     | EC2       | [kty(2), crv]              |\n+-------+-----------+----------------------------+\n| 3     | RSA       | [kty(3)]                   |\n+-------+-----------+----------------------------+\n| 4     | Symmetric | [kty(4)]                   |\n+-------+-----------+----------------------------+\n| 5     | HSS-LMS   | [kty(5), hash algorithm]   |\n+-------+-----------+----------------------------+\n| 6     | WalnutDSA | [kty(6), N value, q value] |\n+-------+-----------+----------------------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Table 22: Key Type Capabilities",
      "ja": "表22：キータイプの機能"
    },
    {
      "indent": 0,
      "text": "10.2. Changes to the \"COSE Algorithms\" Registry",
      "section_title": true,
      "ja": "10.2. 「COSEアルゴリズム」レジストリの変更"
    },
    {
      "indent": 3,
      "text": "IANA has added a new column in the \"COSE Algorithms\" registry. The new column is labeled \"Capabilities\" and has been populated with \"[kty]\" for all current, nonprovisional registrations.",
      "ja": "IANAは、「COSEアルゴリズム」レジストリに新しい列を追加しました。新しい列には「機能」というラベルが付けられており、現在のすべての非展開登録に「[kty]」が入力されています。"
    },
    {
      "indent": 3,
      "text": "IANA has updated the Reference column in the \"COSE Algorithms\" registry to include this document as a reference for all rows where it was not already present.",
      "ja": "IANAは、「COSEアルゴリズム」レジストリの参照列を更新し、このドキュメントをまだ存在していないすべての行の参照として含めるようにしました。"
    },
    {
      "indent": 3,
      "text": "IANA has added a new row to the \"COSE Algorithms\" registry.",
      "ja": "IANAは、「COSEアルゴリズム」レジストリに新しい行を追加しました。"
    },
    {
      "indent": 4,
      "text": "+===============+=======+===============+===========+=============+\n| Name          | Value | Description   | Reference | Recommended |\n+===============+=======+===============+===========+=============+\n| IV-GENERATION | 34    | For doing IV  | RFC 9053  | No          |\n|               |       | generation    |           |             |\n|               |       | for symmetric |           |             |\n|               |       | algorithms.   |           |             |\n+---------------+-------+---------------+-----------+-------------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 12,
      "text": "Table 23: New entry in the COSE Algorithms registry",
      "ja": "表23：COSEアルゴリズムレジストリの新しいエントリ"
    },
    {
      "indent": 3,
      "text": "The Capabilities column for this registration is to be empty.",
      "ja": "この登録の機能列は空にすることです。"
    },
    {
      "indent": 0,
      "text": "10.3. Changes to the \"COSE Key Type Parameters\" Registry",
      "section_title": true,
      "ja": "10.3. 「COSEキータイプパラメーター」レジストリの変更"
    },
    {
      "indent": 3,
      "text": "IANA has modified the description to \"Public Key\" for the line with \"Key Type\" of 1 and the \"Name\" of \"x\". See Table 20, which has been modified with this change.",
      "ja": "IANAは、1の「キータイプ」と「x」の「名前」を含む行の「公開鍵」に説明を変更しました。この変更により変更された表20を参照してください。"
    },
    {
      "indent": 0,
      "text": "10.4. Expert Review Instructions",
      "section_title": true,
      "ja": "10.4. 専門家のレビューの指示"
    },
    {
      "indent": 3,
      "text": "All of the IANA registries established by [RFC8152] are, at least in part, defined as Expert Review [RFC8126]. This section gives some general guidelines for what the experts should be looking for, but they are being designated as experts for a reason, so they should be given substantial latitude.",
      "ja": "[RFC8152]によって確立されたIANAレジストリはすべて、少なくとも部分的には、専門家のレビュー[RFC8126]として定義されています。このセクションでは、専門家が探しているものについてのいくつかの一般的なガイドラインを示していますが、それらは理由で専門家として指定されているため、実質的な緯度を与えられるべきです。"
    },
    {
      "indent": 3,
      "text": "Expert reviewers should take the following into consideration:",
      "ja": "専門家のレビュアーは、次のことを考慮に入れる必要があります。"
    },
    {
      "indent": 3,
      "text": "* Point squatting should be discouraged. Reviewers are encouraged to get sufficient information for registration requests to ensure that the usage is not going to duplicate an existing registration and that the code point is likely to be used in deployments. The ranges tagged as private use are intended for testing purposes and closed environments; code points in other ranges should not be assigned for testing.",
      "ja": "* ポイントスクワットは落胆する必要があります。レビューアは、登録要求に十分な情報を取得して、使用法が既存の登録を複製しないこと、およびコードポイントが展開で使用される可能性が高いことを確認することをお勧めします。私的使用としてタグ付けされた範囲は、テスト目的と閉鎖環境を目的としています。他の範囲のコードポイントは、テスト用に割り当てられないでください。"
    },
    {
      "indent": 3,
      "text": "* Standards Track or BCP RFCs are required to register a code point in the Standards Action range. Specifications should exist for Specification Required ranges, but early assignment before an RFC is available is considered to be permissible. Specifications are needed for the first-come, first-served range if the points are expected to be used outside of closed environments in an interoperable way. When specifications are not provided, the description provided needs to have sufficient information to identify what the point is being used for.",
      "ja": "* 標準トラックまたはBCP RFCは、標準アクション範囲のコードポイントを登録するために必要です。必要な範囲の仕様には仕様が存在する必要がありますが、RFCが利用可能になる前の早期割り当ては許容されると見なされます。ポイントが相互運用可能な方法で閉じた環境の外側で使用されると予想される場合、最初のカム、最初のサービス範囲には仕様が必要です。仕様が提供されていない場合、提供された説明には、ポイントが使用されているものを特定するのに十分な情報が必要です。"
    },
    {
      "indent": 3,
      "text": "* Experts should take into account the expected usage of fields when approving code point assignment. The fact that the Standards Action range is only available to Standards Track documents does not mean that a Standards Track document cannot have points assigned outside of that range. The length of the encoded value should be weighed against how many code points of that length are left and the size of device it will be used on.",
      "ja": "* 専門家は、コードポイントの割り当てを承認する際に、フィールドの予想される使用を考慮する必要があります。標準アクション範囲が標準の追跡ドキュメントでのみ利用可能であるという事実は、標準追跡ドキュメントがその範囲外に割り当てられたポイントを持たないことを意味するものではありません。エンコードされた値の長さは、その長さのコードポイントの数と、使用されるデバイスのサイズと比較検討する必要があります。"
    },
    {
      "indent": 3,
      "text": "* When algorithms are registered, vanity registrations should be discouraged. One way to do this is to require registrations to provide additional documentation on security analysis of the algorithm. Another thing that should be considered is requesting an opinion on the algorithm from the Crypto Forum Research Group (CFRG). Algorithms are expected to meet the security requirements of the community and the requirements of the message structures in order to be suitable for registration.",
      "ja": "* アルゴリズムが登録されている場合、バニティ登録は落胆する必要があります。これを行う1つの方法は、アルゴリズムのセキュリティ分析に関する追加のドキュメントを提供するために登録を要求することです。考慮すべきもう1つのことは、Crypto Forum Research Group（CFRG）からアルゴリズムに関する意見を要求することです。アルゴリズムは、登録に適しているために、コミュニティのセキュリティ要件とメッセージ構造の要件を満たすことが期待されています。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There are a number of security considerations that need to be taken into account by implementers of this specification. The security considerations that are specific to an individual algorithm are placed next to the description of the algorithm. While some considerations have been highlighted here, additional considerations may be found in the documents listed in the references.",
      "ja": "この仕様の実装者が考慮する必要があるセキュリティ上の考慮事項がいくつかあります。個々のアルゴリズムに固有のセキュリティ上の考慮事項は、アルゴリズムの説明の横に配置されます。ここではいくつかの考慮事項が強調されていますが、参照にリストされているドキュメントに追加の考慮事項があります。"
    },
    {
      "indent": 3,
      "text": "Implementations need to protect the private key material for all individuals. Some cases in this document need to be highlighted with regard to this issue.",
      "ja": "実装は、すべての個人の秘密のキー資料を保護する必要があります。このドキュメントの場合によっては、この問題に関して強調表示される必要があります。"
    },
    {
      "indent": 3,
      "text": "* Use of the same key for two different algorithms can leak information about the key. It is therefore recommended that keys be restricted to a single algorithm.",
      "ja": "* 2つの異なるアルゴリズムに同じキーを使用すると、キーに関する情報が漏れます。したがって、キーを単一のアルゴリズムに制限することをお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Use of \"direct\" as a recipient algorithm combined with a second recipient algorithm exposes the direct key to the second recipient; Section 8.5 of [RFC9052] forbids combining \"direct\" recipient algorithms with other modes.",
      "ja": "* 2番目のレシピエントアルゴリズムと組み合わせたレシピエントアルゴリズムとしての「直接」の使用は、直接キーを2番目の受信者に公開します。[RFC9052]のセクション8.5は、「直接」レシピエントアルゴリズムと他のモードを組み合わせた禁止。"
    },
    {
      "indent": 3,
      "text": "* Several of the algorithms in this document have limits on the number of times that a key can be used without leaking information about the key.",
      "ja": "* このドキュメントのアルゴリズムのいくつかは、キーに関する情報を漏らすことなくキーを使用できる回数に制限があります。"
    },
    {
      "indent": 3,
      "text": "The use of ECDH and direct plus KDF (with no key wrap) will not directly lead to the private key being leaked; the one-way function of the KDF will prevent that. There is, however, a different issue that needs to be addressed. Having two recipients requires that the CEK be shared between two recipients. The second recipient therefore has a CEK that was derived from material that can be used for the weak proof of origin. The second recipient could create a message using the same CEK and send it to the first recipient; the first recipient would, for either Static-Static ECDH or direct plus KDF, make an assumption that the CEK could be used for proof of origin, even though it is from the wrong entity. If the key wrap step is added, then no proof of origin is implied and this is not an issue.",
      "ja": "ECDHおよびDirect Plus KDF（キーラップなし）の使用は、秘密鍵が漏れていることに直接つながることはありません。KDFの一方向関数はそれを防ぎます。ただし、対処する必要がある別の問題があります。2人の受信者を持つには、CEKを2人の受信者間で共有する必要があります。したがって、2番目のレシピエントは、弱い原点の証明に使用できる材料から派生したCEKを持っています。2番目の受信者は、同じCEKを使用してメッセージを作成し、最初の受信者に送信できます。最初の受信者は、静的静的ECDHまたはダイレクトプラスKDFのいずれかについて、CEKが間違ったエンティティからであるにもかかわらず、起源の証明に使用できると仮定します。キーラップステップが追加された場合、原点の証明は暗示されておらず、これは問題ではありません。"
    },
    {
      "indent": 3,
      "text": "Although it has been mentioned before, it bears repeating that the use of a single key for multiple algorithms has been demonstrated in some cases to leak information about a key, providing the opportunity for attackers to forge integrity tags or gain information about encrypted content. Binding a key to a single algorithm prevents these problems. Key creators and key consumers are strongly encouraged to not only create new keys for each different algorithm, but to include that selection of algorithm in any distribution of key material and strictly enforce the matching of algorithms in the key structure to algorithms in the message structure. In addition to checking that algorithms are correct, the key form needs to be checked as well. Do not use an \"EC2\" key where an \"OKP\" key is expected.",
      "ja": "以前に言及したことがありますが、複数のアルゴリズムに単一のキーを使用していることが示されていることが示されており、キーに関する情報を漏らし、攻撃者が整合性タグを鍛造したり、暗号化されたコンテンツに関する情報を取得したりする機会を提供します。キーを単一のアルゴリズムに結合すると、これらの問題が防止されます。主要なクリエイターと主要な消費者は、異なるアルゴリズムごとに新しいキーを作成するだけでなく、キー構造内のアルゴリズムの一致をメッセージ構造のアルゴリズムに一致させることを、キーマテリアルの分布にアルゴリズムの選択を含めることを強く奨励されています。アルゴリズムが正しいことを確認することに加えて、重要なフォームも確認する必要があります。「OKP」キーが予想される「EC2」キーを使用しないでください。"
    },
    {
      "indent": 3,
      "text": "Before using a key for transmission, or before acting on information received, a trust decision on a key needs to be made. Is the data or action something that the entity associated with the key has a right to see or a right to request? A number of factors are associated with this trust decision. Some highlighted here are:",
      "ja": "送信にキーを使用する前、または受け取った情報に基づいて行動する前に、キーに関する信頼の決定を下す必要があります。データまたはアクションは、キーに関連付けられているエンティティが見る権利を持っているか、要求する権利を持っているのですか？この信頼の決定には、多くの要因が関連付けられています。ここで強調されているいくつかは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "* What are the permissions associated with the key owner?",
      "ja": "* キーオーナーに関連する権限は何ですか？"
    },
    {
      "indent": 3,
      "text": "* Is the cryptographic algorithm acceptable in the current context?",
      "ja": "* 暗号化アルゴリズムは現在のコンテキストで受け入れられますか？"
    },
    {
      "indent": 3,
      "text": "* Have the restrictions associated with the key, such as algorithm or freshness, been checked, and are they correct?",
      "ja": "* アルゴリズムや新鮮さなどのキーに関連する制限がチェックされていますか？"
    },
    {
      "indent": 3,
      "text": "* Is the request something that is reasonable, given the current state of the application?",
      "ja": "* アプリケーションの現在の状態を考えると、リクエストは合理的なものですか？"
    },
    {
      "indent": 3,
      "text": "* Have any security considerations that are part of the message been enforced (as specified by the application or \"crit\" header parameter)?",
      "ja": "* メッセージの一部であるセキュリティ上の考慮事項は、（アプリケーションまたは「クリティカル」ヘッダーパラメーターによって指定されているように）強制されていますか？"
    },
    {
      "indent": 3,
      "text": "There are a large number of algorithms presented in this document that use nonce values. For all of the nonces defined in this document, there is some type of restriction on the nonce being a unique value for either a key or some other conditions. In all of these cases, there is no known requirement on the nonce being both unique and unpredictable; under these circumstances, it's reasonable to use a counter for creation of the nonce. In cases where one wants the pattern of the nonce to be unpredictable as well as unique, one can use a key created for that purpose and encrypt the counter to produce the nonce value.",
      "ja": "このドキュメントには、NonCE値を使用する多くのアルゴリズムが提示されています。このドキュメントで定義されているすべての非能力について、NonCEがキーまたは他の条件のいずれかの一意の値であることに何らかの制限があります。これらのすべてのケースでは、NonCeがユニークで予測不可能であることに関する既知の要件はありません。これらの状況下では、非CEを作成するためにカウンターを使用することは合理的です。NonCeのパターンが予測不可能であり、一意であることを望んでいる場合、その目的のために作成されたキーを使用して、カウンターを暗号化してNonCe値を生成できます。"
    },
    {
      "indent": 3,
      "text": "One area that has been getting exposure is traffic analysis of encrypted messages based on the length of the message. This specification does not provide a uniform method for providing padding as part of the message structure. An observer can distinguish between two different messages (for example, \"YES\" and \"NO\") based on the length for all of the content encryption algorithms that are defined in this document. This means that it is up to the applications to document how content padding is to be done in order to prevent or discourage such analysis. (For example, the text strings could be defined as \"YES\" and \"NO \".)",
      "ja": "露出を取得している領域の1つは、メッセージの長さに基づいて暗号化されたメッセージのトラフィック分析です。この仕様は、メッセージ構造の一部としてパディングを提供するための均一な方法を提供しません。オブザーバーは、このドキュメントで定義されているすべてのコンテンツ暗号化アルゴリズムの長さに基づいて、2つの異なるメッセージ（「はい」と「いいえ」など）を区別できます。これは、そのような分析を防止または阻止するために、コンテンツパディングがどのように行われるかを文書化するのはアプリケーション次第であることを意味します。（たとえば、テキスト文字列は「はい」および「いいえ」と定義できます。）"
    },
    {
      "indent": 3,
      "text": "The analysis done in [RFC9147] is based on the number of records that are sent. This should map well to the number of messages sent when using COSE, so that analysis should hold here as well, under the assumption that the COSE messages are roughly the same size as DTLS records. It needs to be noted that the limits are based on the number of messages, but QUIC and DTLS are always pairwise-based endpoints. In contrast, [OSCORE-GROUPCOMM] uses COSE in a group communication scenario. Under these circumstances, it may be that no one single entity will see all of the messages that are encrypted, and therefore no single entity can trigger the rekey operation.",
      "ja": "[RFC9147]で行われた分析は、送信されるレコードの数に基づいています。これは、COSEを使用するときに送信されるメッセージの数に適切にマッピングされる必要があります。そのため、COSEメッセージはDTLSレコードとほぼ同じサイズであるという仮定の下で、分析もここに保持する必要があります。制限はメッセージの数に基づいていることに注意する必要がありますが、QUICとDTLは常にペアワイズベースのエンドポイントです。対照的に、[Oscore-GroupComm]は、グループコミュニケーションシナリオでCOSEを使用しています。これらの状況下では、単一のエンティティが暗号化されたすべてのメッセージが表示されないため、単一のエンティティが再キー操作をトリガーできない可能性があります。"
    },
    {
      "indent": 0,
      "text": "12. References",
      "section_title": true,
      "ja": "12. 参考文献"
    },
    {
      "indent": 0,
      "text": "12.1. Normative References",
      "section_title": true,
      "ja": "12.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[AES-GCM] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\", NIST Special Publication 800-38D, DOI 10.6028/NIST.SP.800-38D, November 2007, <https://csrc.nist.gov/publications/ nistpubs/800-38D/SP-800-38D.pdf>.",
      "ja": "[AES-GCM] DWorkin、M。、「操作のブロックモードの推奨：ガロア/カウンターモード（GCM）およびGMAC」、NIST Special Publication 800-38d、DOI 10.6028/nist.sp.sp.sp.sp.、<https://csrc.nist.gov/publications/ nistpubs/800-38d/sp-800-38d.pdf>。"
    },
    {
      "indent": 3,
      "text": "[DSS] National Institute of Standards and Technology, \"Digital Signature Standard (DSS)\", FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4, July 2013, <https://nvlpubs.nist.gov/nistpubs/FIPS/ NIST.FIPS.186-4.pdf>.",
      "ja": "[DSS]国立標準技術研究所、「デジタル署名標準（DSS）」、FIPS Pub 186-4、DOI 10.6028/nist.fips.186-4、2013年7月、<https://nvlpubs.nist.gov/nistpubs/ fips/ nist.fips.186-4.pdf>。"
    },
    {
      "indent": 3,
      "text": "[MAC] Menezes, A., van Oorschot, P., and S. Vanstone, \"Handbook of Applied Cryptography\", CRC Press, Boca Raton, 1996, <https://cacr.uwaterloo.ca/hac/>.",
      "ja": "[Mac] Menezes、A.、Van Oorschot、P。、およびS. Vanstone、「適用された暗号化のハンドブック」、CRC Press、Boca Raton、1996、<https://cacr.uwaterloo.ca/hac/>。"
    },
    {
      "indent": 3,
      "text": "[RFC2104] Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC: Keyed-Hashing for Message Authentication\", RFC 2104, DOI 10.17487/RFC2104, February 1997, <https://www.rfc-editor.org/info/rfc2104>.",
      "ja": "[RFC2104] Krawczyk、H.、Bellare、M。、およびR. CaNetti、「HMAC：メッセージ認証のためのキー付きハッシング」、RFC 2104、DOI 10.17487/RFC2104、1997年2月、<https：//www.rfc-editor.org/info/rfc2104>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC3394] Schaad, J. and R. Housley, \"Advanced Encryption Standard (AES) Key Wrap Algorithm\", RFC 3394, DOI 10.17487/RFC3394, September 2002, <https://www.rfc-editor.org/info/rfc3394>.",
      "ja": "[RFC3394] Schaad、J。and R. Housley、「Advanced Encryption Standard（AES）Key Wrap Algorithm」、RFC 3394、DOI 10.17487/RFC3394、2002年9月、<https://www.rfc-editor.org/info/RFC3394>。"
    },
    {
      "indent": 3,
      "text": "[RFC3610] Whiting, D., Housley, R., and N. Ferguson, \"Counter with CBC-MAC (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September 2003, <https://www.rfc-editor.org/info/rfc3610>.",
      "ja": "[RFC3610] Whiting、D.、Housley、R。、およびN. Ferguson、「CONTER COUNTER with CBC-MAC（CCM）」、RFC 3610、DOI 10.17487/RFC3610、2003年9月、<https：//www.rfc-editor.org/info/rfc3610>。"
    },
    {
      "indent": 3,
      "text": "[RFC5869] Krawczyk, H. and P. Eronen, \"HMAC-based Extract-and-Expand Key Derivation Function (HKDF)\", RFC 5869, DOI 10.17487/RFC5869, May 2010, <https://www.rfc-editor.org/info/rfc5869>.",
      "ja": "[RFC5869] Krawczyk、H。およびP. Eronen、「HMACベースの抽出および拡張キー誘導関数（HKDF）」、RFC 5869、DOI 10.17487/RFC5869、2010年5月、<https：//ww.rfc-editor.org/info/rfc5869>。"
    },
    {
      "indent": 3,
      "text": "[RFC6090] McGrew, D., Igoe, K., and M. Salter, \"Fundamental Elliptic Curve Cryptography Algorithms\", RFC 6090, DOI 10.17487/RFC6090, February 2011, <https://www.rfc-editor.org/info/rfc6090>.",
      "ja": "[RFC6090] McGrew、D.、Igoe、K。、およびM. Salter、「基本楕円曲線暗号化アルゴリズム」、RFC 6090、DOI 10.17487/RFC6090、2011年2月、<https：//www.rfc-editor.org/情報/RFC6090>。"
    },
    {
      "indent": 3,
      "text": "[RFC6979] Pornin, T., \"Deterministic Usage of the Digital Signature Algorithm (DSA) and Elliptic Curve Digital Signature Algorithm (ECDSA)\", RFC 6979, DOI 10.17487/RFC6979, August 2013, <https://www.rfc-editor.org/info/rfc6979>.",
      "ja": "[RFC6979] Pornin、T。、「デジタル署名アルゴリズム（DSA）および楕円曲線デジタル署名アルゴリズム（ECDSA）の決定論的使用」、RFC 6979、DOI 10.17487/RFC6979、2013年8月、<https：//www.RFC-editor.org/info/rfc6979>。"
    },
    {
      "indent": 3,
      "text": "[RFC7748] Langley, A., Hamburg, M., and S. Turner, \"Elliptic Curves for Security\", RFC 7748, DOI 10.17487/RFC7748, January 2016, <https://www.rfc-editor.org/info/rfc7748>.",
      "ja": "[RFC7748] Langley、A.、Hamburg、M。、およびS. Turner、「セキュリティのための楕円曲線」、RFC 7748、DOI 10.17487/RFC7748、2016年1月、<https://www.rfc-editor.org/info/RFC7748>。"
    },
    {
      "indent": 3,
      "text": "[RFC8017] Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch, \"PKCS #1: RSA Cryptography Specifications Version 2.2\", RFC 8017, DOI 10.17487/RFC8017, November 2016, <https://www.rfc-editor.org/info/rfc8017>.",
      "ja": "[RFC8017] Moriarty、K.、Ed。、Kaliski、B.、Jonsson、J.、A。Rusch、 \"PKCS＃1：RSA暗号仕様バージョン2.2\"、RFC 8017、DOI 10.17487/RFC8017、2016年11月、<<<<<https://www.rfc-editor.org/info/rfc8017>。"
    },
    {
      "indent": 3,
      "text": "[RFC8032] Josefsson, S. and I. Liusvaara, \"Edwards-Curve Digital Signature Algorithm (EdDSA)\", RFC 8032, DOI 10.17487/RFC8032, January 2017, <https://www.rfc-editor.org/info/rfc8032>.",
      "ja": "[RFC8032] Josefsson、S。およびI. Liusvaara、「Edwards-Curve Digital Signature Algorithm（EDDSA）」、RFC 8032、DOI 10.17487/RFC8032、2017年1月、<https：//www.rfc-editor.org/info//RFC8032>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8439] Nir, Y. and A. Langley, \"ChaCha20 and Poly1305 for IETF Protocols\", RFC 8439, DOI 10.17487/RFC8439, June 2018, <https://www.rfc-editor.org/info/rfc8439>.",
      "ja": "[RFC8439] NIR、Y。、A。Langley、「IETFプロトコル用のChacha20およびPoly1305、RFC 8439、DOI 10.17487/RFC8439、2018年6月、<https://www.rfc-editor.org/info/rfc8439>。"
    },
    {
      "indent": 3,
      "text": "[RFC9052] Schaad, J., \"CBOR Object Signing and Encryption (COSE): Structures and Process\", STD 96, RFC 9052, DOI 10.17487/RFC9052, August 2022, <https://www.rfc-editor.org/info/rfc9052>.",
      "ja": "[RFC9052] Schaad、J。、「Cborオブジェクトの署名と暗号化（COSE）：構造とプロセス」、STD 96、RFC 9052、DOI 10.17487/RFC9052、2022年8月、<https：//www.rfc-editor.org/情報/RFC9052>。"
    },
    {
      "indent": 3,
      "text": "[SEC1] Certicom Research, \"SEC 1: Elliptic Curve Cryptography\", Standards for Efficient Cryptography, May 2009, <https://www.secg.org/sec1-v2.pdf>.",
      "ja": "[Sec1] Certicom Research、「Sec 1：Elliptic Curve Cryptography」、2009年5月、効率的な暗号化の基準、<https://www.secg.org/sec1-v2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[STD94] Bormann, C. and P. Hoffman, \"Concise Binary Object Representation (CBOR)\", STD 94, RFC 8949, December 2020, <https://www.rfc-editor.org/info/std94>.",
      "ja": "[Std94] Bormann、C。and P. Hoffman、「Concise Binary Object Lepressation（CBOR）」、STD 94、RFC 8949、2020年12月、<https://www.rfc-editor.org/info/std94>。"
    },
    {
      "indent": 0,
      "text": "12.2. Informative References",
      "section_title": true,
      "ja": "12.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[CFRG-DET-SIGS] Mattsson, J. P., Thormarker, E., and S. Ruohomaa, \"Deterministic ECDSA and EdDSA Signatures with Additional Randomness\", Work in Progress, Internet-Draft, draft-mattsson-cfrg-det-sigs-with-noise-04, 15 February 2022, <https://datatracker.ietf.org/doc/html/draft-mattsson-cfrg-det-sigs-with-noise-04>.",
      "ja": "[CFRG-det-sigs] Mattsson、J。P.、Thormarker、E。、およびS. Ruohomaa、「追加のランダム性を備えた決定論的ECDSAおよびEDDSAシグネチャ」、進行中の作業、インターネットドラフト、ドラフトマッツソン-Det-Sigs-with-noise-04、2022年2月15日、<https://datatracker.ietf.org/doc/html/draft-mattsson-cfrg-det-sigs-with-noise-04>。"
    },
    {
      "indent": 3,
      "text": "[COUNTERSIGN] Schaad, J. and R. Housley, \"CBOR Object Signing and Encryption (COSE): Countersignatures\", Work in Progress, Internet-Draft, draft-ietf-cose-countersign-08, 22 August 2022, <https://datatracker.ietf.org/doc/html/draft-ietf-cose-countersign-08>.",
      "ja": "[countersign] Schaad、J。and R. Housley、「Cborオブジェクトの署名と暗号化（COSE）：Countersignatures」、Work in Progress、Internet-Draft、Draft-Itef-Cose-Countersign-08、2022年8月22日、<https：//datatracker.ietf.org/doc/html/draft-cose-countersign-08>。"
    },
    {
      "indent": 3,
      "text": "[GitHub-Examples] \"GitHub Examples of COSE\", commit 3221310, 3 June 2020, <https://github.com/cose-wg/Examples>.",
      "ja": "[github-examples] \"github examples of cose\"、commit 3221310、2020年6月3日、<https://github.com/cose-wg/examples>。"
    },
    {
      "indent": 3,
      "text": "[HKDF] Krawczyk, H., \"Cryptographic Extraction and Key Derivation: The HKDF Scheme\", 2010, <https://eprint.iacr.org/2010/264.pdf>.",
      "ja": "[HKDF] Krawczyk、H。、「暗号化抽出とキー導出：HKDFスキーム」、2010、<https://eprint.iacr.org/2010/264.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OSCORE-GROUPCOMM] Tiloca, M., Selander, G., Palombini, F., Mattsson, J. P., and J. Park, \"Group OSCORE - Secure Group Communication for CoAP\", Work in Progress, Internet-Draft, draft-ietf-core-oscore-groupcomm-14, 7 March 2022, <https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupcomm-14>.",
      "ja": "[Oscore-GroupComm] Tiloca、M.、Selander、G.、Palombini、F.、Mattsson、J。P.、およびJ. Park、「Group Oscore-Coapの安全なグループ通信」、進行中の作業、インターネットドラフト、ドラフト - IETF-CORE-OSCORE-GROUPCOMM-14、2022年3月7日、<https://datatracker.ietf.org/doc/html/draft-ietf-core-oscore-groupcomm-14>。"
    },
    {
      "indent": 3,
      "text": "[RFC4231] Nystrom, M., \"Identifiers and Test Vectors for HMAC-SHA-224, HMAC-SHA-256, HMAC-SHA-384, and HMAC-SHA-512\", RFC 4231, DOI 10.17487/RFC4231, December 2005, <https://www.rfc-editor.org/info/rfc4231>.",
      "ja": "[RFC4231] Nystrom、M。、「HMAC-SHA-224、HMAC-SHA-256、HMAC-SHA-384、およびHMAC-SHA-512 \"の識別子とテストベクター、RFC 4231、DOI 10.17487/RFC4231、2005年12月、<https://www.rfc-editor.org/info/rfc4231>。"
    },
    {
      "indent": 3,
      "text": "[RFC4493] Song, JH., Poovendran, R., Lee, J., and T. Iwata, \"The AES-CMAC Algorithm\", RFC 4493, DOI 10.17487/RFC4493, June 2006, <https://www.rfc-editor.org/info/rfc4493>.",
      "ja": "[RFC4493] Song、JH。、Poovendran、R.、Lee、J。、およびT. Iwata、「AES-CMACアルゴリズム」、RFC 4493、DOI 10.17487/RFC4493、2006年6月、<https：//ww.rfc4493-editor.org/info/rfc4493>。"
    },
    {
      "indent": 3,
      "text": "[RFC5116] McGrew, D., \"An Interface and Algorithms for Authenticated Encryption\", RFC 5116, DOI 10.17487/RFC5116, January 2008, <https://www.rfc-editor.org/info/rfc5116>.",
      "ja": "[RFC5116] McGrew、D。、「認証された暗号化のためのインターフェイスとアルゴリズム」、RFC 5116、DOI 10.17487/RFC5116、2008年1月、<https://www.rfc-editor.org/info/rfc5116>。"
    },
    {
      "indent": 3,
      "text": "[RFC5480] Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk, \"Elliptic Curve Cryptography Subject Public Key Information\", RFC 5480, DOI 10.17487/RFC5480, March 2009, <https://www.rfc-editor.org/info/rfc5480>.",
      "ja": "[RFC5480] Turner、S.、Brown、D.、Yiu、K.、Housley、R。、およびT. Polk、「楕円曲線暗号化科目の公開情報」、RFC 5480、DOI 10.17487/RFC5480、2009年3月、<https://www.rfc-editor.org/info/rfc5480>。"
    },
    {
      "indent": 3,
      "text": "[RFC6151] Turner, S. and L. Chen, \"Updated Security Considerations for the MD5 Message-Digest and the HMAC-MD5 Algorithms\", RFC 6151, DOI 10.17487/RFC6151, March 2011, <https://www.rfc-editor.org/info/rfc6151>.",
      "ja": "[RFC6151] Turner、S。およびL. Chen、「MD5 Message-DigestおよびHMAC-MD5アルゴリズムのセキュリティ上の考慮事項を更新しました」、RFC 6151、DOI 10.17487/RFC6151、2011年3月、<https：//ww.rfc-editor.org/info/rfc6151>。"
    },
    {
      "indent": 3,
      "text": "[RFC7252] Shelby, Z., Hartke, K., and C. Bormann, \"The Constrained Application Protocol (CoAP)\", RFC 7252, DOI 10.17487/RFC7252, June 2014, <https://www.rfc-editor.org/info/rfc7252>.",
      "ja": "[RFC7252] Shelby、Z.、Hartke、K。、およびC. Bormann、「制約付きアプリケーションプロトコル（COAP）」、RFC 7252、DOI 10.17487/RFC7252、2014年6月、<https：//www.rfc-editor。org/info/rfc7252>。"
    },
    {
      "indent": 3,
      "text": "[RFC7518] Jones, M., \"JSON Web Algorithms (JWA)\", RFC 7518, DOI 10.17487/RFC7518, May 2015, <https://www.rfc-editor.org/info/rfc7518>.",
      "ja": "[RFC7518]ジョーンズ、M。、「JSON Webアルゴリズム（JWA）」、RFC 7518、DOI 10.17487/RFC7518、2015年5月、<https://www.rfc-editor.org/info/rfc7518>"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487/RFC8126、2017年6月、<https：// wwwwwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8152] Schaad, J., \"CBOR Object Signing and Encryption (COSE)\", RFC 8152, DOI 10.17487/RFC8152, July 2017, <https://www.rfc-editor.org/info/rfc8152>.",
      "ja": "[RFC8152] Schaad、J。、「Cborオブジェクトの署名と暗号化（COSE）」、RFC 8152、DOI 10.17487/RFC8152、2017年7月、<https://www.rfc-editor.org/info/rfc8152>"
    },
    {
      "indent": 3,
      "text": "[RFC8230] Jones, M., \"Using RSA Algorithms with CBOR Object Signing and Encryption (COSE) Messages\", RFC 8230, DOI 10.17487/RFC8230, September 2017, <https://www.rfc-editor.org/info/rfc8230>.",
      "ja": "[RFC8230] Jones、M。、「CBORオブジェクトの署名と暗号化（COSE）メッセージを使用したRSAアルゴリズムを使用」、RFC 8230、DOI 10.17487/RFC8230、2017年9月、<https://www.rfc-editor.org/info/RFC8230>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 3,
      "text": "[RFC8551] Schaad, J., Ramsdell, B., and S. Turner, \"Secure/ Multipurpose Internet Mail Extensions (S/MIME) Version 4.0 Message Specification\", RFC 8551, DOI 10.17487/RFC8551, April 2019, <https://www.rfc-editor.org/info/rfc8551>.",
      "ja": "[RFC8551] Schaad、J.、Ramsdell、B。、およびS. Turner、「Secure/Multipurpose Internet Mail Extensions（S/MIME）バージョン4.0メッセージ仕様」、RFC 8551、DOI 10.17487/RFC8551、2019年4月、<HTTPS：//www.rfc-editor.org/info/rfc8551>。"
    },
    {
      "indent": 3,
      "text": "[RFC8610] Birkholz, H., Vigano, C., and C. Bormann, \"Concise Data Definition Language (CDDL): A Notational Convention to Express Concise Binary Object Representation (CBOR) and JSON Data Structures\", RFC 8610, DOI 10.17487/RFC8610, June 2019, <https://www.rfc-editor.org/info/rfc8610>.",
      "ja": "[RFC8610] Birkholz、H.、Vigano、C。、およびC. Bormann、「Scise Data Definition Language（CDDL）：簡潔なバイナリオブジェクト表現（CBOR）およびJSONデータ構造を表現する表記規則」、RFC 8610、DOI 10.17487/RFC8610、2019年6月、<https://www.rfc-editor.org/info/rfc8610>。"
    },
    {
      "indent": 3,
      "text": "[RFC8778] Housley, R., \"Use of the HSS/LMS Hash-Based Signature Algorithm with CBOR Object Signing and Encryption (COSE)\", RFC 8778, DOI 10.17487/RFC8778, April 2020, <https://www.rfc-editor.org/info/rfc8778>.",
      "ja": "[RFC8778] Housley、R。、「CBORオブジェクトの署名と暗号化（COSE）を備えたHSS/LMSハッシュベースの署名アルゴリズムの使用」、RFC 8778、DOI 10.17487/RFC8778、2020年4月、<https：//www.rfc-editor.org/info/rfc8778>。"
    },
    {
      "indent": 3,
      "text": "[RFC9021] Atkins, D., \"Use of the Walnut Digital Signature Algorithm with CBOR Object Signing and Encryption (COSE)\", RFC 9021, DOI 10.17487/RFC9021, May 2021, <https://www.rfc-editor.org/info/rfc9021>.",
      "ja": "[RFC9021] Atkins、D。、「CBORオブジェクトの署名と暗号化（COSE）を使用したクルミデジタル署名アルゴリズムの使用」、RFC 9021、DOI 10.17487/RFC9021、2021年5月、<https://www.rfc-editor.org/info/rfc9021>。"
    },
    {
      "indent": 3,
      "text": "[RFC9147] Rescorla, E., Tschofenig, H., and N. Modadugu, \"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022, <https://www.rfc-editor.org/info/rfc9147>.",
      "ja": "[RFC9147] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラム輸送層セキュリティ（DTLS）プロトコルバージョン1.3」、RFC 9147、DOI 10.17487/RFC9147、2022年4月、<https：// www。rfc-editor.org/info/rfc9147>。"
    },
    {
      "indent": 3,
      "text": "[ROBUST] Fischlin, M., Günther, F., and C. Janson, \"Robust Channels: Handling Unreliable Networks in the Record Layers of QUIC and DTLS\", February 2020, <https://eprint.iacr.org/2020/718.pdf>.",
      "ja": "[Robust] Fischlin、M.、Günther、F。、およびC. Janson、「堅牢なチャネル：QuicとDTLSのレコードレイヤーで信頼できないネットワークの処理」、2020年2月、<https://eprint.iacr.org/2020/718.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-38D] Dworkin, M., \"Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC\", NIST Special Publication 800-38D, November 2007, <https://nvlpubs.nist.gov/nistpubs/Legacy/SP/ nistspecialpublication800-38d.pdf>.",
      "ja": "[SP800-38D] Dworkin、M。、「操作のブロックモードの推奨：Galois/Counter Mode（GCM）およびGMACの推奨」、NIST Special Publication 800-38D、2007年11月、<https://nvlpubs.nist.govvv/nistpubs/regacy/sp/nistspecialpublication800-38d.pdf>。"
    },
    {
      "indent": 3,
      "text": "[SP800-56A] Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R. Davis, \"Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography\", NIST Special Publication 800-56A, Revision 3, DOI 10.6028/NIST.SP.800-56Ar3, April 2018, <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/ NIST.SP.800-56Ar2.pdf>.",
      "ja": "[SP800-56A] Barker、E.、Chen、L.、Roginsky、A.、Vassilev、A.、およびR. Davis、「離散対数暗号化を使用したペアワイズの主要確立スキームの推奨」、NIST Special Publication 800-56a、改訂3、DOI 10.6028/nist.sp.800-56ar3、2018年4月、<https://nvlpubs.nist.gov/nistpubs/specialpublications/ nist.sp.800-56ar2.pdf>。"
    },
    {
      "indent": 3,
      "text": "[STD90] Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data Interchange Format\", STD 90, RFC 8259, December 2017, <https://www.rfc-editor.org/info/std90>.",
      "ja": "[Std90] Bray、T.、ed。、「JavaScriptオブジェクト表記（JSON）データインターチェンジ形式」、STD 90、RFC 8259、2017年12月、<https://www.rfc-editor.org/info/std90>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This document is a product of the COSE Working Group of the IETF.",
      "ja": "このドキュメントは、IETFのCOSEワーキンググループの製品です。"
    },
    {
      "indent": 3,
      "text": "The following individuals are to blame for getting me started on this project in the first place: Richard Barnes, Matt Miller, and Martin Thomson.",
      "ja": "以下の個人は、そもそもこのプロジェクトを始めたことを責めます：リチャード・バーンズ、マット・ミラー、マーティン・トムソン。"
    },
    {
      "indent": 3,
      "text": "The initial draft version of the specification was based to some degree on the outputs of the JOSE and S/MIME Working Groups.",
      "ja": "仕様の最初のドラフトバージョンは、ホセとS/MIMEワーキンググループの出力にある程度基づいていました。"
    },
    {
      "indent": 3,
      "text": "The following individuals provided input into the final form of the document: Carsten Bormann, John Bradley, Brian Campbell, Michael B. Jones, Ilari Liusvaara, Francesca Palombini, Ludwig Seitz, and Göran Selander.",
      "ja": "次の個人は、文書の最終形式への入力を提供しました：Carsten Bormann、John Bradley、Brian Campbell、Michael B. Jones、Ilari Liusvaara、Francesca Palombini、Ludwig Seitz、GöranSelander。"
    },
    {
      "indent": 0,
      "text": "Author's Address",
      "ja": "著者の連絡先"
    },
    {
      "indent": 3,
      "text": "Jim Schaad August Cellars",
      "ja": "ジム・シャード・オーガスト・セラーズ"
    }
  ]
}