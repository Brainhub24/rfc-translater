{
  "title": {
    "text": "RFC 9289 - Towards Remote Procedure Call Encryption by Default",
    "ja": "RFC 9289 - リモート手順に向けて、デフォルトで暗号化を呼び出します"
  },
  "number": 9289,
  "created_at": "2022-09-15 02:47:55.701656+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Engineering Task Force (IETF)                      T. Myklebust\nRequest for Comments: 9289                                   Hammerspace\nUpdates: 5531                                              C. Lever, Ed.\nCategory: Standards Track                                         Oracle\nISSN: 2070-1721                                           September 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 10,
      "text": "Towards Remote Procedure Call Encryption by Default",
      "ja": "リモート手順に向けて、デフォルトで暗号化を呼び出します"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a mechanism that, through the use of opportunistic Transport Layer Security (TLS), enables encryption of Remote Procedure Call (RPC) transactions while they are in transit. The proposed mechanism interoperates with Open Network Computing (ONC) RPC implementations that do not support it. This document updates RFC 5531.",
      "ja": "このドキュメントは、日和見輸送層セキュリティ（TLS）を使用することにより、輸送中にリモート手順コール（RPC）トランザクションの暗号化を可能にするメカニズムについて説明します。提案されたメカニズムは、それをサポートしていないオープンネットワークコンピューティング（ONC）RPC実装と相互運用します。このドキュメントは、RFC 5531を更新します。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This is an Internet Standards Track document.",
      "ja": "これは、インターネット標準トラックドキュメントです。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Engineering Task Force (IETF). It represents the consensus of the IETF community. It has received public review and has been approved for publication by the Internet Engineering Steering Group (IESG). Further information on Internet Standards is available in Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットエンジニアリングタスクフォース（IETF）の製品です。IETFコミュニティのコンセンサスを表しています。公開レビューを受けており、インターネットエンジニアリングステアリンググループ（IESG）からの出版が承認されています。インターネット標準の詳細については、RFC 7841のセクション2で入手できます。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9289.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9289で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document. Code Components extracted from this document must include Revised BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Revised BSD License.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。このドキュメントから抽出されたコードコンポーネントには、セクション4.Eで説明されている法的規定のセクション4.Eで説明されており、修正されたBSDライセンスで説明されているように保証なしで提供される修正されたBSDライセンステキストを含める必要があります。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n2.  Requirements Language\n3.  Terminology\n4.  RPC-with-TLS in Operation\n  4.1.  Discovering Server-Side TLS Support\n  4.2.  Authentication\n    4.2.1.  Using TLS with RPCSEC_GSS\n5.  TLS Requirements\n  5.1.  Base Transport Considerations\n    5.1.1.  Protected Operation on TCP\n    5.1.2.  Protected Operation on UDP\n    5.1.3.  Protected Operation on Other Transports\n  5.2.  TLS Peer Authentication\n    5.2.1.  X.509 Certificates Using PKIX Trust\n      5.2.1.1.  Extended Key Usage Values\n    5.2.2.  Pre-shared Keys\n6.  Security Considerations\n  6.1.  The Limitations of Opportunistic Security\n    6.1.1.  STRIPTLS Attacks\n    6.1.2.  Privacy Leakage before Session Establishment\n  6.2.  TLS Identity Management on Clients\n  6.3.  Security Considerations for AUTH_SYS on TLS\n  6.4.  Best Security Policy Practices\n7.  IANA Considerations\n  7.1.  RPC Authentication Flavor\n  7.2.  ALPN Identifier for SunRPC\n  7.3.  Object Identifier for PKIX Extended Key Usage\n  7.4.  Object Identifier for ASN.1 Module\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAppendix A.  Known Weaknesses of the AUTH_SYS Authentication Flavor\nAppendix B.  ASN.1 Module\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "In 2014 the IETF published a document entitled \"Pervasive Monitoring Is an Attack\" [RFC7258], which recognized that unauthorized observation of network traffic had become widespread and was a subversive threat to all who make use of the Internet at large. It strongly recommended that newly defined Internet protocols should make a genuine effort to mitigate monitoring attacks. Typically, this mitigation includes encrypting data in transit.",
      "ja": "2014年に、IETFは「Pervasive Monitoringは攻撃である」[RFC7258]というタイトルのドキュメントを公開しました。これは、ネットワークトラフィックの不正な観察が広範囲に及ぶことを認識し、インターネットを大規模に利用するすべての人にとって破壊的な脅威でした。新たに定義されたインターネットプロトコルは、監視攻撃を緩和するために真の努力をすることを強くお勧めします。通常、この緩和には、輸送中のデータの暗号化が含まれます。"
    },
    {
      "indent": 3,
      "text": "The Remote Procedure Call version 2 protocol has been a Proposed Standard for three decades (see [RFC5531] and its antecedents). Over twenty years ago, Eisler et al. first introduced RPCSEC_GSS as an in-transit encryption mechanism for RPC [RFC2203]. However, experience has shown that RPCSEC_GSS with in-transit encryption can be challenging to use in practice due to the following:",
      "ja": "リモートプロシージャコールバージョン2プロトコルは、30年にわたって提案されている基準です（[RFC5531]とその前件を参照）。20年以上前、アイスラー等。RPC [RFC2203]の輸送内暗号化メカニズムとしてRPCSEC_GSSを最初に導入しました。ただし、経験によると、輸送中の暗号化を伴うRPCSEC_GSSは、以下のために実際に使用するのが難しい場合があります。"
    },
    {
      "indent": 3,
      "text": "* Parts of each RPC header remain in cleartext, constituting a loss of metadata confidentiality.",
      "ja": "* 各RPCヘッダーの一部はクリアテキストのままで、メタデータの機密性の損失を構成します。"
    },
    {
      "indent": 3,
      "text": "* Offloading the Generic Security Service (GSS) privacy service is not practical in large multi-user deployments since each message is encrypted using a key based on the issuing RPC user.",
      "ja": "* ジェネリックセキュリティサービス（GSS）プライバシーサービスのオフロードは、発行されたRPCユーザーに基づいてキーを使用して各メッセージが暗号化されるため、大規模なマルチユーザーの展開では実用的ではありません。"
    },
    {
      "indent": 3,
      "text": "However strong GSS-provided confidentiality is, it cannot provide any security if the challenges of using it result in choosing not to deploy it at all.",
      "ja": "GSSが提供する強力な機密性は、それを使用することの課題がまったく展開しないことを選択してもセキュリティを提供することはできません。"
    },
    {
      "indent": 3,
      "text": "Moreover, the use of AUTH_SYS remains common despite the adverse effects that acceptance of User Identifiers (UIDs) and Group Identifiers (GIDs) from unauthenticated clients brings with it. Continued use is in part because:",
      "ja": "さらに、ユーザー識別子（UIDS）とグループ識別子（GID）が認められないクライアントからの受け入れがそれをもたらすという悪影響にもかかわらず、auth_sysの使用は一般的なままです。継続的な使用は、次の理由の一部です。"
    },
    {
      "indent": 3,
      "text": "* Per-client deployment and administrative costs for the only well-defined alternative to AUTH_SYS are expensive at scale. For instance, administrators must provide keying material for each RPC client, including transient clients.",
      "ja": "* auth_sysの唯一の明確に定義された代替品のクライアント展開と管理コストは、大規模に高価です。たとえば、管理者は、一時的なクライアントを含む各RPCクライアントにキーイング素材を提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "* GSS host identity management and user identity management typically must be enforced in the same security realm. However, cloud providers, for instance, might prefer to remain authoritative for host identity but allow tenants to manage user identities within their private networks.",
      "ja": "* GSSホストID管理とユーザーID管理は、通常、同じセキュリティ領域で実施する必要があります。ただし、たとえば、クラウドプロバイダーは、ホストのアイデンティティに対して権威あるままであることを好むかもしれませんが、テナントはプライベートネットワーク内のユーザーIDを管理することを許可します。"
    },
    {
      "indent": 3,
      "text": "In view of the challenges with the currently available mechanisms for authenticating and protecting the confidentiality of RPC transactions, this document specifies a transport-layer security mechanism that complements the existing ones. The TLS [RFC8446] and Datagram Transport Layer Security (DTLS) [RFC9147] protocols are well-established Internet building blocks that protect many standard Internet protocols such as the Hypertext Transfer Protocol (HTTP) [RFC9110].",
      "ja": "RPCトランザクションの機密性を認証および保護するための現在利用可能なメカニズムの課題を考慮して、このドキュメントは、既存のトランザクションを補完する輸送層セキュリティメカニズムを指定します。TLS [RFC8446]およびデータグラムトランスポートレイヤーセキュリティ（DTLS）[RFC9147]プロトコルは、ハイパーテキスト転送プロトコル（HTTP）[RFC9110]などの多くの標準的なインターネットプロトコルを保護する確立されたインターネットビルディングブロックです。"
    },
    {
      "indent": 3,
      "text": "Encrypting at the RPC transport layer accords several significant benefits:",
      "ja": "RPC輸送層での暗号化は、いくつかの重要な利点を与えます。"
    },
    {
      "indent": 3,
      "text": "Encryption by Default: Transport encryption can be enabled without additional administrative tasks such as identifying client systems to a trust authority and providing each with keying material.",
      "ja": "デフォルトでの暗号化：輸送暗号化は、クライアントシステムを信頼機関に識別したり、それぞれにキーイング素材を提供するなどの追加の管理タスクなしで有効にできます。"
    },
    {
      "indent": 3,
      "text": "Encryption Offload: Hardware support for the GSS privacy service has not appeared in the marketplace. However, the use of a well-established transport encryption mechanism that is employed by other ubiquitous network protocols makes it more likely that encryption offload for RPC is practicable.",
      "ja": "暗号化オフロード：GSSプライバシーサービスのハードウェアサポートは、市場に登場していません。ただし、他のユビキタスネットワークプロトコルで採用されている確立された輸送暗号化メカニズムを使用すると、RPCの暗号化が実行可能である可能性が高くなります。"
    },
    {
      "indent": 3,
      "text": "Securing AUTH_SYS: Most critically, transport encryption can significantly reduce several security issues inherent in the current widespread use of AUTH_SYS (i.e., acceptance of UIDs and GIDs generated by an unauthenticated client).",
      "ja": "Auth_Sysの保護：最も重要なことに、輸送暗号化は、現在のAuth_Sysの現在の広範な使用に固有のいくつかのセキュリティ問題を大幅に減らすことができます（つまり、無慈悲なクライアントによって生成されたUIDとGIDの受け入れ）。"
    },
    {
      "indent": 3,
      "text": "Decoupled User and Host Identities: TLS can be used to authenticate peer hosts while other security mechanisms can handle user authentication.",
      "ja": "分離されたユーザーとホストのアイデンティティ：TLSを使用してピアホストを認証でき、他のセキュリティメカニズムはユーザー認証を処理できます。"
    },
    {
      "indent": 3,
      "text": "Compatibility: The imposition of encryption at the transport layer protects any upper-layer protocol that employs RPC, without alteration of the upper-layer protocol.",
      "ja": "互換性：輸送層での暗号化の賦課は、上層層プロトコルを変更することなく、RPCを使用した上層層プロトコルを保護します。"
    },
    {
      "indent": 3,
      "text": "Further, Section 6 of the current document defines policies in line with [RFC7435] that enable RPC-with-TLS to be deployed opportunistically in environments that contain RPC implementations that do not support TLS. However, specifications for RPC-based upper-layer protocols should choose to require even stricter policies that guarantee encryption and host authentication are used for all RPC transactions to mitigate against pervasive monitoring attacks [RFC7258]. Enforcing the use of RPC-with-TLS is of particular importance for existing upper-layer protocols whose security infrastructure is weak.",
      "ja": "さらに、現在のドキュメントのセクション6では、TLSをサポートしないRPC実装を含む環境でRPC-TLSを日和見的に展開できるようにする[RFC7435]に沿ったポリシーを定義しています。ただし、RPCベースの上層層プロトコルの仕様は、暗号化とホスト認証を保証するより厳格なポリシーを要求することを選択する必要があります。RPC-With-TLSの使用を実施することは、セキュリティインフラストラクチャが弱い既存の上層層プロトコルにとって特に重要です。"
    },
    {
      "indent": 3,
      "text": "The protocol specification in the current document assumes that support for ONC RPC [RFC5531], TLS [RFC8446], PKIX [RFC5280], DNSSEC/ DNS-Based Authentication of Named Entities (DANE) [RFC6698], and optionally RPCSEC_GSS [RFC2203] is available within the platform where RPC-with-TLS support is to be added.",
      "ja": "現在のドキュメントのプロトコル仕様は、ONC RPC [RFC5531]、TLS [RFC8446]、PKIX [RFC5280]、DNSSEC/ DNSベースの名前付きエンティティ（DANE）[RFC6698]、およびオプションのRPCSEC_GS [RFC2203]のサポートを想定しています。RPC-With-TLSサポートが追加されるプラットフォーム内で利用可能です。"
    },
    {
      "indent": 0,
      "text": "2. Requirements Language",
      "section_title": true,
      "ja": "2. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "3. Terminology",
      "section_title": true,
      "ja": "3. 用語"
    },
    {
      "indent": 3,
      "text": "This document adopts the terminology introduced in Section 3 of [RFC6973] and assumes a working knowledge of the RPC version 2 protocol [RFC5531] and the TLS version 1.3 protocol [RFC8446].",
      "ja": "このドキュメントは、[RFC6973]のセクション3で導入された用語を採用し、RPCバージョン2プロトコル[RFC5531]およびTLSバージョン1.3プロトコル[RFC8446]の実用的な知識を想定しています。"
    },
    {
      "indent": 3,
      "text": "Note also that the NFS community long ago adopted the use of the term \"privacy\" from documents such as [RFC2203]. In the current document, the authors use the term \"privacy\" only when referring specifically to the historic GSS privacy service defined in [RFC2203]. Otherwise, the authors use the term \"confidentiality\", following the practices of contemporary security communities.",
      "ja": "また、NFSコミュニティはずっと前に[RFC2203]などの文書から「プライバシー」という用語の使用を採用していたことにも注意してください。現在の文書では、著者は[RFC2203]で定義された歴史的なGSSプライバシーサービスを特に参照する場合にのみ「プライバシー」という用語を使用します。それ以外の場合、著者は、現代のセキュリティコミュニティの実践に従って、「機密性」という用語を使用しています。"
    },
    {
      "indent": 3,
      "text": "We adhere to the convention that a \"client\" is a network host that actively initiates an association, and a \"server\" is a network host that passively accepts an association request.",
      "ja": "「クライアント」は、協会を積極的に開始するネットワークホストであり、「サーバー」は協会のリクエストを受動的に受け入れるネットワークホストであるという条約を遵守します。"
    },
    {
      "indent": 3,
      "text": "RPC documentation historically refers to the authentication of a connecting host as \"machine authentication\" or \"host authentication\". TLS documentation refers to the same as \"peer authentication\". In the current document, there is little distinction between these terms.",
      "ja": "RPCドキュメントは、歴史的に、接続ホストの「マシン認証」または「ホスト認証」として認証を指します。TLSドキュメントは、「ピア認証」と同じを指します。現在のドキュメントでは、これらの用語を区別しません。"
    },
    {
      "indent": 3,
      "text": "The term \"user authentication\" in the current document refers specifically to the RPC caller's credential, provided in the \"cred\" and \"verf\" fields in each RPC Call.",
      "ja": "現在のドキュメントの「ユーザー認証」という用語は、各RPC呼び出しの「クレジット」および「Verf」フィールドで提供されるRPC発信者の資格情報を特に指します。"
    },
    {
      "indent": 0,
      "text": "4. RPC-with-TLS in Operation",
      "section_title": true,
      "ja": "4. rpc-with-tls動作"
    },
    {
      "indent": 0,
      "text": "4.1. Discovering Server-Side TLS Support",
      "section_title": true,
      "ja": "4.1. サーバー側のTLSサポートの発見"
    },
    {
      "indent": 3,
      "text": "The mechanism described in the current document interoperates fully with RPC implementations that do not support RPC-with-TLS. When an RPC-with-TLS-enabled peer encounters a peer that does not support RPC-with-TLS, policy settings on the RPC-with-TLS-enabled peer determine whether RPC operation continues without the use of TLS or is discontinued altogether.",
      "ja": "現在のドキュメントで説明されているメカニズムは、RPC-TLSをサポートしていないRPC実装と完全に相互運用します。RPC-TLS対応のピアがRPC-TLSをサポートしていないピアに遭遇すると、RPC-TLS対応のピアのポリシー設定が、RPC操作がTLSを使用せずに継続するか、完全に中止されているかどうかを判断します。"
    },
    {
      "indent": 3,
      "text": "To achieve this interoperability, we introduce a new RPC authentication flavor called AUTH_TLS. The AUTH_TLS authentication flavor signals that the client wants to initiate TLS negotiation if the server supports it. Except for the modifications described in this section, the RPC protocol is unaware of security encapsulation at the transport layer. The value of AUTH_TLS is defined in Section 7.1.",
      "ja": "この相互運用性を実現するために、auth_tlsと呼ばれる新しいRPC認証フレーバーを導入します。AUTH_TLS認証フレーバーは、サーバーがサポートしている場合、クライアントがTLSネゴシエーションを開始したいことを示しています。このセクションで説明した変更を除き、RPCプロトコルは輸送層でのセキュリティカプセル化を認識していません。auth_tlsの値は、セクション7.1で定義されています。"
    },
    {
      "indent": 3,
      "text": "An RPC client begins its communication with an RPC server by selecting a transport and destination port. The choice of transport and port is typically based on the RPC program that is to be used. The RPC client might query the RPC server's RPCBIND service to make this selection (The RPCBIND service is described in [RFC1833]). The mechanism described in the current document does not support RPC transports other than TCP and UDP. In all cases, an RPC server MUST listen on the same ports for (D)TLS-protected RPC programs as the ports used when (D)TLS is not available.",
      "ja": "RPCクライアントは、トランスポートと宛先ポートを選択することにより、RPCサーバーとの通信を開始します。輸送と港の選択は、通常、使用するRPCプログラムに基づいています。RPCクライアントは、RPCサーバーのRPCBINDサービスを照会してこの選択を行う場合があります（RPCBINDサービスは[RFC1833]で説明されています）。現在のドキュメントで説明されているメカニズムは、TCPおよびUDP以外のRPCトランスポートをサポートしていません。すべての場合において、RPCサーバーは、（d）TLSが使用されていない場合と同じポートで（d）TLS保護されたRPCプログラムについて聞く必要があります。"
    },
    {
      "indent": 3,
      "text": "To protect RPC traffic to a TCP port, the RPC client opens a TCP connection to that port and sends a NULL RPC procedure with an auth_flavor of AUTH_TLS on that connection. To protect RPC traffic to a UDP port, the RPC client sends a UDP datagram to that port containing a NULL RPC procedure with an auth_flavor of AUTH_TLS. The client constructs this RPC procedure as follows:",
      "ja": "RPCトラフィックをTCPポートに保護するために、RPCクライアントはそのポートへのTCP接続を開き、その接続にauth_tlsのauth_flavorを使用してnull rpc手順を送信します。RPCトラフィックをUDPポートに保護するために、RPCクライアントは、auth_tlsのauth_flavorを含むnull RPC手順を含むポートにUDPデータグラムを送信します。クライアントは、次のようにこのRPC手順を構築します。"
    },
    {
      "indent": 3,
      "text": "* The length of the opaque data constituting the credential sent in the RPC Call message MUST be zero.",
      "ja": "* RPCコールメッセージで送信された資格情報を構成する不透明データの長さはゼロでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The verifier accompanying the credential MUST be an AUTH_NONE verifier of length zero.",
      "ja": "* 資格情報に付随する検証剤は、長さゼロのauth_none検証者でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The flavor value of the verifier in the RPC Reply message received from the server MUST be AUTH_NONE.",
      "ja": "* サーバーから受信したRPC返信メッセージの検証剤のフレーバー値は、auth_noneでなければなりません。"
    },
    {
      "indent": 3,
      "text": "* The length of the verifier's body field is eight.",
      "ja": "* 検証器の体磁場の長さは8です。"
    },
    {
      "indent": 3,
      "text": "* The bytes of the verifier's body field encode the ASCII characters \"STARTTLS\" as a fixed-length opaque.",
      "ja": "* 検証器のボディフィールドのバイトは、ASCII文字「startTls」を固定長の不透明としてエンコードします。"
    },
    {
      "indent": 3,
      "text": "The RPC server signals its corresponding support for RPC-with-TLS by replying with a reply_stat of MSG_ACCEPTED and an AUTH_NONE verifier containing the \"STARTTLS\" token. The client SHOULD proceed with TLS session establishment, even if the Reply's accept_stat is not SUCCESS. If the AUTH_TLS probe was done via TCP, the RPC client MUST send the \"ClientHello\" message on the same connection. If the AUTH_TLS probe was done via UDP, the RPC client MUST send the \"ClientHello\" message to the same UDP destination port.",
      "ja": "RPCサーバーは、MSG_ACCEPTEDのREPLY_STATと「startTls」トークンを含むauth_none検証剤で返信することにより、RPC-with-tlsの対応するサポートを信号します。返信が成功していなくても、クライアントはTLSセッションの確立を続行する必要があります。auth_tlsプローブがTCPを介して実行された場合、RPCクライアントは同じ接続で「clienthello」メッセージを送信する必要があります。auth_tlsプローブがUDPを介して実行された場合、RPCクライアントは「clienthello」メッセージを同じUDP宛先ポートに送信する必要があります。"
    },
    {
      "indent": 3,
      "text": "Conversely, if the Reply's reply_stat is not MSG_ACCEPTED, if its verifier flavor is not AUTH_NONE, or if its verifier does not contain the \"STARTTLS\" token, the RPC client MUST NOT send a \"ClientHello\" message. RPC operation may continue, depending on local policy, but without confidentiality, integrity, or peer authentication protection from (D)TLS.",
      "ja": "逆に、ReplyのReply_StatがMSG_ACCEPTEDでない場合、検証剤フレーバーがauth_noneではない場合、または検証剤に「startTls」トークンが含まれていない場合、RPCクライアントは「clienthello」メッセージを送信してはなりません。RPCの操作は、ローカルポリシーに応じて継続する場合がありますが、（d）TLSからの機密性、整合性、またはピア認証保護がありません。"
    },
    {
      "indent": 3,
      "text": "If, after a successful RPC AUTH_TLS probe, the subsequent (D)TLS handshake should fail for any reason, the RPC client reports this failure to the upper-layer application the same way it reports an AUTH_ERROR rejection from the RPC server.",
      "ja": "RPC auth_tlsプローブが成功した後、その後の（d）TLSハンドシェイクが何らかの理由で失敗するはずです。RPCクライアントは、RPCサーバーからのauth_error拒否を報告するのと同じように、この失敗を上層層アプリケーションに報告します。"
    },
    {
      "indent": 3,
      "text": "If an RPC client uses the AUTH_TLS authentication flavor on any procedure other than the NULL procedure, or an RPC client sends an RPC AUTH_TLS probe within an existing (D)TLS session, the RPC server MUST reject that RPC Call by returning a reply_stat of MSG_DENIED with a reject_stat of AUTH_ERROR and an auth_stat of AUTH_BADCRED.",
      "ja": "RPCクライアントがNULLプロシージャ以外の手順でAUTH_TLS認証フレーバーを使用する場合、またはRPCクライアントが既存（D）TLSセッション内でRPC AUTH_TLSプローブを送信する場合、RPCサーバーはMSG_DENIEDのREPLY_STATを返すことによりRPC通話を拒否する必要があります。auth_errorのreject_statとauth_badcredのauth_statで。"
    },
    {
      "indent": 3,
      "text": "Once the TLS session handshake is complete, the RPC client and server have established a secure channel for exchanging RPC transactions. A successful AUTH_TLS probe on one particular port/transport tuple does not imply that RPC-with-TLS is available on that same server using a different port/transport tuple, nor does it imply that RPC-with-TLS will be available in the future using the successfully probed port.",
      "ja": "TLSセッションのハンドシェイクが完了すると、RPCクライアントとサーバーは、RPCトランザクションを交換するための安全なチャネルを確立しました。1つの特定のポート/トランスポートタプルで成功したauth_tlsプローブは、RPC-with-tlsが異なるポート/トランスポートタプルを使用して同じサーバーで利用できることを意味しません。正常にプローブされたポートを使用します。"
    },
    {
      "indent": 0,
      "text": "4.2. Authentication",
      "section_title": true,
      "ja": "4.2. 認証"
    },
    {
      "indent": 3,
      "text": "There is some overlap between the authentication capabilities of RPC and TLS. The goal of interoperability with implementations that do not support TLS requires limiting the combinations that are allowed and precisely specifying the role that each layer plays.",
      "ja": "RPCとTLSの認証機能の間には、ある程度の重複があります。TLSをサポートしていない実装との相互運用性の目標には、許可された組み合わせを制限し、各レイヤーが果たす役割を正確に指定する必要があります。"
    },
    {
      "indent": 3,
      "text": "Each RPC server that supports RPC-with-TLS MUST possess a unique global identity (e.g., a certificate that is signed by a well-known trust anchor). Such an RPC server MUST request a TLS peer identity from each client upon first contact. There are two different modes of client deployment:",
      "ja": "TLSのRPCをサポートする各RPCサーバーは、一意のグローバルID（例えば、よく知られている信頼アンカーによって署名された証明書）を所有する必要があります。このようなRPCサーバーは、最初の連絡先に各クライアントにTLSピアアイデンティティを要求する必要があります。クライアントの展開には2つの異なるモードがあります。"
    },
    {
      "indent": 3,
      "text": "Server-Only Host Authentication In this type of deployment, the client can authenticate the server host using the presented server peer TLS identity, but the server cannot authenticate the client. In this situation, RPC-with-TLS clients are anonymous. They present no globally unique identifier to the server peer.",
      "ja": "サーバーのみのホスト認証このタイプの展開では、クライアントは提示されたサーバーピアTLS IDを使用してサーバーホストを認証できますが、サーバーはクライアントを認証できません。この状況では、RPC-With-TLSクライアントは匿名です。彼らは、サーバーピアにグローバルに一意の識別子を提示しません。"
    },
    {
      "indent": 3,
      "text": "Mutual Host Authentication In this type of deployment, the client possesses an identity that is backed by a trusted entity (e.g., a pre-shared key or a certificate validated with a certification path). As part of the TLS handshake, both peers authenticate using the presented TLS identities. If authentication of either peer fails, or if authorization based on those identities blocks access to the server, the peers MUST reject the association. Further explanation appears in Section 5.2.",
      "ja": "相互ホスト認証このタイプの展開では、クライアントは信頼できるエンティティ（例えば、事前共有キーまたは認証パスで検証された証明書など）に裏付けられるアイデンティティを所有しています。TLSハンドシェイクの一部として、両方のピアは提示されたTLSアイデンティティを使用して認証します。いずれかのピアの認証が失敗した場合、またはそれらのアイデンティティに基づいて承認がサーバーへのアクセスをブロックする場合、ピアは協会を拒否する必要があります。さらに説明はセクション5.2に表示されます。"
    },
    {
      "indent": 3,
      "text": "In either of these modes, RPC user authentication is not affected by the use of transport layer security. When a client presents a TLS peer identity to an RPC server, the protocol extension described in the current document provides no way for the server to know whether that identity represents one RPC user on that client or is shared amongst many RPC users. Therefore, a server implementation cannot utilize the remote TLS peer identity to authenticate RPC users.",
      "ja": "これらのモードのいずれでも、RPCユーザー認証は輸送層のセキュリティの使用による影響を受けません。クライアントがRPCサーバーにTLSピアアイデンティティを提示する場合、現在のドキュメントで説明されているプロトコル拡張機能は、そのアイデンティティがそのクライアントの1人のRPCユーザーを表すか、多くのRPCユーザーの間で共有されているかをサーバーに知る方法を提供しません。したがって、サーバーの実装では、リモートTLSピアIDを使用してRPCユーザーを認証することはできません。"
    },
    {
      "indent": 0,
      "text": "4.2.1. Using TLS with RPCSEC_GSS",
      "section_title": true,
      "ja": "4.2.1. RPCSEC_GSSでTLSを使用します"
    },
    {
      "indent": 3,
      "text": "To use GSS, an RPC server has to possess a GSS service principal. On a TLS session, GSS mutual (peer) authentication occurs as usual, but only after a TLS session has been established for communication. Authentication of RPCSEC_GSS users is unchanged by the use of TLS.",
      "ja": "GSSを使用するには、RPCサーバーがGSSサービスプリンシパルを所有する必要があります。TLSセッションでは、GSS相互（ピア）認証は通常どおりに発生しますが、通信のためにTLSセッションが確立された後にのみ発生します。RPCSEC_GSSユーザーの認証は、TLSの使用によって変更されません。"
    },
    {
      "indent": 3,
      "text": "RPCSEC_GSS can also perform per-request integrity or confidentiality protection. When operating over a TLS session, these GSS services become largely redundant. An RPC implementation capable of concurrently using TLS and RPCSEC_GSS MUST use Generic Security Service Application Program Interface (GSS-API) channel binding, as defined in [RFC5056], to determine when an underlying transport provides a sufficient degree of confidentiality. RPC-with-TLS implementations MUST provide the \"tls-exporter\" channel binding type, as defined in [RFC9266].",
      "ja": "RPCSEC_GSSは、レクエストごとの完全性または機密保護を実行することもできます。TLSセッションで操作する場合、これらのGSSサービスは大部分が冗長になります。TLSとRPCSEC_GSSを同時に使用できるRPC実装では、[RFC5056]で定義されているように、汎用セキュリティサービスアプリケーションプログラムインターフェイス（GSS-API）チャネル結合を使用して、基礎となる輸送が十分な程度の機密性を提供する時期を決定する必要があります。RPC-With-TLS実装は、[RFC9266]で定義されているように、「TLS-Exporter」チャネル結合タイプを提供する必要があります。"
    },
    {
      "indent": 0,
      "text": "5. TLS Requirements",
      "section_title": true,
      "ja": "5. TLS要件"
    },
    {
      "indent": 3,
      "text": "When peers negotiate a TLS session that is to transport RPC, the following restrictions apply:",
      "ja": "ピアがRPCを輸送するTLSセッションを交渉するとき、次の制限が適用されます。"
    },
    {
      "indent": 3,
      "text": "* Implementations MUST NOT negotiate TLS versions prior to 1.3 (for TLS [RFC8446] or DTLS [RFC9147], respectively). Support for mandatory-to-implement cipher suites for the negotiated TLS version is REQUIRED.",
      "ja": "* 実装は、1.3（TLS [RFC8446]またはDTLS [RFC9147]の場合）の前にTLSバージョンを交渉してはなりません。交渉されたTLSバージョンの必須の暗号スイートのサポートが必要です。"
    },
    {
      "indent": 3,
      "text": "* Implementations MUST conform to the recommendations for TLS usage specified in BCP 195 [RFC7525]. Although RFC 7525 permits the use of TLS 1.2, the requirement to use TLS 1.3 or later for RPC-with-TLS takes precedence. Further, because TLS 1.3 ciphers are qualitatively different than cipher suites in previous versions of TLS, and RFC 7525 predates TLS 1.3, the cipher suite recommendations in RFC 7525 do not apply to RPC-with-(D)TLS. A strict TLS mode for RPC-with-TLS that protects against STRIPTLS attacks is discussed in detail in Section 6.1.1.",
      "ja": "* 実装は、BCP 195 [RFC7525]で指定されたTLS使用法の推奨事項に準拠する必要があります。RFC 7525ではTLS 1.2の使用が許可されていますが、TLS 1.3以降を使用する要件は、RPC-With-TLSに優先されます。さらに、TLS 1.3暗号は以前のバージョンのTLSの暗号スイートと定性的に異なり、RFC 7525がTLS 1.3より前に、RFC 7525の暗号スイートの推奨事項はRPC-With-（d）TLSには適用されません。Striptls攻撃から保護するRPC-With-TLSの厳密なTLSモードについては、セクション6.1.1で詳しく説明します。"
    },
    {
      "indent": 3,
      "text": "* Implementations MUST support certificate-based mutual authentication. Support for Pre-Shared Key (PSK) mutual authentication is OPTIONAL; see Section 5.2.2 for further details.",
      "ja": "* 実装は、証明書ベースの相互認証をサポートする必要があります。事前共有キー（PSK）相互認証のサポートはオプションです。詳細については、セクション5.2.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "* Negotiation of a cipher suite providing confidentiality as well as integrity protection is REQUIRED.",
      "ja": "* 機密性と整合性保護を提供する暗号スイートの交渉が必要です。"
    },
    {
      "indent": 3,
      "text": "Client implementations MUST include the \"application_layer_protocol_negotiation(16)\" extension [RFC7301] in their \"ClientHello\" message and MUST include the protocol identifier defined in Section 7.2 in that message's ProtocolNameList value.",
      "ja": "クライアントの実装には、「application_layer_protocol_negotiation（16） \"endixt [rfc7301]が「clienthello」メッセージに含まれている必要があり、そのメッセージのプロトコルナムリスト値のセクション7.2で定義されているプロトコル識別子を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "Similarly, in response to the \"ClientHello\" message, server implementations MUST include the \"application_layer_protocol_negotiation(16)\" extension [RFC7301] in their \"ServerHello\" message and MUST include only the protocol identifier defined in Section 7.2 in that message's ProtocolNameList value.",
      "ja": "同様に、「clienthello」メッセージに応じて、サーバーの実装には、「application_layer_protocol_negotiation（16） \"endoce [rfc7301]が「serverhello」メッセージに含まれている必要があり、そのメッセージのプロトコルナマリスト値のセクション7.2で定義されているプロトコル識別子のみを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "If the server responds incorrectly (for instance, if the \"ServerHello\" message does not conform to the above requirements), the client MUST NOT establish a TLS session for use with RPC on this connection. See [RFC7301] for further details about how to form these messages properly.",
      "ja": "サーバーが誤って応答した場合（たとえば、「serverhello」メッセージが上記の要件に準拠していない場合）、クライアントはこの接続でRPCで使用するためにTLSセッションを確立してはなりません。これらのメッセージを適切に形成する方法の詳細については、[RFC7301]を参照してください。"
    },
    {
      "indent": 0,
      "text": "5.1. Base Transport Considerations",
      "section_title": true,
      "ja": "5.1. 基本輸送に関する考慮事項"
    },
    {
      "indent": 3,
      "text": "There is frequently a strong association between an RPC program and a particular destination port number. The use of TLS or DTLS does not change that association. Thus, it is frequently, though not always, the case that a single TLS session carries traffic for only one RPC program.",
      "ja": "多くの場合、RPCプログラムと特定の宛先ポート番号との間には強力な関連性があります。TLSまたはDTLSの使用は、その関連付けを変更しません。したがって、常にではありませんが、単一のTLSセッションが1つのRPCプログラムのみのトラフィックを運ぶことが多い場合があります。"
    },
    {
      "indent": 0,
      "text": "5.1.1. Protected Operation on TCP",
      "section_title": true,
      "ja": "5.1.1. TCPでの保護操作"
    },
    {
      "indent": 3,
      "text": "The use of the TLS protocol [RFC8446] protects RPC on TCP connections. Typically, once an RPC client completes the TCP handshake, it uses the mechanism described in Section 4.1 to discover RPC-with-TLS support for that RPC program on that connection. Until an AUTH_TLS probe is done on a connection, the RPC server treats all traffic as RPC messages. If spurious traffic appears on a TCP connection between the initial cleartext AUTH_TLS probe and the TLS session handshake, receivers MUST discard that data without response and then SHOULD drop the connection.",
      "ja": "TLSプロトコル[RFC8446]の使用は、TCP接続でRPCを保護します。通常、RPCクライアントがTCPハンドシェイクを完了すると、セクション4.1で説明されているメカニズムを使用して、その接続に関するRPCプログラムのRPC-TLSサポートを発見します。AUTH_TLSプローブが接続で実行されるまで、RPCサーバーはすべてのトラフィックをRPCメッセージとして扱います。初期ClearText auth_tlsプローブとTLSセッションハンドシェイクの間のTCP接続にスプリアストラフィックが表示される場合、受信者はそのデータを応答せずに破棄し、接続をドロップする必要があります。"
    },
    {
      "indent": 3,
      "text": "The protocol convention specified in the current document assumes there can be no more than one concurrent TLS session per TCP connection. This is true of current generations of TLS, but might be different in a future version of TLS.",
      "ja": "現在のドキュメントで指定されているプロトコル規則は、TCP接続ごとに1つの同時TLSセッションがないことを前提としています。これは現在の世代のTLSに当てはまりますが、TLSの将来のバージョンでは異なる場合があります。"
    },
    {
      "indent": 3,
      "text": "Once a TLS session is established on a TCP connection, no further cleartext communication can occur on that connection until the session is terminated. The use of TLS does not alter RPC record framing used on TCP transports.",
      "ja": "TCP接続でTLSセッションが確立されると、セッションが終了するまで、その接続でそれ以上のクリアテキスト通信は発生することはありません。TLSの使用は、TCPトランスポートで使用されるRPCレコードフレーミングを変更しません。"
    },
    {
      "indent": 3,
      "text": "Furthermore, if an RPC server responds with PROG_UNAVAIL to an RPC Call within an established TLS session, that does not imply that RPC server will subsequently reject the same RPC program on a different TCP connection.",
      "ja": "さらに、RPCサーバーが確立されたTLSセッション内でRPCコールにPROG_UNAVAILで応答した場合、RPCサーバーがその後異なるTCP接続で同じRPCプログラムを拒否することを意味しません。"
    },
    {
      "indent": 3,
      "text": "Reverse-direction operation occurs only on connected transports such as TCP (see Section 2 of [RFC8167]). To protect reverse-direction RPC operations, the RPC server does not establish a separate TLS session on the TCP connection but instead uses the existing TLS session on that connection to protect these operations.",
      "ja": "逆方向の動作は、TCPなどの接続された輸送でのみ発生します（[RFC8167]のセクション2を参照）。逆方向のRPC操作を保護するために、RPCサーバーはTCP接続で個別のTLSセッションを確立するのではなく、代わりにこれらの操作を保護するためにその接続で既存のTLSセッションを使用します。"
    },
    {
      "indent": 3,
      "text": "When operation is complete, an RPC peer terminates a TLS session by sending a TLS closure alert. It may then close the TCP connection.",
      "ja": "操作が完了すると、RPCピアはTLSクロージャーアラートを送信することによりTLSセッションを終了します。その後、TCP接続を閉じる可能性があります。"
    },
    {
      "indent": 0,
      "text": "5.1.2. Protected Operation on UDP",
      "section_title": true,
      "ja": "5.1.2. UDPでの保護操作"
    },
    {
      "indent": 3,
      "text": "The use of the DTLS protocol [RFC9147] protects RPC carried in UDP datagrams. As soon as a client initializes a UDP socket for use with an RPC service, it uses the mechanism described in Section 4.1 to discover RPC-with-DTLS support for that RPC program on that port. If spurious traffic appears on a 5-tuple between the initial cleartext AUTH_TLS probe and the DTLS association handshake, receivers MUST discard that traffic without response.",
      "ja": "DTLSプロトコル[RFC9147]の使用は、UDPデータグラムで運ばれるRPCを保護します。クライアントがRPCサービスで使用するためにUDPソケットを初期化するとすぐに、セクション4.1で説明されているメカニズムを使用して、そのポート上のRPCプログラムのRPC-DTLSサポートを発見します。最初のClearText Auth_TLSプローブとDTLS Associationのハンドシェイクの間の5タプルにスプリアストラフィックが表示される場合、受信者はそのトラフィックを応答せずに破棄する必要があります。"
    },
    {
      "indent": 3,
      "text": "Using DTLS does not introduce reliable or in-order semantics to RPC on UDP. The use of DTLS record replay protection is REQUIRED when transporting RPC traffic.",
      "ja": "DTLSを使用しても、UDPでRPCに信頼性の高いまたは順序のセマンティクスが導入されません。RPCトラフィックを輸送する際には、DTLSレコードリプレイ保護の使用が必要です。"
    },
    {
      "indent": 3,
      "text": "Each RPC message MUST fit in a single DTLS record. DTLS encapsulation has overhead, which reduces the Packetization Layer Path MTU (PLPMTU) and thus the maximum RPC payload size. A possible PLPMTU discovery mechanism is offered in [RFC8899].",
      "ja": "各RPCメッセージは、単一のDTLSレコードに適合する必要があります。DTLSカプセル化にはオーバーヘッドがあり、パケット化レイヤーパスMTU（PLPMTU）が減少し、最大RPCペイロードサイズが削減されます。可能なPLPMTU発見メカニズムは[RFC8899]で提供されています。"
    },
    {
      "indent": 3,
      "text": "The current document does not specify a mechanism that enables a server to distinguish between DTLS traffic and unprotected RPC traffic directed to the same port. To make this distinction, each peer matches ingress datagrams that appear to be DTLS traffic to existing DTLS session state. A peer treats any datagram that fails the matching process as an RPC message.",
      "ja": "現在のドキュメントでは、サーバーがDTLSトラフィックと同じポートに向けられた保護されていないRPCトラフィックを区別できるようにするメカニズムを指定していません。この区別をするために、各ピアは、既存のDTLSセッション状態へのDTLSトラフィックのように見えるIngressデータグラムと一致します。ピアは、マッチングプロセスにRPCメッセージとして失敗するデータグラムを扱います。"
    },
    {
      "indent": 3,
      "text": "Multihomed RPC clients and servers may send protected RPC messages via network interfaces that were not involved in the handshake that established the DTLS session. Therefore, when protecting RPC traffic, each DTLS handshake MUST include the \"connection_id(54)\" extension described in Section 9 of [RFC9147], and RPC-with-DTLS peer endpoints MUST provide a ConnectionID with a nonzero length. Endpoints implementing RPC programs that expect a significant number of concurrent clients SHOULD employ ConnectionIDs of at least 4 bytes in length.",
      "ja": "MultiHomed RPCクライアントとサーバーは、DTLSセッションを確立したハンドシェイクに関与していないネットワークインターフェイスを介して保護されたRPCメッセージを送信する場合があります。したがって、RPCトラフィックを保護する場合、各DTLSハンドシェイクには、[RFC9147]のセクション9で説明されている「connection_id（54）」拡張機能を含める必要があります。かなりの数の同時クライアントを期待するRPCプログラムを実装するエンドポイントは、少なくとも4バイトのConnectionIDを使用する必要があります。"
    },
    {
      "indent": 3,
      "text": "Sending a TLS closure alert terminates a DTLS session. Because neither DTLS nor UDP provide in-order delivery, after session closure there can be ambiguity as to whether a datagram should be interpreted as DTLS protected or not. Therefore, receivers MUST discard datagrams exchanged using the same 5-tuple that just terminated the DTLS session for a sufficient length of time to ensure that retransmissions have ceased and packets already in the network have been delivered. In the absence of more specific data, a period of 60 seconds is expected to suffice.",
      "ja": "TLSクロージャーアラートを送信すると、DTLSセッションが終了します。DTLもUDPも順序の配信を提供しないため、セッションの閉鎖後、データグラムをDTLS保護と解釈する必要があるかどうかについての曖昧さがあります。したがって、受信者は、DTLSセッションを十分な時間に終了したのと同じ5タプルを使用してデータグラムを破棄して、再送信が停止し、ネットワーク内のパケットがすでに配信されていることを確認する必要があります。より具体的なデータがない場合、60秒の期間で十分であると予想されます。"
    },
    {
      "indent": 0,
      "text": "5.1.3. Protected Operation on Other Transports",
      "section_title": true,
      "ja": "5.1.3. 他の輸送機で保護された操作"
    },
    {
      "indent": 3,
      "text": "Transports that provide intrinsic TLS-level security (e.g., QUIC) need to be addressed separately from the current document. In such cases, the use of TLS is not opportunistic as it can be for TCP or UDP.",
      "ja": "本質的なTLSレベルのセキュリティを提供するトランスポート（例：QUIC）は、現在のドキュメントとは別に対処する必要があります。そのような場合、TLSの使用はTCPまたはUDPの場合と同じように日和見的ではありません。"
    },
    {
      "indent": 3,
      "text": "RPC-over-RDMA can make use of transport layer security below the RDMA transport layer [RFC8166]. The exact mechanism is not within the scope of the current document. Because there might not be other provisions to exchange client and server certificates, authentication material exchange needs to be provided by facilities within a future version of the RPC-over-RDMA transport protocol.",
      "ja": "RPC-Over-RDMAは、RDMA輸送層[RFC8166]の下で輸送層のセキュリティを利用できます。正確なメカニズムは、現在のドキュメントの範囲内ではありません。クライアントとサーバーの証明書を交換する他の規定がないかもしれないため、RPC-Over-RDMA輸送プロトコルの将来のバージョン内の施設によって認証資料交換が提供される必要があります。"
    },
    {
      "indent": 0,
      "text": "5.2. TLS Peer Authentication",
      "section_title": true,
      "ja": "5.2. TLSピア認証"
    },
    {
      "indent": 3,
      "text": "TLS can perform peer authentication using any of the following mechanisms.",
      "ja": "TLSは、次のメカニズムのいずれかを使用してピア認証を実行できます。"
    },
    {
      "indent": 0,
      "text": "5.2.1. X.509 Certificates Using PKIX Trust",
      "section_title": true,
      "ja": "5.2.1. X.509 PKIX Trustを使用した証明書"
    },
    {
      "indent": 3,
      "text": "X.509 certificates are specified in [X.509]. [RFC5280] provides a profile of Internet PKI X.509 public key infrastructure. RPC-with-TLS implementations are REQUIRED to support the PKIX mechanism described in [RFC5280].",
      "ja": "X.509証明書は[x.509]で指定されています。[RFC5280]は、インターネットPKI X.509公開キーインフラストラクチャのプロファイルを提供します。[RFC5280]で説明されているPKIXメカニズムをサポートするには、RPC-With-TLS実装が必要です。"
    },
    {
      "indent": 3,
      "text": "The rules and guidelines defined in [RFC6125] apply to RPC-with-TLS certificates with the following considerations:",
      "ja": "[RFC6125]で定義されているルールとガイドラインは、次の考慮事項を備えたRPC-TLS証明書に適用されます。"
    },
    {
      "indent": 3,
      "text": "* The DNS-ID identifier type is a subjectAltName extension that contains a dNSName, as defined in Section 4.2.1.6 of [RFC5280]. Support for the DNS-ID identifier type is REQUIRED in RPC-with-TLS client and server implementations. Certification authorities that issue such certificates MUST support the DNS-ID identifier type.",
      "ja": "* DNS-ID識別子タイプは、[RFC5280]のセクション4.2.1.6で定義されているように、DNSNAMEを含むsubjectaltname拡張機能です。DNS-ID識別子タイプのサポートは、RPC-With-TLSクライアントおよびサーバーの実装で必要です。そのような証明書を発行する認定当局は、DNS-ID識別子タイプをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "* To specify the identity of an RPC peer as a domain name, the certificate MUST contain a subjectAltName extension that contains a dNSName. DNS domain names in RPC-with-TLS certificates MUST NOT contain the wildcard character '*' within the identifier.",
      "ja": "* RPCピアの識別をドメイン名として指定するには、証明書にはDNSNameを含むsubjectaltname拡張機能を含める必要があります。rpc-with-tls証明書のDNSドメイン名は、識別子内にワイルドカード文字「*」を含めてはなりません。"
    },
    {
      "indent": 3,
      "text": "* To specify the identity of an RPC peer as a network identifier (netid) or a universal network address (uaddr), the certificate MUST contain a subjectAltName extension that contains an iPAddress.",
      "ja": "* ネットワーク識別子（NetID）またはユニバーサルネットワークアドレス（UADDR）としてのRPCピアのIDを指定するには、証明書にiPaddressを含むsumberaltname拡張機能を含める必要があります。"
    },
    {
      "indent": 3,
      "text": "When validating a server certificate, an RPC-with-TLS client implementation takes the following into account:",
      "ja": "サーバー証明書を検証する場合、クライアントの実装を使用してRPCを使用して以下を考慮します。"
    },
    {
      "indent": 3,
      "text": "* Certificate validation MUST include the verification rules as per Section 6 of [RFC5280] and Section 6 of [RFC6125].",
      "ja": "* 証明書の検証には、[RFC5280]のセクション6および[RFC6125]のセクション6に基づく検証ルールを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* Server certificate validation MUST include a check on whether the locally configured expected DNS-ID or iPAddress subjectAltName of the server that is contacted matches its presented certificate.",
      "ja": "* サーバー証明書の検証には、連絡されたサーバーのローカルで構成された予想されるDNS-IDまたはiPaddress件名が提示された証明書と一致するかどうかのチェックを含める必要があります。"
    },
    {
      "indent": 3,
      "text": "* For RPC services accessed by their netids and uaddrs, the iPAddress subjectAltName MUST be present in the certificate and MUST exactly match the address represented by the universal network address.",
      "ja": "* NetIDとUADDRSがアクセスするRPCサービスの場合、iPaddressのsubjectaltnameは証明書に存在する必要があり、ユニバーサルネットワークアドレスで表されるアドレスと正確に一致する必要があります。"
    },
    {
      "indent": 3,
      "text": "An RPC client's domain name and IP address are often assigned dynamically; thus, RPC servers cannot rely on those to verify client certificates. Therefore, when an RPC-with-TLS client presents a certificate to an RPC-with-TLS server, the server takes the following into account:",
      "ja": "RPCクライアントのドメイン名とIPアドレスは、多くの場合動的に割り当てられます。したがって、RPCサーバーは、クライアント証明書を確認するためにそれらに依存することはできません。したがって、RPC-TLSクライアントがRPC-TLSサーバーに証明書を提示すると、サーバーは以下を考慮します。"
    },
    {
      "indent": 3,
      "text": "* The server MUST use a procedure conformant to Section 6 of [RFC5280] to validate the client certificate's certification path.",
      "ja": "* サーバーは、[RFC5280]のセクション6に適合した手順を使用して、クライアント証明書の認証パスを検証する必要があります。"
    },
    {
      "indent": 3,
      "text": "* The tuple (serial number of the presented certificate; Issuer) uniquely identifies the RPC client. The meaning and syntax of these fields is defined in Section 4 of [RFC5280].",
      "ja": "* Tuple（提示された証明書のシリアル番号;発行者）は、RPCクライアントを一意に識別します。これらのフィールドの意味と構文は、[RFC5280]のセクション4で定義されています。"
    },
    {
      "indent": 3,
      "text": "RPC-with-TLS implementations MAY allow the configuration of a set of additional properties of the certificate to check for a peer's authorization to communicate (e.g., a set of allowed values in subjectAltName:URI, a set of allowed X.509v3 Certificate Policies, or a set of extended key usages).",
      "ja": "RPC-With-TLS実装により、証明書の追加プロパティのセットの構成が、ピアの通信の許可を確認するために（例：subjectaltname：uri、許可されたX.509v3証明書ポリシーのセットの許可値のセット、または一連の拡張キー使用法）。"
    },
    {
      "indent": 3,
      "text": "When the configured set of trust anchors changes (e.g., removal of a Certification Authority (CA) from the list of trusted CAs; issuance of a new Certificate Revocation List (CRL) for a given CA), implementations SHOULD reevaluate the certificate originally presented in the context of the new configuration and terminate the TLS session if the certificate is no longer trustworthy.",
      "ja": "構成されたトラストアンカーのセットが変更された場合（たとえば、信頼できるCAのリストから認証機関（CA）の削除、特定のCAの新しい証明書取消リスト（CRL）の発行）、実装は元々提示された証明書を再評価する必要があります。新しい構成のコンテキストと、証明書がもはや信頼できなくなった場合、TLSセッションを終了します。"
    },
    {
      "indent": 0,
      "text": "5.2.1.1. Extended Key Usage Values",
      "section_title": true,
      "ja": "5.2.1.1. 拡張されたキー使用値"
    },
    {
      "indent": 3,
      "text": "Section 4.2.1.12 of [RFC5280] specifies the extended key usage X.509 certificate extension. This extension, which may appear in end-entity certificates, indicates one or more purposes for which the certified public key may be used in addition to or in place of the basic purposes indicated in the key usage extension.",
      "ja": "[RFC5280]のセクション4.2.1.12は、拡張されたキー使用量X.509証明書延長を指定しています。エンドエンティティ証明書に表示される可能性のあるこの拡張機能は、キーの使用拡張機能に示されている基本的な目的に加えて、またはその代わりに認定された公開キーが使用される可能性がある1つ以上の目的を示します。"
    },
    {
      "indent": 3,
      "text": "The current document defines two new KeyPurposeId values: one that identifies the RPC-with-TLS peer as an RPC client, and one that identifies the RPC-with-TLS peer as an RPC server.",
      "ja": "現在のドキュメントでは、2つの新しいkeypurposeID値を定義します。1つはRPCのピアをRPCクライアントとして識別するものと、RPC-TLSピアをRPCサーバーとして識別するものです。"
    },
    {
      "indent": 3,
      "text": "The inclusion of the RPC server value (id-kp-rpcTLSServer) indicates that the certificate has been issued for allowing the holder to process RPC transactions.",
      "ja": "RPCサーバー値（ID-KP-RPCTLSSERVER）を含めることは、保有者がRPCトランザクションを処理できるようにするために証明書が発行されたことを示しています。"
    },
    {
      "indent": 3,
      "text": "The inclusion of the RPC client value (id-kp-rpcTLSClient) indicates that the certificate has been issued for allowing the holder to request RPC transactions.",
      "ja": "RPCクライアント値（ID-KP-RPCTLSCLIENT）を含めることは、保有者がRPCトランザクションを要求できるようにするために証明書が発行されたことを示しています。"
    },
    {
      "indent": 0,
      "text": "5.2.2. Pre-shared Keys",
      "section_title": true,
      "ja": "5.2.2. 事前に共有キー"
    },
    {
      "indent": 3,
      "text": "This mechanism is OPTIONAL to implement. In this mode, the RPC peer can be uniquely identified by keying material that has been shared out of band (see Section 2.2 of [RFC8446]). The PSK Identifier SHOULD be exposed at the RPC layer.",
      "ja": "このメカニズムは、実装するためにオプションです。このモードでは、RPCピアは、バンドから共有されたキーイング素材によって一意に識別できます（[RFC8446]のセクション2.2を参照）。PSK識別子は、RPCレイヤーで露出する必要があります。"
    },
    {
      "indent": 0,
      "text": "6. Security Considerations",
      "section_title": true,
      "ja": "6. セキュリティに関する考慮事項"
    },
    {
      "indent": 3,
      "text": "One purpose of the mechanism described in the current document is to protect RPC-based applications against threats to the confidentiality of RPC transactions and RPC user identities. A taxonomy of these threats appears in Section 5 of [RFC6973]. Also, Section 6 of [RFC7525] contains a detailed discussion of technologies used in conjunction with TLS. Section 8 of [RFC5280] covers important considerations about handling certificate material securely. Implementers should familiarize themselves with these materials.",
      "ja": "現在のドキュメントで説明されているメカニズムの1つの目的は、RPCトランザクションとRPCユーザーIDの機密性に対する脅威からRPCベースのアプリケーションを保護することです。これらの脅威の分類法は、[RFC6973]のセクション5に表示されます。また、[RFC7525]のセクション6には、TLSと組み合わせて使用される技術の詳細な説明が含まれています。[RFC5280]のセクション8では、証明書資料の取り扱いに関する重要な考慮事項について安全に取り上げています。実装者はこれらの資料に慣れる必要があります。"
    },
    {
      "indent": 3,
      "text": "Once a TLS session is established, the RPC payload carried on TLS version 1.3 is forward secure. However, implementers need to be aware that replay attacks can occur during session establishment. Remedies for such attacks are discussed in detail in Section 8 of [RFC8446]. Further, the current document does not provide a profile that defines the use of 0-RTT data (see Appendix E.5 of [RFC8446]). Therefore, RPC-with-TLS implementations MUST NOT use 0-RTT data.",
      "ja": "TLSセッションが確立されると、TLSバージョン1.3で運ばれるRPCペイロードはフォワードセキュアです。ただし、実装者は、セッションの確立中にリプレイ攻撃が発生する可能性があることに注意する必要があります。このような攻撃の救済策については、[RFC8446]のセクション8で詳しく説明します。さらに、現在のドキュメントでは、0-RTTデータの使用を定義するプロファイルを提供していません（[RFC8446]の付録E.5を参照）。したがって、RPC-With-TLS実装は0-RTTデータを使用してはなりません。"
    },
    {
      "indent": 0,
      "text": "6.1. The Limitations of Opportunistic Security",
      "section_title": true,
      "ja": "6.1. 日和見的セキュリティの限界"
    },
    {
      "indent": 3,
      "text": "Readers can find the definition of Opportunistic Security in [RFC7435]. A discussion of its underlying principles appears in Section 3 of that document.",
      "ja": "読者は[RFC7435]で日和見的セキュリティの定義を見つけることができます。その根本的な原則の議論は、その文書のセクション3に掲載されています。"
    },
    {
      "indent": 3,
      "text": "The purpose of using an explicitly opportunistic approach is to enable interoperation with implementations that do not support RPC-with-TLS. A range of options is allowed by this approach, from \"no peer authentication or encryption\" to \"server-only authentication with encryption\" to \"mutual authentication with encryption\". The actual security level may indeed be selected based on policy and without user intervention.",
      "ja": "明示的に日和見的なアプローチを使用する目的は、RPC-TLSをサポートしていない実装との相互操作を可能にすることです。このアプローチでは、「ピア認証や暗号化なし」から「暗号化によるサーバーのみの認証」、「暗号化による相互認証」まで、さまざまなオプションが許可されています。実際のセキュリティレベルは、実際にポリシーに基づいて、ユーザーの介入なしに選択される場合があります。"
    },
    {
      "indent": 3,
      "text": "In environments where interoperability is a priority, the security benefits of TLS are partially or entirely waived. Implementations of the mechanism described in the current document must take care to accurately represent to all RPC consumers the level of security that is actually in effect, and are REQUIRED to provide an audit log of RPC-with-TLS security mode selection.",
      "ja": "相互運用性が優先事項である環境では、TLSのセキュリティ利益が部分的または完全に放棄されます。現在のドキュメントで説明されているメカニズムの実装は、実際に有効なセキュリティレベルをすべてのRPC消費者に正確に表すように注意しなければならず、RPC-TLSセキュリティモードの選択の監査ログを提供する必要があります。"
    },
    {
      "indent": 3,
      "text": "In all other cases, the adoption, implementation, and deployment of RPC-based upper-layer protocols that enforce the use of TLS authentication and encryption (when similar RPCSEC_GSS services are not in use) is strongly encouraged.",
      "ja": "他のすべてのケースでは、TLS認証と暗号化の使用を実施するRPCベースの上層プロトコルの採用、実装、および展開（同様のRPCSEC_GSSサービスが使用されていない場合）が強く推奨されます。"
    },
    {
      "indent": 0,
      "text": "6.1.1. STRIPTLS Attacks",
      "section_title": true,
      "ja": "6.1.1. striptls攻撃"
    },
    {
      "indent": 3,
      "text": "The initial AUTH_TLS probe occurs in cleartext. An on-path attacker can alter a cleartext handshake to make it appear as though TLS support is not available on one or both peers. Client implementers can choose from the following to mitigate STRIPTLS attacks:",
      "ja": "初期auth_tlsプローブは、ClearTextで発生します。パス上の攻撃者は、クリアテキストの握手を変更して、TLSサポートが一方または両方のピアで利用できないかのように見せることができます。クライアントの実装者は、striptls攻撃を軽減するために以下から選択できます。"
    },
    {
      "indent": 3,
      "text": "* A TLSA record [RFC6698] can alert clients that TLS is expected to work, and provide a binding of a hostname to the X.509 identity. If TLS cannot be negotiated or authentication fails, the client disconnects and reports the problem. When an opportunistic security policy is in place, a client SHOULD check for the existence of a TLSA record for the target server before initiating an RPC-with-TLS association.",
      "ja": "* TLSAレコード[RFC6698]は、TLSが機能すると予想されていることをクライアントに警告し、X.509 IDにホスト名を拘束することができます。TLSを交渉できない場合、または認証が失敗した場合、クライアントは問題を切断して報告します。日和見的セキュリティポリシーが整った場合、クライアントは、RPC-TLS Associationを開始する前に、ターゲットサーバーのTLSAレコードの存在を確認する必要があります。"
    },
    {
      "indent": 3,
      "text": "* Client security policy can require that a TLS session is established on every connection. If an attacker spoofs the handshake, the client disconnects and reports the problem. This policy prevents an attacker from causing the association to fall back to cleartext silently. If TLSA records are not available, this approach is strongly encouraged.",
      "ja": "* クライアントセキュリティポリシーでは、すべての接続でTLSセッションが確立されることを要求できます。攻撃者が握手を押し上げると、クライアントは問題を切断して報告します。このポリシーにより、攻撃者が協会を静かにクリアテキストに戻すことができなくなります。TLSAレコードが利用できない場合、このアプローチが強く推奨されます。"
    },
    {
      "indent": 0,
      "text": "6.1.2. Privacy Leakage before Session Establishment",
      "section_title": true,
      "ja": "6.1.2. セッションの確立前のプライバシーリーク"
    },
    {
      "indent": 3,
      "text": "As mentioned earlier, communication between an RPC client and server appears in the clear on the network prior to the establishment of a TLS session. This cleartext information usually includes transport connection handshake exchanges, the RPC NULL procedure probing support for TLS, and the initial parts of TLS session establishment. Appendix C of [RFC8446] discusses precautions that can mitigate exposure during the exchange of connection handshake information and TLS certificate material that might enable attackers to track the RPC client. Note that when PSK authentication is used, the PSK identifier is exposed during the TLS handshake and can be used to track the RPC client.",
      "ja": "前述のように、RPCクライアントとサーバー間の通信は、TLSセッションを確立する前に、ネットワーク上のクリアに表示されます。このClearText情報には、通常、TLSの輸送接続ハンドシェイク交換、TLSのサポートを調査するRPCヌル手順、およびTLSセッション確立の初期部分が含まれます。[RFC8446]の付録Cは、接続握手情報の交換中に露出を軽減できる予防策と、攻撃者がRPCクライアントを追跡できるようにする可能性のあるTLS証明資料について説明します。PSK認証を使用すると、PSK識別子はTLSハンドシェイク中に公開され、RPCクライアントの追跡に使用できることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Any RPC traffic that appears on the network before a TLS session has been established is vulnerable to monitoring or undetected modification. A secure client implementation limits or prevents any RPC exchanges that are not protected.",
      "ja": "TLSセッションが確立される前にネットワークに表示されるRPCトラフィックは、監視または検出されない変更に対して脆弱です。安全なクライアントの実装は、保護されていないRPC交換を制限または防止します。"
    },
    {
      "indent": 3,
      "text": "The exception to this edict is the initial RPC NULL procedure that acts as a STARTTLS message, which cannot be protected. This RPC NULL procedure contains no arguments or results, and the AUTH_TLS authentication flavor it uses does not contain user information, so there is negligible privacy impact from this exception.",
      "ja": "このdict令の例外は、保護できないStartTLSメッセージとして機能する最初のRPCヌル手順です。このRPC NULLプロシージャには引数も結果も含まれておらず、使用するauth_tls認証フレーバーにはユーザー情報が含まれていないため、この例外からのプライバシーへの影響は無視できます。"
    },
    {
      "indent": 0,
      "text": "6.2. TLS Identity Management on Clients",
      "section_title": true,
      "ja": "6.2. クライアントのTLS ID管理"
    },
    {
      "indent": 3,
      "text": "The goal of RPC-with-TLS is to hide the content of RPC requests while they are in transit. RPC-with-TLS protocol by itself cannot protect against exposure of a user's RPC requests to other users on the same client.",
      "ja": "RPC-With-TLSの目標は、RPC要求のコンテンツを輸送中に非表示にすることです。RPC-With-TLSプロトコル自体は、同じクライアントの他のユーザーへのユーザーのRPC要求の露出から保護することはできません。"
    },
    {
      "indent": 3,
      "text": "Moreover, client implementations are free to transmit RPC requests for more than one RPC user using the same TLS session. Depending on the details of the client RPC implementation, this means that the client's TLS credentials are potentially visible to every RPC user that shares a TLS session. Privileged users may also be able to access this TLS identity.",
      "ja": "さらに、クライアントの実装は、同じTLSセッションを使用して複数のRPCユーザーに対してRPC要求を無料で送信できます。クライアントRPC実装の詳細に応じて、これはクライアントのTLS資格情報が、TLSセッションを共有するすべてのRPCユーザーに潜在的に表示できることを意味します。特権ユーザーは、このTLS IDにアクセスすることもできます。"
    },
    {
      "indent": 3,
      "text": "As a result, client implementations need to carefully segregate TLS credentials so that local access to it is restricted to only the local users that are authorized to perform operations on the remote RPC server.",
      "ja": "その結果、クライアントの実装は、TLS資格情報を慎重に分離して、ローカルアクセスがリモートRPCサーバーで操作を実行することを許可されているローカルユーザーのみに制限されるようにする必要があります。"
    },
    {
      "indent": 0,
      "text": "6.3. Security Considerations for AUTH_SYS on TLS",
      "section_title": true,
      "ja": "6.3. TLS上のauth_sysのセキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Using a TLS-protected transport when the AUTH_SYS authentication flavor is in use addresses several longstanding weaknesses in AUTH_SYS (as detailed in Appendix A). TLS augments AUTH_SYS by providing both integrity protection and confidentiality that AUTH_SYS lacks. TLS protects data payloads, RPC headers, and user identities against monitoring and alteration while in transit.",
      "ja": "Auth_Sys認証フレーバーが使用されている場合、TLS保護されたトランスポートを使用して、Auth_Sysのいくつかの長年の弱点（付録Aで詳細に記載されています）。TLSは、Auth_Sysが欠けている整合性の保護と機密性の両方を提供することにより、Auth_Sysを増強します。TLSは、輸送中の監視と変更に対してデータペイロード、RPCヘッダー、およびユーザーIDを保護します。"
    },
    {
      "indent": 3,
      "text": "TLS guards against in-transit insertion and deletion of RPC messages, thus ensuring the integrity of the message stream between RPC client and server. DTLS does not provide full message stream protection, but it does enable receivers to reject nonparticipant messages. In particular, transport-layer encryption plus peer authentication protects receiving eXternal Data Representation (XDR) decoders from deserializing untrusted data, a common coding vulnerability. However, these decoders would still be exposed to untrusted input in the case of the compromise of a trusted peer or Certification Authority.",
      "ja": "TLSは、RPCメッセージの輸送内挿入と削除に対してガードされ、RPCクライアントとサーバー間のメッセージストリームの整合性を確保します。DTLSは完全なメッセージストリーム保護を提供しませんが、受信者が参加者以外のメッセージを拒否できるようにします。特に、輸送層の暗号化とピア認証は、一般的なコーディングの脆弱性である、信頼されていないデータの脱気を離すことから、外部データ表現（XDR）デコーダーの受信を保護します。ただし、これらのデコーダーは、信頼できるピアまたは認定機関の妥協の場合、信頼されていない入力にさらされます。"
    },
    {
      "indent": 3,
      "text": "The use of TLS enables strong authentication of the communicating RPC peers, providing a degree of non-repudiation. When AUTH_SYS is used with TLS, but the RPC client is unauthenticated, the RPC server still acts on RPC requests for which there is no trustworthy authentication. In-transit traffic is protected, but the RPC client itself can still misrepresent user identity without server detection. TLS without authentication is an improvement from AUTH_SYS without encryption, but it leaves a critical security exposure.",
      "ja": "TLSを使用すると、通信RPCピアの強力な認証が可能になり、ある程度の非repudiationが提供されます。auth_sysがTLSで使用されているが、RPCクライアントが認証されていない場合、RPCサーバーは依然として信頼できる認証がないRPCリクエストに作用します。輸送中のトラフィックは保護されていますが、RPCクライアント自体は、サーバー検出なしでユーザーIDを誤って伝えます。認証のないTLSは、暗号化なしのauth_sysからの改善ですが、重大なセキュリティエクスポージャーを残します。"
    },
    {
      "indent": 3,
      "text": "In light of the above, when AUTH_SYS is used, the use of a TLS mutual authentication mechanism is RECOMMENDED to prove that the RPC client is known to the RPC server. The server can then determine whether the UIDs and GIDs in AUTH_SYS requests from that client can be accepted, based on the authenticated identity of the client.",
      "ja": "上記に照らして、auth_sysを使用すると、RPCクライアントがRPCサーバーに知られていることを証明するために、TLS相互認証メカニズムの使用が推奨されます。サーバーは、クライアントの認証されたアイデンティティに基づいて、そのクライアントからのauth_sys要求のuidとgidsが受け入れることができるかどうかを判断できます。"
    },
    {
      "indent": 3,
      "text": "The use of TLS does not enable RPC clients to detect compromise that leads to the impersonation of RPC users. Also, there continues to be a requirement that the mapping of 32-bit user and group ID values to user identities is the same on both the RPC client and server.",
      "ja": "TLSを使用しても、RPCクライアントがRPCユーザーのなりすましにつながる妥協を検出することはできません。また、32ビットユーザーとグループID値のユーザーID値のマッピングが、RPCクライアントとサーバーの両方で同じであるという要件があり続けています。"
    },
    {
      "indent": 0,
      "text": "6.4. Best Security Policy Practices",
      "section_title": true,
      "ja": "6.4. 最良のセキュリティポリシー慣行"
    },
    {
      "indent": 3,
      "text": "RPC-with-TLS implementations and deployments are strongly encouraged to adhere to the following policies to achieve the strongest possible security with RPC-with-TLS.",
      "ja": "RPC-TLSの実装と展開は、RPC-TLSで可能な限り強力なセキュリティを達成するために、以下のポリシーを遵守することを強くお勧めします。"
    },
    {
      "indent": 3,
      "text": "* When using AUTH_NULL or AUTH_SYS, both peers are RECOMMENDED to have DNSSEC TLSA records, keys with which to perform mutual peer authentication using one of the methods described in Section 5.2, and a security policy that requires mutual peer authentication and rejection of a connection when host authentication fails.",
      "ja": "* auth_nullまたはauth_sysを使用する場合、両方のピアがDNSSEC TLSAレコード、セクション5.2で説明されている方法のいずれかを使用して相互ピア認証を実行するキー、およびホストの場合に相互ピア認証とホストの接続の拒否を必要とするセキュリティポリシーを使用することをお勧めします。認証は失敗します。"
    },
    {
      "indent": 3,
      "text": "* RPCSEC_GSS provides integrity and privacy services that are largely redundant when TLS is in use. These services SHOULD be disabled in that case.",
      "ja": "* RPCSEC_GSSは、TLSが使用されているときに大部分が冗長である整合性とプライバシーサービスを提供します。これらのサービスは、その場合に無効にする必要があります。"
    },
    {
      "indent": 0,
      "text": "7. IANA Considerations",
      "section_title": true,
      "ja": "7. IANAの考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. RPC Authentication Flavor",
      "section_title": true,
      "ja": "7.1. RPC認証フレーバー"
    },
    {
      "indent": 3,
      "text": "Following Appendix B of [RFC5531], an entry has been added to the \"RPC Authentication Flavor Numbers\" registry. The purpose of the new authentication flavor is to signal the use of TLS with RPC. This new flavor is not a pseudo-flavor.",
      "ja": "[RFC5531]の付録Bに従って、「RPC認証フレーバー番号」レジストリにエントリが追加されました。新しい認証フレーバーの目的は、RPCでTLSの使用を通知することです。この新しいフレーバーは擬似風味ではありません。"
    },
    {
      "indent": 3,
      "text": "The fields in the new entry have been assigned as follows:",
      "ja": "新しいエントリのフィールドは次のように割り当てられています。"
    },
    {
      "indent": 3,
      "text": "Identifier String: AUTH_TLS",
      "ja": "識別子文字列：auth_tls"
    },
    {
      "indent": 3,
      "text": "Flavor Name: TLS",
      "ja": "フレーバー名：TLS"
    },
    {
      "indent": 3,
      "text": "Value: 7",
      "ja": "値：7"
    },
    {
      "indent": 3,
      "text": "Description: Indicates support for RPC-with-TLS",
      "ja": "説明：RPC-With-TLSのサポートを示します"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 9289",
      "ja": "参照：RFC 9289"
    },
    {
      "indent": 0,
      "text": "7.2. ALPN Identifier for SunRPC",
      "section_title": true,
      "ja": "7.2. sunrpcのalpn識別子"
    },
    {
      "indent": 3,
      "text": "Following Section 6 of [RFC7301], the following value has been allocated in the \"TLS Application-Layer Protocol Negotiation (ALPN) Protocol IDs\" registry. The \"sunrpc\" string identifies SunRPC when used over TLS.",
      "ja": "[RFC7301]のセクション6に従って、「TLSアプリケーションレイヤープロトコルネゴシエーション（ALPN）プロトコルID」レジストリで次の値が割り当てられています。「sunrpc」文字列は、TLSを介して使用するとSunRPCを識別します。"
    },
    {
      "indent": 3,
      "text": "Protocol: SunRPC",
      "ja": "プロトコル：sunrpc"
    },
    {
      "indent": 3,
      "text": "Identification Sequence: 0x73 0x75 0x6e 0x72 0x70 0x63 (\"sunrpc\")",
      "ja": "識別シーケンス：0x73 0x75 0x6e 0x72 0x70 0x63（ \"sunrpc\"）"
    },
    {
      "indent": 3,
      "text": "Reference: RFC 9289",
      "ja": "参照：RFC 9289"
    },
    {
      "indent": 0,
      "text": "7.3. Object Identifier for PKIX Extended Key Usage",
      "section_title": true,
      "ja": "7.3. PKIXのオブジェクト識別子は、キー使用量を延長しました"
    },
    {
      "indent": 3,
      "text": "Per the Specification Required policy defined in Section 4.6 of [RFC8126], the following new values have been registered in the \"SMI Security for PKIX Extended Key Purpose\" registry (1.3.6.1.5.5.7.3) (see Section 5.2.1.1 and Appendix B).",
      "ja": "[RFC8126]のセクション4.6で定義されている必要なポリシーに従って、次の新しい値は、「PKIX拡張キー目的のSMIセキュリティ」レジストリ（1.3.6.1.1.5.5.7.3）に登録されています（セクション5.2.1.1および付録を参照b）。"
    },
    {
      "indent": 15,
      "text": "+=========+====================+===========+\n| Decimal | Description        | Reference |\n+=========+====================+===========+\n| 33      | id-kp-rpcTLSClient | RFC 9289  |\n+---------+--------------------+-----------+\n| 34      | id-kp-rpcTLSServer | RFC 9289  |\n+---------+--------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 1",
      "ja": "表1"
    },
    {
      "indent": 0,
      "text": "7.4. Object Identifier for ASN.1 Module",
      "section_title": true,
      "ja": "7.4. ASN.1モジュールのオブジェクト識別子"
    },
    {
      "indent": 3,
      "text": "Per the Specification Required policy defined in Section 4.6 of [RFC8126], the following new value has been registered in the \"SMI Security for PKIX Module Identifier\" registry (1.3.6.1.5.5.7.0) (see Appendix B).",
      "ja": "[RFC8126]のセクション4.6で定義されている仕様が必要なポリシーに従って、「PKIXモジュール識別子のSMIセキュリティ」レジストリ（1.3.6.1.1.5.5.7.0）に次の新しい値が登録されています（付録Bを参照）。"
    },
    {
      "indent": 13,
      "text": "+=========+========================+===========+\n| Decimal | Description            | Reference |\n+=========+========================+===========+\n| 105     | id-mod-rpcWithTLS-2021 | RFC 9289  |\n+---------+------------------------+-----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 33,
      "text": "Table 2",
      "ja": "表2"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC5056] Williams, N., \"On the Use of Channel Bindings to Secure Channels\", RFC 5056, DOI 10.17487/RFC5056, November 2007, <https://www.rfc-editor.org/info/rfc5056>.",
      "ja": "[RFC5056]ウィリアムズ、N。、「チャネルバインディングの使用に関するチャネルの使用について」、RFC 5056、DOI 10.17487/RFC5056、2007年11月、<https://www.rfc-editor.org/info/rfc5056>。"
    },
    {
      "indent": 3,
      "text": "[RFC5280] Cooper, D., Santesson, S., Farrell, S., Boeyen, S., Housley, R., and W. Polk, \"Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile\", RFC 5280, DOI 10.17487/RFC5280, May 2008, <https://www.rfc-editor.org/info/rfc5280>.",
      "ja": "[RFC5280] Cooper、D.、Santesson、S.、Farrell、S.、Boeyen、S.、Housley、R.、およびW. Polk、 \"Internet X.509公開キーインフラストラクチャ証明書および証明書失効リスト（CRL）プロファイル\"、RFC 5280、DOI 10.17487/RFC5280、2008年5月、<https://www.rfc-editor.org/info/rfc5280>。"
    },
    {
      "indent": 3,
      "text": "[RFC5531] Thurlow, R., \"RPC: Remote Procedure Call Protocol Specification Version 2\", RFC 5531, DOI 10.17487/RFC5531, May 2009, <https://www.rfc-editor.org/info/rfc5531>.",
      "ja": "[RFC5531] Thurlow、R。、 \"RPC：リモートプロシージャコールプロトコル仕様バージョン2\"、RFC 5531、DOI 10.17487/RFC5531、2009年5月<https://www.rfc-editor.org/info/rfc5531>"
    },
    {
      "indent": 3,
      "text": "[RFC6125] Saint-Andre, P. and J. Hodges, \"Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)\", RFC 6125, DOI 10.17487/RFC6125, March 2011, <https://www.rfc-editor.org/info/rfc6125>.",
      "ja": "[RFC6125] Saint-Andre、P。およびJ. Hodges、「輸送層のセキュリティ（TLS）のコンテキストでX.509（PKIX）証明書を使用したインターネット公開キーインフラストラクチャ内のドメインベースのアプリケーションサービスIDの表現と検証」、RFC 6125、DOI 10.17487/RFC6125、2011年3月、<https://www.rfc-editor.org/info/rfc6125>。"
    },
    {
      "indent": 3,
      "text": "[RFC7301] Friedl, S., Popov, A., Langley, A., and E. Stephan, \"Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension\", RFC 7301, DOI 10.17487/RFC7301, July 2014, <https://www.rfc-editor.org/info/rfc7301>.",
      "ja": "[RFC7301] Friedl、S.、Popov、A.、Langley、A。、およびE. Stephan、「輸送層セキュリティ（TLS）アプリケーション層プロトコル交渉拡張」、RFC 7301、DOI 10.17487/RFC7301、2014年7月、<https://www.rfc-editor.org/info/rfc7301>。"
    },
    {
      "indent": 3,
      "text": "[RFC7525] Sheffer, Y., Holz, R., and P. Saint-Andre, \"Recommendations for Secure Use of Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525, May 2015, <https://www.rfc-editor.org/info/rfc7525>.",
      "ja": "[RFC7525] Sheffer、Y.、Holz、R。、およびP. Saint-Andre、「輸送層セキュリティ（TLS）およびデータグラム輸送層セキュリティ（DTLS）の安全な使用に関する推奨事項」、BCP 195、RFC 7525、DOI 10.17487/RFC7525、2015年5月、<https://www.rfc-editor.org/info/rfc7525>。"
    },
    {
      "indent": 3,
      "text": "[RFC8126] Cotton, M., Leiba, B., and T. Narten, \"Guidelines for Writing an IANA Considerations Section in RFCs\", BCP 26, RFC 8126, DOI 10.17487/RFC8126, June 2017, <https://www.rfc-editor.org/info/rfc8126>.",
      "ja": "[RFC8126] Cotton、M.、Leiba、B。、およびT. Narten、「RFCSでIANA考慮事項セクションを書くためのガイドライン」、BCP 26、RFC 8126、DOI 10.17487/RFC8126、2017年6月、<https：// wwwwwwwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc8126>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 3,
      "text": "[RFC9147] Rescorla, E., Tschofenig, H., and N. Modadugu, \"The Datagram Transport Layer Security (DTLS) Protocol Version 1.3\", RFC 9147, DOI 10.17487/RFC9147, April 2022, <https://www.rfc-editor.org/info/rfc9147>.",
      "ja": "[RFC9147] Rescorla、E.、Tschofenig、H。、およびN. Modadugu、「データグラム輸送層セキュリティ（DTLS）プロトコルバージョン1.3」、RFC 9147、DOI 10.17487/RFC9147、2022年4月、<https：// www。rfc-editor.org/info/rfc9147>。"
    },
    {
      "indent": 3,
      "text": "[RFC9266] Whited, S., \"Channel Bindings for TLS 1.3\", RFC 9266, DOI 10.17487/RFC9266, July 2022, <https://www.rfc-editor.org/info/rfc9266>.",
      "ja": "[RFC9266] Whited、S。、「TLS 1.3用チャネルバインディング」、RFC 9266、DOI 10.17487/RFC9266、2022年7月、<https://www.rfc-editor.org/info/rfc9266>。"
    },
    {
      "indent": 3,
      "text": "[X.509] International Telecommunication Union, \"Information technology - Open Systems Interconnection - The Directory: Public-key and attribute certificate frameworks\", ISO/ IEC 9594-8, ITU-T Recommendation X.509, October 2019.",
      "ja": "[X.509] International Telecommunication Union、「情報技術 - オープンシステムの相互接続 - ディレクトリ：パブリックキーおよび属性証明書フレームワーク」、ISO/ IEC 9594-8、ITU-T推奨X.509、2019年10月。"
    },
    {
      "indent": 3,
      "text": "[X.680] ITU-T, \"Information technology - Abstract Syntax Notation One (ASN.1): Specification of basic notation\", ITU-T Recommendation X.680, February 2021, <https://www.itu.int/rec/T-REC-X.680>.",
      "ja": "[X.680] ITU-T、「情報技術 - 要約構文表記1（ASN.1）：基本表記の仕様」、ITU-T推奨X.680、2021年2月、<https://www.itu.int/REC/T-REC-X.680>。"
    },
    {
      "indent": 3,
      "text": "[X.690] ITU-T, \"Information technology - ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER)\", ITU-T Recommendation X.690, February 2021, <https://www.itu.int/rec/T-REC-X.690>.",
      "ja": "[X.690] ITU-T、「情報技術-ASN.1エンコーディングルール：基本エンコードルール（BER）、標準エンコードルール（CER）および識別型エンコードルール（DER）の仕様」、ITU-T推奨X.690、2021年2月、<https://www.itu.int/rec/t-rec-x.690>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[RFC1833] Srinivasan, R., \"Binding Protocols for ONC RPC Version 2\", RFC 1833, DOI 10.17487/RFC1833, August 1995, <https://www.rfc-editor.org/info/rfc1833>.",
      "ja": "[RFC1833] Srinivasan、R。、「ONC RPCバージョン2の結合プロトコル」、RFC 1833、DOI 10.17487/RFC1833、1995年8月、<https://www.rfc-editor.org/info/rfc1833>"
    },
    {
      "indent": 3,
      "text": "[RFC2203] Eisler, M., Chiu, A., and L. Ling, \"RPCSEC_GSS Protocol Specification\", RFC 2203, DOI 10.17487/RFC2203, September 1997, <https://www.rfc-editor.org/info/rfc2203>.",
      "ja": "[RFC2203] Eisler、M.、Chiu、A。、およびL. Ling、「RPCSEC_GSSプロトコル仕様」、RFC 2203、DOI 10.17487/RFC2203、1997年9月、<https://www.rfc-editor.org/info/RFC2203>。"
    },
    {
      "indent": 3,
      "text": "[RFC6698] Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication of Named Entities (DANE) Transport Layer Security (TLS) Protocol: TLSA\", RFC 6698, DOI 10.17487/RFC6698, August 2012, <https://www.rfc-editor.org/info/rfc6698>.",
      "ja": "[RFC6698] Hoffman、P。and J. Schlyter、「名前付きエンティティ（DANE）輸送層セキュリティ（TLS）プロトコルのDNSベースの認証」、TLSA：RFC 6698、DOI 10.17487/RFC6698、2012年8月、<HTTPS：//www.rfc-editor.org/info/rfc6698>。"
    },
    {
      "indent": 3,
      "text": "[RFC6973] Cooper, A., Tschofenig, H., Aboba, B., Peterson, J., Morris, J., Hansen, M., and R. Smith, \"Privacy Considerations for Internet Protocols\", RFC 6973, DOI 10.17487/RFC6973, July 2013, <https://www.rfc-editor.org/info/rfc6973>.",
      "ja": "[RFC6973] Cooper、A.、Tschofenig、H.、Aboba、B.、Peterson、J.、Morris、J.、Hansen、M。、およびR. Smith、「インターネットプロトコルのプライバシーに関する考慮事項」、RFC 6973、doi10.17487/rfc6973、2013年7月、<https://www.rfc-editor.org/info/rfc6973>。"
    },
    {
      "indent": 3,
      "text": "[RFC7258] Farrell, S. and H. Tschofenig, \"Pervasive Monitoring Is an Attack\", BCP 188, RFC 7258, DOI 10.17487/RFC7258, May 2014, <https://www.rfc-editor.org/info/rfc7258>.",
      "ja": "[RFC7258] Farrell、S。およびH. Tschofenig、「広範な監視は攻撃です」、BCP 188、RFC 7258、DOI 10.17487/RFC7258、2014年5月<https：//www.rfc-editor.org/info/rfc72588>。"
    },
    {
      "indent": 3,
      "text": "[RFC7435] Dukhovni, V., \"Opportunistic Security: Some Protection Most of the Time\", RFC 7435, DOI 10.17487/RFC7435, December 2014, <https://www.rfc-editor.org/info/rfc7435>.",
      "ja": "[RFC7435] Dukhovni、V。、「日和見的セキュリティ：ほとんどの場合、一部の保護」、RFC 7435、DOI 10.17487/RFC7435、2014年12月、<https://www.rfc-editor.org/info/rfc7435>"
    },
    {
      "indent": 3,
      "text": "[RFC8166] Lever, C., Ed., Simpson, W., and T. Talpey, \"Remote Direct Memory Access Transport for Remote Procedure Call Version 1\", RFC 8166, DOI 10.17487/RFC8166, June 2017, <https://www.rfc-editor.org/info/rfc8166>.",
      "ja": "[RFC8166] Lever、C.、Ed。、Simpson、W.、およびT. Talpey、「リモートダイレクトメモリアクセストランスポートコールバージョン1」、RFC 8166、DOI 10.17487/RFC8166、2017年6月、<https：//www.rfc-editor.org/info/rfc8166>。"
    },
    {
      "indent": 3,
      "text": "[RFC8167] Lever, C., \"Bidirectional Remote Procedure Call on RPC-over-RDMA Transports\", RFC 8167, DOI 10.17487/RFC8167, June 2017, <https://www.rfc-editor.org/info/rfc8167>.",
      "ja": "[RFC8167] Lever、C。、「RPC-Over-RDMA Transportsの双方向リモート手順コール」、RFC 8167、DOI 10.17487/RFC8167、2017年6月、<https://www.rfc-editor.org/info/rfc8167>。"
    },
    {
      "indent": 3,
      "text": "[RFC8899] Fairhurst, G., Jones, T., Tüxen, M., Rüngeler, I., and T. Völker, \"Packetization Layer Path MTU Discovery for Datagram Transports\", RFC 8899, DOI 10.17487/RFC8899, September 2020, <https://www.rfc-editor.org/info/rfc8899>.",
      "ja": "[RFC8899] Fairhurst、G.、Jones、T.、Tüxen、M.、Rüngeler、I。、およびT.Völker、「Datagram Transports for Datagram TransportsのPacketization Layer Path Mtu Discovery」、DOI 10.17487/RFC8899、2020年9月、2020年9月、<https://www.rfc-editor.org/info/rfc8899>。"
    },
    {
      "indent": 3,
      "text": "[RFC9110] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[RFC9110] Fielding、R.、Ed。、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https：//www.rfc-editor.org/info/rfc9110>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Known Weaknesses of the AUTH_SYS Authentication Flavor",
      "ja": "付録A. auth_sys認証フレーバーの既知の弱点"
    },
    {
      "indent": 3,
      "text": "The ONC RPC protocol, as specified in [RFC5531], provides several modes of security, commonly referred to as \"authentication flavors\". Some of these flavors provide much more than an authentication service. We refer to these as authentication flavors, security flavors, or simply, flavors. One of the earliest and most basic flavors is AUTH_SYS, also known as AUTH_UNIX. Appendix A of [RFC5531] specifies AUTH_SYS.",
      "ja": "[RFC5531]で指定されているONC RPCプロトコルは、一般に「認証フレーバー」と呼ばれるいくつかのセキュリティモードを提供します。これらのフレーバーの一部は、認証サービス以上のものを提供します。これらを認証フレーバー、セキュリティフレーバー、または単にフレーバーと呼びます。最も早く、最も基本的なフレーバーの1つは、auth_unixとも呼ばれるauth_sysです。[RFC5531]の付録Aは、auth_sysを指定しています。"
    },
    {
      "indent": 3,
      "text": "AUTH_SYS assumes that the RPC client and server both use POSIX-style user and group identifiers (each user and group can be distinctly represented as a 32-bit unsigned integer). It also assumes that the client and server both use the same mapping of user and group to an integer. One user ID, one primary group ID, and up to 16 supplemental group IDs are associated with each RPC request. The combination of these identifies the entity on the client that is making the request.",
      "ja": "Auth_Sysは、RPCクライアントとサーバーの両方がPOSIXスタイルのユーザーとグループ識別子を使用していると想定しています（各ユーザーとグループは、32ビットの非署名整数として明確に表現できます）。また、クライアントとサーバーの両方がユーザーとグループと整数に同じマッピングを使用していると想定しています。1つのユーザーID、1つのプライマリグループID、および最大16の補足グループIDが各RPC要求に関連付けられています。これらの組み合わせは、リクエストを行っているクライアントのエンティティを識別します。"
    },
    {
      "indent": 3,
      "text": "A string identifies peers (hosts) in each RPC request. [RFC5531] does not specify any requirements for this string other than that it is no longer than 255 octets. It does not have to be the same from request to request. Also, it does not have to match the DNS hostname of the sending host. For these reasons, even though most implementations fill in their hostname in this field, receivers typically ignore its content.",
      "ja": "文字列は、各RPC要求でピア（ホスト）を識別します。[RFC5531]は、255オクテット以外のこの文字列以外の要件を指定していません。リクエストからリクエストまで同じである必要はありません。また、送信ホストのDNSホスト名と一致する必要はありません。これらの理由により、ほとんどの実装はこのフィールドのホスト名を埋めますが、レシーバーは通常、コンテンツを無視します。"
    },
    {
      "indent": 3,
      "text": "Appendix A of [RFC5531] contains a brief explanation of security considerations:",
      "ja": "[RFC5531]の付録Aには、セキュリティに関する考慮事項の簡単な説明が含まれています。"
    },
    {
      "indent": 18,
      "text": "It should be noted that use of this flavor of authentication does not guarantee any security for the users or providers of a service, in itself. The authentication provided by this scheme can be considered legitimate only when applications using this scheme and the network can be secured externally, and privileged transport addresses are used for the communicating end-points (an example of this is the use of privileged TCP/UDP ports in UNIX systems -- note that not all systems enforce privileged transport address mechanisms).",
      "ja": "この認証フレーバーの使用は、サービスのユーザーまたはプロバイダー自体のセキュリティを保証しないことに注意する必要があります。このスキームによって提供される認証は、このスキームを使用してネットワークを使用して外部から保護できる場合にのみ合法と見なされ、特権輸送アドレスが通信エンドポイントに使用されます（この例は、特権TCP/UDPポートの使用ですUNIXシステムでは、すべてのシステムが特権輸送アドレスメカニズムを強制しているわけではないことに注意してください）。"
    },
    {
      "indent": 3,
      "text": "It should be clear, therefore, that AUTH_SYS by itself (i.e., without strong client authentication) offers little to no communication security:",
      "ja": "したがって、auth_sys自体（つまり、強力なクライアント認証なしで）がコミュニケーションセキュリティをほとんどまたはまったく提供しないことは明らかです。"
    },
    {
      "indent": 3,
      "text": "1. It does not protect the confidentiality or integrity of RPC requests, users, or payloads, relying instead on \"external\" security.",
      "ja": "1. RPC要求、ユーザー、またはペイロードの機密性や整合性を保護せず、代わりに「外部」セキュリティに依存しています。"
    },
    {
      "indent": 3,
      "text": "2. It does not provide authentication of RPC peer machines, other than inclusion of an unprotected domain name.",
      "ja": "2. 保護されていないドメイン名を含める以外に、RPCピアマシンの認証は提供されません。"
    },
    {
      "indent": 3,
      "text": "3. The use of 32-bit unsigned integers as user and group identifiers is problematic because these data types are not cryptographically signed or otherwise verified by any authority. In addition, the mapping of these integers to users and groups has to be consistent amongst a server and its cohort of clients.",
      "ja": "3. これらのデータ型が暗号化されていないか、当局によって検証されていないため、ユーザーおよびグループ識別子としての32ビットの署名整数の使用には問題があります。さらに、これらの整数のユーザーとグループへのマッピングは、サーバーとそのクライアントのコホートの間で一貫している必要があります。"
    },
    {
      "indent": 3,
      "text": "4. Because the user and group ID fields are not integrity protected, AUTH_SYS does not provide non-repudiation.",
      "ja": "4. ユーザーとグループIDフィールドは整合性保護されていないため、auth_sysは非控除を提供しません。"
    },
    {
      "indent": 0,
      "text": "Appendix B. ASN.1 Module",
      "section_title": true,
      "ja": "付録B. ASN.1モジュール"
    },
    {
      "indent": 3,
      "text": "The following module adheres to ASN.1 specifications [X.680] and [X.690].",
      "ja": "次のモジュールは、ASN.1仕様[X.680]および[X.690]に準拠しています。"
    },
    {
      "indent": 3,
      "text": "<CODE BEGINS>\nRPCwithTLS-2021\n  { iso(1) identified-organization(3) dod(6) internet(1)\n  security(5) mechanisms(5) pkix(7) id-mod(0)\n  id-mod-rpcWithTLS-2021(105) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "DEFINITIONS IMPLICIT TAGS ::=\nBEGIN",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- OID Arc",
      "ja": "-OIDアーク"
    },
    {
      "indent": 3,
      "text": "id-kp OBJECT IDENTIFIER ::=\n  { iso(1) identified-organization(3) dod(6) internet(1)\n    security(5) mechanisms(5) pkix(7) kp(3) }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "-- Extended Key Usage Values",
      "ja": " - 拡張されたキー使用値"
    },
    {
      "indent": 3,
      "text": "id-kp-rpcTLSClient OBJECT IDENTIFIER ::= { id-kp 33 }\nid-kp-rpcTLSServer OBJECT IDENTIFIER ::= { id-kp 34 }",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "END <CODE ENDS>",
      "ja": "End <Code End>"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "Special mention goes to Charles Fisher, author of \"Encrypting NFSv4 with Stunnel TLS\" <https://www.linuxjournal.com/content/encrypting-nfsv4-stunnel-tls>. His article inspired the mechanism described in the current document.",
      "ja": "「Stunnel TLSでNFSV4を暗号化する」<https://www.linuxjournal.com/content/encrypting-nfsv4-stunnel-tls>の著者であるチャールズ・フィッシャーに特別な言及があります。彼の記事は、現在の文書に記載されているメカニズムに影響を与えました。"
    },
    {
      "indent": 3,
      "text": "Many thanks to Benjamin Coddington, Tigran Mkrtchyan, and Rick Macklem for their work on prototype implementations and feedback on the current document. Also, thanks to Benjamin Kaduk for his expert guidance on the use of PKIX and TLS and to Russ Housley for his ASN.1 expertise and for providing other proper finishing touches. In addition, the authors thank the other members of the IESG for their astute review comments. These contributors made this a significantly better document.",
      "ja": "ベンジャミン・コディントン、ティグラン・ムクリチャン、リック・マックレムに、現在の文書に関するプロトタイプの実装とフィードバックに関する作業に感謝します。また、PKIXとTLSの使用に関する専門家のガイダンスと、彼のASN.1の専門知識と他の適切な仕上げを提供してくれたRuss Housleyに感謝します。さらに、著者は、IESGの他のメンバーに、鋭いレビューコメントをしてくれたことに感謝します。これらの貢献者は、これを非常に優れたドキュメントにしました。"
    },
    {
      "indent": 3,
      "text": "Thanks to Derrell Piper for numerous suggestions that improved both this simple mechanism and the current document's security-related discussion.",
      "ja": "この単純なメカニズムと現在の文書のセキュリティ関連の議論の両方を改善した多くの提案をしてくれたDerrell Piperに感謝します。"
    },
    {
      "indent": 3,
      "text": "Many thanks to Transport Area Director Magnus Westerlund for his sharp questions and careful reading of the final revisions of the current document. The text of Section 5.1.2 is mostly his contribution.",
      "ja": "輸送エリアディレクターのマグナスウェスターランドの鋭い質問と、現在の文書の最終的な改訂を慎重に読んでくれたことに感謝します。セクション5.1.2のテキストは、主に彼の貢献です。"
    },
    {
      "indent": 3,
      "text": "The authors are additionally grateful to Bill Baker, David Black, Alan DeKok, Lars Eggert, Olga Kornievskaia, Greg Marsden, Alex McDonald, Justin Mazzola Paluska, Tom Talpey, Martin Thomson, and Nico Williams for their input and support of this work.",
      "ja": "著者は、ビル・ベイカー、デビッド・ブラック、アラン・デコク、ラース・エガート、オルガ・コルニエフスカイア、グレッグ・マースデン、アレックス・マクドナルド、ジャスティン・マッツァーラ・パルスカ、トム・タルピー、マーティン・トムソン、ニコ・ウィリアムズのこの仕事のサポートに感謝しています。"
    },
    {
      "indent": 3,
      "text": "Finally, special thanks to NFSV4 Working Group Chair and document shepherd David Noveck, NFSV4 Working Group Chairs Spencer Shepler and Brian Pawlowski, and NFSV4 Working Group Secretary Thomas Haynes for their guidance and oversight.",
      "ja": "最後に、NFSV4ワーキンググループチェアとドキュメントシェパードのデイビッド・ノヴェック、NFSV4ワーキンググループチェアのスペンサー・シェプラーとブライアン・パウロウスキ、およびNFSV4ワーキンググループ秘書のトーマス・ヘインズの指導と監視に感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Trond Myklebust Hammerspace Inc. 4300 El Camino Real, Suite 105 Los Altos, CA 94022 United States of America Email: trond.myklebust@hammerspace.com",
      "ja": "TROND MYKLEBUST HAMMERSPACE INC. 4300 EL CAMINO REAL、SUITE 105 LOS ALTOS、CA 94022アメリカ合衆国電子メール：trond.myklebust@hammerspace.com"
    },
    {
      "indent": 3,
      "text": "Charles Lever (editor) Oracle Corporation United States of America Email: chuck.lever@oracle.com",
      "ja": "チャールズ・レバー（編集者）Oracle Corporationアメリカ合衆国電子メール：chuck.lever@oracle.com"
    }
  ]
}