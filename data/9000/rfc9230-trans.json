{
  "title": {
    "text": "RFC 9230 - Oblivious DNS over HTTPS (RFC 9230)",
    "ja": "RFC 9230 - HTTPS上の忘却のDNS（RFC 9230）"
  },
  "number": 9230,
  "created_at": "2022-06-28 02:59:03.801073+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Independent Submission                                        E. Kinnear\nRequest for Comments: 9230                                    Apple Inc.\nCategory: Experimental                                        P. McManus\nISSN: 2070-1721                                                   Fastly\n                                                                T. Pauly\n                                                              Apple Inc.\n                                                                T. Verma\n                                                               C.A. Wood\n                                                              Cloudflare\n                                                               June 2022",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 24,
      "text": "Oblivious DNS over HTTPS",
      "ja": "https上の忘却DNS"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes a protocol that allows clients to hide their IP addresses from DNS resolvers via proxying encrypted DNS over HTTPS (DoH) messages. This improves privacy of DNS operations by not allowing any one server entity to be aware of both the client IP address and the content of DNS queries and answers.",
      "ja": "このドキュメントでは、HTTPS（DOH）メッセージを介して暗号化されたDNSをプロキシを介して、クライアントがDNSリゾルバーからIPアドレスを非表示にできるプロトコルについて説明します。これにより、1つのサーバーエンティティがクライアントIPアドレスとDNSクエリと回答のコンテンツの両方を認識できないようにすることにより、DNS操作のプライバシーが向上します。"
    },
    {
      "indent": 3,
      "text": "This experimental protocol has been developed outside the IETF and is published here to guide implementation, ensure interoperability among implementations, and enable wide-scale experimentation.",
      "ja": "この実験プロトコルはIETFの外部で開発されており、実装をガイドし、実装間の相互運用性を確保し、幅広い実験を可能にするためにここで公開されています。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for examination, experimental implementation, and evaluation.",
      "ja": "このドキュメントは、インターネット標準の追跡仕様ではありません。試験、実験的実装、および評価のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document defines an Experimental Protocol for the Internet community. This is a contribution to the RFC Series, independently of any other RFC stream. The RFC Editor has chosen to publish this document at its discretion and makes no statement about its value for implementation or deployment. Documents approved for publication by the RFC Editor are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "このドキュメントは、インターネットコミュニティの実験プロトコルを定義しています。これは、他のRFCストリームとは無関係に、RFCシリーズへの貢献です。RFCエディターは、このドキュメントの裁量でこのドキュメントを公開することを選択しており、実装または展開に対する価値について声明を発表しません。RFCエディターによって公開が承認されたドキュメントは、インターネット標準のレベルの候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9230.",
      "ja": "このドキュメントの現在のステータス、任意のERRATA、およびそのフィードバックを提供する方法に関する情報は、https：//www.rfc-editor.org/info/rfc9230で取得できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2022 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（c）2022 IETF Trustおよび文書著者として特定された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "このドキュメントは、BCP 78およびIETFドキュメント（https://trustee.ietf.org/license-info）に関連するIETF Trustの法的規定の対象となります。この文書に関するあなたの権利と制限を説明するので、これらの文書を注意深く確認してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Specification of Requirements\n2.  Terminology\n3.  Deployment Requirements\n4.  HTTP Exchange\n  4.1.  HTTP Request\n  4.2.  HTTP Request Example\n  4.3.  HTTP Response\n  4.4.  HTTP Response Example\n  4.5.  HTTP Metadata\n5.  Configuration and Public Key Format\n6.  Protocol Encoding\n  6.1.  Message Format\n  6.2.  Encryption and Decryption Routines\n7.  Oblivious Client Behavior\n8.  Oblivious Target Behavior\n9.  Compliance Requirements\n10. Experiment Overview\n11. Security Considerations\n  11.1.  Denial of Service\n  11.2.  Proxy Policies\n  11.3.  Authentication\n12. IANA Considerations\n  12.1.  Oblivious DoH Message Media Type\n13. References\n  13.1.  Normative References\n  13.2.  Informative References\nAppendix A.  Use of Generic Proxy Services\nAcknowledgments\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "DNS over HTTPS (DoH) [RFC8484] defines a mechanism to allow DNS messages to be transmitted in HTTP messages protected with TLS. This provides improved confidentiality and authentication for DNS interactions in various circumstances.",
      "ja": "HTTPS（DOH）[RFC8484]上のDNSは、TLSで保護されたHTTPメッセージでDNSメッセージを送信できるメカニズムを定義します。これにより、さまざまな状況でのDNS相互作用の機密性と認証が向上します。"
    },
    {
      "indent": 3,
      "text": "While DoH can prevent eavesdroppers from directly reading the contents of DNS exchanges, clients cannot send DNS queries to and receive answers from servers without revealing their local IP address (and thus information about the identity or location of the client) to the server.",
      "ja": "DOHは盗聴者がDNS取引所のコンテンツを直接読み取ることを防ぐことができますが、クライアントはローカルIPアドレス（したがってクライアントの身元または場所に関する情報）をサーバーに明らかにすることなく、サーバーからDNSクエリを送信して回答を受信することはできません。"
    },
    {
      "indent": 3,
      "text": "Proposals such as Oblivious DNS [OBLIVIOUS-DNS] increase privacy by ensuring that no single DNS server is aware of both the client IP address and the message contents.",
      "ja": "Oblivious DNS [Oblivious-DNS]などの提案は、単一のDNSサーバーがクライアントIPアドレスとメッセージコンテンツの両方を認識していないことを確認することにより、プライバシーを増やします。"
    },
    {
      "indent": 3,
      "text": "This document defines Oblivious DoH, an experimental protocol built on DoH that permits proxied resolution, in which DNS messages are encrypted so that no server can independently read both the client IP address and the DNS message contents.",
      "ja": "このドキュメントでは、DOH上に構築された実験的なプロトコルであるOblivious DOHを定義します。これにより、DNSメッセージが暗号化されているため、サーバーがクライアントIPアドレスとDNSメッセージの内容の両方を個別に読み取ることができないようになります。"
    },
    {
      "indent": 3,
      "text": "As with DoH, DNS messages exchanged over Oblivious DoH are fully formed DNS messages. Clients that want to receive answers that are relevant to the network they are on without revealing their exact IP address can thus use the EDNS0 Client Subnet option ([RFC7871], Section 7.1.2) to provide a hint to the resolver using Oblivious DoH.",
      "ja": "DOHと同様に、忘却のDOHを介して交換されたDNSメッセージは完全に形成されたDNSメッセージです。したがって、正確なIPアドレスを明らかにすることなく、ネットワークに関連する回答を受けたいクライアントは、EDNS0クライアントサブネットオプション（[RFC7871]、セクション7.1.2）を使用して、忘却のDOHを使用してリゾルバーにヒントを提供します。"
    },
    {
      "indent": 3,
      "text": "This mechanism is intended to be used as one mechanism for resolving privacy-sensitive content in the broader context of DNS privacy.",
      "ja": "このメカニズムは、DNSプライバシーのより広いコンテキストでプライバシーに敏感なコンテンツを解決するための1つのメカニズムとして使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "This experimental protocol has been developed outside the IETF and is published here to guide implementation, ensure interoperability among implementations, and enable wide-scale experimentation. See Section 10 for more details about the experiment.",
      "ja": "この実験プロトコルはIETFの外部で開発されており、実装をガイドし、実装間の相互運用性を確保し、幅広い実験を可能にするためにここで公開されています。実験の詳細については、セクション10を参照してください。"
    },
    {
      "indent": 0,
      "text": "1.1. Specification of Requirements",
      "section_title": true,
      "ja": "1.1. 要件の仕様"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Terminology",
      "section_title": true,
      "ja": "2. 用語"
    },
    {
      "indent": 3,
      "text": "This document defines the following terms:",
      "ja": "このドキュメントでは、次の用語を定義します。"
    },
    {
      "indent": 3,
      "text": "Oblivious Client: A client that sends DNS queries to an Oblivious Target, through an Oblivious Proxy. The Client is responsible for selecting the combination of Proxy and Target to use for a given query.",
      "ja": "Oblivious Client：DNSクエリを忘却のターゲットに送信するクライアントは、忘れられないプロキシを介して。クライアントは、特定のクエリに使用するプロキシとターゲットの組み合わせを選択する責任があります。"
    },
    {
      "indent": 3,
      "text": "Oblivious Proxy: An HTTP server that proxies encrypted DNS queries and responses between an Oblivious Client and an Oblivious Target and is identified by a URI Template [RFC6570] (see Section 4.1). Note that this Oblivious Proxy is not acting as a full HTTP proxy but is instead a specialized server used to forward Oblivious DNS messages.",
      "ja": "Oblivious Proxy：DNSクエリと忘れられないクライアントと忘却のターゲット間の応答をプロキシングするHTTPサーバーは、URIテンプレート[RFC6570]によって識別されます（セクション4.1を参照）。この忘却のプロキシは、完全なHTTPプロキシとして機能するのではなく、代わりに忘れられないDNSメッセージを転送するために使用される専門的なサーバーであることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Oblivious Target: An HTTP server that receives and decrypts encrypted Oblivious Client DNS queries from an Oblivious Proxy and returns encrypted DNS responses via that same Proxy. In order to provide DNS responses, the Target can be a DNS resolver, be co-located with a resolver, or forward to a resolver.",
      "ja": "忘却ターゲット：暗号化された忘れられたクライアントDNSクエリを忘却のプロキシから受け取り、復号化するHTTPサーバーは、同じプロキシを介して暗号化されたDNS応答を返します。DNS応答を提供するために、ターゲットはDNSリゾルバーであるか、リゾルバーと共同でロケートするか、リゾルバーに転送できます。"
    },
    {
      "indent": 3,
      "text": "Throughout the rest of this document, we use the terms \"Client\", \"Proxy\", and \"Target\" to refer to an Oblivious Client, Oblivious Proxy, and Oblivious Target, respectively.",
      "ja": "このドキュメントの残りの部分を通して、「クライアント」、「プロキシ」、「ターゲット」という用語を使用して、それぞれ忘却のクライアント、忘却のプロキシ、および忘却のターゲットを指します。"
    },
    {
      "indent": 0,
      "text": "3. Deployment Requirements",
      "section_title": true,
      "ja": "3. 展開要件"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH requires, at a minimum:",
      "ja": "忘れられないDOHは、少なくとも次のことを必要とします："
    },
    {
      "indent": 3,
      "text": "* An Oblivious Proxy server, identified by a URI Template.",
      "ja": "* URIテンプレートによって識別される忘却のプロキシサーバー。"
    },
    {
      "indent": 3,
      "text": "* An Oblivious Target server. The Target and Proxy are expected to be non-colluding (see Section 11).",
      "ja": "* 忘れられないターゲットサーバー。ターゲットとプロキシは、非共謀であると予想されます（セクション11を参照）。"
    },
    {
      "indent": 3,
      "text": "* One or more Target public keys for encrypting DNS queries sent to a Target via a Proxy (Section 5). These keys guarantee that only the intended Target can decrypt Client queries.",
      "ja": "* プロキシを介してターゲットに送信されるDNSクエリを暗号化するための1つ以上のターゲットパブリックキー（セクション5）。これらのキーは、意図したターゲットのみがクライアントクエリを解読できることを保証します。"
    },
    {
      "indent": 3,
      "text": "The mechanism for discovering and provisioning the Proxy URI Template and Target public keys is out of scope for this document.",
      "ja": "プロキシURIテンプレートとターゲットパブリックキーを発見およびプロビジョニングするメカニズムは、このドキュメントの範囲外です。"
    },
    {
      "indent": 0,
      "text": "4. HTTP Exchange",
      "section_title": true,
      "ja": "4. HTTP Exchange"
    },
    {
      "indent": 3,
      "text": "Unlike direct resolution, oblivious hostname resolution over DoH involves three parties:",
      "ja": "直接的な解決とは異なり、DOHの忘却のホスト名解決には3つのパーティーが含まれます。"
    },
    {
      "indent": 3,
      "text": "1. The Client, which generates queries.",
      "ja": "1. クエリを生成するクライアント。"
    },
    {
      "indent": 3,
      "text": "2. The Proxy, which receives encrypted queries from the Client and passes them on to a Target.",
      "ja": "2. クライアントから暗号化されたクエリを受信し、それらをターゲットに渡すプロキシ。"
    },
    {
      "indent": 3,
      "text": "3. The Target, which receives proxied queries from the Client via the Proxy and produces proxied answers.",
      "ja": "3. ターゲットは、プロキシを介してクライアントからプロキシされたクエリを受け取り、プロキシの回答を生成します。"
    },
    {
      "indent": 3,
      "text": "     --- [ Request encrypted with Target public key ] -->\n+---------+             +-----------+             +-----------+\n| Client  +-------------> Oblivious +-------------> Oblivious |\n|         <-------------+   Proxy   <-------------+  Target   |\n+---------+             +-----------+             +-----------+\n    <-- [   Response encrypted with symmetric key   ] ---",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 1: Oblivious DoH Exchange",
      "ja": "図1：気まぐれなDOH交換"
    },
    {
      "indent": 0,
      "text": "4.1. HTTP Request",
      "section_title": true,
      "ja": "4.1. HTTPリクエスト"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH queries are created by the Client and are sent to the Proxy as HTTP requests using the POST method. Clients are configured with a Proxy URI Template [RFC6570] and the Target URI. The scheme for both the Proxy URI Template and the Target URI MUST be \"https\". The Proxy URI Template uses the Level 3 encoding defined in Section 1.2 of [RFC6570] and contains two variables: \"targethost\", which indicates the hostname of the Target server; and \"targetpath\", which indicates the path on which the Target is accessible. Examples of Proxy URI Templates are shown below:",
      "ja": "忘却のDOHクエリはクライアントによって作成され、POSTメソッドを使用してHTTP要求としてプロキシに送信されます。クライアントは、プロキシURIテンプレート[RFC6570]とターゲットURIで構成されています。プロキシURIテンプレートとターゲットURIの両方のスキームは「HTTPS」でなければなりません。プロキシURIテンプレートは、[RFC6570]のセクション1.2で定義されているレベル3エンコードを使用し、ターゲットサーバーのホスト名を示す「Targethost」という2つの変数が含まれています。および「ターゲットパス」。これは、ターゲットにアクセス可能なパスを示しています。プロキシURIテンプレートの例を以下に示します。"
    },
    {
      "indent": 3,
      "text": "https://dnsproxy.example/dns-query{?targethost,targetpath}\nhttps://dnsproxy.example/{targethost}/{targetpath}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The URI Template MUST contain both the \"targethost\" and \"targetpath\" variables exactly once and MUST NOT contain any other variables. The variables MUST be within the path or query components of the URI. Clients MUST ignore configurations that do not conform to this template. See Section 4.2 for an example request.",
      "ja": "URIテンプレートには、「Targethost」と「TargetPath」変数の両方を正確に1回含める必要があり、他の変数を含めてはなりません。変数は、URIのパスまたはクエリコンポーネント内にある必要があります。クライアントは、このテンプレートに準拠していない構成を無視する必要があります。例の要求については、セクション4.2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH messages have no cache value, since both requests and responses are encrypted using ephemeral key material. Requests and responses MUST NOT be cached.",
      "ja": "忘却のDOHメッセージには、リクエストと応答の両方が短命キー資料を使用して暗号化されるため、キャッシュ値はありません。リクエストと応答をキャッシュしてはなりません。"
    },
    {
      "indent": 3,
      "text": "Clients MUST set the HTTP Content-Type header to \"application/ oblivious-dns-message\" to indicate that this request is an Oblivious DoH query intended for proxying. Clients also SHOULD set this same value for the HTTP Accept header.",
      "ja": "クライアントは、HTTPコンテンツタイプのヘッダーを「Application/ Oblivious-DNS-Message」に設定して、このリクエストがプロキシを目的とした忘却のDOHクエリであることを示す必要があります。また、クライアントはHTTP Acceptヘッダーにこの同じ値を設定する必要があります。"
    },
    {
      "indent": 3,
      "text": "A correctly encoded request has the HTTP Content-Type header \"application/oblivious-dns-message\", uses the HTTP POST method, and contains \"targethost\" and \"targetpath\" variables. If the Proxy fails to match the \"targethost\" and \"targetpath\" variables from the path, it MUST treat the request as malformed. The Proxy constructs the URI of the Target with the \"https\" scheme, using the value of \"targethost\" as the URI host and the percent-decoded value of \"targetpath\" as the URI path. Proxies MUST check that Client requests are correctly encoded and MUST return a 4xx (Client Error) if the check fails, along with the Proxy-Status response header with an \"error\" parameter of type \"http_request_error\" [RFC9209].",
      "ja": "正しくエンコードされた要求には、HTTPコンテンツタイプのヘッダー「アプリケーション/忘却-DNS-Message」があり、HTTP POSTメソッドを使用し、「Targethost」と「TargetPath」変数が含まれています。プロキシがパスから「Targethost」と「TargetPath」変数と一致しない場合、要求を奇形として扱う必要があります。プロキシは、「https」スキームでターゲットのURIを構築し、URIホストとしての「Targethost」の値とURIパスとして「TargetPath」の割合で決定された値を使用します。プロキシは、クライアント要求が正しくエンコードされていることを確認する必要があり、チェックが失敗した場合は4xx（クライアントエラー）を返す必要があり、「http_request_error」[rfc9209]のタイプの「エラー」パラメーターを備えたプロキシステータス応答ヘッダーが必要です。"
    },
    {
      "indent": 3,
      "text": "Proxies MAY choose to not forward connections to non-standard ports. In such cases, Proxies can indicate the error with a 403 response status code, along with a Proxy-Status response header with an \"error\" parameter of type \"http_request_denied\" and with an appropriate explanation in \"details\".",
      "ja": "プロキシは、非標準ポートに接続を転送しないことを選択できます。そのような場合、プロキシは、403の応答ステータスコードでエラーを示すことができ、「http_request_denied」タイプの「エラー」パラメーターと「詳細」の適切な説明を持つプロキシステータス応答ヘッダーを示すことができます。"
    },
    {
      "indent": 3,
      "text": "If the Proxy cannot establish a connection to the Target, it can indicate the error with a 502 response status code, along with a Proxy-Status response header with an \"error\" parameter whose type indicates the reason. For example, if DNS resolution fails, the error type might be \"dns_timeout\", whereas if the TLS connection fails, the error type might be \"tls_protocol_error\".",
      "ja": "プロキシがターゲットへの接続を確立できない場合、502の応答ステータスコードでエラーを示すことができます。また、型が理由を示す「エラー」パラメーターを持つプロキシステータス応答ヘッダーが表示されます。たとえば、DNS解像度が失敗した場合、エラータイプは「DNS_TIMEOUT」である可能性がありますが、TLS接続が失敗する場合、エラータイプは「TLS_PROTOCOL_ERROR」である可能性があります。"
    },
    {
      "indent": 3,
      "text": "Upon receipt of requests from a Proxy, Targets MUST validate that the request has the HTTP Content-Type header \"application/oblivious-dns-message\" and uses the HTTP POST method. Targets can respond with a 4xx response status code if this check fails.",
      "ja": "プロキシからのリクエストを受信すると、ターゲットは、リクエストにHTTPコンテンツタイプのヘッダー「アプリケーション/忘却-DNSメッサージ」があることを検証し、HTTP POSTメソッドを使用する必要があります。このチェックが失敗した場合、ターゲットは4XX応答ステータスコードで応答できます。"
    },
    {
      "indent": 0,
      "text": "4.2. HTTP Request Example",
      "section_title": true,
      "ja": "4.2. HTTP要求の例"
    },
    {
      "indent": 3,
      "text": "The following example shows how a Client requests that a Proxy, \"dnsproxy.example\", forward an encrypted message to \"dnstarget.example\". The URI Template for the Proxy is \"https://dnsproxy.example/dns-query{?targethost,targetpath}\". The URI for the Target is \"https://dnstarget.example/dns-query\".",
      "ja": "次の例は、クライアントがプロキシ「dnsproxy.example」が「dnstarget.example」に転送されたメッセージを転送する方法をどのように要求するかを示しています。プロキシのURIテンプレートは「https：//dnsproxy.example/dns-query {？targethost、TargetPath}」です。ターゲットのURIは「https：//dnstarget.example/dns-query」です。"
    },
    {
      "indent": 3,
      "text": ":method = POST\n:scheme = https\n:authority = dnsproxy.example\n:path = /dns-query?targethost=dnstarget.example&targetpath=/dns-query\naccept = application/oblivious-dns-message\ncontent-type = application/oblivious-dns-message\ncontent-length = 106",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<Bytes containing an encrypted Oblivious DNS query>",
      "ja": "<暗号化された忘却DNSクエリを含むバイト>"
    },
    {
      "indent": 3,
      "text": "The Proxy then sends the following request on to the Target:",
      "ja": "次に、プロキシは次のリクエストをターゲットに送信します。"
    },
    {
      "indent": 3,
      "text": ":method = POST\n:scheme = https\n:authority = dnstarget.example\n:path = /dns-query\naccept = application/oblivious-dns-message\ncontent-type = application/oblivious-dns-message\ncontent-length = 106",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<Bytes containing an encrypted Oblivious DNS query>",
      "ja": "<暗号化された忘却DNSクエリを含むバイト>"
    },
    {
      "indent": 0,
      "text": "4.3. HTTP Response",
      "section_title": true,
      "ja": "4.3. HTTP応答"
    },
    {
      "indent": 3,
      "text": "The response to an Oblivious DoH query is generated by the Target. It MUST set the Content-Type HTTP header to \"application/oblivious-dns-message\" for all successful responses. The body of the response contains an encrypted DNS message; see Section 6.",
      "ja": "気づかないDOHクエリに対する応答は、ターゲットによって生成されます。すべての成功した応答のために、コンテンツタイプのHTTPヘッダーを「アプリケーション/忘却-DNSメサージ」に設定する必要があります。応答の本文には、暗号化されたDNSメッセージが含まれています。セクション6を参照してください。"
    },
    {
      "indent": 3,
      "text": "The response from a Target MUST set the Content-Type HTTP header to \"application/oblivious-dns-message\", and that same type MUST be used on all successful responses sent by the Proxy to the Client. A Client MUST only consider a response that contains the Content-Type header before processing the payload. A response without the appropriate header MUST be treated as an error and be handled appropriately. All other aspects of the HTTP response and error handling are inherited from standard DoH.",
      "ja": "ターゲットからの応答は、コンテンツタイプのhttpヘッダーを「アプリケーション/忘却-dns-message」に設定する必要があり、そのタイプは、クライアントに送信されたすべての成功した応答で使用する必要があります。クライアントは、ペイロードを処理する前にコンテンツタイプのヘッダーを含む応答のみを考慮する必要があります。適切なヘッダーのない応答は、エラーとして扱われ、適切に処理する必要があります。HTTP応答とエラー処理の他のすべての側面は、標準DOHから継承されます。"
    },
    {
      "indent": 3,
      "text": "Proxies forward responses from the Target to the Client, without any modifications to the body or status code. The Proxy also SHOULD add a Proxy-Status response header with a \"received-status\" parameter indicating that the status code was generated by the Target.",
      "ja": "ターゲットからクライアントへの応答を転送し、ボディまたはステータスコードを変更せずにプロキシします。また、プロキシは、ステータスコードがターゲットによって生成されたことを示す「受信ステータス」パラメーターを備えたプロキシステータス応答ヘッダーを追加する必要があります。"
    },
    {
      "indent": 3,
      "text": "Note that if a Client receives a 3xx status code and chooses to follow a redirect, the subsequent request MUST also be performed through a Proxy in order to avoid directly exposing requests to the Target.",
      "ja": "クライアントが3XXステータスコードを受信し、リダイレクトに従うことを選択した場合、ターゲットに直接リクエストを公開することを避けるために、後続の要求もプロキシを使用して実行する必要があることに注意してください。"
    },
    {
      "indent": 3,
      "text": "Requests that cannot be processed by the Target result in 4xx (Client Error) responses. If the Target and Client keys do not match, it is an authorization failure (HTTP status code 401; see Section 15.5.2 of [HTTP]). Otherwise, if the Client's request is invalid, such as in the case of decryption failure, wrong message type, or deserialization failure, this is a bad request (HTTP status code 400; see Section 15.5.1 of [HTTP]).",
      "ja": "ターゲットによって処理できないリクエストは、4xx（クライアントエラー）応答をもたらします。ターゲットキーとクライアントキーが一致しない場合、それは承認障害です（HTTPステータスコード401; [HTTP]のセクション15.5.2を参照）。それ以外の場合、復号化の障害、間違ったメッセージタイプ、または崩壊障害の場合など、クライアントの要求が無効である場合、これは悪い要求です（HTTPステータスコード400; [HTTP]のセクション15.5.1を参照）。"
    },
    {
      "indent": 3,
      "text": "Even in the case of DNS responses indicating failure, such as SERVFAIL or NXDOMAIN, a successful HTTP response with a 2xx status code is used as long as the DNS response is valid. This is identical to how DoH [RFC8484] handles HTTP response codes.",
      "ja": "ServFailやNXDomainなどの障害を示すDNS応答の場合でも、DNS応答が有効である限り、2XXステータスコードを使用したHTTP応答の成功が使用されます。これは、DOH [RFC8484]がHTTP応答コードを処理する方法と同じです。"
    },
    {
      "indent": 0,
      "text": "4.4. HTTP Response Example",
      "section_title": true,
      "ja": "4.4. HTTP応答の例"
    },
    {
      "indent": 3,
      "text": "The following example shows a 2xx (Successful) response that can be sent from a Target to a Client via a Proxy.",
      "ja": "次の例は、プロキシを介してターゲットからクライアントに送信できる2xx（成功）応答を示しています。"
    },
    {
      "indent": 3,
      "text": ":status = 200\ncontent-type = application/oblivious-dns-message\ncontent-length = 154",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "<Bytes containing an encrypted Oblivious DNS response>",
      "ja": "<暗号化された忘却DNS応答を含むバイト>"
    },
    {
      "indent": 0,
      "text": "4.5. HTTP Metadata",
      "section_title": true,
      "ja": "4.5. HTTPメタデータ"
    },
    {
      "indent": 3,
      "text": "Proxies forward requests and responses between Clients and Targets as specified in Section 4.1. Metadata sent with these messages could inadvertently weaken or remove Oblivious DoH privacy properties. Proxies MUST NOT send any Client-identifying information about Clients to Targets, such as \"Forwarded\" HTTP headers [RFC7239]. Additionally, Clients MUST NOT include any private state in requests to Proxies, such as HTTP cookies. See Section 11.3 for related discussion about Client authentication information.",
      "ja": "セクション4.1で指定されているように、クライアントとターゲット間のリクエストと応答を転送します。これらのメッセージで送信されたメタデータは、誤って忘れられないDOHプライバシープロパティを弱体化または削除する可能性があります。プロキシは、「転送された」HTTPヘッダー[RFC7239]など、クライアントを特定する情報をターゲットに送信してはなりません。さらに、クライアントは、HTTP Cookieなどのプロキシへのリクエストに民間の状態を含めるべきではありません。クライアント認証情報に関する関連する議論については、セクション11.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "5. Configuration and Public Key Format",
      "section_title": true,
      "ja": "5. 構成と公開キー形式"
    },
    {
      "indent": 3,
      "text": "In order to send a message to a Target, the Client needs to know a public key to use for encrypting its queries. The mechanism for discovering this configuration is out of scope for this document.",
      "ja": "ターゲットにメッセージを送信するには、クライアントがクエリを暗号化するために使用する公開キーを知る必要があります。この構成を発見するためのメカニズムは、このドキュメントの範囲外です。"
    },
    {
      "indent": 3,
      "text": "Servers ought to rotate public keys regularly. It is RECOMMENDED that servers rotate keys every day. Shorter rotation windows reduce the anonymity set of Clients that might use the public key, whereas longer rotation windows widen the time frame of possible compromise.",
      "ja": "サーバーは定期的に公開キーを回転させる必要があります。サーバーは毎日キーを回転させることをお勧めします。より短い回転ウィンドウは、公開キーを使用する可能性のあるクライアントの匿名セットを減らしますが、より長い回転ウィンドウは妥協の可能性のある時間枠を広げます。"
    },
    {
      "indent": 3,
      "text": "An Oblivious DNS public key configuration is a structure encoded, using TLS-style encoding [RFC8446], as follows:",
      "ja": "忘れられないDNS公開キー構成は、次のように、TLSスタイルのエンコード[RFC8446]を使用してエンコードされた構造です。"
    },
    {
      "indent": 3,
      "text": "struct {\n   uint16 kem_id;\n   uint16 kdf_id;\n   uint16 aead_id;\n   opaque public_key<1..2^16-1>;\n} ObliviousDoHConfigContents;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "struct {\n   uint16 version;\n   uint16 length;\n   select (ObliviousDoHConfig.version) {\n      case 0x0001: ObliviousDoHConfigContents contents;\n   }\n} ObliviousDoHConfig;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "ObliviousDoHConfig ObliviousDoHConfigs<1..2^16-1>;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ObliviousDoHConfigs structure contains one or more ObliviousDoHConfig structures in decreasing order of preference. This allows a server to support multiple versions of Oblivious DoH and multiple sets of Oblivious DoH parameters.",
      "ja": "ObliviousDohconfigs構造には、優先順位の減少において、1つまたは複数のObliviousDohconfig構造が含まれています。これにより、サーバーは、忘却のDOHの複数のバージョンと、忘却のDOHパラメーターの複数のセットをサポートできます。"
    },
    {
      "indent": 3,
      "text": "An ObliviousDoHConfig structure contains a versioned representation of an Oblivious DoH configuration, with the following fields.",
      "ja": "ObliviousDohconfig構造には、次のフィールドを備えた、忘却のDOH構成のバージョン付き表現が含まれています。"
    },
    {
      "indent": 3,
      "text": "version: The version of Oblivious DoH for which this configuration is used. Clients MUST ignore any ObliviousDoHConfig structure with a version they do not support. The version of Oblivious DoH specified in this document is 0x0001.",
      "ja": "バージョン：この構成が使用されている忘却のDOHのバージョン。クライアントは、サポートしていないバージョンを使用して、nobliviousdohconfig構造を無視する必要があります。このドキュメントで指定された忘却DOHのバージョンは0x0001です。"
    },
    {
      "indent": 3,
      "text": "length: The length, in bytes, of the next field.",
      "ja": "長さ：次のフィールドの長さ、バイト単位の長さ。"
    },
    {
      "indent": 3,
      "text": "contents: An opaque byte string whose contents depend on the version. For this specification, the contents are an ObliviousDoHConfigContents structure.",
      "ja": "内容：内容がバージョンに依存する不透明なバイト文字列。この仕様では、内容は忘れられないdohconfigcontents構造です。"
    },
    {
      "indent": 3,
      "text": "An ObliviousDoHConfigContents structure contains the information needed to encrypt a message under ObliviousDoHConfigContents.public_key such that only the owner of the corresponding private key can decrypt the message. The values for ObliviousDoHConfigContents.kem_id, ObliviousDoHConfigContents.kdf_id, and ObliviousDoHConfigContents.aead_id are described in Section 7 of [HPKE]. The fields in this structure are as follows:",
      "ja": "obliviousdohconfigcontents構造には、対応する秘密鍵の所有者のみがメッセージを解読できるように、obliviousdohconfigcontents.public_keyの下でメッセージを暗号化するために必要な情報が含まれています。obliviousdohconfigcontents.kem_id、obliviousdohconfigcontents.kdf_id、およびobliviousdohconfigcontents.aead_idの値は、[hpke]のセクション7で説明されています。この構造のフィールドは次のとおりです。"
    },
    {
      "indent": 3,
      "text": "kem_id: The hybrid public key encryption (HPKE) key encapsulation mechanism (KEM) identifier corresponding to public_key. Clients MUST ignore any ObliviousDoHConfig structure with a key using a KEM they do not support.",
      "ja": "KEM_ID：Public_keyに対応するハイブリッド公開キー暗号化（HPKE）キーカプセル化メカニズム（KEM）識別子。クライアントは、サポートしていないKEMを使用してキーを使用して、忘却のdohconfig構造を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "kdf_id: The HPKE key derivation function (KDF) identifier corresponding to public_key. Clients MUST ignore any ObliviousDoHConfig structure with a key using a KDF they do not support.",
      "ja": "KDF_ID：public_keyに対応するHPKEキー派生関数（KDF）識別子。クライアントは、サポートしていないKDFを使用してキーを使用して、忘却dohconfig構造を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "aead_id: The HPKE authenticated encryption with associated data (AEAD) identifier corresponding to public_key. Clients MUST ignore any ObliviousDoHConfig structure with a key using an AEAD they do not support.",
      "ja": "AEAD_ID：Public_Keyに対応する関連データ（AEAD）識別子を使用したHPKE認証暗号化。クライアントは、サポートしていないAEADを使用してキーを使用して、忘却のdohconfig構造を無視する必要があります。"
    },
    {
      "indent": 3,
      "text": "public_key: The HPKE public key used by the Client to encrypt Oblivious DoH queries.",
      "ja": "public_key：クライアントが忘れられないDOHクエリを暗号化するために使用するHPKE公開キー。"
    },
    {
      "indent": 0,
      "text": "6. Protocol Encoding",
      "section_title": true,
      "ja": "6. プロトコルエンコーディング"
    },
    {
      "indent": 3,
      "text": "This section includes encoding and wire format details for Oblivious DoH, as well as routines for encrypting and decrypting encoded values.",
      "ja": "このセクションには、忘却のDOHのエンコーディングおよびワイヤ形式の詳細、およびエンコードされた値を暗号化および復号化するためのルーチンが含まれています。"
    },
    {
      "indent": 0,
      "text": "6.1. Message Format",
      "section_title": true,
      "ja": "6.1. メッセージ形式"
    },
    {
      "indent": 3,
      "text": "There are two types of Oblivious DoH messages: Queries (0x01) and Responses (0x02). Both messages carry the following information:",
      "ja": "忘却のDOHメッセージには、クエリ（0x01）と応答（0x02）の2種類があります。両方のメッセージには次の情報が含まれています。"
    },
    {
      "indent": 3,
      "text": "1. A DNS message, which is either a Query or Response, depending on context.",
      "ja": "1. コンテキストに応じて、クエリまたは応答のいずれかであるDNSメッセージ。"
    },
    {
      "indent": 3,
      "text": "2. Padding of arbitrary length, which MUST contain all zeros.",
      "ja": "2. すべてのゼロを含む必要がある任意の長さのパディング。"
    },
    {
      "indent": 3,
      "text": "They are encoded using the following structure:",
      "ja": "次の構造を使用してエンコードされています。"
    },
    {
      "indent": 3,
      "text": "struct {\n   opaque dns_message<1..2^16-1>;\n   opaque padding<0..2^16-1>;\n} ObliviousDoHMessagePlaintext;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Both Query and Response messages use the ObliviousDoHMessagePlaintext format.",
      "ja": "クエリメッセージと応答メッセージの両方が、obliviousdohmessageplaintext形式を使用します。"
    },
    {
      "indent": 3,
      "text": "ObliviousDoHMessagePlaintext ObliviousDoHQuery;\nObliviousDoHMessagePlaintext ObliviousDoHResponse;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "An encrypted ObliviousDoHMessagePlaintext parameter is carried in an ObliviousDoHMessage message, encoded as follows:",
      "ja": "暗号化されたobliviousdohmessageplaintextパラメーターは、次のようにエンコードされた忘却dohmessageメッセージで運ばれます。"
    },
    {
      "indent": 3,
      "text": "struct {\n   uint8  message_type;\n   opaque key_id<0..2^16-1>;\n   opaque encrypted_message<1..2^16-1>;\n} ObliviousDoHMessage;",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The ObliviousDoHMessage structure contains the following fields:",
      "ja": "ObliviousDohmessage構造には、次のフィールドが含まれています。"
    },
    {
      "indent": 3,
      "text": "message_type: A one-byte identifier for the type of message. Query messages use message_type 0x01, and Response messages use message_type 0x02.",
      "ja": "message_type：メッセージのタイプの1バイト識別子。クエリメッセージはmessage_type 0x01を使用し、応答メッセージはmessage_type 0x02を使用します。"
    },
    {
      "indent": 3,
      "text": "key_id: The identifier of the corresponding ObliviousDoHConfigContents key. This is computed as Expand(Extract(\"\", config), \"odoh key id\", Nh), where config is the ObliviousDoHConfigContents structure and Extract, Expand, and Nh are as specified by the HPKE cipher suite KDF corresponding to config.kdf_id.",
      "ja": "key_id：対応するobliviousdohconfigcontentsキーの識別子。これは、拡張（抽出（ \"\"、config）、 \"odoh key id\"、nh）として計算されます。ここで、構成は忘却dohconfigcontentsの構造と抽出、拡張、およびnhは、config.kdf_idに対応するhpke cipherスイートkdfによって指定されています。。"
    },
    {
      "indent": 3,
      "text": "encrypted_message: An encrypted message for the Oblivious Target (for Query messages) or Client (for Response messages). Implementations MAY enforce limits on the size of this field, depending on the size of plaintext DNS messages. (DNS queries, for example, will not reach the size limit of 2^16-1 in practice.)",
      "ja": "encrypted_message：忘却のターゲット（クエリメッセージ用）またはクライアント（応答メッセージ用）の暗号化されたメッセージ。実装は、プレーンテキストDNSメッセージのサイズに応じて、このフィールドのサイズに制限を強制する場合があります。（たとえば、DNSクエリは、実際には2^16-1のサイズ制限に達しません。）"
    },
    {
      "indent": 3,
      "text": "The contents of ObliviousDoHMessage.encrypted_message depend on ObliviousDoHMessage.message_type. In particular, ObliviousDoHMessage.encrypted_message is an encryption of an ObliviousDoHQuery message if the message is a Query and an encryption of ObliviousDoHResponse if the message is a Response.",
      "ja": "obliviousdohmessage.encrypted_messageの内容は、obliviousdohmessage.message_typeに依存します。特に、obliviousdohmessage.encrypted_messageは、メッセージがクエリである場合、忘却dohqueryメッセージの暗号化であり、メッセージが応答である場合は忘却dohresponseの暗号化です。"
    },
    {
      "indent": 0,
      "text": "6.2. Encryption and Decryption Routines",
      "section_title": true,
      "ja": "6.2. 暗号化と復号化ルーチン"
    },
    {
      "indent": 3,
      "text": "Clients use the following utility functions for encrypting a Query and decrypting a Response as described in Section 7.",
      "ja": "クライアントは、セクション7で説明されているように、クエリを暗号化し、応答を復号化するために次のユーティリティ関数を使用します。"
    },
    {
      "indent": 3,
      "text": "* encrypt_query_body: Encrypt an Oblivious DoH query.",
      "ja": "* encrypt_query_body：忘れられないDOHクエリを暗号化します。"
    },
    {
      "indent": 3,
      "text": "def encrypt_query_body(pkR, key_id, Q_plain):\n  enc, context = SetupBaseS(pkR, \"odoh query\")\n  aad = 0x01 || len(key_id) || key_id\n  ct = context.Seal(aad, Q_plain)\n  Q_encrypted = enc || ct\n  return Q_encrypted",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* decrypt_response_body: Decrypt an Oblivious DoH response.",
      "ja": "* decrypt_response_body：忘れられないDOH応答を復号化します。"
    },
    {
      "indent": 3,
      "text": "def decrypt_response_body(context, Q_plain, R_encrypted, resp_nonce):\n  aead_key, aead_nonce = derive_secrets(context, Q_plain, resp_nonce)\n  aad = 0x02 || len(resp_nonce) || resp_nonce\n  R_plain, error = Open(key, nonce, aad, R_encrypted)\n  return R_plain, error",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The derive_secrets function is described below.",
      "ja": "derive_secrets関数を以下に説明します。"
    },
    {
      "indent": 3,
      "text": "Targets use the following utility functions in processing queries and producing responses as described in Section 8.",
      "ja": "ターゲットは、セクション8で説明されているように、クエリを処理し、応答を生成する際に次のユーティリティ関数を使用します。"
    },
    {
      "indent": 3,
      "text": "* setup_query_context: Set up an HPKE context used for decrypting an Oblivious DoH query.",
      "ja": "* setup_query_context：忘れられないDOHクエリを復号化するために使用されるHPKEコンテキストを設定します。"
    },
    {
      "indent": 3,
      "text": "def setup_query_context(skR, key_id, Q_encrypted): enc || ct = Q_encrypted context = SetupBaseR(enc, skR, \"odoh query\") return context",
      "ja": "def setup_query_context（skr、key_id、q_encrypted）：enc ||ct = q_encrypted context = setupbaser（enc、skr、 \"odoh query\"）return context"
    },
    {
      "indent": 3,
      "text": "* decrypt_query_body: Decrypt an Oblivious DoH query.",
      "ja": "* decrypt_query_body：忘れられないDOHクエリを復号化します。"
    },
    {
      "indent": 3,
      "text": "def decrypt_query_body(context, key_id, Q_encrypted):\n  aad = 0x01 || len(key_id) || key_id\n  enc || ct = Q_encrypted\n  Q_plain, error = context.Open(aad, ct)\n  return Q_plain, error",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "* derive_secrets: Derive keying material used for encrypting an Oblivious DoH response.",
      "ja": "* derive_secrets：忘れられないDOH応答の暗号化に使用されるキーイング素材を導き出します。"
    },
    {
      "indent": 3,
      "text": "def derive_secrets(context, Q_plain, resp_nonce):\n  secret = context.Export(\"odoh response\", Nk)\n  salt = Q_plain || len(resp_nonce) || resp_nonce\n  prk = Extract(salt, secret)\n  key = Expand(odoh_prk, \"odoh key\", Nk)\n  nonce = Expand(odoh_prk, \"odoh nonce\", Nn)\n  return key, nonce",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "The random(N) function returns N cryptographically secure random bytes from a good source of entropy [RFC4086]. The max(A, B) function returns A if A > B, and B otherwise.",
      "ja": "ランダム（n）関数は、エントロピーの良好なソース[RFC4086]からn暗号的に固定されたランダムバイトを返します。max（a、b）関数はa> bを返し、それ以外の場合はbを返します。"
    },
    {
      "indent": 3,
      "text": "* encrypt_response_body: Encrypt an Oblivious DoH response.",
      "ja": "* encrypt_response_body：忘れられないDOH応答を暗号化します。"
    },
    {
      "indent": 3,
      "text": "def encrypt_response_body(R_plain, aead_key, aead_nonce, resp_nonce):\n  aad = 0x02 || len(resp_nonce) || resp_nonce\n  R_encrypted = Seal(aead_key, aead_nonce, aad, R_plain)\n  return R_encrypted",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "7. Oblivious Client Behavior",
      "section_title": true,
      "ja": "7. 気付かないクライアントの動作"
    },
    {
      "indent": 3,
      "text": "Let M be a DNS message (query) a Client wishes to protect with Oblivious DoH. When sending an Oblivious DoH Query for resolving M to an Oblivious Target with ObliviousDoHConfigContents config, a Client does the following:",
      "ja": "MをDNSメッセージ（クエリ）とし、クライアントが忘れられないDOHで保護したいと考えています。obliviousdohconfigcontents構成を使用して、Mを忘却のターゲットに解決するための忘却のDOHクエリを送信する場合、クライアントは次のことを行います。"
    },
    {
      "indent": 3,
      "text": "1. Creates an ObliviousDoHQuery structure, carrying the message M and padding, to produce Q_plain.",
      "ja": "1. q_plainを生成するために、メッセージmとパディングを運ぶ忘却dohquery構造を作成します。"
    },
    {
      "indent": 3,
      "text": "2. Deserializes config.public_key to produce a public key pkR of type config.kem_id.",
      "ja": "2. deserialize config.public_keyは、type config.kem_idの公開キーPKRを作成します。"
    },
    {
      "indent": 3,
      "text": "3. Computes the encrypted message as Q_encrypted = encrypt_query_body(pkR, key_id, Q_plain), where key_id is as computed in Section 6. Note also that len(key_id) outputs the length of key_id as a two-byte unsigned integer.",
      "ja": "3. 暗号化されたメッセージをq_encrypted = encrypt_query_body（pkr、key_id、q_plain）として計算します。ここで、key_idはセクション6で計算されています。"
    },
    {
      "indent": 3,
      "text": "4. Outputs an ObliviousDoHMessage message Q, where Q.message_type = 0x01, Q.key_id carries key_id, and Q.encrypted_message = Q_encrypted.",
      "ja": "4. q.message_type = 0x01、q.key_idはkey_id、およびq.encrypted_message = q_encryptedをキャリーします。"
    },
    {
      "indent": 3,
      "text": "The Client then sends Q to the Proxy according to Section 4.1. Once the Client receives a response R, encrypted as specified in Section 8, it uses decrypt_response_body to decrypt R.encrypted_message (using R.key_id as a nonce) and produce R_plain. Clients MUST validate R_plain.padding (as all zeros) before using R_plain.dns_message.",
      "ja": "次に、クライアントはQをセクション4.1に従ってプロキシに送信します。セクション8で指定されているように暗号化された応答rをクライアントが受信すると、decrypt_response_bodyを使用してr.encrypted_message（r.key_idを非ceとして使用）を復号化し、r_plainを生成します。クライアントは、r_plain.dns_messageを使用する前に、r_plain.padding（すべてのゼロとして）を検証する必要があります。"
    },
    {
      "indent": 0,
      "text": "8. Oblivious Target Behavior",
      "section_title": true,
      "ja": "8. 忘却のターゲット動作"
    },
    {
      "indent": 3,
      "text": "Targets that receive a Query message Q decrypt and process it as follows:",
      "ja": "クエリメッセージを受信するターゲットq decryptを復号化し、次のように処理します。"
    },
    {
      "indent": 3,
      "text": "1. Look up the ObliviousDoHConfigContents information according to Q.key_id. If no such key exists, the Target MAY discard the query, and if so, it MUST return a 401 (Unauthorized) response to the Proxy. Otherwise, let skR be the private key corresponding to this public key, or one chosen for trial decryption.",
      "ja": "1. Q.Key_idに従って、obliviousdohconfigcontents情報を調べます。そのようなキーが存在しない場合、ターゲットはクエリを破棄する場合があり、その場合、プロキシに対する401（不正な）応答を返す必要があります。それ以外の場合は、SKRをこの公開鍵に対応する秘密鍵、または試用復号化のために選択したものとします。"
    },
    {
      "indent": 3,
      "text": "2. Compute context = setup_query_context(skR, Q.key_id, Q.encrypted_message).",
      "ja": "2. Compute Context = setup_query_context（skr、q.key_id、q.encrypted_message）。"
    },
    {
      "indent": 3,
      "text": "3. Compute Q_plain, error = decrypt_query_body(context, Q.key_id, Q.encrypted_message).",
      "ja": "3. q_plain、error = decrypt_query_body（context、q.key_id、q.encrypted_message）を計算します。"
    },
    {
      "indent": 3,
      "text": "4. If no error was returned and Q_plain.padding is valid (all zeros), resolve Q_plain.dns_message as needed, yielding a DNS message M. Otherwise, if an error was returned or the padding was invalid, return a 400 (Client Error) response to the Proxy.",
      "ja": "4. エラーが返されず、q_plain.paddingが有効である場合（すべてのゼロ）、必要に応じてq_plain.dns_messageを解決し、DNSメッセージMを生成します。プロキシに。"
    },
    {
      "indent": 3,
      "text": "5. Create an ObliviousDoHResponseBody structure, carrying the message M and padding, to produce R_plain.",
      "ja": "5. r_plainを生成するために、メッセージmとパディングを運ぶ忘却dohresponsebody構造を作成します。"
    },
    {
      "indent": 3,
      "text": "6. Create a fresh nonce resp_nonce = random(max(Nn, Nk)).",
      "ja": "6. 新鮮なnonce resp_nonce = random（max（nn、nk））を作成します。"
    },
    {
      "indent": 3,
      "text": "7. Compute aead_key, aead_nonce = derive_secrets(context, Q_plain, resp_nonce).",
      "ja": "7. Aead_key、aead_nonce = derive_secrets（context、q_plain、resp_nonce）を計算します。"
    },
    {
      "indent": 3,
      "text": "8. Compute R_encrypted = encrypt_response_body(R_plain, aead_key, aead_nonce, resp_nonce). The key_id field used for encryption carries resp_nonce in order for Clients to derive the same secrets. Also, the Seal function is the function that is associated with the HPKE AEAD.",
      "ja": "8. compute r_encrypted = encrypt_response_body（r_plain、aead_key、aead_nonce、resp_nonce）。暗号化に使用されるkey_idフィールドは、クライアントが同じ秘密を導き出すためにresp_nonceを運びます。また、シール機能は、HPKE AEADに関連付けられている関数です。"
    },
    {
      "indent": 3,
      "text": "9. Output an ObliviousDoHMessage message R, where R.message_type = 0x02, R.key_id = resp_nonce, and R.encrypted_message = R_encrypted.",
      "ja": "9. r.message_type = 0x02、r.key_id = resp_nonce、およびr.encrypted_message = r_encrypted。"
    },
    {
      "indent": 3,
      "text": "The Target then sends R in a 2xx (Successful) response to the Proxy; see Section 4.3. The Proxy forwards the message R without modification back to the Client as the HTTP response to the Client's original HTTP request. In the event of an error (non-2xx status code), the Proxy forwards the Target error to the Client; see Section 4.3.",
      "ja": "ターゲットは、プロキシに対する2xx（成功）応答でRを送信します。セクション4.3を参照してください。プロキシは、クライアントの元のHTTP要求に対するHTTP応答として、クライアントに変更せずにメッセージRを転送します。エラー（2xx以外のステータスコード）が発生した場合、プロキシはターゲットエラーをクライアントに転送します。セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "9. Compliance Requirements",
      "section_title": true,
      "ja": "9. コンプライアンス要件"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH uses HPKE for public key encryption [HPKE]. In the absence of an application profile standard specifying otherwise, a compliant Oblivious DoH implementation MUST support the following HPKE cipher suite:",
      "ja": "Oblivious Dohは、公開キーの暗号化[HPKE]にHPKEを使用します。それ以外の場合は、アプリケーションプロファイル標準がない場合、準拠した忘却のDOH実装は、次のHPKE暗号スイートをサポートする必要があります。"
    },
    {
      "indent": 3,
      "text": "KEM: DHKEM(X25519, HKDF-SHA256) (see [HPKE], Section 7.1)",
      "ja": "KEM：DHKEM（X25519、HKDF-SHA256）（[HPKE]、セクション7.1を参照）"
    },
    {
      "indent": 3,
      "text": "KDF: HKDF-SHA256 (see [HPKE], Section 7.2)",
      "ja": "KDF：HKDF-SHA256（[HPKE]、セクション7.2を参照）"
    },
    {
      "indent": 3,
      "text": "AEAD: AES-128-GCM (see [HPKE], Section 7.3)",
      "ja": "AEAD：AES-128-GCM（[HPKE]、セクション7.3を参照）"
    },
    {
      "indent": 0,
      "text": "10. Experiment Overview",
      "section_title": true,
      "ja": "10. 実験の概要"
    },
    {
      "indent": 3,
      "text": "This document describes an experimental protocol built on DoH. The purpose of this experiment is to assess deployment configuration viability and related performance impacts on DNS resolution by measuring key performance indicators such as resolution latency. Experiment participants will test various parameters affecting service operation and performance, including mechanisms for discovery and configuration of DoH Proxies and Targets, as well as performance implications of connection reuse and pools where appropriate. The results of this experiment will be used to influence future protocol design and deployment efforts related to Oblivious DoH, such as Oblivious HTTP [OHTP]. Implementations of DoH that are not involved in the experiment will not recognize this protocol and will not participate in the experiment. It is anticipated that the use of Oblivious DoH will be widespread and that this experiment will be of long duration.",
      "ja": "このドキュメントでは、DOH上に構築された実験プロトコルについて説明しています。この実験の目的は、解像度の遅延などの主要なパフォーマンスインジケーターを測定することにより、展開構成の実行可能性とDNS解像度に関連するパフォーマンスの影響を評価することです。実験参加者は、DOHプロキシとターゲットの発見と構成のメカニズム、必要に応じて接続の再利用とプールのパフォーマンスへの影響など、サービスの操作とパフォーマンスに影響を与えるさまざまなパラメーターをテストします。この実験の結果は、忘却のHTTP [OHTP]など、忘却のDOHに関連する将来のプロトコル設計および展開の取り組みに影響を与えるために使用されます。実験に関与していないDOHの実装は、このプロトコルを認識せず、実験に参加しません。気付かないDOHの使用は広く普及し、この実験は長期にわたって普及することが予想されます。"
    },
    {
      "indent": 0,
      "text": "11. Security Considerations",
      "section_title": true,
      "ja": "11. セキュリティ上の考慮事項"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH aims to keep knowledge of the true query origin and its contents known only to Clients. As a simplified model, consider a case where there exist two Clients C1 and C2, one Proxy P, and one Target T. Oblivious DoH assumes an extended Dolev-Yao style attacker [Dolev-Yao] that can observe all network activity and can adaptively compromise either P or T, but not C1 or C2. Note that compromising both P and T is equivalent to collusion between these two parties in practice. Once compromised, the attacker has access to all session information and private key material. (This generalizes to arbitrarily many Clients, Proxies, and Targets, with the constraints that (1) not all Targets and Proxies are simultaneously compromised and (2) at least two Clients are left uncompromised.) The attacker is prohibited from sending Client-identifying information, such as IP addresses, to Targets. (This would allow the attacker to trivially link a query to the corresponding Client.)",
      "ja": "Oblivious Dohは、クライアントのみに知られている真のクエリ起源とその内容の知識を維持することを目指しています。単純化されたモデルとして、2つのクライアントC1とC2、1つのプロキシP、および1つのターゲットT. oblivious DOHが存在する場合を考えてみましょう。PまたはTのいずれかを妥協しますが、C1またはC2は妥協しません。PとTの両方を妥協することは、実際のこれら2つの関係者間の共謀と同等であることに注意してください。侵害されると、攻撃者はすべてのセッション情報と秘密のキー資料にアクセスできます。（これは、多くのクライアント、プロキシ、およびターゲットにarbitrarily意的に一般化され、（1）すべてのターゲットとプロキシが同時に侵害されているわけではなく、（2）少なくとも2人のクライアントが妥協しないままになっているという制約があります。IPアドレスなどの情報がターゲットになります。（これにより、攻撃者はクエリを対応するクライアントに簡単にリンクできます。）"
    },
    {
      "indent": 3,
      "text": "In this model, both C1 and C2 send Oblivious DoH queries Q1 and Q2, respectively, through P to T, and T provides answers A1 and A2. The attacker aims to link C1 to (Q1, A1) and C2 to (Q2, A2), respectively. The attacker succeeds if this linkability is possible without any additional interaction. (For example, if T is compromised, it could return a DNS answer corresponding to an entity it controls and then observe the subsequent connection from a Client, learning its identity in the process. Such attacks are out of scope for this model.)",
      "ja": "このモデルでは、C1とC2の両方が、それぞれPからTを介して忘却のDOHクエリQ1とQ2を送信し、Tは回答A1とA2を提供します。攻撃者は、それぞれC1を（Q1、A1）およびC2に（Q2、A2）にリンクすることを目指しています。このリンク可能性が追加の相互作用なしに可能である場合、攻撃者は成功します。（たとえば、Tが侵害された場合、制御するエンティティに対応するDNS回答を返す可能性があり、クライアントからの後続の接続を観察し、プロセスでそのアイデンティティを学習します。そのような攻撃はこのモデルの範囲外です。）"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH security prevents such linkability. Informally, this means:",
      "ja": "忘れられないDOHセキュリティは、そのようなリンク性を防ぎます。非公式には、これは次のことを意味します。"
    },
    {
      "indent": 3,
      "text": "1. Queries and answers are known only to Clients and Targets in possession of the corresponding response key and HPKE keying material. In particular, Proxies know the origin and destination of an oblivious query, yet do not know the plaintext query. Likewise, Targets know only the oblivious query origin, i.e., the Proxy, and the plaintext query. Only the Client knows both the plaintext query contents and destination.",
      "ja": "1. クエリと回答は、対応する応答キーとHPKEキーイング素材を所有するクライアントとターゲットのみに知られています。特に、プロキシは忘れられないクエリの起源と目的地を知っていますが、プレーンテキストクエリを知らない。同様に、ターゲットは、忘却のクエリの原点、つまりプロキシ、プレーンテキストクエリのみを知っています。クライアントのみが、プレーンテキストクエリの内容と宛先の両方を知っています。"
    },
    {
      "indent": 3,
      "text": "2. Target resolvers cannot link queries from the same Client in the absence of unique per-Client keys.",
      "ja": "2. ターゲットリゾルバーは、一意のクライアントキーがない場合、同じクライアントのクエリをリンクできません。"
    },
    {
      "indent": 3,
      "text": "Traffic analysis mitigations are outside the scope of this document. In particular, this document does not prescribe padding lengths for ObliviousDoHQuery and ObliviousDoHResponse messages. Implementations SHOULD follow the guidance in [RFC8467] for choosing padding length.",
      "ja": "トラフィック分析の緩和は、このドキュメントの範囲外です。特に、このドキュメントでは、忘れられないdohqueryおよびobliviousdohresponseメッセージのパディングの長さを規定していません。実装は、パディングの長さを選択するために[RFC8467]のガイダンスに従う必要があります。"
    },
    {
      "indent": 3,
      "text": "Oblivious DoH security does not depend on Proxy and Target indistinguishability. Specifically, an on-path attacker could determine whether a connection to a specific endpoint is used for oblivious or direct DoH queries. However, this has no effect on the confidentiality goals listed above.",
      "ja": "忘却のDOHセキュリティは、プロキシとターゲットの区別可能性に依存しません。具体的には、パス上の攻撃者は、特定のエンドポイントへの接続が忘却または直接DOHクエリに使用されるかどうかを判断できます。ただし、これは上記の機密性の目標に影響を与えません。"
    },
    {
      "indent": 0,
      "text": "11.1. Denial of Service",
      "section_title": true,
      "ja": "11.1. サービス拒否"
    },
    {
      "indent": 3,
      "text": "Malicious Clients (or Proxies) can send bogus Oblivious DoH queries to Targets as a Denial-of-Service (DoS) attack. Target servers can throttle processing requests if such an event occurs. Additionally, since Targets provide explicit errors upon decryption failure, i.e., if ciphertext decryption fails or if the plaintext DNS message is malformed, Proxies can throttle specific Clients in response to these errors. In general, however, Targets trust Proxies to not overwhelm the Target, and it is expected that Proxies implement either some form of rate limiting or client authentication to limit abuse; see Section 11.3.",
      "ja": "悪意のあるクライアント（またはプロキシ）は、サービス拒否（DOS）攻撃としてターゲットに偽の忘却のDOHクエリを送信できます。ターゲットサーバーは、そのようなイベントが発生した場合、処理リクエストをスロットルすることができます。さらに、ターゲットは復号化障害時に明示的なエラーを提供するため、つまり、暗号文の復号化が失敗した場合、またはPlantext DNSメッセージが奇形である場合、プロキシはこれらのエラーに応じて特定のクライアントを絞り込むことができます。ただし、一般に、ターゲットはプロキシをターゲットに圧倒しないことを信頼しており、プロキシは何らかの形のレート制限またはクライアント認証を実装して虐待を制限することが期待されています。セクション11.3を参照してください。"
    },
    {
      "indent": 3,
      "text": "Malicious Targets or Proxies can send bogus answers in response to Oblivious DoH queries. Response decryption failure is a signal that either the Proxy or Target is misbehaving. Clients can choose to stop using one or both of these servers in the event of such failure. However, as noted above, malicious Targets and Proxies are out of scope for the threat model.",
      "ja": "悪意のあるターゲットまたはプロキシは、気づかないDOHクエリに応じて偽の回答を送信できます。応答復号化障害は、プロキシまたはターゲットが誤動作しているというシグナルです。クライアントは、このような障害が発生した場合に、これらのサーバーのいずれかまたは両方の使用を停止することを選択できます。ただし、上記のように、悪意のあるターゲットとプロキシは脅威モデルの範囲外です。"
    },
    {
      "indent": 0,
      "text": "11.2. Proxy Policies",
      "section_title": true,
      "ja": "11.2. プロキシポリシー"
    },
    {
      "indent": 3,
      "text": "Proxies are free to enforce any forwarding policy they desire for Clients. For example, they can choose to only forward requests to known or otherwise trusted Targets.",
      "ja": "プロキシは、クライアントに望む転送ポリシーを自由に実施できます。たとえば、既知または信頼できるターゲットにリクエストのみを転送することを選択できます。"
    },
    {
      "indent": 3,
      "text": "Proxies that do not reuse connections to Targets for many Clients may allow Targets to link individual queries to unknown Targets. To mitigate this linkability vector, it is RECOMMENDED that Proxies pool and reuse connections to Targets. Note that this benefits performance as well as privacy, since queries do not incur any delay that might otherwise result from Proxy-to-Target connection establishment.",
      "ja": "多くのクライアントのターゲットへの接続を再利用しないプロキシにより、ターゲットが個々のクエリを不明なターゲットにリンクすることができます。このリンク可能性ベクトルを緩和するには、プロキシプールとターゲットへの接続を再利用することをお勧めします。クエリにはプロキシからターゲットへの接続確立から生じる可能性のある遅延が発生しないため、これはパフォーマンスとプライバシーに役立つことに注意してください。"
    },
    {
      "indent": 0,
      "text": "11.3. Authentication",
      "section_title": true,
      "ja": "11.3. 認証"
    },
    {
      "indent": 3,
      "text": "Depending on the deployment scenario, Proxies and Targets might require authentication before use. Regardless of the authentication mechanism in place, Proxies MUST NOT reveal any Client authentication information to Targets. This is required so Targets cannot uniquely identify individual Clients.",
      "ja": "展開シナリオに応じて、プロキシとターゲットには使用前に認証が必要になる場合があります。実施されている認証メカニズムに関係なく、プロキシはターゲットにクライアント認証情報を明らかにしてはなりません。これが必要なため、ターゲットは個々のクライアントを一意に識別できません。"
    },
    {
      "indent": 3,
      "text": "Note that if Targets require Proxies to authenticate at the HTTP or application layer before use, this ought to be done before attempting to forward any Client query to the Target. This will allow Proxies to distinguish 401 (Unauthorized) response codes due to authentication failure from 401 response codes due to Client key mismatch; see Section 4.3.",
      "ja": "ターゲットが使用前にHTTPまたはアプリケーションレイヤーで認証するためにプロキシを必要とする場合、これはクライアントのクエリをターゲットに転送しようとする前に行う必要があることに注意してください。これにより、プロキシは、クライアントのキーの不一致による401の応答コードからの認証障害による401（不正な）応答コードを区別できます。セクション4.3を参照してください。"
    },
    {
      "indent": 0,
      "text": "12. IANA Considerations",
      "section_title": true,
      "ja": "12. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document makes changes to the \"Media Types\" registry. The changes are described in the following subsection.",
      "ja": "このドキュメントは、「メディアタイプ」レジストリを変更します。変更は、次のサブセクションで説明されています。"
    },
    {
      "indent": 0,
      "text": "12.1. Oblivious DoH Message Media Type",
      "section_title": true,
      "ja": "12.1. 忘れられないDOHメッセージメディアタイプ"
    },
    {
      "indent": 3,
      "text": "This document registers a new media type, \"application/oblivious-dns-message\".",
      "ja": "このドキュメントでは、新しいメディアタイプ「アプリケーション/忘却-DNSメサージ」を登録します。"
    },
    {
      "indent": 3,
      "text": "Type name: application",
      "ja": "タイプ名：アプリケーション"
    },
    {
      "indent": 3,
      "text": "Subtype name: oblivious-dns-message",
      "ja": "サブタイプ名：Oblivious-DNS-Message"
    },
    {
      "indent": 3,
      "text": "Required parameters: N/A",
      "ja": "必要なパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Optional parameters: N/A",
      "ja": "オプションのパラメーター：n/a"
    },
    {
      "indent": 3,
      "text": "Encoding considerations: This is a binary format, containing encrypted DNS requests and responses encoded as ObliviousDoHMessage values, as defined in Section 6.1.",
      "ja": "考慮事項のエンコード：これは、セクション6.1で定義されているように、暗号化されたDNS要求とobliviousdohmessage値としてエンコードされた応答を含むバイナリ形式です。"
    },
    {
      "indent": 3,
      "text": "Security considerations: See this document. The content is an encrypted DNS message, and not executable code.",
      "ja": "セキュリティ上の考慮事項：このドキュメントを参照してください。コンテンツは暗号化されたDNSメッセージであり、実行可能なコードではありません。"
    },
    {
      "indent": 3,
      "text": "Interoperability considerations: This document specifies the format of conforming messages and the interpretation thereof; see Section 6.1.",
      "ja": "相互運用性の考慮事項：このドキュメントは、適合メッセージの形式とその解釈を指定します。セクション6.1を参照してください。"
    },
    {
      "indent": 3,
      "text": "Published specification: This document",
      "ja": "公開された仕様：このドキュメント"
    },
    {
      "indent": 3,
      "text": "Applications that use this media type: This media type is intended to be used by Clients wishing to hide their DNS queries when using DNS over HTTPS.",
      "ja": "このメディアタイプを使用するアプリケーション：このメディアタイプは、HTTPSでDNSを使用するときにDNSクエリを非表示にしたいクライアントが使用することを目的としています。"
    },
    {
      "indent": 3,
      "text": "Additional information: N/A",
      "ja": "追加情報：n/a"
    },
    {
      "indent": 3,
      "text": "Person and email address to contact for further information: See the Authors' Addresses section.",
      "ja": "詳細については、個人とメールアドレスをお問い合わせください：著者のアドレスセクションを参照してください。"
    },
    {
      "indent": 3,
      "text": "Intended usage: COMMON",
      "ja": "意図された使用法：共通"
    },
    {
      "indent": 3,
      "text": "Restrictions on usage: N/A",
      "ja": "使用に関する制限：n/a"
    },
    {
      "indent": 3,
      "text": "Author: Tommy Pauly (tpauly@apple.com)",
      "ja": "著者：トミーポーリー（tpauly@apple.com）"
    },
    {
      "indent": 3,
      "text": "Change controller: IETF",
      "ja": "Change Controller：IETF"
    },
    {
      "indent": 3,
      "text": "Provisional registration? (standards tree only): No",
      "ja": "暫定登録？（標準ツリーのみ）：いいえ"
    },
    {
      "indent": 0,
      "text": "13. References",
      "section_title": true,
      "ja": "13. 参考文献"
    },
    {
      "indent": 0,
      "text": "13.1. Normative References",
      "section_title": true,
      "ja": "13.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[HPKE] Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, \"Hybrid Public Key Encryption\", RFC 9180, DOI 10.17487/RFC9180, February 2022, <https://www.rfc-editor.org/info/rfc9180>.",
      "ja": "[Hpke] Barnes、R.、Bhargavan、K.、Lipp、B。、およびC. Wood、「ハイブリッド公開キー暗号化」、RFC 9180、DOI 10.17487/RFC9180、2022年2月、<https：//www.rfc-editor.org/info/rfc9180>。"
    },
    {
      "indent": 3,
      "text": "[HTTP] Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke, Ed., \"HTTP Semantics\", STD 97, RFC 9110, DOI 10.17487/RFC9110, June 2022, <https://www.rfc-editor.org/info/rfc9110>.",
      "ja": "[HTTP] Fielding、R.、Ed。、Nottingham、M.、Ed。、およびJ. Reschke、ed。、 \"HTTP Semantics\"、Std 97、RFC 9110、DOI 10.17487/RFC9110、2022年6月、<https：//www.rfc-editor.org/info/rfc9110>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] Bradner、S。、「要件レベルを示すためにRFCで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487/RFC2119、1997年3月、<https://www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC4086] Eastlake 3rd, D., Schiller, J., and S. Crocker, \"Randomness Requirements for Security\", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005, <https://www.rfc-editor.org/info/rfc4086>.",
      "ja": "[RFC4086] EastLake 3rd、D.、Schiller、J。、およびS. Crocker、「セキュリティのランダム性要件」、BCP 106、RFC 4086、DOI 10.17487/RFC4086、2005年6月、<https：//www.rfc-editor.org/info/rfc4086>。"
    },
    {
      "indent": 3,
      "text": "[RFC6570] Gregorio, J., Fielding, R., Hadley, M., Nottingham, M., and D. Orchard, \"URI Template\", RFC 6570, DOI 10.17487/RFC6570, March 2012, <https://www.rfc-editor.org/info/rfc6570>.",
      "ja": "[RFC6570]グレゴリオ、J。、フィールディング、R。、ハドリー、M。、ノッティンガム、M。、およびD.オーチャード、「URIテンプレート」、RFC 6570、DOI 10.17487/RFC6570、2012年3月、<https：// wwwwwwwwwwwwww.rfc-editor.org/info/rfc6570>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B。、「RFC 2119キーワードの大文字と小文字のあいまいさ」、BCP 14、RFC 8174、DOI 10.17487/RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 3,
      "text": "[RFC8446] Rescorla, E., \"The Transport Layer Security (TLS) Protocol Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018, <https://www.rfc-editor.org/info/rfc8446>.",
      "ja": "[RFC8446] Rescorla、E。、「輸送層セキュリティ（TLS）プロトコルバージョン1.3」、RFC 8446、DOI 10.17487/RFC8446、2018年8月、<https://www.rfc-editor.org/info/rfc846>"
    },
    {
      "indent": 3,
      "text": "[RFC8467] Mayrhofer, A., \"Padding Policies for Extension Mechanisms for DNS (EDNS(0))\", RFC 8467, DOI 10.17487/RFC8467, October 2018, <https://www.rfc-editor.org/info/rfc8467>.",
      "ja": "[RFC8467] Mayrhofer、A。、「DNSの拡張メカニズムのためのパディングポリシー（EDNS（0））」、RFC 8467、DOI 10.17487/RFC8467、2018年10月、<https://www.rfc-editor.org/info/RFC8467>。"
    },
    {
      "indent": 3,
      "text": "[RFC8484] Hoffman, P. and P. McManus, \"DNS Queries over HTTPS (DoH)\", RFC 8484, DOI 10.17487/RFC8484, October 2018, <https://www.rfc-editor.org/info/rfc8484>.",
      "ja": "[RFC8484] Hoffman、P。and P. McManus、「dns queries over https（doh）（doh）（doh）」、RFC 8484、doi 10.17487/rfc8484、2018年10月、<https://www.rfc-editor.org/info/rfc8484>。"
    },
    {
      "indent": 3,
      "text": "[RFC9209] Nottingham, M. and P. Sikora, \"The Proxy-Status HTTP Response Header Field\", RFC 9209, DOI 10.17487/RFC9209, June 2022, <https://www.rfc-editor.org/info/rfc9209>.",
      "ja": "[RFC9209]ノッティンガム、M。およびP.シコラ、「プロキシステータスHTTP応答ヘッダーフィールド」、RFC 9209、DOI 10.17487/RFC9209、2022年6月、<https://www.rfc-editor.org/info/rfc9209>。"
    },
    {
      "indent": 0,
      "text": "13.2. Informative References",
      "section_title": true,
      "ja": "13.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[Dolev-Yao] Dolev, D. and A. C. Yao, \"On the Security of Public Key Protocols\", IEEE Transactions on Information Theory, Vol. IT-29, No. 2, DOI 10.1109/TIT.1983.1056650, March 1983, <https://www.cs.huji.ac.il/~dolev/pubs/dolev-yao-ieee-01056650.pdf>.",
      "ja": "[Dolev-Yao] Dolev、D。およびA. C. Yao、「公開キープロトコルのセキュリティについて」、IEEE Transactions on Information Theory、Vol。IT-29、No。2、doi 10.1109/tit.1983.1056650、1983年3月、<https://www.cs.huji.ac.il/~dolev/pubs/dolev-yao-ieee-01056650.pdf>。"
    },
    {
      "indent": 3,
      "text": "[OBLIVIOUS-DNS] Edmundson, A., Schmitt, P., Feamster, N., and A. Mankin, \"Oblivious DNS - Strong Privacy for DNS Queries\", Work in Progress, Internet-Draft, draft-annee-dprive-oblivious-dns-00, 2 July 2018, <https://datatracker.ietf.org/doc/html/draft-annee-dprive-oblivious-dns-00>.",
      "ja": "[Oblivious-DNS] Edmundson、A.、Schmitt、P.、Feamster、N.、およびA. Mankin、「DNSクエリの強力なプライバシー」、進行中の作業、インターネットドラフト、ドラフトアニー-Dprive-Oblivious-dns-00、2018年7月2日、<https://datatracker.ietf.org/doc/html/draft-annee-dprive-oblivious-dns-00>。"
    },
    {
      "indent": 3,
      "text": "[OHTP] Thomson, M. and C.A. Wood, \"Oblivious HTTP\", Work in Progress, Internet-Draft, draft-ietf-ohai-ohttp-01, 15 February 2022, <https://datatracker.ietf.org/doc/html/ draft-ietf-ohai-ohttp-01>.",
      "ja": "[OHTP]トムソン、M。およびC.A.Wood、「Oblivious HTTP」、作業中の作業、インターネットドラフト、ドラフト-IITF-OHAI-OHTTP-01、2022年2月15日、<https://datatracker.ietf.org/doc/html/ draft-ietf-ohai-yiiOHTTP-01>。"
    },
    {
      "indent": 3,
      "text": "[RFC7239] Petersson, A. and M. Nilsson, \"Forwarded HTTP Extension\", RFC 7239, DOI 10.17487/RFC7239, June 2014, <https://www.rfc-editor.org/info/rfc7239>.",
      "ja": "[RFC7239]ピーターソン、A。およびM.ニルソン、「転送HTTP拡張」、RFC 7239、DOI 10.17487/RFC7239、2014年6月、<https://www.rfc-editor.org/info/rfc7239>"
    },
    {
      "indent": 3,
      "text": "[RFC7871] Contavalli, C., van der Gaast, W., Lawrence, D., and W. Kumari, \"Client Subnet in DNS Queries\", RFC 7871, DOI 10.17487/RFC7871, May 2016, <https://www.rfc-editor.org/info/rfc7871>.",
      "ja": "[RFC7871] Contavalli、C.、van der Gaast、W.、Lawrence、D.、およびW. Kumari、「DNSクエリのクライアントサブネット」、RFC 7871、DOI 10.17487/RFC7871、2016年5月、<https：// wwwwwwwwwwwwwwwwww.rfc-editor.org/info/rfc7871>。"
    },
    {
      "indent": 0,
      "text": "Appendix A. Use of Generic Proxy Services",
      "section_title": true,
      "ja": "付録A.ジェネリックプロキシサービスの使用"
    },
    {
      "indent": 3,
      "text": "Using DoH over anonymizing proxy services such as Tor can also achieve the desired goal of separating query origins from their contents. However, there are several reasons why such systems are undesirable as contrasted with Oblivious DoH:",
      "ja": "TORなどの匿名化プロキシサービスよりもDOHを使用すると、クエリオリジンをコンテンツから分離するという望ましい目標を達成することもできます。ただし、そのようなシステムが忘れられないDOHとは対照的に望ましくない理由はいくつかあります。"
    },
    {
      "indent": 3,
      "text": "1. Tor is meant to be a generic connection-level anonymity system, and it incurs higher latency costs and protocol complexity for the purpose of proxying individual DNS queries. In contrast, Oblivious DoH is a lightweight protocol built on DoH, implemented as an application-layer proxy, that can be enabled as a default mode for users that need increased privacy.",
      "ja": "1. TORは、一般的な接続レベルの匿名システムであることを意図しており、個々のDNSクエリをプロキシングする目的で、より高いレイテンシコストとプロトコルの複雑さが発生します。対照的に、Oblivious DOHは、アプリケーション層プロキシとして実装されたDOH上に構築された軽量プロトコルであり、プライバシーを増やす必要があるユーザーのデフォルトモードとして有効にできます。"
    },
    {
      "indent": 3,
      "text": "2. As a one-hop proxy, Oblivious DoH encourages connectionless proxies to mitigate Client query correlation with few round trips. In contrast, multi-hop systems such as Tor often run secure connections (TLS) end to end, which means that DoH servers could track queries over the same connection. Using a fresh DoH connection per query would incur a non-negligible penalty in connection setup time.",
      "ja": "2. ワンホッププロキシとして、忘却のDOHは、コネクションレスプロキシがクライアントクエリの相関を少数の往復と緩和することを奨励しています。対照的に、TORなどのマルチホップシステムは、多くの場合、セキュア接続（TLS）エンドからエンドを実行することがよくあります。つまり、DOHサーバーは同じ接続でクエリを追跡できます。クエリごとに新たなDOH接続を使用すると、セットアップ時間に依存しないペナルティが発生します。"
    },
    {
      "indent": 0,
      "text": "Acknowledgments",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "This work is inspired by Oblivious DNS [OBLIVIOUS-DNS]. Thanks to all of the authors of that document. Thanks to Nafeez Ahamed, Elliot Briggs, Marwan Fayed, Jonathan Hoyland, Frederic Jacobs, Tommy Jensen, Erik Nygren, Paul Schmitt, Brian Swander, and Peter Wu for their feedback and input.",
      "ja": "この作品は、忘却のDNS [忘却-DNS]に触発されています。その文書のすべての著者に感謝します。Nafeez Ahamed、Elliot Briggs、Marwan Fayed、Jonathan Hoyland、Frederic Jacobs、Tommy Jensen、Erik Nygren、Paul Schmitt、Brian Swander、Peter Wuのフィードバックとインプットに感謝します。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者のアドレス"
    },
    {
      "indent": 3,
      "text": "Eric Kinnear Apple Inc. One Apple Park Way Cupertino, California 95014 United States of America Email: ekinnear@apple.com",
      "ja": "Eric Kinnear Apple Inc. One Apple Park Way Cupertino、California 95014アメリカ合衆国電子メール：ekinnear@apple.com"
    },
    {
      "indent": 3,
      "text": "Patrick McManus Fastly Email: mcmanus@ducksong.com",
      "ja": "Patrick McManus早く電子メール：mcmanus@ducksong.com"
    },
    {
      "indent": 3,
      "text": "Tommy Pauly Apple Inc. One Apple Park Way Cupertino, California 95014 United States of America Email: tpauly@apple.com",
      "ja": "Tommy Pauly Apple Inc. One Apple Park Way Cupertino、カリフォルニア95014アメリカ合衆国電子メール：tpauly@apple.com"
    },
    {
      "indent": 3,
      "text": "Tanya Verma Cloudflare 101 Townsend St San Francisco, California 94107 United States of America Email: vermatanyax@gmail.com",
      "ja": "Tanya Verma Cloudflare 101 Townsend St San Francisco、カリフォルニア94107アメリカ合衆国電子メール：vermatanyax@gmail.com"
    },
    {
      "indent": 3,
      "text": "Christopher A. Wood Cloudflare 101 Townsend St San Francisco, California 94107 United States of America Email: caw@heapingbits.net",
      "ja": "クリストファーA.ウッドクラウドフラア101タウンゼントセントサンフランシスコ、カリフォルニア94107アメリカ合衆国電子メール：caw@heaping.net"
    }
  ]
}