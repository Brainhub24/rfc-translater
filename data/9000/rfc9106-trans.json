{
  "title": {
    "text": "RFC 9106 - Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications",
    "ja": "RFC 9106 - パスワードハッシュおよび作業証明アプリケーションのためのArgon2メモリ - ハード機能"
  },
  "number": 9106,
  "created_at": "2021-09-09 02:59:07.875194+09:00",
  "updated_by": "",
  "contents": [
    {
      "indent": 0,
      "text": "Internet Research Task Force (IRTF)                          A. Biryukov\nRequest for Comments: 9106                                       D. Dinu\nCategory: Informational                         University of Luxembourg\nISSN: 2070-1721                                          D. Khovratovich\n                                                         ABDK Consulting\n                                                            S. Josefsson\n                                                                  SJD AB\n                                                          September 2021",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Argon2 Memory-Hard Function for Password Hashing and Proof-of-Work Applications",
      "ja": "パスワードハッシュおよび作業証明アプリケーションのためのArgon2メモリ - ハード機能"
    },
    {
      "indent": 0,
      "text": "Abstract",
      "ja": "概要"
    },
    {
      "indent": 3,
      "text": "This document describes the Argon2 memory-hard function for password hashing and proof-of-work applications. We provide an implementer-oriented description with test vectors. The purpose is to simplify adoption of Argon2 for Internet protocols. This document is a product of the Crypto Forum Research Group (CFRG) in the IRTF.",
      "ja": "このドキュメントでは、パスワードハッシュおよび作業証明アプリケーションのARGON2メモリハード機能について説明します。テストベクトルを使用して実装志向の説明を提供します。目的は、インターネットプロトコルのためのArgon2の採用を単純化することです。この文書は、IRTFのCrypto Forum Research Group（CFRG）の製品です。"
    },
    {
      "indent": 0,
      "text": "Status of This Memo",
      "ja": "本文書の位置付け"
    },
    {
      "indent": 3,
      "text": "This document is not an Internet Standards Track specification; it is published for informational purposes.",
      "ja": "この文書はインターネット標準のトラック仕様ではありません。情報提供のために公開されています。"
    },
    {
      "indent": 3,
      "text": "This document is a product of the Internet Research Task Force (IRTF). The IRTF publishes the results of Internet-related research and development activities. These results might not be suitable for deployment. This RFC represents the consensus of the Crypto Forum Research Group of the Internet Research Task Force (IRTF). Documents approved for publication by the IRSG are not candidates for any level of Internet Standard; see Section 2 of RFC 7841.",
      "ja": "この文書は、インターネットリサーチタスクフォース（IRTF）の製品です。IRTFはインターネット関連の研究開発活動の結果を発行しています。これらの結果は展開には適していない可能性があります。このRFCは、インターネットリサーチタスクフォース（IRTF）のCryptoフォーラム研究グループの合意を表しています。IRSGによる出版が承認された文書は、インターネット規格のレベルレベルの候補者ではありません。RFC 7841のセクション2を参照してください。"
    },
    {
      "indent": 3,
      "text": "Information about the current status of this document, any errata, and how to provide feedback on it may be obtained at https://www.rfc-editor.org/info/rfc9106.",
      "ja": "この文書の現在のステータス、任意のエラータ、およびフィードバックを提供する方法は、https://www.rfc-editor.org/info/rfc9106で入手できます。"
    },
    {
      "indent": 0,
      "text": "Copyright Notice",
      "ja": "著作権表示"
    },
    {
      "indent": 3,
      "text": "Copyright (c) 2021 IETF Trust and the persons identified as the document authors. All rights reserved.",
      "ja": "著作権（C）2021 IETF信頼と文書著者として識別された人。全著作権所有。"
    },
    {
      "indent": 3,
      "text": "This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document. Please review these documents carefully, as they describe your rights and restrictions with respect to this document.",
      "ja": "この文書は、この文書の公開日に有効なIETF文書（https://truste.ietf.org/License-info）に関するBCP 78とIETF信頼の法的規定を受けています。この文書に関してあなたの権利と制限を説明するので、これらの文書を慎重に見直してください。"
    },
    {
      "indent": 0,
      "text": "Table of Contents",
      "ja": "目次"
    },
    {
      "indent": 3,
      "text": "1.  Introduction\n  1.1.  Requirements Language\n2.  Notation and Conventions\n3.  Argon2 Algorithm\n  3.1.  Argon2 Inputs and Outputs\n  3.2.  Argon2 Operation\n  3.3.  Variable-Length Hash Function H'\n  3.4.  Indexing\n    3.4.1.  Computing the 32-Bit Values J_1 and J_2\n    3.4.2.  Mapping J_1 and J_2 to Reference Block Index [l][z]\n  3.5.  Compression Function G\n  3.6.  Permutation P\n4.  Parameter Choice\n5.  Test Vectors\n  5.1.  Argon2d Test Vectors\n  5.2.  Argon2i Test Vectors\n  5.3.  Argon2id Test Vectors\n6.  IANA Considerations\n7.  Security Considerations\n  7.1.  Security as a Hash Function and KDF\n  7.2.  Security against Time-Space Trade-off Attacks\n  7.3.  Security for Time-Bounded Defenders\n  7.4.  Recommendations\n8.  References\n  8.1.  Normative References\n  8.2.  Informative References\nAcknowledgements\nAuthors' Addresses",
      "raw": true,
      "toc": true,
      "ja": ""
    },
    {
      "indent": 0,
      "text": "1. Introduction",
      "section_title": true,
      "ja": "1. はじめに"
    },
    {
      "indent": 3,
      "text": "This document describes the Argon2 [ARGON2ESP] memory-hard function for password hashing and proof-of-work applications. We provide an implementer-oriented description with test vectors. The purpose is to simplify adoption of Argon2 for Internet protocols. This document corresponds to version 1.3 of the Argon2 hash function.",
      "ja": "このドキュメントでは、パスワードハッシュおよび作業証明アプリケーションのためのargon2 [argon2esp]メモリハード機能について説明します。テストベクトルを使用して実装志向の説明を提供します。目的は、インターネットプロトコルのためのArgon2の採用を単純化することです。この文書はArgon2 Hash関数のバージョン1.3に対応しています。"
    },
    {
      "indent": 3,
      "text": "Argon2 is a memory-hard function [HARD]. It is a streamlined design. It aims at the highest memory-filling rate and effective use of multiple computing units, while still providing defense against trade-off attacks. Argon2 is optimized for the x86 architecture and exploits the cache and memory organization of the recent Intel and AMD processors. Argon2 has one primary variant, Argon2id, and two supplementary variants, Argon2d and Argon2i. Argon2d uses data-dependent memory access, which makes it suitable for cryptocurrencies and proof-of-work applications with no threats from side-channel timing attacks. Argon2i uses data-independent memory access, which is preferred for password hashing and password-based key derivation. Argon2id works as Argon2i for the first half of the first pass over the memory and as Argon2d for the rest, thus providing both side-channel attack protection and brute-force cost savings due to time-memory trade-offs. Argon2i makes more passes over the memory to protect from trade-off attacks [AB15].",
      "ja": "ARGON2はメモリハード機能です[ハード]。合理化されたデザインです。それは依然としてトレードオフ攻撃に対する防御を提供しながら、それは依然として複数のコンピューティングユニットの最高のメモリ充填率および効果的な使用を目的としています。 ARGON2はx86アーキテクチャに最適化され、最近のIntelプロセッサとAMDプロセッサのキャッシュとメモリの整理を利用しています。アルゴン2は、1つの一次変種、アルゴン2ID、および2つの補助変異体、Argon2DおよびArgon2Iを有する。 ARGON2Dはデータ依存メモリアクセスを使用しています。これにより、サイドチャネルタイミング攻撃から脅威のない暗号化および作業実証アプリケーションに適しています。 Argon2iはデータに依存しないメモリアクセスを使用します。これは、パスワードハッシュとパスワードベースのキー導出に優先されます。 ARGON2IDは、最初のパスの前半のメモリの前半として、そして残りのためのArgon2Dの場合はArgon2iとして機能し、タイムメモリのトレードオフによるサイドチャネル攻撃保護とブルートフォースコスト削減の両方を提供します。 ARGON2Iは、トレードオフ攻撃から保護するためにメモリを超過します[AB15]。"
    },
    {
      "indent": 3,
      "text": "Argon2id MUST be supported by any implementation of this document, whereas Argon2d and Argon2i MAY be supported.",
      "ja": "ARGON2IDはこのドキュメントの任意の実装によってサポートされなければなりませんが、ARGON2DとARGON2Iがサポートされている可能性があります。"
    },
    {
      "indent": 3,
      "text": "Argon2 is also a mode of operation over a fixed-input-length compression function G and a variable-input-length hash function H. Even though Argon2 can be potentially used with an arbitrary function H, as long as it provides outputs up to 64 bytes, the BLAKE2b function [BLAKE2] is used in this document.",
      "ja": "ARGON2は、固定入力長圧縮関数Gと可変入力長さのハッシュ関数Hを介した動作モードでも、Argon2は任意の関数Hで潜在的に使用できる場合でも、最大64の出力を提供する限り、任意の関数Hで使用できる。バイト、Blake2B機能[Blake2]はこの文書で使用されています。"
    },
    {
      "indent": 3,
      "text": "For further background and discussion, see the Argon2 paper [ARGON2].",
      "ja": "さらなる背景と議論については、Argon2 Paper [Argon2]を参照してください。"
    },
    {
      "indent": 3,
      "text": "This document represents the consensus of the Crypto Forum Research Group (CFRG).",
      "ja": "この文書は、Crypto Forum Research Group（CFRG）の合意を表しています。"
    },
    {
      "indent": 0,
      "text": "1.1. Requirements Language",
      "section_title": true,
      "ja": "1.1. 要件言語"
    },
    {
      "indent": 3,
      "text": "The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all capitals, as shown here.",
      "ja": "この文書のキーワード \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", および \"OPTIONAL\" はBCP 14 [RFC2119] [RFC8174]で説明されているように、すべて大文字の場合にのみ解釈されます。"
    },
    {
      "indent": 0,
      "text": "2. Notation and Conventions",
      "section_title": true,
      "ja": "2. 表記法と規則"
    },
    {
      "indent": 3,
      "text": "x^y integer x multiplied by itself integer y times",
      "ja": "X ^ Y整数x自体整数y回数を掛けた"
    },
    {
      "indent": 3,
      "text": "a*b multiplication of integer a and integer b",
      "ja": "整数aと整数bのa * b乗算"
    },
    {
      "indent": 3,
      "text": "c-d subtraction of integer d from integer c",
      "ja": "整数からの整数dのC-D減算"
    },
    {
      "indent": 3,
      "text": "E_f variable E with subscript index f",
      "ja": "e_f添え字インデックスFを含む変数e"
    },
    {
      "indent": 3,
      "text": "g / h integer g divided by integer h. The result is a rational number.",
      "ja": "G / H整数gは整数hで割った。結果は有理数です。"
    },
    {
      "indent": 3,
      "text": "I(j) function I evaluated at j",
      "ja": "I（J）関数I Jで評価した"
    },
    {
      "indent": 3,
      "text": "K || L string K concatenated with string L",
      "ja": "k ||L文字列Kは文字列Lと連結されました"
    },
    {
      "indent": 3,
      "text": "a XOR b bitwise exclusive-or between bitstrings a and b",
      "ja": "ビットストリングAとBのXOR Bビット単位排他的またはB間"
    },
    {
      "indent": 3,
      "text": "a mod b remainder of integer a modulo integer b, always in range [0, b-1]",
      "ja": "整数整数b、常に範囲内のmod bの残りの部分[0、B  -  1]"
    },
    {
      "indent": 3,
      "text": "a >>> n        rotation of 64-bit string a to the right by n bits",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "trunc(a) the 64-bit value, truncated to the 32 least significant bits",
      "ja": "TRUNC（A）64ビット値、32個の最下位ビットに切り捨てられた"
    },
    {
      "indent": 3,
      "text": "floor(a) the largest integer not bigger than a",
      "ja": "フロア（a）最大整数は"
    },
    {
      "indent": 3,
      "text": "ceil(a) the smallest integer not smaller than a",
      "ja": "CEIL（A）最小の整数は"
    },
    {
      "indent": 3,
      "text": "extract(a, i) the i-th set of 32 bits from bitstring a, starting from 0-th",
      "ja": "0から始まるBitString Aからの32ビットの抽出（a、i）"
    },
    {
      "indent": 3,
      "text": "|A| the number of elements in set A",
      "ja": "| A |セットAの要素数"
    },
    {
      "indent": 3,
      "text": "LE32(a) 32-bit integer a converted to a byte string in little endian (for example, 123456 (decimal) is 40 E2 01 00)",
      "ja": "LE32（a）32ビット整数Aバイト文字列に変換されたリトルエンディアン（例えば、123456（10進数）は40 E2 0100です）"
    },
    {
      "indent": 3,
      "text": "LE64(a) 64-bit integer a converted to a byte string in little endian (for example, 123456 (decimal) is 40 E2 01 00 00 00 00 00)",
      "ja": "LE64（a）64ビット整数Aバイト文字列に変換されたリトルエンディアンのバイト文字列（例えば、123456（10進数）は40 e2 01 00 00 00 00 00 00）"
    },
    {
      "indent": 3,
      "text": "int32(s) 32-bit string s is converted to a non-negative integer in little endian",
      "ja": "INT32（S）32ビット文字列sは、リトルエンディアンでは負でない整数に変換されます。"
    },
    {
      "indent": 3,
      "text": "int64(s) 64-bit string s is converted to a non-negative integer in little endian",
      "ja": "INT64（S）64ビット文字列Sは、リトルエンディアンでは負でない整数に変換されます。"
    },
    {
      "indent": 3,
      "text": "length(P) the byte length of string P expressed as 32-bit integer",
      "ja": "length（p）文字列pのバイト長は32ビット整数として表しています"
    },
    {
      "indent": 3,
      "text": "ZERO(P) the P-byte zero string",
      "ja": "ゼロ（P）Pバイトゼロ文字列"
    },
    {
      "indent": 0,
      "text": "3. Argon2 Algorithm",
      "section_title": true,
      "ja": "3. アルゴン2アルゴリズム"
    },
    {
      "indent": 0,
      "text": "3.1. Argon2 Inputs and Outputs",
      "section_title": true,
      "ja": "3.1. Argon2入力と出力"
    },
    {
      "indent": 3,
      "text": "Argon2 has the following input parameters:",
      "ja": "ARGON2には次の入力パラメータがあります。"
    },
    {
      "indent": 3,
      "text": "* Message string P, which is a password for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* メッセージ文字列P。パスワードハッシュアプリケーションのパスワードである。2 ^（32）-1バイト以下の長さを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Nonce S, which is a salt for password hashing applications. It MUST have a length not greater than 2^(32)-1 bytes. 16 bytes is RECOMMENDED for password hashing. The salt SHOULD be unique for each password.",
      "ja": "* パスワードハッシュアプリケーションの塩であるNonce S。2 ^（32）-1バイト以下の長さを持たなければなりません。パスワードハッシュには16バイトをお勧めします。塩は各パスワードに固有であるべきです。"
    },
    {
      "indent": 3,
      "text": "* Degree of parallelism p determines how many independent (but synchronizing) computational chains (lanes) can be run. It MUST be an integer value from 1 to 2^(24)-1.",
      "ja": "* 並列度Pの程度は、独立した（しかし同期化）計算チェーン（レーン）を実行できるものを決定する。1~2 ^（24）-1の整数値でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Tag length T MUST be an integer number of bytes from 4 to 2^(32)- 1.",
      "ja": "* タグ長Tは、4から2 ^（32） -  1までの整数バイト数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Memory size m MUST be an integer number of kibibytes from 8*p to 2^(32)-1. The actual number of blocks is m', which is m rounded down to the nearest multiple of 4*p.",
      "ja": "* メモリサイズMは、8 * P~2 ^（32）-1の整数キバイトでなければなりません。実際のブロック数はm 'です。これは4 * pの最も近い倍数に切り捨てられます。"
    },
    {
      "indent": 3,
      "text": "* Number of passes t (used to tune the running time independently of the memory size) MUST be an integer number from 1 to 2^(32)-1.",
      "ja": "* パス数T（メモリサイズとは無関係に実行時間を調整するために使用）は、1から2 ^（32）-1までの整数でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Version number v MUST be one byte 0x13.",
      "ja": "* バージョン番号vは1バイト0x13でなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Secret value K is OPTIONAL. If used, it MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* 秘密値Kはオプションです。使用されている場合、それは2 ^（32）-1バイト以下の長さを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Associated data X is OPTIONAL. If used, it MUST have a length not greater than 2^(32)-1 bytes.",
      "ja": "* 関連データXはオプションです。使用されている場合、それは2 ^（32）-1バイト以下の長さを持たなければなりません。"
    },
    {
      "indent": 3,
      "text": "* Type y MUST be 0 for Argon2d, 1 for Argon2i, or 2 for Argon2id.",
      "ja": "* ARGON2D、ARGON2Iの場合は1、ARGON2IDの場合は2の場合はyと入力してください。"
    },
    {
      "indent": 3,
      "text": "The Argon2 output, or \"tag\", is a string T bytes long.",
      "ja": "ARGON2出力、または「タグ」は、長い文字列Tバイトです。"
    },
    {
      "indent": 0,
      "text": "3.2. Argon2 Operation",
      "section_title": true,
      "ja": "3.2. アルゴン2操作"
    },
    {
      "indent": 3,
      "text": "Argon2 uses an internal compression function G with two 1024-byte inputs, a 1024-byte output, and an internal hash function H^x(), with x being its output length in bytes. Here, H^x() applied to string A is the BLAKE2b ([BLAKE2], Section 3.3) function, which takes (d,ll,kk=0,nn=x) as parameters, where d is A padded to a multiple of 128 bytes and ll is the length of d in bytes. The compression function G is based on its internal permutation. A variable-length hash function H' built upon H is also used. G is described in Section 3.5, and H' is described in Section 3.3.",
      "ja": "ARGON2は、2つの1024バイトの入力、1024バイトの出力、および内部ハッシュ関数H ^ x（）を持つ内部圧縮関数Gを使用して、xはその出力長はバイト数です。ここで、文字列Aに適用されるH ^ x（）は、Blake2B（[Blake2]、3.3）関数で、D、LL、KK = 0、NN = X）はパラメータとして、Dは倍の埋め込みです。128バイト、LLの長さはバイト数のDの長さです。圧縮関数Gはその内部置換に基づいています。Hに基づいた可変長ハッシュ関数H 'も使用されています。gはセクション3.5に記載されており、h 'はセクション3.3で説明されています。"
    },
    {
      "indent": 3,
      "text": "The Argon2 operation is as follows.",
      "ja": "アルゴン2の操作は次のとおりです。"
    },
    {
      "indent": 3,
      "text": "1. Establish H_0 as the 64-byte value as shown below. If K, X, or S has zero length, it is just absent, but its length field remains.",
      "ja": "1. 以下に示すように、64バイトの値としてH_0を確立します。k、x、またはsが長さがゼロの場合、それは存在しないが、その長さフィールドは残ります。"
    },
    {
      "indent": 7,
      "text": "H_0 = H^(64)(LE32(p) || LE32(T) || LE32(m) || LE32(t) ||\n        LE32(v) || LE32(y) || LE32(length(P)) || P ||\n        LE32(length(S)) || S ||  LE32(length(K)) || K ||\n        LE32(length(X)) || X)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "Figure 1: H_0 Generation",
      "ja": "図1：H_0の生成"
    },
    {
      "indent": 3,
      "text": "2. Allocate the memory as m' 1024-byte blocks, where m' is derived as:",
      "ja": "2. メモリをM '1024バイトブロックとして割り当てます。ここで、m'は次のように派生します。"
    },
    {
      "indent": 7,
      "text": "m' = 4 * p * floor (m / 4p)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 2: Memory Allocation",
      "ja": "図2：メモリ割り当て"
    },
    {
      "indent": 7,
      "text": "For p lanes, the memory is organized in a matrix B[i][j] of blocks with p rows (lanes) and q = m' / p columns.",
      "ja": "Pレーンの場合、メモリは、P行（レーン）およびQ = M '/ P列のブロックのマトリックスB [i] [j]に編成されます。"
    },
    {
      "indent": 3,
      "text": "3. Compute B[i][0] for all i ranging from (and including) 0 to (not including) p.",
      "ja": "3. （および含めて）0から（も含む）pの範囲のすべての私のすべてのためにb [i] [0]を計算します。"
    },
    {
      "indent": 7,
      "text": "B[i][0] = H'^(1024)(H_0 || LE32(0) || LE32(i))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 25,
      "text": "Figure 3: Lane Starting Blocks",
      "ja": "図3：車線起動ブロック"
    },
    {
      "indent": 3,
      "text": "4. Compute B[i][1] for all i ranging from (and including) 0 to (not including) p.",
      "ja": "4. （および含む）0から（含まない）pまでのすべての私の範囲のすべての私[i] [1]を計算します。"
    },
    {
      "indent": 7,
      "text": "B[i][1] = H'^(1024)(H_0 || LE32(1) || LE32(i))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 4: Second Lane Blocks",
      "ja": "図4：2番目の車線ブロック"
    },
    {
      "indent": 3,
      "text": "5. Compute B[i][j] for all i ranging from (and including) 0 to (not including) p and for all j ranging from (and including) 2 to (not including) q. The computation MUST proceed slicewise (Section 3.4): first, blocks from slice 0 are computed for all lanes (in an arbitrary order of lanes), then blocks from slice 1 are computed, etc. The block indices l and z are determined for each i, j differently for Argon2d, Argon2i, and Argon2id.",
      "ja": "5. （および含む）0から（もの）P、および（も含む）Qから（および含む）すべてのjの範囲のすべてのi、q。計算はスライスウィーズを進める必要があります（セクション3.4）。まず、スライス0からのブロックがすべてのレーンに対して（レーンの任意の順序で）計算され、次にスライス1からのブロックなどが計算される。ブロックインデックスLおよびZがそれぞれに決定される。i、j argon2d、argon2i、およびargon2idの異なる方法。"
    },
    {
      "indent": 7,
      "text": "B[i][j] = G(B[i][j-1], B[l][z])",
      "ja": "b [i] = g（b [i] [j  -  1]、b [l] [z]）"
    },
    {
      "indent": 23,
      "text": "Figure 5: Further Block Generation",
      "ja": "図5：さらなるブロック生成"
    },
    {
      "indent": 3,
      "text": "6. If the number of passes t is larger than 1, we repeat step 5. We compute B[i][0] and B[i][j] for all i raging from (and including) 0 to (not including) p and for all j ranging from (and including) 1 to (not including) q. However, blocks are computed differently as the old value is XORed with the new one:",
      "ja": "6. パス数Tが1より大きい場合は、ステップ5を繰り返します.0から（も含む）0から（含まれない）P、およびP、およびPとの間でB [i] [0]とB [i] [j]を計算します。1から（も含む）1までのすべてのjの場合q。ただし、古い値が新しい値でXORSされているため、ブロックは異なる方法で計算されます。"
    },
    {
      "indent": 7,
      "text": "B[i][0] = G(B[i][q-1], B[l][z]) XOR B[i][0]; B[i][j] = G(B[i][j-1], B[l][z]) XOR B[i][j].",
      "ja": "b [i] [0] = g（b [i] [q  -  1]、b [l] [z]）xor b [i] [0];b [i] = g（b [i] [j  -  1]、b [l] [z]）xor b [i] [j]。"
    },
    {
      "indent": 28,
      "text": "Figure 6: Further Passes",
      "ja": "図6：それ以上の通過"
    },
    {
      "indent": 3,
      "text": "7. After t steps have been iterated, the final block C is computed as the XOR of the last column:",
      "ja": "7. Tステップが繰り返された後、最後のブロックCは最後の列のXORとして計算されます。"
    },
    {
      "indent": 7,
      "text": "C = B[0][q-1] XOR B[1][q-1] XOR ... XOR B[p-1][q-1]",
      "ja": "C = B [0] [Q  -  1] XOR B [1] [Q  -  1] XOR ... XOR B [P-1] [Q-1]"
    },
    {
      "indent": 29,
      "text": "Figure 7: Final Block",
      "ja": "図7：最終ブロック"
    },
    {
      "indent": 3,
      "text": "8. The output tag is computed as H'^T(C).",
      "ja": "8. 出力タグはH '^ T（c）として計算されます。"
    },
    {
      "indent": 0,
      "text": "3.3. Variable-Length Hash Function H'",
      "section_title": true,
      "ja": "3.3. 可変長ハッシュ関数H '"
    },
    {
      "indent": 3,
      "text": "Let V_i be a 64-byte block and W_i be its first 32 bytes. Then we define function H' as follows:",
      "ja": "v_iを64バイトブロックとし、w_iはその最初の32バイトになります。次に、関数H 'を次のように定義します。"
    },
    {
      "indent": 11,
      "text": "if T <= 64\n    H'^T(A) = H^T(LE32(T)||A)\nelse\n    r = ceil(T/32)-2\n    V_1 = H^(64)(LE32(T)||A)\n    V_2 = H^(64)(V_1)\n    ...\n    V_r = H^(64)(V_{r-1})\n    V_{r+1} = H^(T-32*r)(V_{r})\n    H'^T(X) = W_1 || W_2 || ... || W_r || V_{r+1}",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 8,
      "text": "Figure 8: Function H' for Tag and Initial Block Computations",
      "ja": "図8：タグと初期ブロック計算の関数h '"
    },
    {
      "indent": 0,
      "text": "3.4. Indexing",
      "section_title": true,
      "ja": "3.4. 索引付け"
    },
    {
      "indent": 3,
      "text": "To enable parallel block computation, we further partition the memory matrix into SL = 4 vertical slices. The intersection of a slice and a lane is called a segment, which has a length of q/SL. Segments of the same slice can be computed in parallel and do not reference blocks from each other. All other blocks can be referenced.",
      "ja": "並列ブロック計算を可能にするために、メモリマトリックスをさらにSL = 4つの垂直スライスに分割する。スライスとレーンとの交差点は、長さのQ / SLを有するセグメントと呼ばれます。同じスライスのセグメントは並行して計算することができ、互いにブロックを参照しない。他のすべてのブロックを参照することができます。"
    },
    {
      "indent": 5,
      "text": "  slice 0    slice 1    slice 2    slice 3\n  ___/\\___   ___/\\___   ___/\\___   ___/\\___\n /        \\ /        \\ /        \\ /        \\\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 0\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 1\n+----------+----------+----------+----------+\n|          |          |          |          | > lane 2\n+----------+----------+----------+----------+\n|         ...        ...        ...         | ...\n+----------+----------+----------+----------+\n|          |          |          |          | > lane p - 1\n+----------+----------+----------+----------+",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "Figure 9: Single-Pass Argon2 with p Lanes and 4 Slices",
      "ja": "図9：Pレーンと4スライスを持つシングルパスアルゴン2"
    },
    {
      "indent": 0,
      "text": "3.4.1. Computing the 32-Bit Values J_1 and J_2",
      "section_title": true,
      "ja": "3.4.1. 32ビット値J_1とJ_2の計算"
    },
    {
      "indent": 0,
      "text": "3.4.1.1. Argon2d",
      "section_title": true,
      "ja": "3.4.1.1. アルゴン2D"
    },
    {
      "indent": 3,
      "text": "J_1 is given by the first 32 bits of block B[i][j-1], while J_2 is given by the next 32 bits of block B[i][j-1]:",
      "ja": "J_1はブロックB [i] [j  -  1]の最初の32ビットによって与えられ、J_2はブロックB [i] [J-1]の次の32ビットによって与えられます。"
    },
    {
      "indent": 3,
      "text": "J_1 = int32(extract(B[i][j-1], 0))\nJ_2 = int32(extract(B[i][j-1], 1))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 20,
      "text": "Figure 10: Deriving J1,J2 in Argon2d",
      "ja": "図10：ARGON2DのJ1、J2を導出する"
    },
    {
      "indent": 0,
      "text": "3.4.1.2. Argon2i",
      "section_title": true,
      "ja": "3.4.1.2. Argon2i."
    },
    {
      "indent": 3,
      "text": "For each segment, we do the following. First, we compute the value Z as:",
      "ja": "セグメントごとに、次のようにします。まず、値zを次のように計算します。"
    },
    {
      "indent": 3,
      "text": "Z= ( LE64(r) || LE64(l) || LE64(sl) || LE64(m') ||\n     LE64(t) || LE64(y) )",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 16,
      "text": "Figure 11: Input to Compute J1,J2 in Argon2i",
      "ja": "図11：argon2iのJ1、J2を計算するための入力"
    },
    {
      "indent": 3,
      "text": "where",
      "ja": "ただし"
    },
    {
      "indent": 3,
      "text": "r: the pass number l: the lane number sl: the slice number m': the total number of memory blocks t: the total number of passes y: the Argon2 type (0 for Argon2d, 1 for Argon2i, 2 for Argon2id)",
      "ja": "R：パス番号L：レーン番号SL：スライス番号M '：メモリブロックの総数T：合計パス数Y：argon2タイプ（Argon2Dの場合は0、argon2iの場合は0 for AGRON2ID）"
    },
    {
      "indent": 3,
      "text": "Then we compute:",
      "ja": "それから我々は計算します："
    },
    {
      "indent": 3,
      "text": "q/(128*SL) 1024-byte values G(ZERO(1024),G(ZERO(1024), Z || LE64(1) || ZERO(968) )), G(ZERO(1024),G(ZERO(1024), Z || LE64(2) || ZERO(968) )),... , G(ZERO(1024),G(ZERO(1024), Z || LE64(q/(128*SL)) || ZERO(968) )),",
      "ja": "Q /（128 * SL）1024バイト値G（ゼロ（1024）、G（ゼロ（1024）、Z || LE64（1）||ゼロ（968）））、G（ゼロ（1024）、G（ゼロ（1024）、Z || LE64（2）||ゼロ（968））、...、g（ゼロ（1024）、G（ゼロ（1024）、Z || LE64（Q /（128 * SL）））||ゼロ（968）））"
    },
    {
      "indent": 3,
      "text": "which are partitioned into q/(SL) 8-byte values X, which are viewed as X1||X2 and converted to J_1=int32(X1) and J_2=int32(X2).",
      "ja": "これはq /（SL）8バイト値xに分割され、これはx1 || x2と見られ、j_1 = int32（x1）とj_2 = int32（x2）に変換されます。"
    },
    {
      "indent": 3,
      "text": "The values r, l, sl, m', t, y, and i are represented as 8 bytes in little endian.",
      "ja": "値R、L、SL、M '、T、Y、およびIは、リトルエンディアンで8バイトと表されます。"
    },
    {
      "indent": 0,
      "text": "3.4.1.3. Argon2id",
      "section_title": true,
      "ja": "3.4.1.3. アルゴン2ID"
    },
    {
      "indent": 3,
      "text": "If the pass number is 0 and the slice number is 0 or 1, then compute J_1 and J_2 as for Argon2i, else compute J_1 and J_2 as for Argon2d.",
      "ja": "パス番号が0で、スライス番号が0または1の場合は、j_1とj_2がargon2iとして計算し、argon2dとしてJ_1とJ_2を計算します。"
    },
    {
      "indent": 0,
      "text": "3.4.2. Mapping J_1 and J_2 to Reference Block Index [l][z]",
      "section_title": true,
      "ja": "3.4.2. j_1とj_2のマッピングブロックインデックス[l] [z]"
    },
    {
      "indent": 3,
      "text": "The value of l = J_2 mod p gives the index of the lane from which the block will be taken. For the first pass (r=0) and the first slice (sl=0), the block is taken from the current lane.",
      "ja": "l = j_2 mod pの値は、ブロックが取得されるレーンのインデックスを与える。最初のパス（R = 0）と最初のスライス（SL = 0）の場合、ブロックは現在のレーンから取り出されます。"
    },
    {
      "indent": 3,
      "text": "The set W contains the indices that are referenced according to the following rules:",
      "ja": "SET Wには、次の規則に従って参照されるインデックスが含まれています。"
    },
    {
      "indent": 3,
      "text": "1. If l is the current lane, then W includes the indices of all blocks in the last SL - 1 = 3 segments computed and finished, as well as the blocks computed in the current segment in the current pass excluding B[i][j-1].",
      "ja": "1. Lが現在のレーンである場合、Wは、最後に、最後に終了したSL  -  1 = 3セグメントのすべてのブロックのインデックス、およびB [i]を除く現在のパスの現在のセグメントで計算されたブロックを含む。1]。"
    },
    {
      "indent": 3,
      "text": "2. If l is not the current lane, then W includes the indices of all blocks in the last SL - 1 = 3 segments computed and finished in lane l. If B[i][j] is the first block of a segment, then the very last index from W is excluded.",
      "ja": "2. Lが現在の車線ではない場合、Wは最後のSL  -  1 = 3セグメント内の全ブロックのインデックスを含む。b [i] [j]がセグメントの最初のブロックである場合、Wからの最後のインデックスは除外されます。"
    },
    {
      "indent": 3,
      "text": "Then take a block from W with a nonuniform distribution over [0, |W|) using the following mapping:",
      "ja": "次に、次のマッピングを使用して、[0、| w |の上で不均一な分布でWからブロックを取ります。"
    },
    {
      "indent": 3,
      "text": "J_1 -> |W|(1 - J_1^2 / 2^(64))",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 12: Computing J1",
      "ja": "図12：コンピューティングJ1"
    },
    {
      "indent": 3,
      "text": "To avoid floating point computation, the following approximation is used:",
      "ja": "浮動小数点の計算を避けるために、次の近似値が使用されます。"
    },
    {
      "indent": 3,
      "text": "x = J_1^2 / 2^(32)\ny = (|W| * x) / 2^(32)\nzz = |W| - 1 - y",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 22,
      "text": "Figure 13: Computing J1, Part 2",
      "ja": "図13：コンピューティングJ1、その2"
    },
    {
      "indent": 3,
      "text": "Then take the zz-th index from W; it will be the z value for the reference block index [l][z].",
      "ja": "次にzz-th索引をwから取ります。参照ブロックインデックス[L] [z]のz値になります。"
    },
    {
      "indent": 0,
      "text": "3.5. Compression Function G",
      "section_title": true,
      "ja": "3.5. 圧縮関数G."
    },
    {
      "indent": 3,
      "text": "The compression function G is built upon the BLAKE2b-based transformation P. P operates on the 128-byte input, which can be viewed as eight 16-byte registers:",
      "ja": "圧縮関数GはBlake2Bベースの変換Pに基づいて構築されています.pは128バイトの入力で動作します。これは、8バイトの16バイトのレジスタと見なすことができます。"
    },
    {
      "indent": 3,
      "text": "P(A_0, A_1, ... ,A_7) = (B_0, B_1, ... ,B_7)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 21,
      "text": "Figure 14: Blake Round Function P",
      "ja": "図14：ブレイクラウンド関数P."
    },
    {
      "indent": 3,
      "text": "The compression function G(X, Y) operates on two 1024-byte blocks X and Y. It first computes R = X XOR Y. Then R is viewed as an 8x8 matrix of 16-byte registers R_0, R_1, ... , R_63. Then P is first applied to each row, and then to each column to get Z:",
      "ja": "圧縮関数g（x、y）は、2つの1024バイトのブロックxおよびyに対して動作する。最初にr = x xor yを計算します。その後、Rは16バイトレジスタR_0、R_1、...、8x8行列と見なされます。R_63。その後、Pを最初に各行に適用し、次に各列にZ：を取得します。"
    },
    {
      "indent": 3,
      "text": "( Q_0,  Q_1,  Q_2, ... ,  Q_7) <- P( R_0,  R_1,  R_2, ... ,  R_7)\n( Q_8,  Q_9, Q_10, ... , Q_15) <- P( R_8,  R_9, R_10, ... , R_15)\n                              ...\n(Q_56, Q_57, Q_58, ... , Q_63) <- P(R_56, R_57, R_58, ... , R_63)\n( Z_0,  Z_8, Z_16, ... , Z_56) <- P( Q_0,  Q_8, Q_16, ... , Q_56)\n( Z_1,  Z_9, Z_17, ... , Z_57) <- P( Q_1,  Q_9, Q_17, ... , Q_57)\n                              ...\n( Z_7, Z_15, Z 23, ... , Z_63) <- P( Q_7, Q_15, Q_23, ... , Q_63)",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 17,
      "text": "Figure 15: Core of Compression Function G",
      "ja": "図15：圧縮関数の中核G."
    },
    {
      "indent": 3,
      "text": "Finally, G outputs Z XOR R:",
      "ja": "最後に、G出力z XOR R："
    },
    {
      "indent": 3,
      "text": "G: (X, Y) -> R -> Q -> Z -> Z XOR R",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 28,
      "text": "+---+       +---+\n| X |       | Y |\n+---+       +---+\n  |           |\n  ---->XOR<----\n--------|\n|      \\ /\n|     +---+\n|     | R |\n|     +---+\n|       |\n|      \\ /\n|   P rowwise\n|       |\n|      \\ /\n|     +---+\n|     | Q |\n|     +---+\n|       |\n|      \\ /\n|  P columnwise\n|       |\n|      \\ /\n|     +---+\n|     | Z |\n|     +---+\n|       |\n|      \\ /\n------>XOR\n        |\n       \\ /",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 18,
      "text": "Figure 16: Argon2 Compression Function G",
      "ja": "図16：ARGON2圧縮関数G."
    },
    {
      "indent": 0,
      "text": "3.6. Permutation P",
      "section_title": true,
      "ja": "3.6. 順列P"
    },
    {
      "indent": 3,
      "text": "Permutation P is based on the round function of BLAKE2b.  The eight\n16-byte inputs S_0, S_1, ... , S_7 are viewed as a 4x4 matrix of\n64-bit words, where S_i = (v_{2*i+1} || v_{2*i}):",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": " v_0 v_1 v_2 v_3 v_4 v_5 v_6 v_7 v_8 v_9 v_10 v_11 v_12 v_13 v_14 v_15",
      "ja": "V_0 V_1 V_2 V_3 V_4 V_05 V_6 V_7 V_1 V_11 V_12 V_14 V_14 V_15"
    },
    {
      "indent": 21,
      "text": "Figure 17: Matrix Element Labeling",
      "ja": "図17：行列要素のラベル付け"
    },
    {
      "indent": 3,
      "text": "It works as follows:",
      "ja": "それは次のように動作します。"
    },
    {
      "indent": 11,
      "text": "GB(v_0, v_4, v_8, v_12) GB(v_1, v_5, v_9, v_13) GB(v_2, v_6, v_10, v_14) GB(v_3, v_7, v_11, v_15)",
      "ja": "GB（V_0、V_4、V_8、V_12）GB（V_1、V_5、V_9、V_13）GB（V_2、V_6、V_10、V_14）GB（V_3、V_7、V_11、V_15）"
    },
    {
      "indent": 11,
      "text": "GB(v_0, v_5, v_10, v_15) GB(v_1, v_6, v_11, v_12) GB(v_2, v_7, v_8, v_13) GB(v_3, v_4, v_9, v_14)",
      "ja": "GB（V_0、V_5、V_10、V_15）GB（V_1、V_6、V_11、V_12）GB（V_2、V_7、V_8、V_13）GB（V_3、V_4、V_9、V_14）"
    },
    {
      "indent": 18,
      "text": "Figure 18: Feeding Matrix Elements to GB",
      "ja": "図18：マトリックス要素をGBに供給する"
    },
    {
      "indent": 3,
      "text": "GB(a, b, c, d) is defined as follows:",
      "ja": "GB（A、B、C、D）は次のように定義されています。"
    },
    {
      "indent": 11,
      "text": "a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)\nd = (d XOR a) >>> 32\nc = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)\nb = (b XOR c) >>> 24",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 11,
      "text": "a = (a + b + 2 * trunc(a) * trunc(b)) mod 2^(64)\nd = (d XOR a) >>> 16\nc = (c + d + 2 * trunc(c) * trunc(d)) mod 2^(64)\nb = (b XOR c) >>> 63",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 26,
      "text": "Figure 19: Details of GB",
      "ja": "図19：GBの詳細"
    },
    {
      "indent": 3,
      "text": "The modular additions in GB are combined with 64-bit multiplications. Multiplications are the only difference from the original BLAKE2b design. This choice is done to increase the circuit depth and thus the running time of ASIC implementations, while having roughly the same running time on CPUs thanks to parallelism and pipelining.",
      "ja": "GBのモジュラー加算は64ビットの乗算と組み合わされています。乗算は、元のBlake2Bデザインとの唯一の違いです。この選択は、並列処理とパイプライン化のおかげで、CPU上のほぼ同じ運転時間を持ちながら、回路の深さ、したがってASIC実装の実行時間を長くするために行われます。"
    },
    {
      "indent": 0,
      "text": "4. Parameter Choice",
      "section_title": true,
      "ja": "4. パラメータの選択"
    },
    {
      "indent": 3,
      "text": "Argon2d is optimized for settings where the adversary does not get regular access to system memory or CPU, i.e., they cannot run side-channel attacks based on the timing information, nor can they recover the password much faster using garbage collection. These settings are more typical for backend servers and cryptocurrency minings. For practice, we suggest the following settings:",
      "ja": "ARGON2Dは、敵対者がシステムメモリまたはCPUに定期的にアクセスできない設定に最適化されています。つまり、タイミング情報に基づいてサイドチャネル攻撃を実行できず、ガベージコレクションを使用してパスワードをはるかに高速に回復できません。これらの設定は、バックエンドサーバーと暗号化されたマイナスにはより一般的です。練習用に、次の設定をお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Cryptocurrency mining, which takes 0.1 seconds on a 2 GHz CPU using 1 core -- Argon2d with 2 lanes and 250 MB of RAM.",
      "ja": "* CryptoCurrenceマイニング、これは2レーンと250 MBのRAMを備えた1つのコア-ARGON2Dを使用して2 GHzのCPUで0.1秒かかります。"
    },
    {
      "indent": 3,
      "text": "Argon2id is optimized for more realistic settings, where the adversary can possibly access the same machine, use its CPU, or mount cold-boot attacks. We suggest the following settings:",
      "ja": "Argon2IDは、敵対者が同じマシンにアクセスし、CPUを使用することができる、またはコールドブート攻撃をマウントすることができるより現実的な設定のために最適化されています。以下の設定をお勧めします。"
    },
    {
      "indent": 3,
      "text": "* Backend server authentication, which takes 0.5 seconds on a 2 GHz CPU using 4 cores -- Argon2id with 8 lanes and 4 GiB of RAM.",
      "ja": "* バックエンドサーバ認証.8レーンと4ギブのRAMを備えた4コア -  ARGON2IDを使用して、2 GHzのCPUで0.5秒かかります。"
    },
    {
      "indent": 3,
      "text": "* Key derivation for hard-drive encryption, which takes 3 seconds on a 2 GHz CPU using 2 cores -- Argon2id with 4 lanes and 6 GiB of RAM.",
      "ja": "* ハードドライブ暗号化のための鍵導出、4レーンと6ギブのRAMを持つ2つのコア -  Argon2idを使用して2 GHzのCPUで3秒かかります。"
    },
    {
      "indent": 3,
      "text": "* Frontend server authentication, which takes 0.5 seconds on a 2 GHz CPU using 2 cores -- Argon2id with 4 lanes and 1 GiB of RAM.",
      "ja": "* 4レーンと1 GiBのRAMの2つのコア -  Argon2idを使用して、2 GHzのCPUで0.5秒かかるフロントエンドサーバ認証。"
    },
    {
      "indent": 3,
      "text": "We recommend the following procedure to select the type and the parameters for practical use of Argon2.",
      "ja": "ARGON2の実用化のためのタイプとパラメータを選択するには、次の手順を推奨します。"
    },
    {
      "indent": 3,
      "text": "1. If a uniformly safe option that is not tailored to your application or hardware is acceptable, select Argon2id with t=1 iteration, p=4 lanes, m=2^(21) (2 GiB of RAM), 128-bit salt, and 256-bit tag size. This is the FIRST RECOMMENDED option.",
      "ja": "1. アプリケーションやハードウェアに合わせていない一様に安全なオプションが許容されている場合は、T = 1繰り返し、P = 4レーン、M = 2 ^（21）（2 GiBのRAM）、128ビット塩の順にargon2idを選択します。256ビットタグサイズ。これが最初の推奨オプションです。"
    },
    {
      "indent": 3,
      "text": "2. If much less memory is available, a uniformly safe option is Argon2id with t=3 iterations, p=4 lanes, m=2^(16) (64 MiB of RAM), 128-bit salt, and 256-bit tag size. This is the SECOND RECOMMENDED option.",
      "ja": "2. 利用可能なメモリがはるかに少ない場合、均一な安全なオプションは、T = 3反復、P = 4レーン、M = 2 ^（16）（RAMの64 MIB）、128ビットの塩、および256ビットのタグサイズであるArgon2IDです。これが2番目に推奨されているオプションです。"
    },
    {
      "indent": 3,
      "text": "3. Otherwise, start with selecting the type y. If you do not know the difference between the types or you consider side-channel attacks to be a viable threat, choose Argon2id.",
      "ja": "3. それ以外の場合は、タイプYを選択して始めます。タイプ間の違いがわからない場合、またはサイドチャネル攻撃を実行可能な脅威にすると考える場合は、Argon2IDを選択してください。"
    },
    {
      "indent": 3,
      "text": "4. Select p=4 lanes.",
      "ja": "4. P = 4車線を選択してください。"
    },
    {
      "indent": 3,
      "text": "5. Figure out the maximum amount of memory that each call can afford and translate it to the parameter m.",
      "ja": "5. 各コールがパラメータMに配置して変換できるメモリの最大量を把握してください。"
    },
    {
      "indent": 3,
      "text": "6. Figure out the maximum amount of time (in seconds) that each call can afford.",
      "ja": "6. 各コールが許される可能性がある最大時間（秒単位）を把握してください。"
    },
    {
      "indent": 3,
      "text": "7. Select the salt length. A length of 128 bits is sufficient for all applications but can be reduced to 64 bits in the case of space constraints.",
      "ja": "7. 塩の長さを選択してください。128ビットの長さはすべてのアプリケーションに十分ですが、スペースの制約の場合は64ビットに縮小できます。"
    },
    {
      "indent": 3,
      "text": "8. Select the tag length. A length of 128 bits is sufficient for most applications, including key derivation. If longer keys are needed, select longer tags.",
      "ja": "8. タグの長さを選択してください。キー導出を含むほとんどのアプリケーションには128ビットの長さが十分です。長いキーが必要な場合は、より長いタグを選択してください。"
    },
    {
      "indent": 3,
      "text": "9. If side-channel attacks are a viable threat or if you're uncertain, enable the memory-wiping option in the library call.",
      "ja": "9. サイドチャネル攻撃が実行可能な脅威である場合、または不確実な場合は、ライブラリ通話でメモリ拭き取りオプションを有効にします。"
    },
    {
      "indent": 3,
      "text": "10. Run the scheme of type y, memory m, and p lanes using a different number of passes t. Figure out the maximum t such that the running time does not exceed the affordable time. If it even exceeds for t = 1, reduce m accordingly.",
      "ja": "10. 異なる数のパスTを使用して、Y、メモリM、およびPレーンの方式を実行します。実行時間が手頃な時間を超えないように最大Tを把握してください。t = 1を超えると、それに応じてmを減らします。"
    },
    {
      "indent": 3,
      "text": "11. Use Argon2 with determined values m, p, and t.",
      "ja": "11. 決定された値M、P、およびTでArgon2を使用してください。"
    },
    {
      "indent": 0,
      "text": "5. Test Vectors",
      "section_title": true,
      "ja": "5. テストベクトル"
    },
    {
      "indent": 3,
      "text": "This section contains test vectors for Argon2.",
      "ja": "このセクションにはArgon2のテストベクトルが含まれています。"
    },
    {
      "indent": 0,
      "text": "5.1. Argon2d Test Vectors",
      "section_title": true,
      "ja": "5.1. Argon2Dテストベクトル"
    },
    {
      "indent": 3,
      "text": "We provide test vectors with complete outputs (tags). For the convenience of developers, we also provide some interim variables -- concretely, the first and last memory blocks of each pass.",
      "ja": "完全な出力（タグ）を使用してテストベクトルを提供します。開発者の利便性のために、私たちはまた、具体的には各パスの最初のメモリブロックを具体的に提供します。"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2d version number 19\n=======================================\nMemory: 32 KiB\nPasses: 3\nParallelism: 4 lanes\nTag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: b8 81 97 91 a0 35 96 60\n                    bb 77 09 c8 5f a4 8f 04\n                    d5 d8 2c 05 c5 f2 15 cc\n                    db 88 54 91 71 7c f7 57\n                    08 2c 28 b9 51 be 38 14\n                    10 b5 fc 2e b7 27 40 33\n                    b9 fd c7 ae 67 2b ca ac\n                    5d 17 90 97 a4 af 31 09",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " After pass 0: Block 0000 [ 0]: db2fea6b2c6f5c8a Block 0000 [ 1]: 719413be00f82634 Block 0000 [ 2]: a1e3f6dd42aa25cc Block 0000 [ 3]: 3ea8efd4d55ac0d1 ... Block 0031 [124]: 28d17914aea9734c Block 0031 [125]: 6a4622176522e398 Block 0031 [126]: 951aa08aeecb2c05 Block 0031 [127]: 6a6c49d2cb75d5b6",
      "ja": "パス0：ブロック0000 [0]：DB2FEA6B2C6F5C8Aブロック0000 [2]：3→3 = 3 = 3 = 3 = 3 = 3 = 3 = 3 = 3 = 3 = 3〕〔124〕：28D17914AEA9734Cブロック0031：6A46221765222J398ブロック0031 [126]：951AA08AEECB2C05ブロック0031 [127]：6A6C49D2CB75D5B6"
    },
    {
      "indent": 3,
      "text": " After pass 1: Block 0000 [ 0]: d3801200410f8c0d Block 0000 [ 1]: 0bf9e8a6e442ba6d Block 0000 [ 2]: e2ca92fe9c541fcc Block 0000 [ 3]: 6269fe6db177a388 ... Block 0031 [124]: 9eacfcfbdb3ce0fc Block 0031 [125]: 07dedaeb0aee71ac Block 0031 [126]: 074435fad91548f4 Block 0031 [127]: 2dbfff23f31b5883",
      "ja": "PASS 1：ブロック0000 [0]：D3801200410F8C0D BLOCK 0000 [2]：6269FE6DB177A388 ...ブロック0031 [124]：9ECFCFBDB3CE0FCブロック0031 [125]：07DEDAEB0AEE71ACブロック0031 [126]：074435FAD91548F4ブロック0031 [127]：2DBFFF23F31B5883"
    },
    {
      "indent": 3,
      "text": " After pass 2: Block 0000 [ 0]: 5f047b575c5ff4d2 Block 0000 [ 1]: f06985dbf11c91a8 Block 0000 [ 2]: 89efb2759f9a8964 Block 0000 [ 3]: 7486a73f62f9b142 ... Block 0031 [124]: 57cfb9d20479da49 Block 0031 [125]: 4099654bc6607f69 Block 0031 [126]: f142a1126075a5c8 Block 0031 [127]: c341b3ca45c10da5 Tag: 51 2b 39 1b 6f 11 62 97 53 71 d3 09 19 73 42 94 f8 68 e3 be 39 84 f3 c1 a1 3a 4d b9 fa be 4a cb",
      "ja": "PASS 2：BLOCK 0000 [0]：5F047B575C5F91A8ブロック0000 [2]：7486A73F9B142 ...ブロック0031 [124]：57CFB9D20479DA49ブロック0031 [125]：4099654BC6607F69ブロック0031 [126]：F142A1126075A5C8ブロック0031 [127]：C341B3CA45C10DA5タグ：51 2B 39 1B 6F 11 62 97 53 71 D3 09 19 73 42 94 F8 68 E3 Be 39 84 F3 C1 A1 3A 4D B9 FA BE 4A CB"
    },
    {
      "indent": 0,
      "text": "5.2. Argon2i Test Vectors",
      "section_title": true,
      "ja": "5.2. Argon2iテストベクトル"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2i version number 19\n=======================================\nMemory: 32 KiB\nPasses: 3\nParallelism: 4 lanes\nTag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\n              01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: c4 60 65 81 52 76 a0 b3\n                    e7 31 73 1c 90 2f 1f d8\n                    0c f7 76 90 7f bb 7b 6a\n                    5c a7 2e 7b 56 01 1f ee\n                    ca 44 6c 86 dd 75 b9 46\n                    9a 5e 68 79 de c4 b7 2d\n                    08 63 fb 93 9b 98 2e 5f\n                    39 7c c7 d1 64 fd da a9",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " After pass 0: Block 0000 [ 0]: f8f9e84545db08f6 Block 0000 [ 1]: 9b073a5c87aa2d97 Block 0000 [ 2]: d1e868d75ca8d8e4 Block 0000 [ 3]: 349634174e1aebcc ... Block 0031 [124]: 975f596583745e30 Block 0031 [125]: e349bdd7edeb3092 Block 0031 [126]: b751a689b7a83659 Block 0031 [127]: c570f2ab2a86cf00",
      "ja": "PASS 0：ブロック0000 [0]：9B073A5C8D8E4ブロック0000 [2]：975F596583745E30ブロック0031 [124]：975F596583745E30ブロック0031 [125]：E349BDD7EDEB3092ブロック0031 [126]：B751A689B7A83659ブロック0031 [127]：C570F2AB2A86CF00"
    },
    {
      "indent": 3,
      "text": " After pass 1: Block 0000 [ 0]: b2e4ddfcf76dc85a Block 0000 [ 1]: 4ffd0626c89a2327 Block 0000 [ 2]: 4af1440fff212980 Block 0000 [ 3]: 1e77299c7408505b ... Block 0031 [124]: e4274fd675d1e1d6 Block 0031 [125]: 903fffb7c4a14c98 Block 0031 [126]: 7e5db55def471966 Block 0031 [127]: 421b3c6e9555b79d",
      "ja": "PASS 1：ブロック0000 [0]：B2E4DDFCF76DC85Aブロック0000 [2]：4AF1440FFF212980ブロック0000 [3]：1E77299C7408505B ...ブロック0031 [124]：E4274FD675D1E1D6ブロック0031 [125]：903FFFB7C4A14C98ブロック0031 [126]：7E5DB55DEF471966ブロック0031 [127]：421B3C6E9555B79D"
    },
    {
      "indent": 3,
      "text": " After pass 2: Block 0000 [ 0]: af2a8bd8482c2f11 Block 0000 [ 1]: 785442294fa55e6d Block 0000 [ 2]: 9256a768529a7f96 Block 0000 [ 3]: 25a1c1f5bb953766 ... Block 0031 [124]: 68cf72fccc7112b9 Block 0031 [125]: 91e8c6f8bb0ad70d Block 0031 [126]: 4f59c8bd65cbb765 Block 0031 [127]: 71e436f035f30ed0 Tag: c8 14 d9 d1 dc 7f 37 aa 13 f0 d7 7f 24 94 bd a1 c8 de 6b 01 6d d3 88 d2 99 52 a4 c4 67 2b 6c e8",
      "ja": "PASS 2：BLOCK 0000 [0]：AF2A8BD8482C2F11ブロック0000 [2]：25A1C1F553766 ...ブロック0031 [124]：68CF72FCCC712B9ブロック0031 [125]：91E8C6F8B0AD70Dブロック0031 [126]：4F59C8BD65CBB765ブロック0031 [127]：71E436F035F30ED0タグ：C8 14 D9 D1 DC 7F 24 94 BD A1 C8 DE 6B 01 6D D3 88 D2 99 52 A4 C4 67 2B 6C E8"
    },
    {
      "indent": 0,
      "text": "5.3. Argon2id Test Vectors",
      "section_title": true,
      "ja": "5.3. Argon2idテストベクトル"
    },
    {
      "indent": 3,
      "text": "=======================================\nArgon2id version number 19\n=======================================\nMemory: 32 KiB, Passes: 3,\nParallelism: 4 lanes, Tag length: 32 bytes\nPassword[32]: 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01\n01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01\nSalt[16]: 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02 02\nSecret[8]: 03 03 03 03 03 03 03 03\nAssociated data[12]: 04 04 04 04 04 04 04 04 04 04 04 04\nPre-hashing digest: 28 89 de 48 7e b4 2a e5 00 c0 00 7e d9 25 2f\n 10 69 ea de c4 0d 57 65 b4 85 de 6d c2 43 7a 67 b8 54 6a 2f 0a\n cc 1a 08 82 db 8f cf 74 71 4b 47 2e 94 df 42 1a 5d a1 11 2f fa\n 11 43 43 70 a1 e9 97",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": " After pass 0: Block 0000 [ 0]: 6b2e09f10671bd43 Block 0000 [ 1]: f69f5c27918a21be Block 0000 [ 2]: dea7810ea41290e1 Block 0000 [ 3]: 6787f7171870f893 ... Block 0031 [124]: 377fa81666dc7f2b Block 0031 [125]: 50e586398a9c39c8 Block 0031 [126]: 6f732732a550924a Block 0031 [127]: 81f88b28683ea8e5",
      "ja": "PASS 0：F69F5C27918A21Bブロック0000 [2]：6787F7171870F893 ...ブロック0031 [124]：377FA81666DC7F2Bブロック0031 [125]：50E586398A9C39C8ブロックブロック0031 [127]：81F88B28683A8E5：6F732732A550924A：6F732732A550924A"
    },
    {
      "indent": 3,
      "text": " After pass 1: Block 0000 [ 0]: 3653ec9d01583df9 Block 0000 [ 1]: 69ef53a72d1e1fd3 Block 0000 [ 2]: 35635631744ab54f Block 0000 [ 3]: 599512e96a37ab6e ... Block 0031 [124]: 4d4b435cea35caa6 Block 0031 [125]: c582210d99ad1359 Block 0031 [126]: d087971b36fd6d77 Block 0031 [127]: a55222a93754c692",
      "ja": "PASS 1：ブロック0000 [0]：69EF53A72D1FD3ブロック0000 [2]：599512E37AB6E ...ブロック0031 [124]：4D4B435CEA35CA6ブロック0031 [125]：C582210D99AD1359ブロック0031 [126]：D087971B36FD6D77ブロック0031 [127]：A55222A93754C692"
    },
    {
      "indent": 3,
      "text": " After pass 2: Block 0000 [ 0]: 942363968ce597a4 Block 0000 [ 1]: a22448c0bdad5760 Block 0000 [ 2]: a5f80662b6fa8748 Block 0000 [ 3]: a0f9b9ce392f719f ... Block 0031 [124]: d723359b485f509b Block 0031 [125]: cb78824f42375111 Block 0031 [126]: 35bc8cc6e83b1875 Block 0031 [127]: 0b012846a40f346a Tag: 0d 64 0d f5 8d 78 76 6c 08 c0 37 a3 4a 8b 53 c9 d0 1e f0 45 2d 75 b6 5e b5 25 20 e9 6b 01 e6 59",
      "ja": "PASS 2：BLOCK 0000 [0]：942363968CE5760ブロック0000 [2]：A5F80662B6F748ブロック0000 [3]：A0F9B9CE392F719F ...ブロック0031 [124]：D723359B485F509Bブロック0031 [125]：CB78824F4237511ブロック0031 [126]：35BC8CC6E83B1875ブロック0031 [127]：0B012846A40F346Aタグ：0D 64 0D F5 8D 78 76 6C 08 C0 37 D0 1E F0 45 2D 75 B6 5E B5 25 20 E9 6B 01 E6 59"
    },
    {
      "indent": 0,
      "text": "6. IANA Considerations",
      "section_title": true,
      "ja": "6. IANAの考慮事項"
    },
    {
      "indent": 3,
      "text": "This document has no IANA actions.",
      "ja": "この文書にはIANAの行動がありません。"
    },
    {
      "indent": 0,
      "text": "7. Security Considerations",
      "section_title": true,
      "ja": "7. セキュリティに関する考慮事項"
    },
    {
      "indent": 0,
      "text": "7.1. Security as a Hash Function and KDF",
      "section_title": true,
      "ja": "7.1. ハッシュ関数とKDFとしてのセキュリティ"
    },
    {
      "indent": 3,
      "text": "The collision and preimage resistance levels of Argon2 are equivalent to those of the underlying BLAKE2b hash function. To produce a collision, 2^(256) inputs are needed. To find a preimage, 2^(512) inputs must be tried.",
      "ja": "アルゴン2の衝突およびプリーマージ抵抗レベルは、基礎となるBlake2Bハッシュ関数と同等である。衝突を生み出すには、2 ^（256）入力が必要です。プリ画像を見つけるには、2 ^（512）入力を試す必要があります。"
    },
    {
      "indent": 3,
      "text": "The KDF security is determined by the key length and the size of the internal state of hash function H'. To distinguish the output of the keyed Argon2 from random, a minimum of (2^(128),2^length(K)) calls to BLAKE2b are needed.",
      "ja": "KDFセキュリティは、キー長とハッシュ関数H 'の内部状態のサイズによって決まります。キー付きアルゴン2の出力をランダムに区別するために、Blake2bへの最小値（2 ^（128）、2 ^長さ（k））呼び出しが必要です。"
    },
    {
      "indent": 0,
      "text": "7.2. Security against Time-Space Trade-off Attacks",
      "section_title": true,
      "ja": "7.2. タイムスペーストレードオフ攻撃に対するセキュリティ"
    },
    {
      "indent": 3,
      "text": "Time-space trade-offs allow computing a memory-hard function storing fewer memory blocks at the cost of more calls to the internal compression function. The advantage of trade-off attacks is measured in the reduction factor to the time-area product, where memory and extra compression function cores contribute to the area and time is increased to accommodate the recomputation of missed blocks. A high reduction factor may potentially speed up the preimage search.",
      "ja": "タイムスペーストレードオフは、内部圧縮機能を超えるコストのコストで、より少ないメモリブロックを格納するメモリハード機能を計算することを可能にします。トレードオフ攻撃の利点は、メモリと余分な圧縮機能コアが面積と時間に寄与している時間領域製品への縮小要素で測定され、見逃したブロックの再計算に対応するために増加します。高い縮小要素は、プリ画像検索を潜在的に高速化する可能性があります。"
    },
    {
      "indent": 3,
      "text": "The best-known attack on the 1-pass and 2-pass Argon2i is the low-storage attack described in [CBS16], which reduces the time-area product (using the peak memory value) by the factor of 5. The best attack on Argon2i with 3 passes or more is described in [AB16], with the reduction factor being a function of memory size and the number of passes (e.g., for 1 gibibyte of memory, a reduction factor of 3 for 3 passes, 2.5 for 4 passes, 2 for 6 passes). The reduction factor grows by about 0.5 with every doubling of the memory size. To completely prevent time-space trade-offs from [AB16], the number of passes MUST exceed the binary logarithm of memory minus 26. Asymptotically, the best attack on 1-pass Argon2i is given in [BZ17], with maximal advantage of the adversary upper bounded by O(m^(0.233)), where m is the number of blocks. This attack is also asymptotically optimal as [BZ17] also proves the upper bound on any attack is O(m^(0.25)).",
      "ja": "1パスと2パスArgon2iに対する最もよく知られている攻撃は、[CBS16]で説明されている[CBS16]に記載されている低蓄積攻撃です。これは、時間領域製品（ピークメモリ値を使用して）5件目の攻撃です。3パス以上有するArgon2iに低減係数は、メモリサイズとメモリの1ギビバイト、3つのパス、42.53の縮小率のためのパス（例えば、数の関数であると、[AB16]に記載されていますパスを渡します。縮小率は、メモリサイズの倍増ごとに約0.5増加する。[AB16]からの時間空間トレードオフを完全に防ぐために、パス数はメモリマイナス26のバイナリ対数を超える必要があります。漸近的には、1パスARPON2Iの最良の攻撃は[BZ17]で最高の攻撃です。o（M ^（0.233））によって逆境があります。ここで、mはブロック数です。この攻撃はまた、[BZ17]も任意の攻撃の上限を証明しているので漸近的に最適である（M ^（0.25））。"
    },
    {
      "indent": 3,
      "text": "The best trade-off attack on t-pass Argon2d is the ranking trade-off attack, which reduces the time-area product by the factor of 1.33.",
      "ja": "T-PASS ARGON2Dに対する最良のトレードオフ攻撃はランキングのトレードオフ攻撃です。"
    },
    {
      "indent": 3,
      "text": "The best attack on Argon2id can be obtained by complementing the best attack on the 1-pass Argon2i with the best attack on a multi-pass Argon2d. Thus, the best trade-off attack on 1-pass Argon2id is the combined low-storage attack (for the first half of the memory) and the ranking attack (for the second half), which generate the factor of about 2.1. The best trade-off attack on t-pass Argon2id is the ranking trade-off attack, which reduces the time-area product by the factor of 1.33.",
      "ja": "Argon2IDに対する最良の攻撃は、マルチパスアルゴン2Dへの最良の攻撃を持つ1パスARGON2Iに最適な攻撃を補完することによって得ることができます。したがって、1パスARGON2IDでの最良のトレードオフ攻撃は、（メモリ上半期）とランキングの攻撃（後半）の組み合わせで、約2.1の要素を生成します。T-PASS ARGON2IDの最良のトレードオフ攻撃は、ランキングのトレードオフ攻撃で、時間面積の製品を1.33倍に減少させます。"
    },
    {
      "indent": 0,
      "text": "7.3. Security for Time-Bounded Defenders",
      "section_title": true,
      "ja": "7.3. 時限擁護者のためのセキュリティ"
    },
    {
      "indent": 3,
      "text": "A bottleneck in a system employing the password hashing function is often the function latency rather than memory costs. A rational defender would then maximize the brute-force costs for the attacker equipped with a list of hashes, salts, and timing information for fixed computing time on the defender's machine. The attack cost estimates from [AB16] imply that for Argon2i, 3 passes is almost optimal for most reasonable memory sizes; for Argon2d and Argon2id, 1 pass maximizes the attack costs for the constant defender time.",
      "ja": "パスワードハッシュ関数を使用するシステム内のボトルネックは、メモリコストではなく関数の待ち時間です。その後、Rational Defenderは、ディフェンダーのマシン上の固定コンピューティング時間のためのハッシュ、塩、およびタイミング情報のリストを備えた攻撃者のためのブルートフォースコストを最大化するでしょう。[AB16]からの攻撃コスト見積もりは、Argon2iの場合、3パスが最も合理的なメモリサイズにはほぼ最適です。Argon2DとArgon2IDの場合、1パスは定数の防御時間の攻撃コストを最大化します。"
    },
    {
      "indent": 0,
      "text": "7.4. Recommendations",
      "section_title": true,
      "ja": "7.4. 勧告"
    },
    {
      "indent": 3,
      "text": "The Argon2id variant with t=1 and 2 GiB memory is the FIRST RECOMMENDED option and is suggested as a default setting for all environments. This setting is secure against side-channel attacks and maximizes adversarial costs on dedicated brute-force hardware. The Argon2id variant with t=3 and 64 MiB memory is the SECOND RECOMMENDED option and is suggested as a default setting for memory-constrained environments.",
      "ja": "T = 1および2 GIBメモリを持つArgon2IDバリアントは、最初の推奨オプションであり、すべての環境のデフォルト設定として提案されています。この設定は、サイドチャネル攻撃に対して安全であり、専用のブルートフォースハードウェア上の敵対的コストを最大化します。T = 3と64 MIBメモリを持つArgon2IDバリアントは、2番目の推奨オプションです。メモリ制約付き環境のデフォルト設定として提案されています。"
    },
    {
      "indent": 0,
      "text": "8. References",
      "section_title": true,
      "ja": "8. 参考文献"
    },
    {
      "indent": 0,
      "text": "8.1. Normative References",
      "section_title": true,
      "ja": "8.1. 引用文献"
    },
    {
      "indent": 3,
      "text": "[BLAKE2] Saarinen, M-J., Ed. and J-P. Aumasson, \"The BLAKE2 Cryptographic Hash and Message Authentication Code (MAC)\", RFC 7693, DOI 10.17487/RFC7693, November 2015, <https://www.rfc-editor.org/info/rfc7693>.",
      "ja": "[Blake2] Saarinen、M-J。、ED。そしてJ-P。Aumasson、「Blake2暗号化ハッシュとメッセージ認証コード（Mac）」、RFC 7693、DOI 10.17487 / RFC7693、2015年11月、<https：//www.rfc-editor.org/info/rfc7693>。"
    },
    {
      "indent": 3,
      "text": "[RFC2119] Bradner, S., \"Key words for use in RFCs to Indicate Requirement Levels\", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997, <https://www.rfc-editor.org/info/rfc2119>.",
      "ja": "[RFC2119] BRADNER、S、「RFCSで使用するためのキーワード」、BCP 14、RFC 2119、DOI 10.17487 / RFC2119、1997年3月、<https：//www.rfc-editor.org/info/RFC2119>。"
    },
    {
      "indent": 3,
      "text": "[RFC8174] Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017, <https://www.rfc-editor.org/info/rfc8174>.",
      "ja": "[RFC8174] Leiba、B、「RFC 2119キーワードの大文字の曖昧さ」、BCP 14、RFC 8174、DOI 10.17487 / RFC8174、2017年5月、<https：//www.rfc-editor.org/info/RFC8174>。"
    },
    {
      "indent": 0,
      "text": "8.2. Informative References",
      "section_title": true,
      "ja": "8.2. 参考引用"
    },
    {
      "indent": 3,
      "text": "[AB15] Biryukov, A. and D. Khovratovich, \"Tradeoff Cryptanalysis of Memory-Hard Functions\", ASIACRYPT 2015, DOI 10.1007/978-3-662-48800-3_26, December 2015, <https://eprint.iacr.org/2015/227.pdf>.",
      "ja": "[AB15] Biryukov、A.およびD.Khovratovich、「メモリ - ハード機能のトレードオフクリプターシス」、Asiacrypt 2015、DOI 10.1007 / 978-3-662-48800-3_26、2015年12月、<https：//eprint.iacr。ORG / 2015 / 227.pdf>。"
    },
    {
      "indent": 3,
      "text": "[AB16] Alwen, J. and J. Blocki, \"Efficiently Computing Data-Independent Memory-Hard Functions\", CRYPTO 2016, DOI 10.1007/978-3-662-53008-5_9, March 2016, <https://eprint.iacr.org/2016/115.pdf>.",
      "ja": "[AB16] Alwen、J.およびJ.Blocki、「データ独立メモリハード機能を効率的に計算する」、Crypto 2016、DOI 10.1007 / 978-3-662-53008-5_9、2016年3月、<https：// eprint。iacr.org/2016/115.pdf>。"
    },
    {
      "indent": 3,
      "text": "[ARGON2] Biryukov, A., Dinu, D., and D. Khovratovich, \"Argon2: the memory-hard function for password hashing and other applications\", March 2017, <https://www.cryptolux.org/images/0/0d/Argon2.pdf>.",
      "ja": "[Argon2] Biryukov、A.、Dinu、D.、D.Khovratovich、 \"Argon2：パスワードハッシュおよびその他のアプリケーションのメモリハード機能\"、2017年3月、<https：//www.cryptolux.org/images/0 / 0D / ARGON2.PDF>。"
    },
    {
      "indent": 3,
      "text": "[ARGON2ESP] Biryukov, A., Dinu, D., and D. Khovratovich, \"Argon2: New Generation of Memory-Hard Functions for Password Hashing and Other Applications\", Euro SnP 2016, DOI 10.1109/EuroSP.2016.31, March 2016, <https://www.cryptolux.org/images/d/d0/Argon2ESP.pdf>.",
      "ja": "[Argon2esp] Biryukov、A.、Dinu、D.、D.Khovratovich、「Argon2：パスワードハッシュおよびその他のアプリケーションの新世代のメモリハード機能」、ユーロSNP 2016、DOI 10.1109 / Eurosp.2016.31、2016年3月、<https://www.cryptolux.org/images/d/d0/argon2esp.pdf>。"
    },
    {
      "indent": 3,
      "text": "[BZ17] Blocki, J. and S. Zhou, \"On the Depth-Robustness and Cumulative Pebbling Cost of Argon2i\", TCC 2017, DOI 10.1007/978-3-319-70500-2_15, May 2017, <https://eprint.iacr.org/2017/442.pdf>.",
      "ja": "[BZ17] BZ17、「Argon2iの奥深くに疎足費と累積恵みの費用について」、TCC 2017、DOI 10.1007 / 978-3-319-70500-2_15、2017年5月、<https：//eprint.iacr.org/2017/442.pdf>。"
    },
    {
      "indent": 3,
      "text": "[CBS16] Boneh, D., Corrigan-Gibbs, H., and S. Schechter, \"Balloon Hashing: A Memory-Hard Function Providing Provable Protection Against Sequential Attacks\", ASIACRYPT 2016, DOI 10.1007/978-3-662-53887-6_8, May 2017, <https://eprint.iacr.org/2016/027.pdf>.",
      "ja": "[CBS16] Boneh、D.、Corrigan-Gibbs、H.、およびS.Schechter、「Balloon Hashing：逐次攻撃に対する証明された保護を提供するメモリハード機能」、Asiacrypt 2016、DOI 10.1007 / 978-3-662-53887-6_8、2017年5月、<https：//eprint.iacr.org/2016/027.pdf>。"
    },
    {
      "indent": 3,
      "text": "[HARD] Alwen, J. and V. Serbinenko, \"High Parallel Complexity Graphs and Memory-Hard Functions\", STOC '15, DOI 10.1145/2746539.2746622, June 2015, <https://eprint.iacr.org/2014/238.pdf>.",
      "ja": "[ハード] Alwen、J.およびV.Serbinenko、「高並列複雑度グラフおよびメモリハード機能」、STOC '15、DOI 10.1145 / 2746539.2746622、<https://eprint.iacr.org/2014/238.pdf>。"
    },
    {
      "indent": 0,
      "text": "Acknowledgements",
      "ja": "謝辞"
    },
    {
      "indent": 3,
      "text": "We greatly thank the following individuals who helped in preparing and reviewing this document: Jean-Philippe Aumasson, Samuel Neves, Joel Alwen, Jeremiah Blocki, Bill Cox, Arnold Reinhold, Solar Designer, Russ Housley, Stanislav Smyshlyaev, Kenny Paterson, Alexey Melnikov, and Gwynne Raskind.",
      "ja": "この文書の準備と見直しに役立った次の個人には大変ありがとうございます。そしてGwynne Raskind。"
    },
    {
      "indent": 3,
      "text": "The work described in this document was done before Daniel Dinu joined Intel, while he was at the University of Luxembourg.",
      "ja": "この文書で説明されている作品は、Daniel DinuがIntelに加わる前に行われましたが、彼はルクセンブルク大学にいました。"
    },
    {
      "indent": 0,
      "text": "Authors' Addresses",
      "ja": "著者の住所"
    },
    {
      "indent": 3,
      "text": "Alex Biryukov University of Luxembourg",
      "ja": "ルクセンブルク大学アレックスビルイコフ大学"
    },
    {
      "indent": 3,
      "text": "Email: alex.biryukov@uni.lu",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Daniel Dinu University of Luxembourg",
      "ja": "Daniel Dinuルクセンブルク大学"
    },
    {
      "indent": 3,
      "text": "Email: daniel.dinu@intel.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Dmitry Khovratovich ABDK Consulting",
      "ja": "Dmitry Khovratovich ABDKコンサルティング"
    },
    {
      "indent": 3,
      "text": "Email: khovratovich@gmail.com",
      "raw": true,
      "ja": ""
    },
    {
      "indent": 3,
      "text": "Simon Josefsson SJD AB",
      "ja": "Simon Josefsson SJD AB."
    },
    {
      "indent": 3,
      "text": "Email: simon@josefsson.org\nURI:   http://josefsson.org/",
      "raw": true,
      "ja": ""
    }
  ]
}